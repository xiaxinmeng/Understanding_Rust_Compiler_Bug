{"sha": "e8636afab2f53d12da806f9e2a1670ad8e9e8323", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NjM2YWZhYjJmNTNkMTJkYTgwNmY5ZTJhMTY3MGFkOGU5ZTgzMjM=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-02-17T16:06:54Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-02-17T16:38:31Z"}, "message": "Add a reorder module", "tree": {"sha": "4980973d77448514ee472be043f24b6e800ede52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4980973d77448514ee472be043f24b6e800ede52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8636afab2f53d12da806f9e2a1670ad8e9e8323", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8636afab2f53d12da806f9e2a1670ad8e9e8323", "html_url": "https://github.com/rust-lang/rust/commit/e8636afab2f53d12da806f9e2a1670ad8e9e8323", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8636afab2f53d12da806f9e2a1670ad8e9e8323/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "197c3b4406f484f81ecbfef2548c842ac8e32a78", "url": "https://api.github.com/repos/rust-lang/rust/commits/197c3b4406f484f81ecbfef2548c842ac8e32a78", "html_url": "https://github.com/rust-lang/rust/commit/197c3b4406f484f81ecbfef2548c842ac8e32a78"}], "stats": {"total": 407, "additions": 221, "deletions": 186}, "files": [{"sha": "513bd20023388c911d33fcac30c72d63e95144b0", "filename": "rustfmt-core/src/imports.rs", "status": "modified", "additions": 9, "deletions": 186, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/e8636afab2f53d12da806f9e2a1670ad8e9e8323/rustfmt-core%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8636afab2f53d12da806f9e2a1670ad8e9e8323/rustfmt-core%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fimports.rs?ref=e8636afab2f53d12da806f9e2a1670ad8e9e8323", "patch": "@@ -15,132 +15,22 @@ use syntax::ast;\n use syntax::codemap::{BytePos, Span};\n \n use codemap::SpanUtils;\n-use comment::combine_strs_with_missing_comments;\n use config::IndentStyle;\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n+use reorder::rewrite_reorderable_items;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n use types::{rewrite_path, PathContext};\n use utils::{format_visibility, mk_sp};\n-use visitor::{rewrite_extern_crate, FmtVisitor};\n+use visitor::FmtVisitor;\n \n-fn compare_path_segments(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n-    a.identifier.name.as_str().cmp(&b.identifier.name.as_str())\n-}\n-\n-fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n-    for segment in a.segments.iter().zip(b.segments.iter()) {\n-        let ord = compare_path_segments(segment.0, segment.1);\n-        if ord != Ordering::Equal {\n-            return ord;\n-        }\n-    }\n-    a.segments.len().cmp(&b.segments.len())\n-}\n-\n-fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree, nested: bool) -> Ordering {\n-    use ast::UseTreeKind::*;\n-\n-    // `use_nested_groups` is not yet supported, remove the `if !nested` when support will be\n-    // fully added\n-    if !nested {\n-        let paths_cmp = compare_paths(&a.prefix, &b.prefix);\n-        if paths_cmp != Ordering::Equal {\n-            return paths_cmp;\n-        }\n-    }\n-\n-    match (&a.kind, &b.kind) {\n-        (&Simple(ident_a), &Simple(ident_b)) => {\n-            let name_a = &*path_to_imported_ident(&a.prefix).name.as_str();\n-            let name_b = &*path_to_imported_ident(&b.prefix).name.as_str();\n-            let name_ordering = if name_a == \"self\" {\n-                if name_b == \"self\" {\n-                    Ordering::Equal\n-                } else {\n-                    Ordering::Less\n-                }\n-            } else if name_b == \"self\" {\n-                Ordering::Greater\n-            } else {\n-                name_a.cmp(name_b)\n-            };\n-            if name_ordering == Ordering::Equal {\n-                if ident_a.name.as_str() != name_a {\n-                    if ident_b.name.as_str() != name_b {\n-                        ident_a.name.as_str().cmp(&ident_b.name.as_str())\n-                    } else {\n-                        Ordering::Greater\n-                    }\n-                } else {\n-                    Ordering::Less\n-                }\n-            } else {\n-                name_ordering\n-            }\n-        }\n-        (&Glob, &Glob) => Ordering::Equal,\n-        (&Simple(_), _) | (&Glob, &Nested(_)) => Ordering::Less,\n-        (&Nested(ref a_items), &Nested(ref b_items)) => {\n-            let mut a = a_items\n-                .iter()\n-                .map(|&(ref tree, _)| tree.clone())\n-                .collect::<Vec<_>>();\n-            let mut b = b_items\n-                .iter()\n-                .map(|&(ref tree, _)| tree.clone())\n-                .collect::<Vec<_>>();\n-            a.sort_by(|a, b| compare_use_trees(a, b, true));\n-            b.sort_by(|a, b| compare_use_trees(a, b, true));\n-            for comparison_pair in a.iter().zip(b.iter()) {\n-                let ord = compare_use_trees(comparison_pair.0, comparison_pair.1, true);\n-                if ord != Ordering::Equal {\n-                    return ord;\n-                }\n-            }\n-            a.len().cmp(&b.len())\n-        }\n-        (&Glob, &Simple(_)) | (&Nested(_), _) => Ordering::Greater,\n-    }\n-}\n-\n-fn compare_use_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n-    match (&a.node, &b.node) {\n-        (&ast::ItemKind::Mod(..), &ast::ItemKind::Mod(..)) => {\n-            a.ident.name.as_str().cmp(&b.ident.name.as_str())\n-        }\n-        (&ast::ItemKind::Use(ref a_tree), &ast::ItemKind::Use(ref b_tree)) => {\n-            compare_use_trees(a_tree, b_tree, false)\n-        }\n-        (&ast::ItemKind::ExternCrate(ref a_name), &ast::ItemKind::ExternCrate(ref b_name)) => {\n-            // `extern crate foo as bar;`\n-            //               ^^^ Comparing this.\n-            let a_orig_name =\n-                a_name.map_or_else(|| a.ident.name.as_str(), |symbol| symbol.as_str());\n-            let b_orig_name =\n-                b_name.map_or_else(|| b.ident.name.as_str(), |symbol| symbol.as_str());\n-            let result = a_orig_name.cmp(&b_orig_name);\n-            if result != Ordering::Equal {\n-                return result;\n-            }\n-\n-            // `extern crate foo as bar;`\n-            //                      ^^^ Comparing this.\n-            match (a_name, b_name) {\n-                (Some(..), None) => Ordering::Greater,\n-                (None, Some(..)) => Ordering::Less,\n-                (None, None) => Ordering::Equal,\n-                (Some(..), Some(..)) => a.ident.name.as_str().cmp(&b.ident.name.as_str()),\n-            }\n-        }\n-        _ => unreachable!(),\n-    }\n+/// Returns a name imported by a `use` declaration. e.g. returns `Ordering`\n+/// for `std::cmp::Ordering` and `self` for `std::cmp::self`.\n+pub fn path_to_imported_ident(path: &ast::Path) -> ast::Ident {\n+    path.segments.last().unwrap().identifier\n }\n \n-// TODO (some day) remove unused imports, expand globs, compress many single\n-// imports into a list import.\n-\n fn rewrite_prefix(path: &ast::Path, context: &RewriteContext, shape: Shape) -> Option<String> {\n     if path.segments.len() > 1 && path_to_imported_ident(path).to_string() == \"self\" {\n         let path = &ast::Path {\n@@ -208,7 +98,7 @@ fn is_unused_import_inner(tree: &ast::UseTree) -> bool {\n }\n \n // Rewrite `use foo;` WITHOUT attributes.\n-fn rewrite_import(\n+pub fn rewrite_import(\n     context: &RewriteContext,\n     vis: &ast::Visibility,\n     tree: &ast::UseTree,\n@@ -235,7 +125,7 @@ fn rewrite_import(\n }\n \n /// Rewrite an inline mod.\n-fn rewrite_mod(item: &ast::Item) -> String {\n+pub fn rewrite_mod(item: &ast::Item) -> String {\n     let mut result = String::with_capacity(32);\n     result.push_str(&*format_visibility(&item.vis));\n     result.push_str(\"mod \");\n@@ -244,69 +134,6 @@ fn rewrite_mod(item: &ast::Item) -> String {\n     result\n }\n \n-fn rewrite_imports(\n-    context: &RewriteContext,\n-    use_items: &[&ast::Item],\n-    shape: Shape,\n-    span: Span,\n-) -> Option<String> {\n-    let items = itemize_list(\n-        context.codemap,\n-        use_items.iter(),\n-        \"\",\n-        \";\",\n-        |item| item.span().lo(),\n-        |item| item.span().hi(),\n-        |item| {\n-            let attrs = ::visitor::filter_inline_attrs(&item.attrs, item.span());\n-            let attrs_str = attrs.rewrite(context, shape)?;\n-\n-            let missed_span = if attrs.is_empty() {\n-                mk_sp(item.span.lo(), item.span.lo())\n-            } else {\n-                mk_sp(attrs.last().unwrap().span.hi(), item.span.lo())\n-            };\n-\n-            let item_str = match item.node {\n-                ast::ItemKind::Use(ref tree) => {\n-                    rewrite_import(context, &item.vis, tree, &item.attrs, shape)?\n-                }\n-                ast::ItemKind::ExternCrate(..) => rewrite_extern_crate(context, item)?,\n-                ast::ItemKind::Mod(..) => rewrite_mod(item),\n-                _ => return None,\n-            };\n-\n-            combine_strs_with_missing_comments(\n-                context,\n-                &attrs_str,\n-                &item_str,\n-                missed_span,\n-                shape,\n-                false,\n-            )\n-        },\n-        span.lo(),\n-        span.hi(),\n-        false,\n-    );\n-    let mut item_pair_vec: Vec<_> = items.zip(use_items.iter()).collect();\n-    item_pair_vec.sort_by(|a, b| compare_use_items(a.1, b.1));\n-    let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n-\n-    let fmt = ListFormatting {\n-        tactic: DefinitiveListTactic::Vertical,\n-        separator: \"\",\n-        trailing_separator: SeparatorTactic::Never,\n-        separator_place: SeparatorPlace::Back,\n-        shape,\n-        ends_with_newline: true,\n-        preserve_newline: false,\n-        config: context.config,\n-    };\n-\n-    write_list(&item_vec, &fmt)\n-}\n-\n impl<'a> FmtVisitor<'a> {\n     pub fn format_imports(&mut self, use_items: &[&ast::Item]) {\n         if use_items.is_empty() {\n@@ -316,7 +143,7 @@ impl<'a> FmtVisitor<'a> {\n         let lo = use_items.first().unwrap().span().lo();\n         let hi = use_items.last().unwrap().span().hi();\n         let span = mk_sp(lo, hi);\n-        let rw = rewrite_imports(&self.get_context(), use_items, self.shape(), span);\n+        let rw = rewrite_reorderable_items(&self.get_context(), use_items, self.shape(), span);\n         self.push_rewrite(span, rw);\n     }\n \n@@ -594,7 +421,3 @@ fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n         None => false,\n     }\n }\n-\n-fn path_to_imported_ident(path: &ast::Path) -> ast::Ident {\n-    path.segments.last().unwrap().identifier\n-}"}, {"sha": "9d138a306880c82f5be3c6a44e7dd054b3cdca4d", "filename": "rustfmt-core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8636afab2f53d12da806f9e2a1670ad8e9e8323/rustfmt-core%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8636afab2f53d12da806f9e2a1670ad8e9e8323/rustfmt-core%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Flib.rs?ref=e8636afab2f53d12da806f9e2a1670ad8e9e8323", "patch": "@@ -52,6 +52,7 @@ pub use config::summary::Summary;\n \n #[macro_use]\n mod utils;\n+\n mod chains;\n mod checkstyle;\n mod closures;\n@@ -67,6 +68,7 @@ mod macros;\n mod missed_spans;\n pub mod modules;\n mod patterns;\n+mod reorder;\n mod rewrite;\n pub mod rustfmt_diff;\n mod shape;"}, {"sha": "df08f0662d48b486a2955c870acbfa77628f5e3f", "filename": "rustfmt-core/src/reorder.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/e8636afab2f53d12da806f9e2a1670ad8e9e8323/rustfmt-core%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8636afab2f53d12da806f9e2a1670ad8e9e8323/rustfmt-core%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Freorder.rs?ref=e8636afab2f53d12da806f9e2a1670ad8e9e8323", "patch": "@@ -0,0 +1,210 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Reorder items.\n+//!\n+//! `mod`, `extern crate` and `use` declarations are reorderd in alphabetical\n+//! order. Trait items are reordered in pre-determined order (associated types\n+//! and constatns comes before methods).\n+\n+use config::lists::*;\n+use syntax::{ast, codemap::Span};\n+\n+use comment::combine_strs_with_missing_comments;\n+use imports::{path_to_imported_ident, rewrite_import, rewrite_mod};\n+use lists::{itemize_list, write_list, ListFormatting};\n+use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n+use spanned::Spanned;\n+use utils::mk_sp;\n+use visitor::{filter_inline_attrs, rewrite_extern_crate};\n+\n+use std::cmp::Ordering;\n+\n+fn compare_path_segments(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n+    a.identifier.name.as_str().cmp(&b.identifier.name.as_str())\n+}\n+\n+fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n+    for segment in a.segments.iter().zip(b.segments.iter()) {\n+        let ord = compare_path_segments(segment.0, segment.1);\n+        if ord != Ordering::Equal {\n+            return ord;\n+        }\n+    }\n+    a.segments.len().cmp(&b.segments.len())\n+}\n+\n+fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree, nested: bool) -> Ordering {\n+    use ast::UseTreeKind::*;\n+\n+    // `use_nested_groups` is not yet supported, remove the `if !nested` when support will be\n+    // fully added\n+    if !nested {\n+        let paths_cmp = compare_paths(&a.prefix, &b.prefix);\n+        if paths_cmp != Ordering::Equal {\n+            return paths_cmp;\n+        }\n+    }\n+\n+    match (&a.kind, &b.kind) {\n+        (&Simple(ident_a), &Simple(ident_b)) => {\n+            let name_a = &*path_to_imported_ident(&a.prefix).name.as_str();\n+            let name_b = &*path_to_imported_ident(&b.prefix).name.as_str();\n+            let name_ordering = if name_a == \"self\" {\n+                if name_b == \"self\" {\n+                    Ordering::Equal\n+                } else {\n+                    Ordering::Less\n+                }\n+            } else if name_b == \"self\" {\n+                Ordering::Greater\n+            } else {\n+                name_a.cmp(name_b)\n+            };\n+            if name_ordering == Ordering::Equal {\n+                if ident_a.name.as_str() != name_a {\n+                    if ident_b.name.as_str() != name_b {\n+                        ident_a.name.as_str().cmp(&ident_b.name.as_str())\n+                    } else {\n+                        Ordering::Greater\n+                    }\n+                } else {\n+                    Ordering::Less\n+                }\n+            } else {\n+                name_ordering\n+            }\n+        }\n+        (&Glob, &Glob) => Ordering::Equal,\n+        (&Simple(_), _) | (&Glob, &Nested(_)) => Ordering::Less,\n+        (&Nested(ref a_items), &Nested(ref b_items)) => {\n+            let mut a = a_items\n+                .iter()\n+                .map(|&(ref tree, _)| tree.clone())\n+                .collect::<Vec<_>>();\n+            let mut b = b_items\n+                .iter()\n+                .map(|&(ref tree, _)| tree.clone())\n+                .collect::<Vec<_>>();\n+            a.sort_by(|a, b| compare_use_trees(a, b, true));\n+            b.sort_by(|a, b| compare_use_trees(a, b, true));\n+            for comparison_pair in a.iter().zip(b.iter()) {\n+                let ord = compare_use_trees(comparison_pair.0, comparison_pair.1, true);\n+                if ord != Ordering::Equal {\n+                    return ord;\n+                }\n+            }\n+            a.len().cmp(&b.len())\n+        }\n+        (&Glob, &Simple(_)) | (&Nested(_), _) => Ordering::Greater,\n+    }\n+}\n+\n+/// Choose the ordering between the given two items.\n+fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n+    match (&a.node, &b.node) {\n+        (&ast::ItemKind::Mod(..), &ast::ItemKind::Mod(..)) => {\n+            a.ident.name.as_str().cmp(&b.ident.name.as_str())\n+        }\n+        (&ast::ItemKind::Use(ref a_tree), &ast::ItemKind::Use(ref b_tree)) => {\n+            compare_use_trees(a_tree, b_tree, false)\n+        }\n+        (&ast::ItemKind::ExternCrate(ref a_name), &ast::ItemKind::ExternCrate(ref b_name)) => {\n+            // `extern crate foo as bar;`\n+            //               ^^^ Comparing this.\n+            let a_orig_name =\n+                a_name.map_or_else(|| a.ident.name.as_str(), |symbol| symbol.as_str());\n+            let b_orig_name =\n+                b_name.map_or_else(|| b.ident.name.as_str(), |symbol| symbol.as_str());\n+            let result = a_orig_name.cmp(&b_orig_name);\n+            if result != Ordering::Equal {\n+                return result;\n+            }\n+\n+            // `extern crate foo as bar;`\n+            //                      ^^^ Comparing this.\n+            match (a_name, b_name) {\n+                (Some(..), None) => Ordering::Greater,\n+                (None, Some(..)) => Ordering::Less,\n+                (None, None) => Ordering::Equal,\n+                (Some(..), Some(..)) => a.ident.name.as_str().cmp(&b.ident.name.as_str()),\n+            }\n+        }\n+        _ => unreachable!(),\n+    }\n+}\n+\n+/// Rewrite a list of items with reordering. Every item in `items` must have\n+/// the same `ast::ItemKind`.\n+// TODO (some day) remove unused imports, expand globs, compress many single\n+// imports into a list import.\n+pub fn rewrite_reorderable_items(\n+    context: &RewriteContext,\n+    reorderable_items: &[&ast::Item],\n+    shape: Shape,\n+    span: Span,\n+) -> Option<String> {\n+    let items = itemize_list(\n+        context.codemap,\n+        reorderable_items.iter(),\n+        \"\",\n+        \";\",\n+        |item| item.span().lo(),\n+        |item| item.span().hi(),\n+        |item| {\n+            let attrs = filter_inline_attrs(&item.attrs, item.span());\n+            let attrs_str = attrs.rewrite(context, shape)?;\n+\n+            let missed_span = if attrs.is_empty() {\n+                mk_sp(item.span.lo(), item.span.lo())\n+            } else {\n+                mk_sp(attrs.last().unwrap().span.hi(), item.span.lo())\n+            };\n+\n+            let item_str = match item.node {\n+                ast::ItemKind::Use(ref tree) => {\n+                    rewrite_import(context, &item.vis, tree, &item.attrs, shape)?\n+                }\n+                ast::ItemKind::ExternCrate(..) => rewrite_extern_crate(context, item)?,\n+                ast::ItemKind::Mod(..) => rewrite_mod(item),\n+                _ => return None,\n+            };\n+\n+            combine_strs_with_missing_comments(\n+                context,\n+                &attrs_str,\n+                &item_str,\n+                missed_span,\n+                shape,\n+                false,\n+            )\n+        },\n+        span.lo(),\n+        span.hi(),\n+        false,\n+    );\n+    let mut item_pair_vec: Vec<_> = items.zip(reorderable_items.iter()).collect();\n+    item_pair_vec.sort_by(|a, b| compare_items(a.1, b.1));\n+    let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n+\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        separator: \"\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n+        shape,\n+        ends_with_newline: true,\n+        preserve_newline: false,\n+        config: context.config,\n+    };\n+\n+    write_list(&item_vec, &fmt)\n+}"}]}