{"sha": "f3fc94f2399e8244bb78af8e0e5f462b884083ac", "node_id": "C_kwDOAAsO6NoAKGYzZmM5NGYyMzk5ZTgyNDRiYjc4YWY4ZTBlNWY0NjJiODg0MDgzYWM", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-04-30T13:01:57Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-04-30T13:01:57Z"}, "message": "Fix #[track_caller] with MIR inlining", "tree": {"sha": "eece9ec6947138017e3563084df181f0005b0a5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eece9ec6947138017e3563084df181f0005b0a5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3fc94f2399e8244bb78af8e0e5f462b884083ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fc94f2399e8244bb78af8e0e5f462b884083ac", "html_url": "https://github.com/rust-lang/rust/commit/f3fc94f2399e8244bb78af8e0e5f462b884083ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3fc94f2399e8244bb78af8e0e5f462b884083ac/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f449c0d1756ad2b72240c1961d7d18fc11faba9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f449c0d1756ad2b72240c1961d7d18fc11faba9b", "html_url": "https://github.com/rust-lang/rust/commit/f449c0d1756ad2b72240c1961d7d18fc11faba9b"}], "stats": {"total": 156, "additions": 95, "deletions": 61}, "files": [{"sha": "9bdb9f22c549a56d34850f97cbf2461a0d83585d", "filename": "scripts/test_rustc_tests.sh", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc94f2399e8244bb78af8e0e5f462b884083ac/scripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc94f2399e8244bb78af8e0e5f462b884083ac/scripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftest_rustc_tests.sh?ref=f3fc94f2399e8244bb78af8e0e5f462b884083ac", "patch": "@@ -105,8 +105,6 @@ rm src/test/ui/type-alias-impl-trait/assoc-projection-ice.rs # produces ICE\n \n rm src/test/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n-rm src/test/ui/rfc-2091-track-caller/intrinsic-wrapper.rs # wrong result from `Location::caller()`\n-\n # bugs in the test suite\n # ======================\n rm src/test/ui/backtrace.rs # TODO warning"}, {"sha": "b163a42619172d2739142d1f689a821ab8fcb3e1", "filename": "src/abi/mod.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc94f2399e8244bb78af8e0e5f462b884083ac/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc94f2399e8244bb78af8e0e5f462b884083ac/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=f3fc94f2399e8244bb78af8e0e5f462b884083ac", "patch": "@@ -309,7 +309,7 @@ fn codegen_call_argument_operand<'tcx>(\n \n pub(crate) fn codegen_terminator_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    span: Span,\n+    source_info: mir::SourceInfo,\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n     mir_dest: Option<(Place<'tcx>, BasicBlock)>,\n@@ -340,7 +340,13 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n         match instance.def {\n             InstanceDef::Intrinsic(_) => {\n-                crate::intrinsics::codegen_intrinsic_call(fx, instance, args, destination, span);\n+                crate::intrinsics::codegen_intrinsic_call(\n+                    fx,\n+                    instance,\n+                    args,\n+                    destination,\n+                    source_info,\n+                );\n                 return;\n             }\n             InstanceDef::DropGlue(_, None) => {\n@@ -402,7 +408,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     // Pass the caller location for `#[track_caller]`.\n     if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n-        let caller_location = fx.get_caller_location(span);\n+        let caller_location = fx.get_caller_location(source_info);\n         args.push(CallArgument { value: caller_location, is_owned: false });\n     }\n \n@@ -479,9 +485,10 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         // FIXME find a cleaner way to support varargs\n         if fn_sig.c_variadic {\n             if !matches!(fn_sig.abi, Abi::C { .. }) {\n-                fx.tcx\n-                    .sess\n-                    .span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n+                fx.tcx.sess.span_fatal(\n+                    source_info.span,\n+                    &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n+                );\n             }\n             let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n             let abi_params = call_args\n@@ -490,9 +497,10 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                     let ty = fx.bcx.func.dfg.value_type(arg);\n                     if !ty.is_int() {\n                         // FIXME set %al to upperbound on float args once floats are supported\n-                        fx.tcx\n-                            .sess\n-                            .span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                        fx.tcx.sess.span_fatal(\n+                            source_info.span,\n+                            &format!(\"Non int ty {:?} for variadic call\", ty),\n+                        );\n                     }\n                     AbiParam::new(ty)\n                 })\n@@ -513,7 +521,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n pub(crate) fn codegen_drop<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    span: Span,\n+    source_info: mir::SourceInfo,\n     drop_place: CPlace<'tcx>,\n ) {\n     let ty = drop_place.layout().ty;\n@@ -560,7 +568,7 @@ pub(crate) fn codegen_drop<'tcx>(\n \n                 if drop_instance.def.requires_caller_location(fx.tcx) {\n                     // Pass the caller location for `#[track_caller]`.\n-                    let caller_location = fx.get_caller_location(span);\n+                    let caller_location = fx.get_caller_location(source_info);\n                     call_args.extend(\n                         adjust_arg_for_abi(fx, caller_location, &fn_abi.args[1], false).into_iter(),\n                     );"}, {"sha": "e59998e4dfa4f7c5eadb56eac528bd0f75119f91", "filename": "src/base.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc94f2399e8244bb78af8e0e5f462b884083ac/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc94f2399e8244bb78af8e0e5f462b884083ac/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=f3fc94f2399e8244bb78af8e0e5f462b884083ac", "patch": "@@ -325,7 +325,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                     AssertKind::BoundsCheck { ref len, ref index } => {\n                         let len = codegen_operand(fx, len).load_scalar(fx);\n                         let index = codegen_operand(fx, index).load_scalar(fx);\n-                        let location = fx.get_caller_location(source_info.span).load_scalar(fx);\n+                        let location = fx.get_caller_location(source_info).load_scalar(fx);\n \n                         codegen_panic_inner(\n                             fx,\n@@ -336,7 +336,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                     }\n                     _ => {\n                         let msg_str = msg.description();\n-                        codegen_panic(fx, msg_str, source_info.span);\n+                        codegen_panic(fx, msg_str, source_info);\n                     }\n                 }\n             }\n@@ -393,12 +393,12 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                 func,\n                 args,\n                 destination,\n-                fn_span,\n+                fn_span: _,\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n                 fx.tcx.sess.time(\"codegen call\", || {\n-                    crate::abi::codegen_terminator_call(fx, *fn_span, func, args, *destination)\n+                    crate::abi::codegen_terminator_call(fx, source_info, func, args, *destination)\n                 });\n             }\n             TerminatorKind::InlineAsm {\n@@ -450,7 +450,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n             }\n             TerminatorKind::Drop { place, target, unwind: _ } => {\n                 let drop_place = codegen_place(fx, *place);\n-                crate::abi::codegen_drop(fx, source_info.span, drop_place);\n+                crate::abi::codegen_drop(fx, source_info, drop_place);\n \n                 let target_block = fx.get_block(*target);\n                 fx.bcx.ins().jump(target_block, &[]);\n@@ -898,14 +898,18 @@ pub(crate) fn codegen_operand<'tcx>(\n     }\n }\n \n-pub(crate) fn codegen_panic<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, msg_str: &str, span: Span) {\n-    let location = fx.get_caller_location(span).load_scalar(fx);\n+pub(crate) fn codegen_panic<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    msg_str: &str,\n+    source_info: mir::SourceInfo,\n+) {\n+    let location = fx.get_caller_location(source_info).load_scalar(fx);\n \n     let msg_ptr = fx.anonymous_str(msg_str);\n     let msg_len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n     let args = [msg_ptr, msg_len, location];\n \n-    codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, span);\n+    codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, source_info.span);\n }\n \n pub(crate) fn codegen_panic_inner<'tcx>("}, {"sha": "f9dc1b5169e1a624c35949691a5a8f0f6f0e6f8c", "filename": "src/common.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc94f2399e8244bb78af8e0e5f462b884083ac/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc94f2399e8244bb78af8e0e5f462b884083ac/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=f3fc94f2399e8244bb78af8e0e5f462b884083ac", "patch": "@@ -340,22 +340,46 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         self.bcx.set_srcloc(SourceLoc::new(index as u32));\n     }\n \n-    pub(crate) fn get_caller_location(&mut self, span: Span) -> CValue<'tcx> {\n-        if let Some(loc) = self.caller_location {\n-            // `#[track_caller]` is used; return caller location instead of current location.\n-            return loc;\n+    // Note: must be kept in sync with get_caller_location from cg_ssa\n+    pub(crate) fn get_caller_location(&mut self, mut source_info: mir::SourceInfo) -> CValue<'tcx> {\n+        let span_to_caller_location = |fx: &mut FunctionCx<'_, '_, 'tcx>, span: Span| {\n+            let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n+            let caller = fx.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n+            let const_loc = fx.tcx.const_caller_location((\n+                rustc_span::symbol::Symbol::intern(\n+                    &caller.file.name.prefer_remapped().to_string_lossy(),\n+                ),\n+                caller.line as u32,\n+                caller.col_display as u32 + 1,\n+            ));\n+            crate::constant::codegen_const_value(fx, const_loc, fx.tcx.caller_location_ty())\n+        };\n+\n+        // Walk up the `SourceScope`s, in case some of them are from MIR inlining.\n+        // If so, the starting `source_info.span` is in the innermost inlined\n+        // function, and will be replaced with outer callsite spans as long\n+        // as the inlined functions were `#[track_caller]`.\n+        loop {\n+            let scope_data = &self.mir.source_scopes[source_info.scope];\n+\n+            if let Some((callee, callsite_span)) = scope_data.inlined {\n+                // Stop inside the most nested non-`#[track_caller]` function,\n+                // before ever reaching its caller (which is irrelevant).\n+                if !callee.def.requires_caller_location(self.tcx) {\n+                    return span_to_caller_location(self, source_info.span);\n+                }\n+                source_info.span = callsite_span;\n+            }\n+\n+            // Skip past all of the parents with `inlined: None`.\n+            match scope_data.inlined_parent_scope {\n+                Some(parent) => source_info.scope = parent,\n+                None => break,\n+            }\n         }\n \n-        let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n-        let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n-        let const_loc = self.tcx.const_caller_location((\n-            rustc_span::symbol::Symbol::intern(\n-                &caller.file.name.prefer_remapped().to_string_lossy(),\n-            ),\n-            caller.line as u32,\n-            caller.col_display as u32 + 1,\n-        ));\n-        crate::constant::codegen_const_value(self, const_loc, self.tcx.caller_location_ty())\n+        // No inlined `SourceScope`s, or all of them were `#[track_caller]`.\n+        self.caller_location.unwrap_or_else(|| span_to_caller_location(self, source_info.span))\n     }\n \n     pub(crate) fn anonymous_str(&mut self, msg: &str) -> Value {"}, {"sha": "0468a051bcdc5cffd16134e97535f844a86435ba", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc94f2399e8244bb78af8e0e5f462b884083ac/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc94f2399e8244bb78af8e0e5f462b884083ac/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=f3fc94f2399e8244bb78af8e0e5f462b884083ac", "patch": "@@ -218,7 +218,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n-    span: Span,\n+    source_info: mir::SourceInfo,\n ) {\n     let intrinsic = fx.tcx.item_name(instance.def_id());\n     let substs = instance.substs;\n@@ -232,7 +232,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                     fx.bcx.ins().trap(TrapCode::User(0));\n                 }\n                 sym::transmute => {\n-                    crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", span);\n+                    crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n                 }\n                 _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n             }\n@@ -241,7 +241,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     };\n \n     if intrinsic.as_str().starts_with(\"simd_\") {\n-        self::simd::codegen_simd_intrinsic_call(fx, intrinsic, substs, args, ret, span);\n+        self::simd::codegen_simd_intrinsic_call(fx, intrinsic, substs, args, ret, source_info.span);\n         let ret_block = fx.get_block(destination.expect(\"SIMD intrinsics don't diverge\").1);\n         fx.bcx.ins().jump(ret_block, &[]);\n     } else if codegen_float_intrinsic_call(fx, intrinsic, args, ret) {\n@@ -255,7 +255,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             substs,\n             args,\n             ret,\n-            span,\n+            source_info,\n             destination,\n         );\n     }\n@@ -339,15 +339,15 @@ fn codegen_regular_intrinsic_call<'tcx>(\n     substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n-    span: Span,\n+    source_info: mir::SourceInfo,\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n ) {\n     let usize_layout = fx.layout_of(fx.tcx.types.usize);\n \n     intrinsic_match! {\n         fx, intrinsic, args,\n         _ => {\n-            fx.tcx.sess.span_fatal(span, &format!(\"unsupported intrinsic {}\", intrinsic));\n+            fx.tcx.sess.span_fatal(source_info.span, &format!(\"unsupported intrinsic {}\", intrinsic));\n         };\n \n         assume, (c _a) {};\n@@ -658,7 +658,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     crate::base::codegen_panic(\n                         fx,\n                         &format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty),\n-                        span,\n+                        source_info,\n                     )\n                 });\n                 return;\n@@ -669,7 +669,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     crate::base::codegen_panic(\n                         fx,\n                         &format!(\"attempted to zero-initialize type `{}`, which is invalid\", layout.ty),\n-                        span,\n+                        source_info,\n                     );\n                 });\n                 return;\n@@ -680,7 +680,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     crate::base::codegen_panic(\n                         fx,\n                         &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", layout.ty),\n-                        span,\n+                        source_info,\n                     )\n                 });\n                 return;\n@@ -735,7 +735,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n \n         caller_location, () {\n-            let caller_location = fx.get_caller_location(span);\n+            let caller_location = fx.get_caller_location(source_info);\n             ret.write_cvalue(fx, caller_location);\n         };\n \n@@ -758,12 +758,12 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                         fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n-                        fx.tcx.sess.span_fatal(span, \"128bit atomics not yet supported\");\n+                        fx.tcx.sess.span_fatal(source_info.span, \"128bit atomics not yet supported\");\n                     }\n                 }\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, ty);\n                     return;\n                 }\n             }\n@@ -786,12 +786,12 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                         fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n-                        fx.tcx.sess.span_fatal(span, \"128bit atomics not yet supported\");\n+                        fx.tcx.sess.span_fatal(source_info.span, \"128bit atomics not yet supported\");\n                     }\n                 }\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, ty);\n                     return;\n                 }\n             }\n@@ -805,7 +805,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -823,7 +823,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -843,7 +843,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -861,7 +861,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -879,7 +879,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -897,7 +897,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -915,7 +915,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -933,7 +933,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -951,7 +951,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -969,7 +969,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -987,7 +987,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }\n@@ -1005,7 +1005,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             match layout.ty.kind() {\n                 ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n                 _ => {\n-                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    report_atomic_type_validation_error(fx, intrinsic, source_info.span, layout.ty);\n                     return;\n                 }\n             }"}]}