{"sha": "aa3b89610e081b3b58a3d4acb5201c0d6ea200c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhM2I4OTYxMGUwODFiM2I1OGEzZDRhY2I1MjAxYzBkNmVhMjAwYzY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-29T16:26:50Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-29T18:54:44Z"}, "message": "Track failures in typeck, assign proper type to failing blocks\n\n(and warn for unreachable statements)\n\nCloses #727", "tree": {"sha": "abaa4757900fb43e5c40d709b46fa5f4247f6a36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abaa4757900fb43e5c40d709b46fa5f4247f6a36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa3b89610e081b3b58a3d4acb5201c0d6ea200c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3b89610e081b3b58a3d4acb5201c0d6ea200c6", "html_url": "https://github.com/rust-lang/rust/commit/aa3b89610e081b3b58a3d4acb5201c0d6ea200c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa3b89610e081b3b58a3d4acb5201c0d6ea200c6/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9705f97ead1bdb5863e82a31c315113efd9c1c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/9705f97ead1bdb5863e82a31c315113efd9c1c68", "html_url": "https://github.com/rust-lang/rust/commit/9705f97ead1bdb5863e82a31c315113efd9c1c68"}], "stats": {"total": 218, "additions": 127, "deletions": 91}, "files": [{"sha": "4398d3a606335854ce01e8c7bd88a37bb693a33a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 126, "deletions": 90, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/aa3b89610e081b3b58a3d4acb5201c0d6ea200c6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3b89610e081b3b58a3d4acb5201c0d6ea200c6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=aa3b89610e081b3b58a3d4acb5201c0d6ea200c6", "patch": "@@ -186,7 +186,6 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                         \"this item does not take type \\\n                                       parameters\");\n-            fail;\n         }\n     } else {\n         // We will acquire the type parameters through unification.\n@@ -1516,17 +1515,17 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: &ast::purity,\n     }\n }\n \n-fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n+fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n     // fcx.ccx.tcx.sess.span_warn(expr.span, \"typechecking expr \" +\n     //                            syntax::print::pprust::expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n                           args: &(option::t[@ast::expr])[],\n-                          call_kind: call_kind) {\n+                          call_kind: call_kind) -> bool {\n         // Check the function.\n-        check_expr(fcx, f);\n+        let bot = check_expr(fcx, f);\n \n         // Get the function type.\n         let fty = expr_ty(fcx.ccx.tcx, f);\n@@ -1541,7 +1540,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         // Grab the argument types and the return type.\n         let arg_tys;\n         alt structure_of(fcx, sp, fty_stripped) {\n-          ty::ty_fn(_, arg_tys_0, _, _, _) { arg_tys = arg_tys_0; }\n+          ty::ty_fn(_, arg_tys_0, _, _, _) |\n           ty::ty_native_fn(_, arg_tys_0, _) { arg_tys = arg_tys_0; }\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(f.span,\n@@ -1576,7 +1575,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         for a_opt: option::t[@ast::expr]  in args {\n             alt a_opt {\n               some(a) {\n-                check_expr(fcx, a);\n+                bot |= check_expr(fcx, a);\n                 demand::full(fcx, a.span, arg_tys.(i).ty,\n                              expr_ty(fcx.ccx.tcx, a), ~[],\n                              AUTODEREF_BLOCK_COERCE);\n@@ -1585,47 +1584,49 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n             }\n             i += 1u;\n         }\n+        ret bot;\n     }\n     // A generic function for checking assignment expressions\n \n     fn check_assignment(fcx: &@fn_ctxt, sp: &span, lhs: &@ast::expr,\n-                        rhs: &@ast::expr, id: &ast::node_id) {\n-        check_expr(fcx, lhs);\n-        check_expr(fcx, rhs);\n+                        rhs: &@ast::expr, id: &ast::node_id) -> bool {\n+        let bot = check_expr(fcx, lhs) | check_expr(fcx, rhs);\n         demand::simple(fcx, sp, expr_ty(fcx.ccx.tcx, lhs),\n                        expr_ty(fcx.ccx.tcx, rhs));\n         write::ty_only_fixup(fcx, id, ty::mk_nil(fcx.ccx.tcx));\n+        ret bot;\n     }\n     // A generic function for checking call expressions\n \n     fn check_call(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n-                  args: &(@ast::expr)[], call_kind: call_kind) {\n+                  args: &(@ast::expr)[], call_kind: call_kind) -> bool {\n         let args_opt_0: (option::t[@ast::expr])[] = ~[];\n         for arg: @ast::expr  in args {\n             args_opt_0 += ~[some[@ast::expr](arg)];\n         }\n \n         // Call the generic checker.\n-        check_call_or_bind(fcx, sp, f, args_opt_0, call_kind);\n+        ret check_call_or_bind(fcx, sp, f, args_opt_0, call_kind);\n     }\n     // A generic function for checking for or for-each loops\n \n     fn check_for_or_for_each(fcx: &@fn_ctxt, local: &@ast::local,\n-                             element_ty: &ty::t, body: &ast::blk,\n-                             node_id: ast::node_id) {\n-        check_decl_local(fcx, local);\n+                                 element_ty: &ty::t, body: &ast::blk,\n+                                 node_id: ast::node_id) -> bool {\n+        let bot = check_decl_local(fcx, local);\n         check_block(fcx, body);\n         // Unify type of decl with element type of the seq\n         demand::simple(fcx, local.span, ty::decl_local_ty(fcx.ccx.tcx, local),\n                        element_ty);\n         let typ = ty::mk_nil(fcx.ccx.tcx);\n         write::ty_only_fixup(fcx, node_id, typ);\n+        ret bot;\n     }\n \n     // A generic function for checking the pred in a check\n     // or if-check\n-    fn check_pred_expr(fcx: &@fn_ctxt, e: &@ast::expr) {\n-        check_expr(fcx, e);\n+    fn check_pred_expr(fcx: &@fn_ctxt, e: &@ast::expr) -> bool {\n+        let bot = check_expr(fcx, e);\n         demand::simple(fcx, e.span, ty::mk_bool(fcx.ccx.tcx),\n                        expr_ty(fcx.ccx.tcx, e));\n \n@@ -1665,18 +1666,20 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n           }\n           _ { fcx.ccx.tcx.sess.span_fatal(e.span, \"check on non-predicate\"); }\n         }\n+        ret bot;\n     }\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: &@fn_ctxt, thn: &ast::blk,\n                        elsopt: &option::t[@ast::expr], id: ast::node_id,\n-                       sp: &span) {\n-        check_block(fcx, thn);\n+                       sp: &span) -> bool {\n+        let then_bot = check_block(fcx, thn);\n+        let els_bot = false;\n         let if_t =\n             alt elsopt {\n               some(els) {\n-                check_expr(fcx, els);\n+                els_bot = check_expr(fcx, els);\n                 let thn_t = block_ty(fcx.ccx.tcx, thn);\n                 let elsopt_t = expr_ty(fcx.ccx.tcx, els);\n                 demand::simple(fcx, sp, thn_t, elsopt_t);\n@@ -1687,6 +1690,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n               none. { ty::mk_nil(fcx.ccx.tcx) }\n             };\n         write::ty_only_fixup(fcx, id, if_t);\n+        ret then_bot & els_bot;\n     }\n \n     // Checks the compatibility\n@@ -1704,14 +1708,19 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n     }\n \n     let id = expr.id;\n+    let bot = false;\n     alt expr.node {\n       ast::expr_lit(lit) {\n         let typ = check_lit(fcx.ccx, lit);\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_binary(binop, lhs, rhs) {\n-        check_expr(fcx, lhs);\n-        check_expr(fcx, rhs);\n+        bot = check_expr(fcx, lhs);\n+        if ast::lazy_binop(binop) {\n+            check_expr(fcx, rhs);\n+        } else {\n+            bot |= check_expr(fcx, rhs);\n+        }\n \n         let lhs_t = expr_ty(fcx.ccx.tcx, lhs);\n         let rhs_t = expr_ty(fcx.ccx.tcx, rhs);\n@@ -1733,7 +1742,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         write::ty_only_fixup(fcx, id, t);\n       }\n       ast::expr_unary(unop, oper) {\n-        check_expr(fcx, oper);\n+        bot = check_expr(fcx, oper);\n         let oper_t = expr_ty(fcx.ccx.tcx, oper);\n         alt unop {\n           ast::box(mut) {\n@@ -1787,7 +1796,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         if ty::def_has_ty_params(defn) {\n             let path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n             write::ty_fixup(fcx, id, path_tpot);\n-            ret;\n+            ret false;\n         }\n         // The definition doesn't take type parameters. If the programmer\n         // supplied some, that's an error.\n@@ -1801,6 +1810,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n       }\n       ast::expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       ast::expr_fail(expr_opt) {\n+        bot = true;\n         alt expr_opt {\n           none. {/* do nothing */ }\n           some(e) {\n@@ -1812,9 +1822,10 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         }\n         write::bot_ty(fcx.ccx.tcx, id);\n       }\n-      ast::expr_break. { write::bot_ty(fcx.ccx.tcx, id); }\n-      ast::expr_cont. { write::bot_ty(fcx.ccx.tcx, id); }\n+      ast::expr_break. { write::bot_ty(fcx.ccx.tcx, id); bot = true; }\n+      ast::expr_cont. { write::bot_ty(fcx.ccx.tcx, id); bot = true; }\n       ast::expr_ret(expr_opt) {\n+        bot = true;\n         alt expr_opt {\n           none. {\n             let nil = ty::mk_nil(fcx.ccx.tcx);\n@@ -1846,7 +1857,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n             write::nil_ty(fcx.ccx.tcx, id);\n           }\n           some(e) {\n-            check_expr(fcx, e);\n+            bot = check_expr(fcx, e);\n             demand::simple(fcx, expr.span, fcx.ret_ty,\n                            expr_ty(fcx.ccx.tcx, e));\n             write::nil_ty(fcx.ccx.tcx, id);\n@@ -1855,55 +1866,54 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n       }\n       ast::expr_be(e) {\n         // FIXME: prove instead of assert\n-\n         assert (ast::is_call_expr(e));\n         check_expr(fcx, e);\n+        bot = true;\n         demand::simple(fcx, e.span, fcx.ret_ty, expr_ty(fcx.ccx.tcx, e));\n         write::nil_ty(fcx.ccx.tcx, id);\n       }\n       ast::expr_log(l, e) {\n-        check_expr(fcx, e);\n+        bot = check_expr(fcx, e);\n         write::nil_ty(fcx.ccx.tcx, id);\n       }\n       ast::expr_check(_, e) {\n-        check_pred_expr(fcx, e);\n+        bot = check_pred_expr(fcx, e);\n         write::nil_ty(fcx.ccx.tcx, id);\n       }\n       ast::expr_if_check(cond, thn, elsopt) {\n-        check_pred_expr(fcx, cond);\n-        check_then_else(fcx, thn, elsopt, id, expr.span);\n+        bot = check_pred_expr(fcx, cond) |\n+              check_then_else(fcx, thn, elsopt, id, expr.span);\n       }\n       ast::expr_ternary(_, _, _) {\n-        check_expr(fcx, ast::ternary_to_if(expr));\n+        bot = check_expr(fcx, ast::ternary_to_if(expr));\n       }\n       ast::expr_assert(e) {\n-        check_expr(fcx, e);\n+        bot = check_expr(fcx, e);\n         let ety = expr_ty(fcx.ccx.tcx, e);\n         demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx), ety);\n         write::nil_ty(fcx.ccx.tcx, id);\n       }\n       ast::expr_move(lhs, rhs) {\n         require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-        check_assignment(fcx, expr.span, lhs, rhs, id);\n+        bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_assign(lhs, rhs) {\n         require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-        check_assignment(fcx, expr.span, lhs, rhs, id);\n+        bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_swap(lhs, rhs) {\n         require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-        check_assignment(fcx, expr.span, lhs, rhs, id);\n+        bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_assign_op(op, lhs, rhs) {\n         require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-        check_assignment(fcx, expr.span, lhs, rhs, id);\n+        bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n         check_binop_type_compat(fcx, expr.span, expr_ty(fcx.ccx.tcx, lhs),\n                                 op);\n       }\n       ast::expr_send(lhs, rhs) {\n         require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-        check_expr(fcx, lhs);\n-        check_expr(fcx, rhs);\n+        bot = check_expr(fcx, lhs) | check_expr(fcx, rhs);\n         let rhs_t = expr_ty(fcx.ccx.tcx, rhs);\n         let chan_t = ty::mk_chan(fcx.ccx.tcx, rhs_t);\n         let lhs_t = expr_ty(fcx.ccx.tcx, lhs);\n@@ -1922,21 +1932,20 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n       }\n       ast::expr_recv(lhs, rhs) {\n         require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-        check_expr(fcx, lhs);\n-        check_expr(fcx, rhs);\n+        bot = check_expr(fcx, lhs) | check_expr(fcx, rhs);\n         let item_t = expr_ty(fcx.ccx.tcx, rhs);\n         let port_t = ty::mk_port(fcx.ccx.tcx, item_t);\n         demand::simple(fcx, expr.span, port_t, expr_ty(fcx.ccx.tcx, lhs));\n         write::ty_only_fixup(fcx, id, item_t);\n       }\n       ast::expr_if(cond, thn, elsopt) {\n-        check_expr(fcx, cond);\n+        bot = check_expr(fcx, cond) |\n+              check_then_else(fcx, thn, elsopt, id, expr.span);\n         demand::simple(fcx, cond.span, ty::mk_bool(fcx.ccx.tcx),\n                        expr_ty(fcx.ccx.tcx, cond));\n-        check_then_else(fcx, thn, elsopt, id, expr.span);\n       }\n       ast::expr_for(decl, seq, body) {\n-        check_expr(fcx, seq);\n+        bot = check_expr(fcx, seq);\n         let elt_ty;\n         let ety = expr_ty(fcx.ccx.tcx, seq);\n         alt structure_of(fcx, expr.span, ety) {\n@@ -1950,28 +1959,29 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n                  + \"found \" + ty_to_str(fcx.ccx.tcx, ety));\n           }\n         }\n-        check_for_or_for_each(fcx, decl, elt_ty, body, id);\n+        bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n       }\n       ast::expr_for_each(decl, seq, body) {\n-        check_expr(fcx, seq);\n-        check_for_or_for_each(fcx, decl, expr_ty(fcx.ccx.tcx, seq), body, id);\n+        bot = check_expr(fcx, seq) |\n+              check_for_or_for_each(fcx, decl, expr_ty(fcx.ccx.tcx, seq),\n+                                    body, id);\n       }\n       ast::expr_while(cond, body) {\n-        check_expr(fcx, cond);\n+        bot = check_expr(fcx, cond);\n         check_block(fcx, body);\n         demand::simple(fcx, cond.span, ty::mk_bool(fcx.ccx.tcx),\n                        expr_ty(fcx.ccx.tcx, cond));\n         let typ = ty::mk_nil(fcx.ccx.tcx);\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_do_while(body, cond) {\n-        check_expr(fcx, cond);\n+        bot = check_expr(fcx, cond);\n         check_block(fcx, body);\n         let typ = block_ty(fcx.ccx.tcx, body);\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_alt(expr, arms) {\n-        check_expr(fcx, expr);\n+        bot = check_expr(fcx, expr);\n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n \n@@ -1983,19 +1993,19 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n             }\n         }\n         // Now typecheck the blocks.\n-\n         let result_ty = next_ty_var(fcx);\n+        let arm_non_bot = false;\n         for arm: ast::arm  in arms {\n-            check_block(fcx, arm.block);\n+            if !check_block(fcx, arm.block) { arm_non_bot = true; }\n             let bty = block_ty(fcx.ccx.tcx, arm.block);\n \n-\n             // Failing alt arms don't need to have a matching type\n             if !ty::type_is_bot(fcx.ccx.tcx, bty) {\n                 result_ty =\n                     demand::simple(fcx, arm.block.span, result_ty, bty);\n             }\n         }\n+        bot |= !arm_non_bot;\n         write::ty_only_fixup(fcx, id, result_ty);\n       }\n       ast::expr_fn(f) {\n@@ -2010,7 +2020,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         check_fn(fcx.ccx, f, id, some(fcx));\n       }\n       ast::expr_block(b) {\n-        check_block(fcx, b);\n+        bot = check_block(fcx, b);\n         alt b.node.expr {\n           some(expr) {\n             let typ = expr_ty(fcx.ccx.tcx, expr);\n@@ -2024,7 +2034,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n       }\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n-        check_call_or_bind(fcx, expr.span, f, args, kind_bind);\n+        bot = check_call_or_bind(fcx, expr.span, f, args, kind_bind);\n \n         // Pull the argument and return types out.\n         let proto_1;\n@@ -2067,13 +2077,16 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         function name onto purity-designation */\n \n         require_pure_call(fcx.ccx, fcx.purity, f, expr.span);\n-        check_call(fcx, expr.span, f, args, kind_call);\n+        bot = check_call(fcx, expr.span, f, args, kind_call);\n         // Pull the return type out of the type of the function.\n \n         let rt_1;\n         let fty = do_autoderef(fcx, expr.span, ty::expr_ty(fcx.ccx.tcx, f));\n         alt structure_of(fcx, expr.span, fty) {\n-          ty::ty_fn(_, _, rt, _, _) { rt_1 = rt; }\n+          ty::ty_fn(_, _, rt, cf, _) {\n+            bot |= cf == ast::noreturn;\n+            rt_1 = rt;\n+          }\n           ty::ty_native_fn(_, _, rt) { rt_1 = rt; }\n           _ {\n             log_err \"LHS of call expr didn't have a function type?!\";\n@@ -2092,7 +2105,6 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n             alt oinfo {\n               regular_obj(_, obj_id) {\n                 let did = local_def(obj_id);\n-\n                 // Try looking up the current object in the type\n                 // cache.\n                 alt fcx.ccx.tcx.tcache.find(did) {\n@@ -2139,7 +2151,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n       }\n       ast::expr_spawn(_, _, f, args) {\n-        check_call(fcx, expr.span, f, args, kind_spawn);\n+        bot = check_call(fcx, expr.span, f, args, kind_spawn);\n         let fty = expr_ty(fcx.ccx.tcx, f);\n         let ret_ty = ty::ret_ty_of_fn_ty(fcx.ccx.tcx, fty);\n         demand::simple(fcx, f.span, ty::mk_nil(fcx.ccx.tcx), ret_ty);\n@@ -2156,7 +2168,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_cast(e, t) {\n-        check_expr(fcx, e);\n+        bot = check_expr(fcx, e);\n         let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n         // FIXME: there are more forms of cast to support, eventually.\n \n@@ -2176,11 +2188,11 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         if ivec::len[@ast::expr](args) == 0u {\n             t = next_ty_var(fcx);\n         } else {\n-            check_expr(fcx, args.(0));\n+            bot |= check_expr(fcx, args.(0));\n             t = expr_ty(fcx.ccx.tcx, args.(0));\n         }\n-        for e: @ast::expr  in args {\n-            check_expr(fcx, e);\n+        for e: @ast::expr in args {\n+            bot |= check_expr(fcx, e);\n             let expr_t = expr_ty(fcx.ccx.tcx, e);\n             demand::simple(fcx, expr.span, t, expr_t);\n         }\n@@ -2197,7 +2209,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         alt base { none. {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n         let fields_t: (spanned[field])[] = ~[];\n         for f: ast::field  in fields {\n-            check_expr(fcx, f.node.expr);\n+            bot |= check_expr(fcx, f.node.expr);\n             let expr_t = expr_ty(fcx.ccx.tcx, f.node.expr);\n             let expr_mt = {ty: expr_t, mut: f.node.mut};\n             // for the most precise error message,\n@@ -2213,7 +2225,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           some(bexpr) {\n-            check_expr(fcx, bexpr);\n+            bot |= check_expr(fcx, bexpr);\n             let bexpr_t = expr_ty(fcx.ccx.tcx, bexpr);\n             let base_fields: field[] = ~[];\n             alt structure_of(fcx, expr.span, bexpr_t) {\n@@ -2244,7 +2256,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         }\n       }\n       ast::expr_field(base, field) {\n-        check_expr(fcx, base);\n+        bot |= check_expr(fcx, base);\n         let base_t = expr_ty(fcx.ccx.tcx, base);\n         base_t = do_autoderef(fcx, expr.span, base_t);\n         alt structure_of(fcx, expr.span, base_t) {\n@@ -2278,10 +2290,10 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         }\n       }\n       ast::expr_index(base, idx) {\n-        check_expr(fcx, base);\n+        bot |= check_expr(fcx, base);\n         let base_t = expr_ty(fcx.ccx.tcx, base);\n         base_t = do_autoderef(fcx, expr.span, base_t);\n-        check_expr(fcx, idx);\n+        bot |= check_expr(fcx, idx);\n         let idx_t = expr_ty(fcx.ccx.tcx, idx);\n         if !type_is_integral(fcx, idx.span, idx_t) {\n             fcx.ccx.tcx.sess.span_fatal(idx.span,\n@@ -2335,7 +2347,6 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n         }\n       }\n       ast::expr_anon_obj(ao) {\n-\n         let fields: ast::anon_obj_field[] = ~[];\n         alt ao.fields { none. { } some(v) { fields = v; } }\n \n@@ -2369,15 +2380,11 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n                  constrs: out_constrs};\n         }\n \n-        fn get_anon_obj_method_types(fcx: @fn_ctxt, ao: &ast::anon_obj,\n-                                     fields: &ast::anon_obj_field[]) ->\n-           ty::method[] {\n-\n-            let methods: ty::method[] = ~[];\n-\n+        let method_types: ty::method[] = ~[];\n+        {\n             // Outer methods.\n             for m: @ast::method  in ao.methods {\n-                methods += ~[ty_of_method(fcx.ccx, m)];\n+                method_types += ~[ty_of_method(fcx.ccx, m)];\n             }\n \n             // Inner methods.\n@@ -2392,7 +2399,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n               some(e) {\n                 // If there's a inner_obj, we push it onto the obj_infos stack\n                 // so that self-calls can be checked within its context later.\n-                check_expr(fcx, e);\n+                bot |= check_expr(fcx, e);\n                 inner_obj_ty = expr_ty(fcx.ccx.tcx, e);\n                 inner_obj_sty = some(structure_of(fcx, e.span, inner_obj_ty));\n \n@@ -2437,11 +2444,9 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n                 std::ivec::filter_map[ty::method,\n                                       ty::method](f, inner_obj_methods);\n \n-            methods += inner_obj_methods;\n-            ret methods;\n+            method_types += inner_obj_methods;\n         }\n \n-        let method_types = get_anon_obj_method_types(fcx, ao, fields);\n         let ot = ty::mk_obj(fcx.ccx.tcx, ty::sort_methods(method_types));\n \n         write::ty_only_fixup(fcx, id, ot);\n@@ -2467,6 +2472,10 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n       }\n       _ { fcx.ccx.tcx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n     }\n+    if bot {\n+        write::ty_only_fixup(fcx, expr.id, ty::mk_bot(fcx.ccx.tcx));\n+    }\n+    ret bot;\n }\n \n fn next_ty_var_id(fcx: @fn_ctxt) -> int {\n@@ -2484,8 +2493,8 @@ fn get_obj_info(ccx: &@crate_ctxt) -> option::t[obj_info] {\n }\n \n fn check_decl_initializer(fcx: &@fn_ctxt, nid: ast::node_id,\n-                          init: &ast::initializer) {\n-    check_expr(fcx, init.expr);\n+                          init: &ast::initializer) -> bool {\n+    let bot = check_expr(fcx, init.expr);\n     let lty = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, init.expr.span, nid));\n     alt init.op {\n       ast::init_assign. {\n@@ -2502,10 +2511,12 @@ fn check_decl_initializer(fcx: &@fn_ctxt, nid: ast::node_id,\n                        expr_ty(fcx.ccx.tcx, init.expr));\n       }\n     }\n+    ret bot;\n }\n \n-fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) {\n+fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {\n     let a_id = local.node.id;\n+    let bot = false;\n     alt fcx.locals.find(a_id) {\n       none. {\n         fcx.ccx.tcx.sess.bug(\"check_decl_local: local id not found \" +\n@@ -2515,40 +2526,65 @@ fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) {\n         let t = ty::mk_var(fcx.ccx.tcx, i);\n         write::ty_only_fixup(fcx, a_id, t);\n         alt local.node.init {\n-          some(init) { check_decl_initializer(fcx, local.node.id, init); }\n+          some(init) {\n+            bot = check_decl_initializer(fcx, local.node.id, init);\n+          }\n           _ {/* fall through */ }\n         }\n       }\n     }\n+    ret bot;\n }\n \n-fn check_stmt(fcx: &@fn_ctxt, stmt: &@ast::stmt) {\n+fn check_stmt(fcx: &@fn_ctxt, stmt: &@ast::stmt) -> bool {\n     let node_id;\n+    let bot = false;\n     alt stmt.node {\n       ast::stmt_decl(decl, id) {\n         node_id = id;\n         alt decl.node {\n           ast::decl_local(ls) {\n-            for l: @ast::local  in ls { check_decl_local(fcx, l); }\n+            for l: @ast::local in ls { bot |= check_decl_local(fcx, l); }\n           }\n           ast::decl_item(_) {/* ignore for now */ }\n         }\n       }\n-      ast::stmt_expr(expr, id) { node_id = id; check_expr(fcx, expr); }\n+      ast::stmt_expr(expr, id) { node_id = id; bot = check_expr(fcx, expr); }\n     }\n     write::nil_ty(fcx.ccx.tcx, node_id);\n+    ret bot;\n }\n \n-fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) {\n-    for s: @ast::stmt  in blk.node.stmts { check_stmt(fcx, s); }\n+fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n+    let bot = false;\n+    let warned = false;\n+    for s: @ast::stmt in blk.node.stmts {\n+        if bot && !warned &&\n+           alt s.node {\n+            ast::stmt_decl(@{node: ast::decl_local(_), _}, _) |\n+            ast::stmt_expr(_, _) { true }\n+            _ { false }\n+           } {\n+            fcx.ccx.tcx.sess.span_warn(s.span, \"unreachable statement\");\n+            warned = true;\n+        }\n+        bot |= check_stmt(fcx, s);\n+    }\n     alt blk.node.expr {\n       none. { write::nil_ty(fcx.ccx.tcx, blk.node.id); }\n       some(e) {\n-        check_expr(fcx, e);\n+        if bot && !warned {\n+            fcx.ccx.tcx.sess.span_warn(e.span, \"unreachable expression\");\n+        }\n+        bot |= check_expr(fcx, e);\n         let ety = expr_ty(fcx.ccx.tcx, e);\n         write::ty_only_fixup(fcx, blk.node.id, ety);\n       }\n     }\n+    if bot {\n+        write::ty_only_fixup(fcx, blk.node.id, ty::mk_bot(fcx.ccx.tcx));\n+    }\n+    ret bot;\n }\n \n fn check_const(ccx: &@crate_ctxt, sp: &span, e: &@ast::expr,"}, {"sha": "dd13fcef7d28a25d4ac5b05d6ee72c5522b51456", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa3b89610e081b3b58a3d4acb5201c0d6ea200c6/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3b89610e081b3b58a3d4acb5201c0d6ea200c6/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=aa3b89610e081b3b58a3d4acb5201c0d6ea200c6", "patch": "@@ -81,7 +81,7 @@ fn from_mut[T](v: &T[mutable ]) -> T[] {\n // Predicates\n pred is_empty[T](v: &T[mutable? ]) -> bool {\n     // FIXME: This would be easier if we could just call len\n-    for t: T  in v { ret false; }\n+    for t: T in v { ret false; }\n     ret true;\n }\n "}]}