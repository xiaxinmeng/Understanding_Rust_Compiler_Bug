{"sha": "511fe048b4ee2535961014b1be3294a771cc7e87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMWZlMDQ4YjRlZTI1MzU5NjEwMTRiMWJlMzI5NGE3NzFjYzdlODc=", "commit": {"author": {"name": "Ayrton", "email": "a.munoz3327@gmail.com", "date": "2020-10-06T13:51:10Z"}, "committer": {"name": "Ayrton", "email": "a.munoz3327@gmail.com", "date": "2020-10-27T15:04:04Z"}, "message": "Changed lint to check for `std::fmt::Pointer` and `transmute`\n\nThe lint checks arguments in calls to `transmute` or functions that have\n`Pointer` as a trait bound and displays a warning if the argument is a function\nreference. Also checks for `std::fmt::Pointer::fmt` to handle formatting macros\nalthough it doesn't depend on the exact expansion of the macro or formatting\ninternals. `std::fmt::Pointer` and `std::fmt::Pointer::fmt` were also added as\ndiagnostic items and symbols.", "tree": {"sha": "2fb41c1d16b3a455ab2def35bd3ed9a8fbf504b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fb41c1d16b3a455ab2def35bd3ed9a8fbf504b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/511fe048b4ee2535961014b1be3294a771cc7e87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/511fe048b4ee2535961014b1be3294a771cc7e87", "html_url": "https://github.com/rust-lang/rust/commit/511fe048b4ee2535961014b1be3294a771cc7e87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/511fe048b4ee2535961014b1be3294a771cc7e87/comments", "author": {"login": "ayrtonm", "id": 4975834, "node_id": "MDQ6VXNlcjQ5NzU4MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4975834?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ayrtonm", "html_url": "https://github.com/ayrtonm", "followers_url": "https://api.github.com/users/ayrtonm/followers", "following_url": "https://api.github.com/users/ayrtonm/following{/other_user}", "gists_url": "https://api.github.com/users/ayrtonm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ayrtonm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ayrtonm/subscriptions", "organizations_url": "https://api.github.com/users/ayrtonm/orgs", "repos_url": "https://api.github.com/users/ayrtonm/repos", "events_url": "https://api.github.com/users/ayrtonm/events{/privacy}", "received_events_url": "https://api.github.com/users/ayrtonm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ayrtonm", "id": 4975834, "node_id": "MDQ6VXNlcjQ5NzU4MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4975834?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ayrtonm", "html_url": "https://github.com/ayrtonm", "followers_url": "https://api.github.com/users/ayrtonm/followers", "following_url": "https://api.github.com/users/ayrtonm/following{/other_user}", "gists_url": "https://api.github.com/users/ayrtonm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ayrtonm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ayrtonm/subscriptions", "organizations_url": "https://api.github.com/users/ayrtonm/orgs", "repos_url": "https://api.github.com/users/ayrtonm/repos", "events_url": "https://api.github.com/users/ayrtonm/events{/privacy}", "received_events_url": "https://api.github.com/users/ayrtonm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3214de735969602ddf2625ca500ff8d3ec57a745", "url": "https://api.github.com/repos/rust-lang/rust/commits/3214de735969602ddf2625ca500ff8d3ec57a745", "html_url": "https://github.com/rust-lang/rust/commit/3214de735969602ddf2625ca500ff8d3ec57a745"}], "stats": {"total": 492, "additions": 324, "deletions": 168}, "files": [{"sha": "8adeac7623bad92d1f89ddf2468481c096b6bc0b", "filename": "compiler/rustc_mir/src/transform/function_references.rs", "status": "modified", "additions": 112, "deletions": 92, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/511fe048b4ee2535961014b1be3294a771cc7e87/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511fe048b4ee2535961014b1be3294a771cc7e87/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_references.rs?ref=511fe048b4ee2535961014b1be3294a771cc7e87", "patch": "@@ -1,134 +1,154 @@\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_session::lint::builtin::FUNCTION_REFERENCES;\n-use rustc_span::Span;\n+use rustc_middle::ty::{self, subst::GenericArgKind, PredicateAtom, Ty, TyCtxt, TyS};\n+use rustc_session::lint::builtin::FUNCTION_ITEM_REFERENCES;\n+use rustc_span::{symbol::sym, Span};\n use rustc_target::spec::abi::Abi;\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n \n-pub struct FunctionReferences;\n+pub struct FunctionItemReferences;\n \n-impl<'tcx> MirPass<'tcx> for FunctionReferences {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let source_info = SourceInfo::outermost(body.span);\n-        let mut checker = FunctionRefChecker {\n-            tcx,\n-            body,\n-            potential_lints: Vec::new(),\n-            casts: Vec::new(),\n-            calls: Vec::new(),\n-            source_info,\n-        };\n+impl<'tcx> MirPass<'tcx> for FunctionItemReferences {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let mut checker = FunctionItemRefChecker { tcx, body };\n         checker.visit_body(&body);\n     }\n }\n \n-struct FunctionRefChecker<'a, 'tcx> {\n+struct FunctionItemRefChecker<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    potential_lints: Vec<FunctionRefLint>,\n-    casts: Vec<Span>,\n-    calls: Vec<Span>,\n-    source_info: SourceInfo,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for FunctionRefChecker<'a, 'tcx> {\n-    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n-        self.super_basic_block_data(block, data);\n-        for cast_span in self.casts.drain(..) {\n-            self.potential_lints.retain(|lint| lint.source_info.span != cast_span);\n-        }\n-        for call_span in self.calls.drain(..) {\n-            self.potential_lints.retain(|lint| lint.source_info.span != call_span);\n-        }\n-        for lint in self.potential_lints.drain(..) {\n-            lint.emit(self.tcx, self.body);\n-        }\n-    }\n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-        self.source_info = statement.source_info;\n-        self.super_statement(statement, location);\n-    }\n+impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-        self.source_info = terminator.source_info;\n         if let TerminatorKind::Call {\n             func,\n-            args: _,\n+            args,\n             destination: _,\n             cleanup: _,\n             from_hir_call: _,\n             fn_span: _,\n         } = &terminator.kind\n         {\n-            let span = match func {\n-                Operand::Copy(place) | Operand::Move(place) => {\n-                    self.body.local_decls[place.local].source_info.span\n+            let func_ty = func.ty(self.body, self.tcx);\n+            if let ty::FnDef(def_id, substs_ref) = *func_ty.kind() {\n+                //check arguments for `std::mem::transmute`\n+                if self.tcx.is_diagnostic_item(sym::transmute, def_id) {\n+                    let arg_ty = args[0].ty(self.body, self.tcx);\n+                    for generic_inner_ty in arg_ty.walk() {\n+                        if let GenericArgKind::Type(inner_ty) = generic_inner_ty.unpack() {\n+                            if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(inner_ty) {\n+                                let ident = self.tcx.item_name(fn_id).to_ident_string();\n+                                let source_info = *self.body.source_info(location);\n+                                let span = self.nth_arg_span(&args, 0);\n+                                self.emit_lint(ident, fn_id, source_info, span);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    //check arguments for any function with `std::fmt::Pointer` as a bound trait\n+                    let param_env = self.tcx.param_env(def_id);\n+                    let bounds = param_env.caller_bounds();\n+                    for bound in bounds {\n+                        if let Some(bound_ty) = self.is_pointer_trait(&bound.skip_binders()) {\n+                            let arg_defs = self.tcx.fn_sig(def_id).skip_binder().inputs();\n+                            for (arg_num, arg_def) in arg_defs.iter().enumerate() {\n+                                for generic_inner_ty in arg_def.walk() {\n+                                    if let GenericArgKind::Type(inner_ty) =\n+                                        generic_inner_ty.unpack()\n+                                    {\n+                                        //if any type reachable from the argument types in the fn sig matches the type bound by `Pointer`\n+                                        if TyS::same_type(inner_ty, bound_ty) {\n+                                            //check if this type is a function reference in the function call\n+                                            let norm_ty =\n+                                                self.tcx.subst_and_normalize_erasing_regions(\n+                                                    substs_ref, param_env, &inner_ty,\n+                                                );\n+                                            if let Some(fn_id) =\n+                                                FunctionItemRefChecker::is_fn_ref(norm_ty)\n+                                            {\n+                                                let ident =\n+                                                    self.tcx.item_name(fn_id).to_ident_string();\n+                                                let source_info = *self.body.source_info(location);\n+                                                let span = self.nth_arg_span(&args, arg_num);\n+                                                self.emit_lint(ident, fn_id, source_info, span);\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n                 }\n-                Operand::Constant(constant) => constant.span,\n-            };\n-            self.calls.push(span);\n-        };\n+            }\n+        }\n         self.super_terminator(terminator, location);\n     }\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        match rvalue {\n-            Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n-                let decl = &self.body.local_decls[place.local];\n-                if let ty::FnDef(def_id, _) = decl.ty.kind {\n-                    let ident = self\n-                        .body\n-                        .var_debug_info\n-                        .iter()\n-                        .find(|info| info.source_info.span == decl.source_info.span)\n-                        .map(|info| info.name.to_ident_string())\n-                        .unwrap_or(self.tcx.def_path_str(def_id));\n-                    let lint = FunctionRefLint { ident, def_id, source_info: self.source_info };\n-                    self.potential_lints.push(lint);\n-                }\n-            }\n-            Rvalue::Cast(_, op, _) => {\n-                let op_ty = op.ty(self.body, self.tcx);\n-                if self.is_fn_ref(op_ty) {\n-                    self.casts.push(self.source_info.span);\n+    //check for `std::fmt::Pointer::<T>::fmt` where T is a function reference\n+    //this is used in formatting macros, but doesn't rely on the specific expansion\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n+        let op_ty = operand.ty(self.body, self.tcx);\n+        if let ty::FnDef(def_id, substs_ref) = *op_ty.kind() {\n+            if self.tcx.is_diagnostic_item(sym::pointer_trait_fmt, def_id) {\n+                let param_ty = substs_ref.type_at(0);\n+                if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(param_ty) {\n+                    let source_info = *self.body.source_info(location);\n+                    let callsite_ctxt = source_info.span.source_callsite().ctxt();\n+                    let span = source_info.span.with_ctxt(callsite_ctxt);\n+                    let ident = self.tcx.item_name(fn_id).to_ident_string();\n+                    self.emit_lint(ident, fn_id, source_info, span);\n                 }\n             }\n-            _ => {}\n         }\n-        self.super_rvalue(rvalue, location);\n+        self.super_operand(operand, location);\n     }\n }\n \n-impl<'a, 'tcx> FunctionRefChecker<'a, 'tcx> {\n-    fn is_fn_ref(&self, ty: Ty<'tcx>) -> bool {\n-        let referent_ty = match ty.kind {\n+impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n+    //return the bound parameter type if the trait is `std::fmt::Pointer`\n+    fn is_pointer_trait(&self, bound: &PredicateAtom<'tcx>) -> Option<Ty<'tcx>> {\n+        if let ty::PredicateAtom::Trait(predicate, _) = bound {\n+            if self.tcx.is_diagnostic_item(sym::pointer_trait, predicate.def_id()) {\n+                Some(predicate.trait_ref.self_ty())\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+    fn is_fn_ref(ty: Ty<'tcx>) -> Option<DefId> {\n+        let referent_ty = match ty.kind() {\n             ty::Ref(_, referent_ty, _) => Some(referent_ty),\n-            ty::RawPtr(ty_and_mut) => Some(ty_and_mut.ty),\n+            ty::RawPtr(ty_and_mut) => Some(&ty_and_mut.ty),\n             _ => None,\n         };\n         referent_ty\n-            .map(|ref_ty| if let ty::FnDef(..) = ref_ty.kind { true } else { false })\n-            .unwrap_or(false)\n+            .map(\n+                |ref_ty| {\n+                    if let ty::FnDef(def_id, _) = *ref_ty.kind() { Some(def_id) } else { None }\n+                },\n+            )\n+            .unwrap_or(None)\n     }\n-}\n-\n-struct FunctionRefLint {\n-    ident: String,\n-    def_id: DefId,\n-    source_info: SourceInfo,\n-}\n-\n-impl<'tcx> FunctionRefLint {\n-    fn emit(&self, tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n-        let def_id = self.def_id;\n-        let source_info = self.source_info;\n-        let lint_root = body.source_scopes[source_info.scope]\n+    fn nth_arg_span(&self, args: &Vec<Operand<'tcx>>, n: usize) -> Span {\n+        match &args[n] {\n+            Operand::Copy(place) | Operand::Move(place) => {\n+                self.body.local_decls[place.local].source_info.span\n+            }\n+            Operand::Constant(constant) => constant.span,\n+        }\n+    }\n+    fn emit_lint(&self, ident: String, fn_id: DefId, source_info: SourceInfo, span: Span) {\n+        let lint_root = self.body.source_scopes[source_info.scope]\n             .local_data\n             .as_ref()\n             .assert_crate_local()\n             .lint_root;\n-        let fn_sig = tcx.fn_sig(def_id);\n+        let fn_sig = self.tcx.fn_sig(fn_id);\n         let unsafety = fn_sig.unsafety().prefix_str();\n         let abi = match fn_sig.abi() {\n             Abi::Rust => String::from(\"\"),\n@@ -142,17 +162,17 @@ impl<'tcx> FunctionRefLint {\n         let num_args = fn_sig.inputs().map_bound(|inputs| inputs.len()).skip_binder();\n         let variadic = if fn_sig.c_variadic() { \", ...\" } else { \"\" };\n         let ret = if fn_sig.output().skip_binder().is_unit() { \"\" } else { \" -> _\" };\n-        tcx.struct_span_lint_hir(FUNCTION_REFERENCES, lint_root, source_info.span, |lint| {\n+        self.tcx.struct_span_lint_hir(FUNCTION_ITEM_REFERENCES, lint_root, span, |lint| {\n             lint.build(&format!(\n                 \"cast `{}` with `as {}{}fn({}{}){}` to use it as a pointer\",\n-                self.ident,\n+                ident,\n                 unsafety,\n                 abi,\n                 vec![\"_\"; num_args].join(\", \"),\n                 variadic,\n                 ret,\n             ))\n-            .emit()\n+            .emit();\n         });\n     }\n }"}, {"sha": "e43a238c1bad120839c130cdc89ff8b9f619e2c8", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511fe048b4ee2535961014b1be3294a771cc7e87/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511fe048b4ee2535961014b1be3294a771cc7e87/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=511fe048b4ee2535961014b1be3294a771cc7e87", "patch": "@@ -267,7 +267,7 @@ fn mir_const<'tcx>(\n             // MIR-level lints.\n             &check_packed_ref::CheckPackedRef,\n             &check_const_item_mutation::CheckConstItemMutation,\n-            &function_references::FunctionReferences,\n+            &function_references::FunctionItemReferences,\n             // What we need to do constant evaluation.\n             &simplify::SimplifyCfg::new(\"initial\"),\n             &rustc_peek::SanityCheck,"}, {"sha": "41abdacb54c86c5b95f0f72a4dad840559055480", "filename": "compiler/rustc_session/src/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/511fe048b4ee2535961014b1be3294a771cc7e87/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511fe048b4ee2535961014b1be3294a771cc7e87/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs?ref=511fe048b4ee2535961014b1be3294a771cc7e87", "patch": "@@ -2645,9 +2645,10 @@ declare_lint! {\n         reference: \"issue #76200 <https://github.com/rust-lang/rust/issues/76200>\",\n         edition: None,\n     };\n+}\n \n declare_lint! {\n-    pub FUNCTION_REFERENCES,\n+    pub FUNCTION_ITEM_REFERENCES,\n     Warn,\n     \"suggest casting functions to pointers when attempting to take references\",\n }\n@@ -2767,7 +2768,7 @@ declare_lint_pass! {\n         CONST_EVALUATABLE_UNCHECKED,\n         INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n         UNINHABITED_STATIC,\n-        FUNCTION_REFERENCES,\n+        FUNCTION_ITEM_REFERENCES,\n     ]\n }\n "}, {"sha": "ef0f09ae81895367dbfc13f1a47c69fbdc957e57", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511fe048b4ee2535961014b1be3294a771cc7e87/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511fe048b4ee2535961014b1be3294a771cc7e87/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=511fe048b4ee2535961014b1be3294a771cc7e87", "patch": "@@ -796,6 +796,8 @@ symbols! {\n         plugin_registrar,\n         plugins,\n         pointer,\n+        pointer_trait,\n+        pointer_trait_fmt,\n         poll,\n         position,\n         post_dash_lto: \"post-lto\","}, {"sha": "506d77806868215828708f419b45d15b8093b9ca", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511fe048b4ee2535961014b1be3294a771cc7e87/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511fe048b4ee2535961014b1be3294a771cc7e87/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=511fe048b4ee2535961014b1be3294a771cc7e87", "patch": "@@ -920,9 +920,11 @@ pub trait UpperHex {\n /// assert_eq!(&l_ptr[..2], \"0x\");\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"pointer_trait\"]\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_diagnostic_item = \"pointer_trait_fmt\"]\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n }\n "}, {"sha": "1a8dde857909b833fb991d58634f25d1a7d43eb9", "filename": "src/test/ui/lint/function-references.rs", "status": "modified", "additions": 100, "deletions": 34, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/511fe048b4ee2535961014b1be3294a771cc7e87/src%2Ftest%2Fui%2Flint%2Ffunction-references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511fe048b4ee2535961014b1be3294a771cc7e87/src%2Ftest%2Fui%2Flint%2Ffunction-references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffunction-references.rs?ref=511fe048b4ee2535961014b1be3294a771cc7e87", "patch": "@@ -1,71 +1,137 @@\n // check-pass\n #![feature(c_variadic)]\n-#![allow(dead_code)]\n+#![warn(function_item_references)]\n+use std::fmt::Pointer;\n \n+fn nop() { }\n fn foo() -> u32 { 42 }\n fn bar(x: u32) -> u32 { x }\n fn baz(x: u32, y: u32) -> u32 { x + y }\n unsafe fn unsafe_fn() { }\n extern \"C\" fn c_fn() { }\n unsafe extern \"C\" fn unsafe_c_fn() { }\n unsafe extern fn variadic_fn(_x: u32, _args: ...) { }\n+\n+//function references passed to these functions should never lint\n fn call_fn(f: &dyn Fn(u32) -> u32, x: u32) { f(x); }\n fn parameterized_call_fn<F: Fn(u32) -> u32>(f: &F, x: u32) { f(x); }\n \n+//function references passed to these functions should lint\n+fn print_ptr<F: Pointer>(f: F) { println!(\"{:p}\", f); }\n+fn bound_by_ptr_trait<F: Pointer>(_f: F) { }\n+fn bound_by_ptr_trait_tuple<F: Pointer, G: Pointer>(_t: (F, G)) { }\n+fn implicit_ptr_trait<F>(f: &F) { println!(\"{:p}\", f); }\n+\n fn main() {\n-    let _zst_ref = &foo;\n-    //~^ WARN cast `foo` with `as fn() -> _` to use it as a pointer\n+    //`let` bindings with function references shouldn't lint\n+    let _ = &foo;\n+    let _ = &mut foo;\n+\n+    let zst_ref = &foo;\n     let fn_item = foo;\n-    let _indirect_ref = &fn_item;\n-    //~^ WARN cast `fn_item` with `as fn() -> _` to use it as a pointer\n-    let _cast_zst_ptr = &foo as *const _;\n-    //~^ WARN cast `foo` with `as fn() -> _` to use it as a pointer\n-    let _coerced_zst_ptr: *const _ = &foo;\n-    //~^ WARN cast `foo` with `as fn() -> _` to use it as a pointer\n-\n-    let _zst_ref = &mut foo;\n-    //~^ WARN cast `foo` with `as fn() -> _` to use it as a pointer\n+    let indirect_ref = &fn_item;\n+\n+    let _mut_zst_ref = &mut foo;\n     let mut mut_fn_item = foo;\n-    let _indirect_ref = &mut mut_fn_item;\n-    //~^ WARN cast `fn_item` with `as fn() -> _` to use it as a pointer\n-    let _cast_zst_ptr = &mut foo as *mut _;\n-    //~^ WARN cast `foo` with `as fn() -> _` to use it as a pointer\n-    let _coerced_zst_ptr: *mut _ = &mut foo;\n-    //~^ WARN cast `foo` with `as fn() -> _` to use it as a pointer\n+    let _mut_indirect_ref = &mut mut_fn_item;\n+\n+    let cast_zst_ptr = &foo as *const _;\n+    let coerced_zst_ptr: *const _ = &foo;\n+\n+    let _mut_cast_zst_ptr = &mut foo as *mut _;\n+    let _mut_coerced_zst_ptr: *mut _ = &mut foo;\n \n     let _cast_zst_ref = &foo as &dyn Fn() -> u32;\n     let _coerced_zst_ref: &dyn Fn() -> u32 = &foo;\n \n-    let _cast_zst_ref = &mut foo as &mut dyn Fn() -> u32;\n-    let _coerced_zst_ref: &mut dyn Fn() -> u32 = &mut foo;\n-    let _fn_ptr = foo as fn() -> u32;\n+    let _mut_cast_zst_ref = &mut foo as &mut dyn Fn() -> u32;\n+    let _mut_coerced_zst_ref: &mut dyn Fn() -> u32 = &mut foo;\n \n+    //the suggested way to cast to a function pointer\n+    let fn_ptr = foo as fn() -> u32;\n+\n+    //correct ways to print function pointers\n+    println!(\"{:p}\", foo as fn() -> u32);\n+    println!(\"{:p}\", fn_ptr);\n+\n+    //potential ways to incorrectly try printing function pointers\n     println!(\"{:p}\", &foo);\n-    //~^ WARN cast `foo` with as fn() -> _` to use it as a pointer\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+    print!(\"{:p}\", &foo);\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+    format!(\"{:p}\", &foo);\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+\n+    println!(\"{:p}\", &foo as *const _);\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+    println!(\"{:p}\", zst_ref);\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+    println!(\"{:p}\", cast_zst_ptr);\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+    println!(\"{:p}\", coerced_zst_ptr);\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+\n+    println!(\"{:p}\", &fn_item);\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+    println!(\"{:p}\", indirect_ref);\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+\n+    println!(\"{:p}\", &nop);\n+    //~^ WARNING cast `nop` with `as fn()` to use it as a pointer\n     println!(\"{:p}\", &bar);\n-    //~^ WARN cast `bar` with as fn(_) -> _` to use it as a pointer\n+    //~^ WARNING cast `bar` with `as fn(_) -> _` to use it as a pointer\n     println!(\"{:p}\", &baz);\n-    //~^ WARN cast `baz` with as fn(_, _) -> _` to use it as a pointer\n+    //~^ WARNING cast `baz` with `as fn(_, _) -> _` to use it as a pointer\n     println!(\"{:p}\", &unsafe_fn);\n-    //~^ WARN cast `baz` with as unsafe fn()` to use it as a pointer\n+    //~^ WARNING cast `unsafe_fn` with `as unsafe fn()` to use it as a pointer\n     println!(\"{:p}\", &c_fn);\n-    //~^ WARN cast `baz` with as extern \"C\" fn()` to use it as a pointer\n+    //~^ WARNING cast `c_fn` with `as extern \"C\" fn()` to use it as a pointer\n     println!(\"{:p}\", &unsafe_c_fn);\n-    //~^ WARN cast `baz` with as unsafe extern \"C\" fn()` to use it as a pointer\n+    //~^ WARNING cast `unsafe_c_fn` with `as unsafe extern \"C\" fn()` to use it as a pointer\n     println!(\"{:p}\", &variadic_fn);\n-    //~^ WARN cast `baz` with as unsafe extern \"C\" fn(_, ...) -> _` to use it as a pointer\n+    //~^ WARNING cast `variadic_fn` with `as unsafe extern \"C\" fn(_, ...)` to use it as a pointer\n     println!(\"{:p}\", &std::env::var::<String>);\n-    //~^ WARN cast `std::env::var` with as fn(_) -> _` to use it as a pointer\n+    //~^ WARNING cast `var` with `as fn(_) -> _` to use it as a pointer\n \n-    println!(\"{:p}\", foo as fn() -> u32);\n+    println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n+    //~^ WARNING cast `nop` with `as fn()` to use it as a pointer\n+    //~^^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+    //~^^^ WARNING cast `bar` with `as fn(_) -> _` to use it as a pointer\n+\n+    //using a function reference to call a function shouldn't lint\n+    (&bar)(1);\n+\n+    //passing a function reference to an arbitrary function shouldn't lint\n+    call_fn(&bar, 1);\n+    parameterized_call_fn(&bar, 1);\n+    std::mem::size_of_val(&foo);\n \n     unsafe {\n+        //potential ways to incorrectly try transmuting function pointers\n         std::mem::transmute::<_, usize>(&foo);\n-        //~^ WARN cast `foo` with as fn() -> _` to use it as a pointer\n+        //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+        std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n+        //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+        //~^^ WARNING cast `bar` with `as fn(_) -> _` to use it as a pointer\n+\n+        //the correct way to transmute function pointers\n         std::mem::transmute::<_, usize>(foo as fn() -> u32);\n+        std::mem::transmute::<_, (usize, usize)>((foo as fn() -> u32, bar as fn(u32) -> u32));\n     }\n \n-    (&bar)(1);\n-    call_fn(&bar, 1);\n-    parameterized_call_fn(&bar, 1);\n+    //function references as arguments required to be bound by std::fmt::Pointer should lint\n+    print_ptr(&bar);\n+    //~^ WARNING cast `bar` with `as fn(_) -> _` to use it as a pointer\n+    bound_by_ptr_trait(&bar);\n+    //~^ WARNING cast `bar` with `as fn(_) -> _` to use it as a pointer\n+    bound_by_ptr_trait_tuple((&foo, &bar));\n+    //~^ WARNING cast `foo` with `as fn() -> _` to use it as a pointer\n+    //~^^ WARNING cast `bar` with `as fn(_) -> _` to use it as a pointer\n+    implicit_ptr_trait(&bar);\n+    //~^ WARNING cast `bar` with `as fn(_) -> _` to use it as a pointer\n+\n+    //correct ways to pass function pointers as arguments bound by std::fmt::Pointer\n+    print_ptr(bar as fn(u32) -> u32);\n+    bound_by_ptr_trait(bar as fn(u32) -> u32);\n+    bound_by_ptr_trait_tuple((foo as fn() -> u32, bar as fn(u32) -> u32));\n }"}, {"sha": "bc4947b3d70611fdb4098db06a64bd7e6c5d3057", "filename": "src/test/ui/lint/function-references.stderr", "status": "modified", "additions": 104, "deletions": 39, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/511fe048b4ee2535961014b1be3294a771cc7e87/src%2Ftest%2Fui%2Flint%2Ffunction-references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/511fe048b4ee2535961014b1be3294a771cc7e87/src%2Ftest%2Fui%2Flint%2Ffunction-references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffunction-references.stderr?ref=511fe048b4ee2535961014b1be3294a771cc7e87", "patch": "@@ -1,105 +1,170 @@\n warning: cast `foo` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:16:20\n+  --> $DIR/function-references.rs:58:22\n    |\n-LL |     let _zst_ref = &foo;\n-   |                    ^^^^\n+LL |     println!(\"{:p}\", &foo);\n+   |                      ^^^^\n    |\n-   = note: `#[warn(function_references)]` on by default\n+note: the lint level is defined here\n+  --> $DIR/function-references.rs:3:9\n+   |\n+LL | #![warn(function_item_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: cast `fn_item` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:19:25\n+warning: cast `foo` with `as fn() -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:60:20\n    |\n-LL |     let _indirect_ref = &fn_item;\n-   |                         ^^^^^^^^\n+LL |     print!(\"{:p}\", &foo);\n+   |                    ^^^^\n \n warning: cast `foo` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:21:25\n+  --> $DIR/function-references.rs:62:21\n    |\n-LL |     let _cast_zst_ptr = &foo as *const _;\n-   |                         ^^^^\n+LL |     format!(\"{:p}\", &foo);\n+   |                     ^^^^\n \n warning: cast `foo` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:23:38\n+  --> $DIR/function-references.rs:65:22\n    |\n-LL |     let _coerced_zst_ptr: *const _ = &foo;\n-   |                                      ^^^^\n+LL |     println!(\"{:p}\", &foo as *const _);\n+   |                      ^^^^^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:26:20\n+  --> $DIR/function-references.rs:67:22\n    |\n-LL |     let _zst_ref = &mut foo;\n-   |                    ^^^^^^^^\n+LL |     println!(\"{:p}\", zst_ref);\n+   |                      ^^^^^^^\n \n-warning: cast `mut_fn_item` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:29:25\n+warning: cast `foo` with `as fn() -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:69:22\n    |\n-LL |     let _indirect_ref = &mut mut_fn_item;\n-   |                         ^^^^^^^^^^^^^^^^\n+LL |     println!(\"{:p}\", cast_zst_ptr);\n+   |                      ^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:31:25\n+  --> $DIR/function-references.rs:71:22\n    |\n-LL |     let _cast_zst_ptr = &mut foo as *mut _;\n-   |                         ^^^^^^^^\n+LL |     println!(\"{:p}\", coerced_zst_ptr);\n+   |                      ^^^^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:33:36\n+  --> $DIR/function-references.rs:74:22\n    |\n-LL |     let _coerced_zst_ptr: *mut _ = &mut foo;\n-   |                                    ^^^^^^^^\n+LL |     println!(\"{:p}\", &fn_item);\n+   |                      ^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:43:22\n+  --> $DIR/function-references.rs:76:22\n    |\n-LL |     println!(\"{:p}\", &foo);\n+LL |     println!(\"{:p}\", indirect_ref);\n+   |                      ^^^^^^^^^^^^\n+\n+warning: cast `nop` with `as fn()` to use it as a pointer\n+  --> $DIR/function-references.rs:79:22\n+   |\n+LL |     println!(\"{:p}\", &nop);\n    |                      ^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:45:22\n+  --> $DIR/function-references.rs:81:22\n    |\n LL |     println!(\"{:p}\", &bar);\n    |                      ^^^^\n \n warning: cast `baz` with `as fn(_, _) -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:47:22\n+  --> $DIR/function-references.rs:83:22\n    |\n LL |     println!(\"{:p}\", &baz);\n    |                      ^^^^\n \n warning: cast `unsafe_fn` with `as unsafe fn()` to use it as a pointer\n-  --> $DIR/function-references.rs:49:22\n+  --> $DIR/function-references.rs:85:22\n    |\n LL |     println!(\"{:p}\", &unsafe_fn);\n    |                      ^^^^^^^^^^\n \n warning: cast `c_fn` with `as extern \"C\" fn()` to use it as a pointer\n-  --> $DIR/function-references.rs:51:22\n+  --> $DIR/function-references.rs:87:22\n    |\n LL |     println!(\"{:p}\", &c_fn);\n    |                      ^^^^^\n \n warning: cast `unsafe_c_fn` with `as unsafe extern \"C\" fn()` to use it as a pointer\n-  --> $DIR/function-references.rs:53:22\n+  --> $DIR/function-references.rs:89:22\n    |\n LL |     println!(\"{:p}\", &unsafe_c_fn);\n    |                      ^^^^^^^^^^^^\n \n warning: cast `variadic_fn` with `as unsafe extern \"C\" fn(_, ...)` to use it as a pointer\n-  --> $DIR/function-references.rs:55:22\n+  --> $DIR/function-references.rs:91:22\n    |\n LL |     println!(\"{:p}\", &variadic_fn);\n    |                      ^^^^^^^^^^^^\n \n-warning: cast `std::env::var` with `as fn(_) -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:57:22\n+warning: cast `var` with `as fn(_) -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:93:22\n    |\n LL |     println!(\"{:p}\", &std::env::var::<String>);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^\n \n+warning: cast `nop` with `as fn()` to use it as a pointer\n+  --> $DIR/function-references.rs:96:32\n+   |\n+LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n+   |                                ^^^^\n+\n warning: cast `foo` with `as fn() -> _` to use it as a pointer\n-  --> $DIR/function-references.rs:63:41\n+  --> $DIR/function-references.rs:96:38\n+   |\n+LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n+   |                                      ^^^^\n+\n+warning: cast `bar` with `as fn(_) -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:96:44\n+   |\n+LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n+   |                                            ^^^^\n+\n+warning: cast `foo` with `as fn() -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:111:41\n    |\n LL |         std::mem::transmute::<_, usize>(&foo);\n    |                                         ^^^^\n \n-warning: 17 warnings emitted\n+warning: cast `foo` with `as fn() -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:113:50\n+   |\n+LL |         std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n+   |                                                  ^^^^^^^^^^^^\n+\n+warning: cast `bar` with `as fn(_) -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:113:50\n+   |\n+LL |         std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n+   |                                                  ^^^^^^^^^^^^\n+\n+warning: cast `bar` with `as fn(_) -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:123:15\n+   |\n+LL |     print_ptr(&bar);\n+   |               ^^^^\n+\n+warning: cast `bar` with `as fn(_) -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:125:24\n+   |\n+LL |     bound_by_ptr_trait(&bar);\n+   |                        ^^^^\n+\n+warning: cast `bar` with `as fn(_) -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:127:30\n+   |\n+LL |     bound_by_ptr_trait_tuple((&foo, &bar));\n+   |                              ^^^^^^^^^^^^\n+\n+warning: cast `foo` with `as fn() -> _` to use it as a pointer\n+  --> $DIR/function-references.rs:127:30\n+   |\n+LL |     bound_by_ptr_trait_tuple((&foo, &bar));\n+   |                              ^^^^^^^^^^^^\n+\n+warning: 27 warnings emitted\n+"}]}