{"sha": "4240a0bed0943cd3fa003e7951d91ab8a37ff8e3", "node_id": "C_kwDOAAsO6NoAKDQyNDBhMGJlZDA5NDNjZDNmYTAwM2U3OTUxZDkxYWI4YTM3ZmY4ZTM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-26T20:42:46Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-03T15:59:21Z"}, "message": "Cleanup PatCtxt.", "tree": {"sha": "eeaf687a8a1e6c84a98063e5a61899cbce01d1fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeaf687a8a1e6c84a98063e5a61899cbce01d1fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4240a0bed0943cd3fa003e7951d91ab8a37ff8e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4240a0bed0943cd3fa003e7951d91ab8a37ff8e3", "html_url": "https://github.com/rust-lang/rust/commit/4240a0bed0943cd3fa003e7951d91ab8a37ff8e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4240a0bed0943cd3fa003e7951d91ab8a37ff8e3/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05082f57afbf5d2e8fd7fb67719336d78b58e759", "url": "https://api.github.com/repos/rust-lang/rust/commits/05082f57afbf5d2e8fd7fb67719336d78b58e759", "html_url": "https://github.com/rust-lang/rust/commit/05082f57afbf5d2e8fd7fb67719336d78b58e759"}], "stats": {"total": 96, "additions": 23, "deletions": 73}, "files": [{"sha": "32d0404bd07392077dd3f1182a6b543b82bcbda2", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4240a0bed0943cd3fa003e7951d91ab8a37ff8e3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4240a0bed0943cd3fa003e7951d91ab8a37ff8e3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=4240a0bed0943cd3fa003e7951d91ab8a37ff8e3", "patch": "@@ -59,8 +59,6 @@ struct ConstToPat<'tcx> {\n     // inference context used for checking `T: Structural` bounds.\n     infcx: InferCtxt<'tcx>,\n \n-    include_lint_checks: bool,\n-\n     treat_byte_string_as_slice: bool,\n }\n \n@@ -93,7 +91,6 @@ impl<'tcx> ConstToPat<'tcx> {\n             span,\n             infcx,\n             param_env: pat_ctxt.param_env,\n-            include_lint_checks: pat_ctxt.include_lint_checks,\n             saw_const_match_error: Cell::new(false),\n             saw_const_match_lint: Cell::new(false),\n             behind_reference: Cell::new(false),\n@@ -134,7 +131,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 })\n             });\n \n-        if self.include_lint_checks && !self.saw_const_match_error.get() {\n+        if !self.saw_const_match_error.get() {\n             // If we were able to successfully convert the const to some pat,\n             // double-check that all types in the const implement `Structural`.\n \n@@ -239,21 +236,19 @@ impl<'tcx> ConstToPat<'tcx> {\n \n         let kind = match cv.ty().kind() {\n             ty::Float(_) => {\n-                if self.include_lint_checks {\n                     tcx.emit_spanned_lint(\n                         lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                         id,\n                         span,\n                         FloatPattern,\n                     );\n-                }\n                 PatKind::Constant { value: cv }\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.saw_const_match_error.set(true);\n                 let err = UnionPattern { span };\n-                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             ty::Adt(..)\n@@ -267,7 +262,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             {\n                 self.saw_const_match_error.set(true);\n                 let err = TypeNotStructural { span, non_sm_ty };\n-                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             // If the type is not structurally comparable, just emit the constant directly,\n@@ -280,8 +275,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             // Backwards compatibility hack because we can't cause hard errors on these\n             // types, so we compare them via `PartialEq::eq` at runtime.\n             ty::Adt(..) if !self.type_marked_structural(cv.ty()) && self.behind_reference.get() => {\n-                if self.include_lint_checks\n-                    && !self.saw_const_match_error.get()\n+                if !self.saw_const_match_error.get()\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n@@ -305,7 +299,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 );\n                 self.saw_const_match_error.set(true);\n                 let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n-                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n@@ -339,7 +333,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 ty::Dynamic(..) => {\n                     self.saw_const_match_error.set(true);\n                     let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                    tcx.sess.emit_err(err);\n                     PatKind::Wild\n                 }\n                 // `&str` is represented as `ConstValue::Slice`, let's keep using this\n@@ -406,8 +400,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // to figure out how to get a reference again.\n                 ty::Adt(_, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n-                        if self.include_lint_checks\n-                            && !self.saw_const_match_error.get()\n+                        if !self.saw_const_match_error.get()\n                             && !self.saw_const_match_lint.get()\n                         {\n                            self.saw_const_match_lint.set(true);\n@@ -423,7 +416,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                         if !self.saw_const_match_error.get() {\n                             self.saw_const_match_error.set(true);\n                             let err = TypeNotStructural { span, non_sm_ty: *pointee_ty };\n-                            tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                            tcx.sess.emit_err(err);\n                         }\n                         PatKind::Wild\n                     }\n@@ -437,7 +430,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                         // (except slices, which are handled in a separate arm above).\n \n                         let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n-                        tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                        tcx.sess.emit_err(err);\n \n                         PatKind::Wild\n                     } else {\n@@ -465,8 +458,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             // compilation choices change the runtime behaviour of the match.\n             // See https://github.com/rust-lang/rust/issues/70861 for examples.\n             ty::FnPtr(..) | ty::RawPtr(..) => {\n-                if self.include_lint_checks\n-                    && !self.saw_const_match_error.get()\n+                if !self.saw_const_match_error.get()\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n@@ -482,13 +474,12 @@ impl<'tcx> ConstToPat<'tcx> {\n             _ => {\n                 self.saw_const_match_error.set(true);\n                 let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                    tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n         };\n \n-        if self.include_lint_checks\n-            && !self.saw_const_match_error.get()\n+        if !self.saw_const_match_error.get()\n             && !self.saw_const_match_lint.get()\n             && mir_structural_match_violation\n             // FIXME(#73448): Find a way to bring const qualification into parity with"}, {"sha": "70d015a39e4e2c716996c31d1f9fcfea9f565cb2", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 52, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4240a0bed0943cd3fa003e7951d91ab8a37ff8e3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4240a0bed0943cd3fa003e7951d91ab8a37ff8e3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=4240a0bed0943cd3fa003e7951d91ab8a37ff8e3", "patch": "@@ -31,20 +31,10 @@ use rustc_target::abi::FieldIdx;\n \n use std::cmp::Ordering;\n \n-#[derive(Clone, Debug)]\n-enum PatternError {\n-    AssocConstInPattern(Span),\n-    ConstParamInPattern(Span),\n-    StaticInPattern(Span),\n-    NonConstPath(Span),\n-}\n-\n struct PatCtxt<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n-    errors: Vec<PatternError>,\n-    include_lint_checks: bool,\n }\n \n pub(super) fn pat_from_hir<'a, 'tcx>(\n@@ -53,47 +43,13 @@ pub(super) fn pat_from_hir<'a, 'tcx>(\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     pat: &'tcx hir::Pat<'tcx>,\n ) -> Box<Pat<'tcx>> {\n-    let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n-    pcx.include_lint_checks();\n+    let mut pcx = PatCtxt { tcx, param_env, typeck_results };\n     let result = pcx.lower_pattern(pat);\n-    pcx.report_inlining_errors();\n     debug!(\"pat_from_hir({:?}) = {:?}\", pat, result);\n     result\n }\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n-    ) -> Self {\n-        PatCtxt { tcx, param_env, typeck_results, errors: vec![], include_lint_checks: false }\n-    }\n-\n-    fn include_lint_checks(&mut self) -> &mut Self {\n-        self.include_lint_checks = true;\n-        self\n-    }\n-\n-    fn report_inlining_errors(&self) {\n-        for error in &self.errors {\n-            match *error {\n-                PatternError::StaticInPattern(span) => {\n-                    self.tcx.sess.emit_err(StaticInPattern { span });\n-                }\n-                PatternError::AssocConstInPattern(span) => {\n-                    self.tcx.sess.emit_err(AssocConstInPattern { span });\n-                }\n-                PatternError::ConstParamInPattern(span) => {\n-                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n-                }\n-                PatternError::NonConstPath(span) => {\n-                    self.tcx.sess.emit_err(NonConstPath { span });\n-                }\n-            }\n-        }\n-    }\n-\n     fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n@@ -490,12 +446,15 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             | Res::SelfTyAlias { .. }\n             | Res::SelfCtor(..) => PatKind::Leaf { subpatterns },\n             _ => {\n-                let pattern_error = match res {\n-                    Res::Def(DefKind::ConstParam, _) => PatternError::ConstParamInPattern(span),\n-                    Res::Def(DefKind::Static(_), _) => PatternError::StaticInPattern(span),\n-                    _ => PatternError::NonConstPath(span),\n+                match res {\n+                    Res::Def(DefKind::ConstParam, _) => {\n+                        self.tcx.sess.emit_err(ConstParamInPattern { span })\n+                    }\n+                    Res::Def(DefKind::Static(_), _) => {\n+                        self.tcx.sess.emit_err(StaticInPattern { span })\n+                    }\n+                    _ => self.tcx.sess.emit_err(NonConstPath { span }),\n                 };\n-                self.errors.push(pattern_error);\n                 PatKind::Wild\n             }\n         };\n@@ -548,7 +507,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 // It should be assoc consts if there's no error but we cannot resolve it.\n                 debug_assert!(is_associated_const);\n \n-                self.errors.push(PatternError::AssocConstInPattern(span));\n+                self.tcx.sess.emit_err(AssocConstInPattern { span });\n \n                 return pat_from_kind(PatKind::Wild);\n             }\n@@ -626,7 +585,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         match value {\n             mir::ConstantKind::Ty(c) => match c.kind() {\n                 ConstKind::Param(_) => {\n-                    self.errors.push(PatternError::ConstParamInPattern(span));\n+                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n                     return PatKind::Wild;\n                 }\n                 ConstKind::Error(_) => {"}]}