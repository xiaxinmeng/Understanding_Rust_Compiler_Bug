{"sha": "58b53d1add5fb7cd6b73ac51e181bf56e41912e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YjUzZDFhZGQ1ZmI3Y2Q2YjczYWM1MWUxODFiZjU2ZTQxOTEyZTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-26T16:56:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-26T16:56:34Z"}, "message": "Rollup merge of #62120 - GuillaumeGomez:add-missing-type-links, r=Centril\n\nAdd missing type links in documentation\n\nr? @rust-lang/docs", "tree": {"sha": "46de69125809226ed5b43e8a04bc0557f1bc5f9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46de69125809226ed5b43e8a04bc0557f1bc5f9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58b53d1add5fb7cd6b73ac51e181bf56e41912e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdOzDDCRBK7hj4Ov3rIwAAdHIIAJ1QhRRHcysv5oUyyA20yNsp\nQkweyLxdU2sXjS8VryqvBmeRIRjVXLLpoqH9PiQ2mxZYctmveL3+MxpX21u+pwf6\n3O91RuDVHzY8wp47dKihLkJBHTujetVULt4Nu6b0UUQs8a5JdWl0+EwdhBqJBmTO\ny6eFbAeBuH3EH/E2RMgdPEAcR70DTWiEcibseoePtGhKPG5E1kD2mmBKiVbqvyPs\nJYreb54V4uhYXYtnopT7BaBFN+eLNprg2sviOGcAHV9V2f9rc+MoEilrKs2kX61f\nhijX/So/4HeLWou7bNkXq1i/ymZdKjOFAj00hwSovhpyn7eEiwwnkuv4FzR/ig8=\n=aPzW\n-----END PGP SIGNATURE-----\n", "payload": "tree 46de69125809226ed5b43e8a04bc0557f1bc5f9f\nparent 68d94bd7419eae23e17a7c59c5cb1ad197101ae9\nparent c8aa3c1d89706616232a5942f03e898bb0ae4733\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564160194 +0200\ncommitter GitHub <noreply@github.com> 1564160194 +0200\n\nRollup merge of #62120 - GuillaumeGomez:add-missing-type-links, r=Centril\n\nAdd missing type links in documentation\n\nr? @rust-lang/docs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58b53d1add5fb7cd6b73ac51e181bf56e41912e9", "html_url": "https://github.com/rust-lang/rust/commit/58b53d1add5fb7cd6b73ac51e181bf56e41912e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58b53d1add5fb7cd6b73ac51e181bf56e41912e9/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68d94bd7419eae23e17a7c59c5cb1ad197101ae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/68d94bd7419eae23e17a7c59c5cb1ad197101ae9", "html_url": "https://github.com/rust-lang/rust/commit/68d94bd7419eae23e17a7c59c5cb1ad197101ae9"}, {"sha": "c8aa3c1d89706616232a5942f03e898bb0ae4733", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8aa3c1d89706616232a5942f03e898bb0ae4733", "html_url": "https://github.com/rust-lang/rust/commit/c8aa3c1d89706616232a5942f03e898bb0ae4733"}], "stats": {"total": 144, "additions": 81, "deletions": 63}, "files": [{"sha": "2feaab7a09c9362d48d273244b7f69901cde7e92", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 81, "deletions": 63, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/58b53d1add5fb7cd6b73ac51e181bf56e41912e9/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b53d1add5fb7cd6b73ac51e181bf56e41912e9/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=58b53d1add5fb7cd6b73ac51e181bf56e41912e9", "patch": "@@ -11,13 +11,13 @@\n //! until it gets dropped. We say that the pointee is \"pinned\".\n //!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n-//! and common smart-pointer types such as `Box<T>` and `&mut T` allow replacing and\n-//! moving the values they contain: you can move out of a `Box<T>`, or you can use [`mem::swap`].\n-//! [`Pin<P>`] wraps a pointer type `P`, so `Pin<Box<T>>` functions much like a regular `Box<T>`:\n-//! when a `Pin<Box<T>>` gets dropped, so do its contents, and the memory gets deallocated.\n-//! Similarly, `Pin<&mut T>` is a lot like `&mut T`. However, [`Pin<P>`] does not let clients\n-//! actually obtain a `Box<T>` or `&mut T` to pinned data, which implies that you cannot use\n-//! operations such as [`mem::swap`]:\n+//! and common smart-pointer types such as [`Box<T>`] and `&mut T` allow replacing and\n+//! moving the values they contain: you can move out of a [`Box<T>`], or you can use [`mem::swap`].\n+//! [`Pin<P>`] wraps a pointer type `P`, so [`Pin`]`<`[`Box`]`<T>>` functions much like a regular\n+//! [`Box<T>`]: when a [`Pin`]`<`[`Box`]`<T>>` gets dropped, so do its contents, and the memory gets\n+//! deallocated. Similarly, [`Pin`]`<&mut T>` is a lot like `&mut T`. However, [`Pin<P>`] does\n+//! not let clients actually obtain a [`Box<T>`] or `&mut T` to pinned data, which implies that you\n+//! cannot use operations such as [`mem::swap`]:\n //!\n //! ```\n //! use std::pin::Pin;\n@@ -30,15 +30,15 @@\n //! ```\n //!\n //! It is worth reiterating that [`Pin<P>`] does *not* change the fact that a Rust compiler\n-//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, `Pin<P>`\n-//! prevents certain *values* (pointed to by pointers wrapped in `Pin<P>`) from being\n+//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, [`Pin<P>`]\n+//! prevents certain *values* (pointed to by pointers wrapped in [`Pin<P>`]) from being\n //! moved by making it impossible to call methods that require `&mut T` on them\n //! (like [`mem::swap`]).\n //!\n //! [`Pin<P>`] can be used to wrap any pointer type `P`, and as such it interacts with\n-//! [`Deref`] and [`DerefMut`]. A `Pin<P>` where `P: Deref` should be considered\n-//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a `Pin<Box<T>>` is\n-//! an owned pointer to a pinned `T`, and a `Pin<Rc<T>>` is a reference-counted\n+//! [`Deref`] and [`DerefMut`]. A [`Pin<P>`] where `P: Deref` should be considered\n+//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a [`Pin`]`<`[`Box`]`<T>>` is\n+//! an owned pointer to a pinned `T`, and a [`Pin`]`<`[`Rc`]`<T>>` is a reference-counted\n //! pointer to a pinned `T`.\n //! For correctness, [`Pin<P>`] relies on the implementations of [`Deref`] and\n //! [`DerefMut`] not to move out of their `self` parameter, and only ever to\n@@ -48,15 +48,15 @@\n //!\n //! Many types are always freely movable, even when pinned, because they do not\n //! rely on having a stable address. This includes all the basic types (like\n-//! `bool`, `i32`, and references) as well as types consisting solely of these\n+//! [`bool`], [`i32`], and references) as well as types consisting solely of these\n //! types. Types that do not care about pinning implement the [`Unpin`]\n //! auto-trait, which cancels the effect of [`Pin<P>`]. For `T: Unpin`,\n-//! `Pin<Box<T>>` and `Box<T>` function identically, as do `Pin<&mut T>` and\n+//! [`Pin`]`<`[`Box`]`<T>>` and [`Box<T>`] function identically, as do [`Pin`]`<&mut T>` and\n //! `&mut T`.\n //!\n-//! Note that pinning and `Unpin` only affect the pointed-to type `P::Target`, not the pointer\n-//! type `P` itself that got wrapped in `Pin<P>`. For example, whether or not `Box<T>` is\n-//! `Unpin` has no effect on the behavior of `Pin<Box<T>>` (here, `T` is the\n+//! Note that pinning and [`Unpin`] only affect the pointed-to type `P::Target`, not the pointer\n+//! type `P` itself that got wrapped in [`Pin<P>`]. For example, whether or not [`Box<T>`] is\n+//! [`Unpin`] has no effect on the behavior of [`Pin`]`<`[`Box`]`<T>>` (here, `T` is the\n //! pointed-to type).\n //!\n //! # Example: self-referential struct\n@@ -122,15 +122,15 @@\n //!\n //! To make this work, every element has pointers to its predecessor and successor in\n //! the list. Elements can only be added when they are pinned, because moving the elements\n-//! around would invalidate the pointers. Moreover, the `Drop` implementation of a linked\n+//! around would invalidate the pointers. Moreover, the [`Drop`] implementation of a linked\n //! list element will patch the pointers of its predecessor and successor to remove itself\n //! from the list.\n //!\n-//! Crucially, we have to be able to rely on `drop` being called. If an element\n-//! could be deallocated or otherwise invalidated without calling `drop`, the pointers into it\n+//! Crucially, we have to be able to rely on [`drop`] being called. If an element\n+//! could be deallocated or otherwise invalidated without calling [`drop`], the pointers into it\n //! from its neighbouring elements would become invalid, which would break the data structure.\n //!\n-//! Therefore, pinning also comes with a `drop`-related guarantee.\n+//! Therefore, pinning also comes with a [`drop`]-related guarantee.\n //!\n //! # `Drop` guarantee\n //!\n@@ -139,7 +139,7 @@\n //! otherwise invalidating the memory used to store the data is restricted, too.\n //! Concretely, for pinned data you have to maintain the invariant\n //! that *its memory will not get invalidated or repurposed from the moment it gets pinned until\n-//! when `drop` is called*. Memory can be invalidated by deallocation, but also by\n+//! when [`drop`] is called*. Memory can be invalidated by deallocation, but also by\n //! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n //! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n //! calling the destructor first.\n@@ -148,26 +148,27 @@\n //! section needs to function correctly.\n //!\n //! Notice that this guarantee does *not* mean that memory does not leak! It is still\n-//! completely okay not ever to call `drop` on a pinned element (e.g., you can still\n-//! call [`mem::forget`] on a `Pin<Box<T>>`). In the example of the doubly-linked\n+//! completely okay not ever to call [`drop`] on a pinned element (e.g., you can still\n+//! call [`mem::forget`] on a [`Pin`]`<`[`Box`]`<T>>`). In the example of the doubly-linked\n //! list, that element would just stay in the list. However you may not free or reuse the storage\n-//! *without calling `drop`*.\n+//! *without calling [`drop`]*.\n //!\n //! # `Drop` implementation\n //!\n //! If your type uses pinning (such as the two examples above), you have to be careful\n-//! when implementing `Drop`. The `drop` function takes `&mut self`, but this\n+//! when implementing [`Drop`]. The [`drop`] function takes `&mut self`, but this\n //! is called *even if your type was previously pinned*! It is as if the\n-//! compiler automatically called `get_unchecked_mut`.\n+//! compiler automatically called [`Pin::get_unchecked_mut`].\n //!\n //! This can never cause a problem in safe code because implementing a type that\n //! relies on pinning requires unsafe code, but be aware that deciding to make\n //! use of pinning in your type (for example by implementing some operation on\n-//! `Pin<&Self>` or `Pin<&mut Self>`) has consequences for your `Drop`\n+//! [`Pin`]`<&Self>` or [`Pin`]`<&mut Self>`) has consequences for your [`Drop`]\n //! implementation as well: if an element of your type could have been pinned,\n-//! you must treat Drop as implicitly taking `Pin<&mut Self>`.\n+//! you must treat [`Drop`] as implicitly taking [`Pin`]`<&mut Self>`.\n //!\n //! For example, you could implement `Drop` as follows:\n+//!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n //! # struct Type { }\n@@ -182,7 +183,8 @@\n //!     }\n //! }\n //! ```\n-//! The function `inner_drop` has the type that `drop` *should* have, so this makes sure that\n+//!\n+//! The function `inner_drop` has the type that [`drop`] *should* have, so this makes sure that\n //! you do not accidentally use `self`/`this` in a way that is in conflict with pinning.\n //!\n //! Moreover, if your type is `#[repr(packed)]`, the compiler will automatically\n@@ -192,18 +194,18 @@\n //! # Projections and Structural Pinning\n //!\n //! When working with pinned structs, the question arises how one can access the\n-//! fields of that struct in a method that takes just `Pin<&mut Struct>`.\n+//! fields of that struct in a method that takes just [`Pin`]`<&mut Struct>`.\n //! The usual approach is to write helper methods (so called *projections*)\n-//! that turn `Pin<&mut Struct>` into a reference to the field, but what\n-//! type should that reference have? Is it `Pin<&mut Field>` or `&mut Field`?\n+//! that turn [`Pin`]`<&mut Struct>` into a reference to the field, but what\n+//! type should that reference have? Is it [`Pin`]`<&mut Field>` or `&mut Field`?\n //! The same question arises with the fields of an `enum`, and also when considering\n //! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n //! (This question applies to both mutable and shared references, we just\n //! use the more common case of mutable references here for illustration.)\n //!\n //! It turns out that it is actually up to the author of the data structure\n //! to decide whether the pinned projection for a particular field turns\n-//! `Pin<&mut Struct>` into `Pin<&mut Field>` or `&mut Field`. There are some\n+//! [`Pin`]`<&mut Struct>` into [`Pin`]`<&mut Field>` or `&mut Field`. There are some\n //! constraints though, and the most important constraint is *consistency*:\n //! every field can be *either* projected to a pinned reference, *or* have\n //! pinning removed as part of the projection. If both are done for the same field,\n@@ -218,12 +220,13 @@\n //! ## Pinning *is not* structural for `field`\n //!\n //! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n-//! but that is actually the easiest choice: if a `Pin<&mut Field>` is never created,\n+//! but that is actually the easiest choice: if a [`Pin`]`<&mut Field>` is never created,\n //! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n //! all you have to ensure is that you never create a pinned reference to that field.\n //!\n //! Fields without structural pinning may have a projection method that turns\n-//! `Pin<&mut Struct>` into `&mut Field`:\n+//! [`Pin`]`<&mut Struct>` into `&mut Field`:\n+//!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n //! # type Field = i32;\n@@ -237,16 +240,17 @@\n //! ```\n //!\n //! You may also `impl Unpin for Struct` *even if* the type of `field`\n-//! is not `Unpin`. What that type thinks about pinning is not relevant\n-//! when no `Pin<&mut Field>` is ever created.\n+//! is not [`Unpin`]. What that type thinks about pinning is not relevant\n+//! when no [`Pin`]`<&mut Field>` is ever created.\n //!\n //! ## Pinning *is* structural for `field`\n //!\n //! The other option is to decide that pinning is \"structural\" for `field`,\n //! meaning that if the struct is pinned then so is the field.\n //!\n-//! This allows writing a projection that creates a `Pin<&mut Field>`, thus\n+//! This allows writing a projection that creates a [`Pin`]`<&mut Field>`, thus\n //! witnessing that the field is pinned:\n+//!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n //! # type Field = i32;\n@@ -262,30 +266,30 @@\n //! However, structural pinning comes with a few extra requirements:\n //!\n //! 1.  The struct must only be [`Unpin`] if all the structural fields are\n-//!     `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n+//!     [`Unpin`]. This is the default, but [`Unpin`] is a safe trait, so as the author of\n //!     the struct it is your responsibility *not* to add something like\n //!     `impl<T> Unpin for Struct<T>`. (Notice that adding a projection operation\n-//!     requires unsafe code, so the fact that `Unpin` is a safe trait does not break\n+//!     requires unsafe code, so the fact that [`Unpin`] is a safe trait does not break\n //!     the principle that you only have to worry about any of this if you use `unsafe`.)\n //! 2.  The destructor of the struct must not move structural fields out of its argument. This\n //!     is the exact point that was raised in the [previous section][drop-impl]: `drop` takes\n //!     `&mut self`, but the struct (and hence its fields) might have been pinned before.\n-//!     You have to guarantee that you do not move a field inside your `Drop` implementation.\n+//!     You have to guarantee that you do not move a field inside your [`Drop`] implementation.\n //!     In particular, as explained previously, this means that your struct must *not*\n //!     be `#[repr(packed)]`.\n-//!     See that section for how to write `drop` in a way that the compiler can help you\n+//!     See that section for how to write [`drop`] in a way that the compiler can help you\n //!     not accidentally break pinning.\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n //!     once your struct is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n-//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of `VecDeque<T>`\n-//!     can fail to call `drop` on all elements if one of the destructors panics. This violates the\n-//!     `Drop` guarantee, because it can lead to elements being deallocated without\n-//!     their destructor being called. (`VecDeque` has no pinning projections, so this\n+//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of [`VecDeque<T>`]\n+//!     can fail to call [`drop`] on all elements if one of the destructors panics. This violates\n+//!     the [`Drop`] guarantee, because it can lead to elements being deallocated without\n+//!     their destructor being called. ([`VecDeque<T>`] has no pinning projections, so this\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n //!     the structural fields when your type is pinned. For example, if the struct contains an\n-//!     `Option<T>` and there is a `take`-like operation with type\n+//!     [`Option<T>`] and there is a `take`-like operation with type\n //!     `fn(Pin<&mut Struct<T>>) -> Option<T>`,\n //!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n //!     pinning cannot be structural for the field holding this data.\n@@ -301,37 +305,39 @@\n //!         let content = &mut *b; // And here we have `&mut T` to the same data.\n //!     }\n //!     ```\n-//!     This is catastrophic, it means we can first pin the content of the `RefCell<T>`\n+//!     This is catastrophic, it means we can first pin the content of the [`RefCell<T>`]\n //!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n //!     reference we got later.\n //!\n //! ## Examples\n //!\n //! For a type like [`Vec<T>`], both possibilites (structural pinning or not) make sense.\n-//! A `Vec<T>` with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n+//! A [`Vec<T>`] with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n //! pinned references to elements. However, it could *not* allow calling\n-//! `pop` on a pinned `Vec<T>` because that would move the (structurally pinned) contents!\n-//! Nor could it allow `push`, which might reallocate and thus also move the contents.\n-//! A `Vec<T>` without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n-//! are never pinned and the `Vec<T>` itself is fine with being moved as well.\n+//! [`pop`][Vec::pop] on a pinned [`Vec<T>`] because that would move the (structurally pinned)\n+//! contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also move the\n+//! contents.\n+//!\n+//! A [`Vec<T>`] without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n+//! are never pinned and the [`Vec<T>`] itself is fine with being moved as well.\n //! At that point pinning just has no effect on the vector at all.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n //! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n //! It makes sense to do this for pointer types, because moving the `Box<T>`\n-//! does not actually move the `T`: the `Box<T>` can be freely movable (aka `Unpin`) even if the `T`\n-//! is not. In fact, even `Pin<Box<T>>` and `Pin<&mut T>` are always `Unpin` themselves,\n-//! for the same reason: their contents (the `T`) are pinned, but the pointers themselves\n-//! can be moved without moving the pinned data. For both `Box<T>` and `Pin<Box<T>>`,\n-//! whether the content is pinned is entirely independent of whether the pointer is\n-//! pinned, meaning pinning is *not* structural.\n+//! does not actually move the `T`: the [`Box<T>`] can be freely movable (aka `Unpin`) even if\n+//! the `T` is not. In fact, even [`Pin`]`<`[`Box`]`<T>>` and [`Pin`]`<&mut T>` are always\n+//! [`Unpin`] themselves, for the same reason: their contents (the `T`) are pinned, but the\n+//! pointers themselves can be moved without moving the pinned data. For both [`Box<T>`] and\n+//! [`Pin`]`<`[`Box`]`<T>>`, whether the content is pinned is entirely independent of whether the\n+//! pointer is pinned, meaning pinning is *not* structural.\n //!\n //! When implementing a [`Future`] combinator, you will usually need structural pinning\n-//! for the nested futures, as you need to get pinned references to them to call `poll`.\n+//! for the nested futures, as you need to get pinned references to them to call [`poll`].\n //! But if your combinator contains any other data that does not need to be pinned,\n //! you can make those fields not structural and hence freely access them with a\n-//! mutable reference even when you just have `Pin<&mut Self>` (such as in your own\n-//! `poll` implementation).\n+//! mutable reference even when you just have [`Pin`]`<&mut Self>` (such as in your own\n+//! [`poll`] implementation).\n //!\n //! [`Pin<P>`]: struct.Pin.html\n //! [`Unpin`]: ../marker/trait.Unpin.html\n@@ -342,6 +348,16 @@\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n //! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n //! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n+//! [`Pin`]: struct.Pin.html\n+//! [`Box`]: ../../std/boxed/struct.Box.html\n+//! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop\n+//! [Vec::push]: ../../std/vec/struct.Vec.html#method.push\n+//! [`Rc`]: ../../std/rc/struct.Rc.html\n+//! [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n+//! [`Drop`]: ../../std/ops/trait.Drop.html\n+//! [`drop`]: ../../std/ops/trait.Drop.html#tymethod.drop\n+//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n+//! [`Option<T>`]: ../../std/option/enum.Option.html\n //! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n //! [`RefCell<T>`]: ../cell/struct.RefCell.html\n //! [`None`]: ../option/enum.Option.html#variant.None\n@@ -350,6 +366,8 @@\n //! [`Future`]: ../future/trait.Future.html\n //! [drop-impl]: #drop-implementation\n //! [drop-guarantee]: #drop-guarantee\n+//! [`poll`]: ../../std/future/trait.Future.html#tymethod.poll\n+//! [`Pin::get_unchecked_mut`]: struct.Pin.html#method.get_unchecked_mut\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n "}]}