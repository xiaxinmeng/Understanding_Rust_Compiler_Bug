{"sha": "d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5OWI4MWY4MzllYzJiN2U0YTBlYjM3Yzk2YjQwZTZjNWIwNTBiNzI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-24T14:33:52Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-24T14:33:52Z"}, "message": "Expand derive macros under cursor in `Expand Macro Recursively`", "tree": {"sha": "df61391bfd3aa535b401f2fb0efcd123ad86e8ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df61391bfd3aa535b401f2fb0efcd123ad86e8ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "html_url": "https://github.com/rust-lang/rust/commit/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6287d388c0d9a1d89f333cad23b8fbb87607d0f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6287d388c0d9a1d89f333cad23b8fbb87607d0f6", "html_url": "https://github.com/rust-lang/rust/commit/6287d388c0d9a1d89f333cad23b8fbb87607d0f6"}], "stats": {"total": 92, "additions": 90, "deletions": 2}, "files": [{"sha": "b0435a4bacb444d0847a5fda0012a6b349b9791a", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "patch": "@@ -148,6 +148,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.expand_attr_macro(item)\n     }\n \n+    pub fn expand_derive_macro(&self, derive: &ast::Attr) -> Option<SyntaxNode> {\n+        self.imp.expand_derive_macro(derive)\n+    }\n+\n     pub fn is_attr_macro_call(&self, item: &ast::Item) -> bool {\n         self.imp.is_attr_macro_call(item)\n     }\n@@ -385,6 +389,18 @@ impl<'db> SemanticsImpl<'db> {\n         Some(node)\n     }\n \n+    fn expand_derive_macro(&self, attr: &ast::Attr) -> Option<SyntaxNode> {\n+        let item = attr.syntax().parent().and_then(ast::Item::cast)?;\n+        let sa = self.analyze(item.syntax());\n+        let item = InFile::new(sa.file_id, &item);\n+        let src = InFile::new(sa.file_id, attr.clone());\n+        let macro_call_id = self.with_ctx(|ctx| ctx.attr_to_derive_macro_call(item, src))?;\n+        let file_id = macro_call_id.as_file();\n+        let node = self.db.parse_or_expand(file_id)?;\n+        self.cache(node.clone(), file_id);\n+        Some(node)\n+    }\n+\n     fn is_attr_macro_call(&self, item: &ast::Item) -> bool {\n         let sa = self.analyze(item.syntax());\n         let src = InFile::new(sa.file_id, item.clone());"}, {"sha": "acf545816bd7a760fb0e4209d3d51465378bfc72", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "patch": "@@ -242,6 +242,15 @@ impl SourceToDefCtx<'_, '_> {\n         map[keys::ATTR_MACRO].get(&src).copied()\n     }\n \n+    pub(super) fn attr_to_derive_macro_call(\n+        &mut self,\n+        item: InFile<&ast::Item>,\n+        src: InFile<ast::Attr>,\n+    ) -> Option<MacroCallId> {\n+        let map = self.dyn_map(item)?;\n+        map[keys::DERIVE_MACRO].get(&src).copied()\n+    }\n+\n     fn to_def<Ast: AstNode + 'static, ID: Copy + 'static>(\n         &mut self,\n         src: InFile<Ast>,"}, {"sha": "feb6a88060a006b91622cc72b922ba31e0f87db4", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "patch": "@@ -6,6 +6,7 @@\n \n use either::Either;\n use hir_expand::HirFileId;\n+use syntax::ast::AttrsOwner;\n \n use crate::{\n     db::DefDatabase,\n@@ -108,6 +109,12 @@ impl ChildBySource for ItemScope {\n             let item = ast_id.with_value(ast_id.to_node(db.upcast()));\n             res[keys::ATTR_MACRO].insert(item, call_id);\n         });\n+        self.derive_macro_invocs().for_each(|(ast_id, (attr_id, call_id))| {\n+            let item = ast_id.to_node(db.upcast());\n+            if let Some(attr) = item.attrs().nth(attr_id.ast_index as usize) {\n+                res[keys::DERIVE_MACRO].insert(ast_id.with_value(attr), call_id);\n+            }\n+        });\n \n         fn add_module_def(\n             db: &dyn DefDatabase,"}, {"sha": "51586142e2276e924621c70ac09c040437baf5b2", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "patch": "@@ -12,8 +12,8 @@ use stdx::format_to;\n use syntax::ast;\n \n use crate::{\n-    db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ConstId, ImplId,\n-    LocalModuleId, MacroDefId, ModuleDefId, ModuleId, TraitId,\n+    attr::AttrId, db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType,\n+    ConstId, ImplId, LocalModuleId, MacroDefId, ModuleDefId, ModuleId, TraitId,\n };\n \n #[derive(Copy, Clone)]\n@@ -61,6 +61,7 @@ pub struct ItemScope {\n     // be all resolved to the last one defined if shadowing happens.\n     legacy_macros: FxHashMap<Name, MacroDefId>,\n     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,\n+    derive_macros: FxHashMap<AstId<ast::Item>, (AttrId, MacroCallId)>,\n }\n \n pub(crate) static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n@@ -182,6 +183,21 @@ impl ItemScope {\n         self.attr_macros.iter().map(|(k, v)| (*k, *v))\n     }\n \n+    pub(crate) fn add_derive_macro_invoc(\n+        &mut self,\n+        item: AstId<ast::Item>,\n+        call: MacroCallId,\n+        attr_id: AttrId,\n+    ) {\n+        self.derive_macros.insert(item, (attr_id, call));\n+    }\n+\n+    pub(crate) fn derive_macro_invocs(\n+        &self,\n+    ) -> impl Iterator<Item = (AstId<ast::Item>, (AttrId, MacroCallId))> + '_ {\n+        self.derive_macros.iter().map(|(k, v)| (*k, *v))\n+    }\n+\n     pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {\n         self.unnamed_trait_imports.get(&tr).copied()\n     }\n@@ -320,6 +336,7 @@ impl ItemScope {\n             unnamed_trait_imports,\n             legacy_macros,\n             attr_macros,\n+            derive_macros,\n         } = self;\n         types.shrink_to_fit();\n         values.shrink_to_fit();\n@@ -331,6 +348,7 @@ impl ItemScope {\n         unnamed_trait_imports.shrink_to_fit();\n         legacy_macros.shrink_to_fit();\n         attr_macros.shrink_to_fit();\n+        derive_macros.shrink_to_fit();\n     }\n }\n "}, {"sha": "ef0159350024fe050a9ff055fa51556b3f063893", "filename": "crates/hir_def/src/keys.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fkeys.rs?ref=d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "patch": "@@ -33,6 +33,7 @@ pub const CONST_PARAM: Key<ast::ConstParam, ConstParamId> = Key::new();\n \n pub const MACRO: Key<ast::MacroCall, MacroDefId> = Key::new();\n pub const ATTR_MACRO: Key<ast::Item, MacroCallId> = Key::new();\n+pub const DERIVE_MACRO: Key<ast::Attr, MacroCallId> = Key::new();\n \n /// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n /// equal if they point to exactly the same object."}, {"sha": "e9c33392f3c0c9d2370e73deadb4f18c6c9e9199", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "patch": "@@ -1047,6 +1047,12 @@ impl DefCollector<'_> {\n                         &resolver,\n                     ) {\n                         Ok(call_id) => {\n+                            self.def_map.modules[directive.module_id].scope.add_derive_macro_invoc(\n+                                ast_id.ast_id,\n+                                call_id,\n+                                *derive_attr,\n+                            );\n+\n                             resolved.push((directive.module_id, call_id, directive.depth));\n                             res = ReachedFixedPoint::No;\n                             return false;"}, {"sha": "363b77967c3d926627455ac4fb42600c9d41f59a", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=d99b81f839ec2b7e4a0eb37c96b40e6c5b050b72", "patch": "@@ -2,6 +2,7 @@ use std::iter;\n \n use hir::Semantics;\n use ide_db::{helpers::pick_best_token, RootDatabase};\n+use itertools::Itertools;\n use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxKind::*, SyntaxNode, WalkEvent, T};\n \n use crate::FilePosition;\n@@ -33,6 +34,18 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n     let mut expanded = None;\n     let mut name = None;\n     for node in tok.ancestors() {\n+        if let Some(attr) = ast::Attr::cast(node.clone()) {\n+            if let Some((path, tt)) = attr.as_simple_call() {\n+                if path == \"derive\" {\n+                    let mut tt = tt.syntax().children_with_tokens().skip(1).join(\"\");\n+                    tt.pop();\n+                    name = Some(tt);\n+                    expanded = sema.expand_derive_macro(&attr);\n+                    break;\n+                }\n+            }\n+        }\n+\n         if let Some(item) = ast::Item::cast(node.clone()) {\n             if let Some(def) = sema.resolve_attr_macro_call(&item) {\n                 name = def.name(db).map(|name| name.to_string());\n@@ -325,4 +338,22 @@ fn main() {\n                 0 \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn macro_expand_derive() {\n+        check(\n+            r#\"\n+\n+#[rustc_builtin_macro]\n+pub macro Clone {}\n+\n+#[derive(C$0lone)]\n+struct Foo {}\n+\"#,\n+            expect![[r#\"\n+                Clone\n+                impl< >crate::clone::Clone for Foo< >{}\n+            \"#]],\n+        );\n+    }\n }"}]}