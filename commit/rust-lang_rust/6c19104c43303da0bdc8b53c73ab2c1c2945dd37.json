{"sha": "6c19104c43303da0bdc8b53c73ab2c1c2945dd37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMTkxMDRjNDMzMDNkYTBiZGM4YjUzYzczYWIyYzFjMjk0NWRkMzc=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-03T03:34:46Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-10T17:47:06Z"}, "message": "Fix build\n\nAdditionally, revert unnecessary changes to ty::layout", "tree": {"sha": "4824ef41b43298d4e09fbb38c008bd8dd878e63d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4824ef41b43298d4e09fbb38c008bd8dd878e63d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c19104c43303da0bdc8b53c73ab2c1c2945dd37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c19104c43303da0bdc8b53c73ab2c1c2945dd37", "html_url": "https://github.com/rust-lang/rust/commit/6c19104c43303da0bdc8b53c73ab2c1c2945dd37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c19104c43303da0bdc8b53c73ab2c1c2945dd37/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb727a8faa08557d894506e2f95f2bfdc4996490", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb727a8faa08557d894506e2f95f2bfdc4996490", "html_url": "https://github.com/rust-lang/rust/commit/eb727a8faa08557d894506e2f95f2bfdc4996490"}], "stats": {"total": 39, "additions": 10, "deletions": 29}, "files": [{"sha": "74f2692629c67da65bfb6d70aec804b2d883f3cb", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 10, "deletions": 29, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6c19104c43303da0bdc8b53c73ab2c1c2945dd37/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c19104c43303da0bdc8b53c73ab2c1c2945dd37/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=6c19104c43303da0bdc8b53c73ab2c1c2945dd37", "patch": "@@ -382,25 +382,8 @@ impl Integer {\n         }\n     }\n \n-    pub fn to_attr(&self, signed: bool) -> attr::IntType {\n-        match (*self, signed) {\n-            (I1, false) => attr::IntType::UnsignedInt(UintTy::U8),\n-            (I8, false) => attr::IntType::UnsignedInt(UintTy::U8),\n-            (I16, false) => attr::IntType::UnsignedInt(UintTy::U16),\n-            (I32, false) => attr::IntType::UnsignedInt(UintTy::U32),\n-            (I64, false) => attr::IntType::UnsignedInt(UintTy::U64),\n-            (I128, false) => attr::IntType::UnsignedInt(UintTy::U128),\n-            (I1, true) => attr::IntType::SignedInt(IntTy::I8),\n-            (I8, true) => attr::IntType::SignedInt(IntTy::I8),\n-            (I16, true) => attr::IntType::SignedInt(IntTy::I16),\n-            (I32, true) => attr::IntType::SignedInt(IntTy::I32),\n-            (I64, true) => attr::IntType::SignedInt(IntTy::I64),\n-            (I128, true) => attr::IntType::SignedInt(IntTy::I128),\n-        }\n-    }\n-\n     /// Find the smallest Integer type which can represent the signed value.\n-    pub fn fit_signed(x: i128) -> Integer {\n+    pub fn fit_signed(x: i64) -> Integer {\n         match x {\n             -0x0000_0000_0000_0001...0x0000_0000_0000_0000 => I1,\n             -0x0000_0000_0000_0080...0x0000_0000_0000_007f => I8,\n@@ -412,7 +395,7 @@ impl Integer {\n     }\n \n     /// Find the smallest Integer type which can represent the unsigned value.\n-    pub fn fit_unsigned(x: u128) -> Integer {\n+    pub fn fit_unsigned(x: u64) -> Integer {\n         match x {\n             0...0x0000_0000_0000_0001 => I1,\n             0...0x0000_0000_0000_00ff => I8,\n@@ -453,13 +436,13 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    pub fn repr_discr(tcx: TyCtxt, ty: Ty, repr: &ReprOptions, min: i128, max: i128)\n+    fn repr_discr(tcx: TyCtxt, ty: Ty, repr: &ReprOptions, min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n         // are any negative values, the only valid unsigned representation is u64\n         // which can fit all i64 values, so the result remains unaffected.\n-        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u128, max as u128));\n+        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u64, max as u64));\n         let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n \n         let mut min_from_extern = None;\n@@ -487,6 +470,7 @@ impl Integer {\n         }\n \n         let at_least = min_from_extern.unwrap_or(min_default);\n+\n         // If there are no negative values, we can use the unsigned fit.\n         if min >= 0 {\n             (cmp::max(unsigned_fit, at_least), false)\n@@ -1198,21 +1182,17 @@ impl<'a, 'gcx, 'tcx> Layout {\n                                                             i64::min_value(),\n                                                             true);\n                     for v in &def.variants {\n-                        let x = match def.discr_ty {\n-                            attr::IntType::SignedInt(IntTy::I128) |\n-                            attr::IntType::UnsignedInt(UintTy::U128) =>\n-                                bug!(\"128-bit discriminants not yet supported\"),\n-                            attr::IntType::SignedInt(_) => v.disr_val as i64,\n-                            attr::IntType::UnsignedInt(_) => v.disr_val as u64 as i64,\n-                        };\n+                        let x = v.disr_val as i128 as i64;\n                         if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n                         if x > max { max = x; }\n                     }\n \n                     // FIXME: should handle i128? signed-value based impl is weird and hard to\n                     // grok.\n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, hints, min, max);\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..],\n+                                                              min,\n+                                                              max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n@@ -1330,6 +1310,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n                 let (min_ity, _) = Integer::repr_discr(tcx, ty, &hints[..], 0, discr_max);\n+\n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n "}]}