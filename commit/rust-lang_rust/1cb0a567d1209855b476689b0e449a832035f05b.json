{"sha": "1cb0a567d1209855b476689b0e449a832035f05b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYjBhNTY3ZDEyMDk4NTViNDc2Njg5YjBlNDQ5YTgzMjAzNWYwNWI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-27T12:59:52Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-27T14:20:42Z"}, "message": "Convert vec::{pop, shift, unshift, insert, remove, swap_remove} to methods.", "tree": {"sha": "25959163587a439594e4ee51ca1b1922b9cf1f64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25959163587a439594e4ee51ca1b1922b9cf1f64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cb0a567d1209855b476689b0e449a832035f05b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cb0a567d1209855b476689b0e449a832035f05b", "html_url": "https://github.com/rust-lang/rust/commit/1cb0a567d1209855b476689b0e449a832035f05b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cb0a567d1209855b476689b0e449a832035f05b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "html_url": "https://github.com/rust-lang/rust/commit/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5"}], "stats": {"total": 239, "additions": 103, "deletions": 136}, "files": [{"sha": "4622b8c7284841b2e065193796899580e3f6c374", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cb0a567d1209855b476689b0e449a832035f05b/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cb0a567d1209855b476689b0e449a832035f05b/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=1cb0a567d1209855b476689b0e449a832035f05b", "patch": "@@ -695,7 +695,6 @@ mod test_treemap {\n \n     use core::rand::RngUtil;\n     use core::rand;\n-    use core::vec;\n \n     #[test]\n     fn find_empty() {\n@@ -848,7 +847,7 @@ mod test_treemap {\n \n             for 30.times {\n                 let r = rng.gen_uint_range(0, ctrl.len());\n-                let (key, _) = vec::remove(&mut ctrl, r);\n+                let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);\n                 check_equal(ctrl, &map);"}, {"sha": "7cd64e863d2b1ddaeff76d31d94c772c78d47ddb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cb0a567d1209855b476689b0e449a832035f05b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cb0a567d1209855b476689b0e449a832035f05b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1cb0a567d1209855b476689b0e449a832035f05b", "patch": "@@ -4882,7 +4882,7 @@ impl Resolver {\n             values[smallest] <= max_distance &&\n             name != maybes[smallest] {\n \n-            Some(vec::swap_remove(&mut maybes, smallest))\n+            Some(maybes.swap_remove(smallest))\n \n         } else {\n             None"}, {"sha": "bc933e70b373332c2b20ea6228551fb62fb38eb7", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 101, "deletions": 133, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/1cb0a567d1209855b476689b0e449a832035f05b/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cb0a567d1209855b476689b0e449a832035f05b/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1cb0a567d1209855b476689b0e449a832035f05b", "patch": "@@ -377,96 +377,6 @@ pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     (lefts, rights)\n }\n \n-// Mutators\n-\n-/// Removes the first element from a vector and return it\n-pub fn shift<T>(v: &mut ~[T]) -> T {\n-    unsafe {\n-        assert!(!v.is_empty());\n-\n-        if v.len() == 1 { return v.pop() }\n-\n-        if v.len() == 2 {\n-            let last = v.pop();\n-            let first = v.pop();\n-            v.push(last);\n-            return first;\n-        }\n-\n-        let ln = v.len();\n-        let next_ln = v.len() - 1;\n-\n-        // Save the last element. We're going to overwrite its position\n-        let work_elt = v.pop();\n-        // We still should have room to work where what last element was\n-        assert!(capacity(v) >= ln);\n-        // Pretend like we have the original length so we can use\n-        // the vector copy_memory to overwrite the hole we just made\n-        raw::set_len(&mut *v, ln);\n-\n-        // Memcopy the head element (the one we want) to the location we just\n-        // popped. For the moment it unsafely exists at both the head and last\n-        // positions\n-        {\n-            let first_slice = v.slice(0, 1);\n-            let last_slice = v.slice(next_ln, ln);\n-            raw::copy_memory(transmute(last_slice), first_slice, 1);\n-        }\n-\n-        // Memcopy everything to the left one element\n-        {\n-            let init_slice = v.slice(0, next_ln);\n-            let tail_slice = v.slice(1, ln);\n-            raw::copy_memory(transmute(init_slice),\n-                             tail_slice,\n-                             next_ln);\n-        }\n-\n-        // Set the new length. Now the vector is back to normal\n-        raw::set_len(&mut *v, next_ln);\n-\n-        // Swap out the element we want from the end\n-        let vp = raw::to_mut_ptr(*v);\n-        let vp = ptr::mut_offset(vp, next_ln - 1);\n-\n-        ptr::replace_ptr(vp, work_elt)\n-    }\n-}\n-\n-/// Prepend an element to the vector\n-pub fn unshift<T>(v: &mut ~[T], x: T) {\n-    let vv = util::replace(v, ~[x]);\n-    v.push_all_move(vv);\n-}\n-\n-/// Insert an element at position i within v, shifting all\n-/// elements after position i one position to the right.\n-pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n-    let len = v.len();\n-    assert!(i <= len);\n-\n-    v.push(x);\n-    let mut j = len;\n-    while j > i {\n-        swap(*v, j, j - 1);\n-        j -= 1;\n-    }\n-}\n-\n-/// Remove and return the element at position i within v, shifting\n-/// all elements after position i one position to the left.\n-pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n-    let len = v.len();\n-    assert!(i < len);\n-\n-    let mut j = i;\n-    while j < len - 1 {\n-        swap(*v, j, j + 1);\n-        j += 1;\n-    }\n-    v.pop()\n-}\n-\n /// Consumes all elements, in a vector, moving them out into the / closure\n /// provided. The vector is traversed from the start to the end.\n ///\n@@ -528,37 +438,6 @@ pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n     }\n }\n \n-/// Remove the last element from a vector and return it\n-pub fn pop<T>(v: &mut ~[T]) -> T {\n-    let ln = v.len();\n-    if ln == 0 {\n-        fail!(\"sorry, cannot vec::pop an empty vector\")\n-    }\n-    let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n-    unsafe {\n-        let val = ptr::replace_ptr(valptr, intrinsics::init());\n-        raw::set_len(v, ln - 1u);\n-        val\n-    }\n-}\n-\n-/**\n- * Remove an element from anywhere in the vector and return it, replacing it\n- * with the last element. This does not preserve ordering, but is O(1).\n- *\n- * Fails if index >= length.\n- */\n-pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n-    let ln = v.len();\n-    if index >= ln {\n-        fail!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n-    }\n-    if index < ln - 1 {\n-        swap(*v, index, ln - 1);\n-    }\n-    v.pop()\n-}\n-\n /// Append an element to a vector\n #[inline]\n pub fn push<T>(v: &mut ~[T], initval: T) {\n@@ -1847,34 +1726,123 @@ impl<T> OwnedVector<T> for ~[T] {\n         push_all_move(self, rhs);\n     }\n \n-    #[inline]\n+    /// Remove the last element from a vector and return it\n     fn pop(&mut self) -> T {\n-        pop(self)\n+        let ln = self.len();\n+        if ln == 0 {\n+            fail!(\"sorry, cannot pop an empty vector\")\n+        }\n+        let valptr = ptr::to_mut_unsafe_ptr(&mut self[ln - 1u]);\n+        unsafe {\n+            let val = ptr::replace_ptr(valptr, intrinsics::init());\n+            raw::set_len(self, ln - 1u);\n+            val\n+        }\n     }\n \n-    #[inline]\n+    /// Removes the first element from a vector and return it\n     fn shift(&mut self) -> T {\n-        shift(self)\n+        unsafe {\n+            assert!(!self.is_empty());\n+\n+            if self.len() == 1 { return self.pop() }\n+\n+            if self.len() == 2 {\n+                let last = self.pop();\n+                let first = self.pop();\n+                self.push(last);\n+                return first;\n+            }\n+\n+            let ln = self.len();\n+            let next_ln = self.len() - 1;\n+\n+            // Save the last element. We're going to overwrite its position\n+            let work_elt = self.pop();\n+            // We still should have room to work where what last element was\n+            assert!(capacity(self) >= ln);\n+            // Pretend like we have the original length so we can use\n+            // the vector copy_memory to overwrite the hole we just made\n+            raw::set_len(self, ln);\n+\n+            // Memcopy the head element (the one we want) to the location we just\n+            // popped. For the moment it unsafely exists at both the head and last\n+            // positions\n+            {\n+                let first_slice = self.slice(0, 1);\n+                let last_slice = self.slice(next_ln, ln);\n+                raw::copy_memory(transmute(last_slice), first_slice, 1);\n+            }\n+\n+            // Memcopy everything to the left one element\n+            {\n+                let init_slice = self.slice(0, next_ln);\n+                let tail_slice = self.slice(1, ln);\n+                raw::copy_memory(transmute(init_slice),\n+                                 tail_slice,\n+                                 next_ln);\n+            }\n+\n+            // Set the new length. Now the vector is back to normal\n+            raw::set_len(self, next_ln);\n+\n+            // Swap out the element we want from the end\n+            let vp = raw::to_mut_ptr(*self);\n+            let vp = ptr::mut_offset(vp, next_ln - 1);\n+\n+            ptr::replace_ptr(vp, work_elt)\n+        }\n     }\n \n-    #[inline]\n+    /// Prepend an element to the vector\n     fn unshift(&mut self, x: T) {\n-        unshift(self, x)\n+        let v = util::replace(self, ~[x]);\n+        self.push_all_move(v);\n     }\n \n-    #[inline]\n+    /// Insert an element at position i within v, shifting all\n+    /// elements after position i one position to the right.\n     fn insert(&mut self, i: uint, x:T) {\n-        insert(self, i, x)\n+        let len = self.len();\n+        assert!(i <= len);\n+\n+        self.push(x);\n+        let mut j = len;\n+        while j > i {\n+            swap(*self, j, j - 1);\n+            j -= 1;\n+        }\n     }\n \n-    #[inline]\n+    /// Remove and return the element at position i within v, shifting\n+    /// all elements after position i one position to the left.\n     fn remove(&mut self, i: uint) -> T {\n-        remove(self, i)\n+        let len = self.len();\n+        assert!(i < len);\n+\n+        let mut j = i;\n+        while j < len - 1 {\n+            swap(*self, j, j + 1);\n+            j += 1;\n+        }\n+        self.pop()\n     }\n \n-    #[inline]\n+    /**\n+     * Remove an element from anywhere in the vector and return it, replacing it\n+     * with the last element. This does not preserve ordering, but is O(1).\n+     *\n+     * Fails if index >= length.\n+     */\n     fn swap_remove(&mut self, index: uint) -> T {\n-        swap_remove(self, index)\n+        let ln = self.len();\n+        if index >= ln {\n+            fail!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n+        }\n+        if index < ln - 1 {\n+            swap(*self, index, ln - 1);\n+        }\n+        self.pop()\n     }\n \n     #[inline]"}]}