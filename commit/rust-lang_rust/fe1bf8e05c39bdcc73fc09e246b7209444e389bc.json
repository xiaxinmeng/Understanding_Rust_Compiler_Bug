{"sha": "fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMWJmOGUwNWMzOWJkY2M3M2ZjMDllMjQ2YjcyMDk0NDRlMzg5YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-23T17:24:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-23T17:24:33Z"}, "message": "Auto merge of #82443 - Dylan-DPC:rollup-yni7uio, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #81629 (Point out implicit deref coercions in borrow)\n - #82113 (Improve non_fmt_panic lint.)\n - #82258 (Implement -Z hir-stats for nested foreign items)\n - #82296 (Support `pub` on `macro_rules`)\n - #82297 (Consider auto derefs before warning about write only fields)\n - #82305 (Remove many RefCells from DocContext)\n - #82308 (Lower condition of `if` expression before it's \"then\" block)\n - #82311 (Jsondocck improvements)\n - #82362 (Fix mir-cfg dumps)\n - #82391 (disable atomic_max/min tests in Miri)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9265dd81347434a5b0b6785222fa0b5901e43a1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9265dd81347434a5b0b6785222fa0b5901e43a1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "html_url": "https://github.com/rust-lang/rust/commit/fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "019610754363d1d92a8d0f364d2c0909d6f53dfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/019610754363d1d92a8d0f364d2c0909d6f53dfd", "html_url": "https://github.com/rust-lang/rust/commit/019610754363d1d92a8d0f364d2c0909d6f53dfd"}, {"sha": "51511c75b558beddab7fb4b6d8277a872714b87a", "url": "https://api.github.com/repos/rust-lang/rust/commits/51511c75b558beddab7fb4b6d8277a872714b87a", "html_url": "https://github.com/rust-lang/rust/commit/51511c75b558beddab7fb4b6d8277a872714b87a"}], "stats": {"total": 1317, "additions": 1160, "deletions": 157}, "files": [{"sha": "6d44feec2c4969f6095b557048460a7313e74550", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -347,8 +347,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         macro_rules! make_if {\n             ($opt:expr) => {{\n+                let cond = self.lower_expr(cond);\n                 let then_expr = self.lower_block_expr(then);\n-                hir::ExprKind::If(self.lower_expr(cond), self.arena.alloc(then_expr), $opt)\n+                hir::ExprKind::If(cond, self.arena.alloc(then_expr), $opt)\n             }};\n         }\n         if let Some(rslt) = else_opt {"}, {"sha": "474ec2b589b71496f240513fac1e74daba61e240", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -665,6 +665,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n         // involved, so we only emit errors where there are no other parsing errors.\n         gate_all!(destructuring_assignment, \"destructuring assignments are unstable\");\n     }\n+    gate_all!(pub_macro_rules, \"`pub` on `macro_rules` items is unstable\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "3f484ab5686521b85a4fa06de0ce5e94a6fcf0c4", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -638,6 +638,9 @@ declare_features! (\n     /// Allows macro attributes to observe output of `#[derive]`.\n     (active, macro_attributes_in_derive_output, \"1.51.0\", Some(81119), None),\n \n+    /// Allows `pub` on `macro_rules` items.\n+    (active, pub_macro_rules, \"1.52.0\", Some(78855), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "bfe37ce6959e7d59f56e8f6e520c48f473f05815", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 64, "deletions": 9, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -69,23 +69,65 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n \n     let (span, panic) = panic_call(cx, f);\n \n-    cx.struct_span_lint(NON_FMT_PANIC, arg.span, |lint| {\n+    // Find the span of the argument to `panic!()`, before expansion in the\n+    // case of `panic!(some_macro!())`.\n+    // We don't use source_callsite(), because this `panic!(..)` might itself\n+    // be expanded from another macro, in which case we want to stop at that\n+    // expansion.\n+    let mut arg_span = arg.span;\n+    let mut arg_macro = None;\n+    while !span.contains(arg_span) {\n+        let expn = arg_span.ctxt().outer_expn_data();\n+        if expn.is_root() {\n+            break;\n+        }\n+        arg_macro = expn.macro_def_id;\n+        arg_span = expn.call_site;\n+    }\n+\n+    cx.struct_span_lint(NON_FMT_PANIC, arg_span, |lint| {\n         let mut l = lint.build(\"panic message is not a string literal\");\n         l.note(\"this is no longer accepted in Rust 2021\");\n-        if span.contains(arg.span) {\n+        if !span.contains(arg_span) {\n+            // No clue where this argument is coming from.\n+            l.emit();\n+            return;\n+        }\n+        if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n+            // A case of `panic!(format!(..))`.\n+            l.note(\"the panic!() macro supports formatting, so there's no need for the format!() macro here\");\n+            if let Some((open, close, _)) = find_delimiters(cx, arg_span) {\n+                l.multipart_suggestion(\n+                    \"remove the `format!(..)` macro call\",\n+                    vec![\n+                        (arg_span.until(open.shrink_to_hi()), \"\".into()),\n+                        (close.until(arg_span.shrink_to_hi()), \"\".into()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        } else {\n             l.span_suggestion_verbose(\n-                arg.span.shrink_to_lo(),\n+                arg_span.shrink_to_lo(),\n                 \"add a \\\"{}\\\" format string to Display the message\",\n                 \"\\\"{}\\\", \".into(),\n                 Applicability::MaybeIncorrect,\n             );\n             if panic == sym::std_panic_macro {\n-                l.span_suggestion_verbose(\n-                    span.until(arg.span),\n-                    \"or use std::panic::panic_any instead\",\n-                    \"std::panic::panic_any(\".into(),\n-                    Applicability::MachineApplicable,\n-                );\n+                if let Some((open, close, del)) = find_delimiters(cx, span) {\n+                    l.multipart_suggestion(\n+                        \"or use std::panic::panic_any instead\",\n+                        if del == '(' {\n+                            vec![(span.until(open), \"std::panic::panic_any\".into())]\n+                        } else {\n+                            vec![\n+                                (span.until(open.shrink_to_hi()), \"std::panic::panic_any(\".into()),\n+                                (close, \")\".into()),\n+                            ]\n+                        },\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n             }\n         }\n         l.emit();\n@@ -175,6 +217,19 @@ fn check_panic_str<'tcx>(\n     }\n }\n \n+/// Given the span of `some_macro!(args);`, gives the span of `(` and `)`,\n+/// and the type of (opening) delimiter used.\n+fn find_delimiters<'tcx>(cx: &LateContext<'tcx>, span: Span) -> Option<(Span, Span, char)> {\n+    let snippet = cx.sess().parse_sess.source_map().span_to_snippet(span).ok()?;\n+    let (open, open_ch) = snippet.char_indices().find(|&(_, c)| \"([{\".contains(c))?;\n+    let close = snippet.rfind(|c| \")]}\".contains(c))?;\n+    Some((\n+        span.from_inner(InnerSpan { start: open, end: open + 1 }),\n+        span.from_inner(InnerSpan { start: close, end: close + 1 }),\n+        open_ch,\n+    ))\n+}\n+\n fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span, Symbol) {\n     let mut expn = f.span.ctxt().outer_expn_data();\n "}, {"sha": "b0b58a8d003678219cf2c421884db091854a5d92", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -8,11 +8,10 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n     FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n-    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_param, Ty};\n-use rustc_span::source_map::DesugaringKind;\n-use rustc_span::Span;\n+use rustc_middle::ty::{self, suggest_constraining_type_param, Instance, Ty};\n+use rustc_span::{source_map::DesugaringKind, symbol::sym, Span};\n \n use crate::dataflow::drop_flag_effects;\n use crate::dataflow::indexes::{MoveOutIndex, MovePathIndex};\n@@ -1543,9 +1542,43 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             None,\n         );\n \n+        self.explain_deref_coercion(loan, &mut err);\n+\n         err.buffer(&mut self.errors_buffer);\n     }\n \n+    fn explain_deref_coercion(&mut self, loan: &BorrowData<'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+        let tcx = self.infcx.tcx;\n+        if let (\n+            Some(Terminator { kind: TerminatorKind::Call { from_hir_call: false, .. }, .. }),\n+            Some((method_did, method_substs)),\n+        ) = (\n+            &self.body[loan.reserve_location.block].terminator,\n+            crate::util::find_self_call(\n+                tcx,\n+                self.body,\n+                loan.assigned_place.local,\n+                loan.reserve_location.block,\n+            ),\n+        ) {\n+            if tcx.is_diagnostic_item(sym::deref_method, method_did) {\n+                let deref_target =\n+                    tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n+                        Instance::resolve(tcx, self.param_env, deref_target, method_substs)\n+                            .transpose()\n+                    });\n+                if let Some(Ok(instance)) = deref_target {\n+                    let deref_target_ty = instance.ty(tcx, self.param_env);\n+                    err.note(&format!(\n+                        \"borrow occurs due to deref coercion to `{}`\",\n+                        deref_target_ty\n+                    ));\n+                    err.span_note(tcx.def_span(instance.def_id()), \"deref defined here\");\n+                }\n+            }\n+        }\n+    }\n+\n     /// Reports an illegal reassignment; for example, an assignment to\n     /// (part of) a non-`mut` local that occurs potentially after that\n     /// local has already been initialized. `place` is the path being"}, {"sha": "92c7a358c0a41d59b9552a99ede510c04f0f0f84", "filename": "compiler/rustc_mir/src/util/graphviz.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -2,7 +2,7 @@ use gsgdt::GraphvizSettings;\n use rustc_graphviz as dot;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{self, TyCtxt};\n use std::fmt::Debug;\n use std::io::{self, Write};\n \n@@ -16,14 +16,27 @@ where\n {\n     let def_ids = dump_mir_def_ids(tcx, single);\n \n-    let use_subgraphs = def_ids.len() > 1;\n+    let mirs =\n+        def_ids\n+            .iter()\n+            .flat_map(|def_id| {\n+                if tcx.is_const_fn_raw(*def_id) {\n+                    vec![tcx.optimized_mir(*def_id), tcx.mir_for_ctfe(*def_id)]\n+                } else {\n+                    vec![tcx.instance_mir(ty::InstanceDef::Item(ty::WithOptConstParam::unknown(\n+                        *def_id,\n+                    )))]\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+    let use_subgraphs = mirs.len() > 1;\n     if use_subgraphs {\n         writeln!(w, \"digraph __crate__ {{\")?;\n     }\n \n-    for def_id in def_ids {\n-        let body = &tcx.optimized_mir(def_id);\n-        write_mir_fn_graphviz(tcx, body, use_subgraphs, w)?;\n+    for mir in mirs {\n+        write_mir_fn_graphviz(tcx, mir, use_subgraphs, w)?;\n     }\n \n     if use_subgraphs {"}, {"sha": "073a2d8bd512006d06968457d1bd01e2d43457c5", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -1475,15 +1475,7 @@ impl<'a> Parser<'a> {\n         let vstr = pprust::vis_to_string(vis);\n         let vstr = vstr.trim_end();\n         if macro_rules {\n-            let msg = format!(\"can't qualify macro_rules invocation with `{}`\", vstr);\n-            self.struct_span_err(vis.span, &msg)\n-                .span_suggestion(\n-                    vis.span,\n-                    \"try exporting the macro\",\n-                    \"#[macro_export]\".to_owned(),\n-                    Applicability::MaybeIncorrect, // speculative\n-                )\n-                .emit();\n+            self.sess.gated_spans.gate(sym::pub_macro_rules, vis.span);\n         } else {\n             self.struct_span_err(vis.span, \"can't qualify macro invocation with `pub`\")\n                 .span_suggestion("}, {"sha": "62a95aa57c29f66399a1a138ff7adb15f7cac0d8", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -37,15 +37,6 @@ fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     )\n }\n \n-fn base_expr<'a>(mut expr: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n-    loop {\n-        match expr.kind {\n-            hir::ExprKind::Field(base, ..) => expr = base,\n-            _ => return expr,\n-        }\n-    }\n-}\n-\n struct MarkSymbolVisitor<'tcx> {\n     worklist: Vec<hir::HirId>,\n     tcx: TyCtxt<'tcx>,\n@@ -143,6 +134,22 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         }\n     }\n \n+    fn handle_assign(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n+        if self\n+            .typeck_results()\n+            .expr_adjustments(expr)\n+            .iter()\n+            .any(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n+        {\n+            self.visit_expr(expr);\n+        } else if let hir::ExprKind::Field(base, ..) = expr.kind {\n+            // Ignore write to field\n+            self.handle_assign(base);\n+        } else {\n+            self.visit_expr(expr);\n+        }\n+    }\n+\n     fn handle_field_pattern_match(\n         &mut self,\n         lhs: &hir::Pat<'_>,\n@@ -272,8 +279,7 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n                 self.lookup_and_handle_method(expr.hir_id);\n             }\n             hir::ExprKind::Assign(ref left, ref right, ..) => {\n-                // Ignore write to field\n-                self.visit_expr(base_expr(left));\n+                self.handle_assign(left);\n                 self.visit_expr(right);\n                 return;\n             }"}, {"sha": "a2b6dd17ad9ba011520fbc0812819e1acecc75ef", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -114,6 +114,11 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.visit_impl_item(nested_impl_item)\n     }\n \n+    fn visit_nested_foreign_item(&mut self, id: hir::ForeignItemId) {\n+        let nested_foreign_item = self.krate.unwrap().foreign_item(id);\n+        self.visit_foreign_item(nested_foreign_item);\n+    }\n+\n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n         let nested_body = self.krate.unwrap().body(body_id);\n         self.visit_body(nested_body)"}, {"sha": "65e5b0dddea30f9a175f003ca67d03c1242a69cf", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -1230,13 +1230,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         };\n \n         let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id.to_def_id());\n+        let is_macro_export = self.r.session.contains_name(&item.attrs, sym::macro_export);\n         self.r.macro_map.insert(def_id.to_def_id(), ext);\n         self.r.local_macro_def_scopes.insert(def_id, parent_scope.module);\n \n-        if macro_rules {\n+        if macro_rules && matches!(item.vis.kind, ast::VisibilityKind::Inherited) {\n             let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n-            let is_macro_export = self.r.session.contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1261,6 +1261,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 }),\n             ))\n         } else {\n+            if is_macro_export {\n+                let what = if macro_rules { \"`macro_rules` with `pub`\" } else { \"`macro` items\" };\n+                let msg = format!(\"`#[macro_export]` cannot be used on {what}\");\n+                self.r.session.span_err(item.span, &msg);\n+            }\n             let module = parent_scope.module;\n             let vis = match item.kind {\n                 // Visibilities must not be resolved non-speculatively twice"}, {"sha": "b112402ffe37136728dbee3772356b1fd694765a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -560,6 +560,7 @@ symbols! {\n         format_args,\n         format_args_capture,\n         format_args_nl,\n+        format_macro,\n         freeze,\n         freg,\n         frem_fast,\n@@ -880,6 +881,7 @@ symbols! {\n         ptr_guaranteed_eq,\n         ptr_guaranteed_ne,\n         ptr_offset_from,\n+        pub_macro_rules,\n         pub_restricted,\n         pure,\n         pushpop_unsafe,"}, {"sha": "6a64587a2237fb7059ef3af6a5770b04c481ee6a", "filename": "library/alloc/src/macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/library%2Falloc%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/library%2Falloc%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fmacros.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -107,6 +107,7 @@ macro_rules! vec {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"format_macro\")]\n macro_rules! format {\n     ($($arg:tt)*) => {{\n         let res = $crate::fmt::format($crate::__export::format_args!($($arg)*));"}, {"sha": "539982eb0e49f9579944c099cad85198e757783e", "filename": "library/core/tests/atomic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/library%2Fcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/library%2Fcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fatomic.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -61,6 +61,7 @@ fn uint_xor() {\n \n #[test]\n #[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+#[cfg_attr(miri, ignore)] // FIXME: Miri does not support atomic_min\n fn uint_min() {\n     let x = AtomicUsize::new(0xf731);\n     assert_eq!(x.fetch_min(0x137f, SeqCst), 0xf731);\n@@ -71,6 +72,7 @@ fn uint_min() {\n \n #[test]\n #[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+#[cfg_attr(miri, ignore)] // FIXME: Miri does not support atomic_max\n fn uint_max() {\n     let x = AtomicUsize::new(0x137f);\n     assert_eq!(x.fetch_max(0xf731, SeqCst), 0x137f);\n@@ -109,6 +111,7 @@ fn int_xor() {\n \n #[test]\n #[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+#[cfg_attr(miri, ignore)] // FIXME: Miri does not support atomic_min\n fn int_min() {\n     let x = AtomicIsize::new(0xf731);\n     assert_eq!(x.fetch_min(0x137f, SeqCst), 0xf731);\n@@ -119,6 +122,7 @@ fn int_min() {\n \n #[test]\n #[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+#[cfg_attr(miri, ignore)] // FIXME: Miri does not support atomic_max\n fn int_max() {\n     let x = AtomicIsize::new(0x137f);\n     assert_eq!(x.fetch_max(0xf731, SeqCst), 0x137f);"}, {"sha": "a24cb0a0f93a1ece262be2ff118b163a99933c3e", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     ) -> Option<Item> {\n         let tcx = self.cx.tcx;\n         let trait_ref = ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(ty, &[]) };\n-        if !self.cx.generated_synthetics.borrow_mut().insert((ty, trait_def_id)) {\n+        if !self.cx.generated_synthetics.insert((ty, trait_def_id)) {\n             debug!(\"get_auto_trait_impl_for({:?}): already generated, aborting\", trait_ref);\n             return None;\n         }"}, {"sha": "94b82037e75e9ab2126101cd30008cbb5f11fb55", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -22,8 +22,8 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         debug!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n         for &trait_def_id in self.cx.tcx.all_traits(LOCAL_CRATE).iter() {\n-            if !self.cx.renderinfo.borrow().access_levels.is_public(trait_def_id)\n-                || self.cx.generated_synthetics.borrow_mut().get(&(ty, trait_def_id)).is_some()\n+            if !self.cx.renderinfo.access_levels.is_public(trait_def_id)\n+                || self.cx.generated_synthetics.get(&(ty, trait_def_id)).is_some()\n             {\n                 continue;\n             }\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     return;\n                 }\n \n-                self.cx.generated_synthetics.borrow_mut().insert((ty, trait_def_id));\n+                self.cx.generated_synthetics.insert((ty, trait_def_id));\n                 let provided_trait_methods = self\n                     .cx\n                     .tcx"}, {"sha": "ea75d1614bd806bb2dc1386b3feb0720f3c775a7", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -122,7 +122,7 @@ crate fn try_inline(\n     let target_attrs = load_attrs(cx, did);\n     let attrs = box merge_attrs(cx, Some(parent_module), target_attrs, attrs_clone);\n \n-    cx.renderinfo.borrow_mut().inlined.insert(did);\n+    cx.renderinfo.inlined.insert(did);\n     let what_rustc_thinks = clean::Item::from_def_id_and_parts(did, Some(name), kind, cx);\n     ret.push(clean::Item { attrs, ..what_rustc_thinks });\n     Some(ret)\n@@ -156,7 +156,7 @@ crate fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n-crate fn record_extern_fqn(cx: &DocContext<'_>, did: DefId, kind: clean::TypeKind) {\n+crate fn record_extern_fqn(cx: &mut DocContext<'_>, did: DefId, kind: clean::TypeKind) {\n     let crate_name = cx.tcx.crate_name(did.krate).to_string();\n \n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n@@ -181,9 +181,9 @@ crate fn record_extern_fqn(cx: &DocContext<'_>, did: DefId, kind: clean::TypeKin\n     };\n \n     if did.is_local() {\n-        cx.renderinfo.borrow_mut().exact_paths.insert(did, fqn);\n+        cx.renderinfo.exact_paths.insert(did, fqn);\n     } else {\n-        cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n+        cx.renderinfo.external_paths.insert(did, (fqn, kind));\n     }\n }\n \n@@ -317,7 +317,7 @@ crate fn build_impl(\n     attrs: Option<Attrs<'_>>,\n     ret: &mut Vec<clean::Item>,\n ) {\n-    if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n+    if !cx.renderinfo.inlined.insert(did) {\n         return;\n     }\n \n@@ -329,7 +329,7 @@ crate fn build_impl(\n     if !did.is_local() {\n         if let Some(traitref) = associated_trait {\n             let did = traitref.def_id;\n-            if !cx.renderinfo.borrow().access_levels.is_public(did) {\n+            if !cx.renderinfo.access_levels.is_public(did) {\n                 return;\n             }\n \n@@ -361,7 +361,7 @@ crate fn build_impl(\n     // reachable in rustdoc generated documentation\n     if !did.is_local() {\n         if let Some(did) = for_.def_id() {\n-            if !cx.renderinfo.borrow().access_levels.is_public(did) {\n+            if !cx.renderinfo.access_levels.is_public(did) {\n                 return;\n             }\n \n@@ -613,20 +613,19 @@ crate fn record_extern_trait(cx: &mut DocContext<'_>, did: DefId) {\n     }\n \n     {\n-        if cx.external_traits.borrow().contains_key(&did)\n-            || cx.active_extern_traits.borrow().contains(&did)\n+        if cx.external_traits.borrow().contains_key(&did) || cx.active_extern_traits.contains(&did)\n         {\n             return;\n         }\n     }\n \n     {\n-        cx.active_extern_traits.borrow_mut().insert(did);\n+        cx.active_extern_traits.insert(did);\n     }\n \n     debug!(\"record_extern_trait: {:?}\", did);\n     let trait_ = build_external_trait(cx, did);\n \n     cx.external_traits.borrow_mut().insert(did, trait_);\n-    cx.active_extern_traits.borrow_mut().remove(&did);\n+    cx.active_extern_traits.remove(&did);\n }"}, {"sha": "b6e7046210596a41d41e7391d6de895eb8f89ab6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -357,7 +357,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n                 | rl::Region::LateBound(_, node_id, _)\n                 | rl::Region::Free(_, node_id),\n             ) => {\n-                if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n+                if let Some(lt) = cx.lt_substs.get(&node_id).cloned() {\n                     return lt;\n                 }\n             }\n@@ -644,7 +644,7 @@ impl Clean<Generics> for hir::Generics<'_> {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => unreachable!(),\n                     GenericParamDefKind::Type { did, ref bounds, .. } => {\n-                        cx.impl_trait_bounds.borrow_mut().insert(did.into(), bounds.clone());\n+                        cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n                     }\n                     GenericParamDefKind::Const { .. } => unreachable!(),\n                 }\n@@ -803,7 +803,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                 unreachable!();\n             }\n \n-            cx.impl_trait_bounds.borrow_mut().insert(param, bounds);\n+            cx.impl_trait_bounds.insert(param, bounds);\n         }\n \n         // Now that `cx.impl_trait_bounds` is populated, we can process\n@@ -1291,10 +1291,10 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     match qpath {\n         hir::QPath::Resolved(None, ref path) => {\n             if let Res::Def(DefKind::TyParam, did) = path.res {\n-                if let Some(new_ty) = cx.ty_substs.borrow().get(&did).cloned() {\n+                if let Some(new_ty) = cx.ty_substs.get(&did).cloned() {\n                     return new_ty;\n                 }\n-                if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did.into()) {\n+                if let Some(bounds) = cx.impl_trait_bounds.remove(&did.into()) {\n                     return ImplTrait(bounds);\n                 }\n             }\n@@ -1304,7 +1304,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 // Substitute private type aliases\n                 if let Some(def_id) = def_id.as_local() {\n                     let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n-                    if !cx.renderinfo.borrow().access_levels.is_exported(def_id.to_def_id()) {\n+                    if !cx.renderinfo.access_levels.is_exported(def_id.to_def_id()) {\n                         alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n                     }\n                 }\n@@ -1651,7 +1651,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::Projection(ref data) => data.clean(cx),\n \n             ty::Param(ref p) => {\n-                if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&p.index.into()) {\n+                if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n                     ImplTrait(bounds)\n                 } else {\n                     Generic(p.name)"}, {"sha": "d2eee49f0c968305243892cf00dac5f6a3713ceb", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -23,10 +23,9 @@ crate fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n     let krate = cx.tcx.hir().krate();\n     let module = crate::visit_ast::RustdocVisitor::new(&mut cx).visit(krate);\n \n-    let mut r = cx.renderinfo.get_mut();\n-    r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n-    r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n-    r.owned_box_did = cx.tcx.lang_items().owned_box();\n+    cx.renderinfo.deref_trait_did = cx.tcx.lang_items().deref_trait();\n+    cx.renderinfo.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n+    cx.renderinfo.owned_box_did = cx.tcx.lang_items().owned_box();\n \n     let mut externs = Vec::new();\n     for &cnum in cx.tcx.crates().iter() {\n@@ -494,10 +493,10 @@ crate fn enter_impl_trait<F, R>(cx: &mut DocContext<'_>, f: F) -> R\n where\n     F: FnOnce(&mut DocContext<'_>) -> R,\n {\n-    let old_bounds = mem::take(&mut *cx.impl_trait_bounds.get_mut());\n+    let old_bounds = mem::take(&mut cx.impl_trait_bounds);\n     let r = f(cx);\n-    assert!(cx.impl_trait_bounds.borrow().is_empty());\n-    *cx.impl_trait_bounds.get_mut() = old_bounds;\n+    assert!(cx.impl_trait_bounds.is_empty());\n+    cx.impl_trait_bounds = old_bounds;\n     r\n }\n "}, {"sha": "8fceb00eeae513b1a9b5feed85fc4b78dbac0e87", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -42,32 +42,37 @@ crate type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n crate struct DocContext<'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n+    /// Name resolver. Used for intra-doc links.\n+    ///\n+    /// The `Rc<RefCell<...>>` wrapping is needed because that is what's returned by\n+    /// [`Queries::expansion()`].\n+    // FIXME: see if we can get rid of this RefCell somehow\n     crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n     /// Used for normalization.\n     ///\n     /// Most of this logic is copied from rustc_lint::late.\n     crate param_env: ParamEnv<'tcx>,\n     /// Later on moved into `cache`\n-    crate renderinfo: RefCell<RenderInfo>,\n+    crate renderinfo: RenderInfo,\n     /// Later on moved through `clean::Crate` into `cache`\n     crate external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n-    crate active_extern_traits: RefCell<FxHashSet<DefId>>,\n+    crate active_extern_traits: FxHashSet<DefId>,\n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n     /// Table `DefId` of type parameter -> substituted type\n-    crate ty_substs: RefCell<FxHashMap<DefId, clean::Type>>,\n+    crate ty_substs: FxHashMap<DefId, clean::Type>,\n     /// Table `DefId` of lifetime parameter -> substituted lifetime\n-    crate lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n+    crate lt_substs: FxHashMap<DefId, clean::Lifetime>,\n     /// Table `DefId` of const parameter -> substituted const\n-    crate ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n+    crate ct_substs: FxHashMap<DefId, clean::Constant>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n-    crate impl_trait_bounds: RefCell<FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>>,\n+    crate impl_trait_bounds: FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>,\n     crate fake_def_ids: FxHashMap<CrateNum, DefIndex>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n-    crate generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n+    crate generated_synthetics: FxHashSet<(Ty<'tcx>, DefId)>,\n     crate auto_traits: Vec<DefId>,\n     /// The options given to rustdoc that could be relevant to a pass.\n     crate render_options: RenderOptions,\n@@ -112,14 +117,14 @@ impl<'tcx> DocContext<'tcx> {\n         F: FnOnce(&mut Self) -> R,\n     {\n         let (old_tys, old_lts, old_cts) = (\n-            mem::replace(&mut *self.ty_substs.get_mut(), ty_substs),\n-            mem::replace(&mut *self.lt_substs.get_mut(), lt_substs),\n-            mem::replace(&mut *self.ct_substs.get_mut(), ct_substs),\n+            mem::replace(&mut self.ty_substs, ty_substs),\n+            mem::replace(&mut self.lt_substs, lt_substs),\n+            mem::replace(&mut self.ct_substs, ct_substs),\n         );\n         let r = f(self);\n-        *self.ty_substs.get_mut() = old_tys;\n-        *self.lt_substs.get_mut() = old_lts;\n-        *self.ct_substs.get_mut() = old_cts;\n+        self.ty_substs = old_tys;\n+        self.lt_substs = old_lts;\n+        self.ct_substs = old_cts;\n         r\n     }\n \n@@ -509,7 +514,7 @@ crate fn run_global_ctxt(\n         param_env: ParamEnv::empty(),\n         external_traits: Default::default(),\n         active_extern_traits: Default::default(),\n-        renderinfo: RefCell::new(renderinfo),\n+        renderinfo,\n         ty_substs: Default::default(),\n         lt_substs: Default::default(),\n         ct_substs: Default::default(),\n@@ -642,7 +647,7 @@ crate fn run_global_ctxt(\n     // The main crate doc comments are always collapsed.\n     krate.collapsed = true;\n \n-    (krate, ctxt.renderinfo.into_inner(), ctxt.render_options)\n+    (krate, ctxt.renderinfo, ctxt.render_options)\n }\n \n /// Due to <https://github.com/rust-lang/rust/pull/73566>,"}, {"sha": "c3365b844ecb8352a405b70449691dfbaf29463e", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'b> CoverageCalculator<'a, 'b> {\n     }\n \n     fn print_results(&self) {\n-        let output_format = self.ctx.renderinfo.borrow().output_format;\n+        let output_format = self.ctx.renderinfo.output_format;\n         if output_format.is_json() {\n             println!(\"{}\", self.to_json());\n             return;"}, {"sha": "0271a5b78a7efa32fe10ab2b2a9ce832d768f510", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -48,11 +48,10 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n                 if !cx.tcx.get_attrs(def_id).lists(sym::doc).has_word(sym::hidden) {\n                     let self_ty = cx.tcx.type_of(def_id);\n                     let impls = get_auto_trait_and_blanket_impls(cx, self_ty, def_id);\n-                    let mut renderinfo = cx.renderinfo.borrow_mut();\n \n-                    new_items.extend(impls.filter(|i| renderinfo.inlined.insert(i.def_id)));\n+                    new_items.extend(impls.filter(|i| cx.renderinfo.inlined.insert(i.def_id)));\n                 }\n-            })\n+            });\n         }\n     }\n "}, {"sha": "e8e1bead84fb61ca7c895a9e0d09bfb5b53fc157", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -97,8 +97,7 @@ crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n                 |lint| lint.build(\"missing code example in this documentation\").emit(),\n             );\n         }\n-    } else if tests.found_tests > 0 && !cx.renderinfo.borrow().access_levels.is_public(item.def_id)\n-    {\n+    } else if tests.found_tests > 0 && !cx.renderinfo.access_levels.is_public(item.def_id) {\n         cx.tcx.struct_span_lint_hir(\n             lint::builtin::PRIVATE_DOC_TESTS,\n             hir_id,"}, {"sha": "f83eab6799ee66e38a1cba38639a1ea9727580c0", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -17,7 +17,7 @@ crate const STRIP_PRIVATE: Pass = Pass {\n crate fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet::default();\n-    let access_levels = cx.renderinfo.borrow().access_levels.clone();\n+    let access_levels = cx.renderinfo.access_levels.clone();\n \n     // strip all private items\n     {"}, {"sha": "4d42c181d8cf26d22c4b3a341bb19458a22ddf45", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             assert_eq!(cur_mod_def_id, macro_parent_def_id);\n             cur_mod.macros.push((def, None));\n         }\n-        self.cx.renderinfo.get_mut().exact_paths = self.exact_paths;\n+        self.cx.renderinfo.exact_paths = self.exact_paths;\n         top_level_module\n     }\n \n@@ -199,12 +199,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     } else {\n                         // All items need to be handled here in case someone wishes to link\n                         // to them with intra-doc links\n-                        self.cx\n-                            .renderinfo\n-                            .get_mut()\n-                            .access_levels\n-                            .map\n-                            .insert(did, AccessLevel::Public);\n+                        self.cx.renderinfo.access_levels.map.insert(did, AccessLevel::Public);\n                     }\n                 }\n             }\n@@ -216,7 +211,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => return false,\n         };\n \n-        let is_private = !self.cx.renderinfo.borrow().access_levels.is_public(res_did);\n+        let is_private = !self.cx.renderinfo.access_levels.is_public(res_did);\n         let is_hidden = inherits_doc_hidden(self.cx, res_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped."}, {"sha": "daed5bd107db16f468033e38652d59d6b8af04f0", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n     crate fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n             tcx: cx.tcx,\n-            access_levels: &mut cx.renderinfo.get_mut().access_levels,\n+            access_levels: &mut cx.renderinfo.access_levels,\n             prev_level: Some(AccessLevel::Public),\n             visited_mods: FxHashSet::default(),\n         }"}, {"sha": "a3d4935f49614a1474fcc22d539dddff9c1cb7b9", "filename": "src/test/rustdoc-json/nested.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Frustdoc-json%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Frustdoc-json%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fnested.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -1,24 +1,28 @@\n // edition:2018\n \n-// @has nested.json \"$.index[*][?(@.name=='nested')].kind\" \\\"module\\\"\n-// @has - \"$.index[*][?(@.name=='nested')].inner.is_crate\" true\n+// @is nested.json \"$.index[*][?(@.name=='nested')].kind\" \\\"module\\\"\n+// @is - \"$.index[*][?(@.name=='nested')].inner.is_crate\" true\n // @count - \"$.index[*][?(@.name=='nested')].inner.items[*]\" 1\n \n-// @has nested.json \"$.index[*][?(@.name=='l1')].kind\" \\\"module\\\"\n-// @has - \"$.index[*][?(@.name=='l1')].inner.is_crate\" false\n+// @is nested.json \"$.index[*][?(@.name=='l1')].kind\" \\\"module\\\"\n+// @is - \"$.index[*][?(@.name=='l1')].inner.is_crate\" false\n // @count - \"$.index[*][?(@.name=='l1')].inner.items[*]\" 2\n pub mod l1 {\n \n-    // @has nested.json \"$.index[*][?(@.name=='l3')].kind\" \\\"module\\\"\n-    // @has - \"$.index[*][?(@.name=='l3')].inner.is_crate\" false\n+    // @is nested.json \"$.index[*][?(@.name=='l3')].kind\" \\\"module\\\"\n+    // @is - \"$.index[*][?(@.name=='l3')].inner.is_crate\" false\n     // @count - \"$.index[*][?(@.name=='l3')].inner.items[*]\" 1\n+    // @set l3_id = - \"$.index[*][?(@.name=='l3')].id\"\n+    // @has - \"$.index[*][?(@.name=='l1')].inner.items[*]\" $l3_id\n     pub mod l3 {\n \n-        // @has nested.json \"$.index[*][?(@.name=='L4')].kind\" \\\"struct\\\"\n-        // @has - \"$.index[*][?(@.name=='L4')].inner.struct_type\" \\\"unit\\\"\n+        // @is nested.json \"$.index[*][?(@.name=='L4')].kind\" \\\"struct\\\"\n+        // @is - \"$.index[*][?(@.name=='L4')].inner.struct_type\" \\\"unit\\\"\n+        // @set l4_id = - \"$.index[*][?(@.name=='L4')].id\"\n+        // @has - \"$.index[*][?(@.name=='l3')].inner.items[*]\" $l4_id\n         pub struct L4;\n     }\n-    // @has nested.json \"$.index[*][?(@.inner.span=='l3::L4')].kind\" \\\"import\\\"\n-    // @has - \"$.index[*][?(@.inner.span=='l3::L4')].inner.glob\" false\n+    // @is nested.json \"$.index[*][?(@.inner.span=='l3::L4')].kind\" \\\"import\\\"\n+    // @is - \"$.index[*][?(@.inner.span=='l3::L4')].inner.glob\" false\n     pub use l3::L4;\n }"}, {"sha": "8e212a77016470c4c93ed4937d3944014ca4c6e9", "filename": "src/test/ui/borrowck/issue-81365-1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-1.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,26 @@\n+use std::ops::Deref;\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+impl Container {\n+    fn bad_borrow(&mut self) {\n+        let first = &self.target_field;\n+        self.container_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ef88d7f14a39bdd9f1321cc5eeb692528b4dbe2d", "filename": "src/test/ui/borrowck/issue-81365-1.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-1.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+error[E0506]: cannot assign to `self.container_field` because it is borrowed\n+  --> $DIR/issue-81365-1.rs:21:9\n+   |\n+LL |         let first = &self.target_field;\n+   |                      ---- borrow of `self.container_field` occurs here\n+LL |         self.container_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.container_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+   |\n+   = note: borrow occurs due to deref coercion to `DerefTarget`\n+note: deref defined here\n+  --> $DIR/issue-81365-1.rs:12:5\n+   |\n+LL |     type Target = DerefTarget;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "7602e184a9f9d4f2a76e0fc28e8dc397547480a8", "filename": "src/test/ui/borrowck/issue-81365-10.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-10.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,26 @@\n+use std::ops::Deref;\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+impl Container {\n+    fn bad_borrow(&mut self) {\n+        let first = &self.deref().target_field;\n+        self.container_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "891f70ed7f6b46b8a987f57897a3b3c9d3efd9ea", "filename": "src/test/ui/borrowck/issue-81365-10.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-10.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-10.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-10.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,13 @@\n+error[E0506]: cannot assign to `self.container_field` because it is borrowed\n+  --> $DIR/issue-81365-10.rs:21:9\n+   |\n+LL |         let first = &self.deref().target_field;\n+   |                      ---- borrow of `self.container_field` occurs here\n+LL |         self.container_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.container_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "6b558c65d3d614250c4c86fff089715ad9e2a185", "filename": "src/test/ui/borrowck/issue-81365-11.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-11.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,32 @@\n+use std::ops::{Deref, DerefMut};\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+impl DerefMut for Container {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.target\n+    }\n+}\n+\n+impl Container {\n+    fn bad_borrow(&mut self) {\n+        let first = &mut self.target_field;\n+        self.container_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0770c136632db1f9603c2d6ef0e68ab8c6331a5e", "filename": "src/test/ui/borrowck/issue-81365-11.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-11.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-11.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-11.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,13 @@\n+error[E0506]: cannot assign to `self.container_field` because it is borrowed\n+  --> $DIR/issue-81365-11.rs:27:9\n+   |\n+LL |         let first = &mut self.target_field;\n+   |                          ---- borrow of `self.container_field` occurs here\n+LL |         self.container_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.container_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "fbbdd93b97cc86b839c372ec1d84a82d608397d5", "filename": "src/test/ui/borrowck/issue-81365-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-2.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,30 @@\n+use std::ops::Deref;\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+struct Outer {\n+    container: Container,\n+}\n+\n+impl Outer {\n+    fn bad_borrow(&mut self) {\n+        let first = &self.container.target_field;\n+        self.container.container_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e71edb509649fde9a0be83ee79ef1ec51e63a28b", "filename": "src/test/ui/borrowck/issue-81365-2.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-2.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+error[E0506]: cannot assign to `self.container.container_field` because it is borrowed\n+  --> $DIR/issue-81365-2.rs:25:9\n+   |\n+LL |         let first = &self.container.target_field;\n+   |                      -------------- borrow of `self.container.container_field` occurs here\n+LL |         self.container.container_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.container.container_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+   |\n+   = note: borrow occurs due to deref coercion to `DerefTarget`\n+note: deref defined here\n+  --> $DIR/issue-81365-2.rs:12:5\n+   |\n+LL |     type Target = DerefTarget;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "9a9e3a31358223da0329f5f350714a00dbb6fa94", "filename": "src/test/ui/borrowck/issue-81365-3.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-3.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,37 @@\n+use std::ops::Deref;\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+struct Outer {\n+    container: Container,\n+}\n+\n+impl Deref for Outer {\n+    type Target = Container;\n+    fn deref(&self) -> &Self::Target {\n+        &self.container\n+    }\n+}\n+\n+impl Outer {\n+    fn bad_borrow(&mut self) {\n+        let first = &self.target_field;\n+        self.container.container_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "70bb6bb93a94b17ddb84f933e0eb975646c4e9d0", "filename": "src/test/ui/borrowck/issue-81365-3.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-3.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+error[E0506]: cannot assign to `self.container.container_field` because it is borrowed\n+  --> $DIR/issue-81365-3.rs:32:9\n+   |\n+LL |         let first = &self.target_field;\n+   |                      ---- borrow of `self.container.container_field` occurs here\n+LL |         self.container.container_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.container.container_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+   |\n+   = note: borrow occurs due to deref coercion to `Container`\n+note: deref defined here\n+  --> $DIR/issue-81365-3.rs:23:5\n+   |\n+LL |     type Target = Container;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "b2643eb3358ac58bfe3590a55e97d225c012907c", "filename": "src/test/ui/borrowck/issue-81365-4.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-4.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,38 @@\n+use std::ops::Deref;\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+struct Outer {\n+    container: Container,\n+    outer_field: bool,\n+}\n+\n+impl Deref for Outer {\n+    type Target = Container;\n+    fn deref(&self) -> &Self::Target {\n+        &self.container\n+    }\n+}\n+\n+impl Outer {\n+    fn bad_borrow(&mut self) {\n+        let first = &self.target_field;\n+        self.outer_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e714bb86d1cd2d666718c2cd2961f1ab8be22444", "filename": "src/test/ui/borrowck/issue-81365-4.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-4.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+error[E0506]: cannot assign to `self.outer_field` because it is borrowed\n+  --> $DIR/issue-81365-4.rs:33:9\n+   |\n+LL |         let first = &self.target_field;\n+   |                      ---- borrow of `self.outer_field` occurs here\n+LL |         self.outer_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.outer_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+   |\n+   = note: borrow occurs due to deref coercion to `Container`\n+note: deref defined here\n+  --> $DIR/issue-81365-4.rs:24:5\n+   |\n+LL |     type Target = Container;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "d36b79615e3ad1b90342d076270bba7e424e4c8c", "filename": "src/test/ui/borrowck/issue-81365-5.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-5.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,33 @@\n+use std::ops::Deref;\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+\n+impl DerefTarget {\n+    fn get(&self) -> &bool {\n+        &self.target_field\n+    }\n+}\n+\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+impl Container {\n+    fn bad_borrow(&mut self) {\n+        let first = self.get();\n+        self.container_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7c0e9f43bd0b087eda7e3cc52ac3910a81766ffc", "filename": "src/test/ui/borrowck/issue-81365-5.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-5.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+error[E0506]: cannot assign to `self.container_field` because it is borrowed\n+  --> $DIR/issue-81365-5.rs:28:9\n+   |\n+LL |         let first = self.get();\n+   |                     ---- borrow of `self.container_field` occurs here\n+LL |         self.container_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.container_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+   |\n+   = note: borrow occurs due to deref coercion to `DerefTarget`\n+note: deref defined here\n+  --> $DIR/issue-81365-5.rs:19:5\n+   |\n+LL |     type Target = DerefTarget;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "85ea77756b3bae25871a92fa74b785fc383f389f", "filename": "src/test/ui/borrowck/issue-81365-6.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-6.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,23 @@\n+use std::ops::Deref;\n+\n+struct Container {\n+    target: Vec<()>,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = [()];\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+impl Container {\n+    fn bad_borrow(&mut self) {\n+        let first = &self[0];\n+        self.container_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "85ed6acca3d41a6f68a543822f0d52680e9a9760", "filename": "src/test/ui/borrowck/issue-81365-6.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-6.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+error[E0506]: cannot assign to `self.container_field` because it is borrowed\n+  --> $DIR/issue-81365-6.rs:18:9\n+   |\n+LL |         let first = &self[0];\n+   |                      ---- borrow of `self.container_field` occurs here\n+LL |         self.container_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.container_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+   |\n+   = note: borrow occurs due to deref coercion to `[()]`\n+note: deref defined here\n+  --> $DIR/issue-81365-6.rs:9:5\n+   |\n+LL |     type Target = [()];\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "cbf70f11a9acfaf0f42edad0d0778d3b62654fd7", "filename": "src/test/ui/borrowck/issue-81365-7.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-7.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,24 @@\n+use std::ops::Deref;\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+fn bad_borrow(c: &mut Container) {\n+    let first = &c.target_field;\n+    c.container_field = true; //~ ERROR E0506\n+    first;\n+}\n+\n+fn main() {}"}, {"sha": "506732ec0c5b491e53beac1d01442847903b3aee", "filename": "src/test/ui/borrowck/issue-81365-7.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-7.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+error[E0506]: cannot assign to `c.container_field` because it is borrowed\n+  --> $DIR/issue-81365-7.rs:20:5\n+   |\n+LL |     let first = &c.target_field;\n+   |                  - borrow of `c.container_field` occurs here\n+LL |     c.container_field = true;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `c.container_field` occurs here\n+LL |     first;\n+   |     ----- borrow later used here\n+   |\n+   = note: borrow occurs due to deref coercion to `DerefTarget`\n+note: deref defined here\n+  --> $DIR/issue-81365-7.rs:12:5\n+   |\n+LL |     type Target = DerefTarget;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "0bb1033fb42f71f000501a954e5bad63c729eba3", "filename": "src/test/ui/borrowck/issue-81365-8.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-8.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,26 @@\n+use std::ops::Deref;\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+impl Container {\n+    fn bad_borrow(&mut self) {\n+        let first = &(*self).target_field;\n+        self.container_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "716b6e9b51fd02a12d02feb32646f407f48da34c", "filename": "src/test/ui/borrowck/issue-81365-8.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-8.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+error[E0506]: cannot assign to `self.container_field` because it is borrowed\n+  --> $DIR/issue-81365-8.rs:21:9\n+   |\n+LL |         let first = &(*self).target_field;\n+   |                      ------- borrow of `self.container_field` occurs here\n+LL |         self.container_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.container_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+   |\n+   = note: borrow occurs due to deref coercion to `DerefTarget`\n+note: deref defined here\n+  --> $DIR/issue-81365-8.rs:12:5\n+   |\n+LL |     type Target = DerefTarget;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "cd57afa288df77208986ebeb1195f10d9efe7dc1", "filename": "src/test/ui/borrowck/issue-81365-9.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-9.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,26 @@\n+use std::ops::Deref;\n+\n+struct DerefTarget {\n+    target_field: bool,\n+}\n+struct Container {\n+    target: DerefTarget,\n+    container_field: bool,\n+}\n+\n+impl Deref for Container {\n+    type Target = DerefTarget;\n+    fn deref(&self) -> &Self::Target {\n+        &self.target\n+    }\n+}\n+\n+impl Container {\n+    fn bad_borrow(&mut self) {\n+        let first = &Deref::deref(self).target_field;\n+        self.container_field = true; //~ ERROR E0506\n+        first;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c7d48214fd4a81bb9abeaf08aa9b8f6b983a8074", "filename": "src/test/ui/borrowck/issue-81365-9.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-9.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-9.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81365-9.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,13 @@\n+error[E0506]: cannot assign to `self.container_field` because it is borrowed\n+  --> $DIR/issue-81365-9.rs:21:9\n+   |\n+LL |         let first = &Deref::deref(self).target_field;\n+   |                                   ---- borrow of `self.container_field` occurs here\n+LL |         self.container_field = true;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `self.container_field` occurs here\n+LL |         first;\n+   |         ----- borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "c5393703f70919687a92b223d99b6bb6f244453c", "filename": "src/test/ui/did_you_mean/pub-macro-rules.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/019610754363d1d92a8d0f364d2c0909d6f53dfd/src%2Ftest%2Fui%2Fdid_you_mean%2Fpub-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019610754363d1d92a8d0f364d2c0909d6f53dfd/src%2Ftest%2Fui%2Fdid_you_mean%2Fpub-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fpub-macro-rules.rs?ref=019610754363d1d92a8d0f364d2c0909d6f53dfd", "patch": "@@ -1,16 +0,0 @@\n-#[macro_use] mod bleh {\n-    pub macro_rules! foo { //~ ERROR can't qualify macro_rules invocation\n-        ($n:ident) => (\n-            fn $n () -> i32 {\n-                1\n-            }\n-        )\n-    }\n-\n-}\n-\n-foo!(meh);\n-\n-fn main() {\n-    println!(\"{}\", meh());\n-}"}, {"sha": "0bde5783b8cc615e1784c6f31e491dbbeb1882b5", "filename": "src/test/ui/did_you_mean/pub-macro-rules.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/019610754363d1d92a8d0f364d2c0909d6f53dfd/src%2Ftest%2Fui%2Fdid_you_mean%2Fpub-macro-rules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/019610754363d1d92a8d0f364d2c0909d6f53dfd/src%2Ftest%2Fui%2Fdid_you_mean%2Fpub-macro-rules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fpub-macro-rules.stderr?ref=019610754363d1d92a8d0f364d2c0909d6f53dfd", "patch": "@@ -1,8 +0,0 @@\n-error: can't qualify macro_rules invocation with `pub`\n-  --> $DIR/pub-macro-rules.rs:2:5\n-   |\n-LL |     pub macro_rules! foo {\n-   |     ^^^ help: try exporting the macro: `#[macro_export]`\n-\n-error: aborting due to previous error\n-"}, {"sha": "5504ec317ae59d597ff40b03308b645a6ce0b492", "filename": "src/test/ui/feature-gates/feature-gate-pub_macro_rules.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pub_macro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pub_macro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pub_macro_rules.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,10 @@\n+pub macro_rules! m1 { () => {} } //~ ERROR `pub` on `macro_rules` items is unstable\n+\n+#[cfg(FALSE)]\n+pub macro_rules! m2 { () => {} } //~ ERROR `pub` on `macro_rules` items is unstable\n+\n+pub(crate) macro_rules! m3 { () => {} } //~ ERROR `pub` on `macro_rules` items is unstable\n+\n+pub(in self) macro_rules! m4 { () => {} } //~ ERROR `pub` on `macro_rules` items is unstable\n+\n+fn main() {}"}, {"sha": "bfaec398d9a976fc58587b6aec8d4350a392abc2", "filename": "src/test/ui/feature-gates/feature-gate-pub_macro_rules.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pub_macro_rules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pub_macro_rules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-pub_macro_rules.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,39 @@\n+error[E0658]: `pub` on `macro_rules` items is unstable\n+  --> $DIR/feature-gate-pub_macro_rules.rs:1:1\n+   |\n+LL | pub macro_rules! m1 { () => {} }\n+   | ^^^\n+   |\n+   = note: see issue #78855 <https://github.com/rust-lang/rust/issues/78855> for more information\n+   = help: add `#![feature(pub_macro_rules)]` to the crate attributes to enable\n+\n+error[E0658]: `pub` on `macro_rules` items is unstable\n+  --> $DIR/feature-gate-pub_macro_rules.rs:4:1\n+   |\n+LL | pub macro_rules! m2 { () => {} }\n+   | ^^^\n+   |\n+   = note: see issue #78855 <https://github.com/rust-lang/rust/issues/78855> for more information\n+   = help: add `#![feature(pub_macro_rules)]` to the crate attributes to enable\n+\n+error[E0658]: `pub` on `macro_rules` items is unstable\n+  --> $DIR/feature-gate-pub_macro_rules.rs:6:1\n+   |\n+LL | pub(crate) macro_rules! m3 { () => {} }\n+   | ^^^^^^^^^^\n+   |\n+   = note: see issue #78855 <https://github.com/rust-lang/rust/issues/78855> for more information\n+   = help: add `#![feature(pub_macro_rules)]` to the crate attributes to enable\n+\n+error[E0658]: `pub` on `macro_rules` items is unstable\n+  --> $DIR/feature-gate-pub_macro_rules.rs:8:1\n+   |\n+LL | pub(in self) macro_rules! m4 { () => {} }\n+   | ^^^^^^^^^^^^\n+   |\n+   = note: see issue #78855 <https://github.com/rust-lang/rust/issues/78855> for more information\n+   = help: add `#![feature(pub_macro_rules)]` to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "8938b8a6f2c52856bca6e94da4ca7d1f77fec7a3", "filename": "src/test/ui/issues/issue-81918.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fissues%2Fissue-81918.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fissues%2Fissue-81918.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-81918.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// dont-check-compiler-stdout\n+// compile-flags: -Z unpretty=mir-cfg\n+\n+// This checks that unpretty=mir-cfg does not panic. See #81918.\n+\n+const TAG: &'static str = \"ABCD\";\n+\n+fn main() {\n+    if TAG == \"\" {}\n+}"}, {"sha": "7b3f1e9f5b6cb89e4f88042e1c43df9a48a3a7b9", "filename": "src/test/ui/lint/dead-code/write-only-field.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fwrite-only-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fwrite-only-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fwrite-only-field.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -17,4 +17,53 @@ fn field_write(s: &mut S) {\n fn main() {\n     let mut s = S { f: 0, sub: Sub { f: 0 } };\n     field_write(&mut s);\n+\n+    auto_deref();\n+    nested_boxes();\n+}\n+\n+fn auto_deref() {\n+    struct E {\n+        x: bool,\n+        y: bool, //~ ERROR: field is never read\n+    }\n+\n+    struct P<'a> {\n+        e: &'a mut E\n+    }\n+\n+    impl P<'_> {\n+        fn f(&mut self) {\n+            self.e.x = true;\n+            self.e.y = true;\n+        }\n+    }\n+\n+    let mut e = E { x: false, y: false };\n+    let mut p = P { e: &mut e };\n+    p.f();\n+    assert!(e.x);\n+}\n+\n+fn nested_boxes() {\n+    struct A {\n+        b: Box<B>,\n+    }\n+\n+    struct B {\n+        c: Box<C>,\n+    }\n+\n+    struct C {\n+        u: u32, //~ ERROR: field is never read\n+        v: u32, //~ ERROR: field is never read\n+    }\n+\n+    let mut a = A {\n+        b: Box::new(B {\n+            c: Box::new(C { u: 0, v: 0 }),\n+        }),\n+    };\n+    a.b.c.v = 10;\n+    a.b.c = Box::new(C { u: 1, v: 2 });\n }"}, {"sha": "a191d22c8b94cfe317507529ccb818d0080a0b9a", "filename": "src/test/ui/lint/dead-code/write-only-field.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fwrite-only-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fwrite-only-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fwrite-only-field.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -22,5 +22,23 @@ error: field is never read: `f`\n LL |     f: i32,\n    |     ^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: field is never read: `y`\n+  --> $DIR/write-only-field.rs:28:9\n+   |\n+LL |         y: bool,\n+   |         ^^^^^^^\n+\n+error: field is never read: `u`\n+  --> $DIR/write-only-field.rs:58:9\n+   |\n+LL |         u: u32,\n+   |         ^^^^^^\n+\n+error: field is never read: `v`\n+  --> $DIR/write-only-field.rs:59:9\n+   |\n+LL |         v: u32,\n+   |         ^^^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "467c6ba7b78e4caa60eaf32ea917dc6f0b00cf91", "filename": "src/test/ui/macros/macro-export-on-modularized-macros.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fmacro-export-on-modularized-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fmacro-export-on-modularized-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-export-on-modularized-macros.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,11 @@\n+#![feature(decl_macro)]\n+#![feature(pub_macro_rules)]\n+\n+#[macro_export]\n+macro m1() {} //~ ERROR `#[macro_export]` cannot be used on `macro` items\n+\n+#[macro_export]\n+pub macro_rules! m2 { () => {} }\n+//~^ ERROR `#[macro_export]` cannot be used on `macro_rules` with `pub`\n+\n+fn main() {}"}, {"sha": "8bb031e12cba2c54e54a490328bfb2750b797fc0", "filename": "src/test/ui/macros/macro-export-on-modularized-macros.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fmacro-export-on-modularized-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fmacro-export-on-modularized-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-export-on-modularized-macros.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,14 @@\n+error: `#[macro_export]` cannot be used on `macro` items\n+  --> $DIR/macro-export-on-modularized-macros.rs:5:1\n+   |\n+LL | macro m1() {}\n+   | ^^^^^^^^^^^^^\n+\n+error: `#[macro_export]` cannot be used on `macro_rules` with `pub`\n+  --> $DIR/macro-export-on-modularized-macros.rs:8:1\n+   |\n+LL | pub macro_rules! m2 { () => {} }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "bdb4c73f18b1878ff4d0a94eeccf9db4fbad8651", "filename": "src/test/ui/macros/pub-macro-rules-fail.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fpub-macro-rules-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fpub-macro-rules-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fpub-macro-rules-fail.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,28 @@\n+#![feature(pub_macro_rules)]\n+\n+#[macro_use]\n+mod m {\n+    pub macro_rules! mac { () => {} }\n+\n+    // `pub` `macro_rules` cannot be redefined in the same module.\n+    pub macro_rules! mac { () => {} } //~ ERROR the name `mac` is defined multiple times\n+\n+    pub(self) macro_rules! private_mac { () => {} }\n+}\n+\n+const _: () = {\n+    pub macro_rules! block_mac { () => {} }\n+};\n+\n+mod n {\n+    // Scope of `pub` `macro_rules` is not extended by `#[macro_use]`.\n+    mac!(); //~ ERROR cannot find macro `mac` in this scope\n+\n+    // `pub` `macro_rules` doesn't put the macro into the root module, unlike `#[macro_export]`.\n+    crate::mac!(); //~ ERROR failed to resolve: maybe a missing crate `mac`\n+    crate::block_mac!(); //~ ERROR failed to resolve: maybe a missing crate `block_mac`\n+\n+    crate::m::private_mac!(); //~ ERROR macro `private_mac` is private\n+}\n+\n+fn main() {}"}, {"sha": "588d79dd76a4b9c76b1a1176304df7001c1244c5", "filename": "src/test/ui/macros/pub-macro-rules-fail.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fpub-macro-rules-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fpub-macro-rules-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fpub-macro-rules-fail.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,48 @@\n+error[E0428]: the name `mac` is defined multiple times\n+  --> $DIR/pub-macro-rules-fail.rs:8:5\n+   |\n+LL |     pub macro_rules! mac { () => {} }\n+   |     -------------------- previous definition of the macro `mac` here\n+...\n+LL |     pub macro_rules! mac { () => {} }\n+   |     ^^^^^^^^^^^^^^^^^^^^ `mac` redefined here\n+   |\n+   = note: `mac` must be defined only once in the macro namespace of this module\n+\n+error[E0433]: failed to resolve: maybe a missing crate `mac`?\n+  --> $DIR/pub-macro-rules-fail.rs:22:12\n+   |\n+LL |     crate::mac!();\n+   |            ^^^ maybe a missing crate `mac`?\n+\n+error[E0433]: failed to resolve: maybe a missing crate `block_mac`?\n+  --> $DIR/pub-macro-rules-fail.rs:23:12\n+   |\n+LL |     crate::block_mac!();\n+   |            ^^^^^^^^^ maybe a missing crate `block_mac`?\n+\n+error: cannot find macro `mac` in this scope\n+  --> $DIR/pub-macro-rules-fail.rs:19:5\n+   |\n+LL |     mac!();\n+   |     ^^^\n+   |\n+   = note: consider importing this macro:\n+           m::mac\n+\n+error[E0603]: macro `private_mac` is private\n+  --> $DIR/pub-macro-rules-fail.rs:25:15\n+   |\n+LL |     crate::m::private_mac!();\n+   |               ^^^^^^^^^^^ private macro\n+   |\n+note: the macro `private_mac` is defined here\n+  --> $DIR/pub-macro-rules-fail.rs:10:5\n+   |\n+LL |     pub(self) macro_rules! private_mac { () => {} }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0428, E0433, E0603.\n+For more information about an error, try `rustc --explain E0428`."}, {"sha": "cd4a845f7c07dd3cc8bd6a834612b36772980566", "filename": "src/test/ui/macros/pub-macro-rules.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fpub-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fmacros%2Fpub-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fpub-macro-rules.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+#![feature(pub_macro_rules)]\n+\n+mod m {\n+    // `pub` `macro_rules` can be used earlier in item order than they are defined.\n+    foo!();\n+\n+    pub macro_rules! foo { () => {} }\n+\n+    // `pub(...)` works too.\n+    pub(super) macro_rules! bar { () => {} }\n+}\n+\n+// `pub` `macro_rules` are available by module path.\n+m::foo!();\n+\n+m::bar!();\n+\n+fn main() {}"}, {"sha": "c80a90b3eaaac5d44cae0b509048f6bd6b56d12f", "filename": "src/test/ui/non-fmt-panic.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fnon-fmt-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fnon-fmt-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-fmt-panic.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -29,6 +29,17 @@ fn main() {\n     fancy_panic::fancy_panic!(S);\n     //~^ WARN panic message is not a string literal\n \n+    macro_rules! a {\n+        () => { 123 };\n+    }\n+\n+    panic!(a!()); //~ WARN panic message is not a string literal\n+\n+    panic!(format!(\"{}\", 1)); //~ WARN panic message is not a string literal\n+\n+    panic![123]; //~ WARN panic message is not a string literal\n+    panic!{123}; //~ WARN panic message is not a string literal\n+\n     // Check that the lint only triggers for std::panic and core::panic,\n     // not any panic macro:\n     macro_rules! panic {"}, {"sha": "7a333b3e76abe8d7d2c6ed27354117729c665a5b", "filename": "src/test/ui/non-fmt-panic.stderr", "status": "modified", "additions": 65, "deletions": 4, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -93,7 +93,7 @@ LL |     panic!(\"{}\", C);\n help: or use std::panic::panic_any instead\n    |\n LL |     std::panic::panic_any(C);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n \n warning: panic message is not a string literal\n   --> $DIR/non-fmt-panic.rs:20:12\n@@ -109,7 +109,7 @@ LL |     panic!(\"{}\", S);\n help: or use std::panic::panic_any instead\n    |\n LL |     std::panic::panic_any(S);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n \n warning: panic message is not a string literal\n   --> $DIR/non-fmt-panic.rs:21:17\n@@ -125,7 +125,7 @@ LL |     std::panic!(\"{}\", 123);\n help: or use std::panic::panic_any instead\n    |\n LL |     std::panic::panic_any(123);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n \n warning: panic message is not a string literal\n   --> $DIR/non-fmt-panic.rs:22:18\n@@ -183,5 +183,66 @@ LL |     fancy_panic::fancy_panic!(S);\n    |\n    = note: this is no longer accepted in Rust 2021\n \n-warning: 14 warnings emitted\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:36:12\n+   |\n+LL |     panic!(a!());\n+   |            ^^^^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+help: add a \"{}\" format string to Display the message\n+   |\n+LL |     panic!(\"{}\", a!());\n+   |            ^^^^^\n+help: or use std::panic::panic_any instead\n+   |\n+LL |     std::panic::panic_any(a!());\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:38:12\n+   |\n+LL |     panic!(format!(\"{}\", 1));\n+   |            ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+   = note: the panic!() macro supports formatting, so there's no need for the format!() macro here\n+help: remove the `format!(..)` macro call\n+   |\n+LL |     panic!(\"{}\", 1);\n+   |           --     --\n+\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:40:12\n+   |\n+LL |     panic![123];\n+   |            ^^^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+help: add a \"{}\" format string to Display the message\n+   |\n+LL |     panic![\"{}\", 123];\n+   |            ^^^^^\n+help: or use std::panic::panic_any instead\n+   |\n+LL |     std::panic::panic_any(123);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^   ^\n+\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:41:12\n+   |\n+LL |     panic!{123};\n+   |            ^^^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+help: add a \"{}\" format string to Display the message\n+   |\n+LL |     panic!{\"{}\", 123};\n+   |            ^^^^^\n+help: or use std::panic::panic_any instead\n+   |\n+LL |     std::panic::panic_any(123);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^   ^\n+\n+warning: 18 warnings emitted\n "}, {"sha": "67f0274fe7436e9b1acfe6ff9dec4144ea4bddd2", "filename": "src/test/ui/pattern/issue-82290.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,7 @@\n+#![feature(let_chains)] //~ WARN the feature `let_chains` is incomplete\n+\n+fn main() {\n+    if true && let x = 1 { //~ ERROR `let` expressions are not supported here\n+        let _ = x;\n+    }\n+}"}, {"sha": "65ef018dc97374ddc8371b18e3b8a28c8ec432d7", "filename": "src/test/ui/pattern/issue-82290.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-82290.stderr?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -0,0 +1,20 @@\n+error: `let` expressions are not supported here\n+  --> $DIR/issue-82290.rs:4:16\n+   |\n+LL |     if true && let x = 1 {\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n+warning: the feature `let_chains` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-82290.rs:1:12\n+   |\n+LL | #![feature(let_chains)]\n+   |            ^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "8a6a911321c345a57c8fd0384359190d18791773", "filename": "src/tools/jsondocck/src/cache.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -9,6 +9,7 @@ pub struct Cache {\n     root: PathBuf,\n     files: HashMap<PathBuf, String>,\n     values: HashMap<PathBuf, Value>,\n+    pub variables: HashMap<String, Value>,\n     last_path: Option<PathBuf>,\n }\n \n@@ -19,6 +20,7 @@ impl Cache {\n             root: Path::new(doc_dir).to_owned(),\n             files: HashMap::new(),\n             values: HashMap::new(),\n+            variables: HashMap::new(),\n             last_path: None,\n         }\n     }"}, {"sha": "5020a4917a00a12514aa077d3e11d189443d3c18", "filename": "src/tools/jsondocck/src/main.rs", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe1bf8e05c39bdcc73fc09e246b7209444e389bc/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs?ref=fe1bf8e05c39bdcc73fc09e246b7209444e389bc", "patch": "@@ -2,6 +2,7 @@ use jsonpath_lib::select;\n use lazy_static::lazy_static;\n use regex::{Regex, RegexBuilder};\n use serde_json::Value;\n+use std::borrow::Cow;\n use std::{env, fmt, fs};\n \n mod cache;\n@@ -48,13 +49,16 @@ pub struct Command {\n pub enum CommandKind {\n     Has,\n     Count,\n+    Is,\n+    Set,\n }\n \n impl CommandKind {\n     fn validate(&self, args: &[String], command_num: usize, lineno: usize) -> bool {\n         let count = match self {\n             CommandKind::Has => (1..=3).contains(&args.len()),\n-            CommandKind::Count => 3 == args.len(),\n+            CommandKind::Count | CommandKind::Is => 3 == args.len(),\n+            CommandKind::Set => 4 == args.len(),\n         };\n \n         if !count {\n@@ -83,6 +87,8 @@ impl fmt::Display for CommandKind {\n         let text = match self {\n             CommandKind::Has => \"has\",\n             CommandKind::Count => \"count\",\n+            CommandKind::Is => \"is\",\n+            CommandKind::Set => \"set\",\n         };\n         write!(f, \"{}\", text)\n     }\n@@ -127,6 +133,8 @@ fn get_commands(template: &str) -> Result<Vec<Command>, ()> {\n         let cmd = match cmd {\n             \"has\" => CommandKind::Has,\n             \"count\" => CommandKind::Count,\n+            \"is\" => CommandKind::Is,\n+            \"set\" => CommandKind::Set,\n             _ => {\n                 print_err(&format!(\"Unrecognized command name `@{}`\", cmd), lineno);\n                 errors = true;\n@@ -180,6 +188,7 @@ fn get_commands(template: &str) -> Result<Vec<Command>, ()> {\n /// Performs the actual work of ensuring a command passes. Generally assumes the command\n /// is syntactically valid.\n fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n+    // FIXME: Be more granular about why, (e.g. syntax error, count not equal)\n     let result = match command.kind {\n         CommandKind::Has => {\n             match command.args.len() {\n@@ -188,23 +197,15 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n                 // @has <path> <jsonpath> = check path exists\n                 2 => {\n                     let val = cache.get_value(&command.args[0])?;\n-\n-                    match select(&val, &command.args[1]) {\n-                        Ok(results) => !results.is_empty(),\n-                        Err(_) => false,\n-                    }\n+                    let results = select(&val, &command.args[1]).unwrap();\n+                    !results.is_empty()\n                 }\n                 // @has <path> <jsonpath> <value> = check *any* item matched by path equals value\n                 3 => {\n                     let val = cache.get_value(&command.args[0])?;\n-                    match select(&val, &command.args[1]) {\n-                        Ok(results) => {\n-                            let pat: Value = serde_json::from_str(&command.args[2]).unwrap();\n-\n-                            !results.is_empty() && results.into_iter().any(|val| *val == pat)\n-                        }\n-                        Err(_) => false,\n-                    }\n+                    let results = select(&val, &command.args[1]).unwrap();\n+                    let pat = string_to_value(&command.args[2], cache);\n+                    results.contains(&pat.as_ref())\n                 }\n                 _ => unreachable!(),\n             }\n@@ -215,9 +216,37 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n             let expected: usize = command.args[2].parse().unwrap();\n \n             let val = cache.get_value(&command.args[0])?;\n-            match select(&val, &command.args[1]) {\n-                Ok(results) => results.len() == expected,\n-                Err(_) => false,\n+            let results = select(&val, &command.args[1]).unwrap();\n+            results.len() == expected\n+        }\n+        CommandKind::Is => {\n+            // @has <path> <jsonpath> <value> = check *exactly one* item matched by path, and it equals value\n+            assert_eq!(command.args.len(), 3);\n+            let val = cache.get_value(&command.args[0])?;\n+            let results = select(&val, &command.args[1]).unwrap();\n+            let pat = string_to_value(&command.args[2], cache);\n+            results.len() == 1 && results[0] == pat.as_ref()\n+        }\n+        CommandKind::Set => {\n+            // @set <name> = <path> <jsonpath>\n+            assert_eq!(command.args.len(), 4);\n+            assert_eq!(command.args[1], \"=\", \"Expected an `=`\");\n+            let val = cache.get_value(&command.args[2])?;\n+            let results = select(&val, &command.args[3]).unwrap();\n+            assert_eq!(results.len(), 1);\n+            match results.len() {\n+                0 => false,\n+                1 => {\n+                    let r = cache.variables.insert(command.args[0].clone(), results[0].clone());\n+                    assert!(r.is_none(), \"Name collision: {} is duplicated\", command.args[0]);\n+                    true\n+                }\n+                _ => {\n+                    panic!(\n+                        \"Got multiple results in `@set` for `{}`: {:?}\",\n+                        &command.args[3], results\n+                    );\n+                }\n             }\n         }\n     };\n@@ -247,3 +276,11 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n         Ok(())\n     }\n }\n+\n+fn string_to_value<'a>(s: &str, cache: &'a Cache) -> Cow<'a, Value> {\n+    if s.starts_with(\"$\") {\n+        Cow::Borrowed(&cache.variables[&s[1..]])\n+    } else {\n+        Cow::Owned(serde_json::from_str(s).unwrap())\n+    }\n+}"}]}