{"sha": "5ebd300090429ef8587b3e4026d6c268b2b23c12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYmQzMDAwOTA0MjllZjg1ODdiM2U0MDI2ZDZjMjY4YjJiMjNjMTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-04T17:08:33Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-14T17:03:18Z"}, "message": "ty: erase lifetimes early in `ty::Const::eval`.", "tree": {"sha": "6dd9ee9c6787a12894e7e21e5e99e2ea6ac67e30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dd9ee9c6787a12894e7e21e5e99e2ea6ac67e30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ebd300090429ef8587b3e4026d6c268b2b23c12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebd300090429ef8587b3e4026d6c268b2b23c12", "html_url": "https://github.com/rust-lang/rust/commit/5ebd300090429ef8587b3e4026d6c268b2b23c12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ebd300090429ef8587b3e4026d6c268b2b23c12/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38d38349f3c6aa86adfc2e32384c666ca8844b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/38d38349f3c6aa86adfc2e32384c666ca8844b92", "html_url": "https://github.com/rust-lang/rust/commit/38d38349f3c6aa86adfc2e32384c666ca8844b92"}], "stats": {"total": 58, "additions": 28, "deletions": 30}, "files": [{"sha": "248a2095d0a2c3173c51108008621cb38fd4396d", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd300090429ef8587b3e4026d6c268b2b23c12/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd300090429ef8587b3e4026d6c268b2b23c12/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=5ebd300090429ef8587b3e4026d6c268b2b23c12", "patch": "@@ -2339,43 +2339,41 @@ impl<'tcx> Const<'tcx> {\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n     /// unevaluated constant.\n     pub fn eval(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> &Const<'tcx> {\n-        let try_const_eval = |did, param_env: ParamEnv<'tcx>, substs, promoted| {\n+        if let ConstKind::Unevaluated(did, substs, promoted) = self.val {\n             let param_env_and_substs = param_env.with_reveal_all().and(substs);\n \n-            // Avoid querying `tcx.const_eval(...)` with any inference vars.\n-            if param_env_and_substs.needs_infer() {\n-                return None;\n-            }\n+            // HACK(eddyb) this erases lifetimes even though `const_eval_resolve`\n+            // also does later, but we want to do it before checking for\n+            // inference variables.\n+            let param_env_and_substs = tcx.erase_regions(&param_env_and_substs);\n+\n+            // HACK(eddyb) when the query key would contain inference variables,\n+            // attempt using identity substs and `ParamEnv` instead, that will succeed\n+            // when the expression doesn't depend on any parameters.\n+            // FIXME(eddyb, skinny121) pass `InferCtxt` into here when it's available, so that\n+            // we can call `infcx.const_eval_resolve` which handles inference variables.\n+            let param_env_and_substs = if param_env_and_substs.needs_infer() {\n+                tcx.param_env(did).and(InternalSubsts::identity_for_item(tcx, did))\n+            } else {\n+                param_env_and_substs\n+            };\n \n+            // FIXME(eddyb) maybe the `const_eval_*` methods should take\n+            // `ty::ParamEnvAnd<SubstsRef>` instead of having them separate.\n             let (param_env, substs) = param_env_and_substs.into_parts();\n-\n             // try to resolve e.g. associated constants to their definition on an impl, and then\n             // evaluate the const.\n-            tcx.const_eval_resolve(param_env, did, substs, promoted, None)\n-                .ok()\n-                .map(|val| Const::from_value(tcx, val, self.ty))\n-        };\n-\n-        match self.val {\n-            ConstKind::Unevaluated(did, substs, promoted) => {\n-                // HACK(eddyb) when substs contain inference variables,\n-                // attempt using identity substs instead, that will succeed\n-                // when the expression doesn't depend on any parameters.\n-                // FIXME(eddyb, skinny121) pass `InferCtxt` into here when it's available, so that\n-                // we can call `infcx.const_eval_resolve` which handles inference variables.\n-                if substs.needs_infer() {\n-                    let identity_substs = InternalSubsts::identity_for_item(tcx, did);\n-                    // The `ParamEnv` needs to match the `identity_substs`.\n-                    let identity_param_env = tcx.param_env(did);\n-                    match try_const_eval(did, identity_param_env, identity_substs, promoted) {\n-                        Some(ct) => ct.subst(tcx, substs),\n-                        None => self,\n-                    }\n-                } else {\n-                    try_const_eval(did, param_env, substs, promoted).unwrap_or(self)\n-                }\n+            match tcx.const_eval_resolve(param_env, did, substs, promoted, None) {\n+                // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n+                // and we use the original type, so nothing from `substs`\n+                // (which may be identity substs, see above),\n+                // can leak through `val` into the const we return.\n+                Ok(val) => Const::from_value(tcx, val, self.ty),\n+\n+                Err(_) => self,\n             }\n-            _ => self,\n+        } else {\n+            self\n         }\n     }\n "}]}