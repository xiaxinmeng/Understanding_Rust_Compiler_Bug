{"sha": "f4b74773c730e7afb6e81aa90df3ddade7442b60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0Yjc0NzczYzczMGU3YWZiNmU4MWFhOTBkZjNkZGFkZTc0NDJiNjA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-01-22T17:45:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-02-03T10:14:22Z"}, "message": "rustc_codegen_ssa: convert mir::VarDebugInfo into a custom PerLocalVarDebugInfo.", "tree": {"sha": "deaf3f8cb2fd079ead031d4bd0e24c5d2a65a584", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deaf3f8cb2fd079ead031d4bd0e24c5d2a65a584"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4b74773c730e7afb6e81aa90df3ddade7442b60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b74773c730e7afb6e81aa90df3ddade7442b60", "html_url": "https://github.com/rust-lang/rust/commit/f4b74773c730e7afb6e81aa90df3ddade7442b60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4b74773c730e7afb6e81aa90df3ddade7442b60/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b633c82f094d52a642b53cae64614ff097eebd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b633c82f094d52a642b53cae64614ff097eebd8", "html_url": "https://github.com/rust-lang/rust/commit/0b633c82f094d52a642b53cae64614ff097eebd8"}], "stats": {"total": 187, "additions": 133, "deletions": 54}, "files": [{"sha": "f66496d10fb166fc6c9fb4767c640d926954ead8", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 125, "deletions": 49, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/f4b74773c730e7afb6e81aa90df3ddade7442b60/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b74773c730e7afb6e81aa90df3ddade7442b60/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=f4b74773c730e7afb6e81aa90df3ddade7442b60", "patch": "@@ -1,12 +1,12 @@\n use crate::traits::*;\n use rustc::mir;\n use rustc::session::config::DebugInfo;\n+use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Size};\n-use rustc::ty::TyCtxt;\n use rustc_hir::def_id::CrateNum;\n use rustc_index::vec::IndexVec;\n \n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n \n use super::OperandValue;\n@@ -24,6 +24,19 @@ pub enum VariableKind {\n     LocalVariable,\n }\n \n+/// Like `mir::VarDebugInfo`, but within a `mir::Local`.\n+#[derive(Copy, Clone)]\n+pub struct PerLocalVarDebugInfo<'tcx, D> {\n+    pub name: Symbol,\n+    pub source_info: mir::SourceInfo,\n+\n+    /// `DIVariable` returned by `create_dbg_var`.\n+    pub dbg_var: Option<D>,\n+\n+    /// `.place.projection` from `mir::VarDebugInfo`.\n+    pub projection: &'tcx ty::List<mir::PlaceElem<'tcx>>,\n+}\n+\n #[derive(Clone, Copy, Debug)]\n pub struct DebugScope<D> {\n     pub scope_metadata: Option<D>,\n@@ -103,6 +116,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     // FIXME(eddyb) use `llvm.dbg.value` (which would work for operands),\n     // not just `llvm.dbg.declare` (which requires `alloca`).\n     pub fn debug_introduce_local(&self, bx: &mut Bx, local: mir::Local) {\n+        let full_debug_info = bx.sess().opts.debuginfo == DebugInfo::Full;\n+\n         // FIXME(eddyb) maybe name the return place as `_0` or `return`?\n         if local == mir::RETURN_PLACE {\n             return;\n@@ -112,35 +127,63 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Some(per_local) => &per_local[local],\n             None => return,\n         };\n-        let whole_local_var = vars.iter().copied().find(|var| var.place.projection.is_empty());\n-        let has_proj = || vars.iter().any(|var| !var.place.projection.is_empty());\n+        let whole_local_var = vars.iter().find(|var| var.projection.is_empty()).copied();\n+        let has_proj = || vars.iter().any(|var| !var.projection.is_empty());\n \n-        let (fallback_var, kind) = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n+        let fallback_var = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n             let arg_index = local.index() - 1;\n \n             // Add debuginfo even to unnamed arguments.\n             // FIXME(eddyb) is this really needed?\n-            let var = if arg_index == 0 && has_proj() {\n+            if arg_index == 0 && has_proj() {\n                 // Hide closure environments from debuginfo.\n                 // FIXME(eddyb) shouldn't `ArgumentVariable` indices\n                 // be offset to account for the hidden environment?\n                 None\n+            } else if whole_local_var.is_some() {\n+                // No need to make up anything, there is a `mir::VarDebugInfo`\n+                // covering the whole local.\n+                // FIXME(eddyb) take `whole_local_var.source_info.scope` into\n+                // account, just in case it doesn't use `ArgumentVariable`\n+                // (after #67586 gets fixed).\n+                None\n             } else {\n-                Some(mir::VarDebugInfo {\n-                    name: kw::Invalid,\n-                    source_info: self.mir.local_decls[local].source_info,\n-                    place: local.into(),\n+                let name = kw::Invalid;\n+                let decl = &self.mir.local_decls[local];\n+                let (scope, span) = if full_debug_info {\n+                    self.debug_loc(decl.source_info)\n+                } else {\n+                    (None, decl.source_info.span)\n+                };\n+                let dbg_var = scope.map(|scope| {\n+                    // FIXME(eddyb) is this `+ 1` needed at all?\n+                    let kind = VariableKind::ArgumentVariable(arg_index + 1);\n+\n+                    self.cx.create_dbg_var(\n+                        self.debug_context.as_ref().unwrap(),\n+                        name,\n+                        self.monomorphize(&decl.ty),\n+                        scope,\n+                        kind,\n+                        span,\n+                    )\n+                });\n+\n+                Some(PerLocalVarDebugInfo {\n+                    name,\n+                    source_info: decl.source_info,\n+                    dbg_var,\n+                    projection: ty::List::empty(),\n                 })\n-            };\n-            (var, VariableKind::ArgumentVariable(arg_index + 1))\n+            }\n         } else {\n-            (None, VariableKind::LocalVariable)\n+            None\n         };\n \n         let local_ref = &self.locals[local];\n \n         if !bx.sess().fewer_names() {\n-            let name = match whole_local_var.or(fallback_var.as_ref()) {\n+            let name = match whole_local_var.or(fallback_var) {\n                 Some(var) if var.name != kw::Invalid => var.name.to_string(),\n                 _ => format!(\"{:?}\", local),\n             };\n@@ -163,7 +206,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         }\n \n-        if bx.sess().opts.debuginfo != DebugInfo::Full {\n+        if !full_debug_info {\n             return;\n         }\n \n@@ -178,22 +221,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => return,\n         };\n \n-        let vars = vars.iter().copied().chain(if whole_local_var.is_none() {\n-            fallback_var.as_ref()\n-        } else {\n-            None\n-        });\n+        let vars = vars.iter().copied().chain(fallback_var);\n \n         for var in vars {\n             let mut layout = base.layout;\n             let mut direct_offset = Size::ZERO;\n             // FIXME(eddyb) use smallvec here.\n             let mut indirect_offsets = vec![];\n \n-            let kind =\n-                if var.place.projection.is_empty() { kind } else { VariableKind::LocalVariable };\n-\n-            for elem in &var.place.projection[..] {\n+            for elem in &var.projection[..] {\n                 match *elem {\n                     mir::ProjectionElem::Deref => {\n                         indirect_offsets.push(Size::ZERO);\n@@ -202,7 +238,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 .ty\n                                 .builtin_deref(true)\n                                 .unwrap_or_else(|| {\n-                                    span_bug!(var.source_info.span, \"cannot deref `{}`\", layout.ty,)\n+                                    span_bug!(var.source_info.span, \"cannot deref `{}`\", layout.ty)\n                                 })\n                                 .ty,\n                         );\n@@ -219,24 +255,24 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     _ => span_bug!(\n                         var.source_info.span,\n                         \"unsupported var debuginfo place `{:?}`\",\n-                        var.place,\n+                        mir::Place { local, projection: var.projection },\n                     ),\n                 }\n             }\n \n             let (scope, span) = self.debug_loc(var.source_info);\n             if let Some(scope) = scope {\n-                let dbg_var =\n-                    bx.create_dbg_var(debug_context, var.name, layout.ty, scope, kind, span);\n-                bx.dbg_var_addr(\n-                    debug_context,\n-                    dbg_var,\n-                    scope,\n-                    base.llval,\n-                    direct_offset,\n-                    &indirect_offsets,\n-                    span,\n-                );\n+                if let Some(dbg_var) = var.dbg_var {\n+                    bx.dbg_var_addr(\n+                        debug_context,\n+                        dbg_var,\n+                        scope,\n+                        base.llval,\n+                        direct_offset,\n+                        &indirect_offsets,\n+                        span,\n+                    );\n+                }\n             }\n         }\n     }\n@@ -248,20 +284,60 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         }\n     }\n-}\n \n-/// Partition all `VarDebuginfo` in `body`, by their base `Local`.\n-pub fn per_local_var_debug_info(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a mir::Body<'tcx>,\n-) -> Option<IndexVec<mir::Local, Vec<&'a mir::VarDebugInfo<'tcx>>>> {\n-    if tcx.sess.opts.debuginfo == DebugInfo::Full || !tcx.sess.fewer_names() {\n-        let mut per_local = IndexVec::from_elem(vec![], &body.local_decls);\n-        for var in &body.var_debug_info {\n-            per_local[var.place.local].push(var);\n+    /// Partition all `VarDebugInfo` in `self.mir`, by their base `Local`.\n+    pub fn compute_per_local_var_debug_info(\n+        &self,\n+    ) -> Option<IndexVec<mir::Local, Vec<PerLocalVarDebugInfo<'tcx, Bx::DIVariable>>>> {\n+        let full_debug_info = self.cx.sess().opts.debuginfo == DebugInfo::Full;\n+\n+        if !(full_debug_info || !self.cx.sess().fewer_names()) {\n+            return None;\n+        }\n+\n+        let mut per_local = IndexVec::from_elem(vec![], &self.mir.local_decls);\n+        for var in &self.mir.var_debug_info {\n+            let (scope, span) = if full_debug_info {\n+                self.debug_loc(var.source_info)\n+            } else {\n+                (None, var.source_info.span)\n+            };\n+            let dbg_var = scope.map(|scope| {\n+                let place = var.place;\n+                let var_ty = self.monomorphized_place_ty(place.as_ref());\n+                let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg\n+                    && place.projection.is_empty()\n+                {\n+                    // FIXME(eddyb, #67586) take `var.source_info.scope` into\n+                    // account to avoid using `ArgumentVariable` more than once\n+                    // per argument local.\n+\n+                    let arg_index = place.local.index() - 1;\n+\n+                    // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n+                    // offset in closures to account for the hidden environment?\n+                    // Also, is this `+ 1` needed at all?\n+                    VariableKind::ArgumentVariable(arg_index + 1)\n+                } else {\n+                    VariableKind::LocalVariable\n+                };\n+                self.cx.create_dbg_var(\n+                    self.debug_context.as_ref().unwrap(),\n+                    var.name,\n+                    var_ty,\n+                    scope,\n+                    var_kind,\n+                    span,\n+                )\n+            });\n+\n+            per_local[var.place.local].push(PerLocalVarDebugInfo {\n+                name: var.name,\n+                source_info: var.source_info,\n+                dbg_var,\n+                projection: var.place.projection,\n+            });\n         }\n         Some(per_local)\n-    } else {\n-        None\n     }\n }"}, {"sha": "8a6284479c722160ac48562c44b8308013c4658f", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f4b74773c730e7afb6e81aa90df3ddade7442b60/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b74773c730e7afb6e81aa90df3ddade7442b60/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=f4b74773c730e7afb6e81aa90df3ddade7442b60", "patch": "@@ -11,7 +11,7 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n use self::analyze::CleanupKind;\n-use self::debuginfo::FunctionDebugContext;\n+use self::debuginfo::{FunctionDebugContext, PerLocalVarDebugInfo};\n use self::place::PlaceRef;\n use rustc::mir::traversal;\n \n@@ -74,9 +74,10 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// notably `expect`.\n     locals: IndexVec<mir::Local, LocalRef<'tcx, Bx::Value>>,\n \n-    /// All `VarDebuginfo` from the MIR body, partitioned by `Local`.\n-    /// This is `None` if no variable debuginfo/names are needed.\n-    per_local_var_debug_info: Option<IndexVec<mir::Local, Vec<&'tcx mir::VarDebugInfo<'tcx>>>>,\n+    /// All `VarDebugInfo` from the MIR body, partitioned by `Local`.\n+    /// This is `None` if no var`#[non_exhaustive]`iable debuginfo/names are needed.\n+    per_local_var_debug_info:\n+        Option<IndexVec<mir::Local, Vec<PerLocalVarDebugInfo<'tcx, Bx::DIVariable>>>>,\n \n     /// Caller location propagated if this function has `#[track_caller]`.\n     caller_location: Option<OperandRef<'tcx, Bx::Value>>,\n@@ -178,10 +179,12 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         funclets,\n         locals: IndexVec::new(),\n         debug_context,\n-        per_local_var_debug_info: debuginfo::per_local_var_debug_info(cx.tcx(), mir_body),\n+        per_local_var_debug_info: None,\n         caller_location: None,\n     };\n \n+    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info();\n+\n     let memory_locals = analyze::non_ssa_locals(&fx);\n \n     // Allocate variable and temp allocas"}]}