{"sha": "e19cb40fda70ea3f75bc1927c114ea53d231b288", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxOWNiNDBmZGE3MGVhM2Y3NWJjMTkyN2MxMTRlYTUzZDIzMWIyODg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-07T07:51:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-07T07:51:57Z"}, "message": "Rollup merge of #65974 - Centril:matcher-friendly-gating, r=petrochenkov\n\nA scheme for more macro-matcher friendly pre-expansion gating\n\nPre-expansion gating will now avoid gating macro matchers that did not result in `Success(...)`. That is, the following is now OK despite `box 42` being a valid `expr` and that form being pre-expansion gated:\n\n```rust\nmacro_rules! m {\n    ($e:expr) => { 0 }; // This fails on the input below due to `, foo`.\n    (box $e:expr, foo) => { 1 }; // Successful matcher, we should get `2`.\n}\n\nfn main() {\n    assert_eq!(1, m!(box 42, foo));\n}\n```\n\nCloses https://github.com/rust-lang/rust/issues/65846.\n\nr? @petrochenkov\ncc @Mark-Simulacrum", "tree": {"sha": "cf0891bcc1fca581981d14c7ae6c550fc20f26da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf0891bcc1fca581981d14c7ae6c550fc20f26da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e19cb40fda70ea3f75bc1927c114ea53d231b288", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdw80dCRBK7hj4Ov3rIwAAdHIIAFeYfQrt9No+uUTVNg37v3ie\nULZTmVUxMX3cZuw9FpMTrRqFBqRqLdrZNmFgDb8XUkTss6slKmbE2cfg+GOwNPCu\nyzflEhgSq8LLQDPxMN3p8lCtml1d4f53nCl1BuXxKThGHRba3QQrtoZPsW+XxcQR\n8hWnYn80I8VTLXDFe69Dh3BdJF9Rkwbw3puGdxZTIPqvXqFn+F9dgzs/XmeUDbb5\nmEGdxyQkbFRcOog+bUDk9J8+Hj1pa5fY+bAVOJJMjr8dk4bm6ER2gtamUAdrjJ7I\nArZQ1jgKoGyxJW3i5D8skdYvt4YLtUyYUl9Th3rWXf+1frSu5yYDe75CIlRRrRU=\n=VLSJ\n-----END PGP SIGNATURE-----\n", "payload": "tree cf0891bcc1fca581981d14c7ae6c550fc20f26da\nparent 883fe10da2f0651540fd5824898b7d7476969c41\nparent bceaba86b92325f807351426bfd93ba0513225a4\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1573113117 +0100\ncommitter GitHub <noreply@github.com> 1573113117 +0100\n\nRollup merge of #65974 - Centril:matcher-friendly-gating, r=petrochenkov\n\nA scheme for more macro-matcher friendly pre-expansion gating\n\nPre-expansion gating will now avoid gating macro matchers that did not result in `Success(...)`. That is, the following is now OK despite `box 42` being a valid `expr` and that form being pre-expansion gated:\n\n```rust\nmacro_rules! m {\n    ($e:expr) => { 0 }; // This fails on the input below due to `, foo`.\n    (box $e:expr, foo) => { 1 }; // Successful matcher, we should get `2`.\n}\n\nfn main() {\n    assert_eq!(1, m!(box 42, foo));\n}\n```\n\nCloses https://github.com/rust-lang/rust/issues/65846.\n\nr? @petrochenkov\ncc @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e19cb40fda70ea3f75bc1927c114ea53d231b288", "html_url": "https://github.com/rust-lang/rust/commit/e19cb40fda70ea3f75bc1927c114ea53d231b288", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e19cb40fda70ea3f75bc1927c114ea53d231b288/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "883fe10da2f0651540fd5824898b7d7476969c41", "url": "https://api.github.com/repos/rust-lang/rust/commits/883fe10da2f0651540fd5824898b7d7476969c41", "html_url": "https://github.com/rust-lang/rust/commit/883fe10da2f0651540fd5824898b7d7476969c41"}, {"sha": "bceaba86b92325f807351426bfd93ba0513225a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bceaba86b92325f807351426bfd93ba0513225a4", "html_url": "https://github.com/rust-lang/rust/commit/bceaba86b92325f807351426bfd93ba0513225a4"}], "stats": {"total": 179, "additions": 106, "deletions": 73}, "files": [{"sha": "5b1493ebc9b01dd2b0f6aa06a2aa12a54177f80a", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -870,18 +870,17 @@ pub fn check_crate(krate: &ast::Crate,\n     maybe_stage_features(&parse_sess.span_diagnostic, krate, unstable);\n     let mut visitor = PostExpansionVisitor { parse_sess, features };\n \n+    let spans = parse_sess.gated_spans.spans.borrow();\n     macro_rules! gate_all {\n-        ($gate:ident, $msg:literal) => { gate_all!($gate, $gate, $msg); };\n-        ($spans:ident, $gate:ident, $msg:literal) => {\n-            for span in &*parse_sess.gated_spans.$spans.borrow() {\n+        ($gate:ident, $msg:literal) => {\n+            for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n                 gate_feature!(&visitor, $gate, *span, $msg);\n             }\n         }\n     }\n-\n     gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n     gate_all!(async_closure, \"async closures are unstable\");\n-    gate_all!(yields, generators, \"yield syntax is experimental\");\n+    gate_all!(generators, \"yield syntax is experimental\");\n     gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n     gate_all!(const_extern_fn, \"`const extern fn` definitions are unstable\");\n \n@@ -892,7 +891,7 @@ pub fn check_crate(krate: &ast::Crate,\n             // FIXME(eddyb) do something more useful than always\n             // disabling these uses of early feature-gatings.\n             if false {\n-                for span in &*parse_sess.gated_spans.$gate.borrow() {\n+                for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n                     gate_feature!(&visitor, $gate, *span, $msg);\n                 }\n             }\n@@ -909,7 +908,6 @@ pub fn check_crate(krate: &ast::Crate,\n     gate_all!(try_blocks, \"`try` blocks are unstable\");\n     gate_all!(label_break_value, \"labels on blocks are unstable\");\n     gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n-\n     // To avoid noise about type ascription in common syntax errors,\n     // only emit if it is the *only* error. (Also check it last.)\n     if parse_sess.span_diagnostic.err_count() == 0 {"}, {"sha": "1284e89f195c753a127b38ea53a8e519ca6e6ff6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -1120,7 +1120,7 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n-            self.sess.gated_spans.crate_visibility_modifier.borrow_mut().push(self.prev_span);\n+            self.sess.gated_spans.gate(sym::crate_visibility_modifier, self.prev_span);\n             return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n "}, {"sha": "509e6482dcc06d48d3610528d41547185c29280e", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -16,10 +16,10 @@ use crate::parse::token::{self, Token, TokenKind};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{self, Span};\n-use crate::symbol::{kw, sym};\n use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n \n use errors::Applicability;\n+use syntax_pos::symbol::{kw, sym};\n use syntax_pos::Symbol;\n use std::mem;\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -252,7 +252,7 @@ impl<'a> Parser<'a> {\n                 self.last_type_ascription = Some((self.prev_span, maybe_path));\n \n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n-                self.sess.gated_spans.type_ascription.borrow_mut().push(lhs.span);\n+                self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n@@ -455,7 +455,7 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 let span = lo.to(span);\n-                self.sess.gated_spans.box_syntax.borrow_mut().push(span);\n+                self.sess.gated_spans.gate(sym::box_syntax, span);\n                 (span, ExprKind::Box(e))\n             }\n             token::Ident(..) if self.token.is_ident_named(sym::not) => {\n@@ -1045,7 +1045,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     let span = lo.to(hi);\n-                    self.sess.gated_spans.yields.borrow_mut().push(span);\n+                    self.sess.gated_spans.gate(sym::generators, span);\n                 } else if self.eat_keyword(kw::Let) {\n                     return self.parse_let_expr(attrs);\n                 } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n@@ -1268,7 +1268,7 @@ impl<'a> Parser<'a> {\n         outer_attrs: ThinVec<Attribute>,\n     ) -> PResult<'a, P<Expr>> {\n         if let Some(label) = opt_label {\n-            self.sess.gated_spans.label_break_value.borrow_mut().push(label.ident.span);\n+            self.sess.gated_spans.gate(sym::label_break_value, label.ident.span);\n         }\n \n         self.expect(&token::OpenDelim(token::Brace))?;\n@@ -1297,7 +1297,7 @@ impl<'a> Parser<'a> {\n         };\n         if asyncness.is_async() {\n             // Feature-gate `async ||` closures.\n-            self.sess.gated_spans.async_closure.borrow_mut().push(self.prev_span);\n+            self.sess.gated_spans.gate(sym::async_closure, self.prev_span);\n         }\n \n         let capture_clause = self.parse_capture_clause();\n@@ -1419,8 +1419,7 @@ impl<'a> Parser<'a> {\n \n         if let ExprKind::Let(..) = cond.kind {\n             // Remove the last feature gating of a `let` expression since it's stable.\n-            let last = self.sess.gated_spans.let_chains.borrow_mut().pop();\n-            debug_assert_eq!(cond.span, last.unwrap());\n+            self.sess.gated_spans.ungate_last(sym::let_chains, cond.span);\n         }\n \n         Ok(cond)\n@@ -1437,7 +1436,7 @@ impl<'a> Parser<'a> {\n             |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         )?;\n         let span = lo.to(expr.span);\n-        self.sess.gated_spans.let_chains.borrow_mut().push(span);\n+        self.sess.gated_spans.gate(sym::let_chains, span);\n         Ok(self.mk_expr(span, ExprKind::Let(pat, expr), attrs))\n     }\n \n@@ -1658,7 +1657,7 @@ impl<'a> Parser<'a> {\n             Err(error)\n         } else {\n             let span = span_lo.to(body.span);\n-            self.sess.gated_spans.try_blocks.borrow_mut().push(span);\n+            self.sess.gated_spans.gate(sym::try_blocks, span);\n             Ok(self.mk_expr(span, ExprKind::TryBlock(body), attrs))\n         }\n     }"}, {"sha": "3c094750b4d98ee9901bb3d8638cb20543d88136", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -3,7 +3,8 @@ use super::{Parser, PResult};\n use crate::ast::{self, WhereClause, GenericParam, GenericParamKind, GenericBounds, Attribute};\n use crate::parse::token;\n use crate::source_map::DUMMY_SP;\n-use crate::symbol::kw;\n+\n+use syntax_pos::symbol::{kw, sym};\n \n impl<'a> Parser<'a> {\n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n@@ -62,7 +63,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        self.sess.gated_spans.const_generics.borrow_mut().push(lo.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::const_generics, lo.to(self.prev_span));\n \n         Ok(GenericParam {\n             ident,"}, {"sha": "9d543055f23a7788335b1be7aef4f8d410d380ff", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -146,9 +146,7 @@ impl<'a> Parser<'a> {\n                 let unsafety = self.parse_unsafety();\n \n                 if self.check_keyword(kw::Extern) {\n-                    self.sess.gated_spans.const_extern_fn.borrow_mut().push(\n-                        lo.to(self.token.span)\n-                    );\n+                    self.sess.gated_spans.gate(sym::const_extern_fn, lo.to(self.token.span));\n                 }\n                 let abi = self.parse_extern_abi()?;\n                 self.bump(); // `fn`\n@@ -831,7 +829,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n             }\n \n-            self.sess.gated_spans.trait_alias.borrow_mut().push(whole_span);\n+            self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n \n             Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n         } else {\n@@ -1711,7 +1709,7 @@ impl<'a> Parser<'a> {\n         let span = lo.to(self.prev_span);\n \n         if !def.legacy {\n-            self.sess.gated_spans.decl_macro.borrow_mut().push(span);\n+            self.sess.gated_spans.gate(sym::decl_macro, span);\n         }\n \n         Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))"}, {"sha": "cc8738edff7f50f088a53ab2432364ae18e1b251", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -8,9 +8,8 @@ use crate::mut_visit::{noop_visit_pat, noop_visit_mac, MutVisitor};\n use crate::parse::token::{self};\n use crate::print::pprust;\n use crate::source_map::{respan, Span, Spanned};\n-use crate::symbol::kw;\n use crate::ThinVec;\n-\n+use syntax_pos::symbol::{kw, sym};\n use errors::{Applicability, DiagnosticBuilder};\n \n type Expected = Option<&'static str>;\n@@ -52,11 +51,8 @@ impl<'a> Parser<'a> {\n         // and no other gated or-pattern has been parsed thus far,\n         // then we should really gate the leading `|`.\n         // This complicated procedure is done purely for diagnostics UX.\n-        if gated_leading_vert {\n-            let mut or_pattern_spans = self.sess.gated_spans.or_patterns.borrow_mut();\n-            if or_pattern_spans.is_empty() {\n-                or_pattern_spans.push(leading_vert_span);\n-            }\n+        if gated_leading_vert && self.sess.gated_spans.is_ungated(sym::or_patterns) {\n+            self.sess.gated_spans.gate(sym::or_patterns, leading_vert_span);\n         }\n \n         Ok(pat)\n@@ -117,7 +113,7 @@ impl<'a> Parser<'a> {\n \n         // Feature gate the or-pattern if instructed:\n         if gate_or == GateOr::Yes {\n-            self.sess.gated_spans.or_patterns.borrow_mut().push(or_pattern_span);\n+            self.sess.gated_spans.gate(sym::or_patterns, or_pattern_span);\n         }\n \n         Ok(self.mk_pat(or_pattern_span, PatKind::Or(pats)))\n@@ -325,7 +321,7 @@ impl<'a> Parser<'a> {\n             } else if self.eat_keyword(kw::Box) {\n                 // Parse `box pat`\n                 let pat = self.parse_pat_with_range_pat(false, None)?;\n-                self.sess.gated_spans.box_patterns.borrow_mut().push(lo.to(self.prev_span));\n+                self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_span));\n                 PatKind::Box(pat)\n             } else if self.can_be_ident_pat() {\n                 // Parse `ident @ pat`\n@@ -612,7 +608,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn excluded_range_end(&self, span: Span) -> RangeEnd {\n-        self.sess.gated_spans.exclusive_range_pattern.borrow_mut().push(span);\n+        self.sess.gated_spans.gate(sym::exclusive_range_pattern, span);\n         RangeEnd::Excluded\n     }\n "}, {"sha": "4438d61d9eedde05f130fb7170f513e59cf5c09f", "filename": "src/libsyntax/parse/parser/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -5,7 +5,7 @@ use crate::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, Angle\n use crate::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n use crate::parse::token::{self, Token};\n use crate::source_map::{Span, BytePos};\n-use crate::symbol::kw;\n+use syntax_pos::symbol::{kw, sym};\n \n use std::mem;\n use log::debug;\n@@ -426,7 +426,7 @@ impl<'a> Parser<'a> {\n \n                 // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n                 if let AssocTyConstraintKind::Bound { .. } = kind {\n-                    self.sess.gated_spans.associated_type_bounds.borrow_mut().push(span);\n+                    self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n                 }\n \n                 constraints.push(AssocTyConstraint {"}, {"sha": "faad3e4af1e46daf93b376e7a7b7549df711bb8d", "filename": "src/libsyntax/sess.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fsess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax%2Fsess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsess.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -19,39 +19,53 @@ use std::str;\n /// Collected spans during parsing for places where a certain feature was\n /// used and should be feature gated accordingly in `check_crate`.\n #[derive(Default)]\n-crate struct GatedSpans {\n-    /// Spans collected for gating `let_chains`, e.g. `if a && let b = c {}`.\n-    crate let_chains: Lock<Vec<Span>>,\n-    /// Spans collected for gating `async_closure`, e.g. `async || ..`.\n-    crate async_closure: Lock<Vec<Span>>,\n-    /// Spans collected for gating `yield e?` expressions (`generators` gate).\n-    crate yields: Lock<Vec<Span>>,\n-    /// Spans collected for gating `or_patterns`, e.g. `Some(Foo | Bar)`.\n-    crate or_patterns: Lock<Vec<Span>>,\n-    /// Spans collected for gating `const_extern_fn`, e.g. `const extern fn foo`.\n-    crate const_extern_fn: Lock<Vec<Span>>,\n-    /// Spans collected for gating `trait_alias`, e.g. `trait Foo = Ord + Eq;`.\n-    pub trait_alias: Lock<Vec<Span>>,\n-    /// Spans collected for gating `associated_type_bounds`, e.g. `Iterator<Item: Ord>`.\n-    pub associated_type_bounds: Lock<Vec<Span>>,\n-    /// Spans collected for gating `crate_visibility_modifier`, e.g. `crate fn`.\n-    pub crate_visibility_modifier: Lock<Vec<Span>>,\n-    /// Spans collected for gating `const_generics`, e.g. `const N: usize`.\n-    pub const_generics: Lock<Vec<Span>>,\n-    /// Spans collected for gating `decl_macro`, e.g. `macro m() {}`.\n-    pub decl_macro: Lock<Vec<Span>>,\n-    /// Spans collected for gating `box_patterns`, e.g. `box 0`.\n-    pub box_patterns: Lock<Vec<Span>>,\n-    /// Spans collected for gating `exclusive_range_pattern`, e.g. `0..2`.\n-    pub exclusive_range_pattern: Lock<Vec<Span>>,\n-    /// Spans collected for gating `try_blocks`, e.g. `try { a? + b? }`.\n-    pub try_blocks: Lock<Vec<Span>>,\n-    /// Spans collected for gating `label_break_value`, e.g. `'label: { ... }`.\n-    pub label_break_value: Lock<Vec<Span>>,\n-    /// Spans collected for gating `box_syntax`, e.g. `box $expr`.\n-    pub box_syntax: Lock<Vec<Span>>,\n-    /// Spans collected for gating `type_ascription`, e.g. `42: usize`.\n-    pub type_ascription: Lock<Vec<Span>>,\n+pub struct GatedSpans {\n+    pub spans: Lock<FxHashMap<Symbol, Vec<Span>>>,\n+}\n+\n+impl GatedSpans {\n+    /// Feature gate the given `span` under the given `feature`\n+    /// which is same `Symbol` used in `active.rs`.\n+    pub fn gate(&self, feature: Symbol, span: Span) {\n+        self.spans\n+            .borrow_mut()\n+            .entry(feature)\n+            .or_default()\n+            .push(span);\n+    }\n+\n+    /// Ungate the last span under the given `feature`.\n+    /// Panics if the given `span` wasn't the last one.\n+    ///\n+    /// Using this is discouraged unless you have a really good reason to.\n+    pub fn ungate_last(&self, feature: Symbol, span: Span) {\n+        let removed_span = self.spans\n+            .borrow_mut()\n+            .entry(feature)\n+            .or_default()\n+            .pop()\n+            .unwrap();\n+        debug_assert_eq!(span, removed_span);\n+    }\n+\n+    /// Is the provided `feature` gate ungated currently?\n+    ///\n+    /// Using this is discouraged unless you have a really good reason to.\n+    pub fn is_ungated(&self, feature: Symbol) -> bool {\n+        self.spans\n+            .borrow()\n+            .get(&feature)\n+            .map_or(true, |spans| spans.is_empty())\n+    }\n+\n+    /// Prepend the given set of `spans` onto the set in `self`.\n+    pub fn merge(&self, mut spans: FxHashMap<Symbol, Vec<Span>>) {\n+        let mut inner = self.spans.borrow_mut();\n+        for (gate, mut gate_spans) in inner.drain() {\n+            spans.entry(gate).or_default().append(&mut gate_spans);\n+        }\n+        *inner = spans;\n+    }\n }\n \n /// Info about a parsing session.\n@@ -72,7 +86,7 @@ pub struct ParseSess {\n     /// analysis.\n     pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n     pub injected_crate_name: Once<Symbol>,\n-    crate gated_spans: GatedSpans,\n+    pub gated_spans: GatedSpans,\n     /// The parser has reached `Eof` due to an unclosed brace. Used to silence unnecessary errors.\n     pub reached_eof: Lock<bool>,\n }"}, {"sha": "5571990740317f2dfbc50fd13bc53602d14e7e00", "filename": "src/libsyntax_expand/mbe/macro_rules.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -29,7 +29,7 @@ use syntax_pos::Span;\n use rustc_data_structures::fx::FxHashMap;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n-use std::slice;\n+use std::{mem, slice};\n \n use errors::Applicability;\n use rustc_data_structures::sync::Lrc;\n@@ -182,16 +182,25 @@ fn generic_extension<'cx>(\n \n     // Which arm's failure should we report? (the one furthest along)\n     let mut best_failure: Option<(Token, &str)> = None;\n-\n     for (i, lhs) in lhses.iter().enumerate() {\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n             mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n             _ => cx.span_bug(sp, \"malformed macro lhs\"),\n         };\n \n+        // Take a snapshot of the state of pre-expansion gating at this point.\n+        // This is used so that if a matcher is not `Success(..)`ful,\n+        // then the spans which became gated when parsing the unsucessful matcher\n+        // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n+        let mut gated_spans_snaphot = mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n+\n         match parse_tt(cx, lhs_tt, arg.clone()) {\n             Success(named_matches) => {\n+                // The matcher was `Success(..)`ful.\n+                // Merge the gated spans from parsing the matcher with the pre-existing ones.\n+                cx.parse_sess.gated_spans.merge(gated_spans_snaphot);\n+\n                 let rhs = match rhses[i] {\n                     // ignore delimiters\n                     mbe::TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n@@ -248,6 +257,10 @@ fn generic_extension<'cx>(\n             },\n             Error(err_sp, ref msg) => cx.span_fatal(err_sp.substitute_dummy(sp), &msg[..]),\n         }\n+\n+        // The matcher was not `Success(..)`ful.\n+        // Restore to the state before snapshotting and maybe try again.\n+        mem::swap(&mut gated_spans_snaphot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n     }\n \n     let (token, label) = best_failure.expect(\"ran no matchers\");"}, {"sha": "9d68a7bffdeeebfb96b5b3617ea7d8c4cc5ac4fb", "filename": "src/test/ui/parser/issue-65846-rollback-gating-failing-matcher.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Ftest%2Fui%2Fparser%2Fissue-65846-rollback-gating-failing-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19cb40fda70ea3f75bc1927c114ea53d231b288/src%2Ftest%2Fui%2Fparser%2Fissue-65846-rollback-gating-failing-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-65846-rollback-gating-failing-matcher.rs?ref=e19cb40fda70ea3f75bc1927c114ea53d231b288", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+\n+// Test that failing macro matchers will not cause pre-expansion errors\n+// even though they use a feature that is pre-expansion gated.\n+\n+macro_rules! m {\n+    ($e:expr) => { 0 }; // This fails on the input below due to `, foo`.\n+    ($e:expr,) => { 1 }; // This also fails to match due to `foo`.\n+    (box $e:expr, foo) => { 2 }; // Successful matcher, we should get `2`.\n+}\n+\n+fn main() {\n+    assert_eq!(2, m!(box 42, foo));\n+}"}]}