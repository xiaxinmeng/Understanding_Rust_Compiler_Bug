{"sha": "88860d5474a32f507dde8fba8df35fd2064f11b9", "node_id": "C_kwDOAAsO6NoAKDg4ODYwZDU0NzRhMzJmNTA3ZGRlOGZiYThkZjM1ZmQyMDY0ZjExYjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-09T19:52:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-09T19:52:59Z"}, "message": "Auto merge of #96473 - lcnr:querify-codegen-fn-attrs, r=cjgillot\n\nstore `codegen_fn_attrs` in crate metadata\n\nextracted from #95562 because the change isn't trivial.", "tree": {"sha": "6e2a0e95b8ce4de533bd8cc4e8d5484d2aacf885", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e2a0e95b8ce4de533bd8cc4e8d5484d2aacf885"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88860d5474a32f507dde8fba8df35fd2064f11b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88860d5474a32f507dde8fba8df35fd2064f11b9", "html_url": "https://github.com/rust-lang/rust/commit/88860d5474a32f507dde8fba8df35fd2064f11b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88860d5474a32f507dde8fba8df35fd2064f11b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355", "html_url": "https://github.com/rust-lang/rust/commit/0dd7e10282aaa7a3e1f5660f8bb043ee4ea07355"}, {"sha": "32b13ac9280d15273ef17ee474c0f0a738bb5f5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/32b13ac9280d15273ef17ee474c0f0a738bb5f5a", "html_url": "https://github.com/rust-lang/rust/commit/32b13ac9280d15273ef17ee474c0f0a738bb5f5a"}], "stats": {"total": 351, "additions": 229, "deletions": 122}, "files": [{"sha": "a639df01a78d4acbe1fb4f70d4a5cabe0a8a5580", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -229,6 +229,43 @@ impl DefKind {\n             _ => false,\n         }\n     }\n+\n+    /// Whether `query get_codegen_attrs` should be used with this definition.\n+    pub fn has_codegen_attrs(self) -> bool {\n+        match self {\n+            DefKind::Fn\n+            | DefKind::AssocFn\n+            | DefKind::Ctor(..)\n+            | DefKind::Closure\n+            | DefKind::Generator\n+            | DefKind::Static(_) => true,\n+            DefKind::Mod\n+            | DefKind::Struct\n+            | DefKind::Union\n+            | DefKind::Enum\n+            | DefKind::Variant\n+            | DefKind::Trait\n+            | DefKind::TyAlias\n+            | DefKind::ForeignTy\n+            | DefKind::TraitAlias\n+            | DefKind::AssocTy\n+            | DefKind::Const\n+            | DefKind::AssocConst\n+            | DefKind::Macro(..)\n+            | DefKind::Use\n+            | DefKind::ForeignMod\n+            | DefKind::OpaqueTy\n+            | DefKind::Impl\n+            | DefKind::Field\n+            | DefKind::TyParam\n+            | DefKind::ConstParam\n+            | DefKind::LifetimeParam\n+            | DefKind::AnonConst\n+            | DefKind::InlineConst\n+            | DefKind::GlobalAsm\n+            | DefKind::ExternCrate => false,\n+        }\n+    }\n }\n \n /// The resolution of a path or export."}, {"sha": "9f7ef3981c75b6ff5a922a5164bb2b1abde43b21", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -129,6 +129,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     type_of => { table }\n     variances_of => { table }\n     fn_sig => { table }\n+    codegen_fn_attrs => { table }\n     impl_trait_ref => { table }\n     const_param_default => { table }\n     thir_abstract_const => { table }"}, {"sha": "81388a0bf585ddac473097ad7c799a4524dc2a2c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -1007,6 +1007,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             record!(self.tables.def_span[def_id] <- tcx.def_span(def_id));\n             self.encode_attrs(def_id);\n             record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n+            if def_kind.has_codegen_attrs() {\n+                record!(self.tables.codegen_fn_attrs[def_id] <- self.tcx.codegen_fn_attrs(def_id));\n+            }\n             if should_encode_visibility(def_kind) {\n                 record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n             }"}, {"sha": "356dad4b56be1b404a19836fbd20c266bae3d734", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -14,6 +14,7 @@ use rustc_hir::definitions::DefKey;\n use rustc_hir::lang_items;\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_middle::metadata::ModChild;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use rustc_middle::mir;\n use rustc_middle::thir;\n@@ -329,6 +330,7 @@ define_tables! {\n     type_of: Table<DefIndex, Lazy!(Ty<'tcx>)>,\n     variances_of: Table<DefIndex, Lazy<[ty::Variance]>>,\n     fn_sig: Table<DefIndex, Lazy!(ty::PolyFnSig<'tcx>)>,\n+    codegen_fn_attrs: Table<DefIndex, Lazy!(CodegenFnAttrs)>,\n     impl_trait_ref: Table<DefIndex, Lazy!(ty::TraitRef<'tcx>)>,\n     const_param_default: Table<DefIndex, Lazy<rustc_middle::ty::Const<'tcx>>>,\n     optimized_mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,"}, {"sha": "321fcd43797cc18f5feb7e0739264548dd9e29ee", "filename": "compiler/rustc_middle/src/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -95,7 +95,9 @@ bitflags! {\n }\n \n impl CodegenFnAttrs {\n-    pub fn new() -> CodegenFnAttrs {\n+    pub const EMPTY: &'static Self = &Self::new();\n+\n+    pub const fn new() -> CodegenFnAttrs {\n         CodegenFnAttrs {\n             flags: CodegenFnAttrFlags::empty(),\n             inline: InlineAttr::None,"}, {"sha": "629a550b77596cbcf887cc9712e1097d387d3280", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -1080,7 +1080,8 @@ rustc_queries! {\n     query codegen_fn_attrs(def_id: DefId) -> CodegenFnAttrs {\n         desc { |tcx| \"computing codegen attributes of `{}`\", tcx.def_path_str(def_id) }\n         storage(ArenaCacheSelector<'tcx>)\n-        cache_on_disk_if { true }\n+        cache_on_disk_if { def_id.is_local() }\n+        separate_provide_extern\n     }\n \n     query asm_target_features(def_id: DefId) -> &'tcx FxHashSet<Symbol> {"}, {"sha": "9d3d509eb216beca26e858efd1b759f209f67966", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -5,6 +5,7 @@ use crate::dep_graph::{DepGraph, DepKind, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n+use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath};\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation, ConstValue, Scalar};\n@@ -1066,6 +1067,28 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n+    /// Expects a body and returns its codegen attributes.\n+    ///\n+    /// Unlike `codegen_fn_attrs`, this returns `CodegenFnAttrs::EMPTY` for\n+    /// constants.\n+    pub fn body_codegen_attrs(self, def_id: DefId) -> &'tcx CodegenFnAttrs {\n+        let def_kind = self.def_kind(def_id);\n+        if def_kind.has_codegen_attrs() {\n+            self.codegen_fn_attrs(def_id)\n+        } else if matches!(\n+            def_kind,\n+            DefKind::AnonConst | DefKind::AssocConst | DefKind::Const | DefKind::InlineConst\n+        ) {\n+            CodegenFnAttrs::EMPTY\n+        } else {\n+            bug!(\n+                \"body_codegen_fn_attrs called on unexpected definition: {:?} {:?}\",\n+                def_id,\n+                def_kind\n+            )\n+        }\n+    }\n+\n     pub fn typeck_opt_const_arg(\n         self,\n         def: ty::WithOptConstParam<LocalDefId>,"}, {"sha": "7cf7f8973475d26a766e9577848442e6cb2dab4c", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -246,7 +246,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         match *self {\n             InstanceDef::Item(ty::WithOptConstParam { did: def_id, .. })\n             | InstanceDef::Virtual(def_id, _) => {\n-                tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::TRACK_CALLER)\n+                tcx.body_codegen_attrs(def_id).flags.contains(CodegenFnAttrFlags::TRACK_CALLER)\n             }\n             InstanceDef::ClosureOnceShim { call_once: _, track_caller } => track_caller,\n             _ => false,"}, {"sha": "61f6dab1b2145332322fd174384672a3deb59f43", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -6,6 +6,7 @@ use crate::ty::{self, subst::SubstsRef, ReprOptions, Ty, TyCtxt, TypeFoldable};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -2762,14 +2763,22 @@ impl<'tcx> ty::Instance<'tcx> {\n /// with `-Cpanic=abort` will look like they can't unwind when in fact they\n /// might (from a foreign exception or similar).\n #[inline]\n-pub fn fn_can_unwind<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    codegen_fn_attr_flags: CodegenFnAttrFlags,\n-    abi: SpecAbi,\n-) -> bool {\n-    // Special attribute for functions which can't unwind.\n-    if codegen_fn_attr_flags.contains(CodegenFnAttrFlags::NEVER_UNWIND) {\n-        return false;\n+pub fn fn_can_unwind<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: Option<DefId>, abi: SpecAbi) -> bool {\n+    if let Some(did) = fn_def_id {\n+        // Special attribute for functions which can't unwind.\n+        if tcx.codegen_fn_attrs(did).flags.contains(CodegenFnAttrFlags::NEVER_UNWIND) {\n+            return false;\n+        }\n+\n+        // With -Z panic-in-drop=abort, drop_in_place never unwinds.\n+        //\n+        // This is not part of `codegen_fn_attrs` as it can differ between crates\n+        // and therefore cannot be computed in core.\n+        if tcx.sess.opts.debugging_opts.panic_in_drop == PanicStrategy::Abort {\n+            if Some(did) == tcx.lang_items().drop_in_place_fn() {\n+                return false;\n+            }\n+        }\n     }\n \n     // Otherwise if this isn't special then unwinding is generally determined by\n@@ -2991,13 +3000,7 @@ fn fn_abi_of_fn_ptr<'tcx>(\n ) -> Result<&'tcx FnAbi<'tcx, Ty<'tcx>>, FnAbiError<'tcx>> {\n     let (param_env, (sig, extra_args)) = query.into_parts();\n \n-    LayoutCx { tcx, param_env }.fn_abi_new_uncached(\n-        sig,\n-        extra_args,\n-        None,\n-        CodegenFnAttrFlags::empty(),\n-        false,\n-    )\n+    LayoutCx { tcx, param_env }.fn_abi_new_uncached(sig, extra_args, None, None, false)\n }\n \n fn fn_abi_of_instance<'tcx>(\n@@ -3014,13 +3017,11 @@ fn fn_abi_of_instance<'tcx>(\n         None\n     };\n \n-    let attrs = tcx.codegen_fn_attrs(instance.def_id()).flags;\n-\n     LayoutCx { tcx, param_env }.fn_abi_new_uncached(\n         sig,\n         extra_args,\n         caller_location,\n-        attrs,\n+        Some(instance.def_id()),\n         matches!(instance.def, ty::InstanceDef::Virtual(..)),\n     )\n }\n@@ -3033,7 +3034,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         sig: ty::PolyFnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         caller_location: Option<Ty<'tcx>>,\n-        codegen_fn_attr_flags: CodegenFnAttrFlags,\n+        fn_def_id: Option<DefId>,\n         // FIXME(eddyb) replace this with something typed, like an `enum`.\n         force_thin_self_ptr: bool,\n     ) -> Result<&'tcx FnAbi<'tcx, Ty<'tcx>>, FnAbiError<'tcx>> {\n@@ -3205,7 +3206,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             c_variadic: sig.c_variadic,\n             fixed_count: inputs.len(),\n             conv,\n-            can_unwind: fn_can_unwind(self.tcx(), codegen_fn_attr_flags, sig.abi),\n+            can_unwind: fn_can_unwind(self.tcx(), fn_def_id, sig.abi),\n         };\n         self.fn_abi_adjust_for_abi(&mut fn_abi, sig.abi)?;\n         debug!(\"fn_abi_new_uncached = {:?}\", fn_abi);"}, {"sha": "6c14f207a7d14d7747f6dd1b2630f2ce29feb7a0", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -27,7 +27,7 @@ struct UnsafetyVisitor<'a, 'tcx> {\n     body_unsafety: BodyUnsafety,\n     /// The `#[target_feature]` attributes of the body. Used for checking\n     /// calls to functions with `#[target_feature]` (RFC 2396).\n-    body_target_features: &'tcx Vec<Symbol>,\n+    body_target_features: &'tcx [Symbol],\n     /// When inside the LHS of an assignment to a field, this is the type\n     /// of the LHS and the span of the assignment expression.\n     assignment_info: Option<(Ty<'tcx>, Span)>,\n@@ -643,9 +643,8 @@ pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalD\n         return;\n     }\n \n-    let (thir, expr) = match tcx.thir_body(def) {\n-        Ok(body) => body,\n-        Err(_) => return,\n+    let Ok((thir, expr)) = tcx.thir_body(def) else {\n+        return\n     };\n     let thir = &thir.borrow();\n     // If `thir` is empty, a type error occurred, skip this body.\n@@ -661,7 +660,7 @@ pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalD\n             BodyUnsafety::Safe\n         }\n     });\n-    let body_target_features = &tcx.codegen_fn_attrs(def.did).target_features;\n+    let body_target_features = &tcx.body_codegen_attrs(def.did.to_def_id()).target_features;\n     let safety_context =\n         if body_unsafety.is_unsafe() { SafetyContext::UnsafeFn } else { SafetyContext::Safe };\n     let mut visitor = UnsafetyVisitor {"}, {"sha": "ade6555f4d2c1c7c6a31791164340c77755e3cef", "filename": "compiler/rustc_mir_transform/src/abort_unwinding_calls.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -1,6 +1,5 @@\n use crate::MirPass;\n use rustc_hir::def::DefKind;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::*;\n use rustc_middle::ty::layout;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -46,15 +45,14 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n         //\n         // Here we test for this function itself whether its ABI allows\n         // unwinding or not.\n-        let body_flags = tcx.codegen_fn_attrs(def_id).flags;\n         let body_ty = tcx.type_of(def_id);\n         let body_abi = match body_ty.kind() {\n             ty::FnDef(..) => body_ty.fn_sig(tcx).abi(),\n             ty::Closure(..) => Abi::RustCall,\n             ty::Generator(..) => Abi::Rust,\n             _ => span_bug!(body.span, \"unexpected body ty: {:?}\", body_ty),\n         };\n-        let body_can_unwind = layout::fn_can_unwind(tcx, body_flags, body_abi);\n+        let body_can_unwind = layout::fn_can_unwind(tcx, Some(def_id), body_abi);\n \n         // Look in this function body for any basic blocks which are terminated\n         // with a function call, and whose function we're calling may unwind.\n@@ -73,19 +71,19 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n                 TerminatorKind::Call { func, .. } => {\n                     let ty = func.ty(body, tcx);\n                     let sig = ty.fn_sig(tcx);\n-                    let flags = match ty.kind() {\n-                        ty::FnPtr(_) => CodegenFnAttrFlags::empty(),\n-                        ty::FnDef(def_id, _) => tcx.codegen_fn_attrs(*def_id).flags,\n+                    let fn_def_id = match ty.kind() {\n+                        ty::FnPtr(_) => None,\n+                        &ty::FnDef(def_id, _) => Some(def_id),\n                         _ => span_bug!(span, \"invalid callee of type {:?}\", ty),\n                     };\n-                    layout::fn_can_unwind(tcx, flags, sig.abi())\n+                    layout::fn_can_unwind(tcx, fn_def_id, sig.abi())\n                 }\n                 TerminatorKind::Drop { .. } | TerminatorKind::DropAndReplace { .. } => {\n                     tcx.sess.opts.debugging_opts.panic_in_drop == PanicStrategy::Unwind\n-                        && layout::fn_can_unwind(tcx, CodegenFnAttrFlags::empty(), Abi::Rust)\n+                        && layout::fn_can_unwind(tcx, None, Abi::Rust)\n                 }\n                 TerminatorKind::Assert { .. } | TerminatorKind::FalseUnwind { .. } => {\n-                    layout::fn_can_unwind(tcx, CodegenFnAttrFlags::empty(), Abi::Rust)\n+                    layout::fn_can_unwind(tcx, None, Abi::Rust)\n                 }\n                 _ => continue,\n             };"}, {"sha": "1f73b7da815c505e1b9a7c6f98f2987eca4e36f3", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -375,7 +375,8 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n         }\n \n         let callee_features = &self.tcx.codegen_fn_attrs(func_did).target_features;\n-        let self_features = &self.tcx.codegen_fn_attrs(self.body_did).target_features;\n+        // The body might be a constant, so it doesn't have codegen attributes.\n+        let self_features = &self.tcx.body_codegen_attrs(self.body_did.to_def_id()).target_features;\n \n         // Is `callee_features` a subset of `calling_features`?\n         if !callee_features.iter().all(|feature| self_features.contains(feature)) {"}, {"sha": "8d207e4e1a92489b1857b1bf0fb8a7f7610259ba", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -105,6 +105,9 @@ impl CheckAttrVisitor<'_> {\n                 sym::rustc_allow_const_fn_unstable => {\n                     self.check_rustc_allow_const_fn_unstable(hir_id, &attr, span, target)\n                 }\n+                sym::rustc_std_internal_symbol => {\n+                    self.check_rustc_std_internal_symbol(&attr, span, target)\n+                }\n                 sym::naked => self.check_naked(hir_id, attr, span, target),\n                 sym::rustc_legacy_const_generics => {\n                     self.check_rustc_legacy_const_generics(&attr, span, target, item)\n@@ -194,6 +197,7 @@ impl CheckAttrVisitor<'_> {\n             return;\n         }\n \n+        // FIXME(@lcnr): this doesn't belong here.\n         if matches!(target, Target::Closure | Target::Fn | Target::Method(_) | Target::ForeignFn) {\n             self.tcx.ensure().codegen_fn_attrs(self.tcx.hir().local_def_id(hir_id));\n         }\n@@ -1731,7 +1735,7 @@ impl CheckAttrVisitor<'_> {\n                     }\n                 }\n                 sym::align => {\n-                    if let (Target::Fn, true) = (target, !self.tcx.features().fn_align) {\n+                    if let (Target::Fn, false) = (target, self.tcx.features().fn_align) {\n                         feature_err(\n                             &self.tcx.sess.parse_sess,\n                             sym::fn_align,\n@@ -2052,6 +2056,25 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    fn check_rustc_std_internal_symbol(\n+        &self,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n+        match target {\n+            Target::Fn | Target::Static => true,\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(attr.span, \"attribute should be applied functions or statics\")\n+                    .span_label(span, \"not a function or static\")\n+                    .emit();\n+                false\n+            }\n+        }\n+    }\n+\n     /// default_method_body_is_const should only be applied to trait methods with default bodies.\n     fn check_default_method_body_is_const(\n         &self,"}, {"sha": "df28ea4d444baafe6327d90277ef7cd8963182d9", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -452,15 +452,17 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n     }\n \n     let def_id = tcx.hir().local_def_id(id);\n-    let cg_attrs = tcx.codegen_fn_attrs(def_id);\n-\n-    // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n-    // forcefully, e.g., for placing it in a specific section.\n-    if cg_attrs.contains_extern_indicator()\n-        || cg_attrs.flags.contains(CodegenFnAttrFlags::USED)\n-        || cg_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n-    {\n-        return true;\n+    if tcx.def_kind(def_id).has_codegen_attrs() {\n+        let cg_attrs = tcx.codegen_fn_attrs(def_id);\n+\n+        // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n+        // forcefully, e.g., for placing it in a specific section.\n+        if cg_attrs.contains_extern_indicator()\n+            || cg_attrs.flags.contains(CodegenFnAttrFlags::USED)\n+            || cg_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n+        {\n+            return true;\n+        }\n     }\n \n     tcx.lint_level_at_node(lint::builtin::DEAD_CODE, id).0 == lint::Allow"}, {"sha": "a5133bfd9459cf10d7f92fb0285f85bdf05f4579", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -208,7 +208,11 @@ impl<'tcx> ReachableContext<'tcx> {\n                 } else {\n                     false\n                 };\n-            let codegen_attrs = self.tcx.codegen_fn_attrs(search_item);\n+            let codegen_attrs = if self.tcx.def_kind(search_item).has_codegen_attrs() {\n+                self.tcx.codegen_fn_attrs(search_item)\n+            } else {\n+                CodegenFnAttrs::EMPTY\n+            };\n             let is_extern = codegen_attrs.contains_extern_indicator();\n             let std_internal =\n                 codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n@@ -329,16 +333,18 @@ impl CollectPrivateImplItemsVisitor<'_, '_> {\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\"\n         // which are currently akin to allocator symbols.\n-        let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n-        if codegen_attrs.contains_extern_indicator()\n-            || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n-            // FIXME(nbdd0121): `#[used]` are marked as reachable here so it's picked up by\n-            // `linked_symbols` in cg_ssa. They won't be exported in binary or cdylib due to their\n-            // `SymbolExportLevel::Rust` export level but may end up being exported in dylibs.\n-            || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED)\n-            || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n-        {\n-            self.worklist.push(def_id);\n+        if self.tcx.def_kind(def_id).has_codegen_attrs() {\n+            let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n+            if codegen_attrs.contains_extern_indicator()\n+                || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n+                // FIXME(nbdd0121): `#[used]` are marked as reachable here so it's picked up by\n+                // `linked_symbols` in cg_ssa. They won't be exported in binary or cdylib due to their\n+                // `SymbolExportLevel::Rust` export level but may end up being exported in dylibs.\n+                || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED)\n+                || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n+            {\n+                self.worklist.push(def_id);\n+            }\n         }\n     }\n }"}, {"sha": "ee0994c9ad6ccf431d9168f04b39f98e4c1eeff0", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -96,8 +96,10 @@\n #[macro_use]\n extern crate rustc_middle;\n \n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::SubstsRef;\n@@ -175,7 +177,11 @@ fn compute_symbol_name<'tcx>(\n     }\n \n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-    let attrs = tcx.codegen_fn_attrs(def_id);\n+    let attrs = if tcx.def_kind(def_id).has_codegen_attrs() {\n+        tcx.codegen_fn_attrs(def_id)\n+    } else {\n+        CodegenFnAttrs::EMPTY\n+    };\n \n     // Foreign items by default use no mangling for their symbol name. There's a\n     // few exceptions to this rule though:\n@@ -213,20 +219,25 @@ fn compute_symbol_name<'tcx>(\n         return tcx.item_name(def_id).to_string();\n     }\n \n-    let avoid_cross_crate_conflicts =\n-        // If this is an instance of a generic function, we also hash in\n-        // the ID of the instantiating crate. This avoids symbol conflicts\n-        // in case the same instances is emitted in two crates of the same\n-        // project.\n-        is_generic(substs) ||\n+    // If we're dealing with an instance of a function that's inlined from\n+    // another crate but we're marking it as globally shared to our\n+    // compilation (aka we're not making an internal copy in each of our\n+    // codegen units) then this symbol may become an exported (but hidden\n+    // visibility) symbol. This means that multiple crates may do the same\n+    // and we want to be sure to avoid any symbol conflicts here.\n+    let is_globally_shared_function = matches!(\n+        tcx.def_kind(instance.def_id()),\n+        DefKind::Fn | DefKind::AssocFn | DefKind::Closure | DefKind::Generator | DefKind::Ctor(..)\n+    ) && matches!(\n+        MonoItem::Fn(instance).instantiation_mode(tcx),\n+        InstantiationMode::GloballyShared { may_conflict: true }\n+    );\n \n-        // If we're dealing with an instance of a function that's inlined from\n-        // another crate but we're marking it as globally shared to our\n-        // compilation (aka we're not making an internal copy in each of our\n-        // codegen units) then this symbol may become an exported (but hidden\n-        // visibility) symbol. This means that multiple crates may do the same\n-        // and we want to be sure to avoid any symbol conflicts here.\n-        matches!(MonoItem::Fn(instance).instantiation_mode(tcx), InstantiationMode::GloballyShared { may_conflict: true });\n+    // If this is an instance of a generic function, we also hash in\n+    // the ID of the instantiating crate. This avoids symbol conflicts\n+    // in case the same instances is emitted in two crates of the same\n+    // project.\n+    let avoid_cross_crate_conflicts = is_generic(substs) || is_globally_shared_function;\n \n     let instantiating_crate =\n         if avoid_cross_crate_conflicts { Some(compute_instantiating_crate()) } else { None };"}, {"sha": "74714d75fa0eada943d1c3485a72d71e6feba6ab", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88860d5474a32f507dde8fba8df35fd2064f11b9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=88860d5474a32f507dde8fba8df35fd2064f11b9", "patch": "@@ -45,7 +45,7 @@ use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_target::spec::{abi, PanicStrategy, SanitizerSet};\n+use rustc_target::spec::{abi, SanitizerSet};\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n use std::iter;\n \n@@ -2610,7 +2610,6 @@ fn generator_kind(tcx: TyCtxt<'_>, def_id: DefId) -> Option<hir::GeneratorKind>\n \n fn from_target_feature(\n     tcx: TyCtxt<'_>,\n-    id: DefId,\n     attr: &ast::Attribute,\n     supported_target_features: &FxHashMap<String, Option<Symbol>>,\n     target_features: &mut Vec<Symbol>,\n@@ -2679,7 +2678,7 @@ fn from_target_feature(\n                 Some(name) => bug!(\"unknown target feature gate {}\", name),\n                 None => true,\n             };\n-            if !allowed && id.is_local() {\n+            if !allowed {\n                 feature_err(\n                     &tcx.sess.parse_sess,\n                     feature_gate.unwrap(),\n@@ -2693,7 +2692,7 @@ fn from_target_feature(\n     }\n }\n \n-fn linkage_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str) -> Linkage {\n+fn linkage_by_name(tcx: TyCtxt<'_>, def_id: LocalDefId, name: &str) -> Linkage {\n     use rustc_middle::mir::mono::Linkage::*;\n \n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n@@ -2716,36 +2715,30 @@ fn linkage_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str) -> Linkage {\n         \"private\" => Private,\n         \"weak\" => WeakAny,\n         \"weak_odr\" => WeakODR,\n-        _ => {\n-            let span = tcx.hir().span_if_local(def_id);\n-            if let Some(span) = span {\n-                tcx.sess.span_fatal(span, \"invalid linkage specified\")\n-            } else {\n-                tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n-            }\n-        }\n+        _ => tcx.sess.span_fatal(tcx.def_span(def_id), \"invalid linkage specified\"),\n     }\n }\n \n-fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n-    let attrs = tcx.get_attrs(id);\n+fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n+    if cfg!(debug_assertions) {\n+        let def_kind = tcx.def_kind(did);\n+        assert!(\n+            def_kind.has_codegen_attrs(),\n+            \"unexpected `def_kind` in `codegen_fn_attrs`: {def_kind:?}\",\n+        );\n+    }\n \n+    let did = did.expect_local();\n+    let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(did));\n     let mut codegen_fn_attrs = CodegenFnAttrs::new();\n-    if tcx.should_inherit_track_caller(id) {\n+    if tcx.should_inherit_track_caller(did) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n     }\n \n-    // With -Z panic-in-drop=abort, drop_in_place never unwinds.\n-    if tcx.sess.opts.debugging_opts.panic_in_drop == PanicStrategy::Abort {\n-        if Some(id) == tcx.lang_items().drop_in_place_fn() {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        }\n-    }\n-\n     // The panic_no_unwind function called by TerminatorKind::Abort will never\n     // unwind. If the panic handler that it invokes unwind then it will simply\n     // call the panic handler again.\n-    if Some(id) == tcx.lang_items().panic_no_unwind() {\n+    if Some(did.to_def_id()) == tcx.lang_items().panic_no_unwind() {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n     }\n \n@@ -2760,7 +2753,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         } else if attr.has_name(sym::rustc_allocator) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n         } else if attr.has_name(sym::ffi_returns_twice) {\n-            if tcx.is_foreign_item(id) {\n+            if tcx.is_foreign_item(did) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             } else {\n                 // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n@@ -2773,7 +2766,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 .emit();\n             }\n         } else if attr.has_name(sym::ffi_pure) {\n-            if tcx.is_foreign_item(id) {\n+            if tcx.is_foreign_item(did) {\n                 if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n                     // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n                     struct_span_err!(\n@@ -2797,7 +2790,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 .emit();\n             }\n         } else if attr.has_name(sym::ffi_const) {\n-            if tcx.is_foreign_item(id) {\n+            if tcx.is_foreign_item(did) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n             } else {\n                 // `#[ffi_const]` is only allowed on foreign functions\n@@ -2857,7 +2850,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 None => codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED,\n             }\n         } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if !matches!(tcx.fn_sig(id).abi(), abi::Abi::C { .. }) {\n+            if !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. }) {\n                 struct_span_err!(\n                     tcx.sess,\n                     attr.span,\n@@ -2874,11 +2867,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         } else if attr.has_name(sym::thread_local) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n         } else if attr.has_name(sym::track_caller) {\n-            if !tcx.is_closure(id) && tcx.fn_sig(id).abi() != abi::Abi::Rust {\n+            if !tcx.is_closure(did.to_def_id()) && tcx.fn_sig(did).abi() != abi::Abi::Rust {\n                 struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n                     .emit();\n             }\n-            if tcx.is_closure(id) && !tcx.features().closure_track_caller {\n+            if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n                 feature_err(\n                     &tcx.sess.parse_sess,\n                     sym::closure_track_caller,\n@@ -2904,7 +2897,9 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 codegen_fn_attrs.export_name = Some(s);\n             }\n         } else if attr.has_name(sym::target_feature) {\n-            if !tcx.is_closure(id) && tcx.fn_sig(id).unsafety() == hir::Unsafety::Normal {\n+            if !tcx.is_closure(did.to_def_id())\n+                && tcx.fn_sig(did).unsafety() == hir::Unsafety::Normal\n+            {\n                 if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n                     // The `#[target_feature]` attribute is allowed on\n                     // WebAssembly targets on all functions, including safe\n@@ -2930,22 +2925,21 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                         attr.span,\n                         \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n                     );\n-                    err.span_label(tcx.def_span(id), \"not an `unsafe` function\");\n+                    err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n                     err.emit();\n-                } else if let Some(local_id) = id.as_local() {\n-                    check_target_feature_trait_unsafe(tcx, local_id, attr.span);\n+                } else {\n+                    check_target_feature_trait_unsafe(tcx, did, attr.span);\n                 }\n             }\n             from_target_feature(\n                 tcx,\n-                id,\n                 attr,\n                 supported_target_features,\n                 &mut codegen_fn_attrs.target_features,\n             );\n         } else if attr.has_name(sym::linkage) {\n             if let Some(val) = attr.value_str() {\n-                codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, val.as_str()));\n+                codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n             }\n         } else if attr.has_name(sym::link_section) {\n             if let Some(val) = attr.value_str() {\n@@ -3161,8 +3155,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     });\n \n     // #73631: closures inherit `#[target_feature]` annotations\n-    if tcx.features().target_feature_11 && tcx.is_closure(id) {\n-        let owner_id = tcx.parent(id);\n+    if tcx.features().target_feature_11 && tcx.is_closure(did.to_def_id()) {\n+        let owner_id = tcx.parent(did.to_def_id());\n         codegen_fn_attrs\n             .target_features\n             .extend(tcx.codegen_fn_attrs(owner_id).target_features.iter().copied())\n@@ -3187,7 +3181,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if !codegen_fn_attrs.no_sanitize.is_empty() {\n         if codegen_fn_attrs.inline == InlineAttr::Always {\n             if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n                 tcx.struct_span_lint_hir(\n                     lint::builtin::INLINE_NO_SANITIZE,\n                     hir_id,\n@@ -3207,7 +3201,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     // strippable by the linker.\n     //\n     // Additionally weak lang items have predetermined symbol names.\n-    if tcx.is_weak_lang_item(id) {\n+    if tcx.is_weak_lang_item(did.to_def_id()) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n     }\n     if let Some(name) = weak_lang_items::link_name(attrs) {\n@@ -3237,19 +3231,22 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n \n /// Computes the set of target features used in a function for the purposes of\n /// inline assembly.\n-fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, id: DefId) -> &'tcx FxHashSet<Symbol> {\n+fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx FxHashSet<Symbol> {\n     let mut target_features = tcx.sess.target_features.clone();\n-    let attrs = tcx.codegen_fn_attrs(id);\n-    target_features.extend(&attrs.target_features);\n-    match attrs.instruction_set {\n-        None => {}\n-        Some(InstructionSetAttr::ArmA32) => {\n-            target_features.remove(&sym::thumb_mode);\n-        }\n-        Some(InstructionSetAttr::ArmT32) => {\n-            target_features.insert(sym::thumb_mode);\n+    if tcx.def_kind(did).has_codegen_attrs() {\n+        let attrs = tcx.codegen_fn_attrs(did);\n+        target_features.extend(&attrs.target_features);\n+        match attrs.instruction_set {\n+            None => {}\n+            Some(InstructionSetAttr::ArmA32) => {\n+                target_features.remove(&sym::thumb_mode);\n+            }\n+            Some(InstructionSetAttr::ArmT32) => {\n+                target_features.insert(sym::thumb_mode);\n+            }\n         }\n     }\n+\n     tcx.arena.alloc(target_features)\n }\n "}]}