{"sha": "1899c489d4c30b2640d30b77ac04f0a548834d81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OTljNDg5ZDRjMzBiMjY0MGQzMGI3N2FjMDRmMGE1NDg4MzRkODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-01T14:37:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-01T14:37:50Z"}, "message": "Auto merge of #78553 - Nadrieril:fix-78549, r=varkor\n\nFix #78549\n\nBefore #78430, this worked because `specialize_constructor` didn't actually care too much which constructor was passed to it unless needed. That PR however handles `&str` as a special case, and I did not anticipate patterns for the `&str` type other than string literals.\nI am not very confident there are not other similar oversights left, but hopefully only `&str` was different enough to break my assumptions.\n\nFixes https://github.com/rust-lang/rust/issues/78549", "tree": {"sha": "9eda71b4e2c53d61f41639397c35ade922f0604f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9eda71b4e2c53d61f41639397c35ade922f0604f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1899c489d4c30b2640d30b77ac04f0a548834d81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1899c489d4c30b2640d30b77ac04f0a548834d81", "html_url": "https://github.com/rust-lang/rust/commit/1899c489d4c30b2640d30b77ac04f0a548834d81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1899c489d4c30b2640d30b77ac04f0a548834d81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8cbaf2ae7fc5c564cacedbe55664797dc62d920", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8cbaf2ae7fc5c564cacedbe55664797dc62d920", "html_url": "https://github.com/rust-lang/rust/commit/e8cbaf2ae7fc5c564cacedbe55664797dc62d920"}, {"sha": "1bdcd02a70ef15d3602b52a340169ac68e757460", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bdcd02a70ef15d3602b52a340169ac68e757460", "html_url": "https://github.com/rust-lang/rust/commit/1bdcd02a70ef15d3602b52a340169ac68e757460"}], "stats": {"total": 124, "additions": 86, "deletions": 38}, "files": [{"sha": "e0de1351ac33ef1d26f40b47b5d0291022c0f645", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 55, "deletions": 32, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/1899c489d4c30b2640d30b77ac04f0a548834d81/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1899c489d4c30b2640d30b77ac04f0a548834d81/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=1899c489d4c30b2640d30b77ac04f0a548834d81", "patch": "@@ -327,9 +327,23 @@ struct LiteralExpander;\n impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n-        match (pat.ty.kind(), &*pat.kind) {\n-            (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n-            (_, &PatKind::AscribeUserType { subpattern: ref s, .. }) => s.fold_with(self),\n+        match (pat.ty.kind(), pat.kind.as_ref()) {\n+            (_, PatKind::Binding { subpattern: Some(s), .. }) => s.fold_with(self),\n+            (_, PatKind::AscribeUserType { subpattern: s, .. }) => s.fold_with(self),\n+            (ty::Ref(_, t, _), PatKind::Constant { .. }) if t.is_str() => {\n+                // Treat string literal patterns as deref patterns to a `str` constant, i.e.\n+                // `&CONST`. This expands them like other const patterns. This could have been done\n+                // in `const_to_pat`, but that causes issues with the rest of the matching code.\n+                let mut new_pat = pat.super_fold_with(self);\n+                // Make a fake const pattern of type `str` (instead of `&str`). That the carried\n+                // constant value still knows it is of type `&str`.\n+                new_pat.ty = t;\n+                Pat {\n+                    kind: Box::new(PatKind::Deref { subpattern: new_pat }),\n+                    span: pat.span,\n+                    ty: pat.ty,\n+                }\n+            }\n             _ => pat.super_fold_with(self),\n         }\n     }\n@@ -782,11 +796,9 @@ enum Constructor<'tcx> {\n     /// boxes for the purposes of exhaustiveness: we must not inspect them, and they\n     /// don't count towards making a match exhaustive.\n     Opaque,\n-    /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n+    /// Fake extra constructor for enums that aren't allowed to be matched exhaustively. Also used\n+    /// for those types for which we cannot list constructors explicitly, like `f64` and `str`.\n     NonExhaustive,\n-    /// Fake constructor for those types for which we can't list constructors explicitly, like\n-    /// `f64` and `&str`.\n-    Unlistable,\n     /// Wildcard pattern.\n     Wildcard,\n }\n@@ -880,6 +892,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// For the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n     /// this checks for inclusion.\n     fn is_covered_by<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, other: &Self) -> bool {\n+        // This must be kept in sync with `is_covered_by_any`.\n         match (self, other) {\n             // Wildcards cover anything\n             (_, Wildcard) => true,\n@@ -922,18 +935,19 @@ impl<'tcx> Constructor<'tcx> {\n             (Opaque, _) | (_, Opaque) => false,\n             // Only a wildcard pattern can match the special extra constructor.\n             (NonExhaustive, _) => false,\n-            // If we encounter a `Single` here, this means there was only one constructor for this\n-            // type after all.\n-            (Unlistable, Single) => true,\n-            // Otherwise, only a wildcard pattern can match the special extra constructor.\n-            (Unlistable, _) => false,\n \n-            _ => bug!(\"trying to compare incompatible constructors {:?} and {:?}\", self, other),\n+            _ => span_bug!(\n+                pcx.span,\n+                \"trying to compare incompatible constructors {:?} and {:?}\",\n+                self,\n+                other\n+            ),\n         }\n     }\n \n     /// Faster version of `is_covered_by` when applied to many constructors. `used_ctors` is\n-    /// assumed to be built from `matrix.head_ctors()`, and `self` is assumed to have been split.\n+    /// assumed to be built from `matrix.head_ctors()` with wildcards filtered out, and `self` is\n+    /// assumed to have been split from a wildcard.\n     fn is_covered_by_any<'p>(\n         &self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n@@ -943,8 +957,9 @@ impl<'tcx> Constructor<'tcx> {\n             return false;\n         }\n \n+        // This must be kept in sync with `is_covered_by`.\n         match self {\n-            // `used_ctors` cannot contain anything else than `Single`s.\n+            // If `self` is `Single`, `used_ctors` cannot contain anything else than `Single`s.\n             Single => !used_ctors.is_empty(),\n             Variant(_) => used_ctors.iter().any(|c| c == self),\n             IntRange(range) => used_ctors\n@@ -957,8 +972,6 @@ impl<'tcx> Constructor<'tcx> {\n                 .any(|other| slice.is_covered_by(other)),\n             // This constructor is never covered by anything else\n             NonExhaustive => false,\n-            // This constructor is only covered by `Single`s\n-            Unlistable => used_ctors.iter().any(|c| *c == Single),\n             Str(..) | FloatRange(..) | Opaque | Wildcard => {\n                 bug!(\"found unexpected ctor in all_ctors: {:?}\", self)\n             }\n@@ -1006,6 +1019,10 @@ impl<'tcx> Constructor<'tcx> {\n                         PatKind::Leaf { subpatterns }\n                     }\n                 }\n+                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n+                // be careful to reconstruct the correct constant pattern here. However a string\n+                // literal pattern will never be reported as a non-exhaustiveness witness, so we\n+                // can ignore this issue.\n                 ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n                 ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, pcx.ty),\n                 _ => PatKind::Wild,\n@@ -1038,7 +1055,7 @@ impl<'tcx> Constructor<'tcx> {\n             &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(pcx.cx.tcx),\n-            NonExhaustive | Unlistable => PatKind::Wild,\n+            NonExhaustive => PatKind::Wild,\n             Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n             Wildcard => bug!(\n                 \"trying to apply a wildcard constructor; this should have been done in `apply_constructors`\"\n@@ -1187,8 +1204,9 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Unlistable\n-            | Wildcard => Fields::empty(),\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Wildcard => {\n+                Fields::empty()\n+            }\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -1300,9 +1318,13 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     ///     [Some(0), ..] => {}\n     /// }\n     /// ```\n+    /// This is guaranteed to preserve the number of patterns in `self`.\n     fn replace_with_pattern_arguments(&self, pat: &'p Pat<'tcx>) -> Self {\n         match pat.kind.as_ref() {\n-            PatKind::Deref { subpattern } => Self::from_single_pattern(subpattern),\n+            PatKind::Deref { subpattern } => {\n+                assert_eq!(self.len(), 1);\n+                Fields::from_single_pattern(subpattern)\n+            }\n             PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n                 self.replace_with_fieldpats(subpatterns)\n             }\n@@ -1590,10 +1612,9 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             vec![make_range(0, max)]\n         }\n         _ if cx.is_uninhabited(pcx.ty) => vec![],\n-        ty::Adt(..) | ty::Tuple(..) => vec![Single],\n-        ty::Ref(_, t, _) if !t.is_str() => vec![Single],\n-        // This type is one for which we don't know how to list constructors, like `&str` or `f64`.\n-        _ => vec![Unlistable],\n+        ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => vec![Single],\n+        // This type is one for which we cannot list constructors, like `str` or `f64`.\n+        _ => vec![NonExhaustive],\n     }\n }\n \n@@ -2152,28 +2173,31 @@ fn pat_constructor<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     pat: &'p Pat<'tcx>,\n ) -> Constructor<'tcx> {\n-    match *pat.kind {\n+    match pat.kind.as_ref() {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n         PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n         PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n-        PatKind::Variant { adt_def, variant_index, .. } => {\n+        &PatKind::Variant { adt_def, variant_index, .. } => {\n             Variant(adt_def.variants[variant_index].def_id)\n         }\n         PatKind::Constant { value } => {\n             if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value, pat.span) {\n                 IntRange(int_range)\n             } else {\n-                match value.ty.kind() {\n+                match pat.ty.kind() {\n                     ty::Float(_) => FloatRange(value, value, RangeEnd::Included),\n-                    ty::Ref(_, t, _) if t.is_str() => Str(value),\n+                    // In `expand_pattern`, we convert string literals to `&CONST` patterns with\n+                    // `CONST` a pattern of type `str`. In truth this contains a constant of type\n+                    // `&str`.\n+                    ty::Str => Str(value),\n                     // All constants that can be structurally matched have already been expanded\n                     // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n                     // opaque.\n                     _ => Opaque,\n                 }\n             }\n         }\n-        PatKind::Range(PatRange { lo, hi, end }) => {\n+        &PatKind::Range(PatRange { lo, hi, end }) => {\n             let ty = lo.ty;\n             if let Some(int_range) = IntRange::from_range(\n                 cx.tcx,\n@@ -2188,8 +2212,7 @@ fn pat_constructor<'p, 'tcx>(\n                 FloatRange(lo, hi, end)\n             }\n         }\n-        PatKind::Array { ref prefix, ref slice, ref suffix }\n-        | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n+        PatKind::Array { prefix, slice, suffix } | PatKind::Slice { prefix, slice, suffix } => {\n             let array_len = match pat.ty.kind() {\n                 ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env)),\n                 ty::Slice(_) => None,"}, {"sha": "a0c0d1626ec45d3ddb19fa669834140ca43d7a8b", "filename": "src/test/ui/issues/issue-30240.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1899c489d4c30b2640d30b77ac04f0a548834d81/src%2Ftest%2Fui%2Fissues%2Fissue-30240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1899c489d4c30b2640d30b77ac04f0a548834d81/src%2Ftest%2Fui%2Fissues%2Fissue-30240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30240.rs?ref=1899c489d4c30b2640d30b77ac04f0a548834d81", "patch": "@@ -1,9 +1,9 @@\n fn main() {\n-    match \"world\" { //~ ERROR non-exhaustive patterns: `_`\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n         \"hello\" => {}\n     }\n \n-    match \"world\" { //~ ERROR non-exhaustive patterns: `_`\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n         ref _x if false => {}\n         \"hello\" => {}\n     }"}, {"sha": "a2c58d6e051b54214ddd332fa42edf8feca04d2e", "filename": "src/test/ui/issues/issue-30240.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1899c489d4c30b2640d30b77ac04f0a548834d81/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1899c489d4c30b2640d30b77ac04f0a548834d81/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr?ref=1899c489d4c30b2640d30b77ac04f0a548834d81", "patch": "@@ -1,17 +1,17 @@\n-error[E0004]: non-exhaustive patterns: `_` not covered\n+error[E0004]: non-exhaustive patterns: `&_` not covered\n   --> $DIR/issue-30240.rs:2:11\n    |\n LL |     match \"world\" {\n-   |           ^^^^^^^ pattern `_` not covered\n+   |           ^^^^^^^ pattern `&_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&str`\n \n-error[E0004]: non-exhaustive patterns: `_` not covered\n+error[E0004]: non-exhaustive patterns: `&_` not covered\n   --> $DIR/issue-30240.rs:6:11\n    |\n LL |     match \"world\" {\n-   |           ^^^^^^^ pattern `_` not covered\n+   |           ^^^^^^^ pattern `&_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&str`"}, {"sha": "2879caf2c4c70c03118846322b2a5cee3b4668e2", "filename": "src/test/ui/pattern/usefulness/issue-78549-ref-pat-and-str.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1899c489d4c30b2640d30b77ac04f0a548834d81/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78549-ref-pat-and-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1899c489d4c30b2640d30b77ac04f0a548834d81/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78549-ref-pat-and-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78549-ref-pat-and-str.rs?ref=1899c489d4c30b2640d30b77ac04f0a548834d81", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+// From https://github.com/rust-lang/rust/issues/78549\n+\n+fn main() {\n+    match \"foo\" {\n+        \"foo\" => {},\n+        &_ => {},\n+    }\n+\n+    match \"foo\" {\n+        &_ => {},\n+        \"foo\" => {},\n+    }\n+\n+    match (\"foo\", 0, \"bar\") {\n+        (&_, 0, &_) => {},\n+        (\"foo\", _, \"bar\") => {},\n+        (&_, _, &_) => {},\n+    }\n+\n+    match (&\"foo\", \"bar\") {\n+        (&\"foo\", &_) => {},\n+        (&&_, &_) => {},\n+    }\n+}"}]}