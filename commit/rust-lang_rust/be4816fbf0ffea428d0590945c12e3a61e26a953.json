{"sha": "be4816fbf0ffea428d0590945c12e3a61e26a953", "node_id": "C_kwDOAAsO6NoAKGJlNDgxNmZiZjBmZmVhNDI4ZDA1OTA5NDVjMTJlM2E2MWUyNmE5NTM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-20T20:42:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-20T20:42:38Z"}, "message": "Rollup merge of #103230 - nnethercote:clarify-startup, r=jyn514\n\nClarify startup\n\nA small follow-up to #102769.\n\nr? `@jyn514`", "tree": {"sha": "9192d30b24b7f93419569015c8bca03598390571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9192d30b24b7f93419569015c8bca03598390571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be4816fbf0ffea428d0590945c12e3a61e26a953", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjUbK+CRBK7hj4Ov3rIwAA1MgIAEr8RUFE9QxVINIHD6IZzXnP\n0agdaEU+A+7E1d4+MyGjIhKqPnDHrOGEzvzjp9GiSEW8Zb33oKXJrTreTRQ2cwdE\n/nXcITQlVVFVChRZ3Dw9mXdVrQkwmre5JR9DmpDE3q3rgvLPGY0UsxGO8fpRdryK\nBrOW4lkCHBPf4rBrbDpn90Z8q8wCOnaB1cB8OUJmd4r1IVuyUxxC65AsSQqftzuD\nMKwawjyGhVvrKd2rZFuDxyeeUYfaOx5zdG6FL9VLXfpsAdBU03adSAsYV5PPqAdA\nkkADInTvhtcJ5rEFGdT5HNkWc56XN7ofllD6OUIbd78PCV0pW0i4LKFlazYeaMA=\n=qsjz\n-----END PGP SIGNATURE-----\n", "payload": "tree 9192d30b24b7f93419569015c8bca03598390571\nparent 7ee4b218a86ae091de768729318b4ca1610610e3\nparent 5d716fd0e96c4408ad13e5e82df364fb1e984540\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1666298558 +0200\ncommitter GitHub <noreply@github.com> 1666298558 +0200\n\nRollup merge of #103230 - nnethercote:clarify-startup, r=jyn514\n\nClarify startup\n\nA small follow-up to #102769.\n\nr? `@jyn514`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be4816fbf0ffea428d0590945c12e3a61e26a953", "html_url": "https://github.com/rust-lang/rust/commit/be4816fbf0ffea428d0590945c12e3a61e26a953", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be4816fbf0ffea428d0590945c12e3a61e26a953/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ee4b218a86ae091de768729318b4ca1610610e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee4b218a86ae091de768729318b4ca1610610e3", "html_url": "https://github.com/rust-lang/rust/commit/7ee4b218a86ae091de768729318b4ca1610610e3"}, {"sha": "5d716fd0e96c4408ad13e5e82df364fb1e984540", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d716fd0e96c4408ad13e5e82df364fb1e984540", "html_url": "https://github.com/rust-lang/rust/commit/5d716fd0e96c4408ad13e5e82df364fb1e984540"}], "stats": {"total": 95, "additions": 50, "deletions": 45}, "files": [{"sha": "7edbb6f757ce16bba13623d69c73062f54aa3393", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be4816fbf0ffea428d0590945c12e3a61e26a953/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be4816fbf0ffea428d0590945c12e3a61e26a953/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=be4816fbf0ffea428d0590945c12e3a61e26a953", "patch": "@@ -190,6 +190,7 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         run_compiler(self.at_args, self.callbacks, self.file_loader, self.make_codegen_backend)\n     }\n }\n+\n fn run_compiler(\n     at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),"}, {"sha": "89aaa0b95e41b24a680cffa4ad4b86d3b4d84612", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be4816fbf0ffea428d0590945c12e3a61e26a953/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be4816fbf0ffea428d0590945c12e3a61e26a953/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=be4816fbf0ffea428d0590945c12e3a61e26a953", "patch": "@@ -25,7 +25,10 @@ use std::result;\n \n pub type Result<T> = result::Result<T, ErrorGuaranteed>;\n \n-/// Represents a compiler session.\n+/// Represents a compiler session. Note that every `Compiler` contains a\n+/// `Session`, but `Compiler` also contains some things that cannot be in\n+/// `Session`, due to `Session` being in a crate that has many fewer\n+/// dependencies than this crate.\n ///\n /// Can be used to run `rustc_interface` queries.\n /// Created by passing [`Config`] to [`run_compiler`]."}, {"sha": "519b8a7fc7c378ba8fe855fe5af803a22f1818a4", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/be4816fbf0ffea428d0590945c12e3a61e26a953/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be4816fbf0ffea428d0590945c12e3a61e26a953/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=be4816fbf0ffea428d0590945c12e3a61e26a953", "patch": "@@ -3,14 +3,8 @@ use libloading::Library;\n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-#[cfg(parallel_compiler)]\n-use rustc_data_structures::jobserver;\n use rustc_errors::registry::Registry;\n-#[cfg(parallel_compiler)]\n-use rustc_middle::ty::tls;\n use rustc_parse::validate_attr;\n-#[cfg(parallel_compiler)]\n-use rustc_query_impl::{QueryContext, QueryCtxt};\n use rustc_session as session;\n use rustc_session::config::CheckCfg;\n use rustc_session::config::{self, CrateType};\n@@ -25,8 +19,6 @@ use rustc_span::symbol::{sym, Symbol};\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n use std::mem;\n-#[cfg(not(parallel_compiler))]\n-use std::panic;\n use std::path::{Path, PathBuf};\n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::OnceLock;\n@@ -135,13 +127,20 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     _threads: usize,\n     f: F,\n ) -> R {\n-    // The thread pool is a single thread in the non-parallel compiler.\n-    thread::scope(|s| {\n-        let mut builder = thread::Builder::new().name(\"rustc\".to_string());\n-        if let Some(size) = get_stack_size() {\n-            builder = builder.stack_size(size);\n-        }\n+    // The \"thread pool\" is a single spawned thread in the non-parallel\n+    // compiler. We run on a spawned thread instead of the main thread (a) to\n+    // provide control over the stack size, and (b) to increase similarity with\n+    // the parallel compiler, in particular to ensure there is no accidental\n+    // sharing of data between the main thread and the compilation thread\n+    // (which might cause problems for the parallel compiler).\n+    let mut builder = thread::Builder::new().name(\"rustc\".to_string());\n+    if let Some(size) = get_stack_size() {\n+        builder = builder.stack_size(size);\n+    }\n \n+    // We build the session globals and run `f` on the spawned thread, because\n+    // `SessionGlobals` does not impl `Send` in the non-parallel compiler.\n+    thread::scope(|s| {\n         // `unwrap` is ok here because `spawn_scoped` only panics if the thread\n         // name contains null bytes.\n         let r = builder\n@@ -151,55 +150,57 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n \n         match r {\n             Ok(v) => v,\n-            Err(e) => panic::resume_unwind(e),\n+            Err(e) => std::panic::resume_unwind(e),\n         }\n     })\n }\n \n-/// Creates a new thread and forwards information in thread locals to it.\n-/// The new thread runs the deadlock handler.\n-/// Must only be called when a deadlock is about to happen.\n-#[cfg(parallel_compiler)]\n-unsafe fn handle_deadlock() {\n-    let registry = rustc_rayon_core::Registry::current();\n-\n-    let query_map = tls::with(|tcx| {\n-        QueryCtxt::from_tcx(tcx)\n-            .try_collect_active_jobs()\n-            .expect(\"active jobs shouldn't be locked in deadlock handler\")\n-    });\n-    thread::spawn(move || rustc_query_impl::deadlock(query_map, &registry));\n-}\n-\n #[cfg(parallel_compiler)]\n pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     threads: usize,\n     f: F,\n ) -> R {\n-    let mut config = rayon::ThreadPoolBuilder::new()\n+    use rustc_data_structures::jobserver;\n+    use rustc_middle::ty::tls;\n+    use rustc_query_impl::{deadlock, QueryContext, QueryCtxt};\n+\n+    let mut builder = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)\n         .release_thread_handler(jobserver::release_thread)\n         .num_threads(threads)\n-        .deadlock_handler(|| unsafe { handle_deadlock() });\n-\n+        .deadlock_handler(|| {\n+            // On deadlock, creates a new thread and forwards information in thread\n+            // locals to it. The new thread runs the deadlock handler.\n+            let query_map = tls::with(|tcx| {\n+                QueryCtxt::from_tcx(tcx)\n+                    .try_collect_active_jobs()\n+                    .expect(\"active jobs shouldn't be locked in deadlock handler\")\n+            });\n+            let registry = rustc_rayon_core::Registry::current();\n+            thread::spawn(move || deadlock(query_map, &registry));\n+        });\n     if let Some(size) = get_stack_size() {\n-        config = config.stack_size(size);\n+        builder = builder.stack_size(size);\n     }\n \n-    let with_pool = move |pool: &rayon::ThreadPool| pool.install(f);\n-\n+    // We create the session globals on the main thread, then create the thread\n+    // pool. Upon creation, each worker thread created gets a copy of the\n+    // session globals in TLS. This is possible because `SessionGlobals` impls\n+    // `Send` in the parallel compiler.\n     rustc_span::create_session_globals_then(edition, || {\n         rustc_span::with_session_globals(|session_globals| {\n-            // The main handler runs for each Rayon worker thread and sets up\n-            // the thread local rustc uses. `session_globals` is captured and set\n-            // on the new threads.\n-            let main_handler = move |thread: rayon::ThreadBuilder| {\n-                rustc_span::set_session_globals_then(session_globals, || thread.run())\n-            };\n-\n-            config.build_scoped(main_handler, with_pool).unwrap()\n+            builder\n+                .build_scoped(\n+                    // Initialize each new worker thread when created.\n+                    move |thread: rayon::ThreadBuilder| {\n+                        rustc_span::set_session_globals_then(session_globals, || thread.run())\n+                    },\n+                    // Run `f` on the first thread in the thread pool.\n+                    move |pool: &rayon::ThreadPool| pool.install(f),\n+                )\n+                .unwrap()\n         })\n     })\n }"}]}