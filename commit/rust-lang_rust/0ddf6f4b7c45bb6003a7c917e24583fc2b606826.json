{"sha": "0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZGY2ZjRiN2M0NWJiNjAwM2E3YzkxN2UyNDU4M2ZjMmI2MDY4MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-28T05:21:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-28T05:21:34Z"}, "message": "auto merge of #15233 : jbclements/rust/match-var-hygiene-etc, r=cmr\n\nThis PR includes two big things and a bunch of little ones.\r\n\r\n1) It enables hygiene for variables bound by 'match' expressions.\r\n2) It fixes a bug discovered indirectly (#15221), wherein fold traversal failed to visit nonterminal nodes.\r\n3) It fixes a small bug in the macro tutorial.\r\n\r\nIt also adds tests for the first two, and makes a bunch of small comment improvements and cleanup.", "tree": {"sha": "515b9c4e2a23780eacdb5258e35f4c1994715f3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/515b9c4e2a23780eacdb5258e35f4c1994715f3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "html_url": "https://github.com/rust-lang/rust/commit/0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afdfe40aa0b7dfc7800dddbc1f55da979abfe486", "url": "https://api.github.com/repos/rust-lang/rust/commits/afdfe40aa0b7dfc7800dddbc1f55da979abfe486", "html_url": "https://github.com/rust-lang/rust/commit/afdfe40aa0b7dfc7800dddbc1f55da979abfe486"}, {"sha": "04ced031ad52cfa33f30dbd55f72aff1d95813a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/04ced031ad52cfa33f30dbd55f72aff1d95813a3", "html_url": "https://github.com/rust-lang/rust/commit/04ced031ad52cfa33f30dbd55f72aff1d95813a3"}], "stats": {"total": 465, "additions": 288, "deletions": 177}, "files": [{"sha": "6d3825f8ecf12c9a84eb1d9d628f9db99599eaa3", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -355,6 +355,7 @@ macro_rules! biased_match_rec (\n             _ => { $err }\n         }\n     );\n+    // Produce the requested values\n     ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n )\n \n@@ -364,7 +365,7 @@ macro_rules! biased_match (\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $bind_res:ident\n     ) => (\n-        let ( $( $bind_res ),* ) = biased_match_rec!(\n+        let $bind_res = biased_match_rec!(\n             $( ($e) ~ ($p) else $err ; )*\n             binds $bind_res\n         );"}, {"sha": "529b460adcd34d862bcb951e8ee00a8f27358d40", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -401,6 +401,7 @@ pub enum Decl_ {\n     DeclItem(Gc<Item>),\n }\n \n+/// represents one arm of a 'match'\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,"}, {"sha": "b9cedb7a7797a065a9b32a34e137ef12b1310972", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 135, "deletions": 97, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -31,6 +31,7 @@ use util::small_vector::SmallVector;\n \n use std::gc::{Gc, GC};\n \n+\n pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n     match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n@@ -53,7 +54,6 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n                     }\n                     let extname = pth.segments.get(0).identifier;\n                     let extnamestr = token::get_ident(extname);\n-                    // leaving explicit deref here to highlight unbox op:\n                     let marked_after = match fld.extsbox.find(&extname.name) {\n                         None => {\n                             fld.cx.span_err(\n@@ -130,8 +130,6 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n         // From: `['<ident>:] for <src_pat> in <src_expr> <src_loop_block>`\n         // FIXME #6993: change type of opt_ident to Option<Name>\n         ast::ExprForLoop(src_pat, src_expr, src_loop_block, opt_ident) => {\n-            // Expand any interior macros etc.\n-            // NB: we don't fold pats yet. Curious.\n \n             let span = e.span;\n \n@@ -252,7 +250,7 @@ fn expand_loop_block(loop_block: P<Block>,\n             // the same context will pick that up in the deferred renaming pass\n             // and be renamed incorrectly.\n             let mut rename_list = vec!(rename);\n-            let mut rename_fld = renames_to_fold(&mut rename_list);\n+            let mut rename_fld = IdentRenamer{renames: &mut rename_list};\n             let renamed_ident = rename_fld.fold_ident(label);\n \n             // The rename *must* be added to the enclosed syntax context for\n@@ -281,7 +279,7 @@ macro_rules! with_exts_frame (\n )\n \n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n+fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                    -> SmallVector<Gc<ast::Item>> {\n     let it = expand_item_modifiers(it, fld);\n \n@@ -386,13 +384,13 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n }\n \n // does this attribute list contain \"macro_escape\" ?\n-pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n+fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"macro_escape\")\n }\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n+fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                        -> SmallVector<Gc<ast::Item>> {\n     let (pth, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n@@ -498,7 +496,7 @@ pub fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n }\n \n // expand a stmt\n-pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n+fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n     let (pth, tts, semi) = match s.node {\n@@ -609,25 +607,21 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                         span: span,\n                         source: source,\n                     } = **local;\n-                    // expand the pat (it might contain exprs... #:(o)>\n+                    // expand the pat (it might contain macro uses):\n                     let expanded_pat = fld.fold_pat(pat);\n                     // find the pat_idents in the pattern:\n                     // oh dear heaven... this is going to include the enum\n                     // names, as well... but that should be okay, as long as\n                     // the new names are gensyms for the old ones.\n-                    let mut name_finder = new_name_finder(Vec::new());\n-                    name_finder.visit_pat(&*expanded_pat,());\n                     // generate fresh names, push them to a new pending list\n-                    let mut new_pending_renames = Vec::new();\n-                    for ident in name_finder.ident_accumulator.iter() {\n-                        let new_name = fresh_name(ident);\n-                        new_pending_renames.push((*ident,new_name));\n-                    }\n+                    let idents = pattern_bindings(expanded_pat);\n+                    let mut new_pending_renames =\n+                        idents.iter().map(|ident| (*ident, fresh_name(ident))).collect();\n+                    // rewrite the pattern using the new names (the old\n+                    // ones have already been applied):\n                     let rewritten_pat = {\n-                        let mut rename_fld =\n-                            renames_to_fold(&mut new_pending_renames);\n-                        // rewrite the pattern using the new names (the old\n-                        // ones have already been applied):\n+                        // nested binding to allow borrow to expire:\n+                        let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n                         rename_fld.fold_pat(expanded_pat)\n                     };\n                     // add them to the existing pending renames:\n@@ -659,9 +653,47 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n     }\n }\n \n+fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n+    // expand pats... they might contain macro uses:\n+    let expanded_pats : Vec<Gc<ast::Pat>> = arm.pats.iter().map(|pat| fld.fold_pat(*pat)).collect();\n+    if expanded_pats.len() == 0 {\n+        fail!(\"encountered match arm with 0 patterns\");\n+    }\n+    // all of the pats must have the same set of bindings, so use the\n+    // first one to extract them and generate new names:\n+    let first_pat = expanded_pats.get(0);\n+    // code duplicated from 'let', above. Perhaps this can be lifted\n+    // into a separate function:\n+    let idents = pattern_bindings(*first_pat);\n+    let mut new_pending_renames =\n+        idents.iter().map(|id| (*id,fresh_name(id))).collect();\n+    // rewrite all of the patterns using the new names (the old\n+    // ones have already been applied). Note that we depend here\n+    // on the guarantee that after expansion, there can't be any\n+    // Path expressions (a.k.a. varrefs) left in the pattern. If\n+    // this were false, we'd need to apply this renaming only to\n+    // the bindings, and not to the varrefs, using a more targeted\n+    // fold-er.\n+    let mut rename_fld = IdentRenamer{renames:&mut new_pending_renames};\n+    let rewritten_pats =\n+        expanded_pats.iter().map(|pat| rename_fld.fold_pat(*pat)).collect();\n+    // apply renaming and then expansion to the guard and the body:\n+    let rewritten_guard =\n+        arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n+    let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));\n+    ast::Arm {\n+        attrs: arm.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),\n+        pats: rewritten_pats,\n+        guard: rewritten_guard,\n+        body: rewritten_body,\n+    }\n+}\n+\n+\n+\n // a visitor that extracts the pat_ident (binding) paths\n // from a given thingy and puts them in a mutable\n-// array (passed in to the traversal).\n+// array\n #[deriving(Clone)]\n struct NameFinderContext {\n     ident_accumulator: Vec<ast::Ident> ,\n@@ -701,38 +733,38 @@ impl Visitor<()> for NameFinderContext {\n \n }\n \n-// return a visitor that extracts the pat_ident paths\n-// from a given thingy and puts them in a mutable\n-// array (passed in to the traversal)\n-fn new_name_finder(idents: Vec<ast::Ident> ) -> NameFinderContext {\n-    NameFinderContext {\n-        ident_accumulator: idents,\n-    }\n+// find the pat_ident paths in a pattern\n+fn pattern_bindings(pat : &ast::Pat) -> Vec<ast::Ident> {\n+    let mut name_finder = NameFinderContext{ident_accumulator:Vec::new()};\n+    name_finder.visit_pat(pat,());\n+    name_finder.ident_accumulator\n }\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n-pub fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n+fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n     with_exts_frame!(fld.extsbox,false,\n                      expand_block_elts(blk, fld))\n }\n \n // expand the elements of a block.\n-pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n+fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     let new_view_items = b.view_items.iter().map(|x| fld.fold_view_item(x)).collect();\n     let new_stmts =\n         b.stmts.iter().flat_map(|x| {\n+            // perform all pending renames\n             let renamed_stmt = {\n                 let pending_renames = &mut fld.extsbox.info().pending_renames;\n-                let mut rename_fld = renames_to_fold(pending_renames);\n+                let mut rename_fld = IdentRenamer{renames:pending_renames};\n                 rename_fld.fold_stmt(&**x).expect_one(\"rename_fold didn't return one value\")\n             };\n+            // expand macros in the statement\n             fld.fold_stmt(&*renamed_stmt).move_iter()\n         }).collect();\n     let new_expr = b.expr.map(|x| {\n         let expr = {\n             let pending_renames = &mut fld.extsbox.info().pending_renames;\n-            let mut rename_fld = renames_to_fold(pending_renames);\n+            let mut rename_fld = IdentRenamer{renames:pending_renames};\n             rename_fld.fold_expr(x)\n         };\n         fld.fold_expr(expr)\n@@ -747,7 +779,7 @@ pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     })\n }\n \n-pub fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n+fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n     let (pth, tts) = match p.node {\n         PatMac(ref mac) => {\n             match mac.node {\n@@ -824,6 +856,9 @@ pub fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n     }\n }\n \n+// a tree-folder that applies every rename in its (mutable) list\n+// to every identifier, including both bindings and varrefs\n+// (and lots of things that will turn out to be neither)\n pub struct IdentRenamer<'a> {\n     renames: &'a mut RenameList,\n }\n@@ -840,15 +875,7 @@ impl<'a> Folder for IdentRenamer<'a> {\n     }\n }\n \n-// given a mutable list of renames, return a tree-folder that applies those\n-// renames.\n-pub fn renames_to_fold<'a>(renames: &'a mut RenameList) -> IdentRenamer<'a> {\n-    IdentRenamer {\n-        renames: renames,\n-    }\n-}\n-\n-pub fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n+fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     /* this discards information in the case of macro-defining macros */\n     Span {\n         lo: sp.lo,\n@@ -883,6 +910,10 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_block(&*block, self)\n     }\n \n+    fn fold_arm(&mut self, arm: &ast::Arm) -> ast::Arm {\n+        expand_arm(arm, self)\n+    }\n+\n     fn new_span(&mut self, span: Span) -> Span {\n         new_span(self.cx, span)\n     }\n@@ -965,35 +996,30 @@ impl Folder for Marker {\n     }\n }\n \n-// just a convenience:\n-fn new_mark_folder(m: Mrk) -> Marker {\n-    Marker {mark: m}\n-}\n-\n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n-    fold_tts(tts, &mut new_mark_folder(m))\n+    fold_tts(tts, &mut Marker{mark:m})\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n fn mark_expr(expr: Gc<ast::Expr>, m: Mrk) -> Gc<ast::Expr> {\n-    new_mark_folder(m).fold_expr(expr)\n+    Marker{mark:m}.fold_expr(expr)\n }\n \n // apply a given mark to the given pattern. Used following the expansion of a macro.\n fn mark_pat(pat: Gc<ast::Pat>, m: Mrk) -> Gc<ast::Pat> {\n-    new_mark_folder(m).fold_pat(pat)\n+    Marker{mark:m}.fold_pat(pat)\n }\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> Gc<ast::Stmt> {\n-    new_mark_folder(m).fold_stmt(expr)\n+    Marker{mark:m}.fold_stmt(expr)\n             .expect_one(\"marking a stmt didn't return a stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n fn mark_item(expr: Gc<ast::Item>, m: Mrk) -> SmallVector<Gc<ast::Item>> {\n-    new_mark_folder(m).fold_item(expr)\n+    Marker{mark:m}.fold_item(expr)\n }\n \n fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n@@ -1013,7 +1039,8 @@ fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n \n #[cfg(test)]\n mod test {\n-    use super::{new_name_finder, expand_crate, contains_macro_escape};\n+    use super::{pattern_bindings, expand_crate, contains_macro_escape};\n+    use super::{NameFinderContext};\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord};\n     use attr;\n@@ -1043,22 +1070,22 @@ mod test {\n             match *expr {\n                 ast::Expr{id:_,span:_,node:ast::ExprPath(ref p)} => {\n                     self.path_accumulator.push(p.clone());\n-                    // not calling visit_path, should be fine.\n+                    // not calling visit_path, but it should be fine.\n                 }\n                 _ => visit::walk_expr(self,expr,())\n             }\n         }\n     }\n \n-    // return a visitor that extracts the paths\n-    // from a given thingy and puts them in a mutable\n-    // array (passed in to the traversal)\n-    fn new_path_finder(paths: Vec<ast::Path> ) -> PathExprFinderContext {\n-        PathExprFinderContext {\n-            path_accumulator: paths\n-        }\n+    // find the variable references in a crate\n+    fn crate_varrefs(the_crate : &ast::Crate) -> Vec<ast::Path> {\n+        let mut path_finder = PathExprFinderContext{path_accumulator:Vec::new()};\n+        visit::walk_crate(&mut path_finder, the_crate, ());\n+        path_finder.path_accumulator\n     }\n \n+\n+\n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n \n@@ -1150,6 +1177,14 @@ mod test {\n         expand_crate(&ps,cfg,vec!(),vec!(),crate_ast)\n     }\n \n+    // find the pat_ident paths in a crate\n+    fn crate_bindings(the_crate : &ast::Crate) -> Vec<ast::Ident> {\n+        let mut name_finder = NameFinderContext{ident_accumulator:Vec::new()};\n+        visit::walk_crate(&mut name_finder, the_crate, ());\n+        name_finder.ident_accumulator\n+    }\n+\n+\n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {\n         //let expanded_ast = expand_crate_str(crate_str);\n         // println!(\"expanded: {:?}\\n\",expanded_ast);\n@@ -1246,15 +1281,27 @@ mod test {\n             0)\n     }\n \n-    // FIXME #9384, match variable hygiene. Should expand into\n-    // fn z() {match 8 {x_1 => {match 9 {x_2 | x_2 => x_2 + x_1}}}}\n-    #[ignore]\n+    // match variable hygiene. Should expand into\n+    // fn z() {match 8 {x_1 => {match 9 {x_2 | x_2 if x_2 == x_1 => x_2 + x_1}}}}\n     #[test] fn issue_9384(){\n         run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => ({match 9 {x | x => x + $ex}}))\n-              fn z() {match 8 {x => bad_macro!(_x)}}\",\n+            &(\"macro_rules! bad_macro (($ex:expr) => ({match 9 {x | x if x == $ex => x + $ex}}))\n+              fn z() {match 8 {x => bad_macro!(x)}}\",\n               // NB: the third \"binding\" is the repeat of the second one.\n-              vec!(vec!(1),vec!(0),vec!(0)),\n+              vec!(vec!(1,3),vec!(0,2),vec!(0,2)),\n+              true),\n+            0)\n+    }\n+\n+    // interpolated nodes weren't getting labeled.\n+    // should expand into\n+    // fn main(){let g1_1 = 13; g1_1}}\n+    #[test] fn pat_expand_issue_15221(){\n+        run_renaming_test(\n+            &(\"macro_rules! inner ( ($e:pat ) => ($e))\n+              macro_rules! outer ( ($e:pat ) => (inner!($e)))\n+              fn main() { let outer!(g) = 13; g;}\",\n+              vec!(vec!(0)),\n               true),\n             0)\n     }\n@@ -1283,15 +1330,8 @@ mod test {\n             (ref str,ref conns, bic) => (str.to_owned(), conns.clone(), bic)\n         };\n         let cr = expand_crate_str(teststr.to_string());\n-        // find the bindings:\n-        let mut name_finder = new_name_finder(Vec::new());\n-        visit::walk_crate(&mut name_finder,&cr,());\n-        let bindings = name_finder.ident_accumulator;\n-\n-        // find the varrefs:\n-        let mut path_finder = new_path_finder(Vec::new());\n-        visit::walk_crate(&mut path_finder,&cr,());\n-        let varrefs = path_finder.path_accumulator;\n+        let bindings = crate_bindings(&cr);\n+        let varrefs = crate_varrefs(&cr);\n \n         // must be one check clause for each binding:\n         assert_eq!(bindings.len(),bound_connections.len());\n@@ -1315,9 +1355,13 @@ mod test {\n                                                            .ctxt,\n                                                      invalid_name);\n                     if !(varref_name==binding_name) {\n+                        let varref_idents : Vec<ast::Ident>\n+                            = varref.segments.iter().map(|s|\n+                                                         s.identifier)\n+                            .collect();\n                         println!(\"uh oh, should match but doesn't:\");\n-                        println!(\"varref: {:?}\",varref);\n-                        println!(\"binding: {:?}\", *bindings.get(binding_idx));\n+                        println!(\"varref #{}: {}\",idx, varref_idents);\n+                        println!(\"binding #{}: {}\", binding_idx, *bindings.get(binding_idx));\n                         mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                     }\n                     assert_eq!(varref_name,binding_name);\n@@ -1332,19 +1376,23 @@ mod test {\n                             == binding_name);\n                     // temp debugging:\n                     if fail {\n+                        let varref_idents : Vec<ast::Ident>\n+                            = varref.segments.iter().map(|s|\n+                                                         s.identifier)\n+                            .collect();\n                         println!(\"failure on test {}\",test_idx);\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");\n                         println!(\"uh oh, matches but shouldn't:\");\n-                        println!(\"varref: {:?}\",varref);\n+                        println!(\"varref: {}\",varref_idents);\n                         // good lord, you can't make a path with 0 segments, can you?\n                         let string = token::get_ident(varref.segments\n                                                             .get(0)\n                                                             .identifier);\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments.get(0).identifier.name,\n                                  string.get());\n-                        println!(\"binding: {:?}\", *bindings.get(binding_idx));\n+                        println!(\"binding: {}\", *bindings.get(binding_idx));\n                         mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                     }\n                     assert!(!fail);\n@@ -1360,10 +1408,7 @@ foo_module!()\n \".to_string();\n         let cr = expand_crate_str(crate_str);\n         // find the xx binding\n-        let mut name_finder = new_name_finder(Vec::new());\n-        visit::walk_crate(&mut name_finder, &cr, ());\n-        let bindings = name_finder.ident_accumulator;\n-\n+        let bindings = crate_bindings(&cr);\n         let cxbinds: Vec<&ast::Ident> =\n             bindings.iter().filter(|b| {\n                 let ident = token::get_ident(**b);\n@@ -1376,10 +1421,7 @@ foo_module!()\n             _ => fail!(\"expected just one binding for ext_cx\")\n         };\n         let resolved_binding = mtwt::resolve(*cxbind);\n-        // find all the xx varrefs:\n-        let mut path_finder = new_path_finder(Vec::new());\n-        visit::walk_crate(&mut path_finder, &cr, ());\n-        let varrefs = path_finder.path_accumulator;\n+        let varrefs = crate_varrefs(&cr);\n \n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n@@ -1405,10 +1447,8 @@ foo_module!()\n     fn pat_idents(){\n         let pat = string_to_pat(\n             \"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_string());\n-        let mut pat_idents = new_name_finder(Vec::new());\n-        pat_idents.visit_pat(pat, ());\n-        assert_eq!(pat_idents.ident_accumulator,\n-                   strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n+        let idents = pattern_bindings(pat);\n+        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n     }\n \n     // test the list of identifier patterns gathered by the visitor. Note that\n@@ -1418,12 +1458,10 @@ foo_module!()\n     fn crate_idents(){\n         let the_crate = string_to_crate(\"fn main (a : int) -> int {|b| {\n         match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n-        let mut idents = new_name_finder(Vec::new());\n-        //visit::walk_crate(&mut idents, &the_crate, ());\n-        idents.visit_mod(&the_crate.module, the_crate.span, ast::CRATE_NODE_ID, ());\n-        assert_eq!(idents.ident_accumulator,\n-                   strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n+        let idents = crate_bindings(&the_crate);\n+        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n     }\n \n+    //\n \n }"}, {"sha": "48895d34022c4c28b9459b2c1b23d48102730073", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -30,6 +30,7 @@ use std::collections::HashMap;\n // change the semantics--everything here is immutable--but\n // it should cut down on memory use *a lot*; applying a mark\n // to a tree containing 50 identifiers would otherwise generate\n+// 50 new contexts\n pub struct SCTable {\n     table: RefCell<Vec<SyntaxContext_>>,\n     mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n@@ -160,7 +161,7 @@ fn with_resolve_table_mut<T>(op: |&mut ResolveTable| -> T) -> T {\n }\n \n // Resolve a syntax object to a name, per MTWT.\n-// adding memorization to possibly resolve 500+ seconds in resolve for librustc (!)\n+// adding memoization to resolve 500+ seconds in resolve for librustc (!)\n fn resolve_internal(id: Ident,\n                     table: &SCTable,\n                     resolve_table: &mut ResolveTable) -> Name {"}, {"sha": "c6177ce31f5f874a8282020d717a6ca2f1c792bf", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 93, "deletions": 57, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -86,7 +86,7 @@ pub trait Folder {\n                 kind: sf.node.kind,\n                 id: id,\n                 ty: self.fold_ty(sf.node.ty),\n-                attrs: sf.node.attrs.iter().map(|e| fold_attribute_(*e, self)).collect()\n+                attrs: sf.node.attrs.iter().map(|e| self.fold_attribute(*e)).collect()\n             },\n             span: self.new_span(sf.span)\n         }\n@@ -118,7 +118,7 @@ pub trait Folder {\n \n     fn fold_arm(&mut self, a: &Arm) -> Arm {\n         Arm {\n-            attrs: a.attrs.iter().map(|x| fold_attribute_(*x, self)).collect(),\n+            attrs: a.attrs.iter().map(|x| self.fold_attribute(*x)).collect(),\n             pats: a.pats.iter().map(|x| self.fold_pat(*x)).collect(),\n             guard: a.guard.map(|x| self.fold_expr(x)),\n             body: self.fold_expr(a.body),\n@@ -251,7 +251,7 @@ pub trait Folder {\n             }\n         }\n \n-        let attrs = v.node.attrs.iter().map(|x| fold_attribute_(*x, self)).collect();\n+        let attrs = v.node.attrs.iter().map(|x| self.fold_attribute(*x)).collect();\n \n         let de = match v.node.disr_expr {\n           Some(e) => Some(self.fold_expr(e)),\n@@ -344,6 +344,21 @@ pub trait Folder {\n     fn fold_lifetime(&mut self, l: &Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n+\n+    //used in noop_fold_item and noop_fold_crate\n+    fn fold_attribute(&mut self, at: Attribute) -> Attribute {\n+        Spanned {\n+            span: self.new_span(at.span),\n+            node: ast::Attribute_ {\n+                id: at.node.id,\n+                style: at.node.style,\n+                value: fold_meta_item_(at.node.value, self),\n+                is_sugared_doc: at.node.is_sugared_doc\n+            }\n+        }\n+    }\n+\n+\n }\n \n /* some little folds that probably aren't useful to have in Folder itself*/\n@@ -364,19 +379,6 @@ fn fold_meta_item_<T: Folder>(mi: Gc<MetaItem>, fld: &mut T) -> Gc<MetaItem> {\n         span: fld.new_span(mi.span) }\n }\n \n-//used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n-    Spanned {\n-        span: fld.new_span(at.span),\n-        node: ast::Attribute_ {\n-            id: at.node.id,\n-            style: at.node.style,\n-            value: fold_meta_item_(at.node.value, fld),\n-            is_sugared_doc: at.node.is_sugared_doc\n-        }\n-    }\n-}\n-\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n     let id = fld.new_id(a.id); // Needs to be first, for ast_map.\n@@ -387,53 +389,80 @@ fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n     }\n }\n \n-// build a new vector of tts by appling the Folder's fold_ident to\n-// all of the identifiers in the token trees.\n-//\n-// This is part of hygiene magic. As far as hygiene is concerned, there\n-// are three types of let pattern bindings or loop labels:\n-//      - those defined and used in non-macro part of the program\n-//      - those used as part of macro invocation arguments\n-//      - those defined and used inside macro definitions\n-// Lexically, type 1 and 2 are in one group and type 3 the other. If they\n-// clash, in order for let and loop label to work hygienically, one group\n-// or the other needs to be renamed. The problem is that type 2 and 3 are\n-// parsed together (inside the macro expand function). After being parsed and\n-// AST being constructed, they can no longer be distinguished from each other.\n-//\n-// For that reason, type 2 let bindings and loop labels are actually renamed\n-// in the form of tokens instead of AST nodes, here. There are wasted effort\n-// since many token::IDENT are not necessary part of let bindings and most\n-// token::LIFETIME are certainly not loop labels. But we can't tell in their\n-// token form. So this is less ideal and hacky but it works.\n-pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n-    tts.iter().map(|tt| {\n-        match *tt {\n-            TTTok(span, ref tok) =>\n-            TTTok(span,maybe_fold_ident(tok,fld)),\n-            TTDelim(ref tts) => TTDelim(Rc::new(fold_tts(tts.as_slice(), fld))),\n-            TTSeq(span, ref pattern, ref sep, is_optional) =>\n+pub fn fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n+    match *tt {\n+        TTTok(span, ref tok) =>\n+            TTTok(span, fold_token(tok,fld)),\n+        TTDelim(ref tts) => TTDelim(Rc::new(fold_tts(tts.as_slice(), fld))),\n+        TTSeq(span, ref pattern, ref sep, is_optional) =>\n             TTSeq(span,\n                   Rc::new(fold_tts(pattern.as_slice(), fld)),\n-                  sep.as_ref().map(|tok|maybe_fold_ident(tok,fld)),\n+                  sep.as_ref().map(|tok| fold_token(tok,fld)),\n                   is_optional),\n-            TTNonterminal(sp,ref ident) =>\n+        TTNonterminal(sp,ref ident) =>\n             TTNonterminal(sp,fld.fold_ident(*ident))\n-        }\n-    }).collect()\n+    }\n+}\n+\n+pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n+    tts.iter().map(|tt| fold_tt(tt,fld)).collect()\n }\n \n-// apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n+\n+// apply ident folder if it's an ident, apply other folds to interpolated nodes\n+fn fold_token<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n     match *t {\n         token::IDENT(id, followed_by_colons) => {\n             token::IDENT(fld.fold_ident(id), followed_by_colons)\n         }\n         token::LIFETIME(id) => token::LIFETIME(fld.fold_ident(id)),\n+        token::INTERPOLATED(ref nt) => token::INTERPOLATED(fold_interpolated(nt,fld)),\n         _ => (*t).clone()\n     }\n }\n \n+// apply folder to elements of interpolated nodes\n+//\n+// NB: this can occur only when applying a fold to partially expanded code, where\n+// parsed pieces have gotten implanted ito *other* macro invocations. This is relevant\n+// for macro hygiene, but possibly not elsewhere.\n+//\n+// One problem here occurs because the types for fold_item, fold_stmt, etc. allow the\n+// folder to return *multiple* items; this is a problem for the nodes here, because\n+// they insist on having exactly one piece. One solution would be to mangle the fold\n+// trait to include one-to-many and one-to-one versions of these entry points, but that\n+// would probably confuse a lot of people and help very few. Instead, I'm just going\n+// to put in dynamic checks. I think the performance impact of this will be pretty much\n+// nonexistent. The danger is that someone will apply a fold to a partially expanded\n+// node, and will be confused by the fact that their \"fold_item\" or \"fold_stmt\" isn't\n+// getting called on NtItem or NtStmt nodes. Hopefully they'll wind up reading this\n+// comment, and doing something appropriate.\n+//\n+// BTW, design choice: I considered just changing the type of, e.g., NtItem to contain\n+// multiple items, but decided against it when I looked at parse_item_or_view_item and\n+// tried to figure out what I would do with multiple items there....\n+fn fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T) -> token::Nonterminal {\n+    match *nt {\n+        token::NtItem(item) =>\n+            token::NtItem(fld.fold_item(item)\n+                          .expect_one(\"expected fold to produce exactly one item\")),\n+        token::NtBlock(block) => token::NtBlock(fld.fold_block(block)),\n+        token::NtStmt(stmt) =>\n+            token::NtStmt(fld.fold_stmt(stmt)\n+                          .expect_one(\"expected fold to produce exactly one statement\")),\n+        token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n+        token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n+        token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n+        token::NtIdent(ref id, is_mod_name) =>\n+            token::NtIdent(box fld.fold_ident(**id),is_mod_name),\n+        token::NtMeta(meta_item) => token::NtMeta(fold_meta_item_(meta_item,fld)),\n+        token::NtPath(ref path) => token::NtPath(box fld.fold_path(*path)),\n+        token::NtTT(tt) => token::NtTT(box (GC) fold_tt(tt,fld)),\n+        // it looks to me like we can leave out the matchers: token::NtMatchers(matchers)\n+        _ => (*nt).clone()\n+    }\n+}\n+\n pub fn noop_fold_fn_decl<T: Folder>(decl: &FnDecl, fld: &mut T) -> P<FnDecl> {\n     P(FnDecl {\n         inputs: decl.inputs.iter().map(|x| fold_arg_(x, fld)).collect(), // bad copy\n@@ -526,7 +555,7 @@ fn fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n             kind: f.node.kind,\n             id: id,\n             ty: fld.fold_ty(f.node.ty),\n-            attrs: f.node.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n+            attrs: f.node.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n         },\n         span: fld.new_span(f.span),\n     }\n@@ -578,7 +607,7 @@ pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n     };\n     ViewItem {\n         node: inner_view_item,\n-        attrs: vi.attrs.iter().map(|a| fold_attribute_(*a, folder)).collect(),\n+        attrs: vi.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),\n         vis: vi.vis,\n         span: folder.new_span(vi.span),\n     }\n@@ -658,7 +687,7 @@ pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMeth\n     TypeMethod {\n         id: id,\n         ident: fld.fold_ident(m.ident),\n-        attrs: m.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n+        attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n         fn_style: m.fn_style,\n         decl: fld.fold_fn_decl(&*m.decl),\n         generics: fold_generics(&m.generics, fld),\n@@ -681,14 +710,21 @@ pub fn noop_fold_mod<T: Folder>(m: &Mod, folder: &mut T) -> Mod {\n pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n     Crate {\n         module: folder.fold_mod(&c.module),\n-        attrs: c.attrs.iter().map(|x| fold_attribute_(*x, folder)).collect(),\n+        attrs: c.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),\n         config: c.config.iter().map(|x| fold_meta_item_(*x, folder)).collect(),\n         span: folder.new_span(c.span),\n     }\n }\n \n+// fold one item into possibly many items\n pub fn noop_fold_item<T: Folder>(i: &Item,\n                                  folder: &mut T) -> SmallVector<Gc<Item>> {\n+    SmallVector::one(box(GC) noop_fold_item_(i,folder))\n+}\n+\n+\n+// fold one item into exactly one item\n+pub fn noop_fold_item_<T: Folder>(i: &Item, folder: &mut T) -> Item {\n     let id = folder.new_id(i.id); // Needs to be first, for ast_map.\n     let node = folder.fold_item_underscore(&i.node);\n     let ident = match node {\n@@ -699,14 +735,14 @@ pub fn noop_fold_item<T: Folder>(i: &Item,\n         _ => i.ident\n     };\n \n-    SmallVector::one(box(GC) Item {\n+    Item {\n         id: id,\n         ident: folder.fold_ident(ident),\n-        attrs: i.attrs.iter().map(|e| fold_attribute_(*e, folder)).collect(),\n+        attrs: i.attrs.iter().map(|e| folder.fold_attribute(*e)).collect(),\n         node: node,\n         vis: i.vis,\n         span: folder.new_span(i.span)\n-    })\n+    }\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n@@ -715,7 +751,7 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n     box(GC) ForeignItem {\n         id: id,\n         ident: folder.fold_ident(ni.ident),\n-        attrs: ni.attrs.iter().map(|x| fold_attribute_(*x, folder)).collect(),\n+        attrs: ni.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),\n         node: match ni.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n                 ForeignItemFn(P(FnDecl {\n@@ -739,7 +775,7 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> Gc<Method> {\n     box(GC) Method {\n         id: id,\n         ident: folder.fold_ident(m.ident),\n-        attrs: m.attrs.iter().map(|a| fold_attribute_(*a, folder)).collect(),\n+        attrs: m.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),\n         generics: fold_generics(&m.generics, folder),\n         explicit_self: folder.fold_explicit_self(&m.explicit_self),\n         fn_style: m.fn_style,"}, {"sha": "a93e8270d9866c0b12fe791ab2127411b3a43ffb", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -114,6 +114,7 @@ pub enum Nonterminal {\n     NtPat( Gc<ast::Pat>),\n     NtExpr(Gc<ast::Expr>),\n     NtTy(  P<ast::Ty>),\n+    // see IDENT, above, for meaning of bool in NtIdent:\n     NtIdent(Box<ast::Ident>, bool),\n     NtMeta(Gc<ast::MetaItem>), // stuff inside brackets for attributes\n     NtPath(Box<ast::Path>),"}, {"sha": "2b9abfbc350a64b9ef94fbe174f1cd4eaf9eb71b", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -15,7 +15,7 @@\n \n // This also serves as a pipes test, because Arcs are implemented with pipes.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n extern crate time;\n "}, {"sha": "afed753f455beb2f3184dedc0466b0dfed0ae080", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -15,7 +15,7 @@\n \n // This also serves as a pipes test, because Arcs are implemented with pipes.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n extern crate time;\n "}, {"sha": "e13c53407e457f53d55aa68be1bd7610c4e85a08", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -38,7 +38,7 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n #![feature(phase)]\n #[phase(plugin)] extern crate green;"}, {"sha": "8cec135944fd847a377633a4a198915777b1048e", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n #![feature(phase)]\n #![allow(non_snake_case_functions)]"}, {"sha": "859fc62647a28743ee224f00b69cc8c5dc5ed9af", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n // ignore-win32 FIXME #13259\n extern crate native;\n "}, {"sha": "ccd0d967a51e826973cb5b73370fa9c489c2adce", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n enum E<T> {"}, {"sha": "2abdf4c7c7e0157396683d770ad57eab8a1adb78", "filename": "src/test/run-pass/deriving-cmp-generic-struct-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n #![feature(struct_variant)]\n "}, {"sha": "d1610978e2eb56f61a6d3936d2c582ba5019d7fd", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n struct S<T> {"}, {"sha": "25f62e85ba6f30e6d52b420df463fe719ca94304", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n struct TS<T>(T,T);"}, {"sha": "e5cfccac13a88323597e2a970c2aa4aba3b28b08", "filename": "src/test/run-pass/issue-15221.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15221.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules)]\n+\n+macro_rules! inner (\n+    ($e:pat ) => ($e))\n+\n+macro_rules! outer (\n+    ($e:pat ) => (inner!($e)))\n+\n+fn main() {\n+    let outer!(g1) = 13;\n+    g1;\n+}\n+"}, {"sha": "210371205696a91d6c6b9789b92c3b9769e2bf23", "filename": "src/test/run-pass/issue-8851.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fissue-8851.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Fissue-8851.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8851.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -10,23 +10,28 @@\n \n #![feature(macro_rules)]\n \n+// after fixing #9384 and implementing hygiene for match bindings,\n+// this now fails because the insertion of the 'y' into the match\n+// doesn't cause capture. Making this macro hygienic (as I've done)\n+// could very well make this test case completely pointless....\n+\n enum T {\n     A(int),\n     B(uint)\n }\n \n macro_rules! test(\n-    ($e:expr) => (\n+    ($id:ident, $e:expr) => (\n         fn foo(t: T) -> int {\n             match t {\n-                A(y) => $e,\n-                B(y) => $e\n+                A($id) => $e,\n+                B($id) => $e\n             }\n         }\n     )\n )\n \n-test!(10 + (y as int))\n+test!(y, 10 + (y as int))\n \n pub fn main() {\n     foo(A(20));"}, {"sha": "e9e2a753469f78aaf5266eb69867bbfd3b117c52", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n extern crate debug;\n "}, {"sha": "afeb9125fe64a5042226cea34ce87da254b5ad8e", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n extern crate debug;\n "}, {"sha": "6be79cb62dd7f09ccf6c1f32ffc1c14cd1b0d1a4", "filename": "src/test/run-pass/typeck-macro-interaction-issue-8852.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -15,19 +15,24 @@ enum T {\n     B(f64)\n }\n \n+// after fixing #9384 and implementing hygiene for match bindings,\n+// this now fails because the insertion of the 'y' into the match\n+// doesn't cause capture. Making this macro hygienic (as I've done)\n+// could very well make this test case completely pointless....\n+\n macro_rules! test(\n-    ($e:expr) => (\n+    ($id1:ident, $id2:ident, $e:expr) => (\n         fn foo(a:T, b:T) -> T {\n             match (a, b) {\n-                (A(x), A(y)) => A($e),\n-                (B(x), B(y)) => B($e),\n+                (A($id1), A($id2)) => A($e),\n+                (B($id1), B($id2)) => B($e),\n                 _ => fail!()\n             }\n         }\n     )\n )\n \n-test!(x + y)\n+test!(x,y,x + y)\n \n pub fn main() {\n     foo(A(1), A(2));"}, {"sha": "2af38047264fcf72f06ef428f3150d41f6ff8901", "filename": "src/test/run-pass/unfold-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n use std::iter::Unfold;\n "}, {"sha": "a79fcfa94171fb4211ac1aa79f9a398c3a2f810a", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf6f4b7c45bb6003a7c917e24583fc2b606826/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=0ddf6f4b7c45bb6003a7c917e24583fc2b606826", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty FIXME #15189\n+// no-pretty-expanded FIXME #15189\n \n pub fn main() {\n     let yen: char = '\u00a5'; // 0xa5"}]}