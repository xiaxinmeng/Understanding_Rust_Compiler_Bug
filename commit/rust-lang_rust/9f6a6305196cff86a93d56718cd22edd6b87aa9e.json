{"sha": "9f6a6305196cff86a93d56718cd22edd6b87aa9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNmE2MzA1MTk2Y2ZmODZhOTNkNTY3MThjZDIyZWRkNmI4N2FhOWU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-04T02:43:00Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-04T02:43:40Z"}, "message": "Drop rec and tup alloca temporariles on block exit.", "tree": {"sha": "7a699669ba6d65f650e64247360fd6c1dcb06f2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a699669ba6d65f650e64247360fd6c1dcb06f2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f6a6305196cff86a93d56718cd22edd6b87aa9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f6a6305196cff86a93d56718cd22edd6b87aa9e", "html_url": "https://github.com/rust-lang/rust/commit/9f6a6305196cff86a93d56718cd22edd6b87aa9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f6a6305196cff86a93d56718cd22edd6b87aa9e/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4d97543471a21b00de8a79fae15e6cf9a31508e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d97543471a21b00de8a79fae15e6cf9a31508e", "html_url": "https://github.com/rust-lang/rust/commit/b4d97543471a21b00de8a79fae15e6cf9a31508e"}], "stats": {"total": 25, "additions": 13, "deletions": 12}, "files": [{"sha": "64cba8127101f06db2b0e66e323963f00c5214b6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9f6a6305196cff86a93d56718cd22edd6b87aa9e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f6a6305196cff86a93d56718cd22edd6b87aa9e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9f6a6305196cff86a93d56718cd22edd6b87aa9e", "patch": "@@ -708,7 +708,9 @@ fn iter_sequence(@block_ctxt cx,\n         cond_cx.build.CondBr(end_test, body_cx.llbb, next_cx.llbb);\n \n         auto elt = body_cx.build.GEP(p0, vec(ix));\n-        auto body_res = f(body_cx, elt, elt_ty);\n+        auto body_res = f(body_cx,\n+                          load_non_structural(body_cx, elt, elt_ty),\n+                          elt_ty);\n         auto next_ix = body_res.bcx.build.Add(ix, C_int(1));\n         cond_cx.build.AddIncomingToPhi(ix, vec(next_ix),\n                                        vec(body_res.bcx.llbb));\n@@ -751,11 +753,7 @@ fn incr_all_refcnts(@block_ctxt cx,\n fn drop_slot(@block_ctxt cx,\n              ValueRef slot,\n              @typeck.ty t) -> result {\n-    if (typeck.type_is_structural(t)) {\n-        be drop_ty(cx, slot, t);\n-    } else {\n-        be drop_ty(cx, cx.build.Load(slot), t);\n-    }\n+    be drop_ty(cx, load_non_structural(cx, slot, t), t);\n }\n \n fn drop_ty(@block_ctxt cx,\n@@ -955,8 +953,7 @@ fn target_type(@crate_ctxt cx, @typeck.ty t) -> @typeck.ty {\n fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @typeck.ty {\n     alt (a) {\n         case (ast.ann_none) {\n-            log \"missing type annotation\";\n-            fail;\n+            cx.sess.bug(\"missing type annotation\");\n         }\n         case (ast.ann_type(?t)) {\n             ret target_type(cx, t);\n@@ -1412,8 +1409,10 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n \n impure fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n                     &ast.ann ann) -> result {\n-    auto ty = node_type(cx.fcx.ccx, ann);\n-    auto tup_val = cx.build.Alloca(ty);\n+    auto ty = node_ann_type(cx.fcx.ccx, ann);\n+    auto llty = type_of(cx.fcx.ccx, ty);\n+    auto tup_val = cx.build.Alloca(llty);\n+    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, tup_val, ty));\n     let int i = 0;\n     auto r = res(cx, C_nil());\n     for (ast.elt e in elts) {\n@@ -1429,8 +1428,10 @@ impure fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n \n impure fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n                     &ast.ann ann) -> result {\n-    auto ty = node_type(cx.fcx.ccx, ann);\n-    auto rec_val = cx.build.Alloca(ty);\n+    auto ty = node_ann_type(cx.fcx.ccx, ann);\n+    auto llty = type_of(cx.fcx.ccx, ty);\n+    auto rec_val = cx.build.Alloca(llty);\n+    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, rec_val, ty));\n     let int i = 0;\n     auto r = res(cx, C_nil());\n     for (ast.field f in fields) {"}]}