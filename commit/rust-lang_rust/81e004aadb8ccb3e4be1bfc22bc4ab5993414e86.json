{"sha": "81e004aadb8ccb3e4be1bfc22bc4ab5993414e86", "node_id": "C_kwDOAAsO6NoAKDgxZTAwNGFhZGI4Y2NiM2U0YmUxYmZjMjJiYzRhYjU5OTM0MTRlODY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-06T17:23:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-06T17:23:14Z"}, "message": "Auto merge of #8549 - J-ZhengLi:issue8542, r=llogiq\n\nfix FP in lint `[needless_match]`\n\nfixes: #8542\nfixes: #8551\nfixes: #8595\nfixes: #8599\n\n---\n\nchangelog: check for more complex custom type, and ignore type coercion in [`needless_match`]", "tree": {"sha": "8bde2be330dfa1aa1dccaf52334ff0c74e485436", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bde2be330dfa1aa1dccaf52334ff0c74e485436"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86", "html_url": "https://github.com/rust-lang/rust/commit/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30019d1d052f824cb31185881b71f7dba967bd96", "url": "https://api.github.com/repos/rust-lang/rust/commits/30019d1d052f824cb31185881b71f7dba967bd96", "html_url": "https://github.com/rust-lang/rust/commit/30019d1d052f824cb31185881b71f7dba967bd96"}, {"sha": "85b081b65aa36e0d7cbdfba7cd705517563c0bd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/85b081b65aa36e0d7cbdfba7cd705517563c0bd4", "html_url": "https://github.com/rust-lang/rust/commit/85b081b65aa36e0d7cbdfba7cd705517563c0bd4"}], "stats": {"total": 621, "additions": 425, "deletions": 196}, "files": [{"sha": "e93b494653fc05923feecace84790bb7606d6122", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=81e004aadb8ccb3e4be1bfc22bc4ab5993414e86", "patch": "@@ -667,7 +667,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     overlapping_arms::check(cx, ex, arms);\n                     match_wild_enum::check(cx, ex, arms);\n                     match_as_ref::check(cx, ex, arms, expr);\n-                    needless_match::check_match(cx, ex, arms);\n+                    needless_match::check_match(cx, ex, arms, expr);\n \n                     if self.infallible_destructuring_match_linted {\n                         self.infallible_destructuring_match_linted = false;"}, {"sha": "2105a03e03a301cb8cca7aba53623766dd1fdc6e", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 86, "deletions": 74, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=81e004aadb8ccb3e4be1bfc22bc4ab5993414e86", "patch": "@@ -1,37 +1,25 @@\n use super::NEEDLESS_MATCH;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, get_parent_expr, higher, is_else_clause, is_lang_ctor, peel_blocks_with_stmt};\n+use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n+use clippy_utils::{\n+    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_lang_ctor, over,\n+    peel_blocks_with_stmt,\n+};\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, Pat, PatKind, Path, PathSegment, QPath, UnOp};\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, FnRetTy, Node, Pat, PatKind, Path, QPath};\n use rustc_lint::LateContext;\n use rustc_span::sym;\n+use rustc_typeck::hir_ty_to_ty;\n \n-pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    // This is for avoiding collision with `match_single_binding`.\n-    if arms.len() < 2 {\n-        return;\n-    }\n-\n-    for arm in arms {\n-        if let PatKind::Wild = arm.pat.kind {\n-            let ret_expr = strip_return(arm.body);\n-            if !eq_expr_value(cx, ex, ret_expr) {\n-                return;\n-            }\n-        } else if !pat_same_as_expr(arm.pat, arm.body) {\n-            return;\n-        }\n-    }\n-\n-    if let Some(match_expr) = get_parent_expr(cx, ex) {\n+pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() > 1 && expr_ty_matches_p_ty(cx, ex, expr) && check_all_arms(cx, ex, arms) {\n         let mut applicability = Applicability::MachineApplicable;\n         span_lint_and_sugg(\n             cx,\n             NEEDLESS_MATCH,\n-            match_expr.span,\n+            expr.span,\n             \"this match expression is unnecessary\",\n             \"replace it with\",\n             snippet_with_applicability(cx, ex.span, \"..\", &mut applicability).to_string(),\n@@ -60,11 +48,8 @@ pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n /// }\n /// ```\n pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n-    if_chain! {\n-        if let Some(ref if_let) = higher::IfLet::hir(cx, ex);\n-        if !is_else_clause(cx.tcx, ex);\n-        if check_if_let(cx, if_let);\n-        then {\n+    if let Some(ref if_let) = higher::IfLet::hir(cx, ex) {\n+        if !is_else_clause(cx.tcx, ex) && expr_ty_matches_p_ty(cx, if_let.let_expr, ex) && check_if_let(cx, if_let) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n@@ -79,6 +64,19 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n     }\n }\n \n+fn check_all_arms(cx: &LateContext<'_>, match_expr: &Expr<'_>, arms: &[Arm<'_>]) -> bool {\n+    for arm in arms {\n+        let arm_expr = peel_blocks_with_stmt(arm.body);\n+        if let PatKind::Wild = arm.pat.kind {\n+            return eq_expr_value(cx, match_expr, strip_return(arm_expr));\n+        } else if !pat_same_as_expr(arm.pat, arm_expr) {\n+            return false;\n+        }\n+    }\n+\n+    true\n+}\n+\n fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n     if let Some(if_else) = if_let.if_else {\n         if !pat_same_as_expr(if_let.let_pat, peel_blocks_with_stmt(if_let.if_then)) {\n@@ -92,18 +90,21 @@ fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n \n         if matches!(if_else.kind, ExprKind::Block(..)) {\n             let else_expr = peel_blocks_with_stmt(if_else);\n+            if matches!(else_expr.kind, ExprKind::Block(..)) {\n+                return false;\n+            }\n             let ret = strip_return(else_expr);\n             let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n             if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n                 if let ExprKind::Path(ref qpath) = ret.kind {\n                     return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n                 }\n-            } else {\n-                return eq_expr_value(cx, if_let.let_expr, ret);\n+                return true;\n             }\n-            return true;\n+            return eq_expr_value(cx, if_let.let_expr, ret);\n         }\n     }\n+\n     false\n }\n \n@@ -116,48 +117,70 @@ fn strip_return<'hir>(expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n     }\n }\n \n+/// Manually check for coercion casting by checking if the type of the match operand or let expr\n+/// differs with the assigned local variable or the funtion return type.\n+fn expr_ty_matches_p_ty(cx: &LateContext<'_>, expr: &Expr<'_>, p_expr: &Expr<'_>) -> bool {\n+    if let Some(p_node) = get_parent_node(cx.tcx, p_expr.hir_id) {\n+        match p_node {\n+            // Compare match_expr ty with local in `let local = match match_expr {..}`\n+            Node::Local(local) => {\n+                let results = cx.typeck_results();\n+                return same_type_and_consts(results.node_type(local.hir_id), results.expr_ty(expr));\n+            },\n+            // compare match_expr ty with RetTy in `fn foo() -> RetTy`\n+            Node::Item(..) => {\n+                if let Some(fn_decl) = p_node.fn_decl() {\n+                    if let FnRetTy::Return(ret_ty) = fn_decl.output {\n+                        return same_type_and_consts(hir_ty_to_ty(cx.tcx, ret_ty), cx.typeck_results().expr_ty(expr));\n+                    }\n+                }\n+            },\n+            // check the parent expr for this whole block `{ match match_expr {..} }`\n+            Node::Block(block) => {\n+                if let Some(block_parent_expr) = get_parent_expr_for_hir(cx, block.hir_id) {\n+                    return expr_ty_matches_p_ty(cx, expr, block_parent_expr);\n+                }\n+            },\n+            // recursively call on `if xxx {..}` etc.\n+            Node::Expr(p_expr) => {\n+                return expr_ty_matches_p_ty(cx, expr, p_expr);\n+            },\n+            _ => {},\n+        }\n+    }\n+    false\n+}\n+\n fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n     let expr = strip_return(expr);\n     match (&pat.kind, &expr.kind) {\n         // Example: `Some(val) => Some(val)`\n-        (\n-            PatKind::TupleStruct(QPath::Resolved(_, path), [first_pat, ..], _),\n-            ExprKind::Call(call_expr, [first_param, ..]),\n-        ) => {\n+        (PatKind::TupleStruct(QPath::Resolved(_, path), tuple_params, _), ExprKind::Call(call_expr, call_params)) => {\n             if let ExprKind::Path(QPath::Resolved(_, call_path)) = call_expr.kind {\n-                if has_identical_segments(path.segments, call_path.segments)\n-                    && has_same_non_ref_symbol(first_pat, first_param)\n-                {\n-                    return true;\n-                }\n+                return over(path.segments, call_path.segments, |pat_seg, call_seg| {\n+                    pat_seg.ident.name == call_seg.ident.name\n+                }) && same_non_ref_symbols(tuple_params, call_params);\n             }\n         },\n-        // Example: `val => val`, or `ref val => *val`\n-        (PatKind::Binding(annot, _, pat_ident, _), _) => {\n-            let new_expr = if let (\n-                BindingAnnotation::Ref | BindingAnnotation::RefMut,\n-                ExprKind::Unary(UnOp::Deref, operand_expr),\n-            ) = (annot, &expr.kind)\n-            {\n-                operand_expr\n-            } else {\n-                expr\n-            };\n-\n-            if let ExprKind::Path(QPath::Resolved(\n+        // Example: `val => val`\n+        (\n+            PatKind::Binding(annot, _, pat_ident, _),\n+            ExprKind::Path(QPath::Resolved(\n                 _,\n                 Path {\n                     segments: [first_seg, ..],\n                     ..\n                 },\n-            )) = new_expr.kind\n-            {\n-                return pat_ident.name == first_seg.ident.name;\n-            }\n+            )),\n+        ) => {\n+            return !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut)\n+                && pat_ident.name == first_seg.ident.name;\n         },\n         // Example: `Custom::TypeA => Custom::TypeB`, or `None => None`\n         (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {\n-            return has_identical_segments(p_path.segments, e_path.segments);\n+            return over(p_path.segments, e_path.segments, |p_seg, e_seg| {\n+                p_seg.ident.name == e_seg.ident.name\n+            });\n         },\n         // Example: `5 => 5`\n         (PatKind::Lit(pat_lit_expr), ExprKind::Lit(expr_spanned)) => {\n@@ -171,27 +194,16 @@ fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n     false\n }\n \n-fn has_identical_segments(left_segs: &[PathSegment<'_>], right_segs: &[PathSegment<'_>]) -> bool {\n-    if left_segs.len() != right_segs.len() {\n+fn same_non_ref_symbols(pats: &[Pat<'_>], exprs: &[Expr<'_>]) -> bool {\n+    if pats.len() != exprs.len() {\n         return false;\n     }\n-    for i in 0..left_segs.len() {\n-        if left_segs[i].ident.name != right_segs[i].ident.name {\n-            return false;\n-        }\n-    }\n-    true\n-}\n \n-fn has_same_non_ref_symbol(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let PatKind::Binding(annot, _, pat_ident, _) = pat.kind;\n-        if !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-        if let ExprKind::Path(QPath::Resolved(_, Path {segments: [first_seg, ..], .. })) = expr.kind;\n-        then {\n-            return pat_ident.name == first_seg.ident.name;\n+    for i in 0..pats.len() {\n+        if !pat_same_as_expr(&pats[i], &exprs[i]) {\n+            return false;\n         }\n     }\n \n-    false\n+    true\n }"}, {"sha": "9ccccaa1725a65dc8867a1a48e9698c811682886", "filename": "tests/ui/needless_match.fixed", "status": "modified", "additions": 142, "deletions": 28, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/tests%2Fui%2Fneedless_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/tests%2Fui%2Fneedless_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.fixed?ref=81e004aadb8ccb3e4be1bfc22bc4ab5993414e86", "patch": "@@ -4,38 +4,35 @@\n #![allow(dead_code)]\n \n #[derive(Clone, Copy)]\n-enum Choice {\n+enum Simple {\n     A,\n     B,\n     C,\n     D,\n }\n \n-#[allow(unused_mut)]\n fn useless_match() {\n-    let mut i = 10;\n+    let i = 10;\n     let _: i32 = i;\n-    let _: i32 = i;\n-    let mut _i_mut = i;\n-\n     let s = \"test\";\n     let _: &str = s;\n }\n \n-fn custom_type_match(se: Choice) {\n-    let _: Choice = se;\n+fn custom_type_match() {\n+    let se = Simple::A;\n+    let _: Simple = se;\n     // Don't trigger\n-    let _: Choice = match se {\n-        Choice::A => Choice::A,\n-        Choice::B => Choice::B,\n-        _ => Choice::C,\n+    let _: Simple = match se {\n+        Simple::A => Simple::A,\n+        Simple::B => Simple::B,\n+        _ => Simple::C,\n     };\n     // Mingled, don't trigger\n-    let _: Choice = match se {\n-        Choice::A => Choice::B,\n-        Choice::B => Choice::C,\n-        Choice::C => Choice::D,\n-        Choice::D => Choice::A,\n+    let _: Simple = match se {\n+        Simple::A => Simple::B,\n+        Simple::B => Simple::C,\n+        Simple::C => Simple::D,\n+        Simple::D => Simple::A,\n     };\n }\n \n@@ -55,29 +52,146 @@ fn func_ret_err<T>(err: T) -> Result<i32, T> {\n fn result_match() {\n     let _: Result<i32, i32> = Ok(1);\n     let _: Result<i32, i32> = func_ret_err(0_i32);\n+    // as ref, don't trigger\n+    let res = &func_ret_err(0_i32);\n+    let _: Result<&i32, &i32> = match *res {\n+        Ok(ref x) => Ok(x),\n+        Err(ref x) => Err(x),\n+    };\n }\n \n-fn if_let_option() -> Option<i32> {\n-    Some(1)\n+fn if_let_option() {\n+    let _ = Some(1);\n+\n+    fn do_something() {}\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) {\n+        Some(a)\n+    } else {\n+        do_something();\n+        None\n+    };\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) {\n+        do_something();\n+        Some(a)\n+    } else {\n+        None\n+    };\n }\n \n-fn if_let_result(x: Result<(), i32>) {\n-    let _: Result<(), i32> = x;\n-    let _: Result<(), i32> = x;\n+fn if_let_result() {\n+    let x: Result<i32, i32> = Ok(1);\n+    let _: Result<i32, i32> = x;\n+    let _: Result<i32, i32> = x;\n     // Input type mismatch, don't trigger\n-    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n+    let _: Result<i32, i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n }\n \n-fn if_let_custom_enum(x: Choice) {\n-    let _: Choice = x;\n+fn if_let_custom_enum(x: Simple) {\n+    let _: Simple = x;\n+\n     // Don't trigger\n-    let _: Choice = if let Choice::A = x {\n-        Choice::A\n+    let _: Simple = if let Simple::A = x {\n+        Simple::A\n     } else if true {\n-        Choice::B\n+        Simple::B\n     } else {\n         x\n     };\n }\n \n+mod issue8542 {\n+    #[derive(Clone, Copy)]\n+    enum E {\n+        VariantA(u8, u8),\n+        VariantB(u8, bool),\n+    }\n+\n+    enum Complex {\n+        A(u8),\n+        B(u8, bool),\n+        C(u8, i32, f64),\n+        D(E, bool),\n+    }\n+\n+    fn match_test() {\n+        let ce = Complex::B(8, false);\n+        let aa = 0_u8;\n+        let bb = false;\n+\n+        let _: Complex = ce;\n+\n+        // Don't trigger\n+        let _: Complex = match ce {\n+            Complex::A(_) => Complex::A(aa),\n+            Complex::B(_, b) => Complex::B(aa, b),\n+            Complex::C(_, b, _) => Complex::C(aa, b, 64_f64),\n+            Complex::D(e, b) => Complex::D(e, b),\n+        };\n+\n+        // Don't trigger\n+        let _: Complex = match ce {\n+            Complex::A(a) => Complex::A(a),\n+            Complex::B(a, _) => Complex::B(a, bb),\n+            Complex::C(a, _, _) => Complex::C(a, 32_i32, 64_f64),\n+            _ => ce,\n+        };\n+    }\n+}\n+\n+/// Lint triggered when type coercions happen.\n+/// Do NOT trigger on any of these.\n+mod issue8551 {\n+    trait Trait {}\n+    struct Struct;\n+    impl Trait for Struct {}\n+\n+    fn optmap(s: Option<&Struct>) -> Option<&dyn Trait> {\n+        match s {\n+            Some(s) => Some(s),\n+            None => None,\n+        }\n+    }\n+\n+    fn lint_tests() {\n+        let option: Option<&Struct> = None;\n+        let _: Option<&dyn Trait> = match option {\n+            Some(s) => Some(s),\n+            None => None,\n+        };\n+\n+        let _: Option<&dyn Trait> = if true {\n+            match option {\n+                Some(s) => Some(s),\n+                None => None,\n+            }\n+        } else {\n+            None\n+        };\n+\n+        let result: Result<&Struct, i32> = Err(0);\n+        let _: Result<&dyn Trait, i32> = match result {\n+            Ok(s) => Ok(s),\n+            Err(e) => Err(e),\n+        };\n+\n+        let _: Option<&dyn Trait> = if let Some(s) = option { Some(s) } else { None };\n+    }\n+}\n+\n+trait Tr {\n+    fn as_mut(&mut self) -> Result<&mut i32, &mut i32>;\n+}\n+impl Tr for Result<i32, i32> {\n+    fn as_mut(&mut self) -> Result<&mut i32, &mut i32> {\n+        match self {\n+            Ok(x) => Ok(x),\n+            Err(e) => Err(e),\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "d210ecff7f1633a8a6e157e643cc9d42725457e9", "filename": "tests/ui/needless_match.rs", "status": "modified", "additions": 157, "deletions": 45, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/tests%2Fui%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/tests%2Fui%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.rs?ref=81e004aadb8ccb3e4be1bfc22bc4ab5993414e86", "patch": "@@ -4,33 +4,21 @@\n #![allow(dead_code)]\n \n #[derive(Clone, Copy)]\n-enum Choice {\n+enum Simple {\n     A,\n     B,\n     C,\n     D,\n }\n \n-#[allow(unused_mut)]\n fn useless_match() {\n-    let mut i = 10;\n+    let i = 10;\n     let _: i32 = match i {\n         0 => 0,\n         1 => 1,\n         2 => 2,\n         _ => i,\n     };\n-    let _: i32 = match i {\n-        0 => 0,\n-        1 => 1,\n-        ref i => *i,\n-    };\n-    let mut _i_mut = match i {\n-        0 => 0,\n-        1 => 1,\n-        ref mut i => *i,\n-    };\n-\n     let s = \"test\";\n     let _: &str = match s {\n         \"a\" => \"a\",\n@@ -39,25 +27,26 @@ fn useless_match() {\n     };\n }\n \n-fn custom_type_match(se: Choice) {\n-    let _: Choice = match se {\n-        Choice::A => Choice::A,\n-        Choice::B => Choice::B,\n-        Choice::C => Choice::C,\n-        Choice::D => Choice::D,\n+fn custom_type_match() {\n+    let se = Simple::A;\n+    let _: Simple = match se {\n+        Simple::A => Simple::A,\n+        Simple::B => Simple::B,\n+        Simple::C => Simple::C,\n+        Simple::D => Simple::D,\n     };\n     // Don't trigger\n-    let _: Choice = match se {\n-        Choice::A => Choice::A,\n-        Choice::B => Choice::B,\n-        _ => Choice::C,\n+    let _: Simple = match se {\n+        Simple::A => Simple::A,\n+        Simple::B => Simple::B,\n+        _ => Simple::C,\n     };\n     // Mingled, don't trigger\n-    let _: Choice = match se {\n-        Choice::A => Choice::B,\n-        Choice::B => Choice::C,\n-        Choice::C => Choice::D,\n-        Choice::D => Choice::A,\n+    let _: Simple = match se {\n+        Simple::A => Simple::B,\n+        Simple::B => Simple::C,\n+        Simple::C => Simple::D,\n+        Simple::D => Simple::A,\n     };\n }\n \n@@ -86,37 +75,160 @@ fn result_match() {\n         Err(err) => Err(err),\n         Ok(a) => Ok(a),\n     };\n+    // as ref, don't trigger\n+    let res = &func_ret_err(0_i32);\n+    let _: Result<&i32, &i32> = match *res {\n+        Ok(ref x) => Ok(x),\n+        Err(ref x) => Err(x),\n+    };\n }\n \n-fn if_let_option() -> Option<i32> {\n-    if let Some(a) = Some(1) { Some(a) } else { None }\n+fn if_let_option() {\n+    let _ = if let Some(a) = Some(1) { Some(a) } else { None };\n+\n+    fn do_something() {}\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) {\n+        Some(a)\n+    } else {\n+        do_something();\n+        None\n+    };\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) {\n+        do_something();\n+        Some(a)\n+    } else {\n+        None\n+    };\n }\n \n-fn if_let_result(x: Result<(), i32>) {\n-    let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n-    let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n+fn if_let_result() {\n+    let x: Result<i32, i32> = Ok(1);\n+    let _: Result<i32, i32> = if let Err(e) = x { Err(e) } else { x };\n+    let _: Result<i32, i32> = if let Ok(val) = x { Ok(val) } else { x };\n     // Input type mismatch, don't trigger\n-    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n+    let _: Result<i32, i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n }\n \n-fn if_let_custom_enum(x: Choice) {\n-    let _: Choice = if let Choice::A = x {\n-        Choice::A\n-    } else if let Choice::B = x {\n-        Choice::B\n-    } else if let Choice::C = x {\n-        Choice::C\n+fn if_let_custom_enum(x: Simple) {\n+    let _: Simple = if let Simple::A = x {\n+        Simple::A\n+    } else if let Simple::B = x {\n+        Simple::B\n+    } else if let Simple::C = x {\n+        Simple::C\n     } else {\n         x\n     };\n+\n     // Don't trigger\n-    let _: Choice = if let Choice::A = x {\n-        Choice::A\n+    let _: Simple = if let Simple::A = x {\n+        Simple::A\n     } else if true {\n-        Choice::B\n+        Simple::B\n     } else {\n         x\n     };\n }\n \n+mod issue8542 {\n+    #[derive(Clone, Copy)]\n+    enum E {\n+        VariantA(u8, u8),\n+        VariantB(u8, bool),\n+    }\n+\n+    enum Complex {\n+        A(u8),\n+        B(u8, bool),\n+        C(u8, i32, f64),\n+        D(E, bool),\n+    }\n+\n+    fn match_test() {\n+        let ce = Complex::B(8, false);\n+        let aa = 0_u8;\n+        let bb = false;\n+\n+        let _: Complex = match ce {\n+            Complex::A(a) => Complex::A(a),\n+            Complex::B(a, b) => Complex::B(a, b),\n+            Complex::C(a, b, c) => Complex::C(a, b, c),\n+            Complex::D(E::VariantA(ea, eb), b) => Complex::D(E::VariantA(ea, eb), b),\n+            Complex::D(E::VariantB(ea, eb), b) => Complex::D(E::VariantB(ea, eb), b),\n+        };\n+\n+        // Don't trigger\n+        let _: Complex = match ce {\n+            Complex::A(_) => Complex::A(aa),\n+            Complex::B(_, b) => Complex::B(aa, b),\n+            Complex::C(_, b, _) => Complex::C(aa, b, 64_f64),\n+            Complex::D(e, b) => Complex::D(e, b),\n+        };\n+\n+        // Don't trigger\n+        let _: Complex = match ce {\n+            Complex::A(a) => Complex::A(a),\n+            Complex::B(a, _) => Complex::B(a, bb),\n+            Complex::C(a, _, _) => Complex::C(a, 32_i32, 64_f64),\n+            _ => ce,\n+        };\n+    }\n+}\n+\n+/// Lint triggered when type coercions happen.\n+/// Do NOT trigger on any of these.\n+mod issue8551 {\n+    trait Trait {}\n+    struct Struct;\n+    impl Trait for Struct {}\n+\n+    fn optmap(s: Option<&Struct>) -> Option<&dyn Trait> {\n+        match s {\n+            Some(s) => Some(s),\n+            None => None,\n+        }\n+    }\n+\n+    fn lint_tests() {\n+        let option: Option<&Struct> = None;\n+        let _: Option<&dyn Trait> = match option {\n+            Some(s) => Some(s),\n+            None => None,\n+        };\n+\n+        let _: Option<&dyn Trait> = if true {\n+            match option {\n+                Some(s) => Some(s),\n+                None => None,\n+            }\n+        } else {\n+            None\n+        };\n+\n+        let result: Result<&Struct, i32> = Err(0);\n+        let _: Result<&dyn Trait, i32> = match result {\n+            Ok(s) => Ok(s),\n+            Err(e) => Err(e),\n+        };\n+\n+        let _: Option<&dyn Trait> = if let Some(s) = option { Some(s) } else { None };\n+    }\n+}\n+\n+trait Tr {\n+    fn as_mut(&mut self) -> Result<&mut i32, &mut i32>;\n+}\n+impl Tr for Result<i32, i32> {\n+    fn as_mut(&mut self) -> Result<&mut i32, &mut i32> {\n+        match self {\n+            Ok(x) => Ok(x),\n+            Err(e) => Err(e),\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "34c5226f06057611d9eb87ac5c631b4d241850e8", "filename": "tests/ui/needless_match.stderr", "status": "modified", "additions": 39, "deletions": 48, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/tests%2Fui%2Fneedless_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81e004aadb8ccb3e4be1bfc22bc4ab5993414e86/tests%2Fui%2Fneedless_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.stderr?ref=81e004aadb8ccb3e4be1bfc22bc4ab5993414e86", "patch": "@@ -1,5 +1,5 @@\n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:17:18\n+  --> $DIR/needless_match.rs:16:18\n    |\n LL |       let _: i32 = match i {\n    |  __________________^\n@@ -13,29 +13,7 @@ LL | |     };\n    = note: `-D clippy::needless-match` implied by `-D warnings`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:23:18\n-   |\n-LL |       let _: i32 = match i {\n-   |  __________________^\n-LL | |         0 => 0,\n-LL | |         1 => 1,\n-LL | |         ref i => *i,\n-LL | |     };\n-   | |_____^ help: replace it with: `i`\n-\n-error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:28:22\n-   |\n-LL |       let mut _i_mut = match i {\n-   |  ______________________^\n-LL | |         0 => 0,\n-LL | |         1 => 1,\n-LL | |         ref mut i => *i,\n-LL | |     };\n-   | |_____^ help: replace it with: `i`\n-\n-error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:35:19\n+  --> $DIR/needless_match.rs:23:19\n    |\n LL |       let _: &str = match s {\n    |  ___________________^\n@@ -46,19 +24,19 @@ LL | |     };\n    | |_____^ help: replace it with: `s`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:43:21\n+  --> $DIR/needless_match.rs:32:21\n    |\n-LL |       let _: Choice = match se {\n+LL |       let _: Simple = match se {\n    |  _____________________^\n-LL | |         Choice::A => Choice::A,\n-LL | |         Choice::B => Choice::B,\n-LL | |         Choice::C => Choice::C,\n-LL | |         Choice::D => Choice::D,\n+LL | |         Simple::A => Simple::A,\n+LL | |         Simple::B => Simple::B,\n+LL | |         Simple::C => Simple::C,\n+LL | |         Simple::D => Simple::D,\n LL | |     };\n    | |_____^ help: replace it with: `se`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:65:26\n+  --> $DIR/needless_match.rs:54:26\n    |\n LL |       let _: Option<i32> = match x {\n    |  __________________________^\n@@ -68,7 +46,7 @@ LL | |     };\n    | |_____^ help: replace it with: `x`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:81:31\n+  --> $DIR/needless_match.rs:70:31\n    |\n LL |       let _: Result<i32, i32> = match Ok(1) {\n    |  _______________________________^\n@@ -78,7 +56,7 @@ LL | |     };\n    | |_____^ help: replace it with: `Ok(1)`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:85:31\n+  --> $DIR/needless_match.rs:74:31\n    |\n LL |       let _: Result<i32, i32> = match func_ret_err(0_i32) {\n    |  _______________________________^\n@@ -88,35 +66,48 @@ LL | |     };\n    | |_____^ help: replace it with: `func_ret_err(0_i32)`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:92:5\n+  --> $DIR/needless_match.rs:87:13\n    |\n-LL |     if let Some(a) = Some(1) { Some(a) } else { None }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `Some(1)`\n+LL |     let _ = if let Some(a) = Some(1) { Some(a) } else { None };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `Some(1)`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:96:30\n+  --> $DIR/needless_match.rs:110:31\n    |\n-LL |     let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+LL |     let _: Result<i32, i32> = if let Err(e) = x { Err(e) } else { x };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:97:30\n+  --> $DIR/needless_match.rs:111:31\n    |\n-LL |     let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+LL |     let _: Result<i32, i32> = if let Ok(val) = x { Ok(val) } else { x };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:103:21\n+  --> $DIR/needless_match.rs:117:21\n    |\n-LL |       let _: Choice = if let Choice::A = x {\n+LL |       let _: Simple = if let Simple::A = x {\n    |  _____________________^\n-LL | |         Choice::A\n-LL | |     } else if let Choice::B = x {\n-LL | |         Choice::B\n+LL | |         Simple::A\n+LL | |     } else if let Simple::B = x {\n+LL | |         Simple::B\n ...  |\n LL | |         x\n LL | |     };\n    | |_____^ help: replace it with: `x`\n \n-error: aborting due to 12 previous errors\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:156:26\n+   |\n+LL |           let _: Complex = match ce {\n+   |  __________________________^\n+LL | |             Complex::A(a) => Complex::A(a),\n+LL | |             Complex::B(a, b) => Complex::B(a, b),\n+LL | |             Complex::C(a, b, c) => Complex::C(a, b, c),\n+LL | |             Complex::D(E::VariantA(ea, eb), b) => Complex::D(E::VariantA(ea, eb), b),\n+LL | |             Complex::D(E::VariantB(ea, eb), b) => Complex::D(E::VariantB(ea, eb), b),\n+LL | |         };\n+   | |_________^ help: replace it with: `ce`\n+\n+error: aborting due to 11 previous errors\n "}]}