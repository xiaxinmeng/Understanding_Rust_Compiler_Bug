{"sha": "9b8e4c63de9949b0db0977eaa954ee7009485310", "node_id": "C_kwDOAAsO6NoAKDliOGU0YzYzZGU5OTQ5YjBkYjA5NzdlYWE5NTRlZTcwMDk0ODUzMTA", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-01-27T22:50:46Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-01-27T23:20:25Z"}, "message": "Don't allow {} to refer to implicit captures in format_args.", "tree": {"sha": "4f263d63fcc36f153d6df4ac9e3d71bce556b0a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f263d63fcc36f153d6df4ac9e3d71bce556b0a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b8e4c63de9949b0db0977eaa954ee7009485310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b8e4c63de9949b0db0977eaa954ee7009485310", "html_url": "https://github.com/rust-lang/rust/commit/9b8e4c63de9949b0db0977eaa954ee7009485310", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b8e4c63de9949b0db0977eaa954ee7009485310/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "html_url": "https://github.com/rust-lang/rust/commit/9ad5d82f822b3cb67637f11be2e65c5662b66ec0"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "154c51b2c7b9ef1a4fd37c2ca35020dd38c9bb62", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9b8e4c63de9949b0db0977eaa954ee7009485310/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8e4c63de9949b0db0977eaa954ee7009485310/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=9b8e4c63de9949b0db0977eaa954ee7009485310", "patch": "@@ -23,6 +23,7 @@ enum ArgumentType {\n \n enum Position {\n     Exact(usize),\n+    Capture(usize),\n     Named(Symbol),\n }\n \n@@ -47,6 +48,8 @@ struct Context<'a, 'b> {\n     /// * `arg_unique_types` (in simplified JSON): `[[\"o\", \"x\"], [\"o\", \"x\"], [\"o\", \"x\"]]`\n     /// * `names` (in JSON): `{\"foo\": 2}`\n     args: Vec<P<ast::Expr>>,\n+    /// The number of arguments that were added by implicit capturing.\n+    num_captured_args: usize,\n     /// Placeholder slot numbers indexed by argument.\n     arg_types: Vec<Vec<usize>>,\n     /// Unique format specs seen for each argument.\n@@ -229,6 +232,11 @@ fn parse_args<'a>(\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n+    /// The number of arguments that were explicitly given.\n+    fn num_args(&self) -> usize {\n+        self.args.len() - self.num_captured_args\n+    }\n+\n     fn resolve_name_inplace(&self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n@@ -343,7 +351,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n \n     fn describe_num_args(&self) -> Cow<'_, str> {\n-        match self.args.len() {\n+        match self.num_args() {\n             0 => \"no arguments were given\".into(),\n             1 => \"there is 1 argument\".into(),\n             x => format!(\"there are {} arguments\", x).into(),\n@@ -369,7 +377,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         let count = self.pieces.len()\n             + self.arg_with_formatting.iter().filter(|fmt| fmt.precision_span.is_some()).count();\n-        if self.names.is_empty() && !numbered_position_args && count != self.args.len() {\n+        if self.names.is_empty() && !numbered_position_args && count != self.num_args() {\n             e = self.ecx.struct_span_err(\n                 sp,\n                 &format!(\n@@ -417,7 +425,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             if let Some(span) = fmt.precision_span {\n                 let span = self.fmtsp.from_inner(span);\n                 match fmt.precision {\n-                    parse::CountIsParam(pos) if pos > self.args.len() => {\n+                    parse::CountIsParam(pos) if pos > self.num_args() => {\n                         e.span_label(\n                             span,\n                             &format!(\n@@ -460,7 +468,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             if let Some(span) = fmt.width_span {\n                 let span = self.fmtsp.from_inner(span);\n                 match fmt.width {\n-                    parse::CountIsParam(pos) if pos > self.args.len() => {\n+                    parse::CountIsParam(pos) if pos > self.num_args() => {\n                         e.span_label(\n                             span,\n                             &format!(\n@@ -492,12 +500,15 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Actually verifies and tracks a given format placeholder\n     /// (a.k.a. argument).\n     fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n+        if let Exact(arg) = arg {\n+            if arg >= self.num_args() {\n+                self.invalid_refs.push((arg, self.curpiece));\n+                return;\n+            }\n+        }\n+\n         match arg {\n-            Exact(arg) => {\n-                if self.args.len() <= arg {\n-                    self.invalid_refs.push((arg, self.curpiece));\n-                    return;\n-                }\n+            Exact(arg) | Capture(arg) => {\n                 match ty {\n                     Placeholder(_) => {\n                         // record every (position, type) combination only once\n@@ -524,7 +535,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 match self.names.get(&name) {\n                     Some(&idx) => {\n                         // Treat as positional arg.\n-                        self.verify_arg_type(Exact(idx), ty)\n+                        self.verify_arg_type(Capture(idx), ty)\n                     }\n                     None => {\n                         // For the moment capturing variables from format strings expanded from macros is\n@@ -539,9 +550,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                             } else {\n                                 self.fmtsp\n                             };\n+                            self.num_captured_args += 1;\n                             self.args.push(self.ecx.expr_ident(span, Ident::new(name, span)));\n                             self.names.insert(name, idx);\n-                            self.verify_arg_type(Exact(idx), ty)\n+                            self.verify_arg_type(Capture(idx), ty)\n                         } else {\n                             let msg = format!(\"there is no argument named `{}`\", name);\n                             let sp = if self.is_literal {\n@@ -1010,6 +1022,7 @@ pub fn expand_preparsed_format_args(\n     let mut cx = Context {\n         ecx,\n         args,\n+        num_captured_args: 0,\n         arg_types,\n         arg_unique_types,\n         names,"}]}