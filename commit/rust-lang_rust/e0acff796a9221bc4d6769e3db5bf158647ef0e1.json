{"sha": "e0acff796a9221bc4d6769e3db5bf158647ef0e1", "node_id": "C_kwDOAAsO6NoAKGUwYWNmZjc5NmE5MjIxYmM0ZDY3NjllM2RiNWJmMTU4NjQ3ZWYwZTE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-31T01:02:32Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-06T18:43:06Z"}, "message": "New trait solver is a property of inference context", "tree": {"sha": "2a8cabfad9e1e4173ec2d44871a81dd10180b6d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a8cabfad9e1e4173ec2d44871a81dd10180b6d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0acff796a9221bc4d6769e3db5bf158647ef0e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0acff796a9221bc4d6769e3db5bf158647ef0e1", "html_url": "https://github.com/rust-lang/rust/commit/e0acff796a9221bc4d6769e3db5bf158647ef0e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0acff796a9221bc4d6769e3db5bf158647ef0e1/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3572d7451d1062e8bccf310af6bbf6255091d296", "url": "https://api.github.com/repos/rust-lang/rust/commits/3572d7451d1062e8bccf310af6bbf6255091d296", "html_url": "https://github.com/rust-lang/rust/commit/3572d7451d1062e8bccf310af6bbf6255091d296"}], "stats": {"total": 103, "additions": 61, "deletions": 42}, "files": [{"sha": "a561496b02639ae3d2d529bd768fbbacf2271e06", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -285,7 +285,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         let infcx = self\n             .tcx\n             .infer_ctxt()\n-            .with_opaque_type_inference(if self.tcx.trait_solver_next() {\n+            .with_opaque_type_inference(if self.next_trait_solver() {\n                 DefiningAnchor::Bind(def_id)\n             } else {\n                 DefiningAnchor::Bubble"}, {"sha": "a2f95c19cf59f69038482233fa1a392cafbeb546", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -188,7 +188,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n     // FIXME(-Ztrait-solver=next): A bit dubious that we're only registering\n     // predefined opaques in the typeck root.\n-    if infcx.tcx.trait_solver_next() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n+    if infcx.next_trait_solver() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n         checker.register_predefined_opaques_in_new_solver();\n     }\n "}, {"sha": "f624118a4f1f0ba9f49558c365ce9cc5c87c987e", "filename": "compiler/rustc_hir_analysis/src/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n             // NOTE: we may still need to normalize the built-in deref in case\n             // we have some type like `&<Ty as Trait>::Assoc`, since users of\n             // autoderef expect this type to have been structurally normalized.\n-            if self.infcx.tcx.trait_solver_next()\n+            if self.infcx.next_trait_solver()\n                 && let ty::Alias(ty::Projection, _) = ty.kind()\n             {\n                 let (normalized_ty, obligations) = self.structurally_normalize(ty)?;"}, {"sha": "81231e8fe068ba5a825c7dddca67eb66d3ba3d8a", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -156,7 +156,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // In the new solver, lazy norm may allow us to shallowly equate\n             // more types, but we emit possibly impossible-to-satisfy obligations.\n             // Filter these cases out to make sure our coercion is more accurate.\n-            if self.tcx.trait_solver_next() {\n+            if self.next_trait_solver() {\n                 if let Ok(res) = &res {\n                     for obligation in &res.obligations {\n                         if !self.predicate_may_hold(&obligation) {"}, {"sha": "fb56b7e74cb549bb365d4938ba71d0fedd9f68da", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -1476,7 +1476,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let mut ty = self.resolve_vars_with_obligations(ty);\n \n-        if self.tcx.trait_solver_next()\n+        if self.next_trait_solver()\n             && let ty::Alias(ty::Projection, _) = ty.kind()\n         {\n             match self"}, {"sha": "6a3a46c778a7a0d4e5a061312907c3191a9dbc8c", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -591,7 +591,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 .insert(opaque_type_key, hidden_type)\n                 && last_opaque_ty.ty != hidden_type.ty\n             {\n-                assert!(!self.tcx().trait_solver_next());\n+                assert!(!self.fcx.next_trait_solver());\n                 hidden_type\n                     .report_mismatch(&last_opaque_ty, opaque_type_key.def_id, self.tcx())\n                     .stash(\n@@ -812,7 +812,7 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Resolver<'cx, 'tcx> {\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match self.fcx.fully_resolve(t) {\n-            Ok(t) if self.fcx.tcx.trait_solver_next() => {\n+            Ok(t) if self.fcx.next_trait_solver() => {\n                 // We must normalize erasing regions here, since later lints\n                 // expect that types that show up in the typeck are fully\n                 // normalized."}, {"sha": "1f0bf4f9887c3bacddab7c32e5e7403e9470dc02", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -82,6 +82,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),\n             intercrate: self.intercrate,\n+            next_trait_solver: self.next_trait_solver,\n         }\n     }\n }"}, {"sha": "ccfc44a7e445a14e50cd72f23afd26f7dabb5861", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -109,11 +109,11 @@ impl<'tcx> InferCtxt<'tcx> {\n             | (\n                 ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)),\n                 ty::Alias(AliasKind::Projection, _),\n-            ) if self.tcx.trait_solver_next() => {\n+            ) if self.next_trait_solver() => {\n                 bug!()\n             }\n \n-            (_, ty::Alias(..)) | (ty::Alias(..), _) if self.tcx.trait_solver_next() => {\n+            (_, ty::Alias(..)) | (ty::Alias(..), _) if self.next_trait_solver() => {\n                 relation.register_type_relate_obligation(a, b);\n                 Ok(a)\n             }\n@@ -227,9 +227,22 @@ impl<'tcx> InferCtxt<'tcx> {\n                 return self.unify_const_variable(vid, a, relation.param_env());\n             }\n             (ty::ConstKind::Unevaluated(..), _) | (_, ty::ConstKind::Unevaluated(..))\n-                if self.tcx.features().generic_const_exprs || self.tcx.trait_solver_next() =>\n+                if self.tcx.features().generic_const_exprs || self.next_trait_solver() =>\n             {\n-                relation.register_const_equate_obligation(a, b);\n+                let (a, b) = if relation.a_is_expected() { (a, b) } else { (b, a) };\n+\n+                relation.register_predicates([ty::Binder::dummy(\n+                    if self.next_trait_solver() {\n+                        ty::PredicateKind::AliasRelate(\n+                            a.into(),\n+                            b.into(),\n+                            ty::AliasRelationDirection::Equate,\n+                        )\n+                    } else {\n+                        ty::PredicateKind::ConstEquate(a, b)\n+                    },\n+                )]);\n+\n                 return Ok(b);\n             }\n             _ => {}\n@@ -453,19 +466,6 @@ pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n     /// be used if control over the obligation causes is required.\n     fn register_predicates(&mut self, obligations: impl IntoIterator<Item: ToPredicate<'tcx>>);\n \n-    /// Register an obligation that both constants must be equal to each other.\n-    ///\n-    /// If they aren't equal then the relation doesn't hold.\n-    fn register_const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n-\n-        self.register_predicates([ty::Binder::dummy(if self.tcx().trait_solver_next() {\n-            ty::PredicateKind::AliasRelate(a.into(), b.into(), ty::AliasRelationDirection::Equate)\n-        } else {\n-            ty::PredicateKind::ConstEquate(a, b)\n-        })]);\n-    }\n-\n     /// Register an obligation that both types must be related to each other according to\n     /// the [`ty::AliasRelationDirection`] given by [`ObligationEmittingRelation::alias_relate_direction`]\n     fn register_type_relate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {"}, {"sha": "495c250a77d073dd476166f1d5416cc7be20183e", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n                     && def_id.is_local()\n-                    && !self.tcx().trait_solver_next() =>\n+                    && !self.fields.infcx.next_trait_solver() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "9ef35429fe32c2719878e046ea01d20876b1f743", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -113,7 +113,7 @@ where\n         | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n             if this.define_opaque_types() == DefineOpaqueTypes::Yes\n                 && def_id.is_local()\n-                && !this.tcx().trait_solver_next() =>\n+                && !this.infcx().next_trait_solver() =>\n         {\n             this.register_obligations(\n                 infcx"}, {"sha": "7041e21a3812fa5b593c2f71f895086525126356", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -330,6 +330,8 @@ pub struct InferCtxt<'tcx> {\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     pub intercrate: bool,\n+\n+    next_trait_solver: bool,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -545,6 +547,9 @@ pub struct InferCtxtBuilder<'tcx> {\n     skip_leak_check: bool,\n     /// Whether we are in coherence mode.\n     intercrate: bool,\n+    /// Whether we should use the new trait solver in the local inference context,\n+    /// which affects things like which solver is used in `predicate_may_hold`.\n+    next_trait_solver: bool,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -559,6 +564,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             considering_regions: true,\n             skip_leak_check: false,\n             intercrate: false,\n+            next_trait_solver: self.next_trait_solver_globally(),\n         }\n     }\n }\n@@ -575,6 +581,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn with_next_trait_solver(mut self, next_trait_solver: bool) -> Self {\n+        self.next_trait_solver = next_trait_solver;\n+        self\n+    }\n+\n     pub fn intercrate(mut self, intercrate: bool) -> Self {\n         self.intercrate = intercrate;\n         self\n@@ -617,6 +628,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             considering_regions,\n             skip_leak_check,\n             intercrate,\n+            next_trait_solver,\n         } = *self;\n         InferCtxt {\n             tcx,\n@@ -634,6 +646,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             in_snapshot: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n             intercrate,\n+            next_trait_solver,\n         }\n     }\n }\n@@ -670,6 +683,10 @@ pub struct CombinedSnapshot<'tcx> {\n }\n \n impl<'tcx> InferCtxt<'tcx> {\n+    pub fn next_trait_solver(&self) -> bool {\n+        self.next_trait_solver\n+    }\n+\n     /// Creates a `TypeErrCtxt` for emitting various inference errors.\n     /// During typeck, use `FnCtxt::err_ctxt` instead.\n     pub fn err_ctxt(&self) -> TypeErrCtxt<'_, 'tcx> {"}, {"sha": "71c07f31bc952a6a868ac7810b08054323296e2e", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -491,12 +491,12 @@ where\n             (\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n-            ) if a_def_id == b_def_id || infcx.tcx.trait_solver_next() => {\n+            ) if a_def_id == b_def_id || infcx.next_trait_solver() => {\n                 infcx.super_combine_tys(self, a, b).or_else(|err| {\n                     // This behavior is only there for the old solver, the new solver\n                     // shouldn't ever fail. Instead, it unconditionally emits an\n                     // alias-relate goal.\n-                    assert!(!self.tcx().trait_solver_next());\n+                    assert!(!self.infcx.next_trait_solver());\n                     self.tcx().sess.delay_span_bug(\n                         self.delegate.span(),\n                         \"failure to relate an opaque to itself should result in an error later on\",\n@@ -506,7 +506,7 @@ where\n             }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if def_id.is_local() && !self.tcx().trait_solver_next() =>\n+                if def_id.is_local() && !self.infcx.next_trait_solver() =>\n             {\n                 self.relate_opaques(a, b)\n             }"}, {"sha": "a9ead429f4c71898540e221b6e0946191a1501bc", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> InferOk<'tcx, T> {\n         // We handle opaque types differently in the new solver.\n-        if self.tcx.trait_solver_next() {\n+        if self.next_trait_solver() {\n             return InferOk { value, obligations: vec![] };\n         }\n \n@@ -578,7 +578,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         hidden_ty: Ty<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n-        assert!(self.tcx.trait_solver_next());\n+        assert!(self.next_trait_solver());\n         let origin = self\n             .opaque_type_origin(opaque_type_key.def_id)\n             .expect(\"should be called for defining usages only\");\n@@ -614,7 +614,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n                             && !tcx.is_impl_trait_in_trait(projection_ty.def_id)\n-                            && !tcx.trait_solver_next() =>\n+                            && !self.next_trait_solver() =>\n                     {\n                         self.infer_projection(\n                             param_env,"}, {"sha": "4f8c9188cf85b8440eb6328f604df88af2d0b8fa", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -21,7 +21,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         recursion_depth: usize,\n         obligations: &mut Vec<PredicateObligation<'tcx>>,\n     ) -> Ty<'tcx> {\n-        if self.tcx.trait_solver_next() {\n+        if self.next_trait_solver() {\n             // FIXME(-Ztrait-solver=next): Instead of branching here,\n             // completely change the normalization routine with the new solver.\n             //"}, {"sha": "d9f9d2aabdbf7524a3cbf69c5b839bb2ba9f2b18", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -132,7 +132,7 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n                     && def_id.is_local()\n-                    && !self.tcx().trait_solver_next() =>\n+                    && !self.fields.infcx.next_trait_solver() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "33ca68a0d03858a8135d00d2af5fbe9e2fb115f1", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -2333,7 +2333,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.opt_local_def_id_to_hir_id(local_def_id).unwrap()\n     }\n \n-    pub fn trait_solver_next(self) -> bool {\n+    pub fn next_trait_solver_globally(self) -> bool {\n         self.sess.opts.unstable_opts.trait_solver == rustc_session::config::TraitSolver::Next\n     }\n "}, {"sha": "3001d9f1b1f3f2dd1959abad143bec07519ac2b2", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -187,6 +187,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let (ref infcx, input, var_values) = tcx\n                 .infer_ctxt()\n                 .intercrate(intercrate)\n+                .with_next_trait_solver(true)\n                 .with_opaque_type_inference(canonical_input.value.anchor)\n                 .build_with_canonical(DUMMY_SP, &canonical_input);\n "}, {"sha": "c4481b39e14be6cea8670e13ad66d12ca20ebe45", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -1047,7 +1047,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 // (which may fail).\n                                 span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                             }\n-                            TraitSolver::Chalk | TraitSolver::Next => {\n+                            TraitSolver::Chalk | TraitSolver::Next | TraitSolver::NextCoherence => {\n                                 // FIXME: we'll need a better message which takes into account\n                                 // which bounds actually failed to hold.\n                                 self.tcx.sess.struct_span_err("}, {"sha": "f8ceee50054434034adea9688b9c7b0f1f8e0fd0", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             _ => obligation.param_env.without_const(),\n         };\n \n-        if self.tcx.trait_solver_next() {\n+        if self.next_trait_solver() {\n             self.probe(|snapshot| {\n                 let mut fulfill_cx = crate::solve::FulfillmentCtxt::new();\n                 fulfill_cx.register_predicate_obligation(self, obligation.clone());"}, {"sha": "9d7933e23a8b2de2ccd1a47fdc0897fd5584a15c", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -146,7 +146,7 @@ where\n         infcx: &InferCtxt<'tcx>,\n         span: Span,\n     ) -> Result<TypeOpOutput<'tcx, Self>, ErrorGuaranteed> {\n-        if infcx.tcx.trait_solver_next() {\n+        if infcx.next_trait_solver() {\n             return Ok(scrape_region_constraints(\n                 infcx,\n                 |ocx| QueryTypeOp::perform_locally_in_new_solver(ocx, self),"}, {"sha": "25e5b5e17deff675a9f9f880ea13b0c5af7f5b85", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -539,7 +539,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.evaluation_probe(|this| {\n             let goal =\n                 this.infcx.resolve_vars_if_possible((obligation.predicate, obligation.param_env));\n-            let mut result = if this.tcx().trait_solver_next() {\n+            let mut result = if this.infcx.next_trait_solver() {\n                 this.evaluate_predicates_recursively_in_new_solver([obligation.clone()])?\n             } else {\n                 this.evaluate_predicate_recursively(\n@@ -593,7 +593,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     where\n         I: IntoIterator<Item = PredicateObligation<'tcx>> + std::fmt::Debug,\n     {\n-        if self.tcx().trait_solver_next() {\n+        if self.infcx.next_trait_solver() {\n             self.evaluate_predicates_recursively_in_new_solver(predicates)\n         } else {\n             let mut result = EvaluatedToOk;"}, {"sha": "84746eba3ecf838d351c8856082ad80281193429", "filename": "compiler/rustc_trait_selection/src/traits/structural_normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_normalize.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -21,7 +21,7 @@ impl<'tcx> StructurallyNormalizeExt<'tcx> for At<'_, 'tcx> {\n     ) -> Result<Ty<'tcx>, Vec<FulfillmentError<'tcx>>> {\n         assert!(!ty.is_ty_var(), \"should have resolved vars before calling\");\n \n-        if self.infcx.tcx.trait_solver_next() {\n+        if self.infcx.next_trait_solver() {\n             while let ty::Alias(ty::Projection, projection_ty) = *ty.kind() {\n                 let new_infer_ty = self.infcx.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::NormalizeProjectionType,"}, {"sha": "73756caf37272d3a7185b132d044c0e712f969c3", "filename": "compiler/rustc_traits/src/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0acff796a9221bc4d6769e3db5bf158647ef0e1/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs?ref=e0acff796a9221bc4d6769e3db5bf158647ef0e1", "patch": "@@ -16,7 +16,7 @@ fn evaluate_obligation<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n-    assert!(!tcx.trait_solver_next());\n+    assert!(!tcx.next_trait_solver_globally());\n     debug!(\"evaluate_obligation(canonical_goal={:#?})\", canonical_goal);\n     // HACK This bubble is required for this tests to pass:\n     // impl-trait/issue99642.rs"}]}