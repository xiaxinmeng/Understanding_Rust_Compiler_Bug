{"sha": "48769b57e0f184ff42f5226641447e41cf3053a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NzY5YjU3ZTBmMTg0ZmY0MmY1MjI2NjQxNDQ3ZTQxY2YzMDUzYTc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-08T00:40:07Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-08T23:21:45Z"}, "message": "A bit more WIP on classes, and some cleanup in resolve", "tree": {"sha": "d6434a733e8d66e0754d46f5b8e5c5b8b23d3cff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6434a733e8d66e0754d46f5b8e5c5b8b23d3cff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48769b57e0f184ff42f5226641447e41cf3053a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48769b57e0f184ff42f5226641447e41cf3053a7", "html_url": "https://github.com/rust-lang/rust/commit/48769b57e0f184ff42f5226641447e41cf3053a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48769b57e0f184ff42f5226641447e41cf3053a7/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e680e36a70e94f307928fee1c99b29a28eeba6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e680e36a70e94f307928fee1c99b29a28eeba6e", "html_url": "https://github.com/rust-lang/rust/commit/6e680e36a70e94f307928fee1c99b29a28eeba6e"}], "stats": {"total": 246, "additions": 150, "deletions": 96}, "files": [{"sha": "8a0234fc0c3876f2dd39001235a963c9be90c042", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 131, "deletions": 83, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/48769b57e0f184ff42f5226641447e41cf3053a7/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48769b57e0f184ff42f5226641447e41cf3053a7/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=48769b57e0f184ff42f5226641447e41cf3053a7", "patch": "@@ -2,7 +2,7 @@\n import syntax::{ast, ast_util, codemap};\n import syntax::ast::*;\n import ast::{ident, fn_ident, def, def_id, node_id};\n-import syntax::ast_util::{local_def, def_id_of_def};\n+import syntax::ast_util::{local_def, def_id_of_def, class_item_ident};\n import pat_util::*;\n \n import front::attr;\n@@ -91,6 +91,8 @@ enum mod_index_entry {\n     mie_view_item(ident, node_id, span),\n     mie_import_ident(node_id, span),\n     mie_item(@ast::item),\n+    mie_class_item(node_id, /* parent class name */\n+                   @ast::class_item), /* class member */\n     mie_native_item(@ast::native_item),\n     mie_enum_variant(/* variant index */uint,\n                      /*parts of enum item*/ [variant],\n@@ -267,27 +269,30 @@ fn map_crate(e: @env, c: @ast::crate) {\n         alt vi.node {\n           //if it really is a glob import, that is\n           ast::view_item_import_glob(path, _) {\n-            let imp = follow_import(*e, sc, *path, vi.span);\n-            if option::is_some(imp) {\n-                let glob = {def: option::get(imp), item: vi};\n-                check list::is_not_empty(sc);\n-                alt list::head(sc) {\n-                  scope_item(i) {\n-                    e.mod_map.get(i.id).glob_imports += [glob];\n-                  }\n-                  scope_block(b, _, _) {\n-                    let globs = alt e.block_map.find(b.node.id) {\n-                      some(globs) { globs + [glob] } none { [glob] }\n-                    };\n-                    e.block_map.insert(b.node.id, globs);\n-                  }\n-                  scope_crate {\n-                    e.mod_map.get(ast::crate_node_id).glob_imports += [glob];\n-                  }\n-                  _ { e.sess.span_bug(vi.span, \"Unexpected scope in a glob \\\n-                       import\"); }\n+              alt follow_import(*e, sc, *path, vi.span) {\n+                 some(imp) {\n+                    let glob = {def: imp, item: vi};\n+                    check list::is_not_empty(sc);\n+                    alt list::head(sc) {\n+                      scope_item(i) {\n+                        e.mod_map.get(i.id).glob_imports += [glob];\n+                      }\n+                      scope_block(b, _, _) {\n+                        let globs = alt e.block_map.find(b.node.id) {\n+                                some(globs) { globs + [glob] } none { [glob] }\n+                        };\n+                        e.block_map.insert(b.node.id, globs);\n+                      }\n+                      scope_crate {\n+                        e.mod_map.get(ast::crate_node_id).glob_imports\n+                            += [glob];\n+                      }\n+                      _ { e.sess.span_bug(vi.span, \"Unexpected scope in a \\\n+                           glob import\"); }\n+                      }\n                 }\n-            }\n+                _ { }\n+             }\n           }\n           _ { }\n         }\n@@ -329,7 +334,10 @@ fn resolve_capture_item(e: @env, sc: scopes, &&cap_item: @ast::capture_item) {\n }\n \n fn maybe_insert(e: @env, id: node_id, def: option<def>) {\n-    if option::is_some(def) { e.def_map.insert(id, option::get(def)); }\n+    alt def {\n+       some(df) { e.def_map.insert(id, df); }\n+       _ {}\n+    }\n }\n \n fn resolve_names(e: @env, c: @ast::crate) {\n@@ -401,11 +409,10 @@ fn resolve_names(e: @env, c: @ast::crate) {\n         visit::visit_pat(pat, sc, v);\n         alt pat.node {\n           ast::pat_enum(p, _) {\n-            let fnd = lookup_path_strict(*e, sc, p.span, p.node,\n-                                           ns_val(ns_any_value));\n-            alt option::get(fnd) {\n-              ast::def_variant(did, vid) {\n-                e.def_map.insert(pat.id, option::get(fnd));\n+            alt lookup_path_strict(*e, sc, p.span, p.node,\n+                                           ns_val(ns_any_value)) {\n+              some(fnd@ast::def_variant(_,_)) {\n+                e.def_map.insert(pat.id, fnd);\n               }\n               _ {\n                 e.sess.span_err(p.span,\n@@ -417,11 +424,10 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           /* Here we determine whether a given pat_ident binds a new\n            variable a refers to a nullary enum. */\n           ast::pat_ident(p, none) {\n-              let fnd = lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n-                                    ns_val(ns_a_enum));\n-              alt fnd {\n-                some(ast::def_variant(did, vid)) {\n-                    e.def_map.insert(pat.id, ast::def_variant(did, vid));\n+              alt lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n+                                    ns_val(ns_a_enum)) {\n+                some(fnd@ast::def_variant(_,_)) {\n+                    e.def_map.insert(pat.id, fnd);\n                 }\n                 _ {\n                     // Binds a var -- nothing needs to be done\n@@ -587,16 +593,21 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n     let path_len = vec::len(path);\n     let dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n     let i = 1u;\n-    while true && option::is_some(dcur) {\n-        if i == path_len { break; }\n-        dcur =\n-            lookup_in_mod_strict(e, option::get(dcur), sp, path[i],\n+    while true {\n+       alt dcur {\n+          some(dcur_def) {\n+            if i == path_len { break; }\n+            dcur =\n+                lookup_in_mod_strict(e, dcur_def, sp, path[i],\n                                  ns_module, outside);\n-        i += 1u;\n+            i += 1u;\n+          }\n+          _ { break; }\n+       }\n     }\n     if i == path_len {\n-        alt option::get(dcur) {\n-          ast::def_mod(_) | ast::def_native_mod(_) { ret dcur; }\n+       alt dcur {\n+          some(ast::def_mod(_)) | some(ast::def_native_mod(_)) { ret dcur; }\n           _ {\n             e.sess.span_err(sp, str::connect(path, \"::\") +\n                             \" does not name a module.\");\n@@ -607,20 +618,16 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n }\n \n fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n-    let new_def =\n-        lookup_path_strict(*e, sc, c.span, c.node.path.node,\n-                           ns_val(ns_any_value));\n-    if option::is_some(new_def) {\n-        alt option::get(new_def) {\n-          ast::def_fn(pred_id, ast::pure_fn) {\n-            e.def_map.insert(c.node.id, ast::def_fn(pred_id, ast::pure_fn));\n-          }\n-          _ {\n-            e.sess.span_err(c.span,\n-                            \"Non-predicate in constraint: \" +\n-                                path_to_str(c.node.path));\n-          }\n-        }\n+    alt lookup_path_strict(*e, sc, c.span, c.node.path.node,\n+                           ns_val(ns_any_value)) {\n+       some(d@ast::def_fn(_,ast::pure_fn)) {\n+         e.def_map.insert(c.node.id, d);\n+       }\n+       _ {\n+           e.sess.span_err(c.span,\n+                           \"Non-predicate in constraint: \" +\n+                           path_to_str(c.node.path));\n+       }\n     }\n }\n \n@@ -744,7 +751,7 @@ fn ns_name(ns: namespace) -> str {\n               ns_a_enum    { \"enum\" }\n           }\n       }\n-      ns_module { ret \"modulename\" }\n+      ns_module { \"modulename\" }\n     }\n }\n \n@@ -814,18 +821,26 @@ fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n \n     let first_scope = if pth.global { top_scope() } else { sc };\n \n-    let dcur =\n+    let dcur_ =\n         lookup_in_scope_strict(e, first_scope, sp, pth.idents[0], headns);\n \n-    let i = 1u;\n-    while i < n_idents && option::is_some(dcur) {\n-        let curns = if n_idents == i + 1u { ns } else { ns_module };\n-        dcur =\n-            lookup_in_mod_strict(e, option::get(dcur), sp, pth.idents[i],\n-                                 curns, outside);\n-        i += 1u;\n+    alt dcur_ {\n+      none { ret none; }\n+      some(dcur__) {\n+         let i = 1u;\n+         let dcur = dcur__;\n+         while i < n_idents {\n+            let curns = if n_idents == i + 1u { ns } else { ns_module };\n+            alt lookup_in_mod_strict(e, dcur, sp, pth.idents[i],\n+                                 curns, outside) {\n+               none { break; }\n+               some(thing) { dcur = thing; }\n+            }\n+            i += 1u;\n+         }\n+         ret some(dcur);\n+      }\n     }\n-    ret dcur;\n }\n \n fn lookup_in_scope_strict(e: env, sc: scopes, sp: span, name: ident,\n@@ -985,11 +1000,11 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n         alt copy sc {\n           nil { ret none; }\n           cons(hd, tl) {\n-            let fnd = in_scope(e, sp, name, hd, ns);\n-            if !is_none(fnd) {\n-                let df = option::get(fnd);\n-                let local = def_is_local(df), self_scope = def_is_self(df);\n-                if left_fn && local || left_fn_level2 && self_scope\n+              alt in_scope(e, sp, name, hd, ns) {\n+               some(df_) {\n+                 let df = df_;\n+                 let local = def_is_local(df), self_scope = def_is_self(df);\n+                 if left_fn && local || left_fn_level2 && self_scope\n                    || scope_is_fn(hd) && left_fn && def_is_ty_arg(df) {\n                     let msg = alt ns {\n                       ns_type {\n@@ -1013,12 +1028,13 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                         i -= 1u;\n                         df = ast::def_upvar(def_id_of_def(df), @df,\n                                             closing[i]);\n-                        fnd = some(df);\n                     }\n                 }\n-                ret fnd;\n+                ret some(df);\n             }\n-            if left_fn {\n+                      _ {}\n+                  }\n+             if left_fn {\n                 left_fn_level2 = true;\n             } else if ns != ns_module {\n                 left_fn = scope_is_fn(hd);\n@@ -1193,7 +1209,10 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n           _ { }\n         }\n       }\n-      _ { }\n+      ast::item_class(_, _, _, _, _) {\n+          fail \"class! don't know what to do\";\n+      }\n+      ast::item_impl(_,_,_,_) { /* ??? */ }\n     }\n     ret none;\n }\n@@ -1220,12 +1239,13 @@ fn lookup_in_mod(e: env, m: def, sp: span, name: ident, ns: namespace,\n         if defid.node != ast::crate_node_id {\n             path = cstore::get_path(e.cstore, defid) + path;\n         }\n-        let fnd = lookup_external(e, defid.crate, path, ns);\n-        if !is_none(fnd) {\n-            e.ext_cache.insert({did: defid, ident: name, ns: ns},\n-                               option::get(fnd));\n+        alt lookup_external(e, defid.crate, path, ns) {\n+           some(df) {\n+               e.ext_cache.insert({did: defid, ident: name, ns: ns}, df);\n+               ret some(df);\n+           }\n+           _ { ret none; }\n         }\n-        ret fnd;\n     }\n     alt m {\n       ast::def_mod(defid) {\n@@ -1263,7 +1283,7 @@ fn lookup_import(e: env, defid: def_id, ns: namespace) -> option<def> {\n             e.used_imports.data += [defid.node];\n         }\n         ret alt ns { ns_val(_) { val } ns_type { typ }\n-                     ns_module { md } };\n+            ns_module { md } };\n       }\n       is_glob(_,_,_) {\n           e.sess.bug(\"lookup_import: can't handle is_glob\");\n@@ -1398,6 +1418,18 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n           }\n         }\n       }\n+      mie_class_item(parent_id, class_item) {\n+          alt class_item.node.decl {\n+              instance_var(_,_,_,id) {\n+                  ret some(ast::def_class_field(local_def(parent_id),\n+                                                local_def(id)));\n+              }\n+              class_method(it) {\n+                  ret some(ast::def_class_method(local_def(parent_id),\n+                                                 local_def(it.id)));\n+              }\n+          }\n+      }\n     }\n     ret none;\n }\n@@ -1452,8 +1484,21 @@ fn index_mod(md: ast::_mod) -> mod_index {\n                 variant_idx += 1u;\n             }\n           }\n-          ast::item_class(_, items, _, ctor_decl, _) {\n-              fail \"resolve::index_mod: item_class\";\n+          ast::item_class(tps, items, ctor_id, ctor_decl, ctor_body) {\n+              // add the class name itself\n+              add_to_index(index, it.ident, mie_item(it));\n+              // add the constructor decl\n+              add_to_index(index, it.ident,\n+                           mie_item(@{ident: it.ident, attrs: [],\n+                                       id: ctor_id,\n+                                       node:\n+                                         item_fn(ctor_decl, tps, ctor_body),\n+                                       span: ctor_body.span}));\n+              // add the members\n+              for ci in items {\n+                 add_to_index(index, class_item_ident(ci),\n+                              mie_class_item(it.id, ci));\n+              }\n           }\n         }\n     }\n@@ -1494,11 +1539,13 @@ fn ns_for_def(d: def) -> namespace {\n       ast::def_variant(_, _) { ns_val(ns_a_enum) }\n       ast::def_fn(_, _) | ast::def_self(_) |\n       ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_, _) |\n-      ast::def_upvar(_, _, _) |  ast::def_self(_) { ns_val(ns_any_value) }\n+      ast::def_upvar(_, _, _) |  ast::def_self(_) |\n+      ast::def_class_field(_,_) | ast::def_class_method(_,_)\n+          { ns_val(ns_any_value) }\n       ast::def_mod(_) | ast::def_native_mod(_) { ns_module }\n       ast::def_ty(_) | ast::def_binding(_) | ast::def_use(_) |\n-      ast::def_ty_param(_, _) | ast::def_prim_ty(_) { ns_type }\n-      _ { fail \"Dead\"; }\n+      ast::def_ty_param(_, _) | ast::def_prim_ty(_) | ast::def_class(_)\n+      { ns_type }\n     }\n }\n \n@@ -1583,6 +1630,7 @@ fn mie_span(mie: mod_index_entry) -> span {\n           mie_item(item) { item.span }\n           mie_enum_variant(_, _, _, span) { span }\n           mie_native_item(item) { item.span }\n+          mie_class_item(_,item) { item.span }\n         };\n }\n "}, {"sha": "d0cfb5ee84874849915db0ffb723c0913320765c", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48769b57e0f184ff42f5226641447e41cf3053a7/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48769b57e0f184ff42f5226641447e41cf3053a7/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=48769b57e0f184ff42f5226641447e41cf3053a7", "patch": "@@ -30,9 +30,9 @@ fn def_id_of_def(d: def) -> def_id {\n       def_fn(id, _) | def_self(id) | def_mod(id) |\n       def_native_mod(id) | def_const(id) | def_arg(id, _) | def_local(id, _) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_binding(id) | def_use(id) | def_upvar(id, _, _) { id }\n+      def_binding(id) | def_use(id) | def_upvar(id, _, _) |\n+      def_class(id) | def_class_field(_, id) | def_class_method(_, id) { id }\n       def_prim_ty(_) { fail; }\n-      _ { fail \"Dead\"; }\n     }\n }\n \n@@ -374,6 +374,13 @@ pure fn unguarded_pat(a: arm) -> option<[@pat]> {\n // for reserving this id.\n fn op_expr_callee_id(e: @expr) -> node_id { e.id - 1 }\n \n+pure fn class_item_ident(ci: @class_item) -> ident {\n+    alt ci.node.decl {\n+      instance_var(i,_,_,_) { i }\n+      class_method(it) { it.ident }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "09c9a46e73f693dc8a76376a4e4603d65fd8bd6d", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48769b57e0f184ff42f5226641447e41cf3053a7/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48769b57e0f184ff42f5226641447e41cf3053a7/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=48769b57e0f184ff42f5226641447e41cf3053a7", "patch": "@@ -618,7 +618,7 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n         @{node:\n          {privacy:ci.node.privacy,\n                decl:\n-          alt ci.node.decl {\n+         alt ci.node.decl {\n            instance_var(nm, t, mt, id) {\n                instance_var(nm, f_ty(afp, f, t),\n                                  mt, id)"}, {"sha": "d15c333c5fe24593ca5035481828dcc1fd53d7b8", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/48769b57e0f184ff42f5226641447e41cf3053a7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48769b57e0f184ff42f5226641447e41cf3053a7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=48769b57e0f184ff42f5226641447e41cf3053a7", "patch": "@@ -1580,7 +1580,7 @@ fn parse_let(p: parser) -> @ast::decl {\n     ret @spanned(lo, p.last_span.hi, ast::decl_local(locals));\n }\n \n-fn parse_instance_var(p:parser) -> @ast::class_member {\n+fn parse_instance_var(p:parser) -> ast::class_member {\n     let is_mut = ast::class_immutable;\n     expect_word(p, \"let\");\n     if eat_word(p, \"mutable\") {\n@@ -1592,7 +1592,7 @@ fn parse_instance_var(p:parser) -> @ast::class_member {\n     let name = parse_ident(p);\n     expect(p, token::COLON);\n     let ty = parse_ty(p, false);\n-    ret @ast::instance_var(name, ty, is_mut, p.get_id());\n+    ret ast::instance_var(name, ty, is_mut, p.get_id());\n }\n \n fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n@@ -1973,21 +1973,20 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 the_ctor = some((a_fn_decl, blk));\n             }\n             plain_decl(a_decl) {\n-                items += [@{node: {privacy: ast::pub, decl: *a_decl},\n+                items += [@{node: {privacy: ast::pub, decl: a_decl},\n                             span: p.last_span}];\n             }\n             priv_decls(some_decls) {\n                 items += vec::map(some_decls, {|d|\n-                            @{node: {privacy: ast::priv, decl: *d},\n+                            @{node: {privacy: ast::priv, decl: d},\n                                 span: p.last_span}});\n             }\n        }\n     }\n     p.bump();\n     alt the_ctor {\n        some((ct_d, ct_b)) { ret mk_item(p, lo, p.last_span.hi, class_name,\n-                                 ast::item_class(ty_params, items, ctor_id,\n-                                                 ct_d, ct_b), attrs); }\n+         ast::item_class(ty_params, items, ctor_id, ct_d, ct_b), attrs); }\n        /*\n          Is it strange for the parser to check this?\n        */\n@@ -2000,11 +1999,11 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n // we don't really want just the fn_decl...\n enum class_contents { ctor_decl(ast::fn_decl, ast::blk),\n                       // assumed to be public\n-                      plain_decl(@ast::class_member),\n+                      plain_decl(ast::class_member),\n                       // contents of a priv section --\n                       // parse_class_item ensures that\n                       // none of these are a ctor decl\n-                      priv_decls([@ast::class_member])}\n+                      priv_decls([ast::class_member])}\n \n fn parse_class_item(p:parser) -> class_contents {\n     if eat_word(p, \"new\") {\n@@ -2020,7 +2019,7 @@ fn parse_class_item(p:parser) -> class_contents {\n             while p.token != token::RBRACE {\n                alt parse_item(p, []) {\n                  some(i) {\n-                     results += [@ast::class_method(i)];\n+                     results += [ast::class_method(i)];\n                  }\n                  _ {\n                      let a_var = parse_instance_var(p);\n@@ -2036,7 +2035,7 @@ fn parse_class_item(p:parser) -> class_contents {\n         // Probably need to parse attrs\n         alt parse_item(p, []) {\n          some(i) {\n-             ret plain_decl(@ast::class_method(i));\n+             ret plain_decl(ast::class_method(i));\n          }\n          _ {\n              let a_var = parse_instance_var(p);"}]}