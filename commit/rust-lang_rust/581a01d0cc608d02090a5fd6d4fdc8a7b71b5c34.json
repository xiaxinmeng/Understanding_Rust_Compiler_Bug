{"sha": "581a01d0cc608d02090a5fd6d4fdc8a7b71b5c34", "node_id": "C_kwDOAAsO6NoAKDU4MWEwMWQwY2M2MDhkMDIwOTBhNWZkNmQ0ZmRjOGE3YjcxYjVjMzQ", "commit": {"author": {"name": "DropDemBits", "email": "r3usrlnd@gmail.com", "date": "2022-08-18T17:42:10Z"}, "committer": {"name": "DropDemBits", "email": "r3usrlnd@gmail.com", "date": "2022-08-18T17:42:10Z"}, "message": "Migrate `syntax::make` to use format arg captures", "tree": {"sha": "eed33d56ea850fe2b3691437ac87c5d024b17a23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eed33d56ea850fe2b3691437ac87c5d024b17a23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/581a01d0cc608d02090a5fd6d4fdc8a7b71b5c34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/581a01d0cc608d02090a5fd6d4fdc8a7b71b5c34", "html_url": "https://github.com/rust-lang/rust/commit/581a01d0cc608d02090a5fd6d4fdc8a7b71b5c34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/581a01d0cc608d02090a5fd6d4fdc8a7b71b5c34/comments", "author": {"login": "DropDemBits", "id": 13354275, "node_id": "MDQ6VXNlcjEzMzU0Mjc1", "avatar_url": "https://avatars.githubusercontent.com/u/13354275?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DropDemBits", "html_url": "https://github.com/DropDemBits", "followers_url": "https://api.github.com/users/DropDemBits/followers", "following_url": "https://api.github.com/users/DropDemBits/following{/other_user}", "gists_url": "https://api.github.com/users/DropDemBits/gists{/gist_id}", "starred_url": "https://api.github.com/users/DropDemBits/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DropDemBits/subscriptions", "organizations_url": "https://api.github.com/users/DropDemBits/orgs", "repos_url": "https://api.github.com/users/DropDemBits/repos", "events_url": "https://api.github.com/users/DropDemBits/events{/privacy}", "received_events_url": "https://api.github.com/users/DropDemBits/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DropDemBits", "id": 13354275, "node_id": "MDQ6VXNlcjEzMzU0Mjc1", "avatar_url": "https://avatars.githubusercontent.com/u/13354275?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DropDemBits", "html_url": "https://github.com/DropDemBits", "followers_url": "https://api.github.com/users/DropDemBits/followers", "following_url": "https://api.github.com/users/DropDemBits/following{/other_user}", "gists_url": "https://api.github.com/users/DropDemBits/gists{/gist_id}", "starred_url": "https://api.github.com/users/DropDemBits/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DropDemBits/subscriptions", "organizations_url": "https://api.github.com/users/DropDemBits/orgs", "repos_url": "https://api.github.com/users/DropDemBits/repos", "events_url": "https://api.github.com/users/DropDemBits/events{/privacy}", "received_events_url": "https://api.github.com/users/DropDemBits/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82ff740501e1da239a6c9ff94dddf7ae1ca9aeb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/82ff740501e1da239a6c9ff94dddf7ae1ca9aeb6", "html_url": "https://github.com/rust-lang/rust/commit/82ff740501e1da239a6c9ff94dddf7ae1ca9aeb6"}], "stats": {"total": 263, "additions": 132, "deletions": 131}, "files": [{"sha": "83f8bbac5880bfd5fa542f03e90af2110039d169", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 132, "deletions": 131, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/581a01d0cc608d02090a5fd6d4fdc8a7b71b5c34/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/581a01d0cc608d02090a5fd6d4fdc8a7b71b5c34/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=581a01d0cc608d02090a5fd6d4fdc8a7b71b5c34", "patch": "@@ -25,7 +25,7 @@ pub mod ext {\n         return from_text(&name.text());\n \n         fn from_text(text: &str) -> ast::IdentPat {\n-            ast_from_text(&format!(\"fn f({}: ())\", text))\n+            ast_from_text(&format!(\"fn f({text}: ())\"))\n         }\n     }\n     pub fn ident_path(ident: &str) -> ast::Path {\n@@ -60,10 +60,10 @@ pub mod ext {\n         expr_from_text(\"todo!()\")\n     }\n     pub fn expr_ty_default(ty: &ast::Type) -> ast::Expr {\n-        expr_from_text(&format!(\"{}::default()\", ty))\n+        expr_from_text(&format!(\"{ty}::default()\"))\n     }\n     pub fn expr_ty_new(ty: &ast::Type) -> ast::Expr {\n-        expr_from_text(&format!(\"{}::new()\", ty))\n+        expr_from_text(&format!(\"{ty}::new()\"))\n     }\n \n     pub fn zero_number() -> ast::Expr {\n@@ -92,18 +92,20 @@ pub mod ext {\n         ty_path(ident_path(\"bool\"))\n     }\n     pub fn ty_option(t: ast::Type) -> ast::Type {\n-        ty_from_text(&format!(\"Option<{}>\", t))\n+        ty_from_text(&format!(\"Option<{t}>\"))\n     }\n     pub fn ty_result(t: ast::Type, e: ast::Type) -> ast::Type {\n-        ty_from_text(&format!(\"Result<{}, {}>\", t, e))\n+        ty_from_text(&format!(\"Result<{t}, {e}>\"))\n     }\n }\n \n-pub fn name(text: &str) -> ast::Name {\n-    ast_from_text(&format!(\"mod {}{};\", raw_ident_esc(text), text))\n+pub fn name(name: &str) -> ast::Name {\n+    let raw_escape = raw_ident_esc(name);\n+    ast_from_text(&format!(\"mod {raw_escape}{name};\"))\n }\n-pub fn name_ref(text: &str) -> ast::NameRef {\n-    ast_from_text(&format!(\"fn f() {{ {}{}; }}\", raw_ident_esc(text), text))\n+pub fn name_ref(name_ref: &str) -> ast::NameRef {\n+    let raw_escape = raw_ident_esc(name_ref);\n+    ast_from_text(&format!(\"fn f() {{ {raw_escape}{name_ref}; }}\"))\n }\n fn raw_ident_esc(ident: &str) -> &'static str {\n     let is_keyword = parser::SyntaxKind::from_keyword(ident).is_some();\n@@ -118,10 +120,10 @@ pub fn lifetime(text: &str) -> ast::Lifetime {\n     let mut text = text;\n     let tmp;\n     if never!(!text.starts_with('\\'')) {\n-        tmp = format!(\"'{}\", text);\n+        tmp = format!(\"'{text}\");\n         text = &tmp;\n     }\n-    ast_from_text(&format!(\"fn f<{}>() {{ }}\", text))\n+    ast_from_text(&format!(\"fn f<{text}>() {{ }}\"))\n }\n \n // FIXME: replace stringly-typed constructor with a family of typed ctors, a-la\n@@ -142,16 +144,16 @@ pub fn ty_tuple(types: impl IntoIterator<Item = ast::Type>) -> ast::Type {\n         contents.push(',');\n     }\n \n-    ty_from_text(&format!(\"({})\", contents))\n+    ty_from_text(&format!(\"({contents})\"))\n }\n pub fn ty_ref(target: ast::Type, exclusive: bool) -> ast::Type {\n-    ty_from_text(&if exclusive { format!(\"&mut {}\", target) } else { format!(\"&{}\", target) })\n+    ty_from_text(&if exclusive { format!(\"&mut {target}\") } else { format!(\"&{target}\") })\n }\n pub fn ty_path(path: ast::Path) -> ast::Type {\n     ty_from_text(&path.to_string())\n }\n fn ty_from_text(text: &str) -> ast::Type {\n-    ast_from_text(&format!(\"type _T = {};\", text))\n+    ast_from_text(&format!(\"type _T = {text};\"))\n }\n \n pub fn assoc_item_list() -> ast::AssocItemList {\n@@ -171,7 +173,7 @@ pub fn impl_(\n         Some(params) => params.to_string(),\n         None => String::new(),\n     };\n-    ast_from_text(&format!(\"impl{} {}{} {{}}\", params, ty, ty_params))\n+    ast_from_text(&format!(\"impl{params} {ty}{ty_params} {{}}\"))\n }\n \n pub fn impl_trait(\n@@ -180,21 +182,21 @@ pub fn impl_trait(\n     ty_params: Option<ast::GenericParamList>,\n ) -> ast::Impl {\n     let ty_params = ty_params.map_or_else(String::new, |params| params.to_string());\n-    ast_from_text(&format!(\"impl{2} {} for {}{2} {{}}\", trait_, ty, ty_params))\n+    ast_from_text(&format!(\"impl{ty_params} {trait_} for {ty}{ty_params} {{}}\"))\n }\n \n pub(crate) fn generic_arg_list() -> ast::GenericArgList {\n     ast_from_text(\"const S: T<> = ();\")\n }\n \n pub fn path_segment(name_ref: ast::NameRef) -> ast::PathSegment {\n-    ast_from_text(&format!(\"type __ = {};\", name_ref))\n+    ast_from_text(&format!(\"type __ = {name_ref};\"))\n }\n \n pub fn path_segment_ty(type_ref: ast::Type, trait_ref: Option<ast::PathType>) -> ast::PathSegment {\n     let text = match trait_ref {\n-        Some(trait_ref) => format!(\"fn f(x: <{} as {}>) {{}}\", type_ref, trait_ref),\n-        None => format!(\"fn f(x: <{}>) {{}}\", type_ref),\n+        Some(trait_ref) => format!(\"fn f(x: <{type_ref} as {trait_ref}>) {{}}\"),\n+        None => format!(\"fn f(x: <{type_ref}>) {{}}\"),\n     };\n     ast_from_text(&text)\n }\n@@ -212,15 +214,15 @@ pub fn path_segment_crate() -> ast::PathSegment {\n }\n \n pub fn path_unqualified(segment: ast::PathSegment) -> ast::Path {\n-    ast_from_text(&format!(\"type __ = {};\", segment))\n+    ast_from_text(&format!(\"type __ = {segment};\"))\n }\n \n pub fn path_qualified(qual: ast::Path, segment: ast::PathSegment) -> ast::Path {\n-    ast_from_text(&format!(\"{}::{}\", qual, segment))\n+    ast_from_text(&format!(\"{qual}::{segment}\"))\n }\n // FIXME: path concatenation operation doesn't make sense as AST op.\n pub fn path_concat(first: ast::Path, second: ast::Path) -> ast::Path {\n-    ast_from_text(&format!(\"type __ = {}::{};\", first, second))\n+    ast_from_text(&format!(\"type __ = {first}::{second};\"))\n }\n \n pub fn path_from_segments(\n@@ -229,20 +231,20 @@ pub fn path_from_segments(\n ) -> ast::Path {\n     let segments = segments.into_iter().map(|it| it.syntax().clone()).join(\"::\");\n     ast_from_text(&if is_abs {\n-        format!(\"fn f(x: ::{}) {{}}\", segments)\n+        format!(\"fn f(x: ::{segments}) {{}}\")\n     } else {\n-        format!(\"fn f(x: {}) {{}}\", segments)\n+        format!(\"fn f(x: {segments}) {{}}\")\n     })\n }\n \n pub fn join_paths(paths: impl IntoIterator<Item = ast::Path>) -> ast::Path {\n     let paths = paths.into_iter().map(|it| it.syntax().clone()).join(\"::\");\n-    ast_from_text(&format!(\"type __ = {};\", paths))\n+    ast_from_text(&format!(\"type __ = {paths};\"))\n }\n \n // FIXME: should not be pub\n pub fn path_from_text(text: &str) -> ast::Path {\n-    ast_from_text(&format!(\"fn main() {{ let test = {}; }}\", text))\n+    ast_from_text(&format!(\"fn main() {{ let test = {text}; }}\"))\n }\n \n pub fn use_tree_glob() -> ast::UseTree {\n@@ -257,50 +259,50 @@ pub fn use_tree(\n     let mut buf = \"use \".to_string();\n     buf += &path.syntax().to_string();\n     if let Some(use_tree_list) = use_tree_list {\n-        format_to!(buf, \"::{}\", use_tree_list);\n+        format_to!(buf, \"::{use_tree_list}\");\n     }\n     if add_star {\n         buf += \"::*\";\n     }\n \n     if let Some(alias) = alias {\n-        format_to!(buf, \" {}\", alias);\n+        format_to!(buf, \" {alias}\");\n     }\n     ast_from_text(&buf)\n }\n \n pub fn use_tree_list(use_trees: impl IntoIterator<Item = ast::UseTree>) -> ast::UseTreeList {\n     let use_trees = use_trees.into_iter().map(|it| it.syntax().clone()).join(\", \");\n-    ast_from_text(&format!(\"use {{{}}};\", use_trees))\n+    ast_from_text(&format!(\"use {{{use_trees}}};\"))\n }\n \n pub fn use_(visibility: Option<ast::Visibility>, use_tree: ast::UseTree) -> ast::Use {\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n-    ast_from_text(&format!(\"{}use {};\", visibility, use_tree))\n+    ast_from_text(&format!(\"{visibility}use {use_tree};\"))\n }\n \n pub fn record_expr(path: ast::Path, fields: ast::RecordExprFieldList) -> ast::RecordExpr {\n-    ast_from_text(&format!(\"fn f() {{ {} {} }}\", path, fields))\n+    ast_from_text(&format!(\"fn f() {{ {path} {fields} }}\"))\n }\n \n pub fn record_expr_field_list(\n     fields: impl IntoIterator<Item = ast::RecordExprField>,\n ) -> ast::RecordExprFieldList {\n     let fields = fields.into_iter().join(\", \");\n-    ast_from_text(&format!(\"fn f() {{ S {{ {} }} }}\", fields))\n+    ast_from_text(&format!(\"fn f() {{ S {{ {fields} }} }}\"))\n }\n \n pub fn record_expr_field(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordExprField {\n     return match expr {\n-        Some(expr) => from_text(&format!(\"{}: {}\", name, expr)),\n+        Some(expr) => from_text(&format!(\"{name}: {expr}\")),\n         None => from_text(&name.to_string()),\n     };\n \n     fn from_text(text: &str) -> ast::RecordExprField {\n-        ast_from_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ S {{ {text}, }} }}\"))\n     }\n }\n \n@@ -311,9 +313,9 @@ pub fn record_field(\n ) -> ast::RecordField {\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n-    ast_from_text(&format!(\"struct S {{ {}{}: {}, }}\", visibility, name, ty))\n+    ast_from_text(&format!(\"struct S {{ {visibility}{name}: {ty}, }}\"))\n }\n \n // TODO\n@@ -323,13 +325,13 @@ pub fn block_expr(\n ) -> ast::BlockExpr {\n     let mut buf = \"{\\n\".to_string();\n     for stmt in stmts.into_iter() {\n-        format_to!(buf, \"    {}\\n\", stmt);\n+        format_to!(buf, \"    {stmt}\\n\");\n     }\n     if let Some(tail_expr) = tail_expr {\n-        format_to!(buf, \"    {}\\n\", tail_expr);\n+        format_to!(buf, \"    {tail_expr}\\n\");\n     }\n     buf += \"}\";\n-    ast_from_text(&format!(\"fn f() {}\", buf))\n+    ast_from_text(&format!(\"fn f() {buf}\"))\n }\n \n /// Ideally this function wouldn't exist since it involves manual indenting.\n@@ -343,26 +345,26 @@ pub fn hacky_block_expr_with_comments(\n     let mut buf = \"{\\n\".to_string();\n     for node_or_token in elements.into_iter() {\n         match node_or_token {\n-            rowan::NodeOrToken::Node(n) => format_to!(buf, \"    {}\\n\", n),\n+            rowan::NodeOrToken::Node(n) => format_to!(buf, \"    {n}\\n\"),\n             rowan::NodeOrToken::Token(t) if t.kind() == SyntaxKind::COMMENT => {\n-                format_to!(buf, \"    {}\\n\", t)\n+                format_to!(buf, \"    {t}\\n\")\n             }\n             _ => (),\n         }\n     }\n     if let Some(tail_expr) = tail_expr {\n-        format_to!(buf, \"    {}\\n\", tail_expr);\n+        format_to!(buf, \"    {tail_expr}\\n\");\n     }\n     buf += \"}\";\n-    ast_from_text(&format!(\"fn f() {}\", buf))\n+    ast_from_text(&format!(\"fn f() {buf}\"))\n }\n \n pub fn expr_unit() -> ast::Expr {\n     expr_from_text(\"()\")\n }\n pub fn expr_literal(text: &str) -> ast::Literal {\n     assert_eq!(text.trim(), text);\n-    ast_from_text(&format!(\"fn f() {{ let _ = {}; }}\", text))\n+    ast_from_text(&format!(\"fn f() {{ let _ = {text}; }}\"))\n }\n \n pub fn expr_empty_block() -> ast::Expr {\n@@ -373,108 +375,109 @@ pub fn expr_path(path: ast::Path) -> ast::Expr {\n }\n pub fn expr_continue(label: Option<ast::Lifetime>) -> ast::Expr {\n     match label {\n-        Some(label) => expr_from_text(&format!(\"continue {}\", label)),\n+        Some(label) => expr_from_text(&format!(\"continue {label}\")),\n         None => expr_from_text(\"continue\"),\n     }\n }\n // Consider `op: SyntaxKind` instead for nicer syntax at the call-site?\n pub fn expr_bin_op(lhs: ast::Expr, op: ast::BinaryOp, rhs: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"{} {} {}\", lhs, op, rhs))\n+    expr_from_text(&format!(\"{lhs} {op} {rhs}\"))\n }\n pub fn expr_break(label: Option<ast::Lifetime>, expr: Option<ast::Expr>) -> ast::Expr {\n     let mut s = String::from(\"break\");\n \n     if let Some(label) = label {\n-        format_to!(s, \" {}\", label);\n+        format_to!(s, \" {label}\");\n     }\n \n     if let Some(expr) = expr {\n-        format_to!(s, \" {}\", expr);\n+        format_to!(s, \" {expr}\");\n     }\n \n     expr_from_text(&s)\n }\n pub fn expr_return(expr: Option<ast::Expr>) -> ast::Expr {\n     match expr {\n-        Some(expr) => expr_from_text(&format!(\"return {}\", expr)),\n+        Some(expr) => expr_from_text(&format!(\"return {expr}\")),\n         None => expr_from_text(\"return\"),\n     }\n }\n pub fn expr_try(expr: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"{}?\", expr))\n+    expr_from_text(&format!(\"{expr}?\"))\n }\n pub fn expr_await(expr: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"{}.await\", expr))\n+    expr_from_text(&format!(\"{expr}.await\"))\n }\n pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n-    expr_from_text(&format!(\"match {} {}\", expr, match_arm_list))\n+    expr_from_text(&format!(\"match {expr} {match_arm_list}\"))\n }\n pub fn expr_if(\n     condition: ast::Expr,\n     then_branch: ast::BlockExpr,\n     else_branch: Option<ast::ElseBranch>,\n ) -> ast::Expr {\n     let else_branch = match else_branch {\n-        Some(ast::ElseBranch::Block(block)) => format!(\"else {}\", block),\n-        Some(ast::ElseBranch::IfExpr(if_expr)) => format!(\"else {}\", if_expr),\n+        Some(ast::ElseBranch::Block(block)) => format!(\"else {block}\"),\n+        Some(ast::ElseBranch::IfExpr(if_expr)) => format!(\"else {if_expr}\"),\n         None => String::new(),\n     };\n-    expr_from_text(&format!(\"if {} {} {}\", condition, then_branch, else_branch))\n+    expr_from_text(&format!(\"if {condition} {then_branch} {else_branch}\"))\n }\n pub fn expr_for_loop(pat: ast::Pat, expr: ast::Expr, block: ast::BlockExpr) -> ast::Expr {\n-    expr_from_text(&format!(\"for {} in {} {}\", pat, expr, block))\n+    expr_from_text(&format!(\"for {pat} in {expr} {block}\"))\n }\n \n pub fn expr_loop(block: ast::BlockExpr) -> ast::Expr {\n-    expr_from_text(&format!(\"loop {}\", block))\n+    expr_from_text(&format!(\"loop {block}\"))\n }\n \n pub fn expr_prefix(op: SyntaxKind, expr: ast::Expr) -> ast::Expr {\n     let token = token(op);\n-    expr_from_text(&format!(\"{}{}\", token, expr))\n+    expr_from_text(&format!(\"{token}{expr}\"))\n }\n pub fn expr_call(f: ast::Expr, arg_list: ast::ArgList) -> ast::Expr {\n-    expr_from_text(&format!(\"{}{}\", f, arg_list))\n+    expr_from_text(&format!(\"{f}{arg_list}\"))\n }\n pub fn expr_method_call(\n     receiver: ast::Expr,\n     method: ast::NameRef,\n     arg_list: ast::ArgList,\n ) -> ast::Expr {\n-    expr_from_text(&format!(\"{}.{}{}\", receiver, method, arg_list))\n+    expr_from_text(&format!(\"{receiver}.{method}{arg_list}\"))\n }\n pub fn expr_macro_call(f: ast::Expr, arg_list: ast::ArgList) -> ast::Expr {\n-    expr_from_text(&format!(\"{}!{}\", f, arg_list))\n+    expr_from_text(&format!(\"{f}!{arg_list}\"))\n }\n pub fn expr_ref(expr: ast::Expr, exclusive: bool) -> ast::Expr {\n-    expr_from_text(&if exclusive { format!(\"&mut {}\", expr) } else { format!(\"&{}\", expr) })\n+    expr_from_text(&if exclusive { format!(\"&mut {expr}\") } else { format!(\"&{expr}\") })\n }\n pub fn expr_closure(pats: impl IntoIterator<Item = ast::Param>, expr: ast::Expr) -> ast::Expr {\n     let params = pats.into_iter().join(\", \");\n-    expr_from_text(&format!(\"|{}| {}\", params, expr))\n+    expr_from_text(&format!(\"|{params}| {expr}\"))\n }\n pub fn expr_field(receiver: ast::Expr, field: &str) -> ast::Expr {\n-    expr_from_text(&format!(\"{}.{}\", receiver, field))\n+    expr_from_text(&format!(\"{receiver}.{field}\"))\n }\n pub fn expr_paren(expr: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"({})\", expr))\n+    expr_from_text(&format!(\"({expr})\"))\n }\n pub fn expr_tuple(elements: impl IntoIterator<Item = ast::Expr>) -> ast::Expr {\n     let expr = elements.into_iter().format(\", \");\n-    expr_from_text(&format!(\"({})\", expr))\n+    expr_from_text(&format!(\"({expr})\"))\n }\n pub fn expr_assignment(lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"{} = {}\", lhs, rhs))\n+    expr_from_text(&format!(\"{lhs} = {rhs}\"))\n }\n fn expr_from_text(text: &str) -> ast::Expr {\n-    ast_from_text(&format!(\"const C: () = {};\", text))\n+    ast_from_text(&format!(\"const C: () = {text};\"))\n }\n pub fn expr_let(pattern: ast::Pat, expr: ast::Expr) -> ast::LetExpr {\n-    ast_from_text(&format!(\"const _: () = while let {} = {} {{}};\", pattern, expr))\n+    ast_from_text(&format!(\"const _: () = while let {pattern} = {expr} {{}};\"))\n }\n \n pub fn arg_list(args: impl IntoIterator<Item = ast::Expr>) -> ast::ArgList {\n-    ast_from_text(&format!(\"fn main() {{ ()({}) }}\", args.into_iter().format(\", \")))\n+    let args = args.into_iter().format(\", \");\n+    ast_from_text(&format!(\"fn main() {{ ()({args}) }}\"))\n }\n \n pub fn ident_pat(ref_: bool, mut_: bool, name: ast::Name) -> ast::IdentPat {\n@@ -485,7 +488,7 @@ pub fn ident_pat(ref_: bool, mut_: bool, name: ast::Name) -> ast::IdentPat {\n     if mut_ {\n         s.push_str(\"mut \");\n     }\n-    format_to!(s, \"{}\", name);\n+    format_to!(s, \"{name}\");\n     s.push_str(\": ())\");\n     ast_from_text(&s)\n }\n@@ -494,15 +497,15 @@ pub fn wildcard_pat() -> ast::WildcardPat {\n     return from_text(\"_\");\n \n     fn from_text(text: &str) -> ast::WildcardPat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n pub fn literal_pat(lit: &str) -> ast::LiteralPat {\n     return from_text(lit);\n \n     fn from_text(text: &str) -> ast::LiteralPat {\n-        ast_from_text(&format!(\"fn f() {{ match x {{ {} => {{}} }} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ match x {{ {text} => {{}} }} }}\"))\n     }\n }\n \n@@ -515,10 +518,10 @@ pub fn tuple_pat(pats: impl IntoIterator<Item = ast::Pat>) -> ast::TuplePat {\n     if count == 1 {\n         pats_str.push(',');\n     }\n-    return from_text(&format!(\"({})\", pats_str));\n+    return from_text(&format!(\"({pats_str})\"));\n \n     fn from_text(text: &str) -> ast::TuplePat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n@@ -527,46 +530,46 @@ pub fn tuple_struct_pat(\n     pats: impl IntoIterator<Item = ast::Pat>,\n ) -> ast::TupleStructPat {\n     let pats_str = pats.into_iter().join(\", \");\n-    return from_text(&format!(\"{}({})\", path, pats_str));\n+    return from_text(&format!(\"{path}({pats_str})\"));\n \n     fn from_text(text: &str) -> ast::TupleStructPat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n pub fn record_pat(path: ast::Path, pats: impl IntoIterator<Item = ast::Pat>) -> ast::RecordPat {\n     let pats_str = pats.into_iter().join(\", \");\n-    return from_text(&format!(\"{} {{ {} }}\", path, pats_str));\n+    return from_text(&format!(\"{path} {{ {pats_str} }}\"));\n \n     fn from_text(text: &str) -> ast::RecordPat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n pub fn record_pat_with_fields(path: ast::Path, fields: ast::RecordPatFieldList) -> ast::RecordPat {\n-    ast_from_text(&format!(\"fn f({} {}: ()))\", path, fields))\n+    ast_from_text(&format!(\"fn f({path} {fields}: ()))\"))\n }\n \n pub fn record_pat_field_list(\n     fields: impl IntoIterator<Item = ast::RecordPatField>,\n ) -> ast::RecordPatFieldList {\n     let fields = fields.into_iter().join(\", \");\n-    ast_from_text(&format!(\"fn f(S {{ {} }}: ()))\", fields))\n+    ast_from_text(&format!(\"fn f(S {{ {fields} }}: ()))\"))\n }\n \n pub fn record_pat_field(name_ref: ast::NameRef, pat: ast::Pat) -> ast::RecordPatField {\n-    ast_from_text(&format!(\"fn f(S {{ {}: {} }}: ()))\", name_ref, pat))\n+    ast_from_text(&format!(\"fn f(S {{ {name_ref}: {pat} }}: ()))\"))\n }\n \n pub fn record_pat_field_shorthand(name_ref: ast::NameRef) -> ast::RecordPatField {\n-    ast_from_text(&format!(\"fn f(S {{ {} }}: ()))\", name_ref))\n+    ast_from_text(&format!(\"fn f(S {{ {name_ref} }}: ()))\"))\n }\n \n /// Returns a `BindPat` if the path has just one segment, a `PathPat` otherwise.\n pub fn path_pat(path: ast::Path) -> ast::Pat {\n     return from_text(&path.to_string());\n     fn from_text(text: &str) -> ast::Pat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n@@ -577,12 +580,12 @@ pub fn match_arm(\n ) -> ast::MatchArm {\n     let pats_str = pats.into_iter().join(\" | \");\n     return match guard {\n-        Some(guard) => from_text(&format!(\"{} if {} => {}\", pats_str, guard, expr)),\n-        None => from_text(&format!(\"{} => {}\", pats_str, expr)),\n+        Some(guard) => from_text(&format!(\"{pats_str} if {guard} => {expr}\")),\n+        None => from_text(&format!(\"{pats_str} => {expr}\")),\n     };\n \n     fn from_text(text: &str) -> ast::MatchArm {\n-        ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ match () {{{text}}} }}\"))\n     }\n }\n \n@@ -592,10 +595,10 @@ pub fn match_arm_with_guard(\n     expr: ast::Expr,\n ) -> ast::MatchArm {\n     let pats_str = pats.into_iter().join(\" | \");\n-    return from_text(&format!(\"{} if {} => {}\", pats_str, guard, expr));\n+    return from_text(&format!(\"{pats_str} if {guard} => {expr}\"));\n \n     fn from_text(text: &str) -> ast::MatchArm {\n-        ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ match () {{{text}}} }}\"))\n     }\n }\n \n@@ -605,13 +608,14 @@ pub fn match_arm_list(arms: impl IntoIterator<Item = ast::MatchArm>) -> ast::Mat\n         .map(|arm| {\n             let needs_comma = arm.expr().map_or(true, |it| !it.is_block_like());\n             let comma = if needs_comma { \",\" } else { \"\" };\n-            format!(\"    {}{}\\n\", arm.syntax(), comma)\n+            let arm = arm.syntax();\n+            format!(\"    {arm}{comma}\\n\")\n         })\n         .collect::<String>();\n     return from_text(&arms_str);\n \n     fn from_text(text: &str) -> ast::MatchArmList {\n-        ast_from_text(&format!(\"fn f() {{ match () {{\\n{}}} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ match () {{\\n{text}}} }}\"))\n     }\n }\n \n@@ -620,10 +624,10 @@ pub fn where_pred(\n     bounds: impl IntoIterator<Item = ast::TypeBound>,\n ) -> ast::WherePred {\n     let bounds = bounds.into_iter().join(\" + \");\n-    return from_text(&format!(\"{}: {}\", path, bounds));\n+    return from_text(&format!(\"{path}: {bounds}\"));\n \n     fn from_text(text: &str) -> ast::WherePred {\n-        ast_from_text(&format!(\"fn f() where {} {{ }}\", text))\n+        ast_from_text(&format!(\"fn f() where {text} {{ }}\"))\n     }\n }\n \n@@ -632,7 +636,7 @@ pub fn where_clause(preds: impl IntoIterator<Item = ast::WherePred>) -> ast::Whe\n     return from_text(preds.as_str());\n \n     fn from_text(text: &str) -> ast::WhereClause {\n-        ast_from_text(&format!(\"fn f() where {} {{ }}\", text))\n+        ast_from_text(&format!(\"fn f() where {text} {{ }}\"))\n     }\n }\n \n@@ -642,19 +646,19 @@ pub fn let_stmt(\n     initializer: Option<ast::Expr>,\n ) -> ast::LetStmt {\n     let mut text = String::new();\n-    format_to!(text, \"let {}\", pattern);\n+    format_to!(text, \"let {pattern}\");\n     if let Some(ty) = ty {\n-        format_to!(text, \": {}\", ty);\n+        format_to!(text, \": {ty}\");\n     }\n     match initializer {\n-        Some(it) => format_to!(text, \" = {};\", it),\n+        Some(it) => format_to!(text, \" = {it};\"),\n         None => format_to!(text, \";\"),\n     };\n-    ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n+    ast_from_text(&format!(\"fn f() {{ {text} }}\"))\n }\n pub fn expr_stmt(expr: ast::Expr) -> ast::ExprStmt {\n     let semi = if expr.is_block_like() { \"\" } else { \";\" };\n-    ast_from_text(&format!(\"fn f() {{ {}{} (); }}\", expr, semi))\n+    ast_from_text(&format!(\"fn f() {{ {expr}{semi} (); }}\"))\n }\n \n pub fn item_const(\n@@ -665,21 +669,21 @@ pub fn item_const(\n ) -> ast::Const {\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n-    ast_from_text(&format!(\"{} const {}: {} = {};\", visibility, name, ty, expr))\n+    ast_from_text(&format!(\"{visibility} const {name}: {ty} = {expr};\"))\n }\n \n pub fn param(pat: ast::Pat, ty: ast::Type) -> ast::Param {\n-    ast_from_text(&format!(\"fn f({}: {}) {{ }}\", pat, ty))\n+    ast_from_text(&format!(\"fn f({pat}: {ty}) {{ }}\"))\n }\n \n pub fn self_param() -> ast::SelfParam {\n     ast_from_text(\"fn f(&self) { }\")\n }\n \n pub fn ret_type(ty: ast::Type) -> ast::RetType {\n-    ast_from_text(&format!(\"fn f() -> {} {{ }}\", ty))\n+    ast_from_text(&format!(\"fn f() -> {ty} {{ }}\"))\n }\n \n pub fn param_list(\n@@ -688,30 +692,30 @@ pub fn param_list(\n ) -> ast::ParamList {\n     let args = pats.into_iter().join(\", \");\n     let list = match self_param {\n-        Some(self_param) if args.is_empty() => format!(\"fn f({}) {{ }}\", self_param),\n-        Some(self_param) => format!(\"fn f({}, {}) {{ }}\", self_param, args),\n-        None => format!(\"fn f({}) {{ }}\", args),\n+        Some(self_param) if args.is_empty() => format!(\"fn f({self_param}) {{ }}\"),\n+        Some(self_param) => format!(\"fn f({self_param}, {args}) {{ }}\"),\n+        None => format!(\"fn f({args}) {{ }}\"),\n     };\n     ast_from_text(&list)\n }\n \n pub fn type_param(name: ast::Name, ty: Option<ast::TypeBoundList>) -> ast::TypeParam {\n     let bound = match ty {\n-        Some(it) => format!(\": {}\", it),\n+        Some(it) => format!(\": {it}\"),\n         None => String::new(),\n     };\n-    ast_from_text(&format!(\"fn f<{}{}>() {{ }}\", name, bound))\n+    ast_from_text(&format!(\"fn f<{name}{bound}>() {{ }}\"))\n }\n \n pub fn lifetime_param(lifetime: ast::Lifetime) -> ast::LifetimeParam {\n-    ast_from_text(&format!(\"fn f<{}>() {{ }}\", lifetime))\n+    ast_from_text(&format!(\"fn f<{lifetime}>() {{ }}\"))\n }\n \n pub fn generic_param_list(\n     pats: impl IntoIterator<Item = ast::GenericParam>,\n ) -> ast::GenericParamList {\n     let args = pats.into_iter().join(\", \");\n-    ast_from_text(&format!(\"fn f<{}>() {{ }}\", args))\n+    ast_from_text(&format!(\"fn f<{args}>() {{ }}\"))\n }\n \n pub fn visibility_pub_crate() -> ast::Visibility {\n@@ -724,33 +728,33 @@ pub fn visibility_pub() -> ast::Visibility {\n \n pub fn tuple_field_list(fields: impl IntoIterator<Item = ast::TupleField>) -> ast::TupleFieldList {\n     let fields = fields.into_iter().join(\", \");\n-    ast_from_text(&format!(\"struct f({});\", fields))\n+    ast_from_text(&format!(\"struct f({fields});\"))\n }\n \n pub fn record_field_list(\n     fields: impl IntoIterator<Item = ast::RecordField>,\n ) -> ast::RecordFieldList {\n     let fields = fields.into_iter().join(\", \");\n-    ast_from_text(&format!(\"struct f {{ {} }}\", fields))\n+    ast_from_text(&format!(\"struct f {{ {fields} }}\"))\n }\n \n pub fn tuple_field(visibility: Option<ast::Visibility>, ty: ast::Type) -> ast::TupleField {\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n-    ast_from_text(&format!(\"struct f({}{});\", visibility, ty))\n+    ast_from_text(&format!(\"struct f({visibility}{ty});\"))\n }\n \n pub fn variant(name: ast::Name, field_list: Option<ast::FieldList>) -> ast::Variant {\n     let field_list = match field_list {\n         None => String::new(),\n         Some(it) => match it {\n-            ast::FieldList::RecordFieldList(record) => format!(\" {}\", record),\n-            ast::FieldList::TupleFieldList(tuple) => format!(\"{}\", tuple),\n+            ast::FieldList::RecordFieldList(record) => format!(\" {record}\"),\n+            ast::FieldList::TupleFieldList(tuple) => format!(\"{tuple}\"),\n         },\n     };\n-    ast_from_text(&format!(\"enum f {{ {}{} }}\", name, field_list))\n+    ast_from_text(&format!(\"enum f {{ {name}{field_list} }}\"))\n }\n \n pub fn fn_(\n@@ -763,23 +767,22 @@ pub fn fn_(\n     is_async: bool,\n ) -> ast::Fn {\n     let type_params = match type_params {\n-        Some(type_params) => format!(\"{}\", type_params),\n+        Some(type_params) => format!(\"{type_params}\"),\n         None => \"\".into(),\n     };\n     let ret_type = match ret_type {\n-        Some(ret_type) => format!(\"{} \", ret_type),\n+        Some(ret_type) => format!(\"{ret_type} \"),\n         None => \"\".into(),\n     };\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n \n     let async_literal = if is_async { \"async \" } else { \"\" };\n \n     ast_from_text(&format!(\n-        \"{}{}fn {}{}{} {}{}\",\n-        visibility, async_literal, fn_name, type_params, params, ret_type, body\n+        \"{visibility}{async_literal}fn {fn_name}{type_params}{params} {ret_type}{body}\",\n     ))\n }\n \n@@ -793,13 +796,10 @@ pub fn struct_(\n     let type_params = generic_param_list.map_or_else(String::new, |it| it.to_string());\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n \n-    ast_from_text(&format!(\n-        \"{}struct {}{}{}{}\",\n-        visibility, strukt_name, type_params, field_list, semicolon\n-    ))\n+    ast_from_text(&format!(\"{visibility}struct {strukt_name}{type_params}{field_list}{semicolon}\",))\n }\n \n #[track_caller]\n@@ -808,7 +808,8 @@ fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let node = match parse.tree().syntax().descendants().find_map(N::cast) {\n         Some(it) => it,\n         None => {\n-            panic!(\"Failed to make ast node `{}` from text {}\", std::any::type_name::<N>(), text)\n+            let node = std::any::type_name::<N>();\n+            panic!(\"Failed to make ast node `{node}` from text {text}\")\n         }\n     };\n     let node = node.clone_subtree();\n@@ -824,7 +825,7 @@ pub fn token(kind: SyntaxKind) -> SyntaxToken {\n         .descendants_with_tokens()\n         .filter_map(|it| it.into_token())\n         .find(|it| it.kind() == kind)\n-        .unwrap_or_else(|| panic!(\"unhandled token: {:?}\", kind))\n+        .unwrap_or_else(|| panic!(\"unhandled token: {kind:?}\"))\n }\n \n pub mod tokens {\n@@ -863,7 +864,7 @@ pub mod tokens {\n \n     pub fn literal(text: &str) -> SyntaxToken {\n         assert_eq!(text.trim(), text);\n-        let lit: ast::Literal = super::ast_from_text(&format!(\"fn f() {{ let _ = {}; }}\", text));\n+        let lit: ast::Literal = super::ast_from_text(&format!(\"fn f() {{ let _ = {text}; }}\"));\n         lit.syntax().first_child_or_token().unwrap().into_token().unwrap()\n     }\n "}]}