{"sha": "05395cba88580db10455952706cd8ae292fdbbe7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1Mzk1Y2JhODg1ODBkYjEwNDU1OTUyNzA2Y2Q4YWUyOTJmZGJiZTc=", "commit": {"author": {"name": "g3xzh", "email": "g3xzh@yahoo.com", "date": "2013-12-11T23:57:13Z"}, "committer": {"name": "g3xzh", "email": "g3xzh@yahoo.com", "date": "2013-12-19T00:13:51Z"}, "message": "Fix `sum()` accuracy\n\n`[1e20, 1.0, -1e20].sum()` returns `0.0`. This happens because during\nthe summation, `1.0` is too small relative to `1e20`, making it\nnegligible.\n\nI have tried Kahan summation but it hasn't fixed the problem.\nTherefore, I've used Python's `fsum()` implementation with some\nhelp from Jason Fager and Huon Wilson.\nFor more details, read:\nwww.cs.cmu.edu/~quake-papers/robust-arithmetic.ps\n\nMoreover, benchmark and unit tests were added.\n\nNote: `Status.sum` is still not fully fixed. It doesn't handle\nNaNs, infinities and overflow correctly. See issue 11059:\nhttps://github.com/mozilla/rust/issues/11059", "tree": {"sha": "8a4b1b4a74b76aba35cd82834a835e252a362532", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a4b1b4a74b76aba35cd82834a835e252a362532"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05395cba88580db10455952706cd8ae292fdbbe7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05395cba88580db10455952706cd8ae292fdbbe7", "html_url": "https://github.com/rust-lang/rust/commit/05395cba88580db10455952706cd8ae292fdbbe7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05395cba88580db10455952706cd8ae292fdbbe7/comments", "author": {"login": "g3xzh", "id": 5985993, "node_id": "MDQ6VXNlcjU5ODU5OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5985993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/g3xzh", "html_url": "https://github.com/g3xzh", "followers_url": "https://api.github.com/users/g3xzh/followers", "following_url": "https://api.github.com/users/g3xzh/following{/other_user}", "gists_url": "https://api.github.com/users/g3xzh/gists{/gist_id}", "starred_url": "https://api.github.com/users/g3xzh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/g3xzh/subscriptions", "organizations_url": "https://api.github.com/users/g3xzh/orgs", "repos_url": "https://api.github.com/users/g3xzh/repos", "events_url": "https://api.github.com/users/g3xzh/events{/privacy}", "received_events_url": "https://api.github.com/users/g3xzh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "g3xzh", "id": 5985993, "node_id": "MDQ6VXNlcjU5ODU5OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5985993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/g3xzh", "html_url": "https://github.com/g3xzh", "followers_url": "https://api.github.com/users/g3xzh/followers", "following_url": "https://api.github.com/users/g3xzh/following{/other_user}", "gists_url": "https://api.github.com/users/g3xzh/gists{/gist_id}", "starred_url": "https://api.github.com/users/g3xzh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/g3xzh/subscriptions", "organizations_url": "https://api.github.com/users/g3xzh/orgs", "repos_url": "https://api.github.com/users/g3xzh/repos", "events_url": "https://api.github.com/users/g3xzh/events{/privacy}", "received_events_url": "https://api.github.com/users/g3xzh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e0cb316fc980f00e1b74f3fdb7a842b540be280", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0cb316fc980f00e1b74f3fdb7a842b540be280", "html_url": "https://github.com/rust-lang/rust/commit/4e0cb316fc980f00e1b74f3fdb7a842b540be280"}], "stats": {"total": 67, "additions": 66, "deletions": 1}, "files": [{"sha": "f79ec51a9f7b715eef8829b770c9ef91fd41721f", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/05395cba88580db10455952706cd8ae292fdbbe7/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05395cba88580db10455952706cd8ae292fdbbe7/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=05395cba88580db10455952706cd8ae292fdbbe7", "patch": "@@ -15,6 +15,7 @@ use std::cmp;\n use std::hashmap;\n use std::io;\n use std::num;\n+use std::util;\n \n // NB: this can probably be rewritten in terms of num::Num\n // to be less f64-specific.\n@@ -23,6 +24,12 @@ use std::num;\n pub trait Stats {\n \n     /// Sum of the samples.\n+    ///\n+    /// Note: this method sacrifices performance at the altar of accuracy\n+    /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n+    /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\"]\n+    /// (http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps)\n+    /// *Discrete & Computational Geometry 18*, 3 (Oct 1997), 305-363, Shewchuk J.R.\n     fn sum(self) -> f64;\n \n     /// Minimum value of the samples.\n@@ -147,8 +154,37 @@ impl Summary {\n \n impl<'self> Stats for &'self [f64] {\n \n+    // FIXME #11059 handle NaN, inf and overflow\n     fn sum(self) -> f64 {\n-        self.iter().fold(0.0, |p,q| p + *q)\n+        let mut partials : ~[f64] = ~[];\n+\n+        for &mut x in self.iter() {\n+            let mut j = 0;\n+            // This inner loop applies `hi`/`lo` summation to each\n+            // partial so that the list of partial sums remains exact.\n+            for i in range(0, partials.len()) {\n+                let mut y = partials[i];\n+                if num::abs(x) < num::abs(y) {\n+                    util::swap(&mut x, &mut y);\n+                }\n+                // Rounded `x+y` is stored in `hi` with round-off stored in\n+                // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n+                let hi = x + y;\n+                let lo = y - (hi - x);\n+                if lo != 0f64 {\n+                    partials[j] = lo;\n+                    j += 1;\n+                }\n+                x = hi;\n+            }\n+            if j >= partials.len() {\n+                partials.push(x);\n+            } else {\n+                partials[j] = x;\n+                partials.truncate(j+1);\n+            }\n+        }\n+        partials.iter().fold(0.0, |p, q| p + *q)\n     }\n \n     fn min(self) -> f64 {\n@@ -955,5 +991,34 @@ mod tests {\n         t(&Summary::new([-2.0, 0.0]), ~\"-2 |[------******#******---]| 0\");\n \n     }\n+    #[test]\n+    fn test_sum_f64s() {\n+        assert_eq!([0.5, 3.2321, 1.5678].sum(), 5.2999);\n+    }\n+    #[test]\n+    fn test_sum_f64_between_ints_that_sum_to_0() {\n+        assert_eq!([1e30, 1.2, -1e30].sum(), 1.2);\n+    }\n+}\n \n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+    use std::vec;\n+\n+    #[bench]\n+    fn sum_three_items(bh: &mut BenchHarness) {\n+        bh.iter(|| {\n+            [1e20, 1.5, -1e20].sum();\n+        })\n+    }\n+    #[bench]\n+    fn sum_many_f64(bh: &mut BenchHarness) {\n+        let nums = [-1e30, 1e60, 1e30, 1.0, -1e60];\n+        let v = vec::from_fn(500, |i| nums[i%5]);\n+\n+        bh.iter(|| {\n+            v.sum();\n+        })\n+    }\n }"}]}