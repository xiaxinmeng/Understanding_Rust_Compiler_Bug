{"sha": "2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMmI0ZDcyNTc4YTUzMWVjOTVjYTdhNWFiMTdlNDEzNmQ5NzU2ZmM=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-03-03T15:35:54Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-03-09T19:13:58Z"}, "message": "Pull `thir::Cx` out of the MIR `Builder`", "tree": {"sha": "a2dfccaadce0f18a26eca3666023ffc91ade66ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2dfccaadce0f18a26eca3666023ffc91ade66ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "html_url": "https://github.com/rust-lang/rust/commit/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "url": "https://api.github.com/repos/rust-lang/rust/commits/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "html_url": "https://github.com/rust-lang/rust/commit/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a"}], "stats": {"total": 583, "additions": 254, "deletions": 329}, "files": [{"sha": "7bb141058d22e906614adbf045ecc14dcad7112d", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -110,8 +110,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let_scope_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a source scope.\n-                    let remainder_span =\n-                        remainder_scope.span(this.hir.tcx(), &this.hir.region_scope_tree);\n+                    let remainder_span = remainder_scope.span(this.tcx, &this.region_scope_tree);\n \n                     let visibility_scope =\n                         Some(this.new_source_scope(remainder_span, LintLevel::Inherited, None));\n@@ -175,7 +174,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n         // of the block, which is stored into `destination`.\n-        let tcx = this.hir.tcx();\n+        let tcx = this.tcx;\n         let destination_ty = destination.ty(&this.local_decls, tcx).ty;\n         if let Some(expr) = expr {\n             let tail_result_is_ignored =\n@@ -195,7 +194,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if destination_ty.is_unit() {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n-                this.cfg.push_assign_unit(block, source_info, destination, this.hir.tcx());\n+                this.cfg.push_assign_unit(block, source_info, destination, this.tcx);\n             }\n         }\n         // Finally, we pop all the let scopes before exiting out from the scope of block\n@@ -221,7 +220,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Safety::Safe => {}\n                     // no longer treat `unsafe fn`s as `unsafe` contexts (see RFC #2585)\n                     Safety::FnUnsafe\n-                        if self.hir.tcx().lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, hir_id).0\n+                        if self.tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, hir_id).0\n                             != Level::Allow => {}\n                     _ => return,\n                 }"}, {"sha": "81428e098699d6fad49072ad3c7896b1c655127c", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -136,12 +136,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             });\n         }\n \n-        let tcx = this.hir.tcx();\n+        let tcx = this.tcx;\n \n         if tcx.features().unsized_fn_params {\n             let ty = expr.ty;\n             let span = expr.span;\n-            let param_env = this.hir.param_env;\n+            let param_env = this.param_env;\n \n             if !ty.is_sized(tcx.at(span), param_env) {\n                 // !sized means !copy, so this is an unsized move"}, {"sha": "3581ca1ee5bd5e42fab01d1f00d6a55ad2a623db", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n+        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -377,7 +377,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n+        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -462,8 +462,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place =\n-                        place_builder.clone().into_place(this.hir.tcx(), this.hir.typeck_results());\n+                    let place = place_builder.clone().into_place(this.tcx, this.typeck_results);\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -557,12 +556,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         upvar_id: ty::UpvarId,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         let closure_ty = self\n-            .hir\n-            .typeck_results()\n-            .node_type(self.hir.tcx().hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n+            .typeck_results\n+            .node_type(self.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n \n         let closure_kind = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n-            self.hir.infcx().closure_kind(closure_substs).unwrap()\n+            self.infcx.closure_kind(closure_substs).unwrap()\n         } else {\n             // Generators are considered FnOnce.\n             ty::ClosureKind::FnOnce\n@@ -608,7 +606,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         block = self.bounds_check(\n             block,\n-            base_place.clone().into_place(self.hir.tcx(), self.hir.typeck_results()),\n+            base_place.clone().into_place(self.tcx, self.typeck_results),\n             idx,\n             expr_span,\n             source_info,\n@@ -617,8 +615,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n-            base_place =\n-                base_place.expect_upvars_resolved(self.hir.tcx(), self.hir.typeck_results());\n+            base_place = base_place.expect_upvars_resolved(self.tcx, self.typeck_results);\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -639,8 +636,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr_span: Span,\n         source_info: SourceInfo,\n     ) -> BasicBlock {\n-        let usize_ty = self.hir.usize_ty();\n-        let bool_ty = self.hir.bool_ty();\n+        let usize_ty = self.tcx.types.usize;\n+        let bool_ty = self.tcx.types.bool;\n         // bounds check:\n         let len = self.temp(usize_ty, expr_span);\n         let lt = self.temp(bool_ty, expr_span);\n@@ -670,7 +667,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr_span: Span,\n         source_info: SourceInfo,\n     ) {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let local = match base_place.base {\n             PlaceBase::Local(local) => local,\n             PlaceBase::Upvar { .. } => bug!(\"Expected PlacseBase::Local found Upvar\"),"}, {"sha": "89a179bd4510d0268c31838ed110e1b590df4755", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -61,8 +61,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Unary { op, arg } => {\n                 let arg = unpack!(block = this.as_operand(block, scope, &arg));\n                 // Check for -MIN on signed integers\n-                if this.hir.check_overflow() && *op == UnOp::Neg && expr.ty.is_signed() {\n-                    let bool_ty = this.hir.bool_ty();\n+                if this.check_overflow && *op == UnOp::Neg && expr.ty.is_signed() {\n+                    let bool_ty = this.tcx.types.bool;\n \n                     let minval = this.minval_literal(expr_span, expr.ty);\n                     let is_min = this.temp(bool_ty, expr_span);\n@@ -105,7 +105,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // initialize the box contents:\n                 unpack!(\n                     block = this.expr_into_dest(\n-                        this.hir.tcx().mk_place_deref(Place::from(result)),\n+                        this.tcx.mk_place_deref(Place::from(result)),\n                         block,\n                         &value\n                     )\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 //     to the same MIR as `let x = ();`.\n \n                 // first process the set of fields\n-                let el_ty = expr.ty.sequence_element_type(this.hir.tcx());\n+                let el_ty = expr.ty.sequence_element_type(this.tcx);\n                 let fields: Vec<_> = fields\n                     .into_iter()\n                     .map(|f| unpack!(block = this.as_operand(block, scope, &f)))\n@@ -221,7 +221,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(Rvalue::Use(Operand::Constant(box Constant {\n                     span: expr_span,\n                     user_ty: None,\n-                    literal: ty::Const::zero_sized(this.hir.tcx(), this.hir.tcx().types.unit),\n+                    literal: ty::Const::zero_sized(this.tcx, this.tcx.types.unit),\n                 })))\n             }\n             ExprKind::Yield { .. }\n@@ -273,9 +273,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         rhs: Operand<'tcx>,\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         let source_info = self.source_info(span);\n-        let bool_ty = self.hir.bool_ty();\n-        if self.hir.check_overflow() && op.is_checkable() && ty.is_integral() {\n-            let result_tup = self.hir.tcx().intern_tup(&[ty, bool_ty]);\n+        let bool_ty = self.tcx.types.bool;\n+        if self.check_overflow && op.is_checkable() && ty.is_integral() {\n+            let result_tup = self.tcx.intern_tup(&[ty, bool_ty]);\n             let result_value = self.temp(result_tup, span);\n \n             self.cfg.push_assign(\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let val_fld = Field::new(0);\n             let of_fld = Field::new(1);\n \n-            let tcx = self.hir.tcx();\n+            let tcx = self.tcx;\n             let val = tcx.mk_place_field(result_value, val_fld, ty);\n             let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n \n@@ -389,7 +389,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // is same as that of the capture in the parent closure.\n             PlaceBase::Upvar { .. } => {\n                 let enclosing_upvars_resolved =\n-                    arg_place_builder.clone().into_place(this.hir.tcx(), this.hir.typeck_results());\n+                    arg_place_builder.clone().into_place(this.tcx, this.typeck_results);\n \n                 match enclosing_upvars_resolved.as_ref() {\n                     PlaceRef {\n@@ -426,13 +426,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n-        let arg_place = arg_place_builder.into_place(this.hir.tcx(), this.hir.typeck_results());\n+        let arg_place = arg_place_builder.into_place(this.tcx, this.typeck_results);\n \n         this.cfg.push_assign(\n             block,\n             source_info,\n             Place::from(temp),\n-            Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, borrow_kind, arg_place),\n+            Rvalue::Ref(this.tcx.lifetimes.re_erased, borrow_kind, arg_place),\n         );\n \n         // See the comment in `expr_as_temp` and on the `rvalue_scopes` field for why\n@@ -447,9 +447,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(ty);\n-        let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n+        let bits = self.tcx.layout_of(param_ty).unwrap().size.bits();\n         let n = (!0u128) >> (128 - bits);\n-        let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n+        let literal = ty::Const::from_bits(self.tcx, n, param_ty);\n \n         self.literal_operand(span, literal)\n     }\n@@ -458,9 +458,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         assert!(ty.is_signed());\n         let param_ty = ty::ParamEnv::empty().and(ty);\n-        let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n+        let bits = self.tcx.layout_of(param_ty).unwrap().size.bits();\n         let n = 1 << (bits - 1);\n-        let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n+        let literal = ty::Const::from_bits(self.tcx, n, param_ty);\n \n         self.literal_operand(span, literal)\n     }"}, {"sha": "8b032032bfc43dfda51d576f86cae5923d606db2", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -59,13 +59,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             match expr.kind {\n                 ExprKind::StaticRef { def_id, .. } => {\n-                    assert!(!this.hir.tcx().is_thread_local_static(def_id));\n+                    assert!(!this.tcx.is_thread_local_static(def_id));\n                     local_decl.internal = true;\n                     local_decl.local_info =\n                         Some(box LocalInfo::StaticRef { def_id, is_thread_local: false });\n                 }\n                 ExprKind::ThreadLocalRef(def_id) => {\n-                    assert!(this.hir.tcx().is_thread_local_static(def_id));\n+                    assert!(this.tcx.is_thread_local_static(def_id));\n                     local_decl.internal = true;\n                     local_decl.local_info =\n                         Some(box LocalInfo::StaticRef { def_id, is_thread_local: true });"}, {"sha": "83a09a005084a7da1dfb796385a8ca57a47b7437", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -7,8 +7,9 @@ use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n+use rustc_index::vec::Idx;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::CanonicalUserTypeAnnotation;\n+use rustc_middle::ty::{self, CanonicalUserTypeAnnotation};\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n@@ -58,7 +59,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 let mut then_block = this.cfg.start_new_block();\n                 let mut else_block = this.cfg.start_new_block();\n-                let term = TerminatorKind::if_(this.hir.tcx(), operand, then_block, else_block);\n+                let term = TerminatorKind::if_(this.tcx, operand, then_block, else_block);\n                 this.cfg.terminate(block, source_info, term);\n \n                 unpack!(then_block = this.expr_into_dest(destination, then_block, &then));\n@@ -68,7 +69,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n                     let correct_si = this.source_info(expr_span.shrink_to_hi());\n-                    this.cfg.push_assign_unit(else_block, correct_si, destination, this.hir.tcx());\n+                    this.cfg.push_assign_unit(else_block, correct_si, destination, this.tcx);\n                     else_block\n                 };\n \n@@ -132,25 +133,33 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n-                let term = TerminatorKind::if_(this.hir.tcx(), lhs, blocks.0, blocks.1);\n+                let term = TerminatorKind::if_(this.tcx, lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n                 let rhs = unpack!(else_block = this.as_local_operand(else_block, &rhs));\n-                let term = TerminatorKind::if_(this.hir.tcx(), rhs, true_block, false_block);\n+                let term = TerminatorKind::if_(this.tcx, rhs, true_block, false_block);\n                 this.cfg.terminate(else_block, source_info, term);\n \n                 this.cfg.push_assign_constant(\n                     true_block,\n                     source_info,\n                     destination,\n-                    Constant { span: expr_span, user_ty: None, literal: this.hir.true_literal() },\n+                    Constant {\n+                        span: expr_span,\n+                        user_ty: None,\n+                        literal: ty::Const::from_bool(this.tcx, true),\n+                    },\n                 );\n \n                 this.cfg.push_assign_constant(\n                     false_block,\n                     source_info,\n                     destination,\n-                    Constant { span: expr_span, user_ty: None, literal: this.hir.false_literal() },\n+                    Constant {\n+                        span: expr_span,\n+                        user_ty: None,\n+                        literal: ty::Const::from_bool(this.tcx, false),\n+                    },\n                 );\n \n                 // Link up both branches:\n@@ -241,8 +250,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, &arg)),\n                     _ => unpack!(block = this.as_place(block, &arg)),\n                 };\n-                let borrow =\n-                    Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, *borrow_kind, arg_place);\n+                let borrow = Rvalue::Ref(this.tcx.lifetimes.re_erased, *borrow_kind, arg_place);\n                 this.cfg.push_assign(block, source_info, destination, borrow);\n                 block.unit()\n             }\n@@ -272,7 +280,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     })\n                     .collect();\n \n-                let field_names = this.hir.all_fields(adt_def, *variant_index);\n+                let field_names: Vec<_> =\n+                    (0..adt_def.variants[*variant_index].fields.len()).map(Field::new).collect();\n \n                 let fields: Vec<_> = if let Some(FruInfo { base, field_types }) = base {\n                     let place_builder = unpack!(block = this.as_place_builder(block, &base));\n@@ -290,7 +299,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 this.consume_by_copy_or_move(\n                                     place_builder\n                                         .field(n, ty)\n-                                        .into_place(this.hir.tcx(), this.hir.typeck_results()),\n+                                        .into_place(this.tcx, this.typeck_results),\n                                 )\n                             }\n                         })\n@@ -398,7 +407,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::AssignOp { .. }\n             | ExprKind::LlvmInlineAsm { .. } => {\n                 unpack!(block = this.stmt_expr(block, expr, None));\n-                this.cfg.push_assign_unit(block, source_info, destination, this.hir.tcx());\n+                this.cfg.push_assign_unit(block, source_info, destination, this.tcx);\n                 block.unit()\n             }\n "}, {"sha": "8e907a40f43fa53972d72bc8b12c505aae18f551", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // Generate better code for things that don't need to be\n                 // dropped.\n-                if this.hir.needs_drop(lhs.ty) {\n+                if lhs.ty.needs_drop(this.tcx, this.param_env) {\n                     let rhs = unpack!(block = this.as_local_operand(block, &rhs));\n                     let lhs = unpack!(block = this.as_place(block, &lhs));\n                     unpack!(block = this.build_drop_and_replace(block, lhs_span, lhs, rhs));"}, {"sha": "d93fc6149c213d64ff8c411ebe27e49f0635a829", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let ty_source_info = self.source_info(user_ty_span);\n                 let user_ty = pat_ascription_ty.user_ty(\n                     &mut self.canonical_user_type_annotations,\n-                    place.ty(&self.local_decls, self.hir.tcx()).ty,\n+                    place.ty(&self.local_decls, self.tcx).ty,\n                     ty_source_info.span,\n                 );\n                 self.cfg.push(\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(local_id) });\n-        let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n+        let region_scope = self.region_scope_tree.var_scope(var.local_id);\n         if schedule_drop {\n             self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n         }\n@@ -564,7 +564,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     crate fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n-        let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n+        let region_scope = self.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(span, region_scope, local_id, DropKind::Value);\n     }\n \n@@ -1070,7 +1070,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     fake_borrows.insert(Place {\n                         local: source.local,\n-                        projection: self.hir.tcx().intern_place_elems(proj_base),\n+                        projection: self.tcx.intern_place_elems(proj_base),\n                     });\n                 }\n             }\n@@ -1549,7 +1549,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         fake_borrows: &'b FxHashSet<Place<'tcx>>,\n         temp_span: Span,\n     ) -> Vec<(Place<'tcx>, Local)> {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n \n         debug!(\"add_fake_borrows fake_borrows = {:?}\", fake_borrows);\n \n@@ -1726,7 +1726,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         //    * So we eagerly create the reference for the arm and then take a\n         //      reference to that.\n         if let Some(guard) = guard {\n-            let tcx = self.hir.tcx();\n+            let tcx = self.tcx;\n             let bindings = parent_bindings\n                 .iter()\n                 .flat_map(|(bindings, _)| bindings)\n@@ -1885,7 +1885,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             let user_ty = ascription.user_ty.clone().user_ty(\n                 &mut self.canonical_user_type_annotations,\n-                ascription.source.ty(&self.local_decls, self.hir.tcx()).ty,\n+                ascription.source.ty(&self.local_decls, self.tcx).ty,\n                 source_info.span,\n             );\n             self.cfg.push(\n@@ -1914,7 +1914,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n         // candidate.\n-        let re_erased = self.hir.tcx().lifetimes.re_erased;\n+        let re_erased = self.tcx.lifetimes.re_erased;\n         for binding in bindings {\n             debug!(\"bind_matched_candidate_for_guard(binding={:?})\", binding);\n             let source_info = self.source_info(binding.span);\n@@ -1963,7 +1963,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     {\n         debug!(\"bind_matched_candidate_for_arm_body(block={:?})\", block);\n \n-        let re_erased = self.hir.tcx().lifetimes.re_erased;\n+        let re_erased = self.tcx.lifetimes.re_erased;\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n@@ -2012,7 +2012,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             var_id, name, mode, var_ty, visibility_scope, source_info\n         );\n \n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let debug_source_info = SourceInfo { span: source_info.span, scope: visibility_scope };\n         let binding_mode = match mode {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability),"}, {"sha": "9931cdf3b9e9113049ddbcb3633efeb638a16968", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match_pair: MatchPair<'pat, 'tcx>,\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> Result<(), MatchPair<'pat, 'tcx>> {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         match *match_pair.pattern.kind {\n             PatKind::AscribeUserType {\n                 ref subpattern,\n@@ -251,13 +251,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n                 let irrefutable = adt_def.variants.iter_enumerated().all(|(i, v)| {\n                     i == variant_index || {\n-                        self.hir.tcx().features().exhaustive_patterns\n+                        self.tcx.features().exhaustive_patterns\n                             && !v\n                                 .uninhabited_from(\n-                                    self.hir.tcx(),\n+                                    self.tcx,\n                                     substs,\n                                     adt_def.adt_kind(),\n-                                    self.hir.param_env,\n+                                    self.param_env,\n                                 )\n                                 .is_empty()\n                     }"}, {"sha": "48abaa8d35f82b5cd9d62a6a9e56d99b5b302ff7", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -13,9 +13,11 @@ use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::{LangItem, RangeEnd};\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n+use rustc_middle::ty::subst::{GenericArg, Subst};\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, adjustment::PointerCast, Ty};\n-use rustc_span::symbol::sym;\n+use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n+use rustc_span::def_id::DefId;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::VariantIdx;\n \n use std::cmp::Ordering;\n@@ -93,9 +95,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         match *match_pair.pattern.kind {\n             PatKind::Constant { value } => {\n-                options.entry(value).or_insert_with(|| {\n-                    value.eval_bits(self.hir.tcx(), self.hir.param_env, switch_ty)\n-                });\n+                options\n+                    .entry(value)\n+                    .or_insert_with(|| value.eval_bits(self.tcx, self.param_env, switch_ty));\n                 true\n             }\n             PatKind::Variant { .. } => {\n@@ -157,7 +159,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             \"perform_test({:?}, {:?}: {:?}, {:?})\",\n             block,\n             place,\n-            place.ty(&self.local_decls, self.hir.tcx()),\n+            place.ty(&self.local_decls, self.tcx),\n             test\n         );\n \n@@ -169,7 +171,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let num_enum_variants = adt_def.variants.len();\n                 debug_assert_eq!(target_blocks.len(), num_enum_variants + 1);\n                 let otherwise_block = *target_blocks.last().unwrap();\n-                let tcx = self.hir.tcx();\n+                let tcx = self.tcx;\n                 let switch_targets = SwitchTargets::new(\n                     adt_def.discriminants(tcx).filter_map(|(idx, discr)| {\n                         if variants.contains(idx) {\n@@ -217,7 +219,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             0 => (second_bb, first_bb),\n                             v => span_bug!(test.span, \"expected boolean value but got {:?}\", v),\n                         };\n-                        TerminatorKind::if_(self.hir.tcx(), Operand::Copy(place), true_bb, false_bb)\n+                        TerminatorKind::if_(self.tcx, Operand::Copy(place), true_bb, false_bb)\n                     } else {\n                         bug!(\"`TestKind::SwitchInt` on `bool` should have two targets\")\n                     }\n@@ -292,7 +294,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             TestKind::Len { len, op } => {\n                 let target_blocks = make_target_blocks(self);\n \n-                let usize_ty = self.hir.usize_ty();\n+                let usize_ty = self.tcx.types.usize;\n                 let actual = self.temp(usize_ty, test.span);\n \n                 // actual = len(place)\n@@ -331,7 +333,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         left: Operand<'tcx>,\n         right: Operand<'tcx>,\n     ) {\n-        let bool_ty = self.hir.bool_ty();\n+        let bool_ty = self.tcx.types.bool;\n         let result = self.temp(bool_ty, source_info.span);\n \n         // result = op(left, right)\n@@ -341,7 +343,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.terminate(\n             block,\n             source_info,\n-            TerminatorKind::if_(self.hir.tcx(), Operand::Move(result), success_block, fail_block),\n+            TerminatorKind::if_(self.tcx, Operand::Move(result), success_block, fail_block),\n         );\n     }\n \n@@ -377,7 +379,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // nothing to do, neither is an array\n             (None, None) => {}\n             (Some((region, elem_ty, _)), _) | (None, Some((region, elem_ty, _))) => {\n-                let tcx = self.hir.tcx();\n+                let tcx = self.tcx;\n                 // make both a slice\n                 ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n                 if opt_ref_ty.is_some() {\n@@ -408,10 +410,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n         };\n \n-        let eq_def_id = self.hir.tcx().require_lang_item(LangItem::PartialEq, None);\n-        let method = self.hir.trait_method(eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n+        let eq_def_id = self.tcx.require_lang_item(LangItem::PartialEq, None);\n+        let method = trait_method(self.tcx, eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n \n-        let bool_ty = self.hir.bool_ty();\n+        let bool_ty = self.tcx.types.bool;\n         let eq_result = self.temp(bool_ty, source_info.span);\n         let eq_block = self.cfg.start_new_block();\n         self.cfg.terminate(\n@@ -443,12 +445,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.cfg.terminate(\n                 eq_block,\n                 source_info,\n-                TerminatorKind::if_(\n-                    self.hir.tcx(),\n-                    Operand::Move(eq_result),\n-                    success_block,\n-                    fail_block,\n-                ),\n+                TerminatorKind::if_(self.tcx, Operand::Move(eq_result), success_block, fail_block),\n             );\n         } else {\n             bug!(\"`TestKind::Eq` should have two target blocks\")\n@@ -632,11 +629,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     use rustc_hir::RangeEnd::*;\n                     use std::cmp::Ordering::*;\n \n-                    let tcx = self.hir.tcx();\n+                    let tcx = self.tcx;\n \n                     let test_ty = test.lo.ty;\n-                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.hir.param_env, test_ty)?;\n-                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.hir.param_env, test_ty)?;\n+                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.param_env, test_ty)?;\n+                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.param_env, test_ty)?;\n \n                     match (test.end, pat.end, lo, hi) {\n                         // pat < test\n@@ -731,7 +728,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) {\n         let match_pair = candidate.match_pairs.remove(match_pair_index);\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n \n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n@@ -762,10 +759,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n \n-        let a = compare_const_vals(tcx, range.lo, value, self.hir.param_env, range.lo.ty)?;\n-        let b = compare_const_vals(tcx, value, range.hi, self.hir.param_env, range.lo.ty)?;\n+        let a = compare_const_vals(tcx, range.lo, value, self.param_env, range.lo.ty)?;\n+        let b = compare_const_vals(tcx, value, range.hi, self.param_env, range.lo.ty)?;\n \n         match (b, range.end) {\n             (Less, _) | (Equal, RangeEnd::Included) if a != Greater => Some(true),\n@@ -815,3 +812,25 @@ impl Test<'_> {\n fn is_switch_ty(ty: Ty<'_>) -> bool {\n     ty.is_integral() || ty.is_char() || ty.is_bool()\n }\n+\n+fn trait_method<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    method_name: Symbol,\n+    self_ty: Ty<'tcx>,\n+    params: &[GenericArg<'tcx>],\n+) -> &'tcx ty::Const<'tcx> {\n+    let substs = tcx.mk_substs_trait(self_ty, params);\n+\n+    // The unhygienic comparison here is acceptable because this is only\n+    // used on known traits.\n+    let item = tcx\n+        .associated_items(trait_def_id)\n+        .filter_by_name_unhygienic(method_name)\n+        .find(|item| item.kind == ty::AssocKind::Fn)\n+        .expect(\"trait method not found\");\n+\n+    let method_ty = tcx.type_of(item.def_id);\n+    let method_ty = method_ty.subst(tcx, substs);\n+    ty::Const::zero_sized(tcx, method_ty)\n+}"}, {"sha": "15aca0203aa0117e8efc69a465c17a36788b8275", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -15,8 +15,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         subpatterns\n             .iter()\n             .map(|fieldpat| {\n-                let place =\n-                    self.hir.tcx().mk_place_field(place, fieldpat.field, fieldpat.pattern.ty);\n+                let place = self.tcx.mk_place_field(place, fieldpat.field, fieldpat.pattern.ty);\n                 MatchPair::new(place, &fieldpat.pattern)\n             })\n             .collect()\n@@ -30,9 +29,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         opt_slice: Option<&'pat Pat<'tcx>>,\n         suffix: &'pat [Pat<'tcx>],\n     ) {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let (min_length, exact_size) = match place.ty(&self.local_decls, tcx).ty.kind() {\n-            ty::Array(_, length) => (length.eval_usize(tcx, self.hir.param_env), true),\n+            ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n             _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n         };\n "}, {"sha": "62c217a12aaad1c6cad879f23298aaa09b2f16c1", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -3,10 +3,10 @@\n \n use crate::build::Builder;\n \n-use rustc_middle::ty::{self, Ty};\n-\n use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_trait_selection::infer::InferCtxtExt;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Adds a new temporary value of type `ty` storing the result of\n@@ -37,7 +37,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n     crate fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = ty::Const::from_bits(self.hir.tcx(), 0, ty::ParamEnv::empty().and(ty));\n+        let literal = ty::Const::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n \n         self.literal_operand(span, literal)\n     }\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         source_info: SourceInfo,\n         value: u64,\n     ) -> Place<'tcx> {\n-        let usize_ty = self.hir.usize_ty();\n+        let usize_ty = self.tcx.types.usize;\n         let temp = self.temp(usize_ty, source_info.span);\n         self.cfg.push_assign_constant(\n             block,\n@@ -57,16 +57,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Constant {\n                 span: source_info.span,\n                 user_ty: None,\n-                literal: self.hir.usize_literal(value),\n+                literal: ty::Const::from_usize(self.tcx, value),\n             },\n         );\n         temp\n     }\n \n     crate fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let ty = place.ty(&self.local_decls, tcx).ty;\n-        if !self.hir.type_is_copy_modulo_regions(ty, DUMMY_SP) {\n+        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, DUMMY_SP) {\n             Operand::Move(place)\n         } else {\n             Operand::Copy(place)"}, {"sha": "ecc5f2f260e7dd4ac44744971c73b40e3875b449", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 102, "deletions": 70, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -1,21 +1,21 @@\n use crate::build;\n use crate::build::scope::DropKind;\n use crate::thir::cx::Cx;\n-use crate::thir::{BindingMode, LintLevel, PatKind};\n+use crate::thir::{BindingMode, Expr, LintLevel, Pat, PatKind};\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc_span::symbol::kw;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::PanicStrategy;\n@@ -42,6 +42,7 @@ crate fn mir_built<'tcx>(\n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n     let id = tcx.hir().local_def_id_to_hir_id(def.did);\n+    let body_owner_kind = tcx.hir().body_owner_kind(id);\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span, span_with_body) = match tcx.hir().get(id) {\n@@ -88,13 +89,13 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     let span_with_body = span_with_body.unwrap_or_else(|| tcx.hir().span(id));\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let cx = Cx::new(&infcx, def, id);\n-        let body = if let Some(ErrorReported) = cx.typeck_results().tainted_by_errors {\n-            build::construct_error(cx, body_id)\n-        } else if cx.body_owner_kind.is_fn_or_closure() {\n+        let mut cx = Cx::new(tcx, def);\n+        let body = if let Some(ErrorReported) = cx.typeck_results.tainted_by_errors {\n+            build::construct_error(&infcx, def, id, body_id, body_owner_kind)\n+        } else if body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_sig = cx.typeck_results().liberated_fn_sigs()[id];\n+            let fn_sig = cx.typeck_results.liberated_fn_sigs()[id];\n             let fn_def_id = tcx.hir().local_def_id(id);\n \n             let safety = match fn_sig.unsafety {\n@@ -103,6 +104,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             };\n \n             let body = tcx.hir().body(body_id);\n+            let expr = cx.mirror_expr(&body.value);\n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n             let implicit_argument = match ty.kind() {\n@@ -178,14 +180,16 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             };\n \n             let mut mir = build::construct_fn(\n-                cx,\n+                &infcx,\n+                def,\n                 id,\n                 arguments,\n                 safety,\n                 abi,\n                 return_ty,\n                 return_ty_span,\n                 body,\n+                expr,\n                 span_with_body,\n             );\n             if yield_ty.is_some() {\n@@ -205,9 +209,12 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             // place to be the type of the constant because NLL typeck will\n             // equate them.\n \n-            let return_ty = cx.typeck_results().node_type(id);\n+            let return_ty = cx.typeck_results.node_type(id);\n \n-            build::construct_const(cx, body_id, return_ty, return_ty_span)\n+            let ast_expr = &tcx.hir().body(body_id).value;\n+            let expr = cx.mirror_expr(ast_expr);\n+\n+            build::construct_const(&infcx, expr, def, id, return_ty, return_ty_span)\n         };\n \n         lints::check(tcx, &body);\n@@ -304,10 +311,17 @@ impl BlockFrame {\n struct BlockContext(Vec<BlockFrame>);\n \n struct Builder<'a, 'tcx> {\n-    hir: Cx<'a, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    typeck_results: &'tcx TypeckResults<'tcx>,\n+    region_scope_tree: &'tcx region::ScopeTree,\n+    param_env: ty::ParamEnv<'tcx>,\n+\n     cfg: CFG<'tcx>,\n \n     def_id: DefId,\n+    hir_id: hir::HirId,\n+    check_overflow: bool,\n     fn_span: Span,\n     arg_count: usize,\n     generator_kind: Option<GeneratorKind>,\n@@ -577,31 +591,31 @@ struct ArgInfo<'tcx>(\n     Option<ImplicitSelfKind>,\n );\n \n-fn construct_fn<'a, 'tcx, A>(\n-    hir: Cx<'a, 'tcx>,\n+fn construct_fn<'tcx, A>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    fn_def: ty::WithOptConstParam<LocalDefId>,\n     fn_id: hir::HirId,\n     arguments: A,\n     safety: Safety,\n     abi: Abi,\n     return_ty: Ty<'tcx>,\n     return_ty_span: Span,\n     body: &'tcx hir::Body<'tcx>,\n+    expr: Expr<'tcx>,\n     span_with_body: Span,\n ) -> Body<'tcx>\n where\n     A: Iterator<Item = ArgInfo<'tcx>>,\n {\n     let arguments: Vec<_> = arguments.collect();\n \n-    let tcx = hir.tcx();\n-    let tcx_hir = tcx.hir();\n-    let span = tcx_hir.span(fn_id);\n-\n-    let fn_def_id = tcx_hir.local_def_id(fn_id);\n+    let tcx = infcx.tcx;\n+    let span = tcx.hir().span(fn_id);\n \n     let mut builder = Builder::new(\n-        hir,\n-        fn_def_id.to_def_id(),\n+        infcx,\n+        fn_def,\n+        fn_id,\n         span_with_body,\n         arguments.len(),\n         safety,\n@@ -625,16 +639,16 @@ where\n                 Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n                     builder.args_and_body(\n                         START_BLOCK,\n-                        fn_def_id.to_def_id(),\n+                        fn_def.did.to_def_id(),\n                         &arguments,\n                         arg_scope,\n-                        &body.value,\n+                        &expr,\n                     )\n                 }))\n             }));\n         let source_info = builder.source_info(fn_end);\n         builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n-        let should_abort = should_abort_on_panic(tcx, fn_def_id, abi);\n+        let should_abort = should_abort_on_panic(tcx, fn_def.did, abi);\n         builder.build_drop_trees(should_abort);\n         return_block.unit()\n     }));\n@@ -645,29 +659,27 @@ where\n     } else {\n         None\n     };\n-    debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id.to_def_id()));\n+    debug!(\"fn_id {:?} has attrs {:?}\", fn_def, tcx.get_attrs(fn_def.did.to_def_id()));\n \n     let mut body = builder.finish();\n     body.spread_arg = spread_arg;\n     body\n }\n \n fn construct_const<'a, 'tcx>(\n-    hir: Cx<'a, 'tcx>,\n-    body_id: hir::BodyId,\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    expr: Expr<'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+    hir_id: hir::HirId,\n     const_ty: Ty<'tcx>,\n     const_ty_span: Span,\n ) -> Body<'tcx> {\n-    let tcx = hir.tcx();\n-    let owner_id = tcx.hir().body_owner(body_id);\n-    let def_id = tcx.hir().local_def_id(owner_id);\n-    let span = tcx.hir().span(owner_id);\n+    let tcx = infcx.tcx;\n+    let span = tcx.hir().span(hir_id);\n     let mut builder =\n-        Builder::new(hir, def_id.to_def_id(), span, 0, Safety::Safe, const_ty, const_ty_span, None);\n+        Builder::new(infcx, def, hir_id, span, 0, Safety::Safe, const_ty, const_ty_span, None);\n \n     let mut block = START_BLOCK;\n-    let ast_expr = &tcx.hir().body(body_id).value;\n-    let expr = builder.hir.mirror_expr(ast_expr);\n     unpack!(block = builder.expr_into_dest(Place::return_place(), block, &expr));\n \n     let source_info = builder.source_info(span);\n@@ -682,38 +694,34 @@ fn construct_const<'a, 'tcx>(\n ///\n /// This is required because we may still want to run MIR passes on an item\n /// with type errors, but normal MIR construction can't handle that in general.\n-fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'tcx> {\n-    let tcx = hir.tcx();\n-    let owner_id = tcx.hir().body_owner(body_id);\n-    let def_id = tcx.hir().local_def_id(owner_id);\n-    let span = tcx.hir().span(owner_id);\n+fn construct_error<'a, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+    hir_id: hir::HirId,\n+    body_id: hir::BodyId,\n+    body_owner_kind: hir::BodyOwnerKind,\n+) -> Body<'tcx> {\n+    let tcx = infcx.tcx;\n+    let span = tcx.hir().span(hir_id);\n     let ty = tcx.ty_error();\n     let generator_kind = tcx.hir().body(body_id).generator_kind;\n-    let num_params = match hir.body_owner_kind {\n-        hir::BodyOwnerKind::Fn => tcx.hir().fn_decl_by_hir_id(owner_id).unwrap().inputs.len(),\n+    let num_params = match body_owner_kind {\n+        hir::BodyOwnerKind::Fn => tcx.hir().fn_decl_by_hir_id(hir_id).unwrap().inputs.len(),\n         hir::BodyOwnerKind::Closure => {\n             if generator_kind.is_some() {\n                 // Generators have an implicit `self` parameter *and* a possibly\n                 // implicit resume parameter.\n                 2\n             } else {\n                 // The implicit self parameter adds another local in MIR.\n-                1 + tcx.hir().fn_decl_by_hir_id(owner_id).unwrap().inputs.len()\n+                1 + tcx.hir().fn_decl_by_hir_id(hir_id).unwrap().inputs.len()\n             }\n         }\n         hir::BodyOwnerKind::Const => 0,\n         hir::BodyOwnerKind::Static(_) => 0,\n     };\n-    let mut builder = Builder::new(\n-        hir,\n-        def_id.to_def_id(),\n-        span,\n-        num_params,\n-        Safety::Safe,\n-        ty,\n-        span,\n-        generator_kind,\n-    );\n+    let mut builder =\n+        Builder::new(infcx, def, hir_id, span, num_params, Safety::Safe, ty, span, generator_kind);\n     let source_info = builder.source_info(span);\n     // Some MIR passes will expect the number of parameters to match the\n     // function declaration.\n@@ -728,19 +736,40 @@ fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'t\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn new(\n-        hir: Cx<'a, 'tcx>,\n-        def_id: DefId,\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        def: ty::WithOptConstParam<LocalDefId>,\n+        hir_id: hir::HirId,\n         span: Span,\n         arg_count: usize,\n         safety: Safety,\n         return_ty: Ty<'tcx>,\n         return_span: Span,\n         generator_kind: Option<GeneratorKind>,\n     ) -> Builder<'a, 'tcx> {\n-        let lint_level = LintLevel::Explicit(hir.root_lint_level);\n+        let tcx = infcx.tcx;\n+        let attrs = tcx.hir().attrs(hir_id);\n+        // Some functions always have overflow checks enabled,\n+        // however, they may not get codegen'd, depending on\n+        // the settings for the crate they are codegened in.\n+        let mut check_overflow = tcx.sess.contains_name(attrs, sym::rustc_inherit_overflow_checks);\n+        // Respect -C overflow-checks.\n+        check_overflow |= tcx.sess.overflow_checks();\n+        // Constants always need overflow checks.\n+        check_overflow |= matches!(\n+            tcx.hir().body_owner_kind(hir_id),\n+            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_)\n+        );\n+\n+        let lint_level = LintLevel::Explicit(hir_id);\n         let mut builder = Builder {\n-            hir,\n-            def_id,\n+            tcx,\n+            infcx,\n+            typeck_results: tcx.typeck_opt_const_arg(def),\n+            region_scope_tree: tcx.region_scope_tree(def.did),\n+            param_env: tcx.param_env(def.did),\n+            def_id: def.did.to_def_id(),\n+            hir_id,\n+            check_overflow,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n             arg_count,\n@@ -796,7 +825,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         fn_def_id: DefId,\n         arguments: &[ArgInfo<'tcx>],\n         argument_scope: region::Scope,\n-        ast_body: &'tcx hir::Expr<'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {\n@@ -816,9 +845,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let tcx_hir = tcx.hir();\n-        let hir_typeck_results = self.hir.typeck_results();\n+        let hir_typeck_results = self.typeck_results;\n \n         // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n         // indexed closure and we stored in a map called closure_captures in TypeckResults\n@@ -894,14 +923,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n-                arg_opt.as_ref().map_or(ast_body.span, |arg| arg.pat.span),\n+                arg_opt.as_ref().map_or(expr.span, |arg| arg.pat.span),\n                 argument_scope,\n                 local,\n                 DropKind::Value,\n             );\n \n             if let Some(arg) = arg_opt {\n-                let pattern = self.hir.pattern_from_hir(&arg.pat);\n+                let pat = match tcx.hir().get(arg.pat.hir_id) {\n+                    Node::Pat(pat) | Node::Binding(pat) => pat,\n+                    node => bug!(\"pattern became {:?}\", node),\n+                };\n+                let pattern = Pat::from_hir(tcx, self.param_env, self.typeck_results, pat);\n                 let original_source_scope = self.source_scope;\n                 let span = pattern.span;\n                 self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n@@ -936,7 +969,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     _ => {\n                         scope = self.declare_bindings(\n                             scope,\n-                            ast_body.span,\n+                            expr.span,\n                             &pattern,\n                             matches::ArmHasGuard(false),\n                             Some((Some(&place), span)),\n@@ -953,8 +986,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.source_scope = source_scope;\n         }\n \n-        let body = self.hir.mirror_expr(ast_body);\n-        self.expr_into_dest(Place::return_place(), block, &body)\n+        self.expr_into_dest(Place::return_place(), block, &expr)\n     }\n \n     fn set_correct_source_scope_for_arg(\n@@ -963,15 +995,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         original_source_scope: SourceScope,\n         pattern_span: Span,\n     ) {\n-        let tcx = self.hir.tcx();\n-        let current_root = tcx.maybe_lint_level_root_bounded(arg_hir_id, self.hir.root_lint_level);\n+        let tcx = self.tcx;\n+        let current_root = tcx.maybe_lint_level_root_bounded(arg_hir_id, self.hir_id);\n         let parent_root = tcx.maybe_lint_level_root_bounded(\n             self.source_scopes[original_source_scope]\n                 .local_data\n                 .as_ref()\n                 .assert_crate_local()\n                 .lint_root,\n-            self.hir.root_lint_level,\n+            self.hir_id,\n         );\n         if current_root != parent_root {\n             self.source_scope =\n@@ -983,7 +1015,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match self.unit_temp {\n             Some(tmp) => tmp,\n             None => {\n-                let ty = self.hir.unit_ty();\n+                let ty = self.tcx.mk_unit();\n                 let fn_span = self.fn_span;\n                 let tmp = self.temp(ty, fn_span);\n                 self.unit_temp = Some(tmp);"}, {"sha": "6c58528a3c5c6e85073d6929690a66efbed745d5", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -516,18 +516,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     {\n         debug!(\"in_scope(region_scope={:?})\", region_scope);\n         let source_scope = self.source_scope;\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n             // Use `maybe_lint_level_root_bounded` with `root_lint_level` as a bound\n             // to avoid adding Hir dependences on our parents.\n             // We estimate the true lint roots here to avoid creating a lot of source scopes.\n \n             let parent_root = tcx.maybe_lint_level_root_bounded(\n                 self.source_scopes[source_scope].local_data.as_ref().assert_crate_local().lint_root,\n-                self.hir.root_lint_level,\n+                self.hir_id,\n             );\n-            let current_root =\n-                tcx.maybe_lint_level_root_bounded(current_hir_id, self.hir.root_lint_level);\n+            let current_root = tcx.maybe_lint_level_root_bounded(current_hir_id, self.hir_id);\n \n             if parent_root != current_root {\n                 self.source_scope = self.new_source_scope(\n@@ -615,7 +614,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 unpack!(block = self.expr_into_dest(destination, block, value));\n                 self.block_context.pop();\n             } else {\n-                self.cfg.push_assign_unit(block, source_info, destination, self.hir.tcx())\n+                self.cfg.push_assign_unit(block, source_info, destination, self.tcx)\n             }\n         } else {\n             assert!(value.is_none(), \"`return` and `break` should have a destination\");\n@@ -763,7 +762,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         let needs_drop = match drop_kind {\n             DropKind::Value => {\n-                if !self.hir.needs_drop(self.local_decls[local].ty) {\n+                if !self.local_decls[local].ty.needs_drop(self.tcx, self.param_env) {\n                     return;\n                 }\n                 true\n@@ -834,10 +833,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             if scope.region_scope == region_scope {\n-                let region_scope_span =\n-                    region_scope.span(self.hir.tcx(), &self.hir.region_scope_tree);\n+                let region_scope_span = region_scope.span(self.tcx, &self.region_scope_tree);\n                 // Attribute scope exit drops to scope's closing brace.\n-                let scope_end = self.hir.tcx().sess.source_map().end_point(region_scope_span);\n+                let scope_end = self.tcx.sess.source_map().end_point(region_scope_span);\n \n                 scope.drops.push(DropData {\n                     source_info: SourceInfo { span: scope_end, scope: scope.source_scope },\n@@ -926,7 +924,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let cond = unpack!(block = self.as_local_operand(block, condition));\n         let true_block = self.cfg.start_new_block();\n         let false_block = self.cfg.start_new_block();\n-        let term = TerminatorKind::if_(self.hir.tcx(), cond.clone(), true_block, false_block);\n+        let term = TerminatorKind::if_(self.tcx, cond.clone(), true_block, false_block);\n         self.cfg.terminate(block, source_info, term);\n \n         match cond {"}, {"sha": "25af65d1c6538d931f95a64dceb97b47bd9c7684", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::ty;\n \n use rustc_index::vec::Idx;\n \n-impl<'a, 'tcx> Cx<'a, 'tcx> {\n+impl<'tcx> Cx<'tcx> {\n     crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block<'tcx> {\n         // We have to eagerly lower the \"spine\" of the statements\n         // in order to get the lexical scoping correctly."}, {"sha": "2d1170ca3a89d5bd6aa5091fcb641365731377fa", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{self, AdtKind, Ty};\n use rustc_span::Span;\n \n-impl<'a, 'tcx> Cx<'a, 'tcx> {\n+impl<'tcx> Cx<'tcx> {\n     crate fn mirror_expr(&mut self, hir_expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n         let temp_lifetime = self.region_scope_tree.temporary_scope(hir_expr.hir_id.local_id);\n         let expr_scope =\n@@ -26,7 +26,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         let mut expr = self.make_mirror_unadjusted(hir_expr);\n \n         // Now apply adjustments, if any.\n-        for adjustment in self.typeck_results().expr_adjustments(hir_expr) {\n+        for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n             debug!(\"make_mirror: expr={:?} applying adjustment={:?}\", expr, adjustment);\n             expr = self.apply_adjustment(hir_expr, expr, adjustment);\n         }\n@@ -287,13 +287,13 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n                     self.overloaded_operator(expr, vec![lhs, rhs])\n                 } else {\n                     // FIXME overflow\n-                    match (op.node, self.constness) {\n-                        (hir::BinOpKind::And, _) => ExprKind::LogicalOp {\n+                    match op.node {\n+                        hir::BinOpKind::And => ExprKind::LogicalOp {\n                             op: LogicalOp::And,\n                             lhs: self.mirror_expr_boxed(lhs),\n                             rhs: self.mirror_expr_boxed(rhs),\n                         },\n-                        (hir::BinOpKind::Or, _) => ExprKind::LogicalOp {\n+                        hir::BinOpKind::Or => ExprKind::LogicalOp {\n                             op: LogicalOp::Or,\n                             lhs: self.mirror_expr_boxed(lhs),\n                             rhs: self.mirror_expr_boxed(rhs),\n@@ -420,7 +420,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n                 };\n \n                 let upvars = self\n-                    .typeck_results()\n+                    .typeck_results\n                     .closure_min_captures_flattened(def_id)\n                     .zip(substs.upvar_tys())\n                     .map(|(captured_place, ty)| self.capture_upvar(expr, captured_place, ty))\n@@ -981,7 +981,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n     fn capture_upvar(\n         &mut self,\n         closure_expr: &'tcx hir::Expr<'tcx>,\n-        captured_place: &'a ty::CapturedPlace<'tcx>,\n+        captured_place: &'tcx ty::CapturedPlace<'tcx>,\n         upvar_ty: Ty<'tcx>,\n     ) -> Expr<'tcx> {\n         let upvar_capture = captured_place.info.capture_kind;"}, {"sha": "c00e9ff8dd98e01864b7094fd13f6e59e97ff71e", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 8, "deletions": 136, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2b4d72578a531ec95ca7a5ab17e4136d9756fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=2a2b4d72578a531ec95ca7a5ab17e4136d9756fc", "patch": "@@ -9,114 +9,37 @@ use rustc_ast as ast;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Node;\n-use rustc_index::vec::Idx;\n-use rustc_infer::infer::InferCtxt;\n use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n-use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::VariantIdx;\n-use rustc_trait_selection::infer::InferCtxtExt;\n \n #[derive(Clone)]\n-crate struct Cx<'a, 'tcx> {\n+crate struct Cx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n \n-    crate root_lint_level: hir::HirId,\n     crate param_env: ty::ParamEnv<'tcx>,\n \n-    /// Identity `InternalSubsts` for use with const-evaluation.\n-    crate identity_substs: &'tcx InternalSubsts<'tcx>,\n-\n     crate region_scope_tree: &'tcx region::ScopeTree,\n-    crate typeck_results: &'a ty::TypeckResults<'tcx>,\n-\n-    /// This is `Constness::Const` if we are compiling a `static`,\n-    /// `const`, or the body of a `const fn`.\n-    constness: hir::Constness,\n+    crate typeck_results: &'tcx ty::TypeckResults<'tcx>,\n \n     /// The `DefId` of the owner of this body.\n     body_owner: DefId,\n-\n-    /// What kind of body is being compiled.\n-    crate body_owner_kind: hir::BodyOwnerKind,\n-\n-    /// Whether this constant/function needs overflow checks.\n-    check_overflow: bool,\n }\n \n-impl<'a, 'tcx> Cx<'a, 'tcx> {\n-    crate fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-        src_id: hir::HirId,\n-    ) -> Cx<'a, 'tcx> {\n-        let tcx = infcx.tcx;\n+impl<'tcx> Cx<'tcx> {\n+    crate fn new(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) -> Cx<'tcx> {\n         let typeck_results = tcx.typeck_opt_const_arg(def);\n-        let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n-\n-        let constness = match body_owner_kind {\n-            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => hir::Constness::Const,\n-            hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => hir::Constness::NotConst,\n-        };\n-\n-        let attrs = tcx.hir().attrs(src_id);\n-\n-        // Some functions always have overflow checks enabled,\n-        // however, they may not get codegen'd, depending on\n-        // the settings for the crate they are codegened in.\n-        let mut check_overflow = tcx.sess.contains_name(attrs, sym::rustc_inherit_overflow_checks);\n-\n-        // Respect -C overflow-checks.\n-        check_overflow |= tcx.sess.overflow_checks();\n-\n-        // Constants always need overflow checks.\n-        check_overflow |= constness == hir::Constness::Const;\n-\n         Cx {\n             tcx,\n-            infcx,\n-            root_lint_level: src_id,\n             param_env: tcx.param_env(def.did),\n-            identity_substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             typeck_results,\n-            constness,\n             body_owner: def.did.to_def_id(),\n-            body_owner_kind,\n-            check_overflow,\n         }\n     }\n }\n \n-impl<'a, 'tcx> Cx<'a, 'tcx> {\n-    crate fn usize_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.types.usize\n-    }\n-\n-    crate fn usize_literal(&mut self, value: u64) -> &'tcx ty::Const<'tcx> {\n-        ty::Const::from_usize(self.tcx, value)\n-    }\n-\n-    crate fn bool_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.types.bool\n-    }\n-\n-    crate fn unit_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.mk_unit()\n-    }\n-\n-    crate fn true_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n-        ty::Const::from_bool(self.tcx, true)\n-    }\n-\n-    crate fn false_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n-        ty::Const::from_bool(self.tcx, false)\n-    }\n-\n+impl<'tcx> Cx<'tcx> {\n     crate fn const_eval_literal(\n         &mut self,\n         lit: &'tcx ast::LitKind,\n@@ -149,66 +72,15 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         };\n         Pat::from_hir(self.tcx, self.param_env, self.typeck_results(), p)\n     }\n-\n-    crate fn trait_method(\n-        &mut self,\n-        trait_def_id: DefId,\n-        method_name: Symbol,\n-        self_ty: Ty<'tcx>,\n-        params: &[GenericArg<'tcx>],\n-    ) -> &'tcx ty::Const<'tcx> {\n-        let substs = self.tcx.mk_substs_trait(self_ty, params);\n-\n-        // The unhygienic comparison here is acceptable because this is only\n-        // used on known traits.\n-        let item = self\n-            .tcx\n-            .associated_items(trait_def_id)\n-            .filter_by_name_unhygienic(method_name)\n-            .find(|item| item.kind == ty::AssocKind::Fn)\n-            .expect(\"trait method not found\");\n-\n-        let method_ty = self.tcx.type_of(item.def_id);\n-        let method_ty = method_ty.subst(self.tcx, substs);\n-        ty::Const::zero_sized(self.tcx, method_ty)\n-    }\n-\n-    crate fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: VariantIdx) -> Vec<Field> {\n-        (0..adt_def.variants[variant_index].fields.len()).map(Field::new).collect()\n-    }\n-\n-    crate fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n-        ty.needs_drop(self.tcx, self.param_env)\n-    }\n-\n-    crate fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n-        self.infcx\n-    }\n-\n-    crate fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    crate fn typeck_results(&self) -> &'a ty::TypeckResults<'tcx> {\n-        self.typeck_results\n-    }\n-\n-    crate fn check_overflow(&self) -> bool {\n-        self.check_overflow\n-    }\n-\n-    crate fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n-    }\n }\n \n-impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'_, 'tcx> {\n+impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx()\n+        self.tcx\n     }\n \n     fn typeck_results(&self) -> &ty::TypeckResults<'tcx> {\n-        self.typeck_results()\n+        self.typeck_results\n     }\n }\n "}]}