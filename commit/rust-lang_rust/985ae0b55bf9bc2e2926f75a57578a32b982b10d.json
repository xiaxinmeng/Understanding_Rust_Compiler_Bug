{"sha": "985ae0b55bf9bc2e2926f75a57578a32b982b10d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NWFlMGI1NWJmOWJjMmUyOTI2Zjc1YTU3NTc4YTMyYjk4MmIxMGQ=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-04-11T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-04-11T00:00:00Z"}, "message": "Match against attribute name when validating attributes\n\nExtract attribute name once and match it against symbols that are being\nvalidated, instead of using `Session::check_name` for each symbol\nindividually.\n\nAssume that all validated attributes are used, instead of marking them\nas such, since the attribute check should be exhaustive.", "tree": {"sha": "2dfc1a01947f0806860a40e1c5fbaa8c93b491c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dfc1a01947f0806860a40e1c5fbaa8c93b491c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/985ae0b55bf9bc2e2926f75a57578a32b982b10d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/985ae0b55bf9bc2e2926f75a57578a32b982b10d", "html_url": "https://github.com/rust-lang/rust/commit/985ae0b55bf9bc2e2926f75a57578a32b982b10d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/985ae0b55bf9bc2e2926f75a57578a32b982b10d/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba6275b6a9fc05fd5d93220e9a67fe64d663cb62", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba6275b6a9fc05fd5d93220e9a67fe64d663cb62", "html_url": "https://github.com/rust-lang/rust/commit/ba6275b6a9fc05fd5d93220e9a67fe64d663cb62"}], "stats": {"total": 98, "additions": 46, "deletions": 52}, "files": [{"sha": "8dd82ca79434a1f980de54d415b7e3a33ccb1dd8", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/985ae0b55bf9bc2e2926f75a57578a32b982b10d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985ae0b55bf9bc2e2926f75a57578a32b982b10d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=985ae0b55bf9bc2e2926f75a57578a32b982b10d", "patch": "@@ -100,6 +100,7 @@ pub struct Path {\n }\n \n impl PartialEq<Symbol> for Path {\n+    #[inline]\n     fn eq(&self, symbol: &Symbol) -> bool {\n         self.segments.len() == 1 && { self.segments[0].ident.name == *symbol }\n     }"}, {"sha": "153fca0c2f107031693d1ada581c8c14198348a1", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/985ae0b55bf9bc2e2926f75a57578a32b982b10d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985ae0b55bf9bc2e2926f75a57578a32b982b10d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=985ae0b55bf9bc2e2926f75a57578a32b982b10d", "patch": "@@ -227,8 +227,8 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\"\"#),\n     ),\n     ungated!(link_name, AssumedUsed, template!(NameValueStr: \"name\")),\n-    ungated!(no_link, Normal, template!(Word)),\n-    ungated!(repr, Normal, template!(List: \"C\")),\n+    ungated!(no_link, AssumedUsed, template!(Word)),\n+    ungated!(repr, AssumedUsed, template!(List: \"C\")),\n     ungated!(export_name, AssumedUsed, template!(NameValueStr: \"name\")),\n     ungated!(link_section, AssumedUsed, template!(NameValueStr: \"name\")),\n     ungated!(no_mangle, AssumedUsed, template!(Word)),\n@@ -317,7 +317,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         \"custom test frameworks are an unstable feature\",\n     ),\n     // RFC #1268\n-    gated!(marker, Normal, template!(Word), marker_trait_attr, experimental!(marker)),\n+    gated!(marker, AssumedUsed, template!(Word), marker_trait_attr, experimental!(marker)),\n     gated!(\n         thread_local, AssumedUsed, template!(Word),\n         \"`#[thread_local]` is an experimental feature, and does not currently handle destructors\","}, {"sha": "e1ab4ba81ae47246c67592972638cd8548f6e947", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/985ae0b55bf9bc2e2926f75a57578a32b982b10d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985ae0b55bf9bc2e2926f75a57578a32b982b10d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=985ae0b55bf9bc2e2926f75a57578a32b982b10d", "patch": "@@ -69,55 +69,48 @@ impl CheckAttrVisitor<'tcx> {\n         let mut is_valid = true;\n         let attrs = self.tcx.hir().attrs(hir_id);\n         for attr in attrs {\n-            is_valid &= if self.tcx.sess.check_name(attr, sym::inline) {\n-                self.check_inline(hir_id, attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::non_exhaustive) {\n-                self.check_non_exhaustive(hir_id, attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::marker) {\n-                self.check_marker(hir_id, attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::target_feature) {\n-                self.check_target_feature(hir_id, attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::track_caller) {\n-                self.check_track_caller(hir_id, &attr.span, attrs, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::doc) {\n-                self.check_doc_attrs(attr, hir_id, target)\n-            } else if self.tcx.sess.check_name(attr, sym::no_link) {\n-                self.check_no_link(hir_id, &attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::export_name) {\n-                self.check_export_name(hir_id, &attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::rustc_args_required_const) {\n-                self.check_rustc_args_required_const(&attr, span, target, item)\n-            } else if self.tcx.sess.check_name(attr, sym::rustc_layout_scalar_valid_range_start) {\n-                self.check_rustc_layout_scalar_valid_range(&attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::rustc_layout_scalar_valid_range_end) {\n-                self.check_rustc_layout_scalar_valid_range(&attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::allow_internal_unstable) {\n-                self.check_allow_internal_unstable(hir_id, &attr, span, target, &attrs)\n-            } else if self.tcx.sess.check_name(attr, sym::rustc_allow_const_fn_unstable) {\n-                self.check_rustc_allow_const_fn_unstable(hir_id, &attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::naked) {\n-                self.check_naked(hir_id, attr, span, target)\n-            } else if self.tcx.sess.check_name(attr, sym::rustc_legacy_const_generics) {\n-                self.check_rustc_legacy_const_generics(&attr, span, target, item)\n-            } else if self.tcx.sess.check_name(attr, sym::rustc_clean)\n-                || self.tcx.sess.check_name(attr, sym::rustc_dirty)\n-                || self.tcx.sess.check_name(attr, sym::rustc_if_this_changed)\n-                || self.tcx.sess.check_name(attr, sym::rustc_then_this_would_need)\n-            {\n-                self.check_rustc_dirty_clean(&attr)\n-            } else {\n-                // lint-only checks\n-                if self.tcx.sess.check_name(attr, sym::cold) {\n-                    self.check_cold(hir_id, attr, span, target);\n-                } else if self.tcx.sess.check_name(attr, sym::link_name) {\n-                    self.check_link_name(hir_id, attr, span, target);\n-                } else if self.tcx.sess.check_name(attr, sym::link_section) {\n-                    self.check_link_section(hir_id, attr, span, target);\n-                } else if self.tcx.sess.check_name(attr, sym::no_mangle) {\n-                    self.check_no_mangle(hir_id, attr, span, target);\n+            is_valid &= match attr.name_or_empty() {\n+                sym::inline => self.check_inline(hir_id, attr, span, target),\n+                sym::non_exhaustive => self.check_non_exhaustive(hir_id, attr, span, target),\n+                sym::marker => self.check_marker(hir_id, attr, span, target),\n+                sym::target_feature => self.check_target_feature(hir_id, attr, span, target),\n+                sym::track_caller => {\n+                    self.check_track_caller(hir_id, &attr.span, attrs, span, target)\n                 }\n-                true\n+                sym::doc => self.check_doc_attrs(attr, hir_id, target),\n+                sym::no_link => self.check_no_link(hir_id, &attr, span, target),\n+                sym::export_name => self.check_export_name(hir_id, &attr, span, target),\n+                sym::rustc_args_required_const => {\n+                    self.check_rustc_args_required_const(&attr, span, target, item)\n+                }\n+                sym::rustc_layout_scalar_valid_range_start\n+                | sym::rustc_layout_scalar_valid_range_end => {\n+                    self.check_rustc_layout_scalar_valid_range(&attr, span, target)\n+                }\n+                sym::allow_internal_unstable => {\n+                    self.check_allow_internal_unstable(hir_id, &attr, span, target, &attrs)\n+                }\n+                sym::rustc_allow_const_fn_unstable => {\n+                    self.check_rustc_allow_const_fn_unstable(hir_id, &attr, span, target)\n+                }\n+                sym::naked => self.check_naked(hir_id, attr, span, target),\n+                sym::rustc_legacy_const_generics => {\n+                    self.check_rustc_legacy_const_generics(&attr, span, target, item)\n+                }\n+                sym::rustc_clean\n+                | sym::rustc_dirty\n+                | sym::rustc_if_this_changed\n+                | sym::rustc_then_this_would_need => self.check_rustc_dirty_clean(&attr),\n+                _ => true,\n             };\n+            // lint-only checks\n+            match attr.name_or_empty() {\n+                sym::cold => self.check_cold(hir_id, attr, span, target),\n+                sym::link_name => self.check_link_name(hir_id, attr, span, target),\n+                sym::link_section => self.check_link_section(hir_id, attr, span, target),\n+                sym::no_mangle => self.check_no_mangle(hir_id, attr, span, target),\n+                _ => {}\n+            }\n         }\n \n         if !is_valid {\n@@ -1116,7 +1109,7 @@ impl CheckAttrVisitor<'tcx> {\n         // ```\n         let hints: Vec<_> = attrs\n             .iter()\n-            .filter(|attr| self.tcx.sess.check_name(attr, sym::repr))\n+            .filter(|attr| attr.has_name(sym::repr))\n             .filter_map(|attr| attr.meta_item_list())\n             .flatten()\n             .collect();\n@@ -1287,7 +1280,7 @@ impl CheckAttrVisitor<'tcx> {\n \n     fn check_used(&self, attrs: &'hir [Attribute], target: Target) {\n         for attr in attrs {\n-            if self.tcx.sess.check_name(attr, sym::used) && target != Target::Static {\n+            if attr.has_name(sym::used) && target != Target::Static {\n                 self.tcx\n                     .sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");"}]}