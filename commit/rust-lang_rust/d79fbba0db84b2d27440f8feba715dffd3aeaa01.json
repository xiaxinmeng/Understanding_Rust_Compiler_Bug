{"sha": "d79fbba0db84b2d27440f8feba715dffd3aeaa01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3OWZiYmEwZGI4NGIyZDI3NDQwZjhmZWJhNzE1ZGZmZDNhZWFhMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-30T01:56:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-30T01:56:36Z"}, "message": "auto merge of #13203 : Kimundi/rust/de-map-vec3, r=cmr\n\nThey required unnecessary temporaries, are replaced with iterators, and would conflict with a possible future `Iterable` trait.", "tree": {"sha": "d5f8701b97fcf2fc596a52215ad96462c1eb981e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5f8701b97fcf2fc596a52215ad96462c1eb981e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d79fbba0db84b2d27440f8feba715dffd3aeaa01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d79fbba0db84b2d27440f8feba715dffd3aeaa01", "html_url": "https://github.com/rust-lang/rust/commit/d79fbba0db84b2d27440f8feba715dffd3aeaa01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d79fbba0db84b2d27440f8feba715dffd3aeaa01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86890b9e7c5db28ac2da5cd63d1a51d63a5e6bec", "url": "https://api.github.com/repos/rust-lang/rust/commits/86890b9e7c5db28ac2da5cd63d1a51d63a5e6bec", "html_url": "https://github.com/rust-lang/rust/commit/86890b9e7c5db28ac2da5cd63d1a51d63a5e6bec"}, {"sha": "c356e3ba6a12c3294a9a428ef9120cff9306bf4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c356e3ba6a12c3294a9a428ef9120cff9306bf4b", "html_url": "https://github.com/rust-lang/rust/commit/c356e3ba6a12c3294a9a428ef9120cff9306bf4b"}], "stats": {"total": 603, "additions": 278, "deletions": 325}, "files": [{"sha": "e15145e5f1d3421fe55dfea317115266e05f6ced", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -1764,7 +1764,10 @@ access local variables in the enclosing scope.\n \n ~~~~\n let mut max = 0;\n-[1, 2, 3].map(|x| if *x > max { max = *x });\n+let f = |x: int| if x > max { max = x };\n+for x in [1, 2, 3].iter() {\n+    f(*x);\n+}\n ~~~~\n \n Stack closures are very efficient because their environment is"}, {"sha": "b0f2495e98c4d86f69346a0a5b938a6bb6480ab0", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -597,7 +597,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: proc:(**libc::c_char) -> T) -> T\n     // Next, convert each of the byte strings into a pointer. This is\n     // technically unsafe as the caller could leak these pointers out of our\n     // scope.\n-    let mut ptrs = tmps.map(|tmp| tmp.with_ref(|buf| buf));\n+    let mut ptrs: Vec<_> = tmps.iter().map(|tmp| tmp.with_ref(|buf| buf)).collect();\n \n     // Finally, make sure we add a null pointer.\n     ptrs.push(ptr::null());\n@@ -622,7 +622,9 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: proc:(*c_void) -> T) -> T {\n             }\n \n             // Once again, this is unsafe.\n-            let mut ptrs = tmps.map(|tmp| tmp.with_ref(|buf| buf));\n+            let mut ptrs: Vec<*libc::c_char> = tmps.iter()\n+                                                   .map(|tmp| tmp.with_ref(|buf| buf))\n+                                                   .collect();\n             ptrs.push(ptr::null());\n \n             cb(ptrs.as_ptr() as *c_void)"}, {"sha": "674f5e77cc084135b1720426331fb73201437c1b", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -69,8 +69,8 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     }\n \n     // Internalize everything but the reachable symbols of the current module\n-    let cstrs = reachable.map(|s| s.to_c_str());\n-    let arr = cstrs.map(|c| c.with_ref(|p| p));\n+    let cstrs: Vec<::std::c_str::CString> = reachable.iter().map(|s| s.to_c_str()).collect();\n+    let arr: Vec<*i8> = cstrs.iter().map(|c| c.with_ref(|p| p)).collect();\n     let ptr = arr.as_ptr();\n     unsafe {\n         llvm::LLVMRustRunRestrictionPass(llmod, ptr as **libc::c_char,"}, {"sha": "8328d5faa543ea9d45066bee2e8888610c19f2ee", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -943,9 +943,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> session::Options {\n         NoDebugInfo\n     };\n \n-    let addl_lib_search_paths = matches.opt_strs(\"L\").map(|s| {\n+    let addl_lib_search_paths = matches.opt_strs(\"L\").iter().map(|s| {\n         Path::new(s.as_slice())\n-    }).move_iter().collect();\n+    }).collect();\n \n     let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\").move_iter().collect());\n     let test = matches.opt_present(\"test\");"}, {"sha": "6f20e46a6effce8d03443fc870ac1596e6de1b05", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -1861,7 +1861,7 @@ impl TypeNames {\n     }\n \n     pub fn types_to_str(&self, tys: &[Type]) -> ~str {\n-        let strs = tys.map(|t| self.type_to_str(*t));\n+        let strs: Vec<~str> = tys.iter().map(|t| self.type_to_str(*t)).collect();\n         format!(\"[{}]\", strs.connect(\",\"))\n     }\n "}, {"sha": "5313473739ff7ce25e02b1c40ff5e65ebdde3d6f", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -200,9 +200,9 @@ pub fn get_rust_path() -> Option<~str> {\n pub fn rust_path() -> Vec<Path> {\n     let mut env_rust_path: Vec<Path> = match get_rust_path() {\n         Some(env_path) => {\n-            let env_path_components: Vec<&str> =\n-                env_path.split_str(PATH_ENTRY_SEPARATOR).collect();\n-            env_path_components.map(|&s| Path::new(s))\n+            let env_path_components =\n+                env_path.split_str(PATH_ENTRY_SEPARATOR);\n+            env_path_components.map(|s| Path::new(s)).collect()\n         }\n         None => Vec::new()\n     };"}, {"sha": "8f1a9270047ad97189f2cac4a63d37831c4ef1a5", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -163,7 +163,7 @@ fn raw_pat(p: @Pat) -> @Pat {\n \n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n     assert!((!pats.is_empty()));\n-    let ext = match is_useful(cx, &pats.map(|p| vec!(*p)), [wild()]) {\n+    let ext = match is_useful(cx, &pats.iter().map(|p| vec!(*p)).collect(), [wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable\n             return;\n@@ -692,12 +692,12 @@ fn specialize(cx: &MatchCheckCtxt,\n                     DefVariant(_, variant_id, _) => {\n                         if variant(variant_id) == *ctor_id {\n                             let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n-                            let args = struct_fields.map(|sf| {\n+                            let args = struct_fields.iter().map(|sf| {\n                                 match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n                                     Some(f) => f.pat,\n                                     _ => wild()\n                                 }\n-                            });\n+                            }).collect();\n                             Some(vec::append(args, r.tail()))\n                         } else {\n                             None"}, {"sha": "5eb90f770dd5fe5818815d5f3662220d0cd99db7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -4707,18 +4707,20 @@ impl<'a> Resolver<'a> {\n                                         path: &Path,\n                                         namespace: Namespace)\n                                         -> Option<(Def, LastPrivate)> {\n-        let module_path_idents = path.segments.init().map(|ps| ps.identifier);\n+        let module_path_idents = path.segments.init().iter()\n+                                                     .map(|ps| ps.identifier)\n+                                                     .collect::<Vec<_>>();\n \n         let containing_module;\n         let last_private;\n         match self.resolve_module_path(self.current_module,\n-                                       module_path_idents,\n+                                       module_path_idents.as_slice(),\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n             Failed => {\n                 let msg = format!(\"use of undeclared module `{}`\",\n-                                  self.idents_to_str(module_path_idents));\n+                                  self.idents_to_str(module_path_idents.as_slice()));\n                 self.resolve_error(path.span, msg);\n                 return None;\n             }\n@@ -4772,21 +4774,23 @@ impl<'a> Resolver<'a> {\n                                    path: &Path,\n                                    namespace: Namespace)\n                                        -> Option<(Def, LastPrivate)> {\n-        let module_path_idents = path.segments.init().map(|ps| ps.identifier);\n+        let module_path_idents = path.segments.init().iter()\n+                                                     .map(|ps| ps.identifier)\n+                                                     .collect::<Vec<_>>();\n \n         let root_module = self.graph_root.get_module();\n \n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 module_path_idents,\n+                                                 module_path_idents.as_slice(),\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n                                                  LastMod(AllPublic)) {\n             Failed => {\n                 let msg = format!(\"use of undeclared module `::{}`\",\n-                                  self.idents_to_str(module_path_idents));\n+                                  self.idents_to_str(module_path_idents.as_slice()));\n                 self.resolve_error(path.span, msg);\n                 return None;\n             }"}, {"sha": "8f4c8c84b68643220b0769a1642f6150e2a10417", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -216,7 +216,7 @@ impl<'a> LifetimeContext<'a> {\n                referenced_idents={:?} \\\n                early_count={}\",\n                n,\n-               referenced_idents.map(lifetime_show),\n+               referenced_idents.iter().map(lifetime_show).collect::<Vec<token::InternedString>>(),\n                early_count);\n         if referenced_idents.is_empty() {\n             let scope1 = LateScope(n, &generics.lifetimes, scope);"}, {"sha": "7500c23e006a2e69de06860cd56a2182815e68df", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -134,7 +134,7 @@ impl<T:Subst> Subst for Vec<T> {\n     fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Vec<T> {\n-        self.map(|t| t.subst_spanned(tcx, substs, span))\n+        self.iter().map(|t| t.subst_spanned(tcx, substs, span)).collect()\n     }\n }\n impl<T:Subst> Subst for Rc<T> {\n@@ -189,7 +189,7 @@ impl Subst for ty::substs {\n         ty::substs {\n             regions: self.regions.subst_spanned(tcx, substs, span),\n             self_ty: self.self_ty.map(|typ| typ.subst_spanned(tcx, substs, span)),\n-            tps: self.tps.map(|typ| typ.subst_spanned(tcx, substs, span))\n+            tps: self.tps.iter().map(|typ| typ.subst_spanned(tcx, substs, span)).collect()\n         }\n     }\n }"}, {"sha": "b7a8052fdb917ad6dfd3b6725c90dd6da3cb15e3", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -1578,10 +1578,10 @@ fn compile_submatch_continue<'r,\n             let pat_ty = node_id_type(bcx, pat_id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             expr::with_field_tys(tcx, pat_ty, Some(pat_id), |discr, field_tys| {\n-                let rec_vals = rec_fields.map(|field_name| {\n+                let rec_vals = rec_fields.iter().map(|field_name| {\n                         let ix = ty::field_idx_strict(tcx, field_name.name, field_tys);\n                         adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n-                        });\n+                        }).collect();\n                 compile_submatch(\n                         bcx,\n                         enter_rec_or_struct(bcx,"}, {"sha": "3b28549ed4cee74865a3026688d3de9e71d26770", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -136,9 +136,9 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n-            let mut ftys = fields.map(|field| {\n+            let mut ftys = fields.iter().map(|field| {\n                 ty::lookup_field_type(cx.tcx(), def_id, field.id, substs)\n-            });\n+            }).collect::<Vec<_>>();\n             let packed = ty::lookup_packed(cx.tcx(), def_id);\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n@@ -158,7 +158,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n \n             if cases.iter().all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n-                let discrs = cases.map(|c| c.discr);\n+                let discrs: Vec<u64> = cases.iter().map(|c| c.discr).collect();\n                 let bounds = IntBounds {\n                     ulo: *discrs.iter().min().unwrap(),\n                     uhi: *discrs.iter().max().unwrap(),\n@@ -218,12 +218,12 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n             let ity = range_to_inttype(cx, hint, &bounds);\n-            return General(ity, cases.map(|c| {\n+            return General(ity, cases.iter().map(|c| {\n                 let discr = vec!(ty_of_inttype(ity));\n                 mk_struct(cx,\n                           vec::append(discr, c.tys.as_slice()).as_slice(),\n                           false)\n-            }))\n+            }).collect())\n         }\n         _ => cx.sess().bug(\"adt::represent_type called on non-ADT type\")\n     }\n@@ -270,18 +270,18 @@ impl Case {\n }\n \n fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Case> {\n-    ty::enum_variants(tcx, def_id).map(|vi| {\n-        let arg_tys = vi.args.map(|&raw_ty| {\n+    ty::enum_variants(tcx, def_id).iter().map(|vi| {\n+        let arg_tys = vi.args.iter().map(|&raw_ty| {\n             ty::subst(tcx, substs, raw_ty)\n-        });\n+        }).collect();\n         Case { discr: vi.disr_val, tys: arg_tys }\n-    })\n+    }).collect()\n }\n \n \n fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n-    let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n-    let llty_rec = Type::struct_(cx, lltys, packed);\n+    let lltys = tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n+    let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n@@ -464,9 +464,9 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n \n fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> Vec<Type> {\n     if sizing {\n-        st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n+        st.fields.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        st.fields.map(|&ty| type_of::type_of(cx, ty))\n+        st.fields.iter().map(|&ty| type_of::type_of(cx, ty)).collect()\n     }\n }\n \n@@ -700,7 +700,7 @@ fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n     let ccx = bcx.ccx();\n \n     let val = if needs_cast {\n-        let fields = st.fields.map(|&ty| type_of::type_of(ccx, ty));\n+        let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n         let real_ty = Type::struct_(ccx, fields.as_slice(), st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n@@ -773,11 +773,11 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n                                                  vals).as_slice(),\n                          false)\n             } else {\n-                let vals = nonnull.fields.map(|&ty| {\n+                let vals = nonnull.fields.iter().map(|&ty| {\n                     // Always use null even if it's not the `ptrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n-                }).move_iter().collect::<Vec<ValueRef> >();\n+                }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n                                                  vals.as_slice()).as_slice(),"}, {"sha": "5c32b3fba4494955a99381d42c8fe13feaa10314", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -36,17 +36,17 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     let temp_scope = fcx.push_custom_cleanup_scope();\n \n     // Prepare the output operands\n-    let outputs = ia.outputs.map(|&(ref c, out)| {\n+    let outputs = ia.outputs.iter().map(|&(ref c, out)| {\n         constraints.push((*c).clone());\n \n         let out_datum = unpack_datum!(bcx, expr::trans(bcx, out));\n         output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n         out_datum.val\n \n-    });\n+    }).collect::<Vec<_>>();\n \n     // Now the input operands\n-    let inputs = ia.inputs.map(|&(ref c, input)| {\n+    let inputs = ia.inputs.iter().map(|&(ref c, input)| {\n         constraints.push((*c).clone());\n \n         let in_datum = unpack_datum!(bcx, expr::trans(bcx, input));\n@@ -57,12 +57,15 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n                                    cleanup::CustomScope(temp_scope),\n                                    callee::DontAutorefArg)\n         })\n-    });\n+    }).collect::<Vec<_>>();\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    let mut constraints = constraints.map(|s| s.get().to_str()).connect(\",\");\n+    let mut constraints = constraints.iter()\n+                                     .map(|s| s.get().to_str())\n+                                     .collect::<Vec<~str>>()\n+                                     .connect(\",\");\n \n     let mut clobbers = getClobbers();\n     if !ia.clobbers.get().is_empty() && !clobbers.is_empty() {"}, {"sha": "c7c0d51b3abd8d400f332598ec21280e7e62b79d", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -121,7 +121,7 @@ pub fn Invoke(cx: &Block,\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke({} with arguments ({}))\",\n            cx.val_to_str(fn_),\n-           args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n+           args.iter().map(|a| cx.val_to_str(*a)).collect::<Vec<~str>>().connect(\", \"));\n     B(cx).invoke(fn_, args, then, catch, attributes)\n }\n "}, {"sha": "ff74fac95ff403f6e0d004cafe2e4f506f4f3a04", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -780,13 +780,13 @@ impl<'a> Builder<'a> {\n         let alignstack = if alignstack { lib::llvm::True }\n                          else          { lib::llvm::False };\n \n-        let argtys = inputs.map(|v| {\n+        let argtys = inputs.iter().map(|v| {\n             debug!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_str(*v));\n             val_ty(*v)\n-        });\n+        }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_str(output));\n-        let fty = Type::func(argtys, &output);\n+        let fty = Type::func(argtys.as_slice(), &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n@@ -800,7 +800,10 @@ impl<'a> Builder<'a> {\n \n         debug!(\"Call {} with args ({})\",\n                self.ccx.tn.val_to_str(llfn),\n-               args.map(|&v| self.ccx.tn.val_to_str(v)).connect(\", \"));\n+               args.iter()\n+                   .map(|&v| self.ccx.tn.val_to_str(v))\n+                   .collect::<Vec<~str>>()\n+                   .connect(\", \"));\n \n         unsafe {\n             let v = llvm::LLVMBuildCall(self.llbuilder, llfn, args.as_ptr(),"}, {"sha": "81a6b401d7aa9db67ad2ca3630a43b339063c9d3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -816,7 +816,10 @@ pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n     if !params.iter().all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n             format!(\"type parameters for node {:?} include inference types: {}\",\n-                 node, params.map(|t| bcx.ty_to_str(*t)).connect(\",\")));\n+                 node, params.iter()\n+                             .map(|t| bcx.ty_to_str(*t))\n+                             .collect::<Vec<~str>>()\n+                             .connect(\",\")));\n     }\n \n     match bcx.fcx.param_substs {"}, {"sha": "a35dcaf868b2fe74ec7864565e0975df2ebc770e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -733,7 +733,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         source_locations_enabled: Cell::new(false),\n     };\n \n-    let arg_pats = fn_decl.inputs.map(|arg_ref| arg_ref.pat);\n+    let arg_pats = fn_decl.inputs.iter().map(|arg_ref| arg_ref.pat).collect::<Vec<_>>();\n     populate_scope_map(cx,\n                        arg_pats.as_slice(),\n                        top_level_block,\n@@ -1218,7 +1218,7 @@ struct StructMemberDescriptionFactory {\n impl StructMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> Vec<MemberDescription> {\n-        self.fields.map(|field| {\n+        self.fields.iter().map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n                 ~\"\"\n             } else {\n@@ -1231,7 +1231,7 @@ impl StructMemberDescriptionFactory {\n                 type_metadata: type_metadata(cx, field.mt.ty, self.span),\n                 offset: ComputedMemberOffset,\n             }\n-        })\n+        }).collect()\n     }\n }\n \n@@ -1321,14 +1321,14 @@ struct TupleMemberDescriptionFactory {\n impl TupleMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> Vec<MemberDescription> {\n-        self.component_types.map(|&component_type| {\n+        self.component_types.iter().map(|&component_type| {\n             MemberDescription {\n                 name: ~\"\",\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n                 offset: ComputedMemberOffset,\n             }\n-        })\n+        }).collect()\n     }\n }\n \n@@ -1443,7 +1443,9 @@ fn describe_enum_variant(cx: &CrateContext,\n                       -> (DICompositeType, Type, MemberDescriptionFactory) {\n     let variant_llvm_type =\n         Type::struct_(cx, struct_def.fields\n+                                    .iter()\n                                     .map(|&t| type_of::type_of(cx, t))\n+                                    .collect::<Vec<_>>()\n                                     .as_slice(),\n                       struct_def.packed);\n     // Could some consistency checks here: size, align, field count, discr type\n@@ -1464,11 +1466,11 @@ fn describe_enum_variant(cx: &CrateContext,\n                                            variant_definition_span);\n \n     // Get the argument names from the enum variant info\n-    let mut arg_names = match variant_info.arg_names {\n+    let mut arg_names: Vec<_> = match variant_info.arg_names {\n         Some(ref names) => {\n-            names.map(|ident| token::get_ident(*ident).get().to_str())\n+            names.iter().map(|ident| token::get_ident(*ident).get().to_str()).collect()\n         }\n-        None => variant_info.args.map(|_| ~\"\")\n+        None => variant_info.args.iter().map(|_| ~\"\").collect()\n     };\n \n     // If this is not a univariant enum, there is also the (unnamed) discriminant field"}, {"sha": "bd8c84e85e57be61d39f1898bf71c9d59d861dda", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -994,7 +994,7 @@ fn trans_rec_or_struct<'a>(\n     with_field_tys(tcx, ty, Some(id), |discr, field_tys| {\n         let mut need_base = slice::from_elem(field_tys.len(), true);\n \n-        let numbered_fields = fields.map(|field| {\n+        let numbered_fields = fields.iter().map(|field| {\n             let opt_pos =\n                 field_tys.iter().position(|field_ty|\n                                           field_ty.ident.name == field.ident.node.name);\n@@ -1008,7 +1008,7 @@ fn trans_rec_or_struct<'a>(\n                                       \"Couldn't find field in struct type\")\n                 }\n             }\n-        });\n+        }).collect::<Vec<_>>();\n         let optbase = match base {\n             Some(base_expr) => {\n                 let mut leftovers = Vec::new();\n@@ -1029,7 +1029,7 @@ fn trans_rec_or_struct<'a>(\n         };\n \n         let repr = adt::represent_type(bcx.ccx(), ty);\n-        trans_adt(bcx, repr, discr, numbered_fields, optbase, dest)\n+        trans_adt(bcx, repr, discr, numbered_fields.as_slice(), optbase, dest)\n     })\n }\n "}, {"sha": "158589393efd2ac763ade6020df5c8fcfc57e158", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -851,7 +851,7 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n            ty.repr(ccx.tcx()),\n            ccx.tn.types_to_str(llsig.llarg_tys.as_slice()),\n            ccx.tn.type_to_str(llsig.llret_ty),\n-           ccx.tn.types_to_str(fn_ty.arg_tys.map(|t| t.ty).as_slice()),\n+           ccx.tn.types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n            ccx.tn.type_to_str(fn_ty.ret_ty.ty),\n            ret_def);\n "}, {"sha": "c84e4db768696156f0d3e6d91e2265a98121d23d", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -18,7 +18,7 @@ pub trait LlvmRepr {\n \n impl<'a, T:LlvmRepr> LlvmRepr for &'a [T] {\n     fn llrepr(&self, ccx: &CrateContext) -> ~str {\n-        let reprs = self.map(|t| t.llrepr(ccx));\n+        let reprs: Vec<~str> = self.iter().map(|t| t.llrepr(ccx)).collect();\n         format!(\"[{}]\", reprs.connect(\",\"))\n     }\n }"}, {"sha": "ac787a1847871d5f5715502a90ec8ab67eac6d1a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -541,7 +541,7 @@ fn emit_vtable_methods(bcx: &Block,\n     ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n \n     let trait_method_def_ids = ty::trait_method_def_ids(tcx, trt_id);\n-    trait_method_def_ids.map(|method_def_id| {\n+    trait_method_def_ids.iter().map(|method_def_id| {\n         let ident = ty::method(tcx, *method_def_id).ident;\n         // The substitutions we have are on the impl, so we grab\n         // the method type from the impl to substitute into.\n@@ -558,7 +558,7 @@ fn emit_vtable_methods(bcx: &Block,\n         } else {\n             trans_fn_ref_with_vtables(bcx, m_id, ExprId(0), substs, Some(vtables))\n         }\n-    })\n+    }).collect()\n }\n \n pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,"}, {"sha": "179fda7cc4673978a45e2570a92ec13856df2fa4", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -298,7 +298,7 @@ pub fn make_mono_id(ccx: &CrateContext,\n                vts.repr(ccx.tcx()), substs.tys.repr(ccx.tcx()));\n         let vts_iter = substs.self_vtables.iter().chain(vts.iter());\n         vts_iter.zip(substs_iter).map(|(vtable, subst)| {\n-            let v = vtable.map(|vt| meth::vtable_id(ccx, vt));\n+            let v = vtable.iter().map(|vt| meth::vtable_id(ccx, vt)).collect::<Vec<_>>();\n             (*subst, if !v.is_empty() { Some(@v) } else { None })\n         }).collect()\n       }"}, {"sha": "350ee411029f6f20f8e611a53908aa945380368a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -1408,14 +1408,14 @@ pub fn mk_ctor_fn(cx: &ctxt,\n                   binder_id: ast::NodeId,\n                   input_tys: &[ty::t],\n                   output: ty::t) -> t {\n-    let input_args = input_tys.map(|t| *t);\n+    let input_args = input_tys.iter().map(|t| *t).collect();\n     mk_bare_fn(cx,\n                BareFnTy {\n                    purity: ast::ImpureFn,\n                    abis: AbiSet::Rust(),\n                    sig: FnSig {\n                     binder_id: binder_id,\n-                    inputs: Vec::from_slice(input_args),\n+                    inputs: input_args,\n                     output: output,\n                     variadic: false\n                    }\n@@ -2880,7 +2880,7 @@ pub fn replace_closure_return_type(tcx: &ctxt, fn_type: t, ret_type: t) -> t {\n \n // Returns a vec of all the input and output types of fty.\n pub fn tys_in_fn_sig(sig: &FnSig) -> Vec<t> {\n-    vec::append_one(sig.inputs.map(|a| *a), sig.output)\n+    vec::append_one(sig.inputs.iter().map(|a| *a).collect(), sig.output)\n }\n \n // Type accessors for AST nodes\n@@ -3432,7 +3432,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n     tcx.sess.bug(format!(\n         \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n-        fields.map(|f| token::get_ident(f.ident).get().to_str())));\n+        fields.iter().map(|f| token::get_ident(f.ident).get().to_str()).collect::<Vec<~str>>()));\n }\n \n pub fn method_idx(id: ast::Ident, meths: &[@Method]) -> Option<uint> {\n@@ -3724,8 +3724,8 @@ pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n \n pub fn trait_ref_supertraits(cx: &ctxt, trait_ref: &ty::TraitRef) -> Vec<@TraitRef> {\n     let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n-    supertrait_refs.map(\n-        |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs))\n+    supertrait_refs.iter().map(\n+        |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs)).collect()\n }\n \n fn lookup_locally_or_in_crate_store<V:Clone>(\n@@ -3768,7 +3768,7 @@ pub fn trait_methods(cx: &ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n         Some(&methods) => methods,\n         None => {\n             let def_ids = ty::trait_method_def_ids(cx, trait_did);\n-            let methods = @def_ids.map(|d| ty::method(cx, *d));\n+            let methods = @def_ids.iter().map(|d| ty::method(cx, *d)).collect();\n             trait_methods.insert(trait_did, methods);\n             methods\n         }\n@@ -3876,7 +3876,7 @@ impl VariantInfo {\n         match ast_variant.node.kind {\n             ast::TupleVariantKind(ref args) => {\n                 let arg_tys = if args.len() > 0 {\n-                    ty_fn_args(ctor_ty).map(|a| *a)\n+                    ty_fn_args(ctor_ty).iter().map(|a| *a).collect()\n                 } else {\n                     Vec::new()\n                 };\n@@ -3897,7 +3897,7 @@ impl VariantInfo {\n \n                 assert!(fields.len() > 0);\n \n-                let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n+                let arg_tys = ty_fn_args(ctor_ty).iter().map(|a| *a).collect();\n                 let arg_names = fields.iter().map(|field| {\n                     match field.node.kind {\n                         NamedField(ident, _) => ident,\n@@ -4280,7 +4280,7 @@ fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n // this. Takes a list of substs with which to instantiate field types.\n pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &substs)\n                      -> Vec<field> {\n-    lookup_struct_fields(cx, did).map(|f| {\n+    lookup_struct_fields(cx, did).iter().map(|f| {\n        field {\n             // FIXME #6993: change type of field to Name and get rid of new()\n             ident: ast::Ident::new(f.name),\n@@ -4289,7 +4289,7 @@ pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &substs)\n                 mutbl: MutImmutable\n             }\n         }\n-    })\n+    }).collect()\n }\n \n pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {"}, {"sha": "5d2d221a774e013ba5e50e72332019c614cb8180", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -167,8 +167,8 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     let expected_num_region_params = decl_generics.region_param_defs().len();\n     let supplied_num_region_params = path.segments.last().unwrap().lifetimes.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n-        path.segments.last().unwrap().lifetimes.map(\n-            |l| ast_region_to_region(this.tcx(), l))\n+        path.segments.last().unwrap().lifetimes.iter().map(\n+            |l| ast_region_to_region(this.tcx(), l)).collect::<Vec<_>>()\n     } else {\n         let anon_regions =\n             rscope.anon_regions(path.span, expected_num_region_params);"}, {"sha": "38cb48a6c7c2449b191785b8a252333fca3d8031", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -147,7 +147,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                         let vinfo =\n                             ty::enum_variant_with_id(tcx, enm, var);\n                         let var_tpt = ty::lookup_item_type(tcx, var);\n-                        vinfo.args.map(|t| {\n+                        vinfo.args.iter().map(|t| {\n                             if var_tpt.generics.type_param_defs().len() ==\n                                 expected_substs.tps.len()\n                             {\n@@ -157,7 +157,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                                 *t // In this case, an error was already signaled\n                                     // anyway\n                             }\n-                        })\n+                        }).collect()\n                     };\n \n                     kind_name = \"variant\";\n@@ -209,7 +209,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n             // Get the expected types of the arguments.\n             let class_fields = ty::struct_fields(\n                 tcx, struct_def_id, expected_substs);\n-            arg_types = class_fields.map(|field| field.mt.ty);\n+            arg_types = class_fields.iter().map(|field| field.mt.ty).collect();\n \n             kind_name = \"structure\";\n         }"}, {"sha": "5a5e9ee094154fc5f6cb2a09b59a3ded55fa94b9", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -659,7 +659,10 @@ impl<'a> LookupContext<'a> {\n         debug!(\"push_candidates_from_impl: {} {} {}\",\n                token::get_name(self.m_name),\n                impl_info.ident.repr(self.tcx()),\n-               impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n+               impl_info.methods.iter()\n+                                .map(|m| m.ident)\n+                                .collect::<Vec<ast::Ident>>()\n+                                .repr(self.tcx()));\n \n         let idx = {\n             match impl_info.methods"}, {"sha": "4b611dd5ddfe721c7291341be82bc1e9f42fc9a9", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -449,7 +449,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={:?}, ret_ty={:?})\",\n-           arg_tys.map(|&a| ppaux::ty_to_str(tcx, a)),\n+           arg_tys.iter().map(|&a| ppaux::ty_to_str(tcx, a)).collect::<Vec<~str>>(),\n            ppaux::ty_to_str(tcx, ret_ty));\n \n     // Create the function context.  This is either derived from scratch or,\n@@ -1717,7 +1717,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         debug!(\"check_argument_types: formal_tys={:?}\",\n-               formal_tys.map(|t| fcx.infcx().ty_to_str(*t)));\n+               formal_tys.iter().map(|t| fcx.infcx().ty_to_str(*t)).collect::<Vec<~str>>());\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n@@ -1886,10 +1886,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                 expr.span,\n                                                 fcx.expr_ty(rcvr));\n \n-        let tps = tps.map(|&ast_ty| fcx.to_ty(ast_ty));\n+        let tps = tps.iter().map(|&ast_ty| fcx.to_ty(ast_ty)).collect::<Vec<_>>();\n         let fn_ty = match method::lookup(fcx, expr, rcvr,\n                                          method_name.name,\n-                                         expr_t, tps,\n+                                         expr_t, tps.as_slice(),\n                                          DontDerefArgs,\n                                          CheckTraitsAndInherentMethods,\n                                          AutoderefReceiver) {\n@@ -2235,7 +2235,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let fty = if error_happened {\n             fty_sig = FnSig {\n                 binder_id: ast::CRATE_NODE_ID,\n-                inputs: fn_ty.sig.inputs.map(|_| ty::mk_err()),\n+                inputs: fn_ty.sig.inputs.iter().map(|_| ty::mk_err()).collect(),\n                 output: ty::mk_err(),\n                 variadic: false\n             };\n@@ -2938,11 +2938,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n         check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice());\n-        let arg_tys = args.map(|a| fcx.expr_ty(*a));\n-        let (args_bot, args_err) = arg_tys.iter().fold((false, false),\n+        let mut arg_tys = args.iter().map(|a| fcx.expr_ty(*a));\n+        let (args_bot, args_err) = arg_tys.fold((false, false),\n              |(rest_bot, rest_err), a| {\n-              (rest_bot || ty::type_is_bot(*a),\n-               rest_err || ty::type_is_error(*a))});\n+              (rest_bot || ty::type_is_bot(a),\n+               rest_err || ty::type_is_error(a))});\n         if args_err {\n             fcx.write_error(id);\n         } else if args_bot {\n@@ -3686,8 +3686,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n     let num_expected_regions = tpt.generics.region_param_defs().len();\n     let num_supplied_regions = pth.segments.last().unwrap().lifetimes.len();\n     let regions = if num_expected_regions == num_supplied_regions {\n-        OwnedSlice::from_vec(pth.segments.last().unwrap().lifetimes.map(\n-            |l| ast_region_to_region(fcx.tcx(), l)))\n+        OwnedSlice::from_vec(pth.segments.last().unwrap().lifetimes.iter().map(\n+            |l| ast_region_to_region(fcx.tcx(), l)).collect())\n     } else {\n         if num_supplied_regions != 0 {\n             fcx.ccx.tcx.sess.span_err("}, {"sha": "7159febc7f1074b402df399d0c30dd6d9de0f147", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -113,7 +113,7 @@ fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, vtable_key: MethodCall) {\n \n     fn resolve_origins(fcx: &FnCtxt, sp: Span,\n                        vtbls: vtable_res) -> vtable_res {\n-        @vtbls.map(|os| @os.map(|origin| {\n+        @vtbls.iter().map(|os| @os.iter().map(|origin| {\n             match origin {\n                 &vtable_static(def_id, ref tys, origins) => {\n                     let r_tys = resolve_type_vars_in_types(fcx,\n@@ -126,7 +126,7 @@ fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, vtable_key: MethodCall) {\n                     vtable_param(n, b)\n                 }\n             }\n-        }))\n+        }).collect()).collect()\n     }\n }\n "}, {"sha": "dfde5b1d874e55494e7ac709fb3c25691f5821e8", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -152,7 +152,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         let result_ty = match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n-                let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n+                let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, va.ty)).collect();\n                 ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n             }\n \n@@ -168,8 +168,8 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n                 convert_struct(ccx, struct_def, tpt, variant.node.id);\n \n-                let input_tys = struct_def.fields.map(\n-                    |f| ty::node_id_to_type(ccx.tcx, f.node.id));\n+                let input_tys: Vec<_> = struct_def.fields.iter().map(\n+                    |f| ty::node_id_to_type(ccx.tcx, f.node.id)).collect();\n                 ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n             }\n         };\n@@ -222,7 +222,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                     }\n \n                     // Add an entry mapping\n-                    let method_def_ids = @ms.map(|m| {\n+                    let method_def_ids = @ms.iter().map(|m| {\n                         match m {\n                             &ast::Required(ref ty_method) => {\n                                 local_def(ty_method.id)\n@@ -231,13 +231,11 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                 local_def(method.id)\n                             }\n                         }\n-                    });\n+                    }).collect();\n \n                     let trait_def_id = local_def(trait_id);\n                     tcx.trait_method_def_ids.borrow_mut()\n-                        .insert(trait_def_id, @method_def_ids.iter()\n-                                                             .map(|x| *x)\n-                                                             .collect());\n+                        .insert(trait_def_id, method_def_ids);\n                 }\n                 _ => {} // Ignore things that aren't traits.\n             }\n@@ -697,9 +695,9 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id), tpt);\n             } else if struct_def.fields.get(0).node.kind.is_unnamed() {\n                 // Tuple-like.\n-                let inputs = struct_def.fields.map(\n+                let inputs: Vec<_> = struct_def.fields.iter().map(\n                         |field| tcx.tcache.borrow().get(\n-                            &local_def(field.node.id)).ty);\n+                            &local_def(field.node.id)).ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 ctor_id,\n                                                 inputs.as_slice(),"}, {"sha": "7daf03d8526407ffb03c5cb19cffc4dabdb18e1a", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -683,7 +683,7 @@ impl<'a> InferCtxt<'a> {\n     }\n \n     pub fn tys_to_str(&self, ts: &[ty::t]) -> ~str {\n-        let tstrs = ts.map(|t| self.ty_to_str(*t));\n+        let tstrs: Vec<~str> = ts.iter().map(|t| self.ty_to_str(*t)).collect();\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n "}, {"sha": "4d6d2da18bf1e6e1b6f07e1f1334e7db2fd2cd87", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -1164,8 +1164,14 @@ impl<'a> RegionVarBindings<'a> {\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                   for var {:?}, lower_bounds={}, upper_bounds={}\",\n                  node_idx,\n-                 lower_bounds.map(|x| x.region).repr(self.tcx),\n-                 upper_bounds.map(|x| x.region).repr(self.tcx)));\n+                 lower_bounds.iter()\n+                             .map(|x| x.region)\n+                             .collect::<Vec<ty::Region>>()\n+                             .repr(self.tcx),\n+                 upper_bounds.iter()\n+                             .map(|x| x.region)\n+                             .collect::<Vec<ty::Region>>()\n+                             .repr(self.tcx)));\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1209,7 +1215,10 @@ impl<'a> RegionVarBindings<'a> {\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                   for var {:?}, upper_bounds={}\",\n                  node_idx,\n-                 upper_bounds.map(|x| x.region).repr(self.tcx)));\n+                 upper_bounds.iter()\n+                             .map(|x| x.region)\n+                             .collect::<Vec<ty::Region>>()\n+                             .repr(self.tcx)));\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "aa0b777a0c0f20322d935f2c8a7f1ee49ae0e9aa", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -32,7 +32,7 @@ impl InferStr for ty::t {\n impl InferStr for FnSig {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         format!(\"({}) -> {}\",\n-             self.inputs.map(|a| a.inf_str(cx)).connect(\", \"),\n+             self.inputs.iter().map(|a| a.inf_str(cx)).collect::<Vec<~str>>().connect(\", \"),\n              self.output.inf_str(cx))\n     }\n }"}, {"sha": "72cc936f23ee3b43a04d482642871fd376e70b7c", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -258,7 +258,7 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n                            substs: Vec<ty::t> ) {\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx({}, {:?})\", node_id,\n-               substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n+               substs.iter().map(|t| ppaux::ty_to_str(tcx, *t)).collect::<Vec<~str>>());\n         assert!(substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n         tcx.node_type_substs.borrow_mut().insert(node_id, substs);"}, {"sha": "bdc27ceab2b2bd9543cda9c5425bdde24a8cd97e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -67,7 +67,7 @@ pub fn indenter() -> _indenter {\n pub fn field_expr(f: ast::Field) -> @ast::Expr { return f.expr; }\n \n pub fn field_exprs(fields: Vec<ast::Field> ) -> Vec<@ast::Expr> {\n-    fields.map(|f| f.expr)\n+    fields.move_iter().map(|f| f.expr).collect()\n }\n \n struct LoopQueryVisitor<'a> {"}, {"sha": "9b76d50a66479f9b2f628588f5b4ff7d710c4ed1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -276,7 +276,7 @@ pub fn vstore_ty_to_str(cx: &ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n }\n \n pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> ~str) -> ~str {\n-    let tstrs = ts.map(f);\n+    let tstrs = ts.iter().map(f).collect::<Vec<~str>>();\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n@@ -405,7 +405,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n                        ket: char,\n                        sig: &ty::FnSig) {\n         s.push_char(bra);\n-        let strs = sig.inputs.map(|a| fn_input_to_str(cx, *a));\n+        let strs: Vec<~str> = sig.inputs.iter().map(|a| fn_input_to_str(cx, *a)).collect();\n         s.push_str(strs.connect(\", \"));\n         if sig.variadic {\n             s.push_str(\", ...\");\n@@ -447,7 +447,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n       }\n       ty_unboxed_vec(ref tm) => { format!(\"unboxed_vec<{}>\", mt_to_str(cx, tm)) }\n       ty_tup(ref elems) => {\n-        let strs = elems.map(|elem| ty_to_str(cx, *elem));\n+        let strs: Vec<~str> = elems.iter().map(|elem| ty_to_str(cx, *elem)).collect();\n         ~\"(\" + strs.connect(\",\") + \")\"\n       }\n       ty_closure(ref f) => {"}, {"sha": "a08776946bc819ce6b6bdab86bfc956462f4a46a", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -314,14 +314,14 @@ pub fn unindent(s: &str) -> ~str {\n \n     if lines.len() >= 1 {\n         let mut unindented = vec!( lines.get(0).trim() );\n-        unindented.push_all(lines.tail().map(|&line| {\n+        unindented.push_all(lines.tail().iter().map(|&line| {\n             if line.is_whitespace() {\n                 line\n             } else {\n                 assert!(line.len() >= min_indent);\n                 line.slice_from(min_indent)\n             }\n-        }));\n+        }).collect::<Vec<_>>().as_slice());\n         unindented.connect(\"\\n\")\n     } else {\n         s.to_owned()"}, {"sha": "949275be7cacc29da22f35b83fc03f5a5cc960e0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -1706,7 +1706,7 @@ impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n }\n \n impl<A:ToJson> ToJson for ~[A] {\n-    fn to_json(&self) -> Json { List(self.map(|elt| elt.to_json())) }\n+    fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n impl<A:ToJson> ToJson for TreeMap<~str, A> {"}, {"sha": "57f7d1834588924e99c9cf4803aac717ff23f5c7", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -285,12 +285,12 @@ impl<'a> AsciiStr for &'a [Ascii] {\n \n     #[inline]\n     fn to_lower(&self) -> ~[Ascii] {\n-        self.map(|a| a.to_lower())\n+        self.iter().map(|a| a.to_lower()).collect()\n     }\n \n     #[inline]\n     fn to_upper(&self) -> ~[Ascii] {\n-        self.map(|a| a.to_upper())\n+        self.iter().map(|a| a.to_upper()).collect()\n     }\n \n     #[inline]"}, {"sha": "bf573bfaed876d977f4278aa8af44635a9b33738", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -19,11 +19,12 @@ getaddrinfo()\n \n #![allow(missing_doc)]\n \n+use iter::Iterator;\n use io::IoResult;\n use io::net::ip::{SocketAddr, IpAddr};\n use option::{Option, Some, None};\n use rt::rtio::{IoFactory, LocalIo};\n-use slice::ImmutableVector;\n+use slice::OwnedVector;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n pub enum SocketType {\n@@ -73,7 +74,7 @@ pub struct Info {\n /// Easy name resolution. Given a hostname, returns the list of IP addresses for\n /// that hostname.\n pub fn get_host_addresses(host: &str) -> IoResult<~[IpAddr]> {\n-    lookup(Some(host), None, None).map(|a| a.map(|i| i.address.ip))\n+    lookup(Some(host), None, None).map(|a| a.move_iter().map(|i| i.address.ip).collect())\n }\n \n /// Full-fleged resolution. This function will perform a synchronous call to"}, {"sha": "4a720aefa4eb6457ca78ab2fe656bd1e4be4f8f5", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 1, "deletions": 80, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -348,16 +348,6 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n \n // Functional utilities\n \n-/**\n- * Apply a function to each element of a vector and return a concatenation\n- * of each result vector\n- */\n-pub fn flat_map<T, U>(v: &[T], f: |t: &T| -> ~[U]) -> ~[U] {\n-    let mut result = ~[];\n-    for elem in v.iter() { result.push_all_move(f(elem)); }\n-    result\n-}\n-\n #[allow(missing_doc)]\n pub trait VectorVector<T> {\n     // FIXME #5898: calling these .concat and .connect conflicts with\n@@ -902,11 +892,7 @@ pub trait ImmutableVector<'a, T> {\n     fn initn(&self, n: uint) -> &'a [T];\n     /// Returns the last element of a vector, or `None` if it is empty.\n     fn last(&self) -> Option<&'a T>;\n-    /**\n-     * Apply a function to each element of a vector and return a concatenation\n-     * of each result vector\n-     */\n-    fn flat_map<U>(&self, f: |t: &T| -> ~[U]) -> ~[U];\n+\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n@@ -935,11 +921,6 @@ pub trait ImmutableVector<'a, T> {\n      */\n     fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n \n-    /// Deprecated, use iterators where possible\n-    /// (`self.iter().map(f)`). Apply a function to each element\n-    /// of a vector and return the results.\n-    fn map<U>(&self, |t: &T| -> U) -> ~[U];\n-\n     /**\n      * Returns a mutable reference to the first element in this slice\n      * and adjusts the slice in place so that it no longer contains\n@@ -1094,11 +1075,6 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n             if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n-    #[inline]\n-    fn flat_map<U>(&self, f: |t: &T| -> ~[U]) -> ~[U] {\n-        flat_map(*self, f)\n-    }\n-\n     #[inline]\n     unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n         transmute(self.repr().data.offset(index as int))\n@@ -1129,10 +1105,6 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n         return None;\n     }\n \n-    fn map<U>(&self, f: |t: &T| -> U) -> ~[U] {\n-        self.iter().map(f).collect()\n-    }\n-\n     fn shift_ref(&mut self) -> Option<&'a T> {\n         if self.len() == 0 { return None; }\n         unsafe {\n@@ -3329,27 +3301,6 @@ mod tests {\n          */\n     }\n \n-    #[test]\n-    fn test_map() {\n-        // Test on-stack map.\n-        let v = &[1u, 2u, 3u];\n-        let mut w = v.map(square_ref);\n-        assert_eq!(w.len(), 3u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 4u);\n-        assert_eq!(w[2], 9u);\n-\n-        // Test on-heap map.\n-        let v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = v.map(square_ref);\n-        assert_eq!(w.len(), 5u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 4u);\n-        assert_eq!(w[2], 9u);\n-        assert_eq!(w[3], 16u);\n-        assert_eq!(w[4], 25u);\n-    }\n-\n     #[test]\n     fn test_retain() {\n         let mut v = ~[1, 2, 3, 4, 5];\n@@ -3730,36 +3681,6 @@ mod tests {\n         })\n     }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_map_fail() {\n-        use rc::Rc;\n-        let v = [(~0, Rc::new(0)), (~0, Rc::new(0)), (~0, Rc::new(0)), (~0, Rc::new(0))];\n-        let mut i = 0;\n-        v.map(|_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-            ~[(~0, Rc::new(0))]\n-        });\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_flat_map_fail() {\n-        use rc::Rc;\n-        let v = [(~0, Rc::new(0)), (~0, Rc::new(0)), (~0, Rc::new(0)), (~0, Rc::new(0))];\n-        let mut i = 0;\n-        flat_map(v, |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-            ~[(~0, Rc::new(0))]\n-        });\n-    }\n-\n     #[test]\n     #[should_fail]\n     fn test_permute_fail() {"}, {"sha": "11fd2b8ee225de4f4a98988fa295d6ed8d0ced80", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -902,13 +902,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    ///Apply a function to each element of a vector and return the results.\n-    #[inline]\n-    #[deprecated=\"Use `xs.iter().map(closure)` instead.\"]\n-    pub fn map<U>(&self, f: |t: &T| -> U) -> Vec<U> {\n-        self.iter().map(f).collect()\n-    }\n-\n     /// Takes ownership of the vector `other`, moving all elements into\n     /// the current vector. This does not copy any elements, and it is\n     /// illegal to use the `other` vector after calling this method"}, {"sha": "1676a130235562071bf158587e8698ecac978314", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -25,9 +25,9 @@ use std::u32;\n \n pub fn path_name_i(idents: &[Ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    idents.map(|i| {\n+    idents.iter().map(|i| {\n         token::get_ident(*i).get().to_str()\n-    }).connect(\"::\")\n+    }).collect::<Vec<~str>>().connect(\"::\")\n }\n \n // totally scary function: ignores all but the last element, should have\n@@ -717,13 +717,15 @@ mod test {\n     }\n \n     #[test] fn idents_name_eq_test() {\n-        assert!(segments_name_eq([Ident{name:3,ctxt:4},\n-                                   Ident{name:78,ctxt:82}].map(ident_to_segment),\n-                                 [Ident{name:3,ctxt:104},\n-                                   Ident{name:78,ctxt:182}].map(ident_to_segment)));\n-        assert!(!segments_name_eq([Ident{name:3,ctxt:4},\n-                                    Ident{name:78,ctxt:82}].map(ident_to_segment),\n-                                  [Ident{name:3,ctxt:104},\n-                                    Ident{name:77,ctxt:182}].map(ident_to_segment)));\n+        assert!(segments_name_eq(\n+            [Ident{name:3,ctxt:4}, Ident{name:78,ctxt:82}]\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice(),\n+            [Ident{name:3,ctxt:104}, Ident{name:78,ctxt:182}]\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n+        assert!(!segments_name_eq(\n+            [Ident{name:3,ctxt:4}, Ident{name:78,ctxt:82}]\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice(),\n+            [Ident{name:3,ctxt:104}, Ident{name:77,ctxt:182}]\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n     }\n }"}, {"sha": "489af0fc2d477096ffb4bdc66f005f12ebc73b43", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -746,7 +746,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n     fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> @ast::Expr {\n         let fn_decl = self.fn_decl(\n-            ids.map(|id| self.arg(span, *id, self.ty_infer(span))),\n+            ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n@@ -966,16 +966,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n                      path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem {\n-        let imports = imports.map(|id| {\n+        let imports = imports.iter().map(|id| {\n             respan(sp, ast::PathListIdent_ { name: *id, id: ast::DUMMY_NODE_ID })\n-        });\n+        }).collect();\n \n         self.view_use(sp, vis,\n                       vec!(@respan(sp,\n                                 ast::ViewPathList(self.path(sp, path),\n-                                                  imports.iter()\n-                                                         .map(|x| *x)\n-                                                         .collect(),\n+                                                  imports,\n                                                   ast::DUMMY_NODE_ID))))\n     }\n "}, {"sha": "367accb4b19d863016b15245b1effcf5b6eb352e", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -71,19 +71,19 @@ fn cs_clone(\n \n     if all_fields.len() >= 1 && all_fields.get(0).name.is_none() {\n         // enum-like\n-        let subcalls = all_fields.map(subcall);\n+        let subcalls = all_fields.iter().map(subcall).collect();\n         cx.expr_call_ident(trait_span, ctor_ident, subcalls)\n     } else {\n         // struct-like\n-        let fields = all_fields.map(|field| {\n+        let fields = all_fields.iter().map(|field| {\n             let ident = match field.name {\n                 Some(i) => i,\n                 None => cx.span_bug(trait_span,\n                                     format!(\"unnamed field in normal struct in `deriving({})`\",\n                                             name))\n             };\n             cx.field_imm(field.span, ident, subcall(field))\n-        });\n+        }).collect::<Vec<_>>();\n \n         if fields.is_empty() {\n             // no fields, so construct like `None`"}, {"sha": "94675f91e9d6c684d0d5ddf346d332a7b3443eb3", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -56,14 +56,14 @@ fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructur\n                     if fields.is_empty() {\n                         cx.expr_ident(trait_span, substr.type_ident)\n                     } else {\n-                        let exprs = fields.map(|sp| default_call(*sp));\n+                        let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n                         cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n                     }\n                 }\n                 Named(ref fields) => {\n-                    let default_fields = fields.map(|&(ident, span)| {\n+                    let default_fields = fields.iter().map(|&(ident, span)| {\n                         cx.field_imm(span, ident, default_call(span))\n-                    });\n+                    }).collect();\n                     cx.expr_struct_ident(trait_span, substr.type_ident, default_fields)\n                 }\n             }"}, {"sha": "b7b4d3db64a47909d44bff6d2295fa8e1389b05e", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -371,12 +371,12 @@ impl<'a> TraitDef<'a> {\n         ty_params.extend(generics.ty_params.iter().map(|ty_param| {\n             // I don't think this can be moved out of the loop, since\n             // a TyParamBound requires an ast id\n-            let mut bounds =\n+            let mut bounds: Vec<_> =\n                 // extra restrictions on the generics parameters to the type being derived upon\n-                self.additional_bounds.map(|p| {\n+                self.additional_bounds.iter().map(|p| {\n                     cx.typarambound(p.to_path(cx, self.span,\n                                                   type_ident, generics))\n-                });\n+                }).collect();\n             // require the current trait\n             bounds.push(cx.typarambound(trait_path.clone()));\n \n@@ -413,15 +413,15 @@ impl<'a> TraitDef<'a> {\n             ident,\n             vec::append(vec!(attr), self.attributes.as_slice()),\n             ast::ItemImpl(trait_generics, opt_trait_ref,\n-                          self_type, methods.map(|x| *x)))\n+                          self_type, methods))\n     }\n \n     fn expand_struct_def(&self,\n                          cx: &mut ExtCtxt,\n                          struct_def: &StructDef,\n                          type_ident: Ident,\n                          generics: &Generics) -> @ast::Item {\n-        let methods = self.methods.map(|method_def| {\n+        let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(\n                     cx, self, type_ident, generics);\n@@ -447,7 +447,7 @@ impl<'a> TraitDef<'a> {\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n-        });\n+        }).collect();\n \n         self.create_derived_impl(cx, type_ident, generics, methods)\n     }\n@@ -457,7 +457,7 @@ impl<'a> TraitDef<'a> {\n                        enum_def: &EnumDef,\n                        type_ident: Ident,\n                        generics: &Generics) -> @ast::Item {\n-        let methods = self.methods.map(|method_def| {\n+        let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, self,\n                                                    type_ident, generics);\n@@ -483,7 +483,7 @@ impl<'a> TraitDef<'a> {\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n-        });\n+        }).collect();\n \n         self.create_derived_impl(cx, type_ident, generics, methods)\n     }\n@@ -955,18 +955,18 @@ impl<'a> MethodDef<'a> {\n                                       self_args: &[@Expr],\n                                       nonself_args: &[@Expr])\n         -> @Expr {\n-        let summary = enum_def.variants.map(|v| {\n+        let summary = enum_def.variants.iter().map(|v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n-                    Unnamed(args.map(|va| trait_.set_expn_info(cx, va.ty.span)))\n+                    Unnamed(args.iter().map(|va| trait_.set_expn_info(cx, va.ty.span)).collect())\n                 }\n                 ast::StructVariantKind(struct_def) => {\n                     trait_.summarise_struct(cx, struct_def)\n                 }\n             };\n             (ident, v.span, summary)\n-        });\n+        }).collect();\n         self.call_substructure_method(cx, trait_, type_ident,\n                                       self_args, nonself_args,\n                                       &StaticEnum(enum_def, summary))\n@@ -1027,10 +1027,10 @@ impl<'a> TraitDef<'a> {\n                           field_paths: Vec<ast::Path> ,\n                           mutbl: ast::Mutability)\n                           -> Vec<@ast::Pat> {\n-        field_paths.map(|path| {\n+        field_paths.iter().map(|path| {\n             cx.pat(path.span,\n                         ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n-            })\n+            }).collect()\n     }\n \n     fn create_struct_pattern(&self,\n@@ -1200,12 +1200,14 @@ pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<@Expr> | -> @Expr,\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n-            let called = all_fields.map(|field| {\n+            let called = all_fields.iter().map(|field| {\n                 cx.expr_method_call(field.span,\n                                     field.self_,\n                                     substructure.method_ident,\n-                                    field.other.map(|e| cx.expr_addr_of(field.span, *e)))\n-            });\n+                                    field.other.iter()\n+                                               .map(|e| cx.expr_addr_of(field.span, *e))\n+                                               .collect())\n+            }).collect();\n \n             f(cx, trait_span, called)\n         },"}, {"sha": "6b824e52bb3d702036717b493bc13e15e040ae5b", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -136,15 +136,15 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                 if fields.is_empty() {\n                     cx.expr_ident(trait_span, ctor_ident)\n                 } else {\n-                    let exprs = fields.map(|span| rand_call(cx, *span));\n+                    let exprs = fields.iter().map(|span| rand_call(cx, *span)).collect();\n                     cx.expr_call_ident(trait_span, ctor_ident, exprs)\n                 }\n             }\n             Named(ref fields) => {\n-                let rand_fields = fields.map(|&(ident, span)| {\n+                let rand_fields = fields.iter().map(|&(ident, span)| {\n                     let e = rand_call(cx, span);\n                     cx.field_imm(span, ident, e)\n-                });\n+                }).collect();\n                 cx.expr_struct_ident(trait_span, ctor_ident, rand_fields)\n             }\n         }"}, {"sha": "e58c024fcb01435fbbf6e83d89561a155ca9d53f", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -69,9 +69,9 @@ impl<'a> Path<'a> {\n                    self_ty: Ident,\n                    self_generics: &Generics)\n                    -> ast::Path {\n-        let idents = self.path.map(|s| cx.ident_of(*s) );\n+        let idents = self.path.iter().map(|s| cx.ident_of(*s)).collect();\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n-        let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n+        let tys = self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n \n         cx.path_all(span, self.global, idents, lt, tys)\n     }\n@@ -150,7 +150,9 @@ impl<'a> Ty<'a> {\n                 let ty = if fields.is_empty() {\n                     ast::TyNil\n                 } else {\n-                    ast::TyTup(fields.map(|f| f.to_ty(cx, span, self_ty, self_generics)))\n+                    ast::TyTup(fields.iter()\n+                                     .map(|f| f.to_ty(cx, span, self_ty, self_generics))\n+                                     .collect())\n                 };\n \n                 cx.ty(span, ty)\n@@ -219,10 +221,10 @@ impl<'a> LifetimeBounds<'a> {\n                        self_ty: Ident,\n                        self_generics: &Generics)\n                        -> Generics {\n-        let lifetimes = self.lifetimes.map(|lt| {\n+        let lifetimes = self.lifetimes.iter().map(|lt| {\n             cx.lifetime(span, cx.ident_of(*lt).name)\n-        });\n-        let ty_params = self.bounds.map(|t| {\n+        }).collect();\n+        let ty_params = self.bounds.iter().map(|t| {\n             match t {\n                 &(ref name, ref bounds) => {\n                     mk_ty_param(cx,\n@@ -233,7 +235,7 @@ impl<'a> LifetimeBounds<'a> {\n                                 self_generics)\n                 }\n             }\n-        });\n+        }).collect();\n         mk_generics(lifetimes, ty_params)\n     }\n }"}, {"sha": "10692bd7f93f6a399786bfbccce84ec538421421", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -73,14 +73,14 @@ fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                     if fields.is_empty() {\n                         cx.expr_ident(trait_span, substr.type_ident)\n                     } else {\n-                        let exprs = fields.map(|sp| zero_call(*sp));\n+                        let exprs = fields.iter().map(|sp| zero_call(*sp)).collect();\n                         cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n                     }\n                 }\n                 Named(ref fields) => {\n-                    let zero_fields = fields.map(|&(ident, span)| {\n+                    let zero_fields = fields.iter().map(|&(ident, span)| {\n                         cx.field_imm(span, ident, zero_call(span))\n-                    });\n+                    }).collect();\n                     cx.expr_struct_ident(trait_span, substr.type_ident, zero_fields)\n                 }\n             }"}, {"sha": "aa9330bf65764ee631e7080e99fdf662dea0dbd2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -776,7 +776,7 @@ pub fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n \n // expand the elements of a block.\n pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n-    let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n+    let new_view_items = b.view_items.iter().map(|x| fld.fold_view_item(x)).collect();\n     let new_stmts =\n         b.stmts.iter().flat_map(|x| {\n             let renamed_stmt = {"}, {"sha": "6f8656f494dcb0370d9647e52ee989415038d255", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -83,7 +83,7 @@ pub mod rt {\n \n     impl<'a> ToSource for &'a [@ast::Item] {\n         fn to_source(&self) -> ~str {\n-            self.map(|i| i.to_source()).connect(\"\\n\\n\")\n+            self.iter().map(|i| i.to_source()).collect::<Vec<~str>>().connect(\"\\n\\n\")\n         }\n     }\n \n@@ -95,7 +95,7 @@ pub mod rt {\n \n     impl<'a> ToSource for &'a [ast::Ty] {\n         fn to_source(&self) -> ~str {\n-            self.map(|i| i.to_source()).connect(\", \")\n+            self.iter().map(|i| i.to_source()).collect::<Vec<~str>>().connect(\", \")\n         }\n     }\n \n@@ -339,7 +339,7 @@ pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n }\n \n fn ids_ext(strs: Vec<~str> ) -> Vec<ast::Ident> {\n-    strs.map(|str| str_to_ident(*str))\n+    strs.iter().map(|str| str_to_ident(*str)).collect()\n }\n \n fn id_ext(str: &str) -> ast::Ident {"}, {"sha": "4d8d816d225d4670a0e6b4bed76fe54ab6793ba5", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -71,7 +71,9 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n+                   .iter()\n                    .map(|x| token::get_ident(*x).get().to_str())\n+                   .collect::<Vec<~str>>()\n                    .connect(\"::\");\n     base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(string)))\n }"}, {"sha": "62999fb496afa1347cf76422c35a75a0b24e99b0", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -373,15 +373,15 @@ pub fn parse(sess: &ParseSess,\n         } else {\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n-                let nts = bb_eis.map(|ei| {\n+                let nts = bb_eis.iter().map(|ei| {\n                     match ei.elts.get(ei.idx).node {\n                       MatchNonterminal(bind, name, _) => {\n                         format!(\"{} ('{}')\",\n                                 token::get_ident(name),\n                                 token::get_ident(bind))\n                       }\n                       _ => fail!()\n-                    } }).connect(\" or \");\n+                    } }).collect::<Vec<~str>>().connect(\" or \");\n                 return Error(sp, format!(\n                     \"local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\","}, {"sha": "03963219d52c403dc7149d142b1060c065942187", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -41,7 +41,7 @@ pub trait Folder {\n                 }\n                 ViewPathList(ref path, ref path_list_idents, node_id) => {\n                     ViewPathList(self.fold_path(path),\n-                                 path_list_idents.map(|path_list_ident| {\n+                                 path_list_idents.iter().map(|path_list_ident| {\n                                     let id = self.new_id(path_list_ident.node\n                                                                         .id);\n                                     Spanned {\n@@ -54,7 +54,7 @@ pub trait Folder {\n                                         span: self.new_span(\n                                             path_list_ident.span)\n                                     }\n-                                 }),\n+                                 }).collect(),\n                                  self.new_id(node_id))\n                 }\n             };\n@@ -83,7 +83,7 @@ pub trait Folder {\n                 kind: sf.node.kind,\n                 id: self.new_id(sf.node.id),\n                 ty: self.fold_ty(sf.node.ty),\n-                attrs: sf.node.attrs.map(|e| fold_attribute_(*e, self))\n+                attrs: sf.node.attrs.iter().map(|e| fold_attribute_(*e, self)).collect()\n             },\n             span: self.new_span(sf.span)\n         }\n@@ -115,7 +115,7 @@ pub trait Folder {\n \n     fn fold_arm(&mut self, a: &Arm) -> Arm {\n         Arm {\n-            pats: a.pats.map(|x| self.fold_pat(*x)),\n+            pats: a.pats.iter().map(|x| self.fold_pat(*x)).collect(),\n             guard: a.guard.map(|x| self.fold_expr(x)),\n             body: self.fold_expr(a.body),\n         }\n@@ -163,18 +163,18 @@ pub trait Folder {\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n                     decl: self.fold_fn_decl(f.decl),\n-                    lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n+                    lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n                 })\n             }\n             TyBareFn(ref f) => {\n                 TyBareFn(@BareFnTy {\n-                    lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n+                    lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n                     purity: f.purity,\n                     abis: f.abis,\n                     decl: self.fold_fn_decl(f.decl)\n                 })\n             }\n-            TyTup(ref tys) => TyTup(tys.map(|&ty| self.fold_ty(ty))),\n+            TyTup(ref tys) => TyTup(tys.iter().map(|&ty| self.fold_ty(ty)).collect()),\n             TyPath(ref path, ref bounds, id) => {\n                 TyPath(self.fold_path(path),\n                        fold_opt_bounds(bounds, self),\n@@ -214,8 +214,8 @@ pub trait Folder {\n         let kind;\n         match v.node.kind {\n             TupleVariantKind(ref variant_args) => {\n-                kind = TupleVariantKind(variant_args.map(|x|\n-                    fold_variant_arg_(x, self)))\n+                kind = TupleVariantKind(variant_args.iter().map(|x|\n+                    fold_variant_arg_(x, self)).collect())\n             }\n             StructVariantKind(ref struct_def) => {\n                 kind = StructVariantKind(@ast::StructDef {\n@@ -226,7 +226,7 @@ pub trait Folder {\n             }\n         }\n \n-        let attrs = v.node.attrs.map(|x| fold_attribute_(*x, self));\n+        let attrs = v.node.attrs.iter().map(|x| fold_attribute_(*x, self)).collect();\n \n         let de = match v.node.disr_expr {\n           Some(e) => Some(self.fold_expr(e)),\n@@ -254,11 +254,11 @@ pub trait Folder {\n         ast::Path {\n             span: self.new_span(p.span),\n             global: p.global,\n-            segments: p.segments.map(|segment| ast::PathSegment {\n+            segments: p.segments.iter().map(|segment| ast::PathSegment {\n                 identifier: self.fold_ident(segment.identifier),\n-                lifetimes: segment.lifetimes.map(|l| fold_lifetime(l, self)),\n-                types: segment.types.map(|&typ| self.fold_ty(typ)),\n-            })\n+                lifetimes: segment.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                types: segment.types.iter().map(|&typ| self.fold_ty(typ)).collect(),\n+            }).collect()\n         }\n     }\n \n@@ -323,7 +323,7 @@ fn fold_meta_item_<T: Folder>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n             match mi.node {\n                 MetaWord(ref id) => MetaWord((*id).clone()),\n                 MetaList(ref id, ref mis) => {\n-                    MetaList((*id).clone(), mis.map(|e| fold_meta_item_(*e, fld)))\n+                    MetaList((*id).clone(), mis.iter().map(|e| fold_meta_item_(*e, fld)).collect())\n                 }\n                 MetaNameValue(ref id, ref s) => {\n                     MetaNameValue((*id).clone(), (*s).clone())\n@@ -402,7 +402,7 @@ fn maybe_fold_ident<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n \n pub fn noop_fold_fn_decl<T: Folder>(decl: &FnDecl, fld: &mut T) -> P<FnDecl> {\n     P(FnDecl {\n-        inputs: decl.inputs.map(|x| fold_arg_(x, fld)), // bad copy\n+        inputs: decl.inputs.iter().map(|x| fold_arg_(x, fld)).collect(), // bad copy\n         output: fld.fold_ty(decl.output),\n         cf: decl.cf,\n         variadic: decl.variadic\n@@ -441,7 +441,7 @@ pub fn fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n \n pub fn fold_lifetimes<T: Folder>(lts: &Vec<Lifetime>, fld: &mut T)\n                                    -> Vec<Lifetime> {\n-    lts.map(|l| fold_lifetime(l, fld))\n+    lts.iter().map(|l| fold_lifetime(l, fld)).collect()\n }\n \n pub fn fold_opt_lifetime<T: Folder>(o_lt: &Option<Lifetime>, fld: &mut T)\n@@ -456,7 +456,7 @@ pub fn fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n \n fn fold_struct_def<T: Folder>(struct_def: @StructDef, fld: &mut T) -> @StructDef {\n     @ast::StructDef {\n-        fields: struct_def.fields.map(|f| fold_struct_field(f, fld)),\n+        fields: struct_def.fields.iter().map(|f| fold_struct_field(f, fld)).collect(),\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n     }\n }\n@@ -474,7 +474,7 @@ fn fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n             kind: f.node.kind,\n             id: fld.new_id(f.node.id),\n             ty: fld.fold_ty(f.node.ty),\n-            attrs: f.node.attrs.map(|a| fold_attribute_(*a, fld)),\n+            attrs: f.node.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n         },\n         span: fld.new_span(f.span),\n     }\n@@ -525,14 +525,14 @@ pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n     };\n     ViewItem {\n         node: inner_view_item,\n-        attrs: vi.attrs.map(|a| fold_attribute_(*a, folder)),\n+        attrs: vi.attrs.iter().map(|a| fold_attribute_(*a, folder)).collect(),\n         vis: vi.vis,\n         span: folder.new_span(vi.span),\n     }\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n+    let view_items = b.view_items.iter().map(|x| folder.fold_view_item(x)).collect();\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     P(Block {\n         id: folder.new_id(b.id), // Needs to be first, for ast_map.\n@@ -566,9 +566,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n         ItemEnum(ref enum_definition, ref generics) => {\n             ItemEnum(\n                 ast::EnumDef {\n-                    variants: enum_definition.variants.map(|&x| {\n+                    variants: enum_definition.variants.iter().map(|&x| {\n                         folder.fold_variant(x)\n-                    }),\n+                    }).collect(),\n                 },\n                 fold_generics(generics, folder))\n         }\n@@ -580,18 +580,18 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n             ItemImpl(fold_generics(generics, folder),\n                      ifce.as_ref().map(|p| fold_trait_ref(p, folder)),\n                      folder.fold_ty(ty),\n-                     methods.map(|x| folder.fold_method(*x))\n+                     methods.iter().map(|x| folder.fold_method(*x)).collect()\n             )\n         }\n         ItemTrait(ref generics, ref traits, ref methods) => {\n-            let methods = methods.map(|method| {\n+            let methods = methods.iter().map(|method| {\n                 match *method {\n                     Required(ref m) => Required(folder.fold_type_method(m)),\n                     Provided(method) => Provided(folder.fold_method(method))\n                 }\n-            });\n+            }).collect();\n             ItemTrait(fold_generics(generics, folder),\n-                      traits.map(|p| fold_trait_ref(p, folder)),\n+                      traits.iter().map(|p| fold_trait_ref(p, folder)).collect(),\n                       methods)\n         }\n         ItemMac(ref m) => ItemMac(folder.fold_mac(m)),\n@@ -602,7 +602,7 @@ pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMeth\n     TypeMethod {\n         id: fld.new_id(m.id), // Needs to be first, for ast_map.\n         ident: fld.fold_ident(m.ident),\n-        attrs: m.attrs.map(|a| fold_attribute_(*a, fld)),\n+        attrs: m.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n         purity: m.purity,\n         decl: fld.fold_fn_decl(m.decl),\n         generics: fold_generics(&m.generics, fld),\n@@ -623,8 +623,8 @@ pub fn noop_fold_mod<T: Folder>(m: &Mod, folder: &mut T) -> Mod {\n pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n     Crate {\n         module: folder.fold_mod(&c.module),\n-        attrs: c.attrs.map(|x| fold_attribute_(*x, folder)),\n-        config: c.config.map(|x| fold_meta_item_(*x, folder)),\n+        attrs: c.attrs.iter().map(|x| fold_attribute_(*x, folder)).collect(),\n+        config: c.config.iter().map(|x| fold_meta_item_(*x, folder)).collect(),\n         span: folder.new_span(c.span),\n     }\n }\n@@ -643,7 +643,7 @@ pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item>\n     SmallVector::one(@Item {\n         id: id,\n         ident: folder.fold_ident(ident),\n-        attrs: i.attrs.map(|e| fold_attribute_(*e, folder)),\n+        attrs: i.attrs.iter().map(|e| fold_attribute_(*e, folder)).collect(),\n         node: node,\n         vis: i.vis,\n         span: folder.new_span(i.span)\n@@ -654,11 +654,11 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @F\n     @ForeignItem {\n         id: folder.new_id(ni.id), // Needs to be first, for ast_map.\n         ident: folder.fold_ident(ni.ident),\n-        attrs: ni.attrs.map(|x| fold_attribute_(*x, folder)),\n+        attrs: ni.attrs.iter().map(|x| fold_attribute_(*x, folder)).collect(),\n         node: match ni.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n                 ForeignItemFn(P(FnDecl {\n-                    inputs: fdec.inputs.map(|a| fold_arg_(a, folder)),\n+                    inputs: fdec.inputs.iter().map(|a| fold_arg_(a, folder)).collect(),\n                     output: folder.fold_ty(fdec.output),\n                     cf: fdec.cf,\n                     variadic: fdec.variadic\n@@ -677,7 +677,7 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n     @Method {\n         id: folder.new_id(m.id), // Needs to be first, for ast_map.\n         ident: folder.fold_ident(m.ident),\n-        attrs: m.attrs.map(|a| fold_attribute_(*a, folder)),\n+        attrs: m.attrs.iter().map(|a| fold_attribute_(*a, folder)).collect(),\n         generics: fold_generics(&m.generics, folder),\n         explicit_self: folder.fold_explicit_self(&m.explicit_self),\n         purity: m.purity,\n@@ -700,28 +700,28 @@ pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n         PatLit(e) => PatLit(folder.fold_expr(e)),\n         PatEnum(ref pth, ref pats) => {\n             PatEnum(folder.fold_path(pth),\n-                    pats.as_ref().map(|pats| pats.map(|x| folder.fold_pat(*x))))\n+                    pats.as_ref().map(|pats| pats.iter().map(|x| folder.fold_pat(*x)).collect()))\n         }\n         PatStruct(ref pth, ref fields, etc) => {\n             let pth_ = folder.fold_path(pth);\n-            let fs = fields.map(|f| {\n+            let fs = fields.iter().map(|f| {\n                 ast::FieldPat {\n                     ident: f.ident,\n                     pat: folder.fold_pat(f.pat)\n                 }\n-            });\n+            }).collect();\n             PatStruct(pth_, fs, etc)\n         }\n-        PatTup(ref elts) => PatTup(elts.map(|x| folder.fold_pat(*x))),\n+        PatTup(ref elts) => PatTup(elts.iter().map(|x| folder.fold_pat(*x)).collect()),\n         PatUniq(inner) => PatUniq(folder.fold_pat(inner)),\n         PatRegion(inner) => PatRegion(folder.fold_pat(inner)),\n         PatRange(e1, e2) => {\n             PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n         },\n         PatVec(ref before, ref slice, ref after) => {\n-            PatVec(before.map(|x| folder.fold_pat(*x)),\n+            PatVec(before.iter().map(|x| folder.fold_pat(*x)).collect(),\n                     slice.map(|x| folder.fold_pat(x)),\n-                    after.map(|x| folder.fold_pat(*x)))\n+                    after.iter().map(|x| folder.fold_pat(*x)).collect())\n         }\n     };\n \n@@ -741,21 +741,21 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n             ExprBox(folder.fold_expr(p), folder.fold_expr(e))\n         }\n         ExprVec(ref exprs, mutt) => {\n-            ExprVec(exprs.map(|&x| folder.fold_expr(x)), mutt)\n+            ExprVec(exprs.iter().map(|&x| folder.fold_expr(x)).collect(), mutt)\n         }\n         ExprRepeat(expr, count, mutt) => {\n             ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count), mutt)\n         }\n-        ExprTup(ref elts) => ExprTup(elts.map(|x| folder.fold_expr(*x))),\n+        ExprTup(ref elts) => ExprTup(elts.iter().map(|x| folder.fold_expr(*x)).collect()),\n         ExprCall(f, ref args) => {\n             ExprCall(folder.fold_expr(f),\n-                     args.map(|&x| folder.fold_expr(x)))\n+                     args.iter().map(|&x| folder.fold_expr(x)).collect())\n         }\n         ExprMethodCall(i, ref tps, ref args) => {\n             ExprMethodCall(\n                 folder.fold_ident(i),\n-                tps.map(|&x| folder.fold_ty(x)),\n-                args.map(|&x| folder.fold_expr(x)))\n+                tps.iter().map(|&x| folder.fold_ty(x)).collect(),\n+                args.iter().map(|&x| folder.fold_expr(x)).collect())\n         }\n         ExprBinary(binop, lhs, rhs) => {\n             ExprBinary(binop,\n@@ -790,7 +790,7 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n         }\n         ExprMatch(expr, ref arms) => {\n             ExprMatch(folder.fold_expr(expr),\n-                      arms.map(|x| folder.fold_arm(x)))\n+                      arms.iter().map(|x| folder.fold_arm(x)).collect())\n         }\n         ExprFnBlock(decl, body) => {\n             ExprFnBlock(folder.fold_fn_decl(decl), folder.fold_block(body))\n@@ -810,7 +810,7 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n         ExprField(el, id, ref tys) => {\n             ExprField(folder.fold_expr(el),\n                       folder.fold_ident(id),\n-                      tys.map(|&x| folder.fold_ty(x)))\n+                      tys.iter().map(|&x| folder.fold_ty(x)).collect())\n         }\n         ExprIndex(el, er) => {\n             ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n@@ -823,19 +823,19 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n         }\n         ExprInlineAsm(ref a) => {\n             ExprInlineAsm(InlineAsm {\n-                inputs: a.inputs.map(|&(ref c, input)| {\n+                inputs: a.inputs.iter().map(|&(ref c, input)| {\n                     ((*c).clone(), folder.fold_expr(input))\n-                }),\n-                outputs: a.outputs.map(|&(ref c, out)| {\n+                }).collect(),\n+                outputs: a.outputs.iter().map(|&(ref c, out)| {\n                     ((*c).clone(), folder.fold_expr(out))\n-                }),\n+                }).collect(),\n                 .. (*a).clone()\n             })\n         }\n         ExprMac(ref mac) => ExprMac(folder.fold_mac(mac)),\n         ExprStruct(ref path, ref fields, maybe_expr) => {\n             ExprStruct(folder.fold_path(path),\n-                       fields.map(|x| fold_field_(*x, folder)),\n+                       fields.iter().map(|x| fold_field_(*x, folder)).collect(),\n                        maybe_expr.map(|x| folder.fold_expr(x)))\n         },\n         ExprParen(ex) => ExprParen(folder.fold_expr(ex))"}, {"sha": "7d337e9c0785209751931b4e6c27b18edb7cf0da", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -104,7 +104,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         }\n \n         if can_trim {\n-            lines.map(|line| line.slice(i + 1, line.len()).to_owned())\n+            lines.iter().map(|line| line.slice(i + 1, line.len()).to_owned()).collect()\n         } else {\n             lines\n         }"}, {"sha": "eb7b3162b52d6f544b4ef3284c9ddf3a7ecf42a0", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -70,7 +70,7 @@ pub fn string_to_pat(source_str: ~str) -> @ast::Pat {\n \n // convert a vector of strings to a vector of ast::Ident's\n pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<ast::Ident> {\n-    ids.map(|u| token::str_to_ident(*u))\n+    ids.iter().map(|u| token::str_to_ident(*u)).collect()\n }\n \n // does the given string match the pattern? whitespace in the first string"}, {"sha": "16b743baa3d1323e901e236b7f7fb32916ebd3e0", "filename": "src/test/auxiliary/issue_2723_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -10,5 +10,5 @@\n \n \n pub unsafe fn f(xs: Vec<int> ) {\n-    xs.map(|_x| { unsafe fn q() { fail!(); } });\n+    xs.iter().map(|_x| { unsafe fn q() { fail!(); } }).collect::<Vec<()>>();\n }"}, {"sha": "8529947245846caf72da3102b26ea6c67d42e551", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79fbba0db84b2d27440f8feba715dffd3aeaa01/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=d79fbba0db84b2d27440f8feba715dffd3aeaa01", "patch": "@@ -99,7 +99,9 @@ impl AsciiArt {\n impl fmt::Show for AsciiArt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Convert each line into a string.\n-        let lines = self.lines.map(|line| str::from_chars(line.as_slice()));\n+        let lines = self.lines.iter()\n+                              .map(|line| str::from_chars(line.as_slice()))\n+                              .collect::<Vec<~str>>();\n \n         // Concatenate the lines together using a new-line.\n         write!(f.buf, \"{}\", lines.connect(\"\\n\"))"}]}