{"sha": "df171e4b6898db92610bcccb22d996d361e16902", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMTcxZTRiNjg5OGRiOTI2MTBiY2NjYjIyZDk5NmQzNjFlMTY5MDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-25T22:13:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-25T22:13:09Z"}, "message": "auto merge of #5505 : catamorphism/rust/macro-tutorial, r=graydon\n\nr? @jbclements", "tree": {"sha": "03a49ef2367464debab42591af770d341c5f9cb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03a49ef2367464debab42591af770d341c5f9cb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df171e4b6898db92610bcccb22d996d361e16902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df171e4b6898db92610bcccb22d996d361e16902", "html_url": "https://github.com/rust-lang/rust/commit/df171e4b6898db92610bcccb22d996d361e16902", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df171e4b6898db92610bcccb22d996d361e16902/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef282dbe2af9c6afc89776df177a750a1784853a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef282dbe2af9c6afc89776df177a750a1784853a", "html_url": "https://github.com/rust-lang/rust/commit/ef282dbe2af9c6afc89776df177a750a1784853a"}, {"sha": "3633ba240ff80e176d7457b643c85ff2e2a72758", "url": "https://api.github.com/repos/rust-lang/rust/commits/3633ba240ff80e176d7457b643c85ff2e2a72758", "html_url": "https://github.com/rust-lang/rust/commit/3633ba240ff80e176d7457b643c85ff2e2a72758"}], "stats": {"total": 50, "additions": 27, "deletions": 23}, "files": [{"sha": "24e9f4abc38e6e429b79b798e70c772e507dda0b", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/df171e4b6898db92610bcccb22d996d361e16902/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/df171e4b6898db92610bcccb22d996d361e16902/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=df171e4b6898db92610bcccb22d996d361e16902", "patch": "@@ -3,10 +3,12 @@\n # Introduction\n \n Functions are the primary tool that programmers can use to build abstractions.\n-Sometimes, however, programmers want to perform abstractions over things that are not\n-runtime values. Macros provide a syntactic abstraction. For an example of how this\n-can be useful, consider the following two code fragments, which both pattern-match\n-on their input and return early in one case, and do nothing otherwise:\n+Sometimes, however, programmers want to abstract over compile-time syntax\n+rather than run-time values.\n+Macros provide syntactic abstraction.\n+For an example of how this can be useful, consider the following two code fragments,\n+which both pattern-match on their input and both return early in one case,\n+doing nothing otherwise:\n \n ~~~~\n # enum t { special_a(uint), special_b(uint) };\n@@ -25,9 +27,10 @@ match input_2 {\n # }\n ~~~~\n \n-This code could become tiresome if repeated many times. However, no function\n-can capture its functionality to make it possible to rewrite the repetition\n-away. Rust's macro system, however, can eliminate the repetition. Macros are\n+This code could become tiresome if repeated many times.\n+However, no function can capture its functionality to make it possible\n+to abstract the repetition away.\n+Rust's macro system, however, can eliminate the repetition. Macros are\n lightweight custom syntax extensions, themselves defined using the\n `macro_rules!` syntax extension. The following `early_return` macro captures\n the pattern in the above code:\n@@ -37,7 +40,7 @@ the pattern in the above code:\n # fn f() -> uint {\n # let input_1 = special_a(0), input_2 = special_a(0);\n macro_rules! early_return(\n-    ($inp:expr $sp:ident) => ( //invoke it like `(input_5 special_e)`\n+    ($inp:expr $sp:ident) => ( // invoke it like `(input_5 special_e)`\n         match $inp {\n             $sp(x) => { return x; }\n             _ => {}\n@@ -93,10 +96,10 @@ that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n \n ## Invocation location\n \n-A macro invocation may take the place of (and therefore expand to) either an\n-expression, an item, or a statement. The Rust parser will parse the macro\n-invocation as a \"placeholder\" for whichever of those three nonterminals is\n-appropriate for the location.\n+A macro invocation may take the place of (and therefore expand to)\n+an expression, an item, or a statement.\n+The Rust parser will parse the macro invocation as a \"placeholder\"\n+for whichever of those three nonterminals is appropriate for the location.\n \n At expansion time, the output of the macro will be parsed as whichever of the\n three nonterminals it stands in for. This means that a single macro might,\n@@ -112,17 +115,19 @@ The right-hand side of the `=>` follows the same rules as the left-hand side,\n except that a `$` need only be followed by the name of the syntactic fragment\n to transcribe into the macro expansion; its type need not be repeated.\n \n-The right-hand side must be enclosed by delimiters, which are ignored by the\n-transcriber (therefore `() => ((1,2,3))` is a macro that expands to a tuple\n-expression, `() => (let $x=$val)` is a macro that expands to a statement, and\n-`() => (1,2,3)` is a macro that expands to a syntax error).\n+The right-hand side must be enclosed by delimiters, which the transcriber ignores.\n+Therefore `() => ((1,2,3))` is a macro that expands to a tuple expression,\n+`() => (let $x=$val)` is a macro that expands to a statement,\n+and `() => (1,2,3)` is a macro that expands to a syntax error\n+(since the transcriber interprets the parentheses on the right-hand-size as delimiters,\n+and `1,2,3` is not a valid Rust expression on its own).\n \n Except for permissibility of `$name` (and `$(...)*`, discussed below), the\n right-hand side of a macro definition is ordinary Rust syntax. In particular,\n macro invocations (including invocations of the macro currently being defined)\n are permitted in expression, statement, and item locations. However, nothing\n else about the code is examined or executed by the macro system; execution\n-still has to wait until runtime.\n+still has to wait until run-time.\n \n ## Interpolation location\n \n@@ -287,7 +292,6 @@ A macro may accept multiple different input grammars. The first one to\n successfully match the actual argument to a macro invocation is the one that\n \"wins\".\n \n-\n In the case of the example above, we want to write a recursive macro to\n process the semicolon-terminated lines, one-by-one. So, we want the following\n input patterns:\n@@ -369,19 +373,19 @@ return result + val;\n # }\n ~~~~\n \n-This technique is applicable in many cases where transcribing a result \"all\n-at once\" is not possible. It resembles ordinary functional programming in some\n-respects, but it is important to recognize the differences.\n+This technique applies to many cases where transcribing a result all at once is not possible.\n+The resulting code resembles ordinary functional programming in some respects,\n+but has some important differences from functional programming.\n \n The first difference is important, but also easy to forget: the transcription\n (right-hand) side of a `macro_rules!` rule is literal syntax, which can only\n be executed at run-time. If a piece of transcription syntax does not itself\n appear inside another macro invocation, it will become part of the final\n program. If it is inside a macro invocation (for example, the recursive\n-invocation of `biased_match_rec!`), it does have the opprotunity to affect\n+invocation of `biased_match_rec!`), it does have the opportunity to affect\n transcription, but only through the process of attempted pattern matching.\n \n-The second difference is related: the evaluation order of macros feels\n+The second, related, difference is that the evaluation order of macros feels\n \"backwards\" compared to ordinary programming. Given an invocation\n `m1!(m2!())`, the expander first expands `m1!`, giving it as input the literal\n syntax `m2!()`. If it transcribes its argument unchanged into an appropriate"}]}