{"sha": "ef4d2c10430c941619ccc517e709f093a4ea9689", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNGQyYzEwNDMwYzk0MTYxOWNjYzUxN2U3MDlmMDkzYTRlYTk2ODk=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-26T21:12:01Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-02T13:02:36Z"}, "message": "change WellFormed predicate to GenericArg", "tree": {"sha": "4df315a64f5df7136c490d6afdaa811e7d54d132", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4df315a64f5df7136c490d6afdaa811e7d54d132"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef4d2c10430c941619ccc517e709f093a4ea9689", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4d2c10430c941619ccc517e709f093a4ea9689", "html_url": "https://github.com/rust-lang/rust/commit/ef4d2c10430c941619ccc517e709f093a4ea9689", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef4d2c10430c941619ccc517e709f093a4ea9689/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81831e124e002188d95d690ea090067b3653055f", "url": "https://api.github.com/repos/rust-lang/rust/commits/81831e124e002188d95d690ea090067b3653055f", "html_url": "https://github.com/rust-lang/rust/commit/81831e124e002188d95d690ea090067b3653055f"}], "stats": {"total": 412, "additions": 157, "deletions": 255}, "files": [{"sha": "4ef4ed47cb11a8b20543d907e80c2c5e3275b0e7", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -307,7 +307,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::PredicateKind::WellFormed(b_ty).to_predicate(self.infcx.tcx),\n+                ty::PredicateKind::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n             ));\n         }\n "}, {"sha": "fd3b38e9d67b0e3b670f41c432ed836556d2c87f", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -20,8 +20,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::TypeOutlives(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..)\n-        | ty::PredicateKind::WellFormedConst(..) => None,\n+        | ty::PredicateKind::ConstEquate(..) => None,\n         ty::PredicateKind::RegionOutlives(ref data) => data\n             .no_bound_vars()\n             .map(|ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a)),"}, {"sha": "8081cac0067f172821c84a07cf6d4a4c22ff8d3d", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -45,8 +45,6 @@ pub fn anonymize_predicate<'tcx>(\n         }\n \n         ty::PredicateKind::ConstEquate(c1, c2) => ty::PredicateKind::ConstEquate(c1, c2),\n-\n-        ty::PredicateKind::WellFormedConst(ct) => ty::PredicateKind::WellFormedConst(ct),\n     };\n \n     if new != *kind { new.to_predicate(tcx) } else { pred }\n@@ -206,9 +204,6 @@ impl Elaborator<'tcx> {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::PredicateKind::WellFormedConst(..) => {\n-                // Currently, we do not elaborate WF predicates.\n-            }\n             ty::PredicateKind::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }"}, {"sha": "e17e8b7b9640e8e8dfd334f088859da67a06d1b3", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -1218,7 +1218,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n                     Projection(..) |\n                     // Ignore bounds that a user can't type\n                     WellFormed(..) |\n-                    WellFormedConst(..) |\n                     ObjectSafe(..) |\n                     ClosureKind(..) |\n                     Subtype(..) |"}, {"sha": "a34cff06bc1cde367018565fec3ff3937134cce0", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -14,7 +14,7 @@ use crate::mir::Body;\n use crate::mir::GeneratorLayout;\n use crate::traits::{self, Reveal};\n use crate::ty;\n-use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n use rustc_ast::ast;\n use rustc_attr as attr;\n@@ -1061,7 +1061,7 @@ pub enum PredicateKind<'tcx> {\n     Projection(PolyProjectionPredicate<'tcx>),\n \n     /// No syntax: `T` well-formed.\n-    WellFormed(Ty<'tcx>),\n+    WellFormed(GenericArg<'tcx>),\n \n     /// Trait must be object-safe.\n     ObjectSafe(DefId),\n@@ -1079,9 +1079,6 @@ pub enum PredicateKind<'tcx> {\n \n     /// Constants must be equal. The first component is the const that is expected.\n     ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n-\n-    /// Constant must be well formed.\n-    WellFormedConst(&'tcx Const<'tcx>),\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -1198,9 +1195,6 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::ConstEquate(c1, c2) => {\n                 PredicateKind::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n             }\n-            PredicateKind::WellFormedConst(c) => {\n-                PredicateKind::WellFormedConst(c.subst(tcx, substs))\n-            }\n         };\n \n         if new != *kind { new.to_predicate(tcx) } else { self }\n@@ -1392,8 +1386,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::ClosureKind(..)\n             | PredicateKind::TypeOutlives(..)\n             | PredicateKind::ConstEvaluatable(..)\n-            | PredicateKind::ConstEquate(..)\n-            | PredicateKind::WellFormedConst(..) => None,\n+            | PredicateKind::ConstEquate(..) => None,\n         }\n     }\n \n@@ -1408,8 +1401,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::ObjectSafe(..)\n             | PredicateKind::ClosureKind(..)\n             | PredicateKind::ConstEvaluatable(..)\n-            | PredicateKind::ConstEquate(..)\n-            | PredicateKind::WellFormedConst(..) => None,\n+            | PredicateKind::ConstEquate(..) => None,\n         }\n     }\n }"}, {"sha": "90fb19816179368ae6843daf7f85e19a5ba545dd", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -2031,7 +2031,7 @@ define_print_and_forward_display! {\n             ty::PredicateKind::RegionOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateKind::TypeOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateKind::Projection(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n+            ty::PredicateKind::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n             &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"),\n                    print_def_path(trait_def_id, &[]),\n@@ -2054,9 +2054,6 @@ define_print_and_forward_display! {\n                    print(c2),\n                    write(\"`\"))\n             }\n-            ty::PredicateKind::WellFormedConst(c) => {\n-                p!(print(c), write(\" well-formed\"))\n-            }\n         }\n     }\n "}, {"sha": "6c1a524b7fee5d859457ea95cd2ea6a9f4db8be2", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -236,7 +236,7 @@ impl fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n             ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n             ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n+            ty::PredicateKind::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n             ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 write!(f, \"ObjectSafe({:?})\", trait_def_id)\n             }\n@@ -247,7 +247,6 @@ impl fmt::Debug for ty::PredicateKind<'tcx> {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n             ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n-            ty::PredicateKind::WellFormedConst(c) => write!(f, \"WellFormedConst({:?})\", c),\n         }\n     }\n }\n@@ -508,9 +507,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n             ty::PredicateKind::ConstEquate(c1, c2) => {\n                 tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n             }\n-            ty::PredicateKind::WellFormedConst(c) => {\n-                tcx.lift(&c).map(ty::PredicateKind::WellFormedConst)\n-            }\n         }\n     }\n }"}, {"sha": "377a0b6f25cab98b7ace7ffc22d88372ffdf564d", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::PredicateKind::WellFormed(inferred_ty).to_predicate(self.tcx()),\n+                        ty::PredicateKind::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::PredicateKind::WellFormed(revealed_ty).to_predicate(infcx.tcx),\n+                        ty::PredicateKind::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -1612,7 +1612,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n-                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty)),\n+                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty.into())),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );"}, {"sha": "5615aa84eecd7c52cbfacaaacdac98eb9d1e7f03", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -29,8 +29,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                 | ty::PredicateKind::WellFormed(_)\n                 | ty::PredicateKind::Projection(_)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::WellFormedConst(..) => continue,\n+                | ty::PredicateKind::ConstEquate(..) => continue,\n                 ty::PredicateKind::ObjectSafe(_) => {\n                     bug!(\"object safe predicate on function: {:#?}\", predicate)\n                 }"}, {"sha": "f78a6207a3ab53558b5b171f3b573821c90a42aa", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -1277,8 +1277,7 @@ crate fn required_region_bounds(\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::RegionOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::WellFormedConst(..) => None,\n+                | ty::PredicateKind::ConstEquate(..) => None,\n                 ty::PredicateKind::TypeOutlives(predicate) => {\n                     // Search for a bound of the form `erased_self_ty\n                     // : 'a`, but be wary of something like `for<'a>"}, {"sha": "41811bf44b1aff3f48553d983414bfb866b0930d", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -19,6 +19,7 @@ use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::TypeFolder;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n     self, fast_reject, AdtKind, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt,\n     TypeFoldable, WithConstness,\n@@ -610,15 +611,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n-                    ty::PredicateKind::WellFormedConst(ct) => {\n-                        // Const WF predicates cannot themselves make\n-                        // errors. They can only block due to\n-                        // ambiguity; otherwise, they always\n-                        // degenerate into other obligations\n-                        // (which may fail).\n-                        span_bug!(span, \"const WF predicate not satisfied for {:?}\", ct);\n-                    }\n-\n                     ty::PredicateKind::ConstEvaluatable(..) => {\n                         // Errors for `ConstEvaluatable` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n@@ -1540,22 +1532,24 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err\n             }\n \n-            ty::PredicateKind::WellFormed(ty) => {\n+            ty::PredicateKind::WellFormed(arg) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n-                if ty.references_error() || self.tcx.sess.has_errors() {\n+                if arg.references_error() || self.tcx.sess.has_errors() {\n                     return;\n                 }\n-                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n-            }\n \n-            ty::PredicateKind::WellFormedConst(ct) => {\n-                // Same hacky approach as above to avoid deluging user\n-                // with error messages.\n-                if ct.references_error() || self.tcx.sess.has_errors() {\n-                    return;\n+                match arg.unpack() {\n+                    GenericArgKind::Lifetime(lt) => {\n+                        span_bug!(span, \"unexpected well formed predicate: {:?}\", lt)\n+                    }\n+                    GenericArgKind::Type(ty) => {\n+                        self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n+                    }\n+                    GenericArgKind::Const(ct) => {\n+                        self.need_type_info_err_const(body_id, span, ct, ErrorCode::E0282)\n+                    }\n                 }\n-                self.need_type_info_err_const(body_id, span, ct, ErrorCode::E0282)\n             }\n \n             ty::PredicateKind::Subtype(ref data) => {"}, {"sha": "51c62dbb88c845194c00932dd523afeaef062e43", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -459,38 +459,23 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::WellFormed(ty) => {\n+            &ty::PredicateKind::WellFormed(arg) => {\n                 match wf::obligations(\n                     self.selcx.infcx(),\n                     obligation.param_env,\n                     obligation.cause.body_id,\n-                    ty,\n+                    arg,\n                     obligation.cause.span,\n                 ) {\n                     None => {\n                         pending_obligation.stalled_on =\n-                            vec![TyOrConstInferVar::maybe_from_ty(ty).unwrap()];\n+                            vec![TyOrConstInferVar::maybe_from_generic_arg(arg).unwrap()];\n                         ProcessResult::Unchanged\n                     }\n                     Some(os) => ProcessResult::Changed(mk_pending(os)),\n                 }\n             }\n \n-            ty::PredicateKind::WellFormedConst(constant) => match wf::const_obligations(\n-                self.selcx.infcx(),\n-                obligation.param_env,\n-                obligation.cause.body_id,\n-                constant,\n-                obligation.cause.span,\n-            ) {\n-                Some(predicates) => ProcessResult::Changed(mk_pending(predicates)),\n-                None => {\n-                    pending_obligation.stalled_on =\n-                        vec![TyOrConstInferVar::maybe_from_const(constant).unwrap()];\n-                    ProcessResult::Unchanged\n-                }\n-            },\n-\n             &ty::PredicateKind::Subtype(subtype) => {\n                 match self.selcx.infcx().subtype_predicate(\n                     &obligation.cause,"}, {"sha": "5befc797a517a39573862a48ac70447a307931d6", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -283,8 +283,7 @@ fn predicates_reference_self(\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::WellFormedConst(..) => None,\n+                | ty::PredicateKind::ConstEquate(..) => None,\n             }\n         })\n         .collect()\n@@ -319,8 +318,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::WellFormedConst(..) => false,\n+            | ty::PredicateKind::ConstEquate(..) => false,\n         }\n     })\n }"}, {"sha": "517433b90ee1221bb681e8ef6ba98ddf5fff1713", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -436,25 +436,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::WellFormed(ty) => match wf::obligations(\n+            &ty::PredicateKind::WellFormed(arg) => match wf::obligations(\n                 self.infcx,\n                 obligation.param_env,\n                 obligation.cause.body_id,\n-                ty,\n-                obligation.cause.span,\n-            ) {\n-                Some(mut obligations) => {\n-                    self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n-                    self.evaluate_predicates_recursively(previous_stack, obligations.into_iter())\n-                }\n-                None => Ok(EvaluatedToAmbig),\n-            },\n-\n-            ty::PredicateKind::WellFormedConst(constant) => match wf::const_obligations(\n-                self.infcx,\n-                obligation.param_env,\n-                obligation.cause.body_id,\n-                constant,\n+                arg,\n                 obligation.cause.span,\n             ) {\n                 Some(mut obligations) => {"}, {"sha": "dde50a849527de4fb2e04019b02b6e8ccdb61860", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -9,69 +9,61 @@ use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstnes\n use rustc_span::Span;\n use std::rc::Rc;\n \n-/// Returns the set of obligations needed to make `ty` well-formed.\n-/// If `ty` contains unresolved inference variables, this may include\n-/// further WF obligations. However, if `ty` IS an unresolved\n+/// Returns the set of obligations needed to make `arg` well-formed.\n+/// If `arg` contains unresolved inference variables, this may include\n+/// further WF obligations. However, if `arg` IS an unresolved\n /// inference variable, returns `None`, because we are not able to\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n pub fn obligations<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n-    ty: Ty<'tcx>,\n+    arg: GenericArg<'tcx>,\n     span: Span,\n ) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n     // Handle the \"livelock\" case (see comment above) by bailing out if necessary.\n-    let ty = match ty.kind {\n-        ty::Infer(ty::TyVar(_)) => {\n-            let resolved_ty = infcx.shallow_resolve(ty);\n-            if resolved_ty == ty {\n-                // No progress, bail out to prevent \"livelock\".\n-                return None;\n-            }\n+    let arg = match arg.unpack() {\n+        GenericArgKind::Type(ty) => {\n+            match ty.kind {\n+                ty::Infer(ty::TyVar(_)) => {\n+                    let resolved_ty = infcx.shallow_resolve(ty);\n+                    if resolved_ty == ty {\n+                        // No progress, bail out to prevent \"livelock\".\n+                        return None;\n+                    }\n \n-            resolved_ty\n+                    resolved_ty\n+                }\n+                _ => ty,\n+            }\n+            .into()\n         }\n-        _ => ty,\n-    };\n-\n-    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n-    wf.compute(ty.into());\n-    debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n-\n-    let result = wf.normalize();\n-    debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", ty, body_id, result);\n-    Some(result)\n-}\n+        GenericArgKind::Const(ct) => {\n+            match ct.val {\n+                ty::ConstKind::Infer(infer) => {\n+                    let resolved = infcx.shallow_resolve(infer);\n+                    if resolved == infer {\n+                        // No progress.\n+                        return None;\n+                    }\n \n-/// Returns the set of obligations needed to make the `constant` well-formed.\n-pub fn const_obligations<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body_id: hir::HirId,\n-    constant: &'tcx ty::Const<'tcx>,\n-    span: Span,\n-) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n-    let constant = match constant.val {\n-        ty::ConstKind::Infer(infer) => {\n-            let resolved = infcx.shallow_resolve(infer);\n-            if resolved == infer {\n-                // No progress.\n-                return None;\n+                    infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Infer(resolved), ty: ct.ty })\n+                }\n+                _ => ct,\n             }\n-\n-            infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Infer(resolved), ..*constant })\n+            .into()\n         }\n-        _ => constant,\n+        // There is nothing we have to do for lifetimes.\n+        GenericArgKind::Lifetime(..) => return Some(Vec::new()),\n     };\n \n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n-    wf.compute(constant.into());\n-    debug!(\"wf::const obligations({:?}, body_id={:?}) = {:?}\", constant, body_id, wf.out);\n+    wf.compute(arg);\n+    debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", arg, body_id, wf.out);\n \n     let result = wf.normalize();\n-    debug!(\"wf::const obligations({:?}, body_id={:?}) ~~> {:?}\", constant, body_id, result);\n+    debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", arg, body_id, result);\n     Some(result)\n }\n \n@@ -115,8 +107,8 @@ pub fn predicate_obligations<'a, 'tcx>(\n             wf.compute_projection(t.projection_ty);\n             wf.compute(t.ty.into());\n         }\n-        &ty::PredicateKind::WellFormed(t) => {\n-            wf.compute(t.into());\n+        &ty::PredicateKind::WellFormed(arg) => {\n+            wf.compute(arg);\n         }\n         ty::PredicateKind::ObjectSafe(_) => {}\n         ty::PredicateKind::ClosureKind(..) => {}\n@@ -128,17 +120,14 @@ pub fn predicate_obligations<'a, 'tcx>(\n             let obligations = wf.nominal_obligations(def_id, substs);\n             wf.out.extend(obligations);\n \n-            for subst in substs.iter() {\n-                wf.compute(subst);\n+            for arg in substs.iter() {\n+                wf.compute(arg);\n             }\n         }\n         &ty::PredicateKind::ConstEquate(c1, c2) => {\n             wf.compute(c1.into());\n             wf.compute(c2.into());\n         }\n-        &ty::PredicateKind::WellFormedConst(constant) => {\n-            wf.compute(constant.into());\n-        }\n     }\n \n     wf.normalize()\n@@ -306,15 +295,22 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         }\n \n         let tcx = self.tcx();\n-        self.out.extend(trait_ref.substs.types().filter(|ty| !ty.has_escaping_bound_vars()).map(\n-            |ty| {\n-                traits::Obligation::new(\n-                    cause.clone(),\n-                    param_env,\n-                    ty::PredicateKind::WellFormed(ty).to_predicate(tcx),\n-                )\n-            },\n-        ));\n+        self.out.extend(\n+            trait_ref\n+                .substs\n+                .iter()\n+                .filter(|arg| {\n+                    matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n+                })\n+                .filter(|arg| !arg.has_escaping_bound_vars())\n+                .map(|arg| {\n+                    traits::Obligation::new(\n+                        cause.clone(),\n+                        param_env,\n+                        ty::PredicateKind::WellFormed(arg).to_predicate(tcx),\n+                    )\n+                }),\n+        );\n     }\n \n     /// Pushes the obligations required for `trait_ref::Item` to be WF\n@@ -390,7 +386,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 self.out.push(traits::Obligation::new(\n                                     cause,\n                                     self.param_env,\n-                                    ty::PredicateKind::WellFormedConst(resolved_constant)\n+                                    ty::PredicateKind::WellFormed(resolved_constant.into())\n                                         .to_predicate(self.tcx()),\n                                 ));\n                             }\n@@ -594,7 +590,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx()),\n+                            ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()),\n                         ));\n                     } else {\n                         // Yes, resolved, proceed with the result."}, {"sha": "9530b07e47cdb054ed552c57ad3391ac564d26f2", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -36,7 +36,7 @@ use rustc_middle::traits::{\n     ChalkRustInterner as RustInterner,\n };\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n     self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable, TypeVisitor,\n };\n@@ -126,8 +126,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::Subtype(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n-                    | ty::PredicateKind::ConstEquate(..)\n-                    | ty::PredicateKind::WellFormedConst(..) => {\n+                    | ty::PredicateKind::ConstEquate(..) => {\n                         bug!(\"unexpected predicate {}\", predicate)\n                     }\n                 }\n@@ -166,24 +165,31 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n             ty::PredicateKind::Projection(predicate) => predicate.lower_into(interner),\n-            ty::PredicateKind::WellFormed(ty) => match ty.kind {\n-                // These types are always WF.\n-                ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n-                    chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n-                }\n+            ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n+                GenericArgKind::Type(ty) => match ty.kind {\n+                    // These types are always WF.\n+                    ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n+                        chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+                    }\n \n-                // FIXME(chalk): Well-formed only if ref lifetime outlives type\n-                ty::Ref(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n+                    // FIXME(chalk): Well-formed only if ref lifetime outlives type\n+                    ty::Ref(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n \n-                ty::Param(..) => panic!(\"No Params expected.\"),\n+                    ty::Param(..) => panic!(\"No Params expected.\"),\n \n-                // FIXME(chalk) -- ultimately I think this is what we\n-                // want to do, and we just have rules for how to prove\n-                // `WellFormed` for everything above, instead of\n-                // inlining a bit the rules of the proof here.\n-                _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n-                    chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n-                )),\n+                    // FIXME(chalk) -- ultimately I think this is what we\n+                    // want to do, and we just have rules for how to prove\n+                    // `WellFormed` for everything above, instead of\n+                    // inlining a bit the rules of the proof here.\n+                    _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n+                        chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n+                    )),\n+                },\n+                // FIXME(chalk): handle well formed consts\n+                GenericArgKind::Const(..) => {\n+                    chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+                }\n+                GenericArgKind::Lifetime(lt) => bug!(\"unexpect well formed predicate: {:?}\", lt),\n             },\n \n             // FIXME(chalk): other predicates\n@@ -194,8 +200,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::WellFormedConst(..) => {\n+            | ty::PredicateKind::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n         }\n@@ -462,8 +467,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::WellFormedConst(..) => bug!(\"unexpected predicate {}\", &self),\n+            | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n         }\n     }\n }"}, {"sha": "651596d0379bb7cbbdc68ab176b56dc3682da5dc", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -47,22 +47,22 @@ fn compute_implied_outlives_bounds<'tcx>(\n     // process it next. Currently (at least) these resulting\n     // predicates are always guaranteed to be a subset of the original\n     // type, so we need not fear non-termination.\n-    let mut wf_types = vec![ty];\n+    let mut wf_args = vec![ty.into()];\n \n     let mut implied_bounds = vec![];\n \n     let mut fulfill_cx = FulfillmentContext::new();\n \n-    while let Some(ty) = wf_types.pop() {\n-        // Compute the obligations for `ty` to be well-formed. If `ty` is\n+    while let Some(arg) = wf_args.pop() {\n+        // Compute the obligations for `arg` to be well-formed. If `arg` is\n         // an unresolved inference variable, just substituted an empty set\n         // -- because the return type here is going to be things we *add*\n         // to the environment, it's always ok for this set to be smaller\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n         let obligations =\n-            wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n+            wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, arg, DUMMY_SP).unwrap_or(vec![]);\n \n         // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by\n@@ -101,11 +101,10 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::WellFormedConst(..) => vec![],\n+                | ty::PredicateKind::ConstEquate(..) => vec![],\n \n-                ty::PredicateKind::WellFormed(subty) => {\n-                    wf_types.push(subty);\n+                &ty::PredicateKind::WellFormed(arg) => {\n+                    wf_args.push(arg);\n                     vec![]\n                 }\n "}, {"sha": "fcb75142269df50250985f933087c3093538a7d7", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -49,7 +49,6 @@ fn not_outlives_predicate(p: &ty::Predicate<'_>) -> bool {\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::Subtype(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..)\n-        | ty::PredicateKind::WellFormedConst(..) => true,\n+        | ty::PredicateKind::ConstEquate(..) => true,\n     }\n }"}, {"sha": "374ef3fc9c783f1ea96c6c180110e03d7dea5bd7", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -140,7 +140,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n             self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n \n             self.prove_predicate(\n-                ty::PredicateKind::WellFormed(impl_self_ty).to_predicate(self.tcx()),\n+                ty::PredicateKind::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n             );\n         }\n \n@@ -155,7 +155,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx()));\n+        self.prove_predicate(ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()));\n         Ok(())\n     }\n }"}, {"sha": "aa316105f7f11be99809a1e6d5ca07e683939591", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // we must check that return type of called functions is WF:\n-        self.register_wf_obligation(output, call_expr.span, traits::MiscObligation);\n+        self.register_wf_obligation(output.into(), call_expr.span, traits::MiscObligation);\n \n         output\n     }"}, {"sha": "007794ce1b7ffff34401b193375b5fbd6752b291", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // the function type must also be well-formed (this is not\n         // implied by the substs being well-formed because of inherent\n         // impls and late-bound regions - see issue #28609).\n-        self.register_wf_obligation(fty, self.span, traits::MiscObligation);\n+        self.register_wf_obligation(fty.into(), self.span, traits::MiscObligation);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "ac3fa15417e9cc3bc02289781ea7dfff5ed1176c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.push(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormed(method_ty).to_predicate(tcx),\n+            ty::PredicateKind::WellFormed(method_ty.into()).to_predicate(tcx),\n         ));\n \n         let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };"}, {"sha": "91562d576ea809e3d34598fbe5e4b6f531f6d162", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -814,8 +814,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::TypeOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::WellFormedConst(..) => None,\n+                | ty::PredicateKind::ConstEquate(..) => None,\n             });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {"}, {"sha": "275581318f75d58c4fc1db75f52525a93a84d53f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 44, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -121,9 +121,8 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::{\n-    GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSelfTy, UserSubsts,\n-};\n+use rustc_middle::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArgKind, UserSelfTy, UserSubsts};\n use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n use rustc_middle::ty::{\n     self, AdtKind, CanonicalUserType, Const, GenericParamDefKind, RegionKind, ToPolyTraitRef,\n@@ -3333,7 +3332,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> Ty<'tcx> {\n         let t = AstConv::ast_ty_to_ty(self, ast_t);\n-        self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n+        self.register_wf_obligation(t.into(), ast_t.span, traits::MiscObligation);\n         t\n     }\n \n@@ -3353,8 +3352,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn to_const(&self, ast_c: &hir::AnonConst) -> &'tcx ty::Const<'tcx> {\n         let const_def_id = self.tcx.hir().local_def_id(ast_c.hir_id);\n         let c = ty::Const::from_anon_const(self.tcx, const_def_id);\n-        self.register_wf_const_obligation(\n-            c,\n+        self.register_wf_obligation(\n+            c.into(),\n             self.tcx.hir().span(ast_c.hir_id),\n             ObligationCauseCode::MiscObligation,\n         );\n@@ -3394,24 +3393,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// outlive the region `r`.\n     pub fn register_wf_obligation(\n         &self,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-        code: traits::ObligationCauseCode<'tcx>,\n-    ) {\n-        // WF obligations never themselves fail, so no real need to give a detailed cause:\n-        let cause = traits::ObligationCause::new(span, self.body_id, code);\n-        self.register_predicate(traits::Obligation::new(\n-            cause,\n-            self.param_env,\n-            ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx),\n-        ));\n-    }\n-\n-    /// Registers an obligation for checking later, during regionck, that the type `ty` must\n-    /// outlive the region `r`.\n-    pub fn register_wf_const_obligation(\n-        &self,\n-        ct: &'tcx ty::Const<'tcx>,\n+        arg: subst::GenericArg<'tcx>,\n         span: Span,\n         code: traits::ObligationCauseCode<'tcx>,\n     ) {\n@@ -3420,28 +3402,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.register_predicate(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormedConst(ct).to_predicate(self.tcx),\n+            ty::PredicateKind::WellFormed(arg).to_predicate(self.tcx),\n         ));\n     }\n \n     /// Registers obligations that all `substs` are well-formed.\n     pub fn add_wf_bounds(&self, substs: SubstsRef<'tcx>, expr: &hir::Expr<'_>) {\n-        for subst in substs {\n-            match subst.unpack() {\n-                GenericArgKind::Lifetime(..) => {\n-                    // Nothing to do for lifetimes.\n-                }\n-                GenericArgKind::Type(ty) => {\n-                    if !ty.references_error() {\n-                        self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n-                    }\n-                }\n-                GenericArgKind::Const(ct) => {\n-                    if !ct.references_error() {\n-                        self.register_wf_const_obligation(ct, expr.span, traits::MiscObligation);\n-                    }\n-                }\n-            }\n+        for arg in substs.iter().filter(|arg| {\n+            matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n+        }) {\n+            self.register_wf_obligation(arg, expr.span, traits::MiscObligation);\n         }\n     }\n \n@@ -3872,7 +3842,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ty::PredicateKind::RegionOutlives(..) => None,\n                 ty::PredicateKind::TypeOutlives(..) => None,\n                 ty::PredicateKind::WellFormed(..) => None,\n-                ty::PredicateKind::WellFormedConst(..) => None,\n                 ty::PredicateKind::ObjectSafe(..) => None,\n                 ty::PredicateKind::ConstEvaluatable(..) => None,\n                 ty::PredicateKind::ConstEquate(..) => None,\n@@ -3914,8 +3883,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // All the input types from the fn signature must outlive the call\n         // so as to validate implied bounds.\n-        for (fn_input_ty, arg_expr) in fn_inputs.iter().zip(args.iter()) {\n-            self.register_wf_obligation(fn_input_ty, arg_expr.span, traits::MiscObligation);\n+        for (&fn_input_ty, arg_expr) in fn_inputs.iter().zip(args.iter()) {\n+            self.register_wf_obligation(fn_input_ty.into(), arg_expr.span, traits::MiscObligation);\n         }\n \n         let expected_arg_count = fn_inputs.len();"}, {"sha": "7d9bf975c6913c7d2e87102a9cbac8bb8637bfda", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -292,7 +292,7 @@ fn check_associated_item(\n             ty::AssocKind::Const => {\n                 let ty = fcx.tcx.type_of(item.def_id);\n                 let ty = fcx.normalize_associated_types_in(span, &ty);\n-                fcx.register_wf_obligation(ty, span, code.clone());\n+                fcx.register_wf_obligation(ty.into(), span, code.clone());\n             }\n             ty::AssocKind::Fn => {\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n@@ -313,7 +313,7 @@ fn check_associated_item(\n                 if item.defaultness.has_value() {\n                     let ty = fcx.tcx.type_of(item.def_id);\n                     let ty = fcx.normalize_associated_types_in(span, &ty);\n-                    fcx.register_wf_obligation(ty, span, code.clone());\n+                    fcx.register_wf_obligation(ty.into(), span, code.clone());\n                 }\n             }\n             ty::AssocKind::OpaqueTy => {\n@@ -406,7 +406,7 @@ fn check_type_defn<'tcx, F>(\n             // All field types must be well-formed.\n             for field in &variant.fields {\n                 fcx.register_wf_obligation(\n-                    field.ty,\n+                    field.ty.into(),\n                     field.span,\n                     ObligationCauseCode::MiscObligation,\n                 )\n@@ -601,7 +601,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n             }\n         }\n \n-        fcx.register_wf_obligation(item_ty, ty_span, ObligationCauseCode::MiscObligation);\n+        fcx.register_wf_obligation(item_ty.into(), ty_span, ObligationCauseCode::MiscObligation);\n         if forbid_unsized {\n             fcx.register_bound(\n                 item_ty,\n@@ -650,7 +650,7 @@ fn check_impl<'tcx>(\n                 let self_ty = fcx.tcx.type_of(item_def_id);\n                 let self_ty = fcx.normalize_associated_types_in(item.span, &self_ty);\n                 fcx.register_wf_obligation(\n-                    self_ty,\n+                    self_ty.into(),\n                     ast_self_ty.span,\n                     ObligationCauseCode::MiscObligation,\n                 );\n@@ -698,7 +698,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                 // be sure if it will error or not as user might always specify the other.\n                 if !ty.needs_subst() {\n                     fcx.register_wf_obligation(\n-                        ty,\n+                        ty.into(),\n                         fcx.tcx.def_span(param.def_id),\n                         ObligationCauseCode::MiscObligation,\n                     );\n@@ -841,13 +841,13 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     let sig = fcx.normalize_associated_types_in(span, &sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n \n-    for (input_ty, span) in sig.inputs().iter().zip(hir_sig.decl.inputs.iter().map(|t| t.span)) {\n-        fcx.register_wf_obligation(&input_ty, span, ObligationCauseCode::MiscObligation);\n+    for (&input_ty, span) in sig.inputs().iter().zip(hir_sig.decl.inputs.iter().map(|t| t.span)) {\n+        fcx.register_wf_obligation(input_ty.into(), span, ObligationCauseCode::MiscObligation);\n     }\n     implied_bounds.extend(sig.inputs());\n \n     fcx.register_wf_obligation(\n-        sig.output(),\n+        sig.output().into(),\n         hir_sig.decl.output.span(),\n         ObligationCauseCode::ReturnType,\n     );"}, {"sha": "e4bffedd620b99e2110a533acfb29ba528515a0c", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -332,12 +332,12 @@ fn check_predicates<'tcx>(\n         });\n \n     // Include the well-formed predicates of the type parameters of the impl.\n-    for ty in tcx.impl_trait_ref(impl1_def_id).unwrap().substs.types() {\n+    for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().substs {\n         if let Some(obligations) = wf::obligations(\n             infcx,\n             tcx.param_env(impl1_def_id),\n             tcx.hir().as_local_hir_id(impl1_def_id),\n-            ty,\n+            arg,\n             span,\n         ) {\n             impl2_predicates\n@@ -405,7 +405,6 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::ObjectSafe(_)\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..)\n-        | ty::PredicateKind::WellFormedConst(..) => None,\n+        | ty::PredicateKind::ConstEquate(..) => None,\n     }\n }"}, {"sha": "5740cc224cc572f7615f73845839d82c9cf396ab", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -59,8 +59,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::Subtype(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n-                    | ty::PredicateKind::ConstEquate(..)\n-                    | ty::PredicateKind::WellFormedConst(..) => (),\n+                    | ty::PredicateKind::ConstEquate(..) => (),\n                 }\n             }\n "}, {"sha": "371df7444b004e8e188480e72e48763b7679780a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4d2c10430c941619ccc517e709f093a4ea9689/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ef4d2c10430c941619ccc517e709f093a4ea9689", "patch": "@@ -491,8 +491,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::WellFormedConst(..) => panic!(\"not user writable\"),\n+            | ty::PredicateKind::ConstEquate(..) => panic!(\"not user writable\"),\n         }\n     }\n }"}]}