{"sha": "de806bc057caa599fce959ce56259e6e919f1041", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlODA2YmMwNTdjYWE1OTlmY2U5NTljZTU2MjU5ZTZlOTE5ZjEwNDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-26T12:07:55Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:36:22Z"}, "message": "Teach `project` to project associated types out of object types.", "tree": {"sha": "8531798d6dc6a503691210b7b9ab5fb4e642e069", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8531798d6dc6a503691210b7b9ab5fb4e642e069"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de806bc057caa599fce959ce56259e6e919f1041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de806bc057caa599fce959ce56259e6e919f1041", "html_url": "https://github.com/rust-lang/rust/commit/de806bc057caa599fce959ce56259e6e919f1041", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de806bc057caa599fce959ce56259e6e919f1041/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b53b11ad9aed822ce4c573714de6cb28289f321", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b53b11ad9aed822ce4c573714de6cb28289f321", "html_url": "https://github.com/rust-lang/rust/commit/5b53b11ad9aed822ce4c573714de6cb28289f321"}], "stats": {"total": 133, "additions": 116, "deletions": 17}, "files": [{"sha": "0594c0ac3b833445e822827056868525a0057cc4", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/de806bc057caa599fce959ce56259e6e919f1041/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de806bc057caa599fce959ce56259e6e919f1041/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=de806bc057caa599fce959ce56259e6e919f1041", "patch": "@@ -19,7 +19,7 @@ use super::VtableImplData;\n \n use middle::infer;\n use middle::subst::Subst;\n-use middle::ty::{mod, ToPolyTraitRef, Ty};\n+use middle::ty::{mod, AsPredicate, ToPolyTraitRef, Ty};\n use std::fmt;\n use util::ppaux::Repr;\n \n@@ -46,7 +46,7 @@ pub enum ProjectionError<'tcx> {\n \n #[deriving(Clone)]\n pub struct MismatchedProjectionTypes<'tcx> {\n-    pub err: ty::type_err<'tcx> // TODO expected/actual/etc\n+    pub err: ty::type_err<'tcx>\n }\n \n pub type ProjectionResult<'tcx, T> = Result<T, ProjectionError<'tcx>>;\n@@ -123,9 +123,20 @@ pub fn project_type<'cx,'tcx>(\n                                                 obligation,\n                                                 &mut candidates);\n \n-    let () = try!(assemble_candidates_from_impls(selcx,\n-                                                 obligation,\n-                                                 &mut candidates));\n+    let () = assemble_candidates_from_object_type(selcx,\n+                                                  obligation,\n+                                                  &mut candidates);\n+\n+    if candidates.vec.is_empty() {\n+        // TODO This `if` is not necessarily wrong, but it needs an\n+        // explanation, and it should probably be accompanied by a\n+        // similar rule in `select.rs`. Currently it's *needed*\n+        // because the impl-trait-for-trait branch has not landed.\n+\n+        let () = try!(assemble_candidates_from_impls(selcx,\n+                                                     obligation,\n+                                                     &mut candidates));\n+    }\n \n     debug!(\"{} candidates, ambiguous={}\",\n            candidates.vec.len(),\n@@ -155,9 +166,21 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n     obligation:  &ProjectionTyObligation<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n-    let infcx = selcx.infcx();\n     let env_predicates = selcx.param_env().caller_bounds.predicates.clone();\n     let env_predicates = env_predicates.iter().cloned().collect();\n+    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates);\n+}\n+\n+fn assemble_candidates_from_predicates<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    env_predicates: Vec<ty::Predicate<'tcx>>)\n+{\n+    debug!(\"assemble_candidates_from_predicates(obligation={}, env_predicates={})\",\n+           obligation.repr(selcx.tcx()),\n+           env_predicates.repr(selcx.tcx()));\n+    let infcx = selcx.infcx();\n     for predicate in elaborate_predicates(selcx.tcx(), env_predicates) {\n         match predicate {\n             ty::Predicate::Projection(ref data) => {\n@@ -183,6 +206,26 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n     }\n }\n \n+fn assemble_candidates_from_object_type<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+{\n+    let infcx = selcx.infcx();\n+    let trait_ref = infcx.resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n+    debug!(\"assemble_candidates_from_object_type(trait_ref={})\",\n+           trait_ref.repr(infcx.tcx));\n+    let self_ty = trait_ref.self_ty();\n+    let data = match self_ty.sty {\n+        ty::ty_trait(ref data) => data,\n+        _ => { return; }\n+    };\n+    let env_predicates = data.projection_bounds_with_self_ty(self_ty).iter()\n+                                                                     .map(|p| p.as_predicate())\n+                                                                     .collect();\n+    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates)\n+}\n+\n fn assemble_candidates_from_impls<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,"}, {"sha": "98539b4d15260a68b27b650bfa487e560ac00076", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/de806bc057caa599fce959ce56259e6e919f1041/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de806bc057caa599fce959ce56259e6e919f1041/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=de806bc057caa599fce959ce56259e6e919f1041", "patch": "@@ -1401,6 +1401,31 @@ impl<'tcx> TyTrait<'tcx> {\n             substs: tcx.mk_substs(self.principal.0.substs.with_self_ty(self_ty)),\n         }))\n     }\n+\n+    pub fn projection_bounds_with_self_ty(&self, self_ty: Ty<'tcx>)\n+                                          -> Vec<ty::PolyProjectionPredicate<'tcx>>\n+    {\n+        // otherwise the escaping regions would be captured by the binders\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        self.bounds.projection_bounds.iter()\n+            .map(|in_poly_projection_predicate| {\n+                let in_projection_ty = &in_poly_projection_predicate.0.projection_ty;\n+                let trait_ref =\n+                    Rc::new(ty::TraitRef::new(\n+                        in_projection_ty.trait_ref.def_id,\n+                        in_projection_ty.trait_ref.substs.with_self_ty(self_ty)));\n+                let projection_ty = ty::ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: in_projection_ty.item_name\n+                };\n+                ty::Binder(ty::ProjectionPredicate {\n+                    projection_ty: projection_ty,\n+                    ty: in_poly_projection_predicate.0.ty\n+                })\n+            })\n+            .collect()\n+    }\n }\n \n /// A complete reference to a trait. These take numerous guises in syntax,"}, {"sha": "f5cbfcdcc5216d488495d2ce5ff0db5d951d2ecd", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/de806bc057caa599fce959ce56259e6e919f1041/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de806bc057caa599fce959ce56259e6e919f1041/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=de806bc057caa599fce959ce56259e6e919f1041", "patch": "@@ -13,12 +13,12 @@ use middle::subst::{FnSpace, SelfSpace};\n use middle::traits;\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n-use middle::ty::{mod, Ty, AsPredicate, ToPolyTraitRef};\n+use middle::ty::{mod, Ty, AsPredicate};\n use middle::infer;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::{Repr, ty_to_string};\n+use util::nodemap::FnvHashSet;\n+use util::ppaux::{Repr, UserString};\n \n pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    cast_expr: &ast::Expr,\n@@ -133,10 +133,33 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TyTrait<'tcx>,\n                                  span: Span)\n {\n+    // Also check that the type `object_trait` specifies all\n+    // associated types for all supertraits.\n+    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> = FnvHashSet::new();\n+\n     let object_trait_ref =\n         object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n-    for tr in traits::supertraits(tcx, object_trait_ref) {\n+    for tr in traits::supertraits(tcx, object_trait_ref.clone()) {\n         check_object_safety_inner(tcx, &tr, span);\n+\n+        let trait_def = ty::lookup_trait_def(tcx, object_trait_ref.def_id());\n+        for &associated_type_name in trait_def.associated_type_names.iter() {\n+            associated_types.insert((object_trait_ref.def_id(), associated_type_name));\n+        }\n+    }\n+\n+    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n+        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n+                    projection_bound.0.projection_ty.item_name);\n+        associated_types.remove(&pair);\n+    }\n+\n+    for (trait_def_id, name) in associated_types.into_iter() {\n+        tcx.sess.span_err(\n+            span,\n+            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+                    name.user_string(tcx),\n+                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n     }\n }\n \n@@ -201,7 +224,7 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 Some(format!(\n                     \"cannot call a method (`{}`) whose type contains \\\n                      a self-type (`{}`) through a trait object\",\n-                    method_name, ty_to_string(tcx, ty)))\n+                    method_name, ty.user_string(tcx)))\n             } else {\n                 None\n             }\n@@ -343,15 +366,15 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            referent_ty.repr(fcx.tcx()),\n            object_trait_ty.repr(fcx.tcx()));\n \n+    let cause = ObligationCause::new(span,\n+                                     fcx.body_id,\n+                                     traits::ObjectCastObligation(object_trait_ty));\n+\n     // Create the obligation for casting from T to Trait.\n     let object_trait_ref =\n         object_trait.principal_trait_ref_with_self_ty(fcx.tcx(), referent_ty);\n     let object_obligation =\n-        Obligation::new(\n-            ObligationCause::new(span,\n-                                 fcx.body_id,\n-                                 traits::ObjectCastObligation(object_trait_ty)),\n-            object_trait_ref.as_predicate());\n+        Obligation::new(cause.clone(), object_trait_ref.as_predicate());\n     fcx.register_predicate(object_obligation);\n \n     // Create additional obligations for all the various builtin\n@@ -362,7 +385,15 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.register_builtin_bound(\n             referent_ty,\n             builtin_bound,\n-            ObligationCause::new(span, fcx.body_id, traits::ObjectCastObligation(object_trait_ty)));\n+            cause.clone());\n+    }\n+\n+    // Finally, create obligations for the projection predicates.\n+    let projection_bounds = object_trait.projection_bounds_with_self_ty(referent_ty);\n+    for projection_bound in projection_bounds.iter() {\n+        let projection_obligation =\n+            Obligation::new(cause.clone(), projection_bound.as_predicate());\n+        fcx.register_predicate(projection_obligation);\n     }\n \n     object_trait_ref"}]}