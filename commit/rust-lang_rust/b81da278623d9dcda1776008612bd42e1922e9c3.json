{"sha": "b81da278623d9dcda1776008612bd42e1922e9c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MWRhMjc4NjIzZDlkY2RhMTc3NjAwODYxMmJkNDJlMTkyMmU5YzM=", "commit": {"author": {"name": "NODA, Kai", "email": "nodakai@gmail.com", "date": "2018-06-09T13:13:04Z"}, "committer": {"name": "NODA, Kai", "email": "nodakai@gmail.com", "date": "2018-06-17T07:18:32Z"}, "message": "libstd: add an RAII utility for sys_common::mutex::Mutex\n\nSigned-off-by: NODA, Kai <nodakai@gmail.com>", "tree": {"sha": "9aea5b4aef36eeffec197b0afb61c160e1b8c2be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9aea5b4aef36eeffec197b0afb61c160e1b8c2be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b81da278623d9dcda1776008612bd42e1922e9c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b81da278623d9dcda1776008612bd42e1922e9c3", "html_url": "https://github.com/rust-lang/rust/commit/b81da278623d9dcda1776008612bd42e1922e9c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b81da278623d9dcda1776008612bd42e1922e9c3/comments", "author": {"login": "nodakai", "id": 90726, "node_id": "MDQ6VXNlcjkwNzI2", "avatar_url": "https://avatars.githubusercontent.com/u/90726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nodakai", "html_url": "https://github.com/nodakai", "followers_url": "https://api.github.com/users/nodakai/followers", "following_url": "https://api.github.com/users/nodakai/following{/other_user}", "gists_url": "https://api.github.com/users/nodakai/gists{/gist_id}", "starred_url": "https://api.github.com/users/nodakai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nodakai/subscriptions", "organizations_url": "https://api.github.com/users/nodakai/orgs", "repos_url": "https://api.github.com/users/nodakai/repos", "events_url": "https://api.github.com/users/nodakai/events{/privacy}", "received_events_url": "https://api.github.com/users/nodakai/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nodakai", "id": 90726, "node_id": "MDQ6VXNlcjkwNzI2", "avatar_url": "https://avatars.githubusercontent.com/u/90726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nodakai", "html_url": "https://github.com/nodakai", "followers_url": "https://api.github.com/users/nodakai/followers", "following_url": "https://api.github.com/users/nodakai/following{/other_user}", "gists_url": "https://api.github.com/users/nodakai/gists{/gist_id}", "starred_url": "https://api.github.com/users/nodakai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nodakai/subscriptions", "organizations_url": "https://api.github.com/users/nodakai/orgs", "repos_url": "https://api.github.com/users/nodakai/repos", "events_url": "https://api.github.com/users/nodakai/events{/privacy}", "received_events_url": "https://api.github.com/users/nodakai/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f8f4903f73a21d7f408870551c08acd051abeb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f8f4903f73a21d7f408870551c08acd051abeb0", "html_url": "https://github.com/rust-lang/rust/commit/0f8f4903f73a21d7f408870551c08acd051abeb0"}], "stats": {"total": 142, "additions": 73, "deletions": 69}, "files": [{"sha": "d357966be9227c9a4552db27dd0834003d3404ca", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=b81da278623d9dcda1776008612bd42e1922e9c3", "patch": "@@ -20,6 +20,9 @@ pub struct Lazy<T> {\n     init: fn() -> Arc<T>,\n }\n \n+#[inline]\n+const fn done<T>() -> *mut Arc<T> { 1_usize as *mut _ }\n+\n unsafe impl<T> Sync for Lazy<T> {}\n \n impl<T: Send + Sync + 'static> Lazy<T> {\n@@ -33,17 +36,15 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n \n     pub fn get(&'static self) -> Option<Arc<T>> {\n         unsafe {\n-            self.lock.lock();\n+            let _guard = self.lock.lock();\n             let ptr = self.ptr.get();\n-            let ret = if ptr.is_null() {\n+            if ptr.is_null() {\n                 Some(self.init())\n-            } else if ptr as usize == 1 {\n+            } else if ptr == done() {\n                 None\n             } else {\n                 Some((*ptr).clone())\n-            };\n-            self.lock.unlock();\n-            return ret\n+            }\n         }\n     }\n \n@@ -53,10 +54,10 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         // the at exit handler). Otherwise we just return the freshly allocated\n         // `Arc`.\n         let registered = sys_common::at_exit(move || {\n-            self.lock.lock();\n-            let ptr = self.ptr.get();\n-            self.ptr.set(1 as *mut _);\n-            self.lock.unlock();\n+            let ptr = {\n+                let _guard = self.lock.lock();\n+                self.ptr.replace(done())\n+            };\n             drop(Box::from_raw(ptr))\n         });\n         let ret = (self.init)();"}, {"sha": "e5a410644b907ce6e4f39d426237798d8deb875e", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=b81da278623d9dcda1776008612bd42e1922e9c3", "patch": "@@ -227,7 +227,7 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe {\n-            self.inner.lock();\n+            self.inner.raw_lock();\n             MutexGuard::new(self)\n         }\n     }\n@@ -454,7 +454,7 @@ impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe {\n             self.__lock.poison.done(&self.__poison);\n-            self.__lock.inner.unlock();\n+            self.__lock.inner.raw_unlock();\n         }\n     }\n }"}, {"sha": "556ed77372e69ba53fcad90f1477fe337a00a52f", "filename": "src/libstd/sys/redox/args.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs?ref=b81da278623d9dcda1776008612bd42e1922e9c3", "patch": "@@ -73,17 +73,15 @@ mod imp {\n             CStr::from_ptr(*argv.offset(i) as *const libc::c_char).to_bytes().to_vec()\n         }).collect();\n \n-        LOCK.lock();\n+        let _guard = LOCK.lock();\n         let ptr = get_global_ptr();\n         assert!((*ptr).is_none());\n         (*ptr) = Some(box args);\n-        LOCK.unlock();\n     }\n \n     pub unsafe fn cleanup() {\n-        LOCK.lock();\n+        let _guard = LOCK.lock();\n         *get_global_ptr() = None;\n-        LOCK.unlock();\n     }\n \n     pub fn args() -> Args {\n@@ -96,16 +94,14 @@ mod imp {\n \n     fn clone() -> Option<Vec<Vec<u8>>> {\n         unsafe {\n-            LOCK.lock();\n+            let _guard = LOCK.lock();\n             let ptr = get_global_ptr();\n-            let ret = (*ptr).as_ref().map(|s| (**s).clone());\n-            LOCK.unlock();\n-            return ret\n+            (*ptr).as_ref().map(|s| (**s).clone())\n         }\n     }\n \n-    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n-        unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n+    unsafe fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n+        mem::transmute(&GLOBAL_ARGS_PTR)\n     }\n \n }"}, {"sha": "dc1dba6f2f9b713bece298a7a85e1419e5402ecc", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=b81da278623d9dcda1776008612bd42e1922e9c3", "patch": "@@ -82,17 +82,15 @@ mod imp {\n     static LOCK: Mutex = Mutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-        LOCK.lock();\n+        let _guard = LOCK.lock();\n         ARGC = argc;\n         ARGV = argv;\n-        LOCK.unlock();\n     }\n \n     pub unsafe fn cleanup() {\n-        LOCK.lock();\n+        let _guard = LOCK.lock();\n         ARGC = 0;\n         ARGV = ptr::null();\n-        LOCK.unlock();\n     }\n \n     pub fn args() -> Args {\n@@ -104,13 +102,11 @@ mod imp {\n \n     fn clone() -> Vec<OsString> {\n         unsafe {\n-            LOCK.lock();\n-            let ret = (0..ARGC).map(|i| {\n+            let _guard = LOCK.lock();\n+            (0..ARGC).map(|i| {\n                 let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n                 OsStringExt::from_vec(cstr.to_bytes().to_vec())\n-            }).collect();\n-            LOCK.unlock();\n-            return ret\n+            }).collect()\n         }\n     }\n }"}, {"sha": "82d05f78850d9531b8edef165978a7654786162d", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=b81da278623d9dcda1776008612bd42e1922e9c3", "patch": "@@ -409,10 +409,9 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n /// environment variables of the current process.\n pub fn env() -> Env {\n     unsafe {\n-        ENV_LOCK.lock();\n+        let _guard = ENV_LOCK.lock();\n         let mut environ = *environ();\n         if environ == ptr::null() {\n-            ENV_LOCK.unlock();\n             panic!(\"os::env() failure getting env string from OS: {}\",\n                    io::Error::last_os_error());\n         }\n@@ -423,12 +422,10 @@ pub fn env() -> Env {\n             }\n             environ = environ.offset(1);\n         }\n-        let ret = Env {\n+        return Env {\n             iter: result.into_iter(),\n             _dont_send_or_sync_me: PhantomData,\n-        };\n-        ENV_LOCK.unlock();\n-        return ret\n+        }\n     }\n \n     fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n@@ -452,15 +449,14 @@ pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     // always None as well\n     let k = CString::new(k.as_bytes())?;\n     unsafe {\n-        ENV_LOCK.lock();\n+        let _guard = ENV_LOCK.lock();\n         let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n         let ret = if s.is_null() {\n             None\n         } else {\n             Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n         };\n-        ENV_LOCK.unlock();\n-        return Ok(ret)\n+        Ok(ret)\n     }\n }\n \n@@ -469,21 +465,17 @@ pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let v = CString::new(v.as_bytes())?;\n \n     unsafe {\n-        ENV_LOCK.lock();\n-        let ret = cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ());\n-        ENV_LOCK.unlock();\n-        return ret\n+        let _guard = ENV_LOCK.lock();\n+        cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ())\n     }\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let nbuf = CString::new(n.as_bytes())?;\n \n     unsafe {\n-        ENV_LOCK.lock();\n-        let ret = cvt(libc::unsetenv(nbuf.as_ptr())).map(|_| ());\n-        ENV_LOCK.unlock();\n-        return ret\n+        let _guard = ENV_LOCK.lock();\n+        cvt(libc::unsetenv(nbuf.as_ptr())).map(|_| ())\n     }\n }\n "}, {"sha": "d268d9ad6f92a6ede331ff86956164a92a8adcdb", "filename": "src/libstd/sys_common/at_exit_imp.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs?ref=b81da278623d9dcda1776008612bd42e1922e9c3", "patch": "@@ -14,6 +14,7 @@\n \n use boxed::FnBox;\n use ptr;\n+use mem;\n use sys_common::mutex::Mutex;\n \n type Queue = Vec<Box<FnBox()>>;\n@@ -25,6 +26,8 @@ type Queue = Vec<Box<FnBox()>>;\n static LOCK: Mutex = Mutex::new();\n static mut QUEUE: *mut Queue = ptr::null_mut();\n \n+const DONE: *mut Queue = 1_usize as *mut _;\n+\n // The maximum number of times the cleanup routines will be run. While running\n // the at_exit closures new ones may be registered, and this count is the number\n // of times the new closures will be allowed to register successfully. After\n@@ -35,7 +38,7 @@ unsafe fn init() -> bool {\n     if QUEUE.is_null() {\n         let state: Box<Queue> = box Vec::new();\n         QUEUE = Box::into_raw(state);\n-    } else if QUEUE as usize == 1 {\n+    } else if QUEUE == DONE {\n         // can't re-init after a cleanup\n         return false\n     }\n@@ -44,18 +47,18 @@ unsafe fn init() -> bool {\n }\n \n pub fn cleanup() {\n-    for i in 0..ITERS {\n+    for i in 1..=ITERS {\n         unsafe {\n-            LOCK.lock();\n-            let queue = QUEUE;\n-            QUEUE = if i == ITERS - 1 {1} else {0} as *mut _;\n-            LOCK.unlock();\n+            let queue = {\n+                let _guard = LOCK.lock();\n+                mem::replace(&mut QUEUE, if i == ITERS { DONE } else { ptr::null_mut() })\n+            };\n \n             // make sure we're not recursively cleaning up\n-            assert!(queue as usize != 1);\n+            assert!(queue != DONE);\n \n             // If we never called init, not need to cleanup!\n-            if queue as usize != 0 {\n+            if !queue.is_null() {\n                 let queue: Box<Queue> = Box::from_raw(queue);\n                 for to_run in *queue {\n                     to_run();\n@@ -66,15 +69,13 @@ pub fn cleanup() {\n }\n \n pub fn push(f: Box<FnBox()>) -> bool {\n-    let mut ret = true;\n     unsafe {\n-        LOCK.lock();\n+        let _guard = LOCK.lock();\n         if init() {\n             (*QUEUE).push(f);\n+            true\n         } else {\n-            ret = false;\n+            false\n         }\n-        LOCK.unlock();\n     }\n-    ret\n }"}, {"sha": "608355b7d70f8421f9e8876f387e93ba4441de3d", "filename": "src/libstd/sys_common/mutex.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmutex.rs?ref=b81da278623d9dcda1776008612bd42e1922e9c3", "patch": "@@ -37,7 +37,15 @@ impl Mutex {\n     /// Behavior is undefined if the mutex has been moved between this and any\n     /// previous function call.\n     #[inline]\n-    pub unsafe fn lock(&self) { self.0.lock() }\n+    pub unsafe fn raw_lock(&self) { self.0.lock() }\n+\n+    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n+    /// will be unlocked.\n+    #[inline]\n+    pub unsafe fn lock(&self) -> MutexGuard {\n+        self.raw_lock();\n+        MutexGuard(&self.0)\n+    }\n \n     /// Attempts to lock the mutex without blocking, returning whether it was\n     /// successfully acquired or not.\n@@ -51,8 +59,11 @@ impl Mutex {\n     ///\n     /// Behavior is undefined if the current thread does not actually hold the\n     /// mutex.\n+    ///\n+    /// Consider switching from the pair of raw_lock() and raw_unlock() to\n+    /// lock() whenever possible.\n     #[inline]\n-    pub unsafe fn unlock(&self) { self.0.unlock() }\n+    pub unsafe fn raw_unlock(&self) { self.0.unlock() }\n \n     /// Deallocates all resources associated with this mutex.\n     ///\n@@ -64,3 +75,14 @@ impl Mutex {\n \n // not meant to be exported to the outside world, just the containing module\n pub fn raw(mutex: &Mutex) -> &imp::Mutex { &mutex.0 }\n+\n+#[must_use]\n+/// A simple RAII utility for the above Mutex without the poisoning semantics.\n+pub struct MutexGuard<'a>(&'a imp::Mutex);\n+\n+impl<'a> Drop for MutexGuard<'a> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe { self.0.unlock(); }\n+    }\n+}"}, {"sha": "75f6b9ac7fd8cf06f74bc059a8e06815becf5e54", "filename": "src/libstd/sys_common/thread_local.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=b81da278623d9dcda1776008612bd42e1922e9c3", "patch": "@@ -162,13 +162,12 @@ impl StaticKey {\n         // we just simplify the whole branch.\n         if imp::requires_synchronized_create() {\n             static INIT_LOCK: Mutex = Mutex::new();\n-            INIT_LOCK.lock();\n+            let _guard = INIT_LOCK.lock();\n             let mut key = self.key.load(Ordering::SeqCst);\n             if key == 0 {\n                 key = imp::create(self.dtor) as usize;\n                 self.key.store(key, Ordering::SeqCst);\n             }\n-            INIT_LOCK.unlock();\n             rtassert!(key != 0);\n             return key\n         }"}, {"sha": "1dacf99b64b7808406388285638d8e0b8b71c786", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81da278623d9dcda1776008612bd42e1922e9c3/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=b81da278623d9dcda1776008612bd42e1922e9c3", "patch": "@@ -935,20 +935,17 @@ impl ThreadId {\n         static mut COUNTER: u64 = 0;\n \n         unsafe {\n-            GUARD.lock();\n+            let _guard = GUARD.lock();\n \n             // If we somehow use up all our bits, panic so that we're not\n             // covering up subtle bugs of IDs being reused.\n             if COUNTER == ::u64::MAX {\n-                GUARD.unlock();\n                 panic!(\"failed to generate unique thread ID: bitspace exhausted\");\n             }\n \n             let id = COUNTER;\n             COUNTER += 1;\n \n-            GUARD.unlock();\n-\n             ThreadId(id)\n         }\n     }"}]}