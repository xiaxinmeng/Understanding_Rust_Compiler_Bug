{"sha": "95528d1a9839066a29cc1cb50b097d5f84633148", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NTI4ZDFhOTgzOTA2NmEyOWNjMWNiNTBiMDk3ZDVmODQ2MzMxNDg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-22T00:24:11Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-01T22:29:29Z"}, "message": "Refactor away `resolver.current_vis` and add `module.normal_ancestor_id`.", "tree": {"sha": "c953e5bd7e97b1024d6fa04af0446c51d17579ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c953e5bd7e97b1024d6fa04af0446c51d17579ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95528d1a9839066a29cc1cb50b097d5f84633148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95528d1a9839066a29cc1cb50b097d5f84633148", "html_url": "https://github.com/rust-lang/rust/commit/95528d1a9839066a29cc1cb50b097d5f84633148", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95528d1a9839066a29cc1cb50b097d5f84633148/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e4c8173e182d6254c7faafb3d1e1020eac194c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e4c8173e182d6254c7faafb3d1e1020eac194c8", "html_url": "https://github.com/rust-lang/rust/commit/1e4c8173e182d6254c7faafb3d1e1020eac194c8"}], "stats": {"total": 136, "additions": 47, "deletions": 89}, "files": [{"sha": "83d35095f351bdbb7649fec535c661d9b1f8f7f0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/95528d1a9839066a29cc1cb50b097d5f84633148/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95528d1a9839066a29cc1cb50b097d5f84633148/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=95528d1a9839066a29cc1cb50b097d5f84633148", "patch": "@@ -30,7 +30,7 @@ use syntax::ast::Name;\n use syntax::attr;\n use syntax::parse::token;\n \n-use syntax::ast::{Block, Crate};\n+use syntax::ast::{Block, Crate, DUMMY_NODE_ID};\n use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n@@ -81,7 +81,6 @@ impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item) {\n         let parent = self.current_module;\n-        let parent_vis = self.current_vis;\n         let name = item.ident.name;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n@@ -204,7 +203,7 @@ impl<'b> Resolver<'b> {\n             ItemKind::Mod(..) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false);\n+                let module = self.new_module(parent_link, Some(def), item.id);\n                 module.no_implicit_prelude.set({\n                     parent.no_implicit_prelude.get() ||\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n@@ -214,7 +213,6 @@ impl<'b> Resolver<'b> {\n \n                 // Descend into the module.\n                 self.current_module = module;\n-                self.current_vis = ty::Visibility::Restricted(item.id);\n             }\n \n             ItemKind::ForeignMod(..) => {}\n@@ -243,7 +241,7 @@ impl<'b> Resolver<'b> {\n             ItemKind::Enum(ref enum_definition, _) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false);\n+                let module = self.new_module(parent_link, Some(def), parent.normal_ancestor_id);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n@@ -285,7 +283,8 @@ impl<'b> Resolver<'b> {\n                 // Add all the items within to a new module.\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Trait(def_id);\n-                let module_parent = self.new_module(parent_link, Some(def), false);\n+                let module_parent =\n+                    self.new_module(parent_link, Some(def), parent.normal_ancestor_id);\n                 self.define(parent, name, TypeNS, (module_parent, sp, vis));\n \n                 // Add the names of all the items to the trait info.\n@@ -312,7 +311,6 @@ impl<'b> Resolver<'b> {\n \n         visit::walk_item(&mut BuildReducedGraphVisitor { resolver: self }, item);\n         self.current_module = parent;\n-        self.current_vis = parent_vis;\n     }\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n@@ -363,7 +361,7 @@ impl<'b> Resolver<'b> {\n                    block_id);\n \n             let parent_link = BlockParentLink(parent, block_id);\n-            let new_module = self.new_module(parent_link, None, false);\n+            let new_module = self.new_module(parent_link, None, parent.normal_ancestor_id);\n             self.module_map.insert(block_id, new_module);\n             self.current_module = new_module; // Descend into the block.\n         }\n@@ -395,7 +393,7 @@ impl<'b> Resolver<'b> {\n                 debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n                        name, vis);\n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true);\n+                let module = self.new_module(parent_link, Some(def), DUMMY_NODE_ID);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::Variant(_, variant_id) => {\n@@ -437,7 +435,7 @@ impl<'b> Resolver<'b> {\n                 }\n \n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true);\n+                let module = self.new_module(parent_link, Some(def), DUMMY_NODE_ID);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {"}, {"sha": "b17687e17575c907dbf60b5c5ed06b4d6e012845", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 69, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/95528d1a9839066a29cc1cb50b097d5f84633148/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95528d1a9839066a29cc1cb50b097d5f84633148/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=95528d1a9839066a29cc1cb50b097d5f84633148", "patch": "@@ -54,7 +54,7 @@ use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n-use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n+use syntax::ast::{CRATE_NODE_ID, DUMMY_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -768,6 +768,9 @@ pub struct ModuleS<'a> {\n     parent_link: ParentLink<'a>,\n     def: Option<Def>,\n \n+    // The node id of the closest normal module (`mod`) ancestor (including this module).\n+    normal_ancestor_id: NodeId,\n+\n     // If the module is an extern crate, `def` is root of the external crate and `extern_crate_id`\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n     extern_crate_id: Option<NodeId>,\n@@ -791,17 +794,18 @@ pub struct ModuleS<'a> {\n pub type Module<'a> = &'a ModuleS<'a>;\n \n impl<'a> ModuleS<'a> {\n-    fn new(parent_link: ParentLink<'a>, def: Option<Def>, external: bool) -> Self {\n+    fn new(parent_link: ParentLink<'a>, def: Option<Def>, normal_ancestor_id: NodeId) -> Self {\n         ModuleS {\n             parent_link: parent_link,\n             def: def,\n+            normal_ancestor_id: normal_ancestor_id,\n             extern_crate_id: None,\n             resolutions: RefCell::new(FnvHashMap()),\n             no_implicit_prelude: Cell::new(false),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n-            populated: Cell::new(!external),\n+            populated: Cell::new(normal_ancestor_id != DUMMY_NODE_ID),\n         }\n     }\n \n@@ -829,6 +833,13 @@ impl<'a> ModuleS<'a> {\n             _ => false,\n         }\n     }\n+\n+    fn parent(&self) -> Option<&'a Self> {\n+        match self.parent_link {\n+            ModuleParentLink(parent, _) | BlockParentLink(parent, _) => Some(parent),\n+            NoParentLink => None,\n+        }\n+    }\n }\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n@@ -983,10 +994,6 @@ pub struct Resolver<'a> {\n     // The module that represents the current item scope.\n     current_module: Module<'a>,\n \n-    // The visibility of `pub(self)` items in the current scope.\n-    // Equivalently, the visibility required for an item to be accessible from the current scope.\n-    current_vis: ty::Visibility,\n-\n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n     value_ribs: Vec<Rib<'a>>,\n@@ -1079,15 +1086,12 @@ impl<'a> ResolverArenas<'a> {\n }\n \n impl<'a> ty::NodeIdTree for Resolver<'a> {\n-    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n-        let ancestor = self.definitions.local_def_id(ancestor);\n-        let mut module = *self.module_map.get(&node).unwrap();\n-        while module.def_id() != Some(ancestor) {\n-            let module_parent = match self.get_nearest_normal_module_parent(module) {\n-                Some(parent) => parent,\n+    fn is_descendant_of(&self, mut node: NodeId, ancestor: NodeId) -> bool {\n+        while node != ancestor {\n+            node = match self.module_map[&node].parent() {\n+                Some(parent) => parent.normal_ancestor_id,\n                 None => return false,\n-            };\n-            module = module_parent;\n+            }\n         }\n         true\n     }\n@@ -1149,8 +1153,7 @@ impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session, make_glob_map: MakeGlobMap, arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n-        let graph_root =\n-            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false);\n+        let graph_root = ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), CRATE_NODE_ID);\n         let graph_root = arenas.alloc_module(graph_root);\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n@@ -1173,7 +1176,6 @@ impl<'a> Resolver<'a> {\n             indeterminate_imports: Vec::new(),\n \n             current_module: graph_root,\n-            current_vis: ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n             value_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n             type_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n             label_ribs: Vec::new(),\n@@ -1217,21 +1219,20 @@ impl<'a> Resolver<'a> {\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         self.current_module = self.graph_root;\n-        self.current_vis = ty::Visibility::Restricted(ast::CRATE_NODE_ID);\n         visit::walk_crate(self, krate);\n \n         check_unused::check_crate(self, krate);\n         self.report_privacy_errors();\n     }\n \n-    fn new_module(&self, parent_link: ParentLink<'a>, def: Option<Def>, external: bool)\n+    fn new_module(&self, parent_link: ParentLink<'a>, def: Option<Def>, normal_ancestor_id: NodeId)\n                   -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS::new(parent_link, def, external))\n+        self.arenas.alloc_module(ModuleS::new(parent_link, def, normal_ancestor_id))\n     }\n \n     fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def, local_node_id: NodeId)\n                                -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), false);\n+        let mut module = ModuleS::new(parent_link, Some(def), local_node_id);\n         module.extern_crate_id = Some(local_node_id);\n         self.arenas.modules.alloc(module)\n     }\n@@ -1473,35 +1474,6 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    /// Returns the nearest normal module parent of the given module.\n-    fn get_nearest_normal_module_parent(&self, mut module: Module<'a>) -> Option<Module<'a>> {\n-        loop {\n-            match module.parent_link {\n-                NoParentLink => return None,\n-                ModuleParentLink(new_module, _) |\n-                BlockParentLink(new_module, _) => {\n-                    let new_module = new_module;\n-                    if new_module.is_normal() {\n-                        return Some(new_module);\n-                    }\n-                    module = new_module;\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Returns the nearest normal module parent of the given module, or the\n-    /// module itself if it is a normal module.\n-    fn get_nearest_normal_module_parent_or_self(&self, module: Module<'a>) -> Module<'a> {\n-        if module.is_normal() {\n-            return module;\n-        }\n-        match self.get_nearest_normal_module_parent(module) {\n-            None => module,\n-            Some(new_module) => new_module,\n-        }\n-    }\n-\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n@@ -1514,22 +1486,19 @@ impl<'a> Resolver<'a> {\n             \"super\" => 0,\n             _ => return Success(NoPrefixFound),\n         };\n-        let mut containing_module =\n-            self.get_nearest_normal_module_parent_or_self(self.current_module);\n+\n+        let mut containing_module = self.module_map[&self.current_module.normal_ancestor_id];\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() && \"super\" == module_path[i].as_str() {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n-            match self.get_nearest_normal_module_parent(containing_module) {\n-                None => {\n-                    let msg = \"There are too many initial `super`s.\".into();\n-                    return Failed(span.map(|span| (span, msg)));\n-                }\n-                Some(new_module) => {\n-                    containing_module = new_module;\n-                    i += 1;\n-                }\n+            if let Some(parent) = containing_module.parent() {\n+                containing_module = self.module_map[&parent.normal_ancestor_id];\n+                i += 1;\n+            } else {\n+                let msg = \"There are too many initial `super`s.\".into();\n+                return Failed(span.map(|span| (span, msg)));\n             }\n         }\n \n@@ -1564,14 +1533,12 @@ impl<'a> Resolver<'a> {\n         if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.current_module, module);\n-            let orig_vis = replace(&mut self.current_vis, ty::Visibility::Restricted(id));\n             self.value_ribs.push(Rib::new(ModuleRibKind(module)));\n             self.type_ribs.push(Rib::new(ModuleRibKind(module)));\n \n             f(self);\n \n             self.current_module = orig_module;\n-            self.current_vis = orig_vis;\n             self.value_ribs.pop();\n             self.type_ribs.pop();\n         } else {\n@@ -3248,16 +3215,17 @@ impl<'a> Resolver<'a> {\n             ast::Visibility::Public => return ty::Visibility::Public,\n             ast::Visibility::Crate(_) => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n             ast::Visibility::Restricted { ref path, id } => (path, id),\n-            ast::Visibility::Inherited => return self.current_vis,\n+            ast::Visibility::Inherited => {\n+                return ty::Visibility::Restricted(self.current_module.normal_ancestor_id);\n+            }\n         };\n \n         let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n         let mut path_resolution = err_path_resolution();\n         let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n             Success(module) => {\n-                let def = module.def.unwrap();\n-                path_resolution = PathResolution::new(def);\n-                ty::Visibility::Restricted(self.definitions.as_local_node_id(def.def_id()).unwrap())\n+                path_resolution = PathResolution::new(module.def.unwrap());\n+                ty::Visibility::Restricted(module.normal_ancestor_id)\n             }\n             Indeterminate => unreachable!(),\n             Failed(err) => {\n@@ -3276,7 +3244,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn is_accessible(&self, vis: ty::Visibility) -> bool {\n-        vis.is_at_least(self.current_vis, self)\n+        vis.is_accessible_from(self.current_module.normal_ancestor_id, self)\n     }\n \n     fn report_privacy_errors(&self) {"}, {"sha": "a0aab53c58f0900dc6cff88015d1322ba56b6b33", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95528d1a9839066a29cc1cb50b097d5f84633148/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95528d1a9839066a29cc1cb50b097d5f84633148/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=95528d1a9839066a29cc1cb50b097d5f84633148", "patch": "@@ -381,14 +381,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     // remain or unsuccessfully when no forward progress in resolving imports\n     // is made.\n \n-    fn set_current_module(&mut self, module: Module<'b>) {\n-        self.current_module = module;\n-        self.current_vis = ty::Visibility::Restricted({\n-            let normal_module = self.get_nearest_normal_module_parent_or_self(module);\n-            self.definitions.as_local_node_id(normal_module.def_id().unwrap()).unwrap()\n-        });\n-    }\n-\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     fn resolve_imports(&mut self) {\n@@ -472,7 +464,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                names_to_string(&directive.module_path),\n                module_to_string(self.current_module));\n \n-        self.set_current_module(directive.parent);\n+        self.current_module = directive.parent;\n \n         let module = if let Some(module) = directive.imported_module.get() {\n             module\n@@ -548,7 +540,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n \n     fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n-        self.set_current_module(directive.parent);\n+        self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n         let module_result = self.resolve_module_path(&module_path, DontUseLexicalScope, Some(span));"}]}