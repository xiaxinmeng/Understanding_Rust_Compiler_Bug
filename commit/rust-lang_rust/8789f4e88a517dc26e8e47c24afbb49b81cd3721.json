{"sha": "8789f4e88a517dc26e8e47c24afbb49b81cd3721", "node_id": "C_kwDOAAsO6NoAKDg3ODlmNGU4OGE1MTdkYzI2ZThlNDdjMjRhZmJiNDliODFjZDM3MjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-25T16:48:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-25T16:48:34Z"}, "message": "Auto merge of #8985 - botahamec:single-match-option, r=llogiq\n\nLint `[single_match]` on `Option` matches\n\nfixes #8928\n\nchangelog: did some cleanup of the logic for ``[`single_match`]`` and ``[`single_match_else`]`` which fixes the bug where `Option` matches were not linted unless a wildcard was used for one of the arms.", "tree": {"sha": "5974dd173e1d43c8a095b393bc0e7e0e927e21b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5974dd173e1d43c8a095b393bc0e7e0e927e21b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8789f4e88a517dc26e8e47c24afbb49b81cd3721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8789f4e88a517dc26e8e47c24afbb49b81cd3721", "html_url": "https://github.com/rust-lang/rust/commit/8789f4e88a517dc26e8e47c24afbb49b81cd3721", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8789f4e88a517dc26e8e47c24afbb49b81cd3721/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93ebd0e2db0e7c316cca3d35b077d19a79b4e7b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/93ebd0e2db0e7c316cca3d35b077d19a79b4e7b1", "html_url": "https://github.com/rust-lang/rust/commit/93ebd0e2db0e7c316cca3d35b077d19a79b4e7b1"}, {"sha": "ded2bb54642507c7a037a46bce31078026078672", "url": "https://api.github.com/repos/rust-lang/rust/commits/ded2bb54642507c7a037a46bce31078026078672", "html_url": "https://github.com/rust-lang/rust/commit/ded2bb54642507c7a037a46bce31078026078672"}], "stats": {"total": 197, "additions": 142, "deletions": 55}, "files": [{"sha": "92091a0c3395f7b4578bc9e26126b1c5daa72e7a", "filename": "clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 32, "deletions": 53, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8789f4e88a517dc26e8e47c24afbb49b81cd3721/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8789f4e88a517dc26e8e47c24afbb49b81cd3721/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=8789f4e88a517dc26e8e47c24afbb49b81cd3721", "patch": "@@ -140,70 +140,45 @@ fn check_opt_like<'a>(\n     ty: Ty<'a>,\n     els: Option<&Expr<'_>>,\n ) {\n-    // list of candidate `Enum`s we know will never get any more members\n-    let candidates = &[\n-        (&paths::COW, \"Borrowed\"),\n-        (&paths::COW, \"Cow::Borrowed\"),\n-        (&paths::COW, \"Cow::Owned\"),\n-        (&paths::COW, \"Owned\"),\n-        (&paths::OPTION, \"None\"),\n-        (&paths::RESULT, \"Err\"),\n-        (&paths::RESULT, \"Ok\"),\n-    ];\n-\n-    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n-    // match with the second branch, without enum variants in matches.\n-    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n-        return;\n+    // We don't want to lint if the second arm contains an enum which could\n+    // have more variants in the future.\n+    if form_exhaustive_matches(cx, ty, arms[0].pat, arms[1].pat) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n     }\n+}\n \n+/// Returns `true` if all of the types in the pattern are enums which we know\n+/// won't be expanded in the future\n+fn pat_in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'a>, pat: &Pat<'_>) -> bool {\n     let mut paths_and_types = Vec::new();\n-    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n-        return;\n-    }\n+    collect_pat_paths(&mut paths_and_types, cx, pat, ty);\n+    paths_and_types.iter().all(|ty| in_candidate_enum(cx, *ty))\n+}\n \n-    let in_candidate_enum = |path_info: &(String, Ty<'_>)| -> bool {\n-        let (path, ty) = path_info;\n-        for &(ty_path, pat_path) in candidates {\n-            if path == pat_path && match_type(cx, *ty, ty_path) {\n-                return true;\n-            }\n+/// Returns `true` if the given type is an enum we know won't be expanded in the future\n+fn in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'_>) -> bool {\n+    // list of candidate `Enum`s we know will never get any more members\n+    let candidates = [&paths::COW, &paths::OPTION, &paths::RESULT];\n+\n+    for candidate_ty in candidates {\n+        if match_type(cx, ty, candidate_ty) {\n+            return true;\n         }\n-        false\n-    };\n-    if paths_and_types.iter().all(in_candidate_enum) {\n-        report_single_pattern(cx, ex, arms, expr, els);\n     }\n+    false\n }\n \n-/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n-/// be simplified, false otherwise.\n-fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n+/// Collects types from the given pattern\n+fn collect_pat_paths<'a>(acc: &mut Vec<Ty<'a>>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) {\n     match pat.kind {\n-        PatKind::Wild => true,\n-        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n+        PatKind::Tuple(inner, _) => inner.iter().for_each(|p| {\n             let p_ty = cx.typeck_results().pat_ty(p);\n-            collect_pat_paths(acc, cx, p, p_ty)\n+            collect_pat_paths(acc, cx, p, p_ty);\n         }),\n-        PatKind::TupleStruct(ref path, ..) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n-            acc.push((ident.to_string(), ty));\n-            true\n+        PatKind::TupleStruct(..) | PatKind::Binding(BindingAnnotation::Unannotated, .., None) | PatKind::Path(_) => {\n+            acc.push(ty);\n         },\n-        PatKind::Path(ref path) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        _ => false,\n+        _ => {},\n     }\n }\n \n@@ -218,7 +193,7 @@ fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n \n /// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n /// patterns without a wildcard.\n-fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+fn form_exhaustive_matches<'a>(cx: &LateContext<'a>, ty: Ty<'a>, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n     match (&left.kind, &right.kind) {\n         (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n         (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n@@ -264,6 +239,10 @@ fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n             }\n             true\n         },\n+        (PatKind::TupleStruct(..), PatKind::Path(_)) => pat_in_candidate_enum(cx, ty, right),\n+        (PatKind::TupleStruct(..), PatKind::TupleStruct(_, inner, _)) => {\n+            pat_in_candidate_enum(cx, ty, right) && inner.iter().all(contains_only_wilds)\n+        },\n         _ => false,\n     }\n }"}, {"sha": "4d2b9ec5f903aef7bd0b8486d8ffb1206339d328", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8789f4e88a517dc26e8e47c24afbb49b81cd3721/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8789f4e88a517dc26e8e47c24afbb49b81cd3721/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=8789f4e88a517dc26e8e47c24afbb49b81cd3721", "patch": "@@ -38,6 +38,15 @@ LL | |         _ => {},\n LL | |     };\n    | |_____^ help: try this: `if let (2..=3, 7..=9) = z { dummy() }`\n \n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:54:5\n+   |\n+LL | /     match x {\n+LL | |         Some(y) => dummy(),\n+LL | |         None => (),\n+LL | |     };\n+   | |_____^ help: try this: `if let Some(y) = x { dummy() }`\n+\n error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:59:5\n    |\n@@ -146,5 +155,5 @@ LL | |         (..) => {},\n LL | |     }\n    | |_____^ help: try this: `if let (.., Some(E::V), _) = (Some(42), Some(E::V), Some(42)) {}`\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "70d6febb71f9da4d7ea4d7adc0c094382960a1d9", "filename": "tests/ui/single_match_else.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8789f4e88a517dc26e8e47c24afbb49b81cd3721/tests%2Fui%2Fsingle_match_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8789f4e88a517dc26e8e47c24afbb49b81cd3721/tests%2Fui%2Fsingle_match_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.rs?ref=8789f4e88a517dc26e8e47c24afbb49b81cd3721", "patch": "@@ -97,4 +97,23 @@ fn main() {\n             return;\n         },\n     }\n+\n+    // lint here\n+    use std::convert::Infallible;\n+    match Result::<i32, Infallible>::Ok(1) {\n+        Ok(a) => println!(\"${:?}\", a),\n+        Err(_) => {\n+            println!(\"else block\");\n+            return;\n+        }\n+    }\n+\n+    use std::borrow::Cow;\n+    match Cow::from(\"moo\") {\n+        Cow::Owned(a) => println!(\"${:?}\", a),\n+        Cow::Borrowed(_) => {\n+            println!(\"else block\");\n+            return;\n+        }\n+    }\n }"}, {"sha": "38fd9c6a6782ac87d4ab12a418581cb6bd813576", "filename": "tests/ui/single_match_else.stderr", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8789f4e88a517dc26e8e47c24afbb49b81cd3721/tests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8789f4e88a517dc26e8e47c24afbb49b81cd3721/tests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.stderr?ref=8789f4e88a517dc26e8e47c24afbb49b81cd3721", "patch": "@@ -20,5 +20,85 @@ LL +         None\n LL ~     };\n    |\n \n-error: aborting due to previous error\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:84:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return\n+LL +     }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:93:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return;\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return;\n+LL +     }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:103:5\n+   |\n+LL | /     match Result::<i32, Infallible>::Ok(1) {\n+LL | |         Ok(a) => println!(\"${:?}\", a),\n+LL | |         Err(_) => {\n+LL | |             println!(\"else block\");\n+LL | |             return;\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Ok(a) = Result::<i32, Infallible>::Ok(1) { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return;\n+LL +     }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:112:5\n+   |\n+LL | /     match Cow::from(\"moo\") {\n+LL | |         Cow::Owned(a) => println!(\"${:?}\", a),\n+LL | |         Cow::Borrowed(_) => {\n+LL | |             println!(\"else block\");\n+LL | |             return;\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Cow::Owned(a) = Cow::from(\"moo\") { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return;\n+LL +     }\n+   |\n+\n+error: aborting due to 5 previous errors\n "}]}