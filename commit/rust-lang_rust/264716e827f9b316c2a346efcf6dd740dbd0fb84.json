{"sha": "264716e827f9b316c2a346efcf6dd740dbd0fb84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NDcxNmU4MjdmOWIzMTZjMmEzNDZlZmNmNmRkNzQwZGJkMGZiODQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-24T15:23:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-24T15:23:25Z"}, "message": "Merge #9375\n\n9375: feat: Highlight exit and yield points r=Veykril a=Veykril\n\n![Code_YBHOCF3DbU](https://user-images.githubusercontent.com/3757771/123128986-e1270a80-d44b-11eb-9854-065459a2dd50.png)\r\n![Code_YyMhqES0LX](https://user-images.githubusercontent.com/3757771/123128988-e1bfa100-d44b-11eb-9c81-6a6031aad740.png)\r\n\r\nFixes #4691\r\nFixes #9365\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "eac7e83110ea5df194fbaf45d950f0c6e7a4b117", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eac7e83110ea5df194fbaf45d950f0c6e7a4b117"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/264716e827f9b316c2a346efcf6dd740dbd0fb84", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg1KNtCRBK7hj4Ov3rIwAAvn4IAIUGaq+txCWlZomIM3H9buRm\nly3hjYRInPQbErRoviMH3MXBFCnfK2SegqEAMdpv+O6DStMFcELJU+lacwmPzk/6\nTAJK1O74yTGYXckj3n6AdvSoCRhvDXdqTHdZrp6Zh0bXqg8G+7CUE7/RLC/p2GlG\nvoVHaqvPWFG+6jhYRSMuhC8/p8rmJAN1ysEc7tx+JvBhJ3nAnjY9vOKOYH+pgCZs\na2Hj9TUZ98K5OntRnoYgvEAAaxem1xPgtEITZdbjvoGsNdROFNN+2y1AQCfYlopl\nF3iiv1GEWD/oxJFYCN2eDNe6RafMJmfzYUfQULLlzllJ1azYmgftJnttZ5JVunU=\n=cZdC\n-----END PGP SIGNATURE-----\n", "payload": "tree eac7e83110ea5df194fbaf45d950f0c6e7a4b117\nparent b656751536491706f66cc72256df56906c59297b\nparent d77655e5c3c6c09bc968715b2b7a3db6224f7883\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1624548205 +0000\ncommitter GitHub <noreply@github.com> 1624548205 +0000\n\nMerge #9375\n\n9375: feat: Highlight exit and yield points r=Veykril a=Veykril\n\n![Code_YBHOCF3DbU](https://user-images.githubusercontent.com/3757771/123128986-e1270a80-d44b-11eb-9854-065459a2dd50.png)\r\n![Code_YyMhqES0LX](https://user-images.githubusercontent.com/3757771/123128988-e1bfa100-d44b-11eb-9c81-6a6031aad740.png)\r\n\r\nFixes #4691\r\nFixes #9365\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/264716e827f9b316c2a346efcf6dd740dbd0fb84", "html_url": "https://github.com/rust-lang/rust/commit/264716e827f9b316c2a346efcf6dd740dbd0fb84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/264716e827f9b316c2a346efcf6dd740dbd0fb84/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b656751536491706f66cc72256df56906c59297b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b656751536491706f66cc72256df56906c59297b", "html_url": "https://github.com/rust-lang/rust/commit/b656751536491706f66cc72256df56906c59297b"}, {"sha": "d77655e5c3c6c09bc968715b2b7a3db6224f7883", "url": "https://api.github.com/repos/rust-lang/rust/commits/d77655e5c3c6c09bc968715b2b7a3db6224f7883", "html_url": "https://github.com/rust-lang/rust/commit/d77655e5c3c6c09bc968715b2b7a3db6224f7883"}], "stats": {"total": 716, "additions": 672, "deletions": 44}, "files": [{"sha": "3a901cbbf866915521221a2472001230ae1e6bc9", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=264716e827f9b316c2a346efcf6dd740dbd0fb84", "patch": "@@ -2075,10 +2075,15 @@ impl Type {\n     pub fn is_unit(&self) -> bool {\n         matches!(self.ty.kind(&Interner), TyKind::Tuple(0, ..))\n     }\n+\n     pub fn is_bool(&self) -> bool {\n         matches!(self.ty.kind(&Interner), TyKind::Scalar(Scalar::Bool))\n     }\n \n+    pub fn is_never(&self) -> bool {\n+        matches!(self.ty.kind(&Interner), TyKind::Never)\n+    }\n+\n     pub fn is_mutable_reference(&self) -> bool {\n         matches!(self.ty.kind(&Interner), TyKind::Ref(hir_ty::Mutability::Mut, ..))\n     }"}, {"sha": "1c17d35110924550e65f533ab280a1c0a3d06db7", "filename": "crates/ide/src/highlight_related.rs", "status": "added", "additions": 586, "deletions": 0, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=264716e827f9b316c2a346efcf6dd740dbd0fb84", "patch": "@@ -0,0 +1,586 @@\n+use hir::Semantics;\n+use ide_db::{\n+    base_db::FilePosition,\n+    defs::Definition,\n+    helpers::pick_best_token,\n+    search::{FileReference, ReferenceAccess, SearchScope},\n+    RootDatabase,\n+};\n+use syntax::{\n+    ast::{self, LoopBodyOwner},\n+    match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,\n+};\n+\n+use crate::{display::TryToNav, references, NavigationTarget};\n+\n+pub struct HighlightedRange {\n+    pub range: TextRange,\n+    pub access: Option<ReferenceAccess>,\n+}\n+\n+// Feature: Highlight Related\n+//\n+// Highlights constructs related to the thing under the cursor:\n+// - if on an identifier, highlights all references to that identifier in the current file\n+// - if on an `async` or `await token, highlights all yield points for that async context\n+// - if on a `return` token, `?` character or `->` return type arrow, highlights all exit points for that context\n+pub(crate) fn highlight_related(\n+    sema: &Semantics<RootDatabase>,\n+    position: FilePosition,\n+) -> Option<Vec<HighlightedRange>> {\n+    let _p = profile::span(\"highlight_related\");\n+    let syntax = sema.parse(position.file_id).syntax().clone();\n+\n+    let token = pick_best_token(syntax.token_at_offset(position.offset), |kind| match kind {\n+        T![?] => 2, // prefer `?` when the cursor is sandwiched like `await$0?`\n+        T![await] | T![async] | T![return] | T![->] => 1,\n+        _ => 0,\n+    })?;\n+\n+    match token.kind() {\n+        T![return] | T![?] | T![->] => highlight_exit_points(sema, token),\n+        T![await] | T![async] => highlight_yield_points(token),\n+        _ => highlight_references(sema, &syntax, position),\n+    }\n+}\n+\n+fn highlight_references(\n+    sema: &Semantics<RootDatabase>,\n+    syntax: &SyntaxNode,\n+    FilePosition { offset, file_id }: FilePosition,\n+) -> Option<Vec<HighlightedRange>> {\n+    let def = references::find_def(sema, syntax, offset)?;\n+    let usages = def.usages(sema).set_scope(Some(SearchScope::single_file(file_id))).all();\n+\n+    let declaration = match def {\n+        Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+            Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+        }\n+        def => def.try_to_nav(sema.db),\n+    }\n+    .filter(|decl| decl.file_id == file_id)\n+    .and_then(|decl| {\n+        let range = decl.focus_range?;\n+        let access = references::decl_access(&def, syntax, range);\n+        Some(HighlightedRange { range, access })\n+    });\n+\n+    let file_refs = usages.references.get(&file_id).map_or(&[][..], Vec::as_slice);\n+    let mut res = Vec::with_capacity(file_refs.len() + 1);\n+    res.extend(declaration);\n+    res.extend(\n+        file_refs\n+            .iter()\n+            .map(|&FileReference { access, range, .. }| HighlightedRange { range, access }),\n+    );\n+    Some(res)\n+}\n+\n+fn highlight_exit_points(\n+    sema: &Semantics<RootDatabase>,\n+    token: SyntaxToken,\n+) -> Option<Vec<HighlightedRange>> {\n+    fn hl(\n+        sema: &Semantics<RootDatabase>,\n+        body: Option<ast::Expr>,\n+    ) -> Option<Vec<HighlightedRange>> {\n+        let mut highlights = Vec::new();\n+        let body = body?;\n+        walk(&body, &mut |expr| match expr {\n+            ast::Expr::ReturnExpr(expr) => {\n+                if let Some(token) = expr.return_token() {\n+                    highlights.push(HighlightedRange { access: None, range: token.text_range() });\n+                }\n+            }\n+            ast::Expr::TryExpr(try_) => {\n+                if let Some(token) = try_.question_mark_token() {\n+                    highlights.push(HighlightedRange { access: None, range: token.text_range() });\n+                }\n+            }\n+            ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n+                if sema.type_of_expr(&expr).map_or(false, |ty| ty.is_never()) {\n+                    highlights\n+                        .push(HighlightedRange { access: None, range: expr.syntax().text_range() });\n+                }\n+            }\n+            _ => (),\n+        });\n+        let tail = match body {\n+            ast::Expr::BlockExpr(b) => b.tail_expr(),\n+            e => Some(e),\n+        };\n+\n+        if let Some(tail) = tail {\n+            for_each_inner_tail(&tail, &mut |tail| {\n+                highlights\n+                    .push(HighlightedRange { access: None, range: tail.syntax().text_range() })\n+            });\n+        }\n+        Some(highlights)\n+    }\n+    for anc in token.ancestors() {\n+        return match_ast! {\n+            match anc {\n+                ast::Fn(fn_) => hl(sema, fn_.body().map(ast::Expr::BlockExpr)),\n+                ast::ClosureExpr(closure) => hl(sema, closure.body()),\n+                ast::EffectExpr(effect) => if matches!(effect.effect(), ast::Effect::Async(_) | ast::Effect::Try(_)| ast::Effect::Const(_)) {\n+                    hl(sema, effect.block_expr().map(ast::Expr::BlockExpr))\n+                } else {\n+                    continue;\n+                },\n+                _ => continue,\n+            }\n+        };\n+    }\n+    None\n+}\n+\n+fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n+    fn hl(\n+        async_token: Option<SyntaxToken>,\n+        body: Option<ast::Expr>,\n+    ) -> Option<Vec<HighlightedRange>> {\n+        let mut highlights = Vec::new();\n+        highlights.push(HighlightedRange { access: None, range: async_token?.text_range() });\n+        if let Some(body) = body {\n+            walk(&body, &mut |expr| {\n+                if let ast::Expr::AwaitExpr(expr) = expr {\n+                    if let Some(token) = expr.await_token() {\n+                        highlights\n+                            .push(HighlightedRange { access: None, range: token.text_range() });\n+                    }\n+                }\n+            });\n+        }\n+        Some(highlights)\n+    }\n+    for anc in token.ancestors() {\n+        return match_ast! {\n+            match anc {\n+                ast::Fn(fn_) => hl(fn_.async_token(), fn_.body().map(ast::Expr::BlockExpr)),\n+                ast::EffectExpr(effect) => hl(effect.async_token(), effect.block_expr().map(ast::Expr::BlockExpr)),\n+                ast::ClosureExpr(closure) => hl(closure.async_token(), closure.body()),\n+                _ => continue,\n+            }\n+        };\n+    }\n+    None\n+}\n+\n+/// Preorder walk all the expression's child expressions\n+fn walk(expr: &ast::Expr, cb: &mut dyn FnMut(ast::Expr)) {\n+    let mut preorder = expr.syntax().preorder();\n+    while let Some(event) = preorder.next() {\n+        let node = match event {\n+            WalkEvent::Enter(node) => node,\n+            WalkEvent::Leave(_) => continue,\n+        };\n+        match ast::Stmt::cast(node.clone()) {\n+            // recursively walk the initializer, skipping potential const pat expressions\n+            // lets statements aren't usually nested too deeply so this is fine to recurse on\n+            Some(ast::Stmt::LetStmt(l)) => {\n+                if let Some(expr) = l.initializer() {\n+                    walk(&expr, cb);\n+                }\n+                preorder.skip_subtree();\n+            }\n+            // Don't skip subtree since we want to process the expression child next\n+            Some(ast::Stmt::ExprStmt(_)) => (),\n+            // skip inner items which might have their own expressions\n+            Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n+            None => {\n+                if let Some(expr) = ast::Expr::cast(node) {\n+                    let is_different_context = match &expr {\n+                        ast::Expr::EffectExpr(effect) => {\n+                            matches!(\n+                                effect.effect(),\n+                                ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_)\n+                            )\n+                        }\n+                        ast::Expr::ClosureExpr(__) => true,\n+                        _ => false,\n+                    };\n+                    cb(expr);\n+                    if is_different_context {\n+                        preorder.skip_subtree();\n+                    }\n+                } else {\n+                    preorder.skip_subtree();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// FIXME: doesn't account for labeled breaks in labeled blocks\n+fn for_each_inner_tail(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n+    match expr {\n+        ast::Expr::BlockExpr(b) => {\n+            if let Some(e) = b.tail_expr() {\n+                for_each_inner_tail(&e, cb);\n+            }\n+        }\n+        ast::Expr::EffectExpr(e) => match e.effect() {\n+            ast::Effect::Label(_) | ast::Effect::Unsafe(_) => {\n+                if let Some(e) = e.block_expr().and_then(|b| b.tail_expr()) {\n+                    for_each_inner_tail(&e, cb);\n+                }\n+            }\n+            ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_) => cb(expr),\n+        },\n+        ast::Expr::IfExpr(if_) => {\n+            if_.blocks().for_each(|block| for_each_inner_tail(&ast::Expr::BlockExpr(block), cb))\n+        }\n+        ast::Expr::LoopExpr(l) => for_each_break(l, cb),\n+        ast::Expr::MatchExpr(m) => {\n+            if let Some(arms) = m.match_arm_list() {\n+                arms.arms().filter_map(|arm| arm.expr()).for_each(|e| for_each_inner_tail(&e, cb));\n+            }\n+        }\n+        ast::Expr::ArrayExpr(_)\n+        | ast::Expr::AwaitExpr(_)\n+        | ast::Expr::BinExpr(_)\n+        | ast::Expr::BoxExpr(_)\n+        | ast::Expr::BreakExpr(_)\n+        | ast::Expr::CallExpr(_)\n+        | ast::Expr::CastExpr(_)\n+        | ast::Expr::ClosureExpr(_)\n+        | ast::Expr::ContinueExpr(_)\n+        | ast::Expr::FieldExpr(_)\n+        | ast::Expr::ForExpr(_)\n+        | ast::Expr::IndexExpr(_)\n+        | ast::Expr::Literal(_)\n+        | ast::Expr::MacroCall(_)\n+        | ast::Expr::MacroStmts(_)\n+        | ast::Expr::MethodCallExpr(_)\n+        | ast::Expr::ParenExpr(_)\n+        | ast::Expr::PathExpr(_)\n+        | ast::Expr::PrefixExpr(_)\n+        | ast::Expr::RangeExpr(_)\n+        | ast::Expr::RecordExpr(_)\n+        | ast::Expr::RefExpr(_)\n+        | ast::Expr::ReturnExpr(_)\n+        | ast::Expr::TryExpr(_)\n+        | ast::Expr::TupleExpr(_)\n+        | ast::Expr::WhileExpr(_)\n+        | ast::Expr::YieldExpr(_) => cb(expr),\n+    }\n+}\n+\n+fn for_each_break(l: &ast::LoopExpr, cb: &mut dyn FnMut(&ast::Expr)) {\n+    let label = l.label().and_then(|lbl| lbl.lifetime());\n+    let mut depth = 0;\n+    if let Some(b) = l.loop_body() {\n+        let preorder = &mut b.syntax().preorder();\n+        let ev_as_expr = |ev| match ev {\n+            WalkEvent::Enter(it) => Some(WalkEvent::Enter(ast::Expr::cast(it)?)),\n+            WalkEvent::Leave(it) => Some(WalkEvent::Leave(ast::Expr::cast(it)?)),\n+        };\n+        let eq_label = |lt: Option<ast::Lifetime>| {\n+            lt.zip(label.as_ref()).map_or(false, |(lt, lbl)| lt.text() == lbl.text())\n+        };\n+        while let Some(node) = preorder.find_map(ev_as_expr) {\n+            match node {\n+                WalkEvent::Enter(expr) => match &expr {\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n+                        depth += 1\n+                    }\n+                    ast::Expr::EffectExpr(e) if e.label().is_some() => depth += 1,\n+                    ast::Expr::BreakExpr(b) if depth == 0 || eq_label(b.lifetime()) => {\n+                        cb(&expr);\n+                    }\n+                    _ => (),\n+                },\n+                WalkEvent::Leave(expr) => match expr {\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n+                        depth -= 1\n+                    }\n+                    ast::Expr::EffectExpr(e) if e.label().is_some() => depth -= 1,\n+                    _ => (),\n+                },\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::fixture;\n+\n+    use super::*;\n+\n+    fn check(ra_fixture: &str) {\n+        let (analysis, pos, annotations) = fixture::annotations(ra_fixture);\n+        let hls = analysis.highlight_related(pos).unwrap().unwrap();\n+\n+        let mut expected = annotations\n+            .into_iter()\n+            .map(|(r, access)| (r.range, (!access.is_empty()).then(|| access)))\n+            .collect::<Vec<_>>();\n+\n+        let mut actual = hls\n+            .into_iter()\n+            .map(|hl| {\n+                (\n+                    hl.range,\n+                    hl.access.map(|it| {\n+                        match it {\n+                            ReferenceAccess::Read => \"read\",\n+                            ReferenceAccess::Write => \"write\",\n+                        }\n+                        .to_string()\n+                    }),\n+                )\n+            })\n+            .collect::<Vec<_>>();\n+        actual.sort_by_key(|(range, _)| range.start());\n+        expected.sort_by_key(|(range, _)| range.start());\n+\n+        assert_eq!(expected, actual);\n+    }\n+\n+    #[test]\n+    fn test_hl_module() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+mod foo$0;\n+ // ^^^\n+//- /foo.rs\n+struct Foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_self_in_crate_root() {\n+        check(\n+            r#\"\n+use self$0;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_self_in_module() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+//- /foo.rs\n+use self$0;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_local() {\n+        check(\n+            r#\"\n+fn foo() {\n+    let mut bar = 3;\n+         // ^^^ write\n+    bar$0;\n+ // ^^^ read\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_yield_points() {\n+        check(\n+            r#\"\n+pub async fn foo() {\n+ // ^^^^^\n+    let x = foo()\n+        .await$0\n+      // ^^^^^\n+        .await;\n+      // ^^^^^\n+    || { 0.await };\n+    (async { 0.await }).await\n+                     // ^^^^^\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_yield_points2() {\n+        check(\n+            r#\"\n+pub async$0 fn foo() {\n+ // ^^^^^\n+    let x = foo()\n+        .await\n+      // ^^^^^\n+        .await;\n+      // ^^^^^\n+    || { 0.await };\n+    (async { 0.await }).await\n+                     // ^^^^^\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_yield_nested_fn() {\n+        check(\n+            r#\"\n+async fn foo() {\n+    async fn foo2() {\n+ // ^^^^^\n+        async fn foo3() {\n+            0.await\n+        }\n+        0.await$0\n+       // ^^^^^\n+    }\n+    0.await\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_yield_nested_async_blocks() {\n+        check(\n+            r#\"\n+async fn foo() {\n+    (async {\n+  // ^^^^^\n+        (async {\n+           0.await\n+        }).await$0 }\n+        // ^^^^^\n+    ).await;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_exit_points() {\n+        check(\n+            r#\"\n+fn foo() -> u32 {\n+    if true {\n+        return$0 0;\n+     // ^^^^^^\n+    }\n+\n+    0?;\n+  // ^\n+    0xDEAD_BEEF\n+ // ^^^^^^^^^^^\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_exit_points2() {\n+        check(\n+            r#\"\n+fn foo() ->$0 u32 {\n+    if true {\n+        return 0;\n+     // ^^^^^^\n+    }\n+\n+    0?;\n+  // ^\n+    0xDEAD_BEEF\n+ // ^^^^^^^^^^^\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_prefer_ref_over_tail_exit() {\n+        check(\n+            r#\"\n+fn foo() -> u32 {\n+// ^^^\n+    if true {\n+        return 0;\n+    }\n+\n+    0?;\n+\n+    foo$0()\n+ // ^^^\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_never_call_is_exit_point() {\n+        check(\n+            r#\"\n+struct Never;\n+impl Never {\n+    fn never(self) -> ! { loop {} }\n+}\n+macro_rules! never {\n+    () => { never() }\n+}\n+fn never() -> ! { loop {} }\n+fn foo() ->$0 u32 {\n+    never();\n+ // ^^^^^^^\n+    never!();\n+ // FIXME sema doesn't give us types for macrocalls\n+\n+    Never.never();\n+ // ^^^^^^^^^^^^^\n+\n+    0\n+ // ^\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_inner_tail_exit_points() {\n+        check(\n+            r#\"\n+fn foo() ->$0 u32 {\n+    if true {\n+        unsafe {\n+            return 5;\n+         // ^^^^^^\n+            5\n+         // ^\n+        }\n+    } else {\n+        match 5 {\n+            6 => 100,\n+              // ^^^\n+            7 => loop {\n+                break 5;\n+             // ^^^^^^^\n+            }\n+            8 => 'a: loop {\n+                'b: loop {\n+                    break 'a 5;\n+                 // ^^^^^^^^^^\n+                    break 'b 5;\n+                    break 5;\n+                };\n+            }\n+            //\n+            _ => 500,\n+              // ^^^\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "336ef9a0315d5f24153751154f6dcfc947b06608", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=264716e827f9b316c2a346efcf6dd740dbd0fb84", "patch": "@@ -24,33 +24,34 @@ mod display;\n \n mod annotations;\n mod call_hierarchy;\n+mod doc_links;\n+mod highlight_related;\n mod expand_macro;\n mod extend_selection;\n mod file_structure;\n+mod fn_references;\n mod folding_ranges;\n mod goto_declaration;\n mod goto_definition;\n mod goto_implementation;\n mod goto_type_definition;\n-mod view_hir;\n mod hover;\n mod inlay_hints;\n mod join_lines;\n+mod markdown_remove;\n mod matching_brace;\n mod move_item;\n mod parent_module;\n mod references;\n mod rename;\n-mod fn_references;\n mod runnables;\n mod ssr;\n mod status;\n mod syntax_highlighting;\n mod syntax_tree;\n mod typing;\n-mod markdown_remove;\n-mod doc_links;\n mod view_crate_graph;\n+mod view_hir;\n mod view_item_tree;\n \n use std::sync::Arc;\n@@ -76,6 +77,7 @@ pub use crate::{\n     expand_macro::ExpandedMacro,\n     file_structure::{StructureNode, StructureNodeKind},\n     folding_ranges::{Fold, FoldKind},\n+    highlight_related::HighlightedRange,\n     hover::{HoverAction, HoverConfig, HoverDocFormat, HoverGotoTypeData, HoverResult},\n     inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n     markup::Markup,\n@@ -492,6 +494,14 @@ impl Analysis {\n         self.with_db(|db| syntax_highlighting::highlight(db, file_id, None, false))\n     }\n \n+    /// Computes all ranges to highlight for a given item in a file.\n+    pub fn highlight_related(\n+        &self,\n+        position: FilePosition,\n+    ) -> Cancellable<Option<Vec<HighlightedRange>>> {\n+        self.with_db(|db| highlight_related::highlight_related(&Semantics::new(db), position))\n+    }\n+\n     /// Computes syntax highlighting for the given file range.\n     pub fn highlight_range(&self, frange: FileRange) -> Cancellable<Vec<HlRange>> {\n         self.with_db(|db| {"}, {"sha": "2d3a0f598122b32affda50d6756ba4a78cead6cd", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=264716e827f9b316c2a346efcf6dd740dbd0fb84", "patch": "@@ -20,7 +20,7 @@ use rustc_hash::FxHashMap;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n-    match_ast, AstNode, SyntaxNode, TextRange, T,\n+    match_ast, AstNode, SyntaxNode, TextRange, TextSize, T,\n };\n \n use crate::{display::TryToNav, FilePosition, NavigationTarget};\n@@ -60,7 +60,7 @@ pub(crate) fn find_all_refs(\n         if let Some(name) = get_name_of_item_declaration(&syntax, position) {\n             (NameClass::classify(sema, &name)?.referenced_or_defined(sema.db), true)\n         } else {\n-            (find_def(sema, &syntax, position)?, false)\n+            (find_def(sema, &syntax, position.offset)?, false)\n         };\n \n     let mut usages = def.usages(sema).set_scope(search_scope).include_self_refs().all();\n@@ -90,7 +90,13 @@ pub(crate) fn find_all_refs(\n             _ => {}\n         }\n     }\n-    let declaration = def.try_to_nav(sema.db).map(|nav| {\n+    let declaration = match def {\n+        Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+            Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+        }\n+        def => def.try_to_nav(sema.db),\n+    }\n+    .map(|nav| {\n         let decl_range = nav.focus_or_full_range();\n         Declaration { nav, access: decl_access(&def, &syntax, decl_range) }\n     });\n@@ -104,12 +110,12 @@ pub(crate) fn find_all_refs(\n     Some(ReferenceSearchResult { declaration, references })\n }\n \n-fn find_def(\n+pub(crate) fn find_def(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n-    position: FilePosition,\n+    offset: TextSize,\n ) -> Option<Definition> {\n-    let def = match sema.find_node_at_offset_with_descend(syntax, position.offset)? {\n+    let def = match sema.find_node_at_offset_with_descend(syntax, offset)? {\n         ast::NameLike::NameRef(name_ref) => {\n             NameRefClass::classify(sema, &name_ref)?.referenced(sema.db)\n         }\n@@ -126,7 +132,11 @@ fn find_def(\n     Some(def)\n }\n \n-fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Option<ReferenceAccess> {\n+pub(crate) fn decl_access(\n+    def: &Definition,\n+    syntax: &SyntaxNode,\n+    range: TextRange,\n+) -> Option<ReferenceAccess> {\n     match def {\n         Definition::Local(_) | Definition::Field(_) => {}\n         _ => return None,\n@@ -658,9 +668,6 @@ fn f() {\n         );\n     }\n \n-    // `mod foo;` is not in the results because `foo` is an `ast::Name`.\n-    // So, there are two references: the first one is a definition of the `foo` module,\n-    // which is the whole `foo.rs`, and the second one is in `use foo::Foo`.\n     #[test]\n     fn test_find_all_refs_decl_module() {\n         check(\n@@ -680,13 +687,44 @@ pub struct Foo {\n }\n \"#,\n             expect![[r#\"\n-                foo Module FileId(1) 0..35\n+                foo Module FileId(0) 0..8 4..7\n \n                 FileId(0) 14..17\n             \"#]],\n         );\n     }\n \n+    #[test]\n+    fn test_find_all_refs_decl_module_on_self() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+\n+//- /foo.rs\n+use self$0;\n+\"#,\n+            expect![[r#\"\n+                foo Module FileId(0) 0..8 4..7\n+\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_decl_module_on_self_crate_root() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+use self$0;\n+\"#,\n+            expect![[r#\"\n+                Module FileId(0) 0..10\n+\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_find_all_refs_super_mod_vis() {\n         check(\n@@ -1021,7 +1059,7 @@ impl Foo {\n                 actual += \"\\n\";\n             }\n         }\n-        expect.assert_eq(&actual)\n+        expect.assert_eq(actual.trim_start())\n     }\n \n     #[test]"}, {"sha": "406039b736846ae20d0219dcda371c3e1c192540", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/264716e827f9b316c2a346efcf6dd740dbd0fb84/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=264716e827f9b316c2a346efcf6dd740dbd0fb84", "patch": "@@ -9,21 +9,21 @@ use std::{\n \n use ide::{\n     AnnotationConfig, AssistKind, AssistResolveStrategy, FileId, FilePosition, FileRange,\n-    HoverAction, HoverGotoTypeData, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n-    SingleResolve, SourceChange, TextEdit,\n+    HoverAction, HoverGotoTypeData, Query, RangeInfo, Runnable, RunnableKind, SingleResolve,\n+    SourceChange, TextEdit,\n };\n use ide_db::SymbolKind;\n use itertools::Itertools;\n use lsp_server::ErrorCode;\n use lsp_types::{\n     CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem,\n     CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams,\n-    CodeLens, CompletionItem, Diagnostic, DiagnosticTag, DocumentFormattingParams,\n-    DocumentHighlight, FoldingRange, FoldingRangeParams, HoverContents, Location, NumberOrString,\n-    Position, PrepareRenameResponse, Range, RenameParams, SemanticTokensDeltaParams,\n-    SemanticTokensFullDeltaResult, SemanticTokensParams, SemanticTokensRangeParams,\n-    SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation, SymbolTag,\n-    TextDocumentIdentifier, TextDocumentPositionParams, Url, WorkspaceEdit,\n+    CodeLens, CompletionItem, Diagnostic, DiagnosticTag, DocumentFormattingParams, FoldingRange,\n+    FoldingRangeParams, HoverContents, Location, NumberOrString, Position, PrepareRenameResponse,\n+    Range, RenameParams, SemanticTokensDeltaParams, SemanticTokensFullDeltaResult,\n+    SemanticTokensParams, SemanticTokensRangeParams, SemanticTokensRangeResult,\n+    SemanticTokensResult, SymbolInformation, SymbolTag, TextDocumentIdentifier,\n+    TextDocumentPositionParams, Url, WorkspaceEdit,\n };\n use project_model::TargetKind;\n use serde::{Deserialize, Serialize};\n@@ -1178,33 +1178,22 @@ pub(crate) fn handle_code_lens_resolve(\n pub(crate) fn handle_document_highlight(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentHighlightParams,\n-) -> Result<Option<Vec<DocumentHighlight>>> {\n+) -> Result<Option<Vec<lsp_types::DocumentHighlight>>> {\n     let _p = profile::span(\"handle_document_highlight\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n     let line_index = snap.file_line_index(position.file_id)?;\n \n-    let refs = match snap\n-        .analysis\n-        .find_all_refs(position, Some(SearchScope::single_file(position.file_id)))?\n-    {\n+    let refs = match snap.analysis.highlight_related(position)? {\n         None => return Ok(None),\n         Some(refs) => refs,\n     };\n-\n-    let decl = refs.declaration.filter(|decl| decl.nav.file_id == position.file_id).map(|decl| {\n-        DocumentHighlight {\n-            range: to_proto::range(&line_index, decl.nav.focus_or_full_range()),\n-            kind: decl.access.map(to_proto::document_highlight_kind),\n-        }\n-    });\n-\n-    let file_refs = refs.references.get(&position.file_id).map_or(&[][..], Vec::as_slice);\n-    let mut res = Vec::with_capacity(file_refs.len() + 1);\n-    res.extend(decl);\n-    res.extend(file_refs.iter().map(|&(range, access)| DocumentHighlight {\n-        range: to_proto::range(&line_index, range),\n-        kind: access.map(to_proto::document_highlight_kind),\n-    }));\n+    let res = refs\n+        .into_iter()\n+        .map(|ide::HighlightedRange { range, access }| lsp_types::DocumentHighlight {\n+            range: to_proto::range(&line_index, range),\n+            kind: access.map(to_proto::document_highlight_kind),\n+        })\n+        .collect();\n     Ok(Some(res))\n }\n "}]}