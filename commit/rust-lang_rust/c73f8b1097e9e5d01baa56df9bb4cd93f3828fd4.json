{"sha": "c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3M2Y4YjEwOTdlOWU1ZDAxYmFhNTZkZjliYjRjZDkzZjM4MjhmZDQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-22T12:55:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-22T12:55:33Z"}, "message": "fmt", "tree": {"sha": "8db7df2a90c8c7ceb2d7a05017c98a38015c86e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8db7df2a90c8c7ceb2d7a05017c98a38015c86e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "html_url": "https://github.com/rust-lang/rust/commit/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bbd6e609cb1fef17e7454bb6ced66a37f743ded", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bbd6e609cb1fef17e7454bb6ced66a37f743ded", "html_url": "https://github.com/rust-lang/rust/commit/1bbd6e609cb1fef17e7454bb6ced66a37f743ded"}], "stats": {"total": 81, "additions": 53, "deletions": 28}, "files": [{"sha": "16ab03ace2228249dd7026e65e5c91266b2e039c", "filename": "src/data_race.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "patch": "@@ -883,21 +883,19 @@ impl VClockAlloc {\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation for which data-race detection is handled separately, for example\n     /// atomic read operations.\n-    pub fn read<'tcx>(&self, pointer: Pointer<Tag>, len: Size, global: &GlobalState) -> InterpResult<'tcx> {\n+    pub fn read<'tcx>(\n+        &self,\n+        pointer: Pointer<Tag>,\n+        len: Size,\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n         if global.multi_threaded.get() {\n             let (index, clocks) = global.current_thread_state();\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (_, range) in alloc_ranges.iter_mut(pointer.offset, len) {\n                 if let Err(DataRace) = range.read_race_detect(&*clocks, index) {\n                     // Report data-race.\n-                    return Self::report_data_race(\n-                        global,\n-                        range,\n-                        \"Read\",\n-                        false,\n-                        pointer,\n-                        len,\n-                    );\n+                    return Self::report_data_race(global, range, \"Read\", false, pointer, len);\n                 }\n             }\n             Ok(())\n@@ -939,15 +937,25 @@ impl VClockAlloc {\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n-    pub fn write<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size, global: &mut GlobalState) -> InterpResult<'tcx> {\n+    pub fn write<'tcx>(\n+        &mut self,\n+        pointer: Pointer<Tag>,\n+        len: Size,\n+        global: &mut GlobalState,\n+    ) -> InterpResult<'tcx> {\n         self.unique_access(pointer, len, WriteType::Write, global)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n-    pub fn deallocate<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size, global: &mut GlobalState) -> InterpResult<'tcx> {\n+    pub fn deallocate<'tcx>(\n+        &mut self,\n+        pointer: Pointer<Tag>,\n+        len: Size,\n+        global: &mut GlobalState,\n+    ) -> InterpResult<'tcx> {\n         self.unique_access(pointer, len, WriteType::Deallocate, global)\n     }\n }"}, {"sha": "fb2d877c3803992779ceaa3c519014f979742703", "filename": "src/machine.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "patch": "@@ -151,11 +151,8 @@ impl MemoryExtra {\n         } else {\n             None\n         };\n-        let data_race = if config.data_race_detector {\n-            Some(data_race::GlobalState::new())\n-        } else {\n-            None\n-        };\n+        let data_race =\n+            if config.data_race_detector { Some(data_race::GlobalState::new()) } else { None };\n         MemoryExtra {\n             stacked_borrows,\n             data_race,\n@@ -532,7 +529,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.write(ptr, size, memory_extra.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_written(ptr, size, memory_extra.stacked_borrows.as_mut().unwrap())\n+            stacked_borrows.memory_written(\n+                ptr,\n+                size,\n+                memory_extra.stacked_borrows.as_mut().unwrap(),\n+            )\n         } else {\n             Ok(())\n         }\n@@ -552,7 +553,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.deallocate(ptr, size, memory_extra.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_deallocated(ptr, size, memory_extra.stacked_borrows.as_mut().unwrap())\n+            stacked_borrows.memory_deallocated(\n+                ptr,\n+                size,\n+                memory_extra.stacked_borrows.as_mut().unwrap(),\n+            )\n         } else {\n             Ok(())\n         }"}, {"sha": "a9c030c87de4ed94f929d3f11de5837123130ec2", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "patch": "@@ -1,10 +1,10 @@\n //! Implements \"Stacked Borrows\".  See <https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md>\n //! for further information.\n \n+use log::trace;\n use std::cell::RefCell;\n use std::fmt;\n use std::num::NonZeroU64;\n-use log::trace;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::Mutability;\n@@ -509,15 +509,29 @@ impl Stacks {\n     }\n \n     #[inline(always)]\n-    pub fn memory_read<'tcx>(&self, ptr: Pointer<Tag>, size: Size, extra: &MemoryExtra) -> InterpResult<'tcx> {\n+    pub fn memory_read<'tcx>(\n+        &self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        extra: &MemoryExtra,\n+    ) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, &*extra.borrow(), |ptr, stack, global| stack.access(AccessKind::Read, ptr, global))\n+        self.for_each(ptr, size, &*extra.borrow(), |ptr, stack, global| {\n+            stack.access(AccessKind::Read, ptr, global)\n+        })\n     }\n \n     #[inline(always)]\n-    pub fn memory_written<'tcx>(&mut self, ptr: Pointer<Tag>, size: Size, extra: &mut MemoryExtra) -> InterpResult<'tcx> {\n+    pub fn memory_written<'tcx>(\n+        &mut self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        extra: &mut MemoryExtra,\n+    ) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| stack.access(AccessKind::Write, ptr, global))\n+        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| {\n+            stack.access(AccessKind::Write, ptr, global)\n+        })\n     }\n \n     #[inline(always)]\n@@ -589,7 +603,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        stacked_borrows.for_each(ptr, size, &*global, |ptr, stack, global| stack.grant(ptr, item, global))\n+        stacked_borrows\n+            .for_each(ptr, size, &*global, |ptr, stack, global| stack.grant(ptr, item, global))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version."}, {"sha": "3418e8c7d2bfdf9ce63522b418c86bbee05e689e", "filename": "src/thread.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "patch": "@@ -436,10 +436,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Wakes up threads joining on the active one and deallocates thread-local statics.\n     /// The `AllocId` that can now be freed is returned.\n-    fn thread_terminated(\n-        &mut self,\n-        data_race: &Option<data_race::GlobalState>,\n-    ) -> Vec<AllocId> {\n+    fn thread_terminated(&mut self, data_race: &Option<data_race::GlobalState>) -> Vec<AllocId> {\n         let mut free_tls_statics = Vec::new();\n         {\n             let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();"}]}