{"sha": "41601a8c95240cada94c13466a1fea02e5fe87ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNjAxYThjOTUyNDBjYWRhOTRjMTM0NjZhMWZlYTAyZTVmZTg3ZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-06T23:35:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-06T23:35:00Z"}, "message": "Auto merge of #67104 - Centril:rollup-07vahh9, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #66606 (Add feature gate for mut refs in const fn)\n - #66841 (Add `{f32,f64}::approx_unchecked_to<Int>` unsafe methods)\n - #67009 (Emit coercion suggestions in more places)\n - #67052 (Ditch `parse_in_attr`)\n - #67071 (Do not ICE on closure typeck)\n - #67078 (accept union inside enum if not followed by identifier)\n - #67090 (Change \"either\" to \"any\" in Layout::from_size_align's docs)\n - #67092 (Fix comment typos in src/libcore/alloc.rs)\n - #67094 (get rid of __ in field names)\n - #67102 (Add note to src/ci/docker/README.md about multiple docker images)\n\nFailed merges:\n\n - #67101 (use `#[allow(unused_attributes)]` to paper over incr.comp problem)\n\nr? @ghost", "tree": {"sha": "703464bdb077746244b9d553579c48b9cbbedc70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/703464bdb077746244b9d553579c48b9cbbedc70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41601a8c95240cada94c13466a1fea02e5fe87ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41601a8c95240cada94c13466a1fea02e5fe87ed", "html_url": "https://github.com/rust-lang/rust/commit/41601a8c95240cada94c13466a1fea02e5fe87ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41601a8c95240cada94c13466a1fea02e5fe87ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae1b871cca56613b1af1a5121dd24ac810ff4b89", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae1b871cca56613b1af1a5121dd24ac810ff4b89", "html_url": "https://github.com/rust-lang/rust/commit/ae1b871cca56613b1af1a5121dd24ac810ff4b89"}, {"sha": "dbc9f306b69153cdff991303c1dfd7a29136b752", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9f306b69153cdff991303c1dfd7a29136b752", "html_url": "https://github.com/rust-lang/rust/commit/dbc9f306b69153cdff991303c1dfd7a29136b752"}], "stats": {"total": 1966, "additions": 1278, "deletions": 688}, "files": [{"sha": "872f2c3467d202729241b31dabe0936a2f37dcd9", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -16,6 +16,13 @@ for example:\n \n Images will output artifacts in an `obj` dir at the root of a repository.\n \n+**NOTE**: Re-using the same `obj` dir with different docker images with\n+the same target triple (e.g. `dist-x86_64-linux` and `dist-various-1`)\n+may result in strange linker errors, due shared library versions differing between platforms.\n+\n+If you encounter any issues when using multiple Docker images, try deleting your `obj` directory\n+before running your command.\n+\n ## Filesystem layout\n \n - Each directory, excluding `scripts` and `disabled`, corresponds to a docker image"}, {"sha": "20248f7f6c13e374e471f423a37b48ef14556f24", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -53,7 +53,7 @@ pub struct Layout {\n \n impl Layout {\n     /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `LayoutErr` if either of the following conditions\n+    /// or returns `LayoutErr` if any of the following conditions\n     /// are not met:\n     ///\n     /// * `align` must not be zero,\n@@ -137,7 +137,7 @@ impl Layout {\n     #[inline]\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n-        // See rationale in `new` for why this us using an unsafe variant below\n+        // See rationale in `new` for why this is using an unsafe variant below\n         debug_assert!(Layout::from_size_align(size, align).is_ok());\n         unsafe {\n             Layout::from_size_align_unchecked(size, align)\n@@ -196,7 +196,7 @@ impl Layout {\n         //    valid.\n         //\n         // 2. `len + align - 1` can overflow by at most `align - 1`,\n-        //    so the &-mask wth `!(align - 1)` will ensure that in the\n+        //    so the &-mask with `!(align - 1)` will ensure that in the\n         //    case of overflow, `len_rounded_up` will itself be 0.\n         //    Thus the returned padding, when added to `len`, yields 0,\n         //    which trivially satisfies the alignment `align`."}, {"sha": "16d5375059feebd663c6bc563c96aa750375bd7c", "filename": "src/libcore/convert/mod.rs", "status": "renamed", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -40,6 +40,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+mod num;\n+\n+#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+pub use num::FloatToInt;\n+\n /// The identity function.\n ///\n /// Two things are important to note about this function:", "previous_filename": "src/libcore/convert.rs"}, {"sha": "0877dacb38dd2ee80662e021f02219274f9a7997", "filename": "src/libcore/convert/num.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,369 @@\n+use super::{From, TryFrom};\n+use crate::num::TryFromIntError;\n+\n+mod private {\n+    /// This trait being unreachable from outside the crate\n+    /// prevents other implementations of the `FloatToInt` trait,\n+    /// which allows potentially adding more trait methods after the trait is `#[stable]`.\n+    #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+    pub trait Sealed {}\n+}\n+\n+/// Supporting trait for inherent methods of `f32` and `f64` such as `round_unchecked_to`.\n+/// Typically doesn\u2019t need to be used directly.\n+#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+pub trait FloatToInt<Int>: private::Sealed + Sized {\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[doc(hidden)]\n+    unsafe fn approx_unchecked(self) -> Int;\n+}\n+\n+macro_rules! impl_float_to_int {\n+    ( $Float: ident => $( $Int: ident )+ ) => {\n+        #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+        impl private::Sealed for $Float {}\n+        $(\n+            #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+            impl FloatToInt<$Int> for $Float {\n+                #[cfg(not(bootstrap))]\n+                #[doc(hidden)]\n+                #[inline]\n+                unsafe fn approx_unchecked(self) -> $Int {\n+                    crate::intrinsics::float_to_int_approx_unchecked(self)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+impl_float_to_int!(f32 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n+impl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n+\n+// Conversion traits for primitive integer and float types\n+// Conversions T -> T are covered by a blanket impl and therefore excluded\n+// Some conversions from and to usize/isize are not implemented due to portability concerns\n+macro_rules! impl_from {\n+    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n+        #[$attr]\n+        #[doc = $doc]\n+        impl From<$Small> for $Large {\n+            #[inline]\n+            fn from(small: $Small) -> $Large {\n+                small as $Large\n+            }\n+        }\n+    };\n+    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n+        impl_from!($Small,\n+                   $Large,\n+                   #[$attr],\n+                   concat!(\"Converts `\",\n+                           stringify!($Small),\n+                           \"` to `\",\n+                           stringify!($Large),\n+                           \"` losslessly.\"));\n+    }\n+}\n+\n+macro_rules! impl_from_bool {\n+    ($target: ty, #[$attr:meta]) => {\n+        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n+            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n+values.\n+\n+# Examples\n+\n+```\n+assert_eq!(\", stringify!($target), \"::from(true), 1);\n+assert_eq!(\", stringify!($target), \"::from(false), 0);\n+```\"));\n+    };\n+}\n+\n+// Bool -> Any\n+impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+\n+// Unsigned -> Unsigned\n+impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Signed -> Signed\n+impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Unsigned -> Signed\n+impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n+// which imply that pointer-sized integers must be at least 16 bits:\n+// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n+impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+\n+// RISC-V defines the possibility of a 128-bit address space (RV128).\n+\n+// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n+// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n+// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n+\n+\n+// Note: integers can only be represented with full precision in a float if\n+// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n+// Lossy float conversions are not implemented at this time.\n+\n+// Signed -> Float\n+impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Unsigned -> Float\n+impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Float -> Float\n+impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// no possible bounds violation\n+macro_rules! try_from_unbounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(value: $source) -> Result<Self, Self::Error> {\n+                Ok(value as $target)\n+            }\n+        }\n+    )*}\n+}\n+\n+// only negative bounds\n+macro_rules! try_from_lower_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u >= 0 {\n+                    Ok(u as $target)\n+                } else {\n+                    Err(TryFromIntError(()))\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// unsigned to signed (only positive bound)\n+macro_rules! try_from_upper_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u > (<$target>::max_value() as $source) {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// all other cases\n+macro_rules! try_from_both_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                let min = <$target>::min_value() as $source;\n+                let max = <$target>::max_value() as $source;\n+                if u < min || u > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+macro_rules! rev {\n+    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n+        $mac!($target, $source);\n+    )*}\n+}\n+\n+// intra-sign conversions\n+try_from_upper_bounded!(u16, u8);\n+try_from_upper_bounded!(u32, u16, u8);\n+try_from_upper_bounded!(u64, u32, u16, u8);\n+try_from_upper_bounded!(u128, u64, u32, u16, u8);\n+\n+try_from_both_bounded!(i16, i8);\n+try_from_both_bounded!(i32, i16, i8);\n+try_from_both_bounded!(i64, i32, i16, i8);\n+try_from_both_bounded!(i128, i64, i32, i16, i8);\n+\n+// unsigned-to-signed\n+try_from_upper_bounded!(u8, i8);\n+try_from_upper_bounded!(u16, i8, i16);\n+try_from_upper_bounded!(u32, i8, i16, i32);\n+try_from_upper_bounded!(u64, i8, i16, i32, i64);\n+try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n+\n+// signed-to-unsigned\n+try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n+try_from_lower_bounded!(i16, u16, u32, u64, u128);\n+try_from_lower_bounded!(i32, u32, u64, u128);\n+try_from_lower_bounded!(i64, u64, u128);\n+try_from_lower_bounded!(i128, u128);\n+try_from_both_bounded!(i16, u8);\n+try_from_both_bounded!(i32, u16, u8);\n+try_from_both_bounded!(i64, u32, u16, u8);\n+try_from_both_bounded!(i128, u64, u32, u16, u8);\n+\n+// usize/isize\n+try_from_upper_bounded!(usize, isize);\n+try_from_lower_bounded!(isize, usize);\n+\n+#[cfg(target_pointer_width = \"16\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8);\n+    try_from_unbounded!(usize, u16, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16);\n+    try_from_unbounded!(usize, i32, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8);\n+    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8);\n+    try_from_unbounded!(isize, i16, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16);\n+    rev!(try_from_both_bounded, usize, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n+    rev!(try_from_both_bounded, isize, i32, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16);\n+    try_from_unbounded!(usize, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32);\n+    try_from_unbounded!(usize, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16);\n+    try_from_lower_bounded!(isize, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16);\n+    try_from_unbounded!(isize, i32, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32);\n+    rev!(try_from_upper_bounded, usize, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n+    rev!(try_from_both_bounded, usize, i64, i128);\n+\n+    rev!(try_from_unbounded, isize, u16);\n+    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n+    rev!(try_from_unbounded, isize, i32);\n+    rev!(try_from_both_bounded, isize, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16, u32);\n+    try_from_unbounded!(usize, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n+    try_from_unbounded!(usize, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16, u32);\n+    try_from_lower_bounded!(isize, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16, i32);\n+    try_from_unbounded!(isize, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32, u64);\n+    rev!(try_from_upper_bounded, usize, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n+    rev!(try_from_both_bounded, usize, i128);\n+\n+    rev!(try_from_unbounded, isize, u16, u32);\n+    rev!(try_from_upper_bounded, isize, u64, u128);\n+    rev!(try_from_unbounded, isize, i32, i64);\n+    rev!(try_from_both_bounded, isize, i128);\n+}"}, {"sha": "18aae59573d7d56a0707f586617bf86570a816ad", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1144,6 +1144,11 @@ extern \"rust-intrinsic\" {\n     /// May assume inputs are finite.\n     pub fn frem_fast<T>(a: T, b: T) -> T;\n \n+    /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n+    /// https://github.com/rust-lang/rust/issues/10184\n+    #[cfg(not(bootstrap))]\n+    pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n+\n \n     /// Returns the number of bits set in an integer type `T`\n     pub fn ctpop<T>(x: T) -> T;"}, {"sha": "ac06f95e244b6f97c407804b0812dac9d151fa12", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -7,9 +7,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(bootstrap))]\n+use crate::convert::FloatToInt;\n #[cfg(not(test))]\n use crate::intrinsics;\n-\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -400,6 +401,35 @@ impl f32 {\n         intrinsics::minnumf32(self, other)\n     }\n \n+    /// Rounds toward zero and converts to any primitive integer type,\n+    /// assuming that the value is finite and fits in that type.\n+    ///\n+    /// ```\n+    /// #![feature(float_approx_unchecked_to)]\n+    ///\n+    /// let value = 4.6_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// assert_eq!(rounded, 4);\n+    ///\n+    /// let value = -128.9_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n+    /// assert_eq!(rounded, std::i8::MIN);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The value must:\n+    ///\n+    /// * Not be `NaN`\n+    /// * Not be infinite\n+    /// * Be representable in the return type `Int`, after truncating off its fractional part\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[inline]\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+        FloatToInt::<Int>::approx_unchecked(self)\n+    }\n+\n     /// Raw transmutation to `u32`.\n     ///\n     /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms."}, {"sha": "794f77fcfc1be379e879214ee5a4cd2672ac9ae8", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -7,9 +7,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(bootstrap))]\n+use crate::convert::FloatToInt;\n #[cfg(not(test))]\n use crate::intrinsics;\n-\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -413,6 +414,35 @@ impl f64 {\n         intrinsics::minnumf64(self, other)\n     }\n \n+    /// Rounds toward zero and converts to any primitive integer type,\n+    /// assuming that the value is finite and fits in that type.\n+    ///\n+    /// ```\n+    /// #![feature(float_approx_unchecked_to)]\n+    ///\n+    /// let value = 4.6_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// assert_eq!(rounded, 4);\n+    ///\n+    /// let value = -128.9_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n+    /// assert_eq!(rounded, std::i8::MIN);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The value must:\n+    ///\n+    /// * Not be `NaN`\n+    /// * Not be infinite\n+    /// * Be representable in the return type `Int`, after truncating off its fractional part\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[inline]\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+        FloatToInt::<Int>::approx_unchecked(self)\n+    }\n+\n     /// Raw transmutation to `u64`.\n     ///\n     /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms."}, {"sha": "585f144cf8a9f3b76ce64f2851c47a03409acc48", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 330, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -4,7 +4,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::convert::TryFrom;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n@@ -4701,7 +4700,7 @@ from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n /// The error type returned when a checked integral type conversion fails.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromIntError(());\n+pub struct TryFromIntError(pub(crate) ());\n \n impl TryFromIntError {\n     #[unstable(feature = \"int_error_internals\",\n@@ -4728,206 +4727,6 @@ impl From<!> for TryFromIntError {\n     }\n }\n \n-// no possible bounds violation\n-macro_rules! try_from_unbounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(value: $source) -> Result<Self, Self::Error> {\n-                Ok(value as $target)\n-            }\n-        }\n-    )*}\n-}\n-\n-// only negative bounds\n-macro_rules! try_from_lower_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u >= 0 {\n-                    Ok(u as $target)\n-                } else {\n-                    Err(TryFromIntError(()))\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// unsigned to signed (only positive bound)\n-macro_rules! try_from_upper_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u > (<$target>::max_value() as $source) {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// all other cases\n-macro_rules! try_from_both_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                let min = <$target>::min_value() as $source;\n-                let max = <$target>::max_value() as $source;\n-                if u < min || u > max {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-macro_rules! rev {\n-    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n-        $mac!($target, $source);\n-    )*}\n-}\n-\n-// intra-sign conversions\n-try_from_upper_bounded!(u16, u8);\n-try_from_upper_bounded!(u32, u16, u8);\n-try_from_upper_bounded!(u64, u32, u16, u8);\n-try_from_upper_bounded!(u128, u64, u32, u16, u8);\n-\n-try_from_both_bounded!(i16, i8);\n-try_from_both_bounded!(i32, i16, i8);\n-try_from_both_bounded!(i64, i32, i16, i8);\n-try_from_both_bounded!(i128, i64, i32, i16, i8);\n-\n-// unsigned-to-signed\n-try_from_upper_bounded!(u8, i8);\n-try_from_upper_bounded!(u16, i8, i16);\n-try_from_upper_bounded!(u32, i8, i16, i32);\n-try_from_upper_bounded!(u64, i8, i16, i32, i64);\n-try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n-\n-// signed-to-unsigned\n-try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n-try_from_lower_bounded!(i16, u16, u32, u64, u128);\n-try_from_lower_bounded!(i32, u32, u64, u128);\n-try_from_lower_bounded!(i64, u64, u128);\n-try_from_lower_bounded!(i128, u128);\n-try_from_both_bounded!(i16, u8);\n-try_from_both_bounded!(i32, u16, u8);\n-try_from_both_bounded!(i64, u32, u16, u8);\n-try_from_both_bounded!(i128, u64, u32, u16, u8);\n-\n-// usize/isize\n-try_from_upper_bounded!(usize, isize);\n-try_from_lower_bounded!(isize, usize);\n-\n-#[cfg(target_pointer_width = \"16\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8);\n-    try_from_unbounded!(usize, u16, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16);\n-    try_from_unbounded!(usize, i32, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8);\n-    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8);\n-    try_from_unbounded!(isize, i16, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16);\n-    rev!(try_from_both_bounded, usize, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_both_bounded, isize, i32, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16);\n-    try_from_unbounded!(usize, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32);\n-    try_from_unbounded!(usize, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16);\n-    try_from_lower_bounded!(isize, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16);\n-    try_from_unbounded!(isize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32);\n-    rev!(try_from_upper_bounded, usize, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n-    rev!(try_from_both_bounded, usize, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u16);\n-    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i32);\n-    rev!(try_from_both_bounded, isize, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16, u32);\n-    try_from_unbounded!(usize, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n-    try_from_unbounded!(usize, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16, u32);\n-    try_from_lower_bounded!(isize, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16, i32);\n-    try_from_unbounded!(isize, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32, u64);\n-    rev!(try_from_upper_bounded, usize, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n-    rev!(try_from_both_bounded, usize, i128);\n-\n-    rev!(try_from_unbounded, isize, u16, u32);\n-    rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i32, i64);\n-    rev!(try_from_both_bounded, isize, i128);\n-}\n-\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n@@ -5110,131 +4909,3 @@ impl fmt::Display for ParseIntError {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::num::dec2flt::ParseFloatError;\n-\n-// Conversion traits for primitive integer and float types\n-// Conversions T -> T are covered by a blanket impl and therefore excluded\n-// Some conversions from and to usize/isize are not implemented due to portability concerns\n-macro_rules! impl_from {\n-    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n-        #[$attr]\n-        #[doc = $doc]\n-        impl From<$Small> for $Large {\n-            #[inline]\n-            fn from(small: $Small) -> $Large {\n-                small as $Large\n-            }\n-        }\n-    };\n-    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n-        impl_from!($Small,\n-                   $Large,\n-                   #[$attr],\n-                   concat!(\"Converts `\",\n-                           stringify!($Small),\n-                           \"` to `\",\n-                           stringify!($Large),\n-                           \"` losslessly.\"));\n-    }\n-}\n-\n-macro_rules! impl_from_bool {\n-    ($target: ty, #[$attr:meta]) => {\n-        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n-            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n-values.\n-\n-# Examples\n-\n-```\n-assert_eq!(\", stringify!($target), \"::from(true), 1);\n-assert_eq!(\", stringify!($target), \"::from(false), 0);\n-```\"));\n-    };\n-}\n-\n-// Bool -> Any\n-impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-\n-// Unsigned -> Unsigned\n-impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Signed -> Signed\n-impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Unsigned -> Signed\n-impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n-// which imply that pointer-sized integers must be at least 16 bits:\n-// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n-impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-\n-// RISC-V defines the possibility of a 128-bit address space (RV128).\n-\n-// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n-// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n-// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n-\n-\n-// Note: integers can only be represented with full precision in a float if\n-// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n-// Lossy float conversions are not implemented at this time.\n-\n-// Signed -> Float\n-impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Unsigned -> Float\n-impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Float -> Float\n-impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }"}, {"sha": "35017d6330da31555805556276b32139d5099d16", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -2210,6 +2210,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         let span = self.tcx.def_span(generator_did);\n+        // Do not ICE on closure typeck (#66868).\n+        if let None = self.tcx.hir().as_local_hir_id(generator_did) {\n+            return false;\n+        }\n         let tables = self.tcx.typeck_tables_of(generator_did);\n         debug!(\"note_obligation_cause_for_async_await: generator_did={:?} span={:?} \",\n                generator_did, span);"}, {"sha": "1767ad118e7c0912bd706b9527caabbbdbdaaeee", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -516,9 +516,36 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         return;\n                     }\n                 }\n-\n             },\n \n+            \"float_to_int_approx_unchecked\" => {\n+                if float_type_width(arg_tys[0]).is_none() {\n+                    span_invalid_monomorphization_error(\n+                        tcx.sess, span,\n+                        &format!(\"invalid monomorphization of `float_to_int_approx_unchecked` \\\n+                                  intrinsic: expected basic float type, \\\n+                                  found `{}`\", arg_tys[0]));\n+                    return;\n+                }\n+                match int_type_width_signed(ret_ty, self.cx) {\n+                    Some((width, signed)) => {\n+                        if signed {\n+                            self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n+                        } else {\n+                            self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n+                        }\n+                    }\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `float_to_int_approx_unchecked` \\\n+                                      intrinsic:  expected basic integer type, \\\n+                                      found `{}`\", ret_ty));\n+                        return;\n+                    }\n+                }\n+            }\n+\n             \"discriminant_value\" => {\n                 args[0].deref(self.cx()).codegen_get_discr(self, ret_ty)\n             }"}, {"sha": "9c1bec39b29e2834533163c00bab032c12003b7f", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -18,7 +18,6 @@ E0010: include_str!(\"./error_codes/E0010.md\"),\n E0013: include_str!(\"./error_codes/E0013.md\"),\n E0014: include_str!(\"./error_codes/E0014.md\"),\n E0015: include_str!(\"./error_codes/E0015.md\"),\n-E0017: include_str!(\"./error_codes/E0017.md\"),\n E0019: include_str!(\"./error_codes/E0019.md\"),\n E0023: include_str!(\"./error_codes/E0023.md\"),\n E0025: include_str!(\"./error_codes/E0025.md\"),"}, {"sha": "d5e6857b4d6f893c2418f0962d15dcabef21fa83", "filename": "src/librustc_error_codes/error_codes/E0017.md", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae1b871cca56613b1af1a5121dd24ac810ff4b89/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae1b871cca56613b1af1a5121dd24ac810ff4b89/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md?ref=ae1b871cca56613b1af1a5121dd24ac810ff4b89", "patch": "@@ -1,20 +0,0 @@\n-References in statics and constants may only refer to immutable values.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0017\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-// these three are not allowed:\n-const CR: &mut i32 = &mut C;\n-static STATIC_REF: &'static mut i32 = &mut X;\n-static CONST_REF: &'static mut i32 = &mut C;\n-```\n-\n-Statics are shared everywhere, and if they refer to mutable data one might\n-violate memory safety since holding multiple mutable references to shared data\n-is not allowed.\n-\n-If you really want global mutable state, try using `static mut` or a global\n-`UnsafeCell`."}, {"sha": "b1ae7c6ca33d872d6e802ae4a0251c660a0c0fae", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -523,6 +523,9 @@ declare_features! (\n     /// Allows the use of `#[cfg(sanitize = \"option\")]`; set when -Zsanitizer is used.\n     (active, cfg_sanitize, \"1.41.0\", Some(39699), None),\n \n+    /// Allows using `&mut` in constant functions.\n+    (active, const_mut_refs, \"1.41.0\", Some(57349), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "393ae9442a17e2976c9d85072f85b13da582393c", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,7 +1,6 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::BorrowKind;\n use rustc::session::config::nightly_options;\n use rustc::ty::TyCtxt;\n use syntax::feature_gate::feature_err;\n@@ -181,38 +180,53 @@ impl NonConstOp for Loop {\n }\n \n #[derive(Debug)]\n-pub struct MutBorrow(pub BorrowKind);\n+pub struct CellBorrow;\n+impl NonConstOp for CellBorrow {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        span_err!(item.tcx.sess, span, E0492,\n+            \"cannot borrow a constant which may contain \\\n+            interior mutability, create a static instead\");\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct MutBorrow;\n impl NonConstOp for MutBorrow {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_mut_refs)\n+    }\n+\n     fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-        let kind = self.0;\n-        if let BorrowKind::Mut { .. } = kind {\n-            let mut err = struct_span_err!(item.tcx.sess, span, E0017,\n-                                           \"references in {}s may only refer \\\n-                                            to immutable values\", item.const_kind());\n-            err.span_label(span, format!(\"{}s require immutable values\",\n-                                                item.const_kind()));\n-            if item.tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\"References in statics and constants may only refer \\\n-                          to immutable values.\\n\\n\\\n-                          Statics are shared everywhere, and if they refer to \\\n-                          mutable data one might violate memory safety since \\\n-                          holding multiple mutable references to shared data \\\n-                          is not allowed.\\n\\n\\\n-                          If you really want global mutable state, try using \\\n-                          static mut or a global UnsafeCell.\");\n-            }\n-            err.emit();\n-        } else {\n-            span_err!(item.tcx.sess, span, E0492,\n-                      \"cannot borrow a constant which may contain \\\n-                       interior mutability, create a static instead\");\n+        let mut err = feature_err(\n+            &item.tcx.sess.parse_sess,\n+            sym::const_mut_refs,\n+            span,\n+            &format!(\"references in {}s may only refer \\\n+                      to immutable values\", item.const_kind())\n+        );\n+        err.span_label(span, format!(\"{}s require immutable values\",\n+                                            item.const_kind()));\n+        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\"References in statics and constants may only refer \\\n+                      to immutable values.\\n\\n\\\n+                      Statics are shared everywhere, and if they refer to \\\n+                      mutable data one might violate memory safety since \\\n+                      holding multiple mutable references to shared data \\\n+                      is not allowed.\\n\\n\\\n+                      If you really want global mutable state, try using \\\n+                      static mut or a global UnsafeCell.\");\n         }\n+        err.emit();\n     }\n }\n \n #[derive(Debug)]\n pub struct MutDeref;\n-impl NonConstOp for MutDeref {}\n+impl NonConstOp for MutDeref {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_mut_refs)\n+    }\n+}\n \n #[derive(Debug)]\n pub struct Panic;"}, {"sha": "7170857926b3786599075bb551f4edad7aad98fc", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -359,7 +359,11 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 };\n \n                 if !is_allowed {\n-                    self.check_op(ops::MutBorrow(kind));\n+                    if let BorrowKind::Mut{ .. } = kind {\n+                        self.check_op(ops::MutBorrow);\n+                    } else {\n+                        self.check_op(ops::CellBorrow);\n+                    }\n                 }\n             }\n \n@@ -384,7 +388,11 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 );\n \n                 if borrowed_place_has_mut_interior {\n-                    self.check_op(ops::MutBorrow(kind));\n+                    if let BorrowKind::Mut{ .. } = kind {\n+                        self.check_op(ops::MutBorrow);\n+                    } else {\n+                        self.check_op(ops::CellBorrow);\n+                    }\n                 }\n             }\n \n@@ -451,7 +459,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n         }\n     }\n-\n     fn visit_projection_elem(\n         &mut self,\n         place_base: &PlaceBase<'tcx>,"}, {"sha": "cf2e1306dc44b42bcb1622a424e4a260b39f4fee", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -79,10 +79,14 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n     for ty in ty.walk() {\n         match ty.kind {\n-            ty::Ref(_, _, hir::Mutability::Mutable) => return Err((\n-                span,\n-                \"mutable references in const fn are unstable\".into(),\n-            )),\n+            ty::Ref(_, _, hir::Mutability::Mutable) => {\n+                if !tcx.features().const_mut_refs {\n+                    return Err((\n+                        span,\n+                        \"mutable references in const fn are unstable\".into(),\n+                    ))\n+                }\n+            }\n             ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n                 if !tcx.const_fn_is_allowed_fn_ptr(fn_def_id) {"}, {"sha": "1e9203f377f383b028978416b6f6c34d5b2a9788", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 62, "deletions": 44, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -8,18 +8,19 @@\n //!\n //! [#64197]: https://github.com/rust-lang/rust/issues/64197\n \n-use crate::validate_attr;\n+use crate::{parse_in, validate_attr};\n use rustc_feature::Features;\n use rustc_errors::Applicability;\n use syntax::attr::HasAttrs;\n use syntax::feature_gate::{feature_err, get_features};\n use syntax::attr;\n-use syntax::ast;\n+use syntax::ast::{self, Attribute, AttrItem, MetaItem};\n use syntax::edition::Edition;\n use syntax::mut_visit::*;\n use syntax::ptr::P;\n use syntax::sess::ParseSess;\n use syntax::util::map_in_place::MapInPlace;\n+use syntax_pos::Span;\n use syntax_pos::symbol::sym;\n \n use smallvec::SmallVec;\n@@ -72,6 +73,11 @@ macro_rules! configure {\n     }\n }\n \n+const CFG_ATTR_GRAMMAR_HELP: &str = \"#[cfg_attr(condition, attribute, other_attribute, ...)]\";\n+const CFG_ATTR_NOTE_REF: &str = \"for more information, visit \\\n+    <https://doc.rust-lang.org/reference/conditional-compilation.html\\\n+    #the-cfg_attr-attribute>\";\n+\n impl<'a> StripUnconfigured<'a> {\n     pub fn configure<T: HasAttrs>(&mut self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n@@ -97,34 +103,14 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives a compiler warning when the `cfg_attr` contains no attributes and\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n-    fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Vec<ast::Attribute> {\n+    fn process_cfg_attr(&mut self, attr: Attribute) -> Vec<Attribute> {\n         if !attr.has_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n-        if let ast::MacArgs::Empty = attr.get_normal_item().args {\n-            self.sess.span_diagnostic\n-                .struct_span_err(\n-                    attr.span,\n-                    \"malformed `cfg_attr` attribute input\",\n-                ).span_suggestion(\n-                    attr.span,\n-                    \"missing condition and attribute\",\n-                    \"#[cfg_attr(condition, attribute, other_attribute, ...)]\".to_owned(),\n-                    Applicability::HasPlaceholders,\n-                ).note(\"for more information, visit \\\n-                       <https://doc.rust-lang.org/reference/conditional-compilation.html\\\n-                       #the-cfg_attr-attribute>\")\n-                .emit();\n-            return vec![];\n-        }\n \n-        let res = crate::parse_in_attr(self.sess, &attr, |p| p.parse_cfg_attr());\n-        let (cfg_predicate, expanded_attrs) = match res {\n-            Ok(result) => result,\n-            Err(mut e) => {\n-                e.emit();\n-                return vec![];\n-            }\n+        let (cfg_predicate, expanded_attrs) = match self.parse_cfg_attr(&attr) {\n+            None => return vec![],\n+            Some(r) => r,\n         };\n \n         // Lint on zero attributes in source.\n@@ -135,24 +121,56 @@ impl<'a> StripUnconfigured<'a> {\n         // At this point we know the attribute is considered used.\n         attr::mark_used(&attr);\n \n-        if attr::cfg_matches(&cfg_predicate, self.sess, self.features) {\n-            // We call `process_cfg_attr` recursively in case there's a\n-            // `cfg_attr` inside of another `cfg_attr`. E.g.\n-            //  `#[cfg_attr(false, cfg_attr(true, some_attr))]`.\n-            expanded_attrs.into_iter()\n-            .flat_map(|(item, span)| self.process_cfg_attr(attr::mk_attr_from_item(\n-                attr.style,\n-                item,\n-                span,\n-            )))\n+        if !attr::cfg_matches(&cfg_predicate, self.sess, self.features) {\n+            return vec![];\n+        }\n+\n+        // We call `process_cfg_attr` recursively in case there's a\n+        // `cfg_attr` inside of another `cfg_attr`. E.g.\n+        //  `#[cfg_attr(false, cfg_attr(true, some_attr))]`.\n+        expanded_attrs\n+            .into_iter()\n+            .flat_map(|(item, span)| {\n+                let attr = attr::mk_attr_from_item(attr.style, item, span);\n+                self.process_cfg_attr(attr)\n+            })\n             .collect()\n-        } else {\n-            vec![]\n+    }\n+\n+    fn parse_cfg_attr(&self, attr: &Attribute) -> Option<(MetaItem, Vec<(AttrItem, Span)>)> {\n+        match attr.get_normal_item().args {\n+            ast::MacArgs::Delimited(dspan, delim, ref tts) if !tts.is_empty() => {\n+                let msg = \"wrong `cfg_attr` delimiters\";\n+                validate_attr::check_meta_bad_delim(self.sess, dspan, delim, msg);\n+                match parse_in(self.sess, tts.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n+                    Ok(r) => return Some(r),\n+                    Err(mut e) => e\n+                        .help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n+                        .note(CFG_ATTR_NOTE_REF)\n+                        .emit(),\n+                }\n+            }\n+            _ => self.error_malformed_cfg_attr_missing(attr.span),\n         }\n+        None\n+    }\n+\n+    fn error_malformed_cfg_attr_missing(&self, span: Span) {\n+        self.sess\n+            .span_diagnostic\n+            .struct_span_err(span, \"malformed `cfg_attr` attribute input\")\n+            .span_suggestion(\n+                span,\n+                \"missing condition and attribute\",\n+                CFG_ATTR_GRAMMAR_HELP.to_string(),\n+                Applicability::HasPlaceholders,\n+            )\n+            .note(CFG_ATTR_NOTE_REF)\n+            .emit();\n     }\n \n     /// Determines if a node with the given attributes should be included in this configuration.\n-    pub fn in_cfg(&self, attrs: &[ast::Attribute]) -> bool {\n+    pub fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n             if !is_cfg(attr) {\n                 return true;\n@@ -199,15 +217,15 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// Visit attributes on expression and statements (but not attributes on items in blocks).\n-    fn visit_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn visit_expr_attrs(&mut self, attrs: &[Attribute]) {\n         // flag the offending attributes\n         for attr in attrs.iter() {\n             self.maybe_emit_expr_attr_err(attr);\n         }\n     }\n \n     /// If attributes are not allowed on expressions, emit an error for `attr`\n-    pub fn maybe_emit_expr_attr_err(&self, attr: &ast::Attribute) {\n+    pub fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n             let mut err = feature_err(self.sess,\n                                       sym::stmt_expr_attributes,\n@@ -350,7 +368,7 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n     }\n }\n \n-fn is_cfg(attr: &ast::Attribute) -> bool {\n+fn is_cfg(attr: &Attribute) -> bool {\n     attr.check_name(sym::cfg)\n }\n \n@@ -359,8 +377,8 @@ fn is_cfg(attr: &ast::Attribute) -> bool {\n pub fn process_configure_mod(\n     sess: &ParseSess,\n     cfg_mods: bool,\n-    attrs: &[ast::Attribute],\n-) -> (bool, Vec<ast::Attribute>) {\n+    attrs: &[Attribute],\n+) -> (bool, Vec<Attribute>) {\n     // Don't perform gated feature checking.\n     let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n     let mut attrs = attrs.to_owned();"}, {"sha": "faff386e9231826d42924eba891daf68bd0397dc", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -271,21 +271,13 @@ pub fn stream_to_parser_with_base_dir<'a>(\n }\n \n /// Runs the given subparser `f` on the tokens of the given `attr`'s item.\n-pub fn parse_in_attr<'a, T>(\n+pub fn parse_in<'a, T>(\n     sess: &'a ParseSess,\n-    attr: &ast::Attribute,\n+    tts: TokenStream,\n+    name: &'static str,\n     mut f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n ) -> PResult<'a, T> {\n-    let mut parser = Parser::new(\n-        sess,\n-        // FIXME(#66940, Centril | petrochenkov): refactor this function so it doesn't\n-        // require reconstructing and immediately re-parsing delimiters.\n-        attr.get_normal_item().args.outer_tokens(),\n-        None,\n-        false,\n-        false,\n-        Some(\"attribute\"),\n-    );\n+    let mut parser = Parser::new(sess, tts, None, false, false, Some(name));\n     let result = f(&mut parser)?;\n     if parser.token != token::Eof {\n         parser.unexpected()?;"}, {"sha": "00fd6b8a25bc3df5ec298423cb17789dd135de58", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -220,7 +220,7 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    pub(super) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n+    crate fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n         let lit = self.parse_lit()?;\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n \n@@ -238,25 +238,36 @@ impl<'a> Parser<'a> {\n \n     /// Parses `cfg_attr(pred, attr_item_list)` where `attr_item_list` is comma-delimited.\n     pub fn parse_cfg_attr(&mut self) -> PResult<'a, (ast::MetaItem, Vec<(ast::AttrItem, Span)>)> {\n-        self.expect(&token::OpenDelim(token::Paren))?;\n-\n         let cfg_predicate = self.parse_meta_item()?;\n         self.expect(&token::Comma)?;\n \n         // Presumably, the majority of the time there will only be one attr.\n         let mut expanded_attrs = Vec::with_capacity(1);\n-\n-        while !self.check(&token::CloseDelim(token::Paren)) {\n-            let lo = self.token.span.lo();\n+        while self.token.kind != token::Eof {\n+            let lo = self.token.span;\n             let item = self.parse_attr_item()?;\n-            expanded_attrs.push((item, self.prev_span.with_lo(lo)));\n-            self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Paren)])?;\n+            expanded_attrs.push((item, lo.to(self.prev_span)));\n+            if !self.eat(&token::Comma) {\n+                break;\n+            }\n         }\n \n-        self.expect(&token::CloseDelim(token::Paren))?;\n         Ok((cfg_predicate, expanded_attrs))\n     }\n \n+    /// Matches `COMMASEP(meta_item_inner)`.\n+    crate fn parse_meta_seq_top(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n+        // Presumably, the majority of the time there will only be one attr.\n+        let mut nmis = Vec::with_capacity(1);\n+        while self.token.kind != token::Eof {\n+            nmis.push(self.parse_meta_item_inner()?);\n+            if !self.eat(&token::Comma) {\n+                break;\n+            }\n+        }\n+        Ok(nmis)\n+    }\n+\n     /// Matches the following grammar (per RFC 1559).\n     ///\n     ///     meta_item : PATH ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;"}, {"sha": "c3e5b39635f03530c14a878cf80486c3bbee8db2", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1727,9 +1727,10 @@ impl<'a> Parser<'a> {\n     /// Checks if current token is one of tokens which cannot be nested like `kw::Enum`. In case\n     /// it is, we try to parse the item and report error about nested types.\n     fn recover_nested_adt_item(&mut self, keyword: Symbol) -> PResult<'a, bool> {\n-        if self.token.is_keyword(kw::Enum) ||\n+        if (self.token.is_keyword(kw::Enum) ||\n             self.token.is_keyword(kw::Struct) ||\n-            self.token.is_keyword(kw::Union)\n+            self.token.is_keyword(kw::Union))\n+           && self.look_ahead(1, |t| t.is_ident())\n         {\n             let kw_token = self.token.clone();\n             let kw_str = pprust::token_to_string(&kw_token);"}, {"sha": "5334fc485e7a63a26d8aba09e1a173f28ed16a82", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -3,7 +3,6 @@ use crate::maybe_whole;\n use rustc_errors::{PResult, Applicability, pluralize};\n use syntax::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n use syntax::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n-use syntax::ast::MacArgs;\n use syntax::ThinVec;\n use syntax::token::{self, Token};\n use syntax_pos::source_map::{Span, BytePos};\n@@ -109,42 +108,6 @@ impl<'a> Parser<'a> {\n         Ok(Path { segments, span: lo.to(self.prev_span) })\n     }\n \n-    /// Like `parse_path`, but also supports parsing `Word` meta items into paths for\n-    /// backwards-compatibility. This is used when parsing derive macro paths in `#[derive]`\n-    /// attributes.\n-    fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, Path> {\n-        let meta_ident = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtMeta(ref item) => match item.args {\n-                    MacArgs::Empty => Some(item.path.clone()),\n-                    _ => None,\n-                },\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-        if let Some(path) = meta_ident {\n-            self.bump();\n-            return Ok(path);\n-        }\n-        self.parse_path(style)\n-    }\n-\n-    /// Parse a list of paths inside `#[derive(path_0, ..., path_n)]`.\n-    pub fn parse_derive_paths(&mut self) -> PResult<'a, Vec<Path>> {\n-        self.expect(&token::OpenDelim(token::Paren))?;\n-        let mut list = Vec::new();\n-        while !self.eat(&token::CloseDelim(token::Paren)) {\n-            let path = self.parse_path_allowing_meta(PathStyle::Mod)?;\n-            list.push(path);\n-            if !self.eat(&token::Comma) {\n-                self.expect(&token::CloseDelim(token::Paren))?;\n-                break\n-            }\n-        }\n-        Ok(list)\n-    }\n-\n     pub(super) fn parse_path_segments(\n         &mut self,\n         segments: &mut Vec<PathSegment>,"}, {"sha": "94d3fe7b55167e65b69ffc5c9a5819c56106a0f1", "filename": "src/librustc_parse/validate_attr.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_parse%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fvalidate_attr.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,10 +1,13 @@\n //! Meta-syntax validation logic of attributes for post-expansion.\n \n+use crate::parse_in;\n+\n use rustc_errors::{PResult, Applicability};\n use rustc_feature::{AttributeTemplate, BUILTIN_ATTRIBUTE_MAP};\n-use syntax::ast::{self, Attribute, AttrKind, Ident, MacArgs, MetaItem, MetaItemKind};\n+use syntax::ast::{self, Attribute, AttrKind, Ident, MacArgs, MacDelimiter, MetaItem, MetaItemKind};\n use syntax::attr::mk_name_value_item_str;\n use syntax::early_buffered_lints::ILL_FORMED_ATTRIBUTE_INPUT;\n+use syntax::tokenstream::DelimSpan;\n use syntax::sess::ParseSess;\n use syntax_pos::{Symbol, sym};\n \n@@ -27,16 +30,45 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, MetaItem> {\n     Ok(match attr.kind {\n         AttrKind::Normal(ref item) => MetaItem {\n-            path: item.path.clone(),\n-            kind: super::parse_in_attr(sess, attr, |p| p.parse_meta_item_kind())?,\n             span: attr.span,\n+            path: item.path.clone(),\n+            kind: match &attr.get_normal_item().args {\n+                MacArgs::Empty => MetaItemKind::Word,\n+                MacArgs::Eq(_, t) => {\n+                    let v = parse_in(sess, t.clone(), \"name value\", |p| p.parse_unsuffixed_lit())?;\n+                    MetaItemKind::NameValue(v)\n+                }\n+                MacArgs::Delimited(dspan, delim, t) => {\n+                    check_meta_bad_delim(sess, *dspan, *delim, \"wrong meta list delimiters\");\n+                    let nmis = parse_in(sess, t.clone(), \"meta list\", |p| p.parse_meta_seq_top())?;\n+                    MetaItemKind::List(nmis)\n+                }\n+            }\n         },\n         AttrKind::DocComment(comment) => {\n             mk_name_value_item_str(Ident::new(sym::doc, attr.span), comment, attr.span)\n         }\n     })\n }\n \n+crate fn check_meta_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter, msg: &str) {\n+    if let ast::MacDelimiter::Parenthesis = delim {\n+        return;\n+    }\n+\n+    sess.span_diagnostic\n+        .struct_span_err(span.entire(), msg)\n+        .multipart_suggestion(\n+            \"the delimiters should be `(` and `)`\",\n+            vec![\n+                (span.open, \"(\".to_string()),\n+                (span.close, \")\".to_string()),\n+            ],\n+            Applicability::MachineApplicable,\n+        )\n+        .emit();\n+}\n+\n /// Checks that the given meta-item is compatible with this `AttributeTemplate`.\n fn is_attr_template_compatible(template: &AttributeTemplate, meta: &ast::MetaItemKind) -> bool {\n     match meta {"}, {"sha": "253fc5575c5bc1639f3010d82a2e078755c6978c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1284,6 +1284,10 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     augment_error(&mut err);\n                 }\n \n+                if let Some(expr) = expression {\n+                    fcx.emit_coerce_suggestions(&mut err, expr, found, expected);\n+                }\n+\n                 // Error possibly reported in `check_assign` so avoid emitting error again.\n                 err.emit_unless(expression.filter(|e| fcx.is_assign_to_bool(e, expected))\n                     .is_some());"}, {"sha": "16a55d2a4d318214c4c48ab95eb83d6f4c2693b5", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -15,6 +15,22 @@ use errors::{Applicability, DiagnosticBuilder};\n use super::method::probe;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+\n+    pub fn emit_coerce_suggestions(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr,\n+        expr_ty: Ty<'tcx>,\n+        expected: Ty<'tcx>\n+    ) {\n+        self.annotate_expected_due_to_let_ty(err, expr);\n+        self.suggest_compatible_variants(err, expr, expected, expr_ty);\n+        self.suggest_ref_or_into(err, expr, expected, expr_ty);\n+        self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n+        self.suggest_missing_await(err, expr, expected, expr_ty);\n+    }\n+\n+\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n@@ -137,11 +153,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return (expected, None)\n         }\n \n-        self.annotate_expected_due_to_let_ty(&mut err, expr);\n-        self.suggest_compatible_variants(&mut err, expr, expected, expr_ty);\n-        self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n-        self.suggest_boxing_when_appropriate(&mut err, expr, expected, expr_ty);\n-        self.suggest_missing_await(&mut err, expr, expected, expr_ty);\n+        self.emit_coerce_suggestions(&mut err, expr, expr_ty, expected);\n \n         (expected, Some(err))\n     }"}, {"sha": "b967c6e36e35ebc209ba4f7d73e69a42254e1655", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -336,6 +336,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                 (1, vec![param(0), param(0)], param(0)),\n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n+            \"float_to_int_approx_unchecked\" => (2, vec![ param(0) ], param(1)),\n \n             \"assume\" => (0, vec![tcx.types.bool], tcx.mk_unit()),\n             \"likely\" => (0, vec![tcx.types.bool], tcx.types.bool),"}, {"sha": "a956aba4f62b9896ff13b0f56e35b1b31eafa326", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -4584,8 +4584,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             pointing_at_return_type = self.suggest_missing_return_type(\n                 err, &fn_decl, expected, found, can_suggest);\n         }\n-        self.suggest_ref_or_into(err, expr, expected, found);\n-        self.suggest_boxing_when_appropriate(err, expr, expected, found);\n         pointing_at_return_type\n     }\n \n@@ -4957,15 +4955,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ty: expected,\n                 }));\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n+                debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);\n                 if self.infcx.predicate_may_hold(&obligation) {\n+                    debug!(\"suggest_missing_await: obligation held: {:?}\", obligation);\n                     if let Ok(code) = self.sess().source_map().span_to_snippet(sp) {\n                         err.span_suggestion(\n                             sp,\n                             \"consider using `.await` here\",\n                             format!(\"{}.await\", code),\n                             Applicability::MaybeIncorrect,\n                         );\n+                    } else {\n+                        debug!(\"suggest_missing_await: no snippet for {:?}\", sp);\n                     }\n+                } else {\n+                    debug!(\"suggest_missing_await: obligation did not hold: {:?}\", obligation)\n                 }\n             }\n         }"}, {"sha": "e90da69906009e9e01568eee6e60a3340d337ac7", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -143,10 +143,8 @@ unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n #[must_use = \"if unused the Mutex will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct MutexGuard<'a, T: ?Sized + 'a> {\n-    // funny underscores due to how Deref/DerefMut currently work (they\n-    // disregard field privacy).\n-    __lock: &'a Mutex<T>,\n-    __poison: poison::Guard,\n+    lock: &'a Mutex<T>,\n+    poison: poison::Guard,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -417,8 +415,8 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n     unsafe fn new(lock: &'mutex Mutex<T>) -> LockResult<MutexGuard<'mutex, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             MutexGuard {\n-                __lock: lock,\n-                __poison: guard,\n+                lock: lock,\n+                poison: guard,\n             }\n         })\n     }\n@@ -429,14 +427,14 @@ impl<T: ?Sized> Deref for MutexGuard<'_, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n-        unsafe { &*self.__lock.data.get() }\n+        unsafe { &*self.lock.data.get() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for MutexGuard<'_, T> {\n     fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.__lock.data.get() }\n+        unsafe { &mut *self.lock.data.get() }\n     }\n }\n \n@@ -445,8 +443,8 @@ impl<T: ?Sized> Drop for MutexGuard<'_, T> {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            self.__lock.poison.done(&self.__poison);\n-            self.__lock.inner.raw_unlock();\n+            self.lock.poison.done(&self.poison);\n+            self.lock.inner.raw_unlock();\n         }\n     }\n }\n@@ -466,11 +464,11 @@ impl<T: ?Sized + fmt::Display> fmt::Display for MutexGuard<'_, T> {\n }\n \n pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n-    &guard.__lock.inner\n+    &guard.lock.inner\n }\n \n pub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n-    &guard.__lock.poison\n+    &guard.lock.poison\n }\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]"}, {"sha": "c217291a42e4856de7192aa5bc2f0f52802577a3", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -87,7 +87,7 @@ unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n #[must_use = \"if unused the RwLock will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n-    __lock: &'a RwLock<T>,\n+    lock: &'a RwLock<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -108,8 +108,8 @@ unsafe impl<T: ?Sized + Sync> Sync for RwLockReadGuard<'_, T> {}\n #[must_use = \"if unused the RwLock will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n-    __lock: &'a RwLock<T>,\n-    __poison: poison::Guard,\n+    lock: &'a RwLock<T>,\n+    poison: poison::Guard,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -465,7 +465,7 @@ impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n                   -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n             RwLockReadGuard {\n-                __lock: lock,\n+                lock: lock,\n             }\n         })\n     }\n@@ -476,8 +476,8 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n                   -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             RwLockWriteGuard {\n-                __lock: lock,\n-                __poison: guard,\n+                lock: lock,\n+                poison: guard,\n             }\n         })\n     }\n@@ -487,7 +487,7 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n impl<T: fmt::Debug> fmt::Debug for RwLockReadGuard<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"RwLockReadGuard\")\n-            .field(\"lock\", &self.__lock)\n+            .field(\"lock\", &self.lock)\n             .finish()\n     }\n }\n@@ -503,7 +503,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RwLockReadGuard<'_, T> {\n impl<T: fmt::Debug> fmt::Debug for RwLockWriteGuard<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"RwLockWriteGuard\")\n-            .field(\"lock\", &self.__lock)\n+            .field(\"lock\", &self.lock)\n             .finish()\n     }\n }\n@@ -520,7 +520,7 @@ impl<T: ?Sized> Deref for RwLockReadGuard<'_, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n-        unsafe { &*self.__lock.data.get() }\n+        unsafe { &*self.lock.data.get() }\n     }\n }\n \n@@ -529,29 +529,29 @@ impl<T: ?Sized> Deref for RwLockWriteGuard<'_, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n-        unsafe { &*self.__lock.data.get() }\n+        unsafe { &*self.lock.data.get() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for RwLockWriteGuard<'_, T> {\n     fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.__lock.data.get() }\n+        unsafe { &mut *self.lock.data.get() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for RwLockReadGuard<'_, T> {\n     fn drop(&mut self) {\n-        unsafe { self.__lock.inner.read_unlock(); }\n+        unsafe { self.lock.inner.read_unlock(); }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for RwLockWriteGuard<'_, T> {\n     fn drop(&mut self) {\n-        self.__lock.poison.done(&self.__poison);\n-        unsafe { self.__lock.inner.write_unlock(); }\n+        self.lock.poison.done(&self.poison);\n+        unsafe { self.lock.inner.write_unlock(); }\n     }\n }\n "}, {"sha": "520488c658676bfc07e179951269d44458e4f0a2", "filename": "src/libsyntax_expand/proc_macro.rs", "status": "modified", "additions": 62, "deletions": 25, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibsyntax_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibsyntax_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fproc_macro.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,7 +1,7 @@\n use crate::base::{self, *};\n use crate::proc_macro_server;\n \n-use syntax::ast::{self, ItemKind, MacArgs};\n+use syntax::ast::{self, ItemKind, MetaItemKind, NestedMetaItem};\n use syntax::errors::{Applicability, FatalError};\n use syntax::symbol::sym;\n use syntax::token;\n@@ -171,34 +171,71 @@ crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>)\n         if !attr.has_name(sym::derive) {\n             return true;\n         }\n-        if !attr.is_meta_item_list() {\n-            cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n-                .span_suggestion(\n-                    attr.span,\n-                    \"missing traits to be derived\",\n-                    \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n-                    Applicability::HasPlaceholders,\n-                ).emit();\n-            return false;\n-        }\n \n-        let parse_derive_paths = |attr: &ast::Attribute| {\n-            if let MacArgs::Empty = attr.get_normal_item().args {\n-                return Ok(Vec::new());\n+        // 1) First let's ensure that it's a meta item.\n+        let nmis = match attr.meta_item_list() {\n+            None => {\n+                cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n+                    .span_suggestion(\n+                        attr.span,\n+                        \"missing traits to be derived\",\n+                        \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n+                        Applicability::HasPlaceholders,\n+                    )\n+                    .emit();\n+                return false;\n             }\n-            rustc_parse::parse_in_attr(cx.parse_sess, attr, |p| p.parse_derive_paths())\n+            Some(x) => x,\n         };\n \n-        match parse_derive_paths(attr) {\n-            Ok(traits) => {\n-                result.extend(traits);\n-                true\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                false\n-            }\n-        }\n+        let mut error_reported_filter_map = false;\n+        let mut error_reported_map = false;\n+        let traits = nmis\n+            .into_iter()\n+            // 2) Moreover, let's ensure we have a path and not `#[derive(\"foo\")]`.\n+            .filter_map(|nmi| match nmi {\n+                NestedMetaItem::Literal(lit) => {\n+                    error_reported_filter_map = true;\n+                    cx.struct_span_err(lit.span, \"expected path to a trait, found literal\")\n+                        .help(\"for example, write `#[derive(Debug)]` for `Debug`\")\n+                        .emit();\n+                    None\n+                }\n+                NestedMetaItem::MetaItem(mi) => Some(mi),\n+            })\n+            // 3) Finally, we only accept `#[derive($path_0, $path_1, ..)]`\n+            // but not e.g. `#[derive($path_0 = \"value\", $path_1(abc))]`.\n+            // In this case we can still at least determine that the user\n+            // wanted this trait to be derived, so let's keep it.\n+            .map(|mi| {\n+                let mut traits_dont_accept = |title, action| {\n+                    error_reported_map = true;\n+                    let sp = mi.span.with_lo(mi.path.span.hi());\n+                    cx.struct_span_err(sp, title)\n+                        .span_suggestion(\n+                            sp,\n+                            action,\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                };\n+                match &mi.kind {\n+                    MetaItemKind::List(..) => traits_dont_accept(\n+                        \"traits in `#[derive(...)]` don't accept arguments\",\n+                        \"remove the arguments\",\n+                    ),\n+                    MetaItemKind::NameValue(..) => traits_dont_accept(\n+                        \"traits in `#[derive(...)]` don't accept values\",\n+                        \"remove the value\",\n+                    ),\n+                    MetaItemKind::Word => {}\n+                }\n+                mi.path\n+            });\n+\n+        result.extend(traits);\n+        !error_reported_filter_map && !error_reported_map\n     });\n     result\n }"}, {"sha": "e8f7a125739ac07cb190bb5f0dd4d3ccd219aaae", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -213,6 +213,7 @@ symbols! {\n         const_indexing,\n         const_in_array_repeat_expressions,\n         const_let,\n+        const_mut_refs,\n         const_panic,\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,"}, {"sha": "5d26059644d17a04dd5832cd2ff4bcdaa98c1dac", "filename": "src/test/compile-fail/consts/const-fn-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fcompile-fail%2Fconsts%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fcompile-fail%2Fconsts%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsts%2Fconst-fn-error.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -6,7 +6,7 @@ const fn f(x: usize) -> usize {\n     let mut sum = 0;\n     for i in 0..x {\n         //~^ ERROR E0015\n-        //~| ERROR E0017\n+        //~| ERROR E0658\n         //~| ERROR E0080\n         //~| ERROR E0744\n         //~| ERROR E0019"}, {"sha": "1ec59d906206eada93ce9282dfd81e12afef9517", "filename": "src/test/ui/async-await/suggest-missing-await.fixed", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -16,4 +16,15 @@ async fn suggest_await_in_async_fn() {\n     //~| SUGGESTION x.await\n }\n \n+async fn dummy() {}\n+\n+#[allow(unused)]\n+async fn suggest_await_in_async_fn_return() {\n+    dummy().await;\n+    //~^ ERROR mismatched types [E0308]\n+    //~| HELP try adding a semicolon\n+    //~| HELP consider using `.await` here\n+    //~| SUGGESTION dummy().await\n+}\n+\n fn main() {}"}, {"sha": "70cc1f1d5a2c6078da0f8c4014b9a2e1eec4bd70", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -16,4 +16,15 @@ async fn suggest_await_in_async_fn() {\n     //~| SUGGESTION x.await\n }\n \n+async fn dummy() {}\n+\n+#[allow(unused)]\n+async fn suggest_await_in_async_fn_return() {\n+    dummy()\n+    //~^ ERROR mismatched types [E0308]\n+    //~| HELP try adding a semicolon\n+    //~| HELP consider using `.await` here\n+    //~| SUGGESTION dummy().await\n+}\n+\n fn main() {}"}, {"sha": "7ab024434b2bf86250d4c2db32263b20e8259be3", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -10,6 +10,23 @@ LL |     take_u32(x)\n    = note:     expected type `u32`\n            found opaque type `impl std::future::Future`\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-missing-await.rs:23:5\n+   |\n+LL |     dummy()\n+   |     ^^^^^^^ expected `()`, found opaque type\n+   |\n+   = note: expected unit type `()`\n+            found opaque type `impl std::future::Future`\n+help: try adding a semicolon\n+   |\n+LL |     dummy();\n+   |            ^\n+help: consider using `.await` here\n+   |\n+LL |     dummy().await\n+   |\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "39da824ede57c256ec7eee6ca20bc365597264cf", "filename": "src/test/ui/check-static-immutable-mut-slices.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fcheck-static-immutable-mut-slices.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fcheck-static-immutable-mut-slices.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-immutable-mut-slices.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,9 +1,12 @@\n-error[E0017]: references in statics may only refer to immutable values\n+error[E0658]: references in statics may only refer to immutable values\n   --> $DIR/check-static-immutable-mut-slices.rs:3:37\n    |\n LL | static TEST: &'static mut [isize] = &mut [];\n    |                                     ^^^^^^^ statics require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0017`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "8ca31c118369c23f9db2f495676bcb647f5f61ae", "filename": "src/test/ui/conditional-compilation/cfg-attr-parse.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,11 +1,11 @@\n // Parse `cfg_attr` with varying numbers of attributes and trailing commas\n \n // Completely empty `cfg_attr` input\n-#[cfg_attr()] //~ error: expected identifier, found `)`\n+#[cfg_attr()] //~ error: malformed `cfg_attr` attribute input\n struct NoConfigurationPredicate;\n \n // Zero attributes, zero trailing comma (comma manatory here)\n-#[cfg_attr(all())] //~ error: expected `,`, found `)`\n+#[cfg_attr(all())] //~ error: expected `,`, found end of `cfg_attr`\n struct A0C0;\n \n // Zero attributes, one trailing comma\n@@ -40,4 +40,16 @@ struct A2C1;\n #[cfg_attr(all(), must_use, deprecated,,)] //~ ERROR expected identifier\n struct A2C2;\n \n+// Wrong delimiter `[`\n+#[cfg_attr[all(),,]]\n+//~^ ERROR wrong `cfg_attr` delimiters\n+//~| ERROR expected identifier, found `,`\n+struct BracketZero;\n+\n+// Wrong delimiter `{`\n+#[cfg_attr{all(),,}]\n+//~^ ERROR wrong `cfg_attr` delimiters\n+//~| ERROR expected identifier, found `,`\n+struct BraceZero;\n+\n fn main() {}"}, {"sha": "3a590d3282d46b04bfba865e320b69270e4b45d8", "filename": "src/test/ui/conditional-compilation/cfg-attr-parse.stderr", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,32 +1,86 @@\n-error: expected identifier, found `)`\n-  --> $DIR/cfg-attr-parse.rs:4:12\n+error: malformed `cfg_attr` attribute input\n+  --> $DIR/cfg-attr-parse.rs:4:1\n    |\n LL | #[cfg_attr()]\n-   |            ^ expected identifier\n+   | ^^^^^^^^^^^^^ help: missing condition and attribute: `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   |\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n-error: expected `,`, found `)`\n+error: expected `,`, found end of `cfg_attr` input\n   --> $DIR/cfg-attr-parse.rs:8:17\n    |\n LL | #[cfg_attr(all())]\n    |                 ^ expected `,`\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: expected identifier, found `,`\n   --> $DIR/cfg-attr-parse.rs:16:18\n    |\n LL | #[cfg_attr(all(),,)]\n    |                  ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: expected identifier, found `,`\n   --> $DIR/cfg-attr-parse.rs:28:28\n    |\n LL | #[cfg_attr(all(), must_use,,)]\n    |                            ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: expected identifier, found `,`\n   --> $DIR/cfg-attr-parse.rs:40:40\n    |\n LL | #[cfg_attr(all(), must_use, deprecated,,)]\n    |                                        ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n+\n+error: wrong `cfg_attr` delimiters\n+  --> $DIR/cfg-attr-parse.rs:44:11\n+   |\n+LL | #[cfg_attr[all(),,]]\n+   |           ^^^^^^^^^\n+   |\n+help: the delimiters should be `(` and `)`\n+   |\n+LL | #[cfg_attr(all(),,)]\n+   |           ^       ^\n+\n+error: expected identifier, found `,`\n+  --> $DIR/cfg-attr-parse.rs:44:18\n+   |\n+LL | #[cfg_attr[all(),,]]\n+   |                  ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n+\n+error: wrong `cfg_attr` delimiters\n+  --> $DIR/cfg-attr-parse.rs:50:11\n+   |\n+LL | #[cfg_attr{all(),,}]\n+   |           ^^^^^^^^^\n+   |\n+help: the delimiters should be `(` and `)`\n+   |\n+LL | #[cfg_attr(all(),,)]\n+   |           ^       ^\n+\n+error: expected identifier, found `,`\n+  --> $DIR/cfg-attr-parse.rs:50:18\n+   |\n+LL | #[cfg_attr{all(),,}]\n+   |                  ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "54b35073340fd3ca80582a816ed5f023e4689472", "filename": "src/test/ui/consts/const-eval/issue-65394.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,8 +1,11 @@\n-error[E0017]: references in constants may only refer to immutable values\n+error[E0658]: references in constants may only refer to immutable values\n   --> $DIR/issue-65394.rs:8:13\n    |\n LL |     let r = &mut x;\n    |             ^^^^^^ constants require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/issue-65394.rs:7:9\n@@ -12,5 +15,5 @@ LL |     let mut x = Vec::<i32>::new();\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0017, E0493.\n-For more information about an error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0493, E0658.\n+For more information about an error, try `rustc --explain E0493`."}, {"sha": "0809c77c1b604514d0451fcfc232f99309c699f9", "filename": "src/test/ui/consts/const-multi-ref.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,8 +1,11 @@\n-error[E0017]: references in constants may only refer to immutable values\n+error[E0658]: references in constants may only refer to immutable values\n   --> $DIR/const-multi-ref.rs:6:13\n    |\n LL |     let p = &mut a;\n    |             ^^^^^^ constants require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n   --> $DIR/const-multi-ref.rs:16:13\n@@ -12,5 +15,5 @@ LL |     let p = &a;\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0017, E0492.\n-For more information about an error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0492, E0658.\n+For more information about an error, try `rustc --explain E0492`."}, {"sha": "99006a20b1bcba56dfe6275b847724ea47185cc1", "filename": "src/test/ui/consts/const-mut-refs/const_mut_refs.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,36 @@\n+// run-pass\n+\n+#![feature(const_mut_refs)]\n+\n+struct Foo {\n+    x: usize\n+}\n+\n+const fn foo() -> Foo {\n+    Foo { x: 0 }\n+}\n+\n+impl Foo {\n+    const fn bar(&mut self) -> usize {\n+        self.x = 1;\n+        self.x\n+    }\n+\n+}\n+\n+const fn baz(foo: &mut Foo) -> usize {\n+    let x = &mut foo.x;\n+    *x = 2;\n+    *x\n+}\n+\n+const fn bazz(foo: &mut Foo) -> usize {\n+    foo.x = 3;\n+    foo.x\n+}\n+\n+fn main() {\n+    let _: [(); foo().bar()] = [(); 1];\n+    let _: [(); baz(&mut foo())] = [(); 2];\n+    let _: [(); bazz(&mut foo())] = [(); 3];\n+}"}, {"sha": "2207599815ee8056198f2a3bbdcb03ffa93bab66", "filename": "src/test/ui/consts/const-mut-refs/feature-gate-const_mut_refs.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Ffeature-gate-const_mut_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Ffeature-gate-const_mut_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Ffeature-gate-const_mut_refs.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    foo(&mut 5);\n+}\n+\n+const fn foo(x: &mut i32) -> i32 { //~ ERROR mutable references in const fn are unstable\n+    *x + 1\n+}"}, {"sha": "4fae119f026045b0a2674cdc4d50075fa70e8231", "filename": "src/test/ui/consts/const-mut-refs/feature-gate-const_mut_refs.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Ffeature-gate-const_mut_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Ffeature-gate-const_mut_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Ffeature-gate-const_mut_refs.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,12 @@\n+error[E0723]: mutable references in const fn are unstable\n+  --> $DIR/feature-gate-const_mut_refs.rs:5:14\n+   |\n+LL | const fn foo(x: &mut i32) -> i32 {\n+   |              ^\n+   |\n+   = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "7852874944b22c8bce3a9cab994c41af395c4cc6", "filename": "src/test/ui/consts/const_let_assign3.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -4,17 +4,23 @@ error[E0019]: constant function contains unimplemented expression type\n LL |         self.state = x;\n    |         ^^^^^^^^^^^^^^\n \n-error[E0017]: references in constants may only refer to immutable values\n+error[E0658]: references in constants may only refer to immutable values\n   --> $DIR/const_let_assign3.rs:16:5\n    |\n LL |     s.foo(3);\n    |     ^ constants require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0017]: references in constants may only refer to immutable values\n+error[E0658]: references in constants may only refer to immutable values\n   --> $DIR/const_let_assign3.rs:22:13\n    |\n LL |     let y = &mut x;\n    |             ^^^^^^ constants require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0019]: constant contains unimplemented expression type\n   --> $DIR/const_let_assign3.rs:24:5\n@@ -24,5 +30,5 @@ LL |     *y = 42;\n \n error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0017, E0019.\n-For more information about an error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0019, E0658.\n+For more information about an error, try `rustc --explain E0019`."}, {"sha": "972f59549ea7415806e1ce8e64098e9a9adbb7c6", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: -Zunleash-the-miri-inside-of-you\n \n #![feature(const_raw_ptr_deref)]\n+#![feature(const_mut_refs)]\n #![deny(const_err)]\n \n use std::cell::UnsafeCell;\n@@ -12,9 +13,7 @@ const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n const MUTATING_BEHIND_RAW: () = {\n     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n     unsafe {\n-        *MUTABLE_BEHIND_RAW = 99 //~ WARN skipping const checks\n-        //~^ ERROR any use of this value will cause an error\n-        //~^^ tried to modify constant memory\n+        *MUTABLE_BEHIND_RAW = 99 //~ ERROR any use of this value will cause an error\n     }\n };\n "}, {"sha": "9daca765c7cd0760cd698778ba1a4c40ecea7bf2", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,30 +1,23 @@\n warning: skipping const checks\n-  --> $DIR/mutable_const.rs:9:38\n+  --> $DIR/mutable_const.rs:10:38\n    |\n LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n \n-warning: skipping const checks\n-  --> $DIR/mutable_const.rs:15:9\n-   |\n-LL |         *MUTABLE_BEHIND_RAW = 99\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error: any use of this value will cause an error\n-  --> $DIR/mutable_const.rs:15:9\n+  --> $DIR/mutable_const.rs:16:9\n    |\n LL | / const MUTATING_BEHIND_RAW: () = {\n LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n LL | |     unsafe {\n LL | |         *MUTABLE_BEHIND_RAW = 99\n    | |         ^^^^^^^^^^^^^^^^^^^^^^^^ tried to modify constant memory\n-...  |\n LL | |     }\n LL | | };\n    | |__-\n    |\n note: lint level defined here\n-  --> $DIR/mutable_const.rs:4:9\n+  --> $DIR/mutable_const.rs:5:9\n    |\n LL | #![deny(const_err)]\n    |         ^^^^^^^^^"}, {"sha": "fe3c4ee70f2a21ee9b81282bd32ed05c8d05a442", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,20 +1,22 @@\n // compile-flags: -Zunleash-the-miri-inside-of-you\n+#![feature(const_mut_refs)]\n #![allow(const_err)]\n \n use std::cell::UnsafeCell;\n \n // a test demonstrating what things we could allow with a smarter const qualification\n \n+// this is fine because is not possible to mutate through an immutable reference.\n static FOO: &&mut u32 = &&mut 42;\n-//~^ WARN: skipping const checks\n \n+// this is fine because accessing an immutable static `BAR` is equivalent to accessing `*&BAR`\n+// which puts the mutable reference behind an immutable one.\n static BAR: &mut () = &mut ();\n-//~^ WARN: skipping const checks\n \n struct Foo<T>(T);\n \n+// this is fine for the same reason as `BAR`.\n static BOO: &mut Foo<()> = &mut Foo(());\n-//~^ WARN: skipping const checks\n \n struct Meh {\n     x: &'static UnsafeCell<i32>,\n@@ -27,8 +29,8 @@ static MEH: Meh = Meh {\n     //~^ WARN: skipping const checks\n };\n \n+// this is fine for the same reason as `BAR`.\n static OH_YES: &mut i32 = &mut 42;\n-//~^ WARN: skipping const checks\n \n fn main() {\n     unsafe {"}, {"sha": "3e1300c63c17d6a737ecea4fd9806b2d5c6fb6bb", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.stderr", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,35 +1,11 @@\n warning: skipping const checks\n-  --> $DIR/mutable_references.rs:8:26\n-   |\n-LL | static FOO: &&mut u32 = &&mut 42;\n-   |                          ^^^^^^^\n-\n-warning: skipping const checks\n-  --> $DIR/mutable_references.rs:11:23\n-   |\n-LL | static BAR: &mut () = &mut ();\n-   |                       ^^^^^^^\n-\n-warning: skipping const checks\n-  --> $DIR/mutable_references.rs:16:28\n-   |\n-LL | static BOO: &mut Foo<()> = &mut Foo(());\n-   |                            ^^^^^^^^^^^^\n-\n-warning: skipping const checks\n-  --> $DIR/mutable_references.rs:26:8\n+  --> $DIR/mutable_references.rs:28:8\n    |\n LL |     x: &UnsafeCell::new(42),\n    |        ^^^^^^^^^^^^^^^^^^^^\n \n-warning: skipping const checks\n-  --> $DIR/mutable_references.rs:30:27\n-   |\n-LL | static OH_YES: &mut i32 = &mut 42;\n-   |                           ^^^^^^^\n-\n error[E0594]: cannot assign to `*OH_YES`, as `OH_YES` is an immutable static item\n-  --> $DIR/mutable_references.rs:37:5\n+  --> $DIR/mutable_references.rs:39:5\n    |\n LL |     *OH_YES = 99;\n    |     ^^^^^^^^^^^^ cannot assign"}, {"sha": "821c501c9fcc5e4cec5cc3a73283e58bd45a1352", "filename": "src/test/ui/consts/miri_unleashed/read_from_static.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fread_from_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fread_from_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fread_from_static.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+#![feature(const_mut_refs)]\n+#![allow(const_err)]\n+\n+static OH_YES: &mut i32 = &mut 42;\n+\n+fn main() {\n+    // Make sure `OH_YES` can be read.\n+    assert_eq!(*OH_YES, 42);\n+}"}, {"sha": "23538777c9df3698191727f8504f68b016f1b220", "filename": "src/test/ui/consts/projection_qualif.mut_refs.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.mut_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.mut_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.mut_refs.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: dereferencing raw pointers in constants is unstable\n+  --> $DIR/projection_qualif.rs:11:18\n+   |\n+LL |         unsafe { *b = 5; }\n+   |                  ^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/51911\n+   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "cfe8e7f03d5e45e8445ff79094bf79610b71de1d", "filename": "src/test/ui/consts/projection_qualif.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,11 +1,15 @@\n+// revisions: stock mut_refs\n+\n+#![cfg_attr(mut_refs, feature(const_mut_refs))]\n+\n use std::cell::Cell;\n \n const FOO: &u32 = {\n     let mut a = 42;\n     {\n-        let b: *mut u32 = &mut a; //~ ERROR may only refer to immutable values\n+        let b: *mut u32 = &mut a; //[stock]~ ERROR may only refer to immutable values\n         unsafe { *b = 5; } //~ ERROR dereferencing raw pointers in constants\n-        //~^ contains unimplemented expression\n+        //[stock]~^ contains unimplemented expression\n     }\n     &{a}\n };"}, {"sha": "472d2607453d066f9fa1488027588d0dea597af3", "filename": "src/test/ui/consts/projection_qualif.stock.stderr", "status": "renamed", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stock.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,11 +1,14 @@\n-error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/projection_qualif.rs:6:27\n+error[E0658]: references in constants may only refer to immutable values\n+  --> $DIR/projection_qualif.rs:10:27\n    |\n LL |         let b: *mut u32 = &mut a;\n    |                           ^^^^^^ constants require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0658]: dereferencing raw pointers in constants is unstable\n-  --> $DIR/projection_qualif.rs:7:18\n+  --> $DIR/projection_qualif.rs:11:18\n    |\n LL |         unsafe { *b = 5; }\n    |                  ^^^^^^\n@@ -14,12 +17,12 @@ LL |         unsafe { *b = 5; }\n    = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/projection_qualif.rs:7:18\n+  --> $DIR/projection_qualif.rs:11:18\n    |\n LL |         unsafe { *b = 5; }\n    |                  ^^^^^^\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0017, E0019, E0658.\n-For more information about an error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0019, E0658.\n+For more information about an error, try `rustc --explain E0019`.", "previous_filename": "src/test/ui/consts/projection_qualif.stderr"}, {"sha": "b43fbc86f99f2c3e6f47107c3f33dcf6c0b4ba5c", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.mut_refs.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/static_mut_containing_mut_ref2.rs:7:45\n+   |\n+LL | pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ tried to modify a static's initial value from another static's initializer\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "74162fbd54b046537817eeb17a99b8e716632077", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,7 +1,12 @@\n+// revisions: stock mut_refs\n+\n+#![cfg_attr(mut_refs, feature(const_mut_refs))]\n+\n static mut STDERR_BUFFER_SPACE: u8 = 0;\n \n pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n-//~^ ERROR references in statics may only refer to immutable values\n-//~| ERROR static contains unimplemented expression type\n+//[mut_refs]~^ ERROR could not evaluate static initializer\n+//[stock]~^^ ERROR references in statics may only refer to immutable values\n+//[stock]~| ERROR static contains unimplemented expression type\n \n fn main() {}"}, {"sha": "430cef94dc3cb88e90cdc5d5248221fadbf9c29f", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.stock.stderr", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.stock.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,16 +1,19 @@\n-error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/static_mut_containing_mut_ref2.rs:3:46\n+error[E0658]: references in statics may only refer to immutable values\n+  --> $DIR/static_mut_containing_mut_ref2.rs:7:46\n    |\n LL | pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0019]: static contains unimplemented expression type\n-  --> $DIR/static_mut_containing_mut_ref2.rs:3:45\n+  --> $DIR/static_mut_containing_mut_ref2.rs:7:45\n    |\n LL | pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0017, E0019.\n-For more information about an error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0019, E0658.\n+For more information about an error, try `rustc --explain E0019`.", "previous_filename": "src/test/ui/consts/static_mut_containing_mut_ref2.stderr"}, {"sha": "048913e25cd96b9205de9bd1a72a1c55f96ad30f", "filename": "src/test/ui/enum/union-in-enum.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fenum%2Funion-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fenum%2Funion-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Funion-in-enum.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,13 @@\n+// This test checks that the union keyword\n+// is accepted as the name of an enum variant\n+// when not followed by an identifier\n+// This special case exists because `union` is a contextual keyword.\n+\n+#![allow(warnings)]\n+\n+// check-pass\n+\n+enum A { union }\n+enum B { union {} }\n+enum C { union() }\n+fn main(){}"}, {"sha": "64be41170d0c897156211e5d7fc5c1b8b4f9959c", "filename": "src/test/ui/error-codes/E0017.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -2,10 +2,10 @@ static X: i32 = 1;\n const C: i32 = 2;\n static mut M: i32 = 3;\n \n-const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n-static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n+const CR: &'static mut i32 = &mut C; //~ ERROR E0658\n+static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0658\n                                               //~| ERROR E0019\n                                               //~| ERROR cannot borrow\n-static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n-static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M }; //~ ERROR E0017\n+static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0658\n+static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M }; //~ ERROR E0658\n fn main() {}"}, {"sha": "9a87195a9d05efb9b4df524cd8c0ed2d26d278a8", "filename": "src/test/ui/error-codes/E0017.stderr", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,40 +1,52 @@\n-error[E0017]: references in constants may only refer to immutable values\n+error[E0658]: references in constants may only refer to immutable values\n   --> $DIR/E0017.rs:5:30\n    |\n LL | const CR: &'static mut i32 = &mut C;\n    |                              ^^^^^^ constants require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0019]: static contains unimplemented expression type\n   --> $DIR/E0017.rs:6:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X;\n    |                                       ^^^^^^\n \n-error[E0017]: references in statics may only refer to immutable values\n+error[E0658]: references in statics may only refer to immutable values\n   --> $DIR/E0017.rs:6:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X;\n    |                                       ^^^^^^ statics require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0596]: cannot borrow immutable static item `X` as mutable\n   --> $DIR/E0017.rs:6:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X;\n    |                                       ^^^^^^ cannot borrow as mutable\n \n-error[E0017]: references in statics may only refer to immutable values\n+error[E0658]: references in statics may only refer to immutable values\n   --> $DIR/E0017.rs:9:38\n    |\n LL | static CONST_REF: &'static mut i32 = &mut C;\n    |                                      ^^^^^^ statics require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0017]: references in statics may only refer to immutable values\n+error[E0658]: references in statics may only refer to immutable values\n   --> $DIR/E0017.rs:10:52\n    |\n LL | static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M };\n    |                                                    ^^^^^^ statics require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0017, E0019, E0596.\n-For more information about an error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0019, E0596, E0658.\n+For more information about an error, try `rustc --explain E0019`."}, {"sha": "5954e3490b06c770766b596604225d9798b05d14", "filename": "src/test/ui/error-codes/E0388.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,10 @@\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+const CR: &'static mut i32 = &mut C; //~ ERROR E0658\n+static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0658\n+                                              //~| ERROR cannot borrow\n+                                              //~| ERROR E0019\n+static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0658\n+\n+fn main() {}"}, {"sha": "986307d3f123ff0f128138c499be1c46711ca103", "filename": "src/test/ui/error-codes/E0388.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,43 @@\n+error[E0658]: references in constants may only refer to immutable values\n+  --> $DIR/E0388.rs:4:30\n+   |\n+LL | const CR: &'static mut i32 = &mut C;\n+   |                              ^^^^^^ constants require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error[E0019]: static contains unimplemented expression type\n+  --> $DIR/E0388.rs:5:39\n+   |\n+LL | static STATIC_REF: &'static mut i32 = &mut X;\n+   |                                       ^^^^^^\n+\n+error[E0658]: references in statics may only refer to immutable values\n+  --> $DIR/E0388.rs:5:39\n+   |\n+LL | static STATIC_REF: &'static mut i32 = &mut X;\n+   |                                       ^^^^^^ statics require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error[E0596]: cannot borrow immutable static item `X` as mutable\n+  --> $DIR/E0388.rs:5:39\n+   |\n+LL | static STATIC_REF: &'static mut i32 = &mut X;\n+   |                                       ^^^^^^ cannot borrow as mutable\n+\n+error[E0658]: references in statics may only refer to immutable values\n+  --> $DIR/E0388.rs:8:38\n+   |\n+LL | static CONST_REF: &'static mut i32 = &mut C;\n+   |                                      ^^^^^^ statics require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0019, E0596, E0658.\n+For more information about an error, try `rustc --explain E0019`."}, {"sha": "ca61fb0c171febdbd67445dac6811c3d94f2e7c1", "filename": "src/test/ui/fully-qualified-type/fully-qualified-type-name4.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name4.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -4,7 +4,10 @@ error[E0308]: mismatched types\n LL | fn bar(x: usize) -> Option<usize> {\n    |                     ------------- expected `std::option::Option<usize>` because of return type\n LL |     return x;\n-   |            ^ expected enum `std::option::Option`, found `usize`\n+   |            ^\n+   |            |\n+   |            expected enum `std::option::Option`, found `usize`\n+   |            help: try using a variant of the expected enum: `Some(x)`\n    |\n    = note: expected enum `std::option::Option<usize>`\n               found type `usize`"}, {"sha": "7e4a62ac96957482ed612afbb68297f1e44a69eb", "filename": "src/test/ui/issues/issue-17718-const-bad-values.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,22 +1,28 @@\n-error[E0017]: references in constants may only refer to immutable values\n+error[E0658]: references in constants may only refer to immutable values\n   --> $DIR/issue-17718-const-bad-values.rs:1:34\n    |\n LL | const C1: &'static mut [usize] = &mut [];\n    |                                  ^^^^^^^ constants require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0013]: constants cannot refer to statics, use a constant instead\n   --> $DIR/issue-17718-const-bad-values.rs:5:46\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n    |                                              ^\n \n-error[E0017]: references in constants may only refer to immutable values\n+error[E0658]: references in constants may only refer to immutable values\n   --> $DIR/issue-17718-const-bad-values.rs:5:41\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n    |                                         ^^^^^^ constants require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0013, E0017.\n+Some errors have detailed explanations: E0013, E0658.\n For more information about an error, try `rustc --explain E0013`."}, {"sha": "e1967eb7655425e642cfaaf60efc7350081810f0", "filename": "src/test/ui/issues/issue-46604.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-46604.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-46604.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46604.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,4 +1,4 @@\n-static buf: &mut [u8] = &mut [1u8,2,3,4,5,7];   //~ ERROR E0017\n+static buf: &mut [u8] = &mut [1u8,2,3,4,5,7];   //~ ERROR E0658\n fn write<T: AsRef<[u8]>>(buffer: T) { }\n \n fn main() {"}, {"sha": "32c7ecbf72e951ca5c299d0fc923eb7f42081e3a", "filename": "src/test/ui/issues/issue-46604.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-46604.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-46604.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46604.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,8 +1,11 @@\n-error[E0017]: references in statics may only refer to immutable values\n+error[E0658]: references in statics may only refer to immutable values\n   --> $DIR/issue-46604.rs:1:25\n    |\n LL | static buf: &mut [u8] = &mut [1u8,2,3,4,5,7];\n    |                         ^^^^^^^^^^^^^^^^^^^^ statics require immutable values\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/57349\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0594]: cannot assign to `buf[_]`, as `buf` is an immutable static item\n   --> $DIR/issue-46604.rs:6:5\n@@ -12,5 +15,5 @@ LL |     buf[0]=2;\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0017, E0594.\n-For more information about an error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0594, E0658.\n+For more information about an error, try `rustc --explain E0594`."}, {"sha": "9ca983df30af51392b22145e8f56abc28e9c550e", "filename": "src/test/ui/issues/issue-51632-try-desugar-incompatible-types.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-51632-try-desugar-incompatible-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-51632-try-desugar-incompatible-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51632-try-desugar-incompatible-types.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -2,13 +2,18 @@ error[E0308]: try expression alternatives have incompatible types\n   --> $DIR/issue-51632-try-desugar-incompatible-types.rs:8:5\n    |\n LL |     missing_discourses()?\n-   |     ^^^^^^^^^^^^^^^^^^^^-\n-   |     |                   |\n-   |     |                   help: try removing this `?`\n-   |     expected enum `std::result::Result`, found `isize`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found `isize`\n    |\n    = note: expected enum `std::result::Result<isize, ()>`\n               found type `isize`\n+help: try removing this `?`\n+   |\n+LL |     missing_discourses()\n+   |                        --\n+help: try using a variant of the expected enum\n+   |\n+LL |     Ok(missing_discourses()?)\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "d6df0592be32c7edfe0165c94189bac43ffe1932", "filename": "src/test/ui/issues/issue-59756.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-59756.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-59756.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59756.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,4 +1,8 @@\n // run-rustfix\n+// ignore-test\n+//\n+// FIXME: Re-enable this test once we support choosing\n+// between multiple mutually exclusive suggestions for the same span\n \n #![allow(warnings)]\n "}, {"sha": "9066e57aabfe5eefafb8d89b2261c8921805bc70", "filename": "src/test/ui/issues/issue-59756.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-59756.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fissues%2Fissue-59756.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59756.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -2,13 +2,18 @@ error[E0308]: try expression alternatives have incompatible types\n   --> $DIR/issue-59756.rs:13:5\n    |\n LL |     foo()?\n-   |     ^^^^^-\n-   |     |    |\n-   |     |    help: try removing this `?`\n-   |     expected enum `std::result::Result`, found struct `A`\n+   |     ^^^^^^ expected enum `std::result::Result`, found struct `A`\n    |\n    = note: expected enum `std::result::Result<A, B>`\n             found struct `A`\n+help: try removing this `?`\n+   |\n+LL |     foo()\n+   |         --\n+help: try using a variant of the expected enum\n+   |\n+LL |     Ok(foo()?)\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "77fa2f566a8fc1524bd5d61ea5e58e23d1392387", "filename": "src/test/ui/malformed/malformed-derive-entry.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,7 +1,11 @@\n-#[derive(Copy(Bad))] //~ ERROR expected one of `)`, `,`, or `::`, found `(`\n+#[derive(Copy(Bad))]\n+//~^ ERROR traits in `#[derive(...)]` don't accept arguments\n+//~| ERROR the trait bound\n struct Test1;\n \n-#[derive(Copy=\"bad\")] //~ ERROR expected one of `)`, `,`, or `::`, found `=`\n+#[derive(Copy=\"bad\")]\n+//~^ ERROR traits in `#[derive(...)]` don't accept values\n+//~| ERROR the trait bound\n struct Test2;\n \n #[derive] //~ ERROR malformed `derive` attribute input"}, {"sha": "1f1ee39b049e309a35cbfe14139458ff15b14f28", "filename": "src/test/ui/malformed/malformed-derive-entry.stderr", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,20 +1,33 @@\n-error: expected one of `)`, `,`, or `::`, found `(`\n+error: traits in `#[derive(...)]` don't accept arguments\n   --> $DIR/malformed-derive-entry.rs:1:14\n    |\n LL | #[derive(Copy(Bad))]\n-   |              ^ expected one of `)`, `,`, or `::`\n+   |              ^^^^^ help: remove the arguments\n \n-error: expected one of `)`, `,`, or `::`, found `=`\n-  --> $DIR/malformed-derive-entry.rs:4:14\n+error: traits in `#[derive(...)]` don't accept values\n+  --> $DIR/malformed-derive-entry.rs:6:14\n    |\n LL | #[derive(Copy=\"bad\")]\n-   |              ^ expected one of `)`, `,`, or `::`\n+   |              ^^^^^^ help: remove the value\n \n error: malformed `derive` attribute input\n-  --> $DIR/malformed-derive-entry.rs:7:1\n+  --> $DIR/malformed-derive-entry.rs:11:1\n    |\n LL | #[derive]\n    | ^^^^^^^^^ help: missing traits to be derived: `#[derive(Trait1, Trait2, ...)]`\n \n-error: aborting due to 3 previous errors\n+error[E0277]: the trait bound `Test1: std::clone::Clone` is not satisfied\n+  --> $DIR/malformed-derive-entry.rs:1:10\n+   |\n+LL | #[derive(Copy(Bad))]\n+   |          ^^^^ the trait `std::clone::Clone` is not implemented for `Test1`\n+\n+error[E0277]: the trait bound `Test2: std::clone::Clone` is not satisfied\n+  --> $DIR/malformed-derive-entry.rs:6:10\n+   |\n+LL | #[derive(Copy=\"bad\")]\n+   |          ^^^^ the trait `std::clone::Clone` is not implemented for `Test2`\n+\n+error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "5b1614b69a92b6bc482cefece3f57456a12f05bc", "filename": "src/test/ui/malformed/malformed-meta-delim.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,11 @@\n+fn main() {}\n+\n+#[allow { foo_lint } ]\n+//~^ ERROR wrong meta list delimiters\n+//~| HELP the delimiters should be `(` and `)`\n+fn delim_brace() {}\n+\n+#[allow [ foo_lint ] ]\n+//~^ ERROR wrong meta list delimiters\n+//~| HELP the delimiters should be `(` and `)`\n+fn delim_bracket() {}"}, {"sha": "407193d4adebbd8784daf89623206769a145e5f5", "filename": "src/test/ui/malformed/malformed-meta-delim.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -0,0 +1,24 @@\n+error: wrong meta list delimiters\n+  --> $DIR/malformed-meta-delim.rs:3:9\n+   |\n+LL | #[allow { foo_lint } ]\n+   |         ^^^^^^^^^^^^\n+   |\n+help: the delimiters should be `(` and `)`\n+   |\n+LL | #[allow ( foo_lint ) ]\n+   |         ^          ^\n+\n+error: wrong meta list delimiters\n+  --> $DIR/malformed-meta-delim.rs:8:9\n+   |\n+LL | #[allow [ foo_lint ] ]\n+   |         ^^^^^^^^^^^^\n+   |\n+help: the delimiters should be `(` and `)`\n+   |\n+LL | #[allow ( foo_lint ) ]\n+   |         ^          ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "05b7ebe4666622c61f309087e983617db31c5dbc", "filename": "src/test/ui/malformed/malformed-special-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,7 +1,7 @@\n #[cfg_attr] //~ ERROR malformed `cfg_attr` attribute\n struct S1;\n \n-#[cfg_attr = \"\"] //~ ERROR expected `(`, found `=`\n+#[cfg_attr = \"\"] //~ ERROR malformed `cfg_attr` attribute\n struct S2;\n \n #[derive] //~ ERROR malformed `derive` attribute"}, {"sha": "6f535e03e6aec31035d8bd73b56231aaebeaad30", "filename": "src/test/ui/malformed/malformed-special-attrs.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -6,11 +6,13 @@ LL | #[cfg_attr]\n    |\n    = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n-error: expected `(`, found `=`\n-  --> $DIR/malformed-special-attrs.rs:4:12\n+error: malformed `cfg_attr` attribute input\n+  --> $DIR/malformed-special-attrs.rs:4:1\n    |\n LL | #[cfg_attr = \"\"]\n-   |            ^ expected `(`\n+   | ^^^^^^^^^^^^^^^^ help: missing condition and attribute: `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   |\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: malformed `derive` attribute input\n   --> $DIR/malformed-special-attrs.rs:7:1"}, {"sha": "c73130643db7b18c06d1a215878db53ed361ae80", "filename": "src/test/ui/mismatched_types/abridged.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -26,7 +26,10 @@ error[E0308]: mismatched types\n LL | fn b() -> Option<Foo> {\n    |           ----------- expected `std::option::Option<Foo>` because of return type\n LL |     Foo { bar: 1 }\n-   |     ^^^^^^^^^^^^^^ expected enum `std::option::Option`, found struct `Foo`\n+   |     ^^^^^^^^^^^^^^\n+   |     |\n+   |     expected enum `std::option::Option`, found struct `Foo`\n+   |     help: try using a variant of the expected enum: `Some(Foo { bar: 1 })`\n    |\n    = note: expected enum `std::option::Option<Foo>`\n             found struct `Foo`\n@@ -37,7 +40,10 @@ error[E0308]: mismatched types\n LL | fn c() -> Result<Foo, Bar> {\n    |           ---------------- expected `std::result::Result<Foo, Bar>` because of return type\n LL |     Foo { bar: 1 }\n-   |     ^^^^^^^^^^^^^^ expected enum `std::result::Result`, found struct `Foo`\n+   |     ^^^^^^^^^^^^^^\n+   |     |\n+   |     expected enum `std::result::Result`, found struct `Foo`\n+   |     help: try using a variant of the expected enum: `Ok(Foo { bar: 1 })`\n    |\n    = note: expected enum `std::result::Result<Foo, Bar>`\n             found struct `Foo`"}, {"sha": "8fb34f21152ab513fb1a3cfb2daeeedaee6e2e9e", "filename": "src/test/ui/on-unimplemented/expected-comma-found-token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -6,7 +6,7 @@\n \n #[rustc_on_unimplemented(\n     message=\"the message\"\n-    label=\"the label\" //~ ERROR expected one of `)` or `,`, found `label`\n+    label=\"the label\" //~ ERROR expected `,`, found `label`\n )]\n trait T {}\n "}, {"sha": "048b72ee3bcdff21f184fc6b1bb5df22a5471ccb", "filename": "src/test/ui/on-unimplemented/expected-comma-found-token.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -1,11 +1,8 @@\n-error: expected one of `)` or `,`, found `label`\n+error: expected `,`, found `label`\n   --> $DIR/expected-comma-found-token.rs:9:5\n    |\n LL |     message=\"the message\"\n-   |                          -\n-   |                          |\n-   |                          expected one of `)` or `,`\n-   |                          help: missing `,`\n+   |                          - expected `,`\n LL |     label=\"the label\"\n    |     ^^^^^ unexpected token\n "}, {"sha": "a77e92022e2b676a4eab4dba9b85bf345174760b", "filename": "src/test/ui/proc-macro/span-preservation.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -14,6 +14,11 @@ LL | fn b(x: Option<isize>) -> usize {\n LL |     match x {\n LL |         Some(x) => { return x },\n    |                             ^ expected `usize`, found `isize`\n+   |\n+help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         Some(x) => { return x.try_into().unwrap() },\n+   |                             ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/span-preservation.rs:33:22"}, {"sha": "713b9eb542cfac9e3be6a637f5a7a2a10c7d3119", "filename": "src/test/ui/span/macro-ty-params.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -10,5 +10,4 @@ fn main() {\n     foo::<T>!(); //~ ERROR generic arguments in macro path\n     foo::<>!(); //~ ERROR generic arguments in macro path\n     m!(Default<>); //~ ERROR generic arguments in macro path\n-    //~^ ERROR unexpected generic arguments in path\n }"}, {"sha": "21683b2fb8643cb414c123da09b3fa09e06a4a65", "filename": "src/test/ui/span/macro-ty-params.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -10,17 +10,11 @@ error: generic arguments in macro path\n LL |     foo::<>!();\n    |          ^^\n \n-error: unexpected generic arguments in path\n-  --> $DIR/macro-ty-params.rs:12:8\n-   |\n-LL |     m!(Default<>);\n-   |        ^^^^^^^^^\n-\n error: generic arguments in macro path\n   --> $DIR/macro-ty-params.rs:12:15\n    |\n LL |     m!(Default<>);\n    |               ^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "69f8ffa581bc128c0dcabbdd9aa6113d38d97bde", "filename": "src/test/ui/tail-typeck.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ftail-typeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Ftail-typeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftail-typeck.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -5,6 +5,11 @@ LL | fn f() -> isize { return g(); }\n    |           -----          ^^^ expected `isize`, found `usize`\n    |           |\n    |           expected `isize` because of return type\n+   |\n+help: you can convert an `usize` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL | fn f() -> isize { return g().try_into().unwrap(); }\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "c1274bd0ea6bc3226bdb8a7ca79e3780ad46ebac", "filename": "src/test/ui/wrong-ret-type.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fwrong-ret-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41601a8c95240cada94c13466a1fea02e5fe87ed/src%2Ftest%2Fui%2Fwrong-ret-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrong-ret-type.stderr?ref=41601a8c95240cada94c13466a1fea02e5fe87ed", "patch": "@@ -5,6 +5,11 @@ LL | fn mk_int() -> usize { let i: isize = 3; return i; }\n    |                -----                            ^ expected `usize`, found `isize`\n    |                |\n    |                expected `usize` because of return type\n+   |\n+help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL | fn mk_int() -> usize { let i: isize = 3; return i.try_into().unwrap(); }\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}