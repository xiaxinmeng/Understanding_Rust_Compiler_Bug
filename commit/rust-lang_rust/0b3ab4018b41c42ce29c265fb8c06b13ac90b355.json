{"sha": "0b3ab4018b41c42ce29c265fb8c06b13ac90b355", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiM2FiNDAxOGI0MWM0MmNlMjljMjY1ZmI4YzA2YjEzYWM5MGIzNTU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-07T13:22:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T07:26:13Z"}, "message": "rustc: keep a TyCtxt in PrintCx and use it instead of ty::tls.", "tree": {"sha": "c949800e8e5c94fb680713268661b3b2ef7048d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c949800e8e5c94fb680713268661b3b2ef7048d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b3ab4018b41c42ce29c265fb8c06b13ac90b355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3ab4018b41c42ce29c265fb8c06b13ac90b355", "html_url": "https://github.com/rust-lang/rust/commit/0b3ab4018b41c42ce29c265fb8c06b13ac90b355", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b3ab4018b41c42ce29c265fb8c06b13ac90b355/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f3841ca2fe5cf0ba714db42a29a8004a878b6e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f3841ca2fe5cf0ba714db42a29a8004a878b6e6", "html_url": "https://github.com/rust-lang/rust/commit/5f3841ca2fe5cf0ba714db42a29a8004a878b6e6"}], "stats": {"total": 398, "additions": 190, "deletions": 208}, "files": [{"sha": "b04bb5b3d0171b8f202e1c150d8ccdb47119b1ea", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0b3ab4018b41c42ce29c265fb8c06b13ac90b355/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3ab4018b41c42ce29c265fb8c06b13ac90b355/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0b3ab4018b41c42ce29c265fb8c06b13ac90b355", "patch": "@@ -2369,17 +2369,19 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 };\n \n                 // When printing regions, add trailing space if necessary.\n-                let region = if ppaux::verbose() || ppaux::identify_regions() {\n-                    let mut region = region.to_string();\n-                    if region.len() > 0 {\n-                        region.push(' ');\n-                    }\n-                    region\n-                } else {\n-                    // Do not even print 'static\n-                    String::new()\n-                };\n-                write!(fmt, \"&{}{}{:?}\", region, kind_str, place)\n+                ty::print::PrintCx::with(|cx| {\n+                    let region = if cx.is_verbose || cx.identify_regions {\n+                        let mut region = region.to_string();\n+                        if region.len() > 0 {\n+                            region.push(' ');\n+                        }\n+                        region\n+                    } else {\n+                        // Do not even print 'static\n+                        String::new()\n+                    };\n+                    write!(fmt, \"&{}{}{:?}\", region, kind_str, place)\n+                })\n             }\n \n             Aggregate(ref kind, ref places) => {"}, {"sha": "fb296519d499768cc59d1abd5065b328a681ef65", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0b3ab4018b41c42ce29c265fb8c06b13ac90b355/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3ab4018b41c42ce29c265fb8c06b13ac90b355/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=0b3ab4018b41c42ce29c265fb8c06b13ac90b355", "patch": "@@ -1,4 +1,4 @@\n-use crate::ty::{self, TypeFoldable};\n+use crate::ty::{self, TyCtxt, TypeFoldable};\n \n use rustc_data_structures::fx::FxHashSet;\n use syntax::symbol::InternedString;\n@@ -21,8 +21,8 @@ impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct PrintCx {\n+pub struct PrintCx<'a, 'gcx, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub(crate) is_debug: bool,\n     pub(crate) is_verbose: bool,\n     pub(crate) identify_regions: bool,\n@@ -31,22 +31,21 @@ pub struct PrintCx {\n     pub(crate) binder_depth: usize,\n }\n \n-impl PrintCx {\n-    pub(crate) fn new() -> Self {\n+impl PrintCx<'a, 'gcx, 'tcx> {\n+    pub(crate) fn with<R>(f: impl FnOnce(PrintCx<'_, '_, '_>) -> R) -> R {\n         ty::tls::with(|tcx| {\n-            let (is_verbose, identify_regions) =\n-                (tcx.sess.verbose(), tcx.sess.opts.debugging_opts.identify_regions);\n-            PrintCx {\n+            f(PrintCx {\n+                tcx,\n                 is_debug: false,\n-                is_verbose: is_verbose,\n-                identify_regions: identify_regions,\n+                is_verbose: tcx.sess.verbose(),\n+                identify_regions: tcx.sess.opts.debugging_opts.identify_regions,\n                 used_region_names: None,\n                 region_index: 0,\n                 binder_depth: 0,\n-            }\n+            })\n         })\n     }\n-    pub(crate) fn prepare_late_bound_region_info<'tcx, T>(&mut self, value: &ty::Binder<T>)\n+    pub(crate) fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n     where T: TypeFoldable<'tcx>\n     {\n         let mut collector = LateBoundRegionNameCollector(Default::default());\n@@ -57,32 +56,32 @@ impl PrintCx {\n }\n \n pub trait Print<'tcx> {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx) -> fmt::Result;\n-    fn print_to_string(&self, cx: &mut PrintCx) -> String {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, '_>) -> fmt::Result;\n+    fn print_to_string(&self, cx: &mut PrintCx<'_, '_, '_>) -> String {\n         let mut result = String::new();\n         let _ = self.print(&mut result, cx);\n         result\n     }\n-    fn print_display<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx) -> fmt::Result {\n+    fn print_display<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, '_>) -> fmt::Result {\n         let old_debug = cx.is_debug;\n         cx.is_debug = false;\n         let result = self.print(f, cx);\n         cx.is_debug = old_debug;\n         result\n     }\n-    fn print_display_to_string(&self, cx: &mut PrintCx) -> String {\n+    fn print_display_to_string(&self, cx: &mut PrintCx<'_, '_, '_>) -> String {\n         let mut result = String::new();\n         let _ = self.print_display(&mut result, cx);\n         result\n     }\n-    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx) -> fmt::Result {\n+    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, '_>) -> fmt::Result {\n         let old_debug = cx.is_debug;\n         cx.is_debug = true;\n         let result = self.print(f, cx);\n         cx.is_debug = old_debug;\n         result\n     }\n-    fn print_debug_to_string(&self, cx: &mut PrintCx) -> String {\n+    fn print_debug_to_string(&self, cx: &mut PrintCx<'_, '_, '_>) -> String {\n         let mut result = String::new();\n         let _ = self.print_debug(&mut result, cx);\n         result"}, {"sha": "ff66df4e4a3f67733266af05c8d0d07c6dcea3ee", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 160, "deletions": 179, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/0b3ab4018b41c42ce29c265fb8c06b13ac90b355/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3ab4018b41c42ce29c265fb8c06b13ac90b355/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0b3ab4018b41c42ce29c265fb8c06b13ac90b355", "patch": "@@ -8,7 +8,7 @@ use crate::ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n use crate::ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n use crate::ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use crate::ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind, ParamConst};\n+use crate::ty::{self, Ty, TypeFoldable, GenericParamCount, GenericParamDefKind, ParamConst};\n use crate::ty::print::{PrintCx, Print};\n use crate::mir::interpret::ConstValue;\n \n@@ -182,8 +182,7 @@ impl RegionHighlightMode {\n macro_rules! gen_display_debug_body {\n     ( $with:path ) => {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            let mut cx = PrintCx::new();\n-            $with(self, f, &mut cx)\n+            PrintCx::with(|mut cx| $with(self, f, &mut cx))\n         }\n     };\n }\n@@ -213,15 +212,23 @@ macro_rules! gen_display_debug {\n macro_rules! gen_print_impl {\n     ( ($($x:tt)+) $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n         impl<$($x)+> Print<'tcx> for $target {\n-            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintCx) -> fmt::Result {\n+            fn print<F: fmt::Write>(\n+                &$self,\n+                $f: &mut F,\n+                $cx: &mut PrintCx<'_, '_, '_>,\n+            ) -> fmt::Result {\n                 if $cx.is_debug $dbg\n                 else $disp\n             }\n         }\n     };\n     ( () $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n         impl Print<'tcx> for $target {\n-            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintCx) -> fmt::Result {\n+            fn print<F: fmt::Write>(\n+                &$self,\n+                $f: &mut F,\n+                $cx: &mut PrintCx<'_, '_, '_>,\n+            ) -> fmt::Result {\n                 if $cx.is_debug $dbg\n                 else $disp\n             }\n@@ -275,7 +282,7 @@ macro_rules! print {\n     };\n }\n \n-impl PrintCx {\n+impl PrintCx<'a, 'gcx, 'tcx> {\n     fn fn_sig<F: fmt::Write>(&mut self,\n                              f: &mut F,\n                              inputs: &[Ty<'_>],\n@@ -307,21 +314,22 @@ impl PrintCx {\n                                     did: DefId,\n                                     projections: &[ty::ProjectionPredicate<'_>])\n                                     -> fmt::Result {\n-        let key = ty::tls::with(|tcx| tcx.def_key(did));\n+        let key = self.tcx.def_key(did);\n \n         let verbose = self.is_verbose;\n         let mut num_supplied_defaults = 0;\n-        let mut has_self = false;\n+        let has_self;\n         let mut own_counts: GenericParamCount = Default::default();\n         let mut is_value_path = false;\n         let mut item_name = Some(key.disambiguated_data.data.as_interned_str());\n-        let fn_trait_kind = ty::tls::with(|tcx| {\n+        let mut path_def_id = did;\n+        {\n             // Unfortunately, some kinds of items (e.g., closures) don't have\n             // generics. So walk back up the find the closest parent that DOES\n             // have them.\n             let mut item_def_id = did;\n             loop {\n-                let key = tcx.def_key(item_def_id);\n+                let key = self.tcx.def_key(item_def_id);\n                 match key.disambiguated_data.data {\n                     DefPathData::AssocTypeInTrait(_) |\n                     DefPathData::AssocTypeInImpl(_) |\n@@ -360,17 +368,16 @@ impl PrintCx {\n                     }\n                 }\n             }\n-            let mut generics = tcx.generics_of(item_def_id);\n+            let mut generics = self.tcx.generics_of(item_def_id);\n             let child_own_counts = generics.own_counts();\n-            let mut path_def_id = did;\n             has_self = generics.has_self;\n \n             let mut child_types = 0;\n             if let Some(def_id) = generics.parent {\n                 // Methods.\n                 assert!(is_value_path);\n                 child_types = child_own_counts.types;\n-                generics = tcx.generics_of(def_id);\n+                generics = self.tcx.generics_of(def_id);\n                 own_counts = generics.own_counts();\n \n                 if has_self {\n@@ -404,23 +411,22 @@ impl PrintCx {\n                     *has_default.unwrap_or(&false)\n                 };\n                 if has_default {\n-                    let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n+                    let substs = self.tcx.lift(&substs).expect(\"could not lift for printing\");\n                     let types = substs.types().rev().skip(child_types);\n                     for ((def_id, has_default), actual) in type_params.zip(types) {\n                         if !has_default {\n                             break;\n                         }\n-                        if tcx.type_of(def_id).subst(tcx, substs) != actual {\n+                        if self.tcx.type_of(def_id).subst(self.tcx, substs) != actual {\n                             break;\n                         }\n                         num_supplied_defaults += 1;\n                     }\n                 }\n             }\n-\n-            print!(f, self, write(\"{}\", tcx.item_path_str(path_def_id)))?;\n-            Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n-        })?;\n+        }\n+        print!(f, self, write(\"{}\", self.tcx.item_path_str(path_def_id)))?;\n+        let fn_trait_kind = self.tcx.lang_items().fn_trait_kind(path_def_id);\n \n         if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n             let projection_ty = projections[0].ty;\n@@ -482,12 +488,10 @@ impl PrintCx {\n \n         for projection in projections {\n             start_or_continue(f, \"<\", \", \")?;\n-            ty::tls::with(|tcx|\n-                print!(f, self,\n-                       write(\"{}=\",\n-                             tcx.associated_item(projection.projection_ty.item_def_id).ident),\n-                       print_display(projection.ty))\n-            )?;\n+            print!(f, self,\n+                    write(\"{}=\",\n+                            self.tcx.associated_item(projection.projection_ty.item_def_id).ident),\n+                    print_display(projection.ty))?;\n         }\n \n         // FIXME(const_generics::defaults)\n@@ -526,12 +530,7 @@ impl PrintCx {\n         Ok(())\n     }\n \n-    fn in_binder<'a, 'gcx, 'tcx, T, F>(\n-        &mut self,\n-        f: &mut F,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        value: ty::Binder<T>,\n-    ) -> fmt::Result\n+    fn in_binder<T, F>(&mut self, f: &mut F, value: ty::Binder<T>) -> fmt::Result\n         where T: Print<'tcx> + TypeFoldable<'tcx>, F: fmt::Write\n     {\n         fn name_by_region_index(index: usize) -> InternedString {\n@@ -563,7 +562,7 @@ impl PrintCx {\n \n         let old_region_index = self.region_index;\n         let mut region_index = old_region_index;\n-        let new_value = tcx.replace_late_bound_regions(&value, |br| {\n+        let new_value = self.tcx.replace_late_bound_regions(&value, |br| {\n             let _ = start_or_continue(f, \"for<\", \", \");\n             let br = match br {\n                 ty::BrNamed(_, name) => {\n@@ -581,10 +580,10 @@ impl PrintCx {\n                         }\n                     };\n                     let _ = write!(f, \"{}\", name);\n-                    ty::BrNamed(tcx.hir().local_def_id(CRATE_NODE_ID), name)\n+                    ty::BrNamed(self.tcx.hir().local_def_id(CRATE_NODE_ID), name)\n                 }\n             };\n-            tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n+            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n         }).0;\n         start_or_continue(f, \"\", \"> \")?;\n \n@@ -605,24 +604,16 @@ impl PrintCx {\n     }\n }\n \n-pub fn verbose() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.verbose())\n-}\n-\n-pub fn identify_regions() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n-}\n-\n pub fn parameterized<F: fmt::Write>(f: &mut F,\n                                     substs: SubstsRef<'_>,\n                                     did: DefId,\n                                     projections: &[ty::ProjectionPredicate<'_>])\n                                     -> fmt::Result {\n-    PrintCx::new().parameterized(f, substs, did, projections)\n+    PrintCx::with(|mut cx| cx.parameterized(f, substs, did, projections))\n }\n \n impl<'a, 'tcx, T: Print<'tcx>> Print<'tcx> for &'a T {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx) -> fmt::Result {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, '_>) -> fmt::Result {\n         (*self).print(f, cx)\n     }\n }\n@@ -631,50 +622,47 @@ define_print! {\n     ('tcx) &'tcx ty::List<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n         display {\n             // Generate the main trait ref, including associated types.\n-            ty::tls::with(|tcx| {\n-                // Use a type that can't appear in defaults of type parameters.\n-                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-                let mut first = true;\n-\n-                if let Some(principal) = self.principal() {\n-                    let principal = tcx\n-                        .lift(&principal)\n-                        .expect(\"could not lift for printing\")\n-                        .with_self_ty(tcx, dummy_self);\n-                    let projections = self.projection_bounds().map(|p| {\n-                        tcx.lift(&p)\n-                            .expect(\"could not lift for printing\")\n-                            .with_self_ty(tcx, dummy_self)\n-                    }).collect::<Vec<_>>();\n-                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n-                    first = false;\n-                }\n \n-                // Builtin bounds.\n-                let mut auto_traits: Vec<_> = self.auto_traits().map(|did| {\n-                    tcx.item_path_str(did)\n-                }).collect();\n-\n-                // The auto traits come ordered by `DefPathHash`. While\n-                // `DefPathHash` is *stable* in the sense that it depends on\n-                // neither the host nor the phase of the moon, it depends\n-                // \"pseudorandomly\" on the compiler version and the target.\n-                //\n-                // To avoid that causing instabilities in compiletest\n-                // output, sort the auto-traits alphabetically.\n-                auto_traits.sort();\n-\n-                for auto_trait in auto_traits {\n-                    if !first {\n-                        write!(f, \" + \")?;\n-                    }\n-                    first = false;\n+            // Use a type that can't appear in defaults of type parameters.\n+            let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n+            let mut first = true;\n+\n+            if let Some(principal) = self.principal() {\n+                let principal = cx.tcx\n+                    .lift(&principal)\n+                    .expect(\"could not lift for printing\")\n+                    .with_self_ty(cx.tcx, dummy_self);\n+                let projections = self.projection_bounds().map(|p| {\n+                    cx.tcx.lift(&p)\n+                        .expect(\"could not lift for printing\")\n+                        .with_self_ty(cx.tcx, dummy_self)\n+                }).collect::<Vec<_>>();\n+                cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n+                first = false;\n+            }\n \n-                    write!(f, \"{}\", auto_trait)?;\n+            // Builtin bounds.\n+            let mut auto_traits: Vec<_> = self.auto_traits().map(|did| {\n+                cx.tcx.item_path_str(did)\n+            }).collect();\n+\n+            // The auto traits come ordered by `DefPathHash`. While\n+            // `DefPathHash` is *stable* in the sense that it depends on\n+            // neither the host nor the phase of the moon, it depends\n+            // \"pseudorandomly\" on the compiler version and the target.\n+            //\n+            // To avoid that causing instabilities in compiletest\n+            // output, sort the auto-traits alphabetically.\n+            auto_traits.sort();\n+\n+            for auto_trait in auto_traits {\n+                if !first {\n+                    write!(f, \" + \")?;\n                 }\n+                first = false;\n \n-                Ok(())\n-            })?;\n+                write!(f, \"{}\", auto_trait)?;\n+            }\n \n             Ok(())\n         }\n@@ -698,16 +686,16 @@ impl fmt::Debug for ty::GenericParamDef {\n \n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            write!(f, \"{}\", tcx.item_path_str(self.def_id))\n+        PrintCx::with(|cx| {\n+            write!(f, \"{}\", cx.tcx.item_path_str(self.def_id))\n         })\n     }\n }\n \n impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            write!(f, \"{}\", tcx.item_path_str(self.did))\n+        PrintCx::with(|cx| {\n+            write!(f, \"{}\", cx.tcx.item_path_str(self.did))\n         })\n     }\n }\n@@ -724,7 +712,9 @@ impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"UpvarId({:?};`{}`;{:?})\",\n                self.var_path.hir_id,\n-               ty::tls::with(|tcx| tcx.hir().name_by_hir_id(self.var_path.hir_id)),\n+               PrintCx::with(|cx| {\n+                    cx.tcx.hir().name_by_hir_id(self.var_path.hir_id)\n+               }),\n                self.closure_expr_id)\n     }\n }\n@@ -768,14 +758,12 @@ define_print! {\n             cx.parameterized(f, self.substs, self.def_id, &[])\n         }\n         debug {\n-            ty::tls::with(|tcx| {\n-                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+            let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n \n-                let trait_ref = *tcx.lift(&ty::Binder::bind(*self))\n-                                   .expect(\"could not lift for printing\")\n-                                   .with_self_ty(tcx, dummy_self).skip_binder();\n-                cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n-            })\n+            let trait_ref = *cx.tcx.lift(&ty::Binder::bind(*self))\n+                                .expect(\"could not lift for printing\")\n+                                .with_self_ty(cx.tcx, dummy_self).skip_binder();\n+            cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n         }\n     }\n }\n@@ -1092,7 +1080,7 @@ impl fmt::Debug for ty::FloatVarValue {\n           for<'a> <T as ty::Lift<'a>>::Lifted: fmt::Display + TypeFoldable<'a>\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, tcx.lift(self)\n+        PrintCx::with(|cx| cx.in_binder(f, cx.tcx.lift(self)\n             .expect(\"could not lift for printing\")))\n     }\n }*/\n@@ -1110,8 +1098,8 @@ define_print_multi! {\n     ]\n     (self, f, cx) {\n         display {\n-            ty::tls::with(|tcx| cx.in_binder(f, tcx, tcx.lift(self)\n-                .expect(\"could not lift for printing\")))\n+            cx.in_binder(f, cx.tcx.lift(self)\n+                .expect(\"could not lift for printing\"))\n         }\n     }\n }\n@@ -1178,12 +1166,10 @@ define_print! {\n                     write!(f, \")\")\n                 }\n                 FnDef(def_id, substs) => {\n-                    ty::tls::with(|tcx| {\n-                        let substs = tcx.lift(&substs)\n-                            .expect(\"could not lift for printing\");\n-                        let sig = tcx.fn_sig(def_id).subst(tcx, substs);\n-                        print!(f, cx, print(sig), write(\" {{\"))\n-                    })?;\n+                    let substs = cx.tcx.lift(&substs)\n+                        .expect(\"could not lift for printing\");\n+                    let sig = cx.tcx.fn_sig(def_id).subst(cx.tcx, substs);\n+                    print!(f, cx, print(sig), write(\" {{\"))?;\n                     cx.parameterized(f, substs, def_id, &[])?;\n                     write!(f, \"}}\")\n                 }\n@@ -1235,71 +1221,69 @@ define_print! {\n                         return write!(f, \"Opaque({:?}, {:?})\", def_id, substs);\n                     }\n \n-                    ty::tls::with(|tcx| {\n-                        let def_key = tcx.def_key(def_id);\n-                        if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                            write!(f, \"{}\", name)?;\n-                            let mut substs = substs.iter();\n-                            if let Some(first) = substs.next() {\n-                                write!(f, \"::<\")?;\n-                                write!(f, \"{}\", first)?;\n-                                for subst in substs {\n-                                    write!(f, \", {}\", subst)?;\n-                                }\n-                                write!(f, \">\")?;\n+                    let def_key = cx.tcx.def_key(def_id);\n+                    if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                        write!(f, \"{}\", name)?;\n+                        let mut substs = substs.iter();\n+                        if let Some(first) = substs.next() {\n+                            write!(f, \"::<\")?;\n+                            write!(f, \"{}\", first)?;\n+                            for subst in substs {\n+                                write!(f, \", {}\", subst)?;\n                             }\n-                            return Ok(());\n+                            write!(f, \">\")?;\n                         }\n-                        // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                        // by looking up the projections associated with the def_id.\n-                        let substs = tcx.lift(&substs)\n-                            .expect(\"could not lift for printing\");\n-                        let bounds = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-\n-                        let mut first = true;\n-                        let mut is_sized = false;\n-                        write!(f, \"impl\")?;\n-                        for predicate in bounds.predicates {\n-                            if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                                // Don't print +Sized, but rather +?Sized if absent.\n-                                if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n-                                    is_sized = true;\n-                                    continue;\n-                                }\n-\n-                                print!(f, cx,\n-                                       write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                       print(trait_ref))?;\n-                                first = false;\n+                        return Ok(());\n+                    }\n+                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                    // by looking up the projections associated with the def_id.\n+                    let substs = cx.tcx.lift(&substs)\n+                        .expect(\"could not lift for printing\");\n+                    let bounds = cx.tcx.predicates_of(def_id).instantiate(cx.tcx, substs);\n+\n+                    let mut first = true;\n+                    let mut is_sized = false;\n+                    write!(f, \"impl\")?;\n+                    for predicate in bounds.predicates {\n+                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                            // Don't print +Sized, but rather +?Sized if absent.\n+                            if Some(trait_ref.def_id()) == cx.tcx.lang_items().sized_trait() {\n+                                is_sized = true;\n+                                continue;\n                             }\n+\n+                            print!(f, cx,\n+                                    write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                    print(trait_ref))?;\n+                            first = false;\n                         }\n-                        if !is_sized {\n-                            write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n+                    }\n+                    if !is_sized {\n+                        write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n                         } else if first {\n                             write!(f, \" Sized\")?;\n-                        }\n-                        Ok(())\n-                    })\n+                    }\n+                    Ok(())\n                 }\n                 Str => write!(f, \"str\"),\n-                Generator(did, substs, movability) => ty::tls::with(|tcx| {\n-                    let upvar_tys = substs.upvar_tys(did, tcx);\n-                    let witness = substs.witness(did, tcx);\n+                Generator(did, substs, movability) => {\n+                    let upvar_tys = substs.upvar_tys(did, cx.tcx);\n+                    let witness = substs.witness(did, cx.tcx);\n                     if movability == hir::GeneratorMovability::Movable {\n                         write!(f, \"[generator\")?;\n                     } else {\n                         write!(f, \"[static generator\")?;\n                     }\n \n-                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-                        write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n+                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n+                        write!(f, \"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id))?;\n                         let mut sep = \" \";\n-                        tcx.with_freevars(hir_id, |freevars| {\n+                        cx.tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\",\n                                              sep,\n-                                             tcx.hir().name(freevar.var_id())),\n+                                             cx.tcx.hir().name(freevar.var_id())),\n                                        print(upvar_ty))?;\n                                 sep = \", \";\n                             }\n@@ -1319,28 +1303,28 @@ define_print! {\n                     }\n \n                     print!(f, cx, write(\" \"), print(witness), write(\"]\"))\n-                }),\n+                },\n                 GeneratorWitness(types) => {\n-                    ty::tls::with(|tcx| cx.in_binder(f, tcx, tcx.lift(&types)\n-                        .expect(\"could not lift for printing\")))\n+                    cx.in_binder(f, cx.tcx.lift(&types)\n+                        .expect(\"could not lift for printing\"))\n                 }\n-                Closure(did, substs) => ty::tls::with(|tcx| {\n-                    let upvar_tys = substs.upvar_tys(did, tcx);\n+                Closure(did, substs) => {\n+                    let upvar_tys = substs.upvar_tys(did, cx.tcx);\n                     write!(f, \"[closure\")?;\n \n-                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-                        if tcx.sess.opts.debugging_opts.span_free_formats {\n+                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n+                        if cx.tcx.sess.opts.debugging_opts.span_free_formats {\n                             write!(f, \"@{:?}\", hir_id)?;\n                         } else {\n-                            write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n+                            write!(f, \"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id))?;\n                         }\n                         let mut sep = \" \";\n-                        tcx.with_freevars(hir_id, |freevars| {\n+                        cx.tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\",\n                                              sep,\n-                                             tcx.hir().name(freevar.var_id())),\n+                                             cx.tcx.hir().name(freevar.var_id())),\n                                        print(upvar_ty))?;\n                                 sep = \", \";\n                             }\n@@ -1369,21 +1353,21 @@ define_print! {\n                     }\n \n                     write!(f, \"]\")\n-                }),\n+                },\n                 Array(ty, sz) => {\n                     print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n                     match sz {\n                         ty::LazyConst::Unevaluated(_def_id, _substs) => {\n                             write!(f, \"_\")?;\n                         }\n-                        ty::LazyConst::Evaluated(c) => ty::tls::with(|tcx| {\n+                        ty::LazyConst::Evaluated(c) => {\n                             match c.val {\n-                                ConstValue::Infer(..) => write!(f, \"_\"),\n+                                ConstValue::Infer(..) => write!(f, \"_\")?,\n                                 ConstValue::Param(ParamConst { name, .. }) =>\n-                                    write!(f, \"{}\", name),\n-                                _ => write!(f, \"{}\", c.unwrap_usize(tcx)),\n+                                    write!(f, \"{}\", name)?,\n+                                _ => write!(f, \"{}\", c.unwrap_usize(cx.tcx))?,\n                             }\n-                        })?,\n+                        }\n                     }\n                     write!(f, \"]\")\n                 }\n@@ -1510,9 +1494,8 @@ define_print! {\n             // FIXME(tschottdorf): use something like\n             //   parameterized(f, self.substs, self.item_def_id, &[])\n             // (which currently ICEs).\n-            let (trait_ref, item_name) = ty::tls::with(|tcx|\n-                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).ident)\n-            );\n+            let trait_ref = self.trait_ref(cx.tcx);\n+            let item_name = cx.tcx.associated_item(self.item_def_id).ident;\n             print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n         }\n     }\n@@ -1540,15 +1523,13 @@ define_print! {\n                 ty::Predicate::TypeOutlives(ref predicate) => predicate.print(f, cx),\n                 ty::Predicate::Projection(ref predicate) => predicate.print(f, cx),\n                 ty::Predicate::WellFormed(ty) => print!(f, cx, print(ty), write(\" well-formed\")),\n-                ty::Predicate::ObjectSafe(trait_def_id) =>\n-                    ty::tls::with(|tcx| {\n-                        write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n-                    }),\n-                ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) =>\n-                    ty::tls::with(|tcx| {\n-                        write!(f, \"the closure `{}` implements the trait `{}`\",\n-                               tcx.item_path_str(closure_def_id), kind)\n-                    }),\n+                ty::Predicate::ObjectSafe(trait_def_id) => {\n+                    write!(f, \"the trait `{}` is object-safe\", cx.tcx.item_path_str(trait_def_id))\n+                }\n+                ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+                    write!(f, \"the closure `{}` implements the trait `{}`\",\n+                           cx.tcx.item_path_str(closure_def_id), kind)\n+                }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                     write!(f, \"the constant `\")?;\n                     cx.parameterized(f, substs, def_id, &[])?;"}]}