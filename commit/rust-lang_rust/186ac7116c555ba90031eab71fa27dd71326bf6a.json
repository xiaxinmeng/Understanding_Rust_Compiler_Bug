{"sha": "186ac7116c555ba90031eab71fa27dd71326bf6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NmFjNzExNmM1NTViYTkwMDMxZWFiNzFmYTI3ZGQ3MTMyNmJmNmE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-14T14:43:57Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:06:52Z"}, "message": "rustc: de-@ freevars.", "tree": {"sha": "155289f99230dc3ba7283eb5f80e86eea4e51890", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/155289f99230dc3ba7283eb5f80e86eea4e51890"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/186ac7116c555ba90031eab71fa27dd71326bf6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/186ac7116c555ba90031eab71fa27dd71326bf6a", "html_url": "https://github.com/rust-lang/rust/commit/186ac7116c555ba90031eab71fa27dd71326bf6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/186ac7116c555ba90031eab71fa27dd71326bf6a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1350fbdb24a06bd389cf1617ad5b78289a0c2354", "url": "https://api.github.com/repos/rust-lang/rust/commits/1350fbdb24a06bd389cf1617ad5b78289a0c2354", "html_url": "https://github.com/rust-lang/rust/commit/1350fbdb24a06bd389cf1617ad5b78289a0c2354"}], "stats": {"total": 127, "additions": 65, "deletions": 62}, "files": [{"sha": "ef33d984d166e4ca6b03c333bccff7a915466c9c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=186ac7116c555ba90031eab71fa27dd71326bf6a", "patch": "@@ -526,7 +526,7 @@ impl tr for ty::TraitStore {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: &mut Encoder, fv: @freevar_entry) {\n+fn encode_freevar_entry(ebml_w: &mut Encoder, fv: &freevar_entry) {\n     (*fv).encode(ebml_w).unwrap();\n }\n \n@@ -1018,7 +1018,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n                 ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n-                    Ok(encode_freevar_entry(ebml_w, *fv_entry))\n+                    Ok(encode_freevar_entry(ebml_w, fv_entry))\n                 });\n             })\n         })\n@@ -1370,8 +1370,8 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         dcx.tcx.node_type_substs.borrow_mut().insert(id, tys);\n                     }\n                     c::tag_table_freevars => {\n-                        let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n-                            Ok(@val_dsr.read_freevar_entry(xcx))\n+                        let fv_info = val_dsr.read_to_vec(|val_dsr| {\n+                            Ok(val_dsr.read_freevar_entry(xcx))\n                         }).unwrap().move_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }"}, {"sha": "83f6d5abfa4cfef0e072c31f43a9b206a1b4d730", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=186ac7116c555ba90031eab71fa27dd71326bf6a", "patch": "@@ -29,12 +29,11 @@ pub struct freevar_entry {\n     pub def: ast::Def, //< The variable being accessed free.\n     pub span: Span     //< First span where it is accessed (there can be multiple)\n }\n-pub type freevar_info = @Vec<@freevar_entry> ;\n-pub type freevar_map = NodeMap<freevar_info>;\n+pub type freevar_map = NodeMap<Vec<freevar_entry>>;\n \n struct CollectFreevarsVisitor<'a> {\n     seen: NodeSet,\n-    refs: Vec<@freevar_entry>,\n+    refs: Vec<freevar_entry>,\n     def_map: &'a resolve::DefMap,\n }\n \n@@ -65,7 +64,7 @@ impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n                         if i == depth { // Made it to end of loop\n                             let dnum = ast_util::def_id_of_def(def).node;\n                             if !self.seen.contains(&dnum) {\n-                                self.refs.push(@freevar_entry {\n+                                self.refs.push(freevar_entry {\n                                     def: def,\n                                     span: expr.span,\n                                 });\n@@ -87,15 +86,15 @@ impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: &resolve::DefMap, blk: &ast::Block) -> freevar_info {\n+fn collect_freevars(def_map: &resolve::DefMap, blk: &ast::Block) -> Vec<freevar_entry> {\n     let mut v = CollectFreevarsVisitor {\n         seen: NodeSet::new(),\n         refs: Vec::new(),\n         def_map: def_map,\n     };\n \n     v.visit_block(blk, 1);\n-    @v.refs\n+    v.refs\n }\n \n struct AnnotateFreevarsVisitor<'a> {\n@@ -128,9 +127,9 @@ pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate) ->\n     visitor.freevars\n }\n \n-pub fn get_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> freevar_info {\n+pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]| -> T) -> T {\n     match tcx.freevars.borrow().find(&fid) {\n-        None => fail!(\"get_freevars: {} has no freevars\", fid),\n-        Some(&d) => return d\n+        None => fail!(\"with_freevars: {} has no freevars\", fid),\n+        Some(d) => f(d.as_slice())\n     }\n }"}, {"sha": "dee6af17e802d44f7eff25a5021f12feacd48c3d", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=186ac7116c555ba90031eab71fa27dd71326bf6a", "patch": "@@ -163,7 +163,7 @@ fn check_item(cx: &mut Context, item: &Item) {\n // closure.\n fn with_appropriate_checker(cx: &Context,\n                             id: NodeId,\n-                            b: |checker: |&Context, @freevar_entry||) {\n+                            b: |checker: |&Context, &freevar_entry||) {\n     fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n@@ -184,7 +184,7 @@ fn with_appropriate_checker(cx: &Context,\n                              bounds, Some(var_t));\n     }\n \n-    fn check_for_bare(cx: &Context, fv: @freevar_entry) {\n+    fn check_for_bare(cx: &Context, fv: &freevar_entry) {\n         cx.tcx.sess.span_err(\n             fv.span,\n             \"can't capture dynamic environment in a fn item; \\\n@@ -223,10 +223,11 @@ fn check_fn(\n \n     // Check kinds on free variables:\n     with_appropriate_checker(cx, fn_id, |chk| {\n-        let r = freevars::get_freevars(cx.tcx, fn_id);\n-        for fv in r.iter() {\n-            chk(cx, *fv);\n-        }\n+        freevars::with_freevars(cx.tcx, fn_id, |r| {\n+            for fv in r.iter() {\n+                chk(cx, fv);\n+            }\n+        })\n     });\n \n     visit::walk_fn(cx, fk, decl, body, sp, fn_id, ());"}, {"sha": "53d3dec671301d1e9a6a218087a1f00fce757b2c", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=186ac7116c555ba90031eab71fa27dd71326bf6a", "patch": "@@ -544,7 +544,7 @@ impl<'a> VisitContext<'a> {\n                     self.use_pat(a.pat);\n                 }\n                 let cap_vars = self.compute_captures(expr.id);\n-                self.move_maps.capture_map.insert(expr.id, cap_vars);\n+                self.move_maps.capture_map.insert(expr.id, Rc::new(cap_vars));\n                 self.consume_block(body);\n             }\n \n@@ -639,34 +639,35 @@ impl<'a> VisitContext<'a> {\n         self.consume_expr(arg_expr)\n     }\n \n-    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> Rc<Vec<CaptureVar> > {\n+    fn compute_captures(&mut self, fn_expr_id: NodeId) -> Vec<CaptureVar> {\n         debug!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n-        let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n-        Rc::new(match ty::ty_closure_store(fn_ty) {\n-            ty::RegionTraitStore(..) => {\n-                // || captures everything by ref\n-                freevars.iter()\n-                        .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n-                        .collect()\n-            }\n-            ty::UniqTraitStore => {\n-                // proc captures by copy or by move depending on type\n-                freevars.iter()\n-                        .map(|fvar| {\n-                    let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n-                    let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n-                    debug!(\"fvar_def_id={:?} fvar_ty={}\",\n-                        fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n-                    let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n-                        CapMove\n-                    } else {\n-                        CapCopy\n-                    };\n-                    CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n-                }).collect()\n+        freevars::with_freevars(self.tcx, fn_expr_id, |freevars| {\n+            match ty::ty_closure_store(fn_ty) {\n+                ty::RegionTraitStore(..) => {\n+                    // || captures everything by ref\n+                    freevars.iter()\n+                            .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n+                            .collect()\n+                }\n+                ty::UniqTraitStore => {\n+                    // proc captures by copy or by move depending on type\n+                    freevars.iter()\n+                            .map(|fvar| {\n+                        let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n+                        let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n+                        debug!(\"fvar_def_id={:?} fvar_ty={}\",\n+                            fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n+                        let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n+                            CapMove\n+                        } else {\n+                            CapCopy\n+                        };\n+                        CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n+                    }).collect()\n+                }\n             }\n         })\n     }"}, {"sha": "c8c878d6c2a2eddd74a9cdedf0eb68bfa4865dbe", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/186ac7116c555ba90031eab71fa27dd71326bf6a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=186ac7116c555ba90031eab71fa27dd71326bf6a", "patch": "@@ -611,20 +611,21 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     match ty::get(function_type).sty {\n         ty::ty_closure(~ty::ClosureTy {\n                 store: ty::RegionTraitStore(region, _), ..}) => {\n-            let freevars = freevars::get_freevars(tcx, expr.id);\n-            if freevars.is_empty() {\n-                // No free variables means that the environment\n-                // will be NULL at runtime and hence the closure\n-                // has static lifetime.\n-            } else {\n-                // Closure must not outlive the variables it closes over.\n-                constrain_free_variables(rcx, region, expr, freevars);\n-\n-                // Closure cannot outlive the appropriate temporary scope.\n-                let s = rcx.repeating_scope;\n-                rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n-                                region, ty::ReScope(s));\n-            }\n+            freevars::with_freevars(tcx, expr.id, |freevars| {\n+                if freevars.is_empty() {\n+                    // No free variables means that the environment\n+                    // will be NULL at runtime and hence the closure\n+                    // has static lifetime.\n+                } else {\n+                    // Closure must not outlive the variables it closes over.\n+                    constrain_free_variables(rcx, region, expr, freevars);\n+\n+                    // Closure cannot outlive the appropriate temporary scope.\n+                    let s = rcx.repeating_scope;\n+                    rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n+                                    region, ty::ReScope(s));\n+                }\n+            });\n         }\n         _ => ()\n     }\n@@ -635,16 +636,17 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     match ty::get(function_type).sty {\n         ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n-            let freevars = freevars::get_freevars(tcx, expr.id);\n-            propagate_upupvar_borrow_kind(rcx, expr, freevars);\n+            freevars::with_freevars(tcx, expr.id, |freevars| {\n+                propagate_upupvar_borrow_kind(rcx, expr, freevars);\n+            });\n         }\n         _ => ()\n     }\n \n     fn constrain_free_variables(rcx: &mut Rcx,\n                                 region: ty::Region,\n                                 expr: &ast::Expr,\n-                                freevars: freevars::freevar_info) {\n+                                freevars: &[freevars::freevar_entry]) {\n         /*!\n          * Make sure that all free variables referenced inside the closure\n          * outlive the closure itself. Also, create an entry in the\n@@ -690,7 +692,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     fn propagate_upupvar_borrow_kind(rcx: &mut Rcx,\n                                      expr: &ast::Expr,\n-                                     freevars: freevars::freevar_info) {\n+                                     freevars: &[freevars::freevar_entry]) {\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"propagate_upupvar_borrow_kind({})\", expr.repr(tcx));\n         for freevar in freevars.iter() {"}]}