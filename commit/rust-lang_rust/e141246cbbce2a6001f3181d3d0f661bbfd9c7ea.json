{"sha": "e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "node_id": "C_kwDOAAsO6NoAKGUxNDEyNDZjYmJjZTJhNjAwMWYzMTgxZDNkMGY2NjFiYmZkOWM3ZWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T04:50:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T04:50:42Z"}, "message": "Auto merge of #100082 - matthiaskrgr:rollup-ywu4iux, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #99933 (parallelize HTML checking tool)\n - #99958 (Improve position named arguments lint underline and formatting names)\n - #100008 (Update all pre-cloned submodules on startup)\n - #100049 (:arrow_up: rust-analyzer)\n - #100070 (Clarify Cargo.toml comments)\n - #100074 (rustc-docs: Be less specific about the representation of `+bundle`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1b5d478cb8ea19987952a47af2df2cc043294443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b5d478cb8ea19987952a47af2df2cc043294443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "html_url": "https://github.com/rust-lang/rust/commit/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b759b2efad2d9c713eeab19bf90736a12ff0d74c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b759b2efad2d9c713eeab19bf90736a12ff0d74c", "html_url": "https://github.com/rust-lang/rust/commit/b759b2efad2d9c713eeab19bf90736a12ff0d74c"}, {"sha": "e20f7f83c04e03ee0e758394092794ff2f3e332e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e20f7f83c04e03ee0e758394092794ff2f3e332e", "html_url": "https://github.com/rust-lang/rust/commit/e20f7f83c04e03ee0e758394092794ff2f3e332e"}], "stats": {"total": 1526, "additions": 1103, "deletions": 423}, "files": [{"sha": "7592b08febea9ea63b9a99025ca2977f08d0c6b2", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -1788,6 +1788,7 @@ dependencies = [\n name = \"html-checker\"\n version = \"0.1.0\"\n dependencies = [\n+ \"rayon\",\n  \"walkdir\",\n ]\n "}, {"sha": "cec574e38c579b1c2f901282a4f96d251cf6ac58", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 59, "deletions": 25, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -16,6 +16,7 @@ use smallvec::SmallVec;\n \n use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n+use rustc_parse_format::Count;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n \n@@ -57,26 +58,45 @@ struct PositionalNamedArg {\n     replacement: Symbol,\n     /// The span for the positional named argument (so the lint can point a message to it)\n     positional_named_arg_span: Span,\n+    has_formatting: bool,\n }\n \n impl PositionalNamedArg {\n-    /// Determines what span to replace with the name of the named argument\n-    fn get_span_to_replace(&self, cx: &Context<'_, '_>) -> Option<Span> {\n+    /// Determines:\n+    /// 1) span to be replaced with the name of the named argument and\n+    /// 2) span to be underlined for error messages\n+    fn get_positional_arg_spans(&self, cx: &Context<'_, '_>) -> (Option<Span>, Option<Span>) {\n         if let Some(inner_span) = &self.inner_span_to_replace {\n-            return Some(\n-                cx.fmtsp.from_inner(InnerSpan { start: inner_span.start, end: inner_span.end }),\n-            );\n+            let span =\n+                cx.fmtsp.from_inner(InnerSpan { start: inner_span.start, end: inner_span.end });\n+            (Some(span), Some(span))\n         } else if self.ty == PositionalNamedArgType::Arg {\n-            // In the case of a named argument whose position is implicit, there will not be a span\n-            // to replace. Instead, we insert the name after the `{`, which is the first character\n-            // of arg_span.\n-            return cx\n-                .arg_spans\n-                .get(self.cur_piece)\n-                .map(|arg_span| arg_span.with_lo(arg_span.lo() + BytePos(1)).shrink_to_lo());\n+            // In the case of a named argument whose position is implicit, if the argument *has*\n+            // formatting, there will not be a span to replace. Instead, we insert the name after\n+            // the `{`, which will be the first character of arg_span. If the argument does *not*\n+            // have formatting, there may or may not be a span to replace. This is because\n+            // whitespace is allowed in arguments without formatting (such as `format!(\"{  }\", 1);`)\n+            // but is not allowed in arguments with formatting (an error will be generated in cases\n+            // like `format!(\"{ :1.1}\", 1.0f32);`.\n+            // For the message span, if there is formatting, we want to use the opening `{` and the\n+            // next character, which will the `:` indicating the start of formatting. If there is\n+            // not any formatting, we want to underline the entire span.\n+            cx.arg_spans.get(self.cur_piece).map_or((None, None), |arg_span| {\n+                if self.has_formatting {\n+                    (\n+                        Some(arg_span.with_lo(arg_span.lo() + BytePos(1)).shrink_to_lo()),\n+                        Some(arg_span.with_hi(arg_span.lo() + BytePos(2))),\n+                    )\n+                } else {\n+                    let replace_start = arg_span.lo() + BytePos(1);\n+                    let replace_end = arg_span.hi() - BytePos(1);\n+                    let to_replace = arg_span.with_lo(replace_start).with_hi(replace_end);\n+                    (Some(to_replace), Some(*arg_span))\n+                }\n+            })\n+        } else {\n+            (None, None)\n         }\n-\n-        None\n     }\n }\n \n@@ -117,10 +137,18 @@ impl PositionalNamedArgsLint {\n         cur_piece: usize,\n         inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n         names: &FxHashMap<Symbol, (usize, Span)>,\n+        has_formatting: bool,\n     ) {\n         let start_of_named_args = total_args_length - names.len();\n         if current_positional_arg >= start_of_named_args {\n-            self.maybe_push(format_argument_index, ty, cur_piece, inner_span_to_replace, names)\n+            self.maybe_push(\n+                format_argument_index,\n+                ty,\n+                cur_piece,\n+                inner_span_to_replace,\n+                names,\n+                has_formatting,\n+            )\n         }\n     }\n \n@@ -134,6 +162,7 @@ impl PositionalNamedArgsLint {\n         cur_piece: usize,\n         inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n         names: &FxHashMap<Symbol, (usize, Span)>,\n+        has_formatting: bool,\n     ) {\n         let named_arg = names\n             .iter()\n@@ -156,6 +185,7 @@ impl PositionalNamedArgsLint {\n                 inner_span_to_replace,\n                 replacement,\n                 positional_named_arg_span,\n+                has_formatting,\n             });\n         }\n     }\n@@ -414,6 +444,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                     PositionalNamedArgType::Precision,\n                 );\n \n+                let has_precision = arg.format.precision != Count::CountImplied;\n+                let has_width = arg.format.width != Count::CountImplied;\n+\n                 // argument second, if it's an implicit positional parameter\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n@@ -426,6 +459,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             self.curpiece,\n                             Some(arg.position_span),\n                             &self.names,\n+                            has_precision || has_width,\n                         );\n \n                         Exact(i)\n@@ -439,6 +473,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             self.curpiece,\n                             None,\n                             &self.names,\n+                            has_precision || has_width,\n                         );\n                         Exact(i)\n                     }\n@@ -530,6 +565,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.curpiece,\n                     *inner_span,\n                     &self.names,\n+                    true,\n                 );\n                 self.verify_arg_type(Exact(i), Count);\n             }\n@@ -1152,24 +1188,22 @@ pub fn expand_format_args_nl<'cx>(\n \n fn create_lints_for_named_arguments_used_positionally(cx: &mut Context<'_, '_>) {\n     for named_arg in &cx.unused_names_lint.positional_named_args {\n-        let arg_span = named_arg.get_span_to_replace(cx);\n+        let (position_sp_to_replace, position_sp_for_msg) = named_arg.get_positional_arg_spans(cx);\n \n         let msg = format!(\"named argument `{}` is not used by name\", named_arg.replacement);\n-        let replacement = match named_arg.ty {\n-            PositionalNamedArgType::Arg => named_arg.replacement.to_string(),\n-            _ => named_arg.replacement.to_string() + \"$\",\n-        };\n \n         cx.ecx.buffered_early_lint.push(BufferedEarlyLint {\n             span: MultiSpan::from_span(named_arg.positional_named_arg_span),\n             msg: msg.clone(),\n             node_id: ast::CRATE_NODE_ID,\n             lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n-            diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally(\n-                arg_span,\n-                named_arg.positional_named_arg_span,\n-                replacement,\n-            ),\n+            diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally {\n+                position_sp_to_replace,\n+                position_sp_for_msg,\n+                named_arg_sp: named_arg.positional_named_arg_span,\n+                named_arg_name: named_arg.replacement.to_string(),\n+                is_formatting_arg: named_arg.ty != PositionalNamedArgType::Arg,\n+            },\n         });\n     }\n }"}, {"sha": "b95fc341db656c0091b92020eb726ba7f4450bdd", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -856,13 +856,18 @@ pub trait LintContext: Sized {\n                         Applicability::MachineApplicable,\n                     );\n                 },\n-                BuiltinLintDiagnostics::NamedArgumentUsedPositionally(positional_arg, named_arg, name) => {\n-                    db.span_label(named_arg, \"this named argument is only referred to by position in formatting string\");\n-                    if let Some(positional_arg) = positional_arg {\n-                        let msg = format!(\"this formatting argument uses named argument `{}` by position\", name);\n-                        db.span_label(positional_arg, msg);\n+                BuiltinLintDiagnostics::NamedArgumentUsedPositionally{ position_sp_to_replace, position_sp_for_msg, named_arg_sp, named_arg_name, is_formatting_arg} => {\n+                    db.span_label(named_arg_sp, \"this named argument is referred to by position in formatting string\");\n+                    if let Some(positional_arg_for_msg) = position_sp_for_msg {\n+                        let msg = format!(\"this formatting argument uses named argument `{}` by position\", named_arg_name);\n+                        db.span_label(positional_arg_for_msg, msg);\n+                    }\n+\n+                    if let Some(positional_arg_to_replace) = position_sp_to_replace {\n+                        let name = if is_formatting_arg { named_arg_name + \"$\" } else { named_arg_name };\n+\n                         db.span_suggestion_verbose(\n-                            positional_arg,\n+                            positional_arg_to_replace,\n                             \"use the named argument by name to avoid ambiguity\",\n                             name,\n                             Applicability::MaybeIncorrect,"}, {"sha": "6acbe97a7a118d13093351c045ccd54a90f41ac5", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -467,7 +467,19 @@ pub enum BuiltinLintDiagnostics {\n         /// If true, the lifetime will be fully elided.\n         use_span: Option<(Span, bool)>,\n     },\n-    NamedArgumentUsedPositionally(Option<Span>, Span, String),\n+    NamedArgumentUsedPositionally {\n+        /// Span where the named argument is used by position and will be replaced with the named\n+        /// argument name\n+        position_sp_to_replace: Option<Span>,\n+        /// Span where the named argument is used by position and is used for lint messages\n+        position_sp_for_msg: Option<Span>,\n+        /// Span where the named argument's name is (so we know where to put the warning message)\n+        named_arg_sp: Span,\n+        /// String containing the named arguments name\n+        named_arg_name: String,\n+        /// Indicates if the named argument is used as a width/precision for formatting\n+        is_formatting_arg: bool,\n+    },\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "f84de73297acb066e0d0988d4fd0a610fbc1ad51", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -624,20 +624,6 @@ impl Build {\n     /// If any submodule has been initialized already, sync it unconditionally.\n     /// This avoids contributors checking in a submodule change by accident.\n     pub fn maybe_update_submodules(&self) {\n-        // WARNING: keep this in sync with the submodules hard-coded in bootstrap.py\n-        let mut bootstrap_submodules: Vec<&str> = vec![\n-            \"src/tools/rust-installer\",\n-            \"src/tools/cargo\",\n-            \"src/tools/rls\",\n-            \"src/tools/miri\",\n-            \"library/backtrace\",\n-            \"library/stdarch\",\n-        ];\n-        // As in bootstrap.py, we include `rust-analyzer` if `build.vendor` was set in\n-        // `config.toml`.\n-        if self.config.vendor {\n-            bootstrap_submodules.push(\"src/tools/rust-analyzer\");\n-        }\n         // Avoid running git when there isn't a git checkout.\n         if !self.config.submodules(&self.rust_info) {\n             return;\n@@ -653,10 +639,8 @@ impl Build {\n             // Look for `submodule.$name.path = $path`\n             // Sample output: `submodule.src/rust-installer.path src/tools/rust-installer`\n             let submodule = Path::new(line.splitn(2, ' ').nth(1).unwrap());\n-            // avoid updating submodules twice\n-            if !bootstrap_submodules.iter().any(|&p| Path::new(p) == submodule)\n-                && channel::GitInfo::new(false, submodule).is_git()\n-            {\n+            // Don't update the submodule unless it's already been cloned.\n+            if channel::GitInfo::new(false, submodule).is_git() {\n                 self.update_submodule(submodule);\n             }\n         }"}, {"sha": "f05ff3f1b6b4e5c95ec60a6b0a0973a43cc58fb2", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -89,9 +89,9 @@ but it is not guaranteed. If you need whole archive semantics use `+whole-archiv\n This modifier is only compatible with the `static` linking kind.\n Using any other kind will result in a compiler error.\n \n-When building a rlib or staticlib `+bundle` means that all object files from the native static\n-library will be added to the rlib or staticlib archive, and then used from it during linking of\n-the final binary.\n+When building a rlib or staticlib `+bundle` means that the native static library\n+will be packed into the rlib or staticlib archive, and then retrieved from there\n+during linking of the final binary.\n \n When building a rlib `-bundle` means that the native static library is registered as a dependency\n of that rlib \"by name\", and object files from it are included only during linking of the final"}, {"sha": "c93451c761ae4f3619c0f8b75790b1c2e4da88a4", "filename": "src/test/ui/macros/issue-98466.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-98466.stderr?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -2,9 +2,9 @@ warning: named argument `_x` is not used by name\n   --> $DIR/issue-98466.rs:7:26\n    |\n LL |     println!(\"_x is {}\", _x = 5);\n-   |                      -   ^^ this named argument is only referred to by position in formatting string\n-   |                      |\n-   |                      this formatting argument uses named argument `_x` by position\n+   |                     --   ^^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `_x` by position\n    |\n    = note: `#[warn(named_arguments_used_positionally)]` on by default\n help: use the named argument by name to avoid ambiguity\n@@ -16,9 +16,9 @@ warning: named argument `y` is not used by name\n   --> $DIR/issue-98466.rs:10:26\n    |\n LL |     println!(\"_x is {}\", y = _x);\n-   |                      -   ^ this named argument is only referred to by position in formatting string\n-   |                      |\n-   |                      this formatting argument uses named argument `y` by position\n+   |                     --   ^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `y` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -29,9 +29,9 @@ warning: named argument `y` is not used by name\n   --> $DIR/issue-98466.rs:13:83\n    |\n LL |     println!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n-   |                                                                         -         ^ this named argument is only referred to by position in formatting string\n-   |                                                                         |\n-   |                                                                         this formatting argument uses named argument `y` by position\n+   |                                                                        --         ^ this named argument is referred to by position in formatting string\n+   |                                                                        |\n+   |                                                                        this formatting argument uses named argument `y` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -42,9 +42,9 @@ warning: named argument `_x` is not used by name\n   --> $DIR/issue-98466.rs:19:34\n    |\n LL |     let _f = format!(\"_x is {}\", _x = 5);\n-   |                              -   ^^ this named argument is only referred to by position in formatting string\n-   |                              |\n-   |                              this formatting argument uses named argument `_x` by position\n+   |                             --   ^^ this named argument is referred to by position in formatting string\n+   |                             |\n+   |                             this formatting argument uses named argument `_x` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -55,9 +55,9 @@ warning: named argument `y` is not used by name\n   --> $DIR/issue-98466.rs:22:34\n    |\n LL |     let _f = format!(\"_x is {}\", y = _x);\n-   |                              -   ^ this named argument is only referred to by position in formatting string\n-   |                              |\n-   |                              this formatting argument uses named argument `y` by position\n+   |                             --   ^ this named argument is referred to by position in formatting string\n+   |                             |\n+   |                             this formatting argument uses named argument `y` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -68,9 +68,9 @@ warning: named argument `y` is not used by name\n   --> $DIR/issue-98466.rs:25:91\n    |\n LL |     let _f = format!(\"first positional arg {}, second positional arg {}, _x is {}\", 1, 2, y = _x);\n-   |                                                                                 -         ^ this named argument is only referred to by position in formatting string\n-   |                                                                                 |\n-   |                                                                                 this formatting argument uses named argument `y` by position\n+   |                                                                                --         ^ this named argument is referred to by position in formatting string\n+   |                                                                                |\n+   |                                                                                this formatting argument uses named argument `y` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |"}, {"sha": "2bfeedd7d07370312c8e0fc1fa6bf1063d61283b", "filename": "src/test/ui/macros/issue-99265.stderr", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-99265.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-99265.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-99265.stderr?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -2,9 +2,9 @@ warning: named argument `a` is not used by name\n   --> $DIR/issue-99265.rs:5:24\n    |\n LL |     println!(\"{b} {}\", a=1, b=2);\n-   |                    -   ^ this named argument is only referred to by position in formatting string\n-   |                    |\n-   |                    this formatting argument uses named argument `a` by position\n+   |                   --   ^ this named argument is referred to by position in formatting string\n+   |                   |\n+   |                   this formatting argument uses named argument `a` by position\n    |\n    = note: `#[warn(named_arguments_used_positionally)]` on by default\n help: use the named argument by name to avoid ambiguity\n@@ -16,9 +16,9 @@ warning: named argument `a` is not used by name\n   --> $DIR/issue-99265.rs:9:35\n    |\n LL |     println!(\"{} {} {} {} {}\", 0, a=1, b=2, c=3, d=4);\n-   |                   -               ^ this named argument is only referred to by position in formatting string\n-   |                   |\n-   |                   this formatting argument uses named argument `a` by position\n+   |                  --               ^ this named argument is referred to by position in formatting string\n+   |                  |\n+   |                  this formatting argument uses named argument `a` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -29,9 +29,9 @@ warning: named argument `b` is not used by name\n   --> $DIR/issue-99265.rs:9:40\n    |\n LL |     println!(\"{} {} {} {} {}\", 0, a=1, b=2, c=3, d=4);\n-   |                      -                 ^ this named argument is only referred to by position in formatting string\n-   |                      |\n-   |                      this formatting argument uses named argument `b` by position\n+   |                     --                 ^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `b` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -42,9 +42,9 @@ warning: named argument `c` is not used by name\n   --> $DIR/issue-99265.rs:9:45\n    |\n LL |     println!(\"{} {} {} {} {}\", 0, a=1, b=2, c=3, d=4);\n-   |                         -                   ^ this named argument is only referred to by position in formatting string\n-   |                         |\n-   |                         this formatting argument uses named argument `c` by position\n+   |                        --                   ^ this named argument is referred to by position in formatting string\n+   |                        |\n+   |                        this formatting argument uses named argument `c` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -55,9 +55,9 @@ warning: named argument `d` is not used by name\n   --> $DIR/issue-99265.rs:9:50\n    |\n LL |     println!(\"{} {} {} {} {}\", 0, a=1, b=2, c=3, d=4);\n-   |                            -                     ^ this named argument is only referred to by position in formatting string\n-   |                            |\n-   |                            this formatting argument uses named argument `d` by position\n+   |                           --                     ^ this named argument is referred to by position in formatting string\n+   |                           |\n+   |                           this formatting argument uses named argument `d` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -68,9 +68,9 @@ warning: named argument `width` is not used by name\n   --> $DIR/issue-99265.rs:19:35\n    |\n LL |     println!(\"Hello {:1$}!\", \"x\", width = 5);\n-   |                       --          ^^^^^ this named argument is only referred to by position in formatting string\n+   |                       --          ^^^^^ this named argument is referred to by position in formatting string\n    |                       |\n-   |                       this formatting argument uses named argument `width$` by position\n+   |                       this formatting argument uses named argument `width` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -81,9 +81,9 @@ warning: named argument `width` is not used by name\n   --> $DIR/issue-99265.rs:23:46\n    |\n LL |     println!(\"Hello {:1$.2$}!\", f = 0.02f32, width = 5, precision = 2);\n-   |                       --                     ^^^^^ this named argument is only referred to by position in formatting string\n+   |                       --                     ^^^^^ this named argument is referred to by position in formatting string\n    |                       |\n-   |                       this formatting argument uses named argument `width$` by position\n+   |                       this formatting argument uses named argument `width` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -94,9 +94,9 @@ warning: named argument `precision` is not used by name\n   --> $DIR/issue-99265.rs:23:57\n    |\n LL |     println!(\"Hello {:1$.2$}!\", f = 0.02f32, width = 5, precision = 2);\n-   |                          --                             ^^^^^^^^^ this named argument is only referred to by position in formatting string\n+   |                          --                             ^^^^^^^^^ this named argument is referred to by position in formatting string\n    |                          |\n-   |                          this formatting argument uses named argument `precision$` by position\n+   |                          this formatting argument uses named argument `precision` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -107,9 +107,9 @@ warning: named argument `f` is not used by name\n   --> $DIR/issue-99265.rs:23:33\n    |\n LL |     println!(\"Hello {:1$.2$}!\", f = 0.02f32, width = 5, precision = 2);\n-   |                      -          ^ this named argument is only referred to by position in formatting string\n-   |                      |\n-   |                      this formatting argument uses named argument `f` by position\n+   |                     --          ^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `f` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -120,9 +120,9 @@ warning: named argument `width` is not used by name\n   --> $DIR/issue-99265.rs:31:47\n    |\n LL |     println!(\"Hello {0:1$.2$}!\", f = 0.02f32, width = 5, precision = 2);\n-   |                        --                     ^^^^^ this named argument is only referred to by position in formatting string\n+   |                        --                     ^^^^^ this named argument is referred to by position in formatting string\n    |                        |\n-   |                        this formatting argument uses named argument `width$` by position\n+   |                        this formatting argument uses named argument `width` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -133,9 +133,9 @@ warning: named argument `precision` is not used by name\n   --> $DIR/issue-99265.rs:31:58\n    |\n LL |     println!(\"Hello {0:1$.2$}!\", f = 0.02f32, width = 5, precision = 2);\n-   |                           --                             ^^^^^^^^^ this named argument is only referred to by position in formatting string\n+   |                           --                             ^^^^^^^^^ this named argument is referred to by position in formatting string\n    |                           |\n-   |                           this formatting argument uses named argument `precision$` by position\n+   |                           this formatting argument uses named argument `precision` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -146,7 +146,7 @@ warning: named argument `f` is not used by name\n   --> $DIR/issue-99265.rs:31:34\n    |\n LL |     println!(\"Hello {0:1$.2$}!\", f = 0.02f32, width = 5, precision = 2);\n-   |                      -           ^ this named argument is only referred to by position in formatting string\n+   |                      -           ^ this named argument is referred to by position in formatting string\n    |                      |\n    |                      this formatting argument uses named argument `f` by position\n    |\n@@ -159,10 +159,10 @@ warning: named argument `width` is not used by name\n   --> $DIR/issue-99265.rs:52:9\n    |\n LL |         \"{}, Hello {1:2$.3$} {4:5$.6$}! {1}\",\n-   |                       -- this formatting argument uses named argument `width$` by position\n+   |                       -- this formatting argument uses named argument `width` by position\n ...\n LL |         width = 5,\n-   |         ^^^^^ this named argument is only referred to by position in formatting string\n+   |         ^^^^^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -173,10 +173,10 @@ warning: named argument `precision` is not used by name\n   --> $DIR/issue-99265.rs:54:9\n    |\n LL |         \"{}, Hello {1:2$.3$} {4:5$.6$}! {1}\",\n-   |                          -- this formatting argument uses named argument `precision$` by position\n+   |                          -- this formatting argument uses named argument `precision` by position\n ...\n LL |         precision = 2,\n-   |         ^^^^^^^^^ this named argument is only referred to by position in formatting string\n+   |         ^^^^^^^^^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -190,7 +190,7 @@ LL |         \"{}, Hello {1:2$.3$} {4:5$.6$}! {1}\",\n    |                     - this formatting argument uses named argument `f` by position\n ...\n LL |         f = 0.02f32,\n-   |         ^ this named argument is only referred to by position in formatting string\n+   |         ^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -201,10 +201,10 @@ warning: named argument `width2` is not used by name\n   --> $DIR/issue-99265.rs:58:9\n    |\n LL |         \"{}, Hello {1:2$.3$} {4:5$.6$}! {1}\",\n-   |                                 -- this formatting argument uses named argument `width2$` by position\n+   |                                 -- this formatting argument uses named argument `width2` by position\n ...\n LL |         width2 = 5,\n-   |         ^^^^^^ this named argument is only referred to by position in formatting string\n+   |         ^^^^^^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -215,10 +215,10 @@ warning: named argument `precision2` is not used by name\n   --> $DIR/issue-99265.rs:60:9\n    |\n LL |         \"{}, Hello {1:2$.3$} {4:5$.6$}! {1}\",\n-   |                                    -- this formatting argument uses named argument `precision2$` by position\n+   |                                    -- this formatting argument uses named argument `precision2` by position\n ...\n LL |         precision2 = 2\n-   |         ^^^^^^^^^^ this named argument is only referred to by position in formatting string\n+   |         ^^^^^^^^^^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -232,7 +232,7 @@ LL |         \"{}, Hello {1:2$.3$} {4:5$.6$}! {1}\",\n    |                               - this formatting argument uses named argument `g` by position\n ...\n LL |         g = 0.02f32,\n-   |         ^ this named argument is only referred to by position in formatting string\n+   |         ^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -246,7 +246,7 @@ LL |         \"{}, Hello {1:2$.3$} {4:5$.6$}! {1}\",\n    |                                          - this formatting argument uses named argument `f` by position\n ...\n LL |         f = 0.02f32,\n-   |         ^ this named argument is only referred to by position in formatting string\n+   |         ^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -257,9 +257,9 @@ warning: named argument `f` is not used by name\n   --> $DIR/issue-99265.rs:64:31\n    |\n LL |     println!(\"Hello {:0.1}!\", f = 0.02f32);\n-   |                      -        ^ this named argument is only referred to by position in formatting string\n-   |                      |\n-   |                      this formatting argument uses named argument `f` by position\n+   |                     --        ^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `f` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -270,7 +270,7 @@ warning: named argument `f` is not used by name\n   --> $DIR/issue-99265.rs:68:32\n    |\n LL |     println!(\"Hello {0:0.1}!\", f = 0.02f32);\n-   |                      -         ^ this named argument is only referred to by position in formatting string\n+   |                      -         ^ this named argument is referred to by position in formatting string\n    |                      |\n    |                      this formatting argument uses named argument `f` by position\n    |\n@@ -283,9 +283,9 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:79:23\n    |\n LL |     println!(\"{:0$}\", v = val);\n-   |                 --    ^ this named argument is only referred to by position in formatting string\n+   |                 --    ^ this named argument is referred to by position in formatting string\n    |                 |\n-   |                 this formatting argument uses named argument `v$` by position\n+   |                 this formatting argument uses named argument `v` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -296,9 +296,9 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:79:23\n    |\n LL |     println!(\"{:0$}\", v = val);\n-   |                -      ^ this named argument is only referred to by position in formatting string\n-   |                |\n-   |                this formatting argument uses named argument `v` by position\n+   |               --      ^ this named argument is referred to by position in formatting string\n+   |               |\n+   |               this formatting argument uses named argument `v` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -309,9 +309,9 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:84:24\n    |\n LL |     println!(\"{0:0$}\", v = val);\n-   |                  --    ^ this named argument is only referred to by position in formatting string\n+   |                  --    ^ this named argument is referred to by position in formatting string\n    |                  |\n-   |                  this formatting argument uses named argument `v$` by position\n+   |                  this formatting argument uses named argument `v` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -322,7 +322,7 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:84:24\n    |\n LL |     println!(\"{0:0$}\", v = val);\n-   |                -       ^ this named argument is only referred to by position in formatting string\n+   |                -       ^ this named argument is referred to by position in formatting string\n    |                |\n    |                this formatting argument uses named argument `v` by position\n    |\n@@ -335,9 +335,9 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:89:26\n    |\n LL |     println!(\"{:0$.0$}\", v = val);\n-   |                 --       ^ this named argument is only referred to by position in formatting string\n+   |                 --       ^ this named argument is referred to by position in formatting string\n    |                 |\n-   |                 this formatting argument uses named argument `v$` by position\n+   |                 this formatting argument uses named argument `v` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -348,9 +348,9 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:89:26\n    |\n LL |     println!(\"{:0$.0$}\", v = val);\n-   |                    --    ^ this named argument is only referred to by position in formatting string\n+   |                    --    ^ this named argument is referred to by position in formatting string\n    |                    |\n-   |                    this formatting argument uses named argument `v$` by position\n+   |                    this formatting argument uses named argument `v` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -361,9 +361,9 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:89:26\n    |\n LL |     println!(\"{:0$.0$}\", v = val);\n-   |                -         ^ this named argument is only referred to by position in formatting string\n-   |                |\n-   |                this formatting argument uses named argument `v` by position\n+   |               --         ^ this named argument is referred to by position in formatting string\n+   |               |\n+   |               this formatting argument uses named argument `v` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -374,9 +374,9 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:96:27\n    |\n LL |     println!(\"{0:0$.0$}\", v = val);\n-   |                  --       ^ this named argument is only referred to by position in formatting string\n+   |                  --       ^ this named argument is referred to by position in formatting string\n    |                  |\n-   |                  this formatting argument uses named argument `v$` by position\n+   |                  this formatting argument uses named argument `v` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -387,9 +387,9 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:96:27\n    |\n LL |     println!(\"{0:0$.0$}\", v = val);\n-   |                     --    ^ this named argument is only referred to by position in formatting string\n+   |                     --    ^ this named argument is referred to by position in formatting string\n    |                     |\n-   |                     this formatting argument uses named argument `v$` by position\n+   |                     this formatting argument uses named argument `v` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -400,7 +400,7 @@ warning: named argument `v` is not used by name\n   --> $DIR/issue-99265.rs:96:27\n    |\n LL |     println!(\"{0:0$.0$}\", v = val);\n-   |                -          ^ this named argument is only referred to by position in formatting string\n+   |                -          ^ this named argument is referred to by position in formatting string\n    |                |\n    |                this formatting argument uses named argument `v` by position\n    |\n@@ -413,9 +413,9 @@ warning: named argument `a` is not used by name\n   --> $DIR/issue-99265.rs:104:28\n    |\n LL |     println!(\"{} {a} {0}\", a = 1);\n-   |                -           ^ this named argument is only referred to by position in formatting string\n-   |                |\n-   |                this formatting argument uses named argument `a` by position\n+   |               --           ^ this named argument is referred to by position in formatting string\n+   |               |\n+   |               this formatting argument uses named argument `a` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -426,7 +426,7 @@ warning: named argument `a` is not used by name\n   --> $DIR/issue-99265.rs:104:28\n    |\n LL |     println!(\"{} {a} {0}\", a = 1);\n-   |                       -    ^ this named argument is only referred to by position in formatting string\n+   |                       -    ^ this named argument is referred to by position in formatting string\n    |                       |\n    |                       this formatting argument uses named argument `a` by position\n    |\n@@ -439,10 +439,10 @@ warning: named argument `b` is not used by name\n   --> $DIR/issue-99265.rs:115:23\n    |\n LL |                 {:1$.2$}\",\n-   |                   -- this formatting argument uses named argument `b$` by position\n+   |                   -- this formatting argument uses named argument `b` by position\n ...\n LL |              a = 1.0, b = 1, c = 2,\n-   |                       ^ this named argument is only referred to by position in formatting string\n+   |                       ^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -453,10 +453,10 @@ warning: named argument `c` is not used by name\n   --> $DIR/issue-99265.rs:115:30\n    |\n LL |                 {:1$.2$}\",\n-   |                      -- this formatting argument uses named argument `c$` by position\n+   |                      -- this formatting argument uses named argument `c` by position\n ...\n LL |              a = 1.0, b = 1, c = 2,\n-   |                              ^ this named argument is only referred to by position in formatting string\n+   |                              ^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -467,10 +467,10 @@ warning: named argument `a` is not used by name\n   --> $DIR/issue-99265.rs:115:14\n    |\n LL |                 {:1$.2$}\",\n-   |                  - this formatting argument uses named argument `a` by position\n+   |                 -- this formatting argument uses named argument `a` by position\n ...\n LL |              a = 1.0, b = 1, c = 2,\n-   |              ^ this named argument is only referred to by position in formatting string\n+   |              ^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -481,10 +481,10 @@ warning: named argument `b` is not used by name\n   --> $DIR/issue-99265.rs:126:23\n    |\n LL |                 {0:1$.2$}\",\n-   |                    -- this formatting argument uses named argument `b$` by position\n+   |                    -- this formatting argument uses named argument `b` by position\n ...\n LL |              a = 1.0, b = 1, c = 2,\n-   |                       ^ this named argument is only referred to by position in formatting string\n+   |                       ^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -495,10 +495,10 @@ warning: named argument `c` is not used by name\n   --> $DIR/issue-99265.rs:126:30\n    |\n LL |                 {0:1$.2$}\",\n-   |                       -- this formatting argument uses named argument `c$` by position\n+   |                       -- this formatting argument uses named argument `c` by position\n ...\n LL |              a = 1.0, b = 1, c = 2,\n-   |                              ^ this named argument is only referred to by position in formatting string\n+   |                              ^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -512,7 +512,7 @@ LL |                 {0:1$.2$}\",\n    |                  - this formatting argument uses named argument `a` by position\n ...\n LL |              a = 1.0, b = 1, c = 2,\n-   |              ^ this named argument is only referred to by position in formatting string\n+   |              ^ this named argument is referred to by position in formatting string\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -523,9 +523,9 @@ warning: named argument `width` is not used by name\n   --> $DIR/issue-99265.rs:132:39\n    |\n LL |     println!(\"{{{:1$.2$}}}\", x = 1.0, width = 3, precision = 2);\n-   |                   --                  ^^^^^ this named argument is only referred to by position in formatting string\n+   |                   --                  ^^^^^ this named argument is referred to by position in formatting string\n    |                   |\n-   |                   this formatting argument uses named argument `width$` by position\n+   |                   this formatting argument uses named argument `width` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -536,9 +536,9 @@ warning: named argument `precision` is not used by name\n   --> $DIR/issue-99265.rs:132:50\n    |\n LL |     println!(\"{{{:1$.2$}}}\", x = 1.0, width = 3, precision = 2);\n-   |                      --                          ^^^^^^^^^ this named argument is only referred to by position in formatting string\n+   |                      --                          ^^^^^^^^^ this named argument is referred to by position in formatting string\n    |                      |\n-   |                      this formatting argument uses named argument `precision$` by position\n+   |                      this formatting argument uses named argument `precision` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |\n@@ -549,9 +549,9 @@ warning: named argument `x` is not used by name\n   --> $DIR/issue-99265.rs:132:30\n    |\n LL |     println!(\"{{{:1$.2$}}}\", x = 1.0, width = 3, precision = 2);\n-   |                  -           ^ this named argument is only referred to by position in formatting string\n-   |                  |\n-   |                  this formatting argument uses named argument `x` by position\n+   |                 --           ^ this named argument is referred to by position in formatting string\n+   |                 |\n+   |                 this formatting argument uses named argument `x` by position\n    |\n help: use the named argument by name to avoid ambiguity\n    |"}, {"sha": "9e0e1b80ee59fbb24fd3a2755a06ec54bcf74a0d", "filename": "src/test/ui/macros/issue-99907.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-99907.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-99907.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-99907.fixed?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+// run-rustfix\n+\n+fn main() {\n+    println!(\"Hello {f:.1}!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    println!(\"Hello {f:1.1}!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    println!(\"Hello {f}!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    println!(\"Hello {f}!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    println!(\"Hello {f}!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+}"}, {"sha": "eebcfc2efecc9d097b40db2c16604760b538af8e", "filename": "src/test/ui/macros/issue-99907.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-99907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-99907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-99907.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+// run-rustfix\n+\n+fn main() {\n+    println!(\"Hello {:.1}!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    println!(\"Hello {:1.1}!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    println!(\"Hello {}!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    println!(\"Hello { }!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+\n+    println!(\"Hello {  }!\", f = 0.02f32);\n+    //~^ WARNING named argument `f` is not used by name [named_arguments_used_positionally]\n+    //~| HELP use the named argument by name to avoid ambiguity\n+}"}, {"sha": "4786ce003b4c2462d7fce35b4047632af1e73a09", "filename": "src/test/ui/macros/issue-99907.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-99907.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftest%2Fui%2Fmacros%2Fissue-99907.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-99907.stderr?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -0,0 +1,68 @@\n+warning: named argument `f` is not used by name\n+  --> $DIR/issue-99907.rs:5:30\n+   |\n+LL |     println!(\"Hello {:.1}!\", f = 0.02f32);\n+   |                     --       ^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `f` by position\n+   |\n+   = note: `#[warn(named_arguments_used_positionally)]` on by default\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"Hello {f:.1}!\", f = 0.02f32);\n+   |                      +\n+\n+warning: named argument `f` is not used by name\n+  --> $DIR/issue-99907.rs:9:31\n+   |\n+LL |     println!(\"Hello {:1.1}!\", f = 0.02f32);\n+   |                     --        ^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `f` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"Hello {f:1.1}!\", f = 0.02f32);\n+   |                      +\n+\n+warning: named argument `f` is not used by name\n+  --> $DIR/issue-99907.rs:13:27\n+   |\n+LL |     println!(\"Hello {}!\", f = 0.02f32);\n+   |                     --    ^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `f` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"Hello {f}!\", f = 0.02f32);\n+   |                      +\n+\n+warning: named argument `f` is not used by name\n+  --> $DIR/issue-99907.rs:17:28\n+   |\n+LL |     println!(\"Hello { }!\", f = 0.02f32);\n+   |                     ---    ^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `f` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"Hello {f}!\", f = 0.02f32);\n+   |                      +\n+\n+warning: named argument `f` is not used by name\n+  --> $DIR/issue-99907.rs:21:29\n+   |\n+LL |     println!(\"Hello {  }!\", f = 0.02f32);\n+   |                     ----    ^ this named argument is referred to by position in formatting string\n+   |                     |\n+   |                     this formatting argument uses named argument `f` by position\n+   |\n+help: use the named argument by name to avoid ambiguity\n+   |\n+LL |     println!(\"Hello {f}!\", f = 0.02f32);\n+   |                      +\n+\n+warning: 5 warnings emitted\n+"}, {"sha": "72d61d9bd2638048050344c787a97d84d11c6a63", "filename": "src/tools/html-checker/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Fhtml-checker%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Fhtml-checker%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fhtml-checker%2FCargo.toml?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -9,3 +9,4 @@ path = \"main.rs\"\n \n [dependencies]\n walkdir = \"2\"\n+rayon = \"1.5\""}, {"sha": "9b4d2c52598068892f8277f1b7bff44a6b23a6f4", "filename": "src/tools/html-checker/main.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Fhtml-checker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Fhtml-checker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fhtml-checker%2Fmain.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -1,3 +1,4 @@\n+use rayon::iter::{ParallelBridge, ParallelIterator};\n use std::env;\n use std::path::Path;\n use std::process::{Command, Output};\n@@ -56,27 +57,30 @@ const DOCS_TO_CHECK: &[&str] =\n \n // Returns the number of files read and the number of errors.\n fn find_all_html_files(dir: &Path) -> (usize, usize) {\n-    let mut files_read = 0;\n-    let mut errors = 0;\n-\n-    for entry in walkdir::WalkDir::new(dir).into_iter().filter_entry(|e| {\n-        e.depth() != 1\n-            || e.file_name()\n-                .to_str()\n-                .map(|s| DOCS_TO_CHECK.into_iter().any(|d| *d == s))\n-                .unwrap_or(false)\n-    }) {\n-        let entry = entry.expect(\"failed to read file\");\n-        if !entry.file_type().is_file() {\n-            continue;\n-        }\n-        let entry = entry.path();\n-        if entry.extension().and_then(|s| s.to_str()) == Some(\"html\") {\n-            errors += check_html_file(&entry);\n-            files_read += 1;\n-        }\n-    }\n-    (files_read, errors)\n+    walkdir::WalkDir::new(dir)\n+        .into_iter()\n+        .filter_entry(|e| {\n+            e.depth() != 1\n+                || e.file_name()\n+                    .to_str()\n+                    .map(|s| DOCS_TO_CHECK.into_iter().any(|d| *d == s))\n+                    .unwrap_or(false)\n+        })\n+        .par_bridge()\n+        .map(|entry| {\n+            let entry = entry.expect(\"failed to read file\");\n+            if !entry.file_type().is_file() {\n+                return (0, 0);\n+            }\n+            let entry = entry.path();\n+            // (Number of files processed, number of errors)\n+            if entry.extension().and_then(|s| s.to_str()) == Some(\"html\") {\n+                (1, check_html_file(&entry))\n+            } else {\n+                (0, 0)\n+            }\n+        })\n+        .reduce(|| (0, 0), |a, b| (a.0 + b.0, a.1 + b.1))\n }\n \n /// Default `tidy` command for macOS is too old that it does not have `mute-id` and `mute` options."}, {"sha": "a4497f49e3c2f8c5193aea300b044251ec262463", "filename": "src/tools/rust-analyzer/.github/workflows/publish.yml", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -34,8 +34,21 @@ jobs:\n           git config --global user.email \"runner@gha.local\"\n           git config --global user.name \"Github Action\"\n           rm Cargo.lock\n+          # Fix names for crates that were published before switch to kebab-case.\n+          cargo workspaces rename --from base-db base_db\n+          cargo workspaces rename --from hir-def hir_def\n+          cargo workspaces rename --from hir-expand hir_expand\n+          cargo workspaces rename --from hir-ty hir_ty\n+          cargo workspaces rename --from ide-assists ide_assists\n+          cargo workspaces rename --from ide-completion ide_completion\n+          cargo workspaces rename --from ide-db ide_db\n+          cargo workspaces rename --from ide-diagnostics ide_diagnostics\n+          cargo workspaces rename --from ide-ssr ide_ssr\n+          cargo workspaces rename --from proc-macro-api proc_macro_api\n+          cargo workspaces rename --from proc-macro-srv proc_macro_srv\n+          cargo workspaces rename --from project-model project_model\n+          cargo workspaces rename --from test-utils test_utils\n+          cargo workspaces rename --from text-edit text_edit\n           cargo workspaces rename ra_ap_%n\n           find crates/rust-analyzer -type f -name '*.rs' -exec sed -i 's/rust_analyzer/ra_ap_rust_analyzer/g' {} +\n-          # Fix names for crates that were published before switch to kebab-case.\n-          find crates -name 'Cargo.toml' -exec sed -i \"s/ra_ap_base-db/ra_ap_base_db/g; s/ra_ap_hir-def/ra_ap_hir_def/g; s/ra_ap_hir-expand/ra_ap_hir_expand/g; s/ra_ap_hir-ty/ra_ap_hir_ty/g; s/ra_ap_ide-assists/ra_ap_ide_assists/g; s/ra_ap_ide-completion/ra_ap_ide_completion/g; s/ra_ap_ide-db/ra_ap_ide_db/g; s/ra_ap_ide-diagnostics/ra_ap_ide_diagnostics/g; s/ra_ap_ide-ssr/ra_ap_ide_ssr/g; s/ra_ap_proc-macro-api/ra_ap_proc_macro_api/g; s/ra_ap_proc-macro-srv/ra_ap_proc_macro_srv/g; s/ra_ap_project-model/ra_ap_project_model/g; s/ra_ap_test-utils/ra_ap_test_utils/g; s/ra_ap_text-edit/ra_ap_text_edit/g\" {} +\n           cargo workspaces publish --yes --force '*' --exact --no-git-commit --allow-dirty --skip-published custom 0.0.$PATCH"}, {"sha": "2b39c6f8da86bee737371f8fd86547d5ed281d11", "filename": "src/tools/rust-analyzer/crates/hir-def/src/attr.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -124,13 +124,24 @@ impl RawAttrs {\n \n     pub(crate) fn merge(&self, other: Self) -> Self {\n         // FIXME: This needs to fixup `AttrId`s\n-        match (&self.entries, &other.entries) {\n+        match (&self.entries, other.entries) {\n             (None, None) => Self::EMPTY,\n-            (Some(entries), None) | (None, Some(entries)) => {\n-                Self { entries: Some(entries.clone()) }\n-            }\n+            (None, entries @ Some(_)) => Self { entries },\n+            (Some(entries), None) => Self { entries: Some(entries.clone()) },\n             (Some(a), Some(b)) => {\n-                Self { entries: Some(a.iter().chain(b.iter()).cloned().collect()) }\n+                let last_ast_index = a.last().map_or(0, |it| it.id.ast_index + 1);\n+                Self {\n+                    entries: Some(\n+                        a.iter()\n+                            .cloned()\n+                            .chain(b.iter().map(|it| {\n+                                let mut it = it.clone();\n+                                it.id.ast_index += last_ast_index;\n+                                it\n+                            }))\n+                            .collect(),\n+                    ),\n+                }\n             }\n         }\n     }"}, {"sha": "a11a92204c15c29c788a4d134e71e681595e466c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -5,6 +5,7 @@ use std::collections::hash_map::Entry;\n \n use base_db::CrateId;\n use hir_expand::{name::Name, AstId, MacroCallId};\n+use itertools::Itertools;\n use once_cell::sync::Lazy;\n use profile::Count;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -97,15 +98,14 @@ pub(crate) enum BuiltinShadowMode {\n impl ItemScope {\n     pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n         // FIXME: shadowing\n-        let keys: FxHashSet<_> = self\n-            .types\n+        self.types\n             .keys()\n             .chain(self.values.keys())\n             .chain(self.macros.keys())\n             .chain(self.unresolved.iter())\n-            .collect();\n-\n-        keys.into_iter().map(move |name| (name, self.get(name)))\n+            .sorted()\n+            .unique()\n+            .map(move |name| (name, self.get(name)))\n     }\n \n     pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {"}, {"sha": "8a6bb929c3df7bd660e2fcd5995b8e38b61bcfc0", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -1055,7 +1055,7 @@ impl DefCollector<'_> {\n         };\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|directive| {\n-            let resolver2 = |path| {\n+            let resolver = |path| {\n                 let resolved_res = self.def_map.resolve_path_fp_with_macro(\n                     self.db,\n                     ResolveMode::Other,\n@@ -1068,7 +1068,7 @@ impl DefCollector<'_> {\n                     .take_macros()\n                     .map(|it| (it, macro_id_to_def_id(self.db, it)))\n             };\n-            let resolver = |path| resolver2(path).map(|(_, it)| it);\n+            let resolver_def_id = |path| resolver(path).map(|(_, it)| it);\n \n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n@@ -1077,7 +1077,7 @@ impl DefCollector<'_> {\n                         ast_id,\n                         *expand_to,\n                         self.def_map.krate,\n-                        &resolver,\n+                        &resolver_def_id,\n                         &mut |_err| (),\n                     );\n                     if let Ok(Ok(call_id)) = call_id {\n@@ -1093,7 +1093,7 @@ impl DefCollector<'_> {\n                         *derive_attr,\n                         *derive_pos as u32,\n                         self.def_map.krate,\n-                        &resolver2,\n+                        &resolver,\n                     );\n \n                     if let Ok((macro_id, def_id, call_id)) = id {\n@@ -1158,7 +1158,7 @@ impl DefCollector<'_> {\n                         }\n                     }\n \n-                    let def = match resolver(path.clone()) {\n+                    let def = match resolver_def_id(path.clone()) {\n                         Some(def) if def.is_attribute() => def,\n                         _ => return true,\n                     };\n@@ -1292,7 +1292,8 @@ impl DefCollector<'_> {\n             true\n         });\n         // Attribute resolution can add unresolved macro invocations, so concatenate the lists.\n-        self.unresolved_macros.extend(macros);\n+        macros.extend(mem::take(&mut self.unresolved_macros));\n+        self.unresolved_macros = macros;\n \n         for (module_id, depth, container, macro_call_id) in resolved {\n             self.collect_macro_expansion(module_id, macro_call_id, depth, container);"}, {"sha": "a9c124b42dc2c112b3a04718f4c0d161fcb00afc", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -34,6 +34,7 @@ pub trait TyExt {\n     fn callable_sig(&self, db: &dyn HirDatabase) -> Option<CallableSig>;\n \n     fn strip_references(&self) -> &Ty;\n+    fn strip_reference(&self) -> &Ty;\n \n     /// If this is a `dyn Trait`, returns that trait.\n     fn dyn_trait(&self) -> Option<TraitId>;\n@@ -182,6 +183,10 @@ impl TyExt for Ty {\n         t\n     }\n \n+    fn strip_reference(&self) -> &Ty {\n+        self.as_reference().map_or(self, |(ty, _, _)| ty)\n+    }\n+\n     fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>> {\n         match self.kind(Interner) {\n             TyKind::OpaqueType(opaque_ty_id, subst) => {"}, {"sha": "8f984210e1176702c1ce23c865ed8aca631a4c82", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -2769,6 +2769,10 @@ impl Type {\n         self.derived(self.ty.strip_references().clone())\n     }\n \n+    pub fn strip_reference(&self) -> Type {\n+        self.derived(self.ty.strip_reference().clone())\n+    }\n+\n     pub fn is_unknown(&self) -> bool {\n         self.ty.is_unknown()\n     }"}, {"sha": "c84318b2fb8774123dbe91b69df2aae53da34547", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -324,6 +324,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_type(ty)\n     }\n \n+    pub fn resolve_trait(&self, trait_: &ast::Path) -> Option<Trait> {\n+        self.imp.resolve_trait(trait_)\n+    }\n+\n     // FIXME: Figure out a nice interface to inspect adjustments\n     pub fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n         self.imp.is_implicit_reborrow(expr)\n@@ -924,7 +928,12 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn original_ast_node<N: AstNode>(&self, node: N) -> Option<N> {\n-        self.wrap_node_infile(node).original_ast_node(self.db.upcast()).map(|it| it.value)\n+        self.wrap_node_infile(node).original_ast_node(self.db.upcast()).map(\n+            |InFile { file_id, value }| {\n+                self.cache(find_root(value.syntax()), file_id);\n+                value\n+            },\n+        )\n     }\n \n     fn diagnostics_display_range(&self, src: InFile<SyntaxNodePtr>) -> FileRange {\n@@ -1009,6 +1018,20 @@ impl<'db> SemanticsImpl<'db> {\n         Some(Type::new_with_resolver(self.db, &analyze.resolver, ty))\n     }\n \n+    fn resolve_trait(&self, path: &ast::Path) -> Option<Trait> {\n+        let analyze = self.analyze(path.syntax())?;\n+        let hygiene = hir_expand::hygiene::Hygiene::new(self.db.upcast(), analyze.file_id);\n+        let ctx = body::LowerCtx::with_hygiene(self.db.upcast(), &hygiene);\n+        let hir_path = Path::from_src(path.clone(), &ctx)?;\n+        match analyze\n+            .resolver\n+            .resolve_path_in_type_ns_fully(self.db.upcast(), hir_path.mod_path())?\n+        {\n+            TypeNs::TraitId(id) => Some(Trait { id }),\n+            _ => None,\n+        }\n+    }\n+\n     fn is_implicit_reborrow(&self, expr: &ast::Expr) -> Option<Mutability> {\n         self.analyze(expr.syntax())?.is_implicit_reborrow(self.db, expr)\n     }"}, {"sha": "87f5018fb69586f44e6307cb8f2561d558d85e03", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -36,7 +36,7 @@ use crate::{\n //     pub struct Baz;\n // }\n //\n-// use foo::{Baz, Bar};\n+// use foo::{Bar, Baz};\n //\n // fn qux(bar: Bar, baz: Baz) {}\n // ```\n@@ -281,7 +281,7 @@ mod foo {\n     pub fn f() {}\n }\n \n-use foo::{Baz, Bar, f};\n+use foo::{Bar, Baz, f};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n@@ -351,7 +351,7 @@ mod foo {\n     pub fn f() {}\n }\n \n-use foo::{Baz, Bar, f};\n+use foo::{Bar, Baz, f};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n@@ -440,7 +440,7 @@ mod foo {\n     }\n }\n \n-use foo::{bar::{Baz, Bar, f}, baz::*};\n+use foo::{bar::{Bar, Baz, f}, baz::*};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n@@ -561,7 +561,7 @@ mod foo {\n \n use foo::{\n     bar::{*, f},\n-    baz::{g, qux::{q, h}}\n+    baz::{g, qux::{h, q}}\n };\n \n fn qux(bar: Bar, baz: Baz) {"}, {"sha": "80d3b925593674266776a705fadd0c4ea59f9b65", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -7,7 +7,7 @@ use ide_db::{\n     imports::insert_use::remove_path_if_in_use_stmt,\n     path_transform::PathTransform,\n     search::{FileReference, SearchScope},\n-    syntax_helpers::node_ext::expr_as_name_ref,\n+    syntax_helpers::{insert_whitespace_into_node::insert_ws_into, node_ext::expr_as_name_ref},\n     RootDatabase,\n };\n use itertools::{izip, Itertools};\n@@ -301,7 +301,16 @@ fn inline(\n     params: &[(ast::Pat, Option<ast::Type>, hir::Param)],\n     CallInfo { node, arguments, generic_arg_list }: &CallInfo,\n ) -> ast::Expr {\n-    let body = fn_body.clone_for_update();\n+    let body = if sema.hir_file_for(fn_body.syntax()).is_macro() {\n+        cov_mark::hit!(inline_call_defined_in_macro);\n+        if let Some(body) = ast::BlockExpr::cast(insert_ws_into(fn_body.syntax().clone())) {\n+            body\n+        } else {\n+            fn_body.clone_for_update()\n+        }\n+    } else {\n+        fn_body.clone_for_update()\n+    };\n     let usages_for_locals = |local| {\n         Definition::Local(local)\n             .usages(sema)\n@@ -1144,6 +1153,41 @@ fn bar() -> u32 {\n         x\n     }) + foo()\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn inline_call_defined_in_macro() {\n+        cov_mark::check!(inline_call_defined_in_macro);\n+        check_assist(\n+            inline_call,\n+            r#\"\n+macro_rules! define_foo {\n+    () => { fn foo() -> u32 {\n+        let x = 0;\n+        x\n+    } };\n+}\n+define_foo!();\n+fn bar() -> u32 {\n+    foo$0()\n+}\n+\"#,\n+            r#\"\n+macro_rules! define_foo {\n+    () => { fn foo() -> u32 {\n+        let x = 0;\n+        x\n+    } };\n+}\n+define_foo!();\n+fn bar() -> u32 {\n+    {\n+      let x = 0;\n+      x\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "6eaab48a32ba54e567f0e958f9a52d8cebbe9bbe", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -535,7 +535,7 @@ mod foo {\n     pub struct Baz;\n }\n \n-use foo::{Baz, Bar};\n+use foo::{Bar, Baz};\n \n fn qux(bar: Bar, baz: Baz) {}\n \"#####,"}, {"sha": "72579e6026aee736868f1ae64bbdc310b00b46cd", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -400,7 +400,7 @@ impl Completions {\n     ) {\n         if let PathCompletionCtx { kind: PathKind::Pat { pat_ctx }, .. } = path_ctx {\n             cov_mark::hit!(enum_variant_pattern_path);\n-            self.add_variant_pat(ctx, pat_ctx, variant, local_name);\n+            self.add_variant_pat(ctx, pat_ctx, Some(path_ctx), variant, local_name);\n             return;\n         }\n \n@@ -484,12 +484,14 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext<'_>,\n         pattern_ctx: &PatternContext,\n+        path_ctx: Option<&PathCompletionCtx>,\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n         self.add_opt(render_variant_pat(\n             RenderContext::new(ctx),\n             pattern_ctx,\n+            path_ctx,\n             variant,\n             local_name.clone(),\n             None,\n@@ -504,7 +506,14 @@ impl Completions {\n         path: hir::ModPath,\n     ) {\n         let path = Some(&path);\n-        self.add_opt(render_variant_pat(RenderContext::new(ctx), pattern_ctx, variant, None, path));\n+        self.add_opt(render_variant_pat(\n+            RenderContext::new(ctx),\n+            pattern_ctx,\n+            None,\n+            variant,\n+            None,\n+            path,\n+        ));\n     }\n \n     pub(crate) fn add_struct_pat("}, {"sha": "d9fe94cb44ee1d3d5e3d4573d5d6e696f411c67b", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -115,7 +115,7 @@ pub(crate) fn complete_attribute_path(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n     }\n \n     let attributes = annotated_item_kind.and_then(|kind| {"}, {"sha": "793c22630bf8959039856f2ecd9ddd126565cc1a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -97,7 +97,7 @@ pub(crate) fn complete_derive_path(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n     }\n }\n "}, {"sha": "5d0ddaaf2a22854e96f1029db1a14722afbe08a2", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -11,7 +11,14 @@ pub(crate) fn complete_expr_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n-    &ExprCtx {\n+    expr_ctx: &ExprCtx,\n+) {\n+    let _p = profile::span(\"complete_expr_path\");\n+    if !ctx.qualifier_ctx.none() {\n+        return;\n+    }\n+\n+    let &ExprCtx {\n         in_block_expr,\n         in_loop_body,\n         after_if_expr,\n@@ -23,12 +30,7 @@ pub(crate) fn complete_expr_path(\n         ref impl_,\n         in_match_guard,\n         ..\n-    }: &ExprCtx,\n-) {\n-    let _p = profile::span(\"complete_expr_path\");\n-    if !ctx.qualifier_ctx.none() {\n-        return;\n-    }\n+    } = expr_ctx;\n \n     let wants_mut_token =\n         ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false);\n@@ -46,11 +48,32 @@ pub(crate) fn complete_expr_path(\n     };\n \n     match qualified {\n-        Qualified::Infer => ctx\n+        Qualified::TypeAnchor { ty: None, trait_: None } => ctx\n             .traits_in_scope()\n             .iter()\n             .flat_map(|&it| hir::Trait::from(it).items(ctx.sema.db))\n             .for_each(|item| add_assoc_item(acc, item)),\n+        Qualified::TypeAnchor { trait_: Some(trait_), .. } => {\n+            trait_.items(ctx.sema.db).into_iter().for_each(|item| add_assoc_item(acc, item))\n+        }\n+        Qualified::TypeAnchor { ty: Some(ty), trait_: None } => {\n+            if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                cov_mark::hit!(completes_variant_through_alias);\n+                acc.add_enum_variants(ctx, path_ctx, e);\n+            }\n+\n+            ctx.iterate_path_candidates(&ty, |item| {\n+                add_assoc_item(acc, item);\n+            });\n+\n+            // Iterate assoc types separately\n+            ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n+                if let hir::AssocItem::TypeAlias(ty) = item {\n+                    acc.add_type_alias(ctx, ty)\n+                }\n+                None::<()>\n+            });\n+        }\n         Qualified::With { resolution: None, .. } => {}\n         Qualified::With { resolution: Some(resolution), .. } => {\n             // Add associated types on type parameters and `Self`.\n@@ -179,10 +202,21 @@ pub(crate) fn complete_expr_path(\n                     }\n                 }\n             }\n-            ctx.process_all_names(&mut |name, def| {\n-                if scope_def_applicable(def) {\n-                    acc.add_path_resolution(ctx, path_ctx, name, def);\n+            ctx.process_all_names(&mut |name, def| match def {\n+                ScopeDef::ModuleDef(hir::ModuleDef::Trait(t)) => {\n+                    let assocs = t.items_with_supertraits(ctx.db);\n+                    match &*assocs {\n+                        // traits with no assoc items are unusable as expressions since\n+                        // there is no associated item path that can be constructed with them\n+                        [] => (),\n+                        // FIXME: Render the assoc item with the trait qualified\n+                        &[_item] => acc.add_path_resolution(ctx, path_ctx, name, def),\n+                        // FIXME: Append `::` to the thing here, since a trait on its own won't work\n+                        [..] => acc.add_path_resolution(ctx, path_ctx, name, def),\n+                    }\n                 }\n+                _ if scope_def_applicable(def) => acc.add_path_resolution(ctx, path_ctx, name, def),\n+                _ => (),\n             });\n \n             if is_func_update.is_none() {"}, {"sha": "60d05ae46b9168181d7823f660867a1b3ad36462", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -66,7 +66,7 @@ pub(crate) fn complete_item_list(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::No | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::No | Qualified::With { .. } => {}\n     }\n }\n "}, {"sha": "71d2d9d434b449f915dbad29a58c756ae591b651", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -74,7 +74,7 @@ pub(crate) fn complete_pattern(\n                 hir::ModuleDef::Variant(variant)\n                     if refutable || single_variant_enum(variant.parent_enum(ctx.db)) =>\n                 {\n-                    acc.add_variant_pat(ctx, pattern_ctx, variant, Some(name.clone()));\n+                    acc.add_variant_pat(ctx, pattern_ctx, None, variant, Some(name.clone()));\n                     true\n                 }\n                 hir::ModuleDef::Adt(hir::Adt::Enum(e)) => refutable || single_variant_enum(e),\n@@ -180,6 +180,6 @@ pub(crate) fn complete_pattern_path(\n \n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n     }\n }"}, {"sha": "8f9db2f94c204c5e78bd962c0de7e07b3a08e3f0", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -49,11 +49,27 @@ pub(crate) fn complete_type_path(\n     };\n \n     match qualified {\n-        Qualified::Infer => ctx\n+        Qualified::TypeAnchor { ty: None, trait_: None } => ctx\n             .traits_in_scope()\n             .iter()\n             .flat_map(|&it| hir::Trait::from(it).items(ctx.sema.db))\n             .for_each(|item| add_assoc_item(acc, item)),\n+        Qualified::TypeAnchor { trait_: Some(trait_), .. } => {\n+            trait_.items(ctx.sema.db).into_iter().for_each(|item| add_assoc_item(acc, item))\n+        }\n+        Qualified::TypeAnchor { ty: Some(ty), trait_: None } => {\n+            ctx.iterate_path_candidates(&ty, |item| {\n+                add_assoc_item(acc, item);\n+            });\n+\n+            // Iterate assoc types separately\n+            ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n+                if let hir::AssocItem::TypeAlias(ty) = item {\n+                    acc.add_type_alias(ctx, ty)\n+                }\n+                None::<()>\n+            });\n+        }\n         Qualified::With { resolution: None, .. } => {}\n         Qualified::With { resolution: Some(resolution), .. } => {\n             // Add associated types on type parameters and `Self`."}, {"sha": "2555c34aa7477090bc7f588ae66a908990f9db34", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -115,6 +115,6 @@ pub(crate) fn complete_use_path(\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::Infer | Qualified::With { resolution: None, .. } => {}\n+        Qualified::TypeAnchor { .. } | Qualified::With { resolution: None, .. } => {}\n     }\n }"}, {"sha": "5e6cf4bf9a52142d572924a5f280d5625f88f2a1", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn complete_vis_path(\n \n             acc.add_super_keyword(ctx, *super_chain_len);\n         }\n-        Qualified::Absolute | Qualified::Infer | Qualified::With { .. } => {}\n+        Qualified::Absolute | Qualified::TypeAnchor { .. } | Qualified::With { .. } => {}\n         Qualified::No => {\n             if !has_in_token {\n                 cov_mark::hit!(kw_completion_in);"}, {"sha": "e35f79d2b6951e05a57c943af8eba44bb60e7f57", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -193,7 +193,10 @@ pub(super) enum Qualified {\n         super_chain_len: Option<usize>,\n     },\n     /// <_>::\n-    Infer,\n+    TypeAnchor {\n+        ty: Option<hir::Type>,\n+        trait_: Option<hir::Trait>,\n+    },\n     /// Whether the path is an absolute path\n     Absolute,\n }"}, {"sha": "22ec7cead4988cc54d33b9f8c49e6c4b34cd1d88", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 187, "deletions": 127, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -162,11 +162,52 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     /// Calculate the expected type and name of the cursor position.\n-    fn expected_type_and_name(&self) -> (Option<Type>, Option<NameOrNameRef>) {\n+    fn expected_type_and_name(\n+        &self,\n+        name_like: &ast::NameLike,\n+    ) -> (Option<Type>, Option<NameOrNameRef>) {\n         let mut node = match self.token.parent() {\n             Some(it) => it,\n             None => return (None, None),\n         };\n+\n+        let strip_refs = |mut ty: Type| match name_like {\n+            ast::NameLike::NameRef(n) => {\n+                let p = match n.syntax().parent() {\n+                    Some(it) => it,\n+                    None => return ty,\n+                };\n+                let top_syn = match_ast! {\n+                    match p {\n+                        ast::FieldExpr(e) => e\n+                            .syntax()\n+                            .ancestors()\n+                            .map_while(ast::FieldExpr::cast)\n+                            .last()\n+                            .map(|it| it.syntax().clone()),\n+                        ast::PathSegment(e) => e\n+                            .syntax()\n+                            .ancestors()\n+                            .skip(1)\n+                            .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n+                            .find_map(ast::PathExpr::cast)\n+                            .map(|it| it.syntax().clone()),\n+                        _ => None\n+                    }\n+                };\n+                let top_syn = match top_syn {\n+                    Some(it) => it,\n+                    None => return ty,\n+                };\n+                for _ in top_syn.ancestors().skip(1).map_while(ast::RefExpr::cast) {\n+                    cov_mark::hit!(expected_type_fn_param_ref);\n+                    ty = ty.strip_reference();\n+                }\n+                ty\n+            }\n+            _ => ty,\n+        };\n+\n         loop {\n             break match_ast! {\n                 match node {\n@@ -199,13 +240,9 @@ impl<'a> CompletionContext<'a> {\n                             self.token.clone(),\n                         ).map(|ap| {\n                             let name = ap.ident().map(NameOrNameRef::Name);\n-                            let ty = if has_ref(&self.token) {\n-                                cov_mark::hit!(expected_type_fn_param_ref);\n-                                ap.ty.remove_ref()\n-                            } else {\n-                                Some(ap.ty)\n-                            };\n-                            (ty, name)\n+\n+                            let ty = strip_refs(ap.ty);\n+                            (Some(ty), name)\n                         })\n                         .unwrap_or((None, None))\n                     },\n@@ -330,8 +367,6 @@ impl<'a> CompletionContext<'a> {\n             return None;\n         }\n \n-        (self.expected_type, self.expected_name) = self.expected_type_and_name();\n-\n         // Overwrite the path kind for derives\n         if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n             if let Some(ast::NameLike::NameRef(name_ref)) =\n@@ -389,6 +424,7 @@ impl<'a> CompletionContext<'a> {\n                 return Some(analysis);\n             }\n         };\n+        (self.expected_type, self.expected_name) = self.expected_type_and_name(&name_like);\n         let analysis = match name_like {\n             ast::NameLike::Lifetime(lifetime) => CompletionAnalysis::Lifetime(\n                 Self::classify_lifetime(&self.sema, original_file, lifetime)?,\n@@ -556,7 +592,7 @@ impl<'a> CompletionContext<'a> {\n             has_call_parens: false,\n             has_macro_bang: false,\n             qualified: Qualified::No,\n-            parent: path.parent_path(),\n+            parent: None,\n             path: path.clone(),\n             kind: PathKind::Item { kind: ItemListKind::SourceFile },\n             has_type_args: false,\n@@ -791,142 +827,179 @@ impl<'a> CompletionContext<'a> {\n             PathKind::Type { location: location.unwrap_or(TypeLocation::Other) }\n         };\n \n+        let mut kind_macro_call = |it: ast::MacroCall| {\n+            path_ctx.has_macro_bang = it.excl_token().is_some();\n+            let parent = it.syntax().parent()?;\n+            // Any path in an item list will be treated as a macro call by the parser\n+            let kind = match_ast! {\n+                match parent {\n+                    ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n+                    ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n+                    ast::MacroType(ty) => make_path_kind_type(ty.into()),\n+                    ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n+                    ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n+                        Some(it) => match_ast! {\n+                            match it {\n+                                ast::Trait(_) => ItemListKind::Trait,\n+                                ast::Impl(it) => if it.trait_().is_some() {\n+                                    ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n+                                } else {\n+                                    ItemListKind::Impl\n+                                },\n+                                _ => return None\n+                            }\n+                        },\n+                        None => return None,\n+                    } },\n+                    ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n+                    ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n+                    _ => return None,\n+                }\n+            };\n+            Some(kind)\n+        };\n+        let make_path_kind_attr = |meta: ast::Meta| {\n+            let attr = meta.parent_attr()?;\n+            let kind = attr.kind();\n+            let attached = attr.syntax().parent()?;\n+            let is_trailing_outer_attr = kind != AttrKind::Inner\n+                && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next)\n+                    .is_none();\n+            let annotated_item_kind =\n+                if is_trailing_outer_attr { None } else { Some(attached.kind()) };\n+            Some(PathKind::Attr { attr_ctx: AttrCtx { kind, annotated_item_kind } })\n+        };\n+\n         // Infer the path kind\n         let parent = path.syntax().parent()?;\n         let kind = match_ast! {\n-                match parent {\n-                    ast::PathType(it) => make_path_kind_type(it.into()),\n-                    ast::PathExpr(it) => {\n-                        if let Some(p) = it.syntax().parent() {\n-                            if ast::ExprStmt::can_cast(p.kind()) {\n-                                if let Some(kind) = inbetween_body_and_decl_check(p) {\n-                                    return Some(make_res(NameRefKind::Keyword(kind)));\n-                                }\n+            match parent {\n+                ast::PathType(it) => make_path_kind_type(it.into()),\n+                ast::PathExpr(it) => {\n+                    if let Some(p) = it.syntax().parent() {\n+                        if ast::ExprStmt::can_cast(p.kind()) {\n+                            if let Some(kind) = inbetween_body_and_decl_check(p) {\n+                                return Some(make_res(NameRefKind::Keyword(kind)));\n                             }\n                         }\n+                    }\n \n-                        path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+                    path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n \n-                        make_path_kind_expr(it.into())\n-                    },\n-                    ast::TupleStructPat(it) => {\n-                        path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                    },\n-                    ast::RecordPat(it) => {\n-                        path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                    },\n-                    ast::PathPat(it) => {\n-                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                    },\n-                    ast::MacroCall(it) => {\n-                        // A macro call in this position is usually a result of parsing recovery, so check that\n-                        if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n-                            return Some(make_res(NameRefKind::Keyword(kind)));\n-                        }\n+                    make_path_kind_expr(it.into())\n+                },\n+                ast::TupleStructPat(it) => {\n+                    path_ctx.has_call_parens = true;\n+                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                },\n+                ast::RecordPat(it) => {\n+                    path_ctx.has_call_parens = true;\n+                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                },\n+                ast::PathPat(it) => {\n+                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+                },\n+                ast::MacroCall(it) => {\n+                    // A macro call in this position is usually a result of parsing recovery, so check that\n+                    if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n+                        return Some(make_res(NameRefKind::Keyword(kind)));\n+                    }\n \n-                        path_ctx.has_macro_bang = it.excl_token().is_some();\n-                        let parent = it.syntax().parent()?;\n-                        // Any path in an item list will be treated as a macro call by the parser\n-                        match_ast! {\n-                            match parent {\n-                                ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n-                                ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n-                                ast::MacroType(ty) => make_path_kind_type(ty.into()),\n-                                ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n-                                ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n-                                    Some(it) => match_ast! {\n-                                        match it {\n-                                            ast::Trait(_) => ItemListKind::Trait,\n-                                            ast::Impl(it) => if it.trait_().is_some() {\n-                                                ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n-                                            } else {\n-                                                ItemListKind::Impl\n-                                            },\n-                                            _ => return None\n-                                        }\n-                                    },\n-                                    None => return None,\n-                                } },\n-                                ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n-                                ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n-                                _ => return None,\n-                            }\n-                        }\n-                    },\n-                    ast::Meta(meta) => {\n-                        let attr = meta.parent_attr()?;\n-                        let kind = attr.kind();\n-                        let attached = attr.syntax().parent()?;\n-                        let is_trailing_outer_attr = kind != AttrKind::Inner\n-                            && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next).is_none();\n-                        let annotated_item_kind = if is_trailing_outer_attr {\n-                            None\n-                        } else {\n-                            Some(attached.kind())\n-                        };\n-                        PathKind::Attr {\n-                            attr_ctx: AttrCtx {\n-                                kind,\n-                                annotated_item_kind,\n-                            }\n+                    kind_macro_call(it)?\n+                },\n+                ast::Meta(meta) => make_path_kind_attr(meta)?,\n+                ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+                ast::UseTree(_) => PathKind::Use,\n+                // completing inside a qualifier\n+                ast::Path(parent) => {\n+                    path_ctx.parent = Some(parent.clone());\n+                    let parent = iter::successors(Some(parent), |it| it.parent_path()).last()?.syntax().parent()?;\n+                    match_ast! {\n+                        match parent {\n+                            ast::PathType(it) => make_path_kind_type(it.into()),\n+                            ast::PathExpr(it) => {\n+                                path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+\n+                                make_path_kind_expr(it.into())\n+                            },\n+                            ast::TupleStructPat(it) => {\n+                                path_ctx.has_call_parens = true;\n+                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                            },\n+                            ast::RecordPat(it) => {\n+                                path_ctx.has_call_parens = true;\n+                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                            },\n+                            ast::PathPat(it) => {\n+                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+                            },\n+                            ast::MacroCall(it) => {\n+                                kind_macro_call(it)?\n+                            },\n+                            ast::Meta(meta) => make_path_kind_attr(meta)?,\n+                            ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+                            ast::UseTree(_) => PathKind::Use,\n+                            ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+                            _ => return None,\n                         }\n-                    },\n-                    ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n-                    ast::UseTree(_) => PathKind::Use,\n-                    _ => return None,\n-\n+                    }\n+                },\n+                ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+                _ => return None,\n             }\n         };\n \n         path_ctx.kind = kind;\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n         // calculate the qualifier context\n-        if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n+        if let Some((qualifier, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n             path_ctx.use_tree_parent = use_tree_parent;\n             if !use_tree_parent && segment.coloncolon_token().is_some() {\n                 path_ctx.qualified = Qualified::Absolute;\n             } else {\n-                let path = path\n+                let qualifier = qualifier\n                     .segment()\n                     .and_then(|it| find_node_in_file(original_file, &it))\n                     .map(|it| it.parent_path());\n-                if let Some(path) = path {\n-                    // `<_>::$0`\n-                    let is_infer_qualifier = path.qualifier().is_none()\n-                        && matches!(\n-                            path.segment().and_then(|it| it.kind()),\n-                            Some(ast::PathSegmentKind::Type {\n-                                type_ref: Some(ast::Type::InferType(_)),\n-                                trait_ref: None,\n-                            })\n-                        );\n+                if let Some(qualifier) = qualifier {\n+                    let type_anchor = match qualifier.segment().and_then(|it| it.kind()) {\n+                        Some(ast::PathSegmentKind::Type {\n+                            type_ref: Some(type_ref),\n+                            trait_ref,\n+                        }) if qualifier.qualifier().is_none() => Some((type_ref, trait_ref)),\n+                        _ => None,\n+                    };\n \n-                    path_ctx.qualified = if is_infer_qualifier {\n-                        Qualified::Infer\n+                    path_ctx.qualified = if let Some((ty, trait_ref)) = type_anchor {\n+                        let ty = match ty {\n+                            ast::Type::InferType(_) => None,\n+                            ty => sema.resolve_type(&ty),\n+                        };\n+                        let trait_ = trait_ref.and_then(|it| sema.resolve_trait(&it.path()?));\n+                        Qualified::TypeAnchor { ty, trait_ }\n                     } else {\n-                        let res = sema.resolve_path(&path);\n+                        let res = sema.resolve_path(&qualifier);\n \n                         // For understanding how and why super_chain_len is calculated the way it\n                         // is check the documentation at it's definition\n                         let mut segment_count = 0;\n-                        let super_count = iter::successors(Some(path.clone()), |p| p.qualifier())\n-                            .take_while(|p| {\n-                                p.segment()\n-                                    .and_then(|s| {\n-                                        segment_count += 1;\n-                                        s.super_token()\n-                                    })\n-                                    .is_some()\n-                            })\n-                            .count();\n+                        let super_count =\n+                            iter::successors(Some(qualifier.clone()), |p| p.qualifier())\n+                                .take_while(|p| {\n+                                    p.segment()\n+                                        .and_then(|s| {\n+                                            segment_count += 1;\n+                                            s.super_token()\n+                                        })\n+                                        .is_some()\n+                                })\n+                                .count();\n \n                         let super_chain_len =\n                             if segment_count > super_count { None } else { Some(super_count) };\n \n-                        Qualified::With { path, resolution: res, super_chain_len }\n+                        Qualified::With { path: qualifier, resolution: res, super_chain_len }\n                     }\n                 };\n             }\n@@ -1141,19 +1214,6 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     Some((use_tree.path()?, true))\n }\n \n-fn has_ref(token: &SyntaxToken) -> bool {\n-    let mut token = token.clone();\n-    for skip in [SyntaxKind::IDENT, SyntaxKind::WHITESPACE, T![mut]] {\n-        if token.kind() == skip {\n-            token = match token.prev_token() {\n-                Some(it) => it,\n-                None => return false,\n-            }\n-        }\n-    }\n-    token.kind() == T![&]\n-}\n-\n pub(crate) fn is_in_token_of_for_loop(element: SyntaxElement) -> bool {\n     // oh my ...\n     (|| {"}, {"sha": "50845b3881f433953014dfa47d3ec00261806bf7", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -391,3 +391,23 @@ fn foo($0: Foo) {}\n         expect![[r#\"ty: ?, name: ?\"#]],\n     );\n }\n+\n+#[test]\n+fn expected_type_ref_prefix_on_field() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo(_: &mut i32) {}\n+struct S {\n+    field: i32,\n+}\n+\n+fn main() {\n+    let s = S {\n+        field: 100,\n+    };\n+    foo(&mut s.f$0);\n+}\n+\"#,\n+        expect![\"ty: i32, name: ?\"],\n+    );\n+}"}, {"sha": "946134b0ff95db78cb4682f847c6e4131dbf3fd4", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -1271,8 +1271,8 @@ fn main() {\n                 st S []\n                 st &mut S [type]\n                 st S []\n-                fn main() []\n                 fn foo(\u2026) []\n+                fn main() []\n             \"#]],\n         );\n         check_relevance(\n@@ -1288,8 +1288,8 @@ fn main() {\n                 lc s [type+name+local]\n                 st S [type]\n                 st S []\n-                fn main() []\n                 fn foo(\u2026) []\n+                fn main() []\n             \"#]],\n         );\n         check_relevance(\n@@ -1305,8 +1305,8 @@ fn main() {\n                 lc ssss [type+local]\n                 st S [type]\n                 st S []\n-                fn main() []\n                 fn foo(\u2026) []\n+                fn main() []\n             \"#]],\n         );\n     }\n@@ -1342,12 +1342,11 @@ fn main() {\n                 lc &t [type+local]\n                 st S []\n                 st &S [type]\n-                st T []\n                 st S []\n-                fn main() []\n+                st T []\n                 fn foo(\u2026) []\n+                fn main() []\n                 md core []\n-                tt Sized []\n             \"#]],\n         )\n     }\n@@ -1389,12 +1388,11 @@ fn main() {\n                 lc &mut t [type+local]\n                 st S []\n                 st &mut S [type]\n-                st T []\n                 st S []\n-                fn main() []\n+                st T []\n                 fn foo(\u2026) []\n+                fn main() []\n                 md core []\n-                tt Sized []\n             \"#]],\n         )\n     }\n@@ -1485,14 +1483,13 @@ fn main() {\n             expect![[r#\"\n                 st S []\n                 st &S [type]\n-                st T []\n                 st S []\n-                fn main() []\n+                st T []\n                 fn bar() []\n                 fn &bar() [type]\n                 fn foo(\u2026) []\n+                fn main() []\n                 md core []\n-                tt Sized []\n             \"#]],\n         )\n     }\n@@ -1636,8 +1633,8 @@ fn foo() {\n                 ev Foo::B [type_could_unify]\n                 fn foo() []\n                 en Foo []\n-                fn baz() []\n                 fn bar() []\n+                fn baz() []\n             \"#]],\n         );\n     }\n@@ -1727,9 +1724,9 @@ fn f() {\n }\n \"#,\n             expect![[r#\"\n-                md std []\n                 st Buffer []\n                 fn f() []\n+                md std []\n                 tt BufRead (use std::io::BufRead) [requires_import]\n                 st BufReader (use std::io::BufReader) [requires_import]\n                 st BufWriter (use std::io::BufWriter) [requires_import]"}, {"sha": "4b5535718c5dfd4027df9e1d8132db83dad9ec54", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -85,7 +85,9 @@ fn render(\n                 item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n             }\n             FuncKind::Method(DotAccess { receiver: Some(receiver), .. }, _) => {\n-                item.ref_match(ref_match, receiver.syntax().text_range().start());\n+                if let Some(original_expr) = completion.sema.original_ast_node(receiver.clone()) {\n+                    item.ref_match(ref_match, original_expr.syntax().text_range().start());\n+                }\n             }\n             _ => (),\n         }"}, {"sha": "34a384f2f7ae8cabdffbdc986101c5f71bed1936", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -6,7 +6,7 @@ use itertools::Itertools;\n use syntax::SmolStr;\n \n use crate::{\n-    context::{ParamContext, ParamKind, PatternContext},\n+    context::{ParamContext, ParamKind, PathCompletionCtx, PatternContext},\n     render::{\n         variant::{format_literal_label, visible_fields},\n         RenderContext,\n@@ -42,6 +42,7 @@ pub(crate) fn render_struct_pat(\n pub(crate) fn render_variant_pat(\n     ctx: RenderContext<'_>,\n     pattern_ctx: &PatternContext,\n+    path_ctx: Option<&PathCompletionCtx>,\n     variant: hir::Variant,\n     local_name: Option<Name>,\n     path: Option<&hir::ModPath>,\n@@ -58,9 +59,23 @@ pub(crate) fn render_variant_pat(\n             (name.to_smol_str(), name.escaped().to_smol_str())\n         }\n     };\n-    let kind = variant.kind(ctx.db());\n-    let label = format_literal_label(name.as_str(), kind);\n-    let pat = render_pat(&ctx, pattern_ctx, &escaped_name, kind, &visible_fields, fields_omitted)?;\n+\n+    let (label, pat) = match path_ctx {\n+        Some(PathCompletionCtx { has_call_parens: true, .. }) => (name, escaped_name.to_string()),\n+        _ => {\n+            let kind = variant.kind(ctx.db());\n+            let label = format_literal_label(name.as_str(), kind);\n+            let pat = render_pat(\n+                &ctx,\n+                pattern_ctx,\n+                &escaped_name,\n+                kind,\n+                &visible_fields,\n+                fields_omitted,\n+            )?;\n+            (label, pat)\n+        }\n+    };\n \n     Some(build_completion(ctx, label, pat, variant))\n }"}, {"sha": "cf826648dcf7b92426d162055248a2f7248a91c3", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -23,8 +23,6 @@ mod type_pos;\n mod use_tree;\n mod visibility;\n \n-use std::mem;\n-\n use hir::{db::DefDatabase, PrefixKind, Semantics};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n@@ -107,12 +105,9 @@ fn completion_list_with_config(\n ) -> String {\n     // filter out all but one builtintype completion for smaller test outputs\n     let items = get_all_items(config, ra_fixture, trigger_character);\n-    let mut bt_seen = false;\n     let items = items\n         .into_iter()\n-        .filter(|it| {\n-            it.kind() != CompletionItemKind::BuiltinType || !mem::replace(&mut bt_seen, true)\n-        })\n+        .filter(|it| it.kind() != CompletionItemKind::BuiltinType || it.label() == \"u32\")\n         .filter(|it| include_keywords || it.kind() != CompletionItemKind::Keyword)\n         .filter(|it| include_keywords || it.kind() != CompletionItemKind::Snippet)\n         .sorted_by_key(|it| (it.kind(), it.label().to_owned(), it.detail().map(ToOwned::to_owned)))"}, {"sha": "925081ebf66025552c5a5a1e03bbbf0c2e058176", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -44,7 +44,6 @@ fn baz() {\n             st Record\n             st Tuple\n             st Unit\n-            tt Trait\n             un Union\n             ev TupleV(\u2026)     TupleV(u32)\n             bt u32\n@@ -137,7 +136,6 @@ impl Unit {\n             st Record\n             st Tuple\n             st Unit\n-            tt Trait\n             tp TypeParam\n             un Union\n             ev TupleV(\u2026)    TupleV(u32)\n@@ -653,3 +651,22 @@ fn main() {\n         \"]],\n     );\n }\n+\n+#[test]\n+fn complete_record_expr_path() {\n+    check(\n+        r#\"\n+struct Zulu;\n+impl Zulu {\n+    fn test() -> Self { }\n+}\n+fn boi(val: Zulu) { }\n+fn main() {\n+    boi(Zulu:: $0 {});\n+}\n+\"#,\n+        expect![[r#\"\n+            fn test() fn() -> Zulu\n+        \"#]],\n+    );\n+}"}, {"sha": "30ddbe2dc6f6010caca0c48d70e718a3178c1c90", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -443,7 +443,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n-            bn TupleVariant(\u2026) TupleVariant($1)$0\n+            bn TupleVariant TupleVariant\n         \"#]],\n     );\n     check_empty(\n@@ -458,7 +458,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n-            bn RecordVariant {\u2026} RecordVariant { field$1 }$0\n+            bn RecordVariant RecordVariant\n         \"#]],\n     );\n }"}, {"sha": "f6accc68e5e80cec252e9c5c970ad819662ab81e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/record.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -167,7 +167,6 @@ fn main() {\n             st Foo\n             st Foo {\u2026}              Foo { foo1: u32, foo2: u32 }\n             tt Default\n-            tt Sized\n             bt u32\n             kw crate::\n             kw self::"}, {"sha": "033dc99c26cf0c09acfdb2efb52a073b95b2a2f2", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -674,7 +674,60 @@ fn bar() -> Bar {\n         expect![[r#\"\n                 fn foo() (as Foo) fn() -> Self\n             \"#]],\n-    )\n+    );\n+}\n+\n+#[test]\n+fn type_anchor_type() {\n+    check(\n+        r#\"\n+trait Foo {\n+    fn foo() -> Self;\n+}\n+struct Bar;\n+impl Bar {\n+    fn bar() {}\n+}\n+impl Foo for Bar {\n+    fn foo() -> {\n+        Bar\n+    }\n+}\n+fn bar() -> Bar {\n+    <Bar>::$0\n+}\n+\"#,\n+        expect![[r#\"\n+            fn bar()          fn()\n+            fn foo() (as Foo) fn() -> Self\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn type_anchor_type_trait() {\n+    check(\n+        r#\"\n+trait Foo {\n+    fn foo() -> Self;\n+}\n+struct Bar;\n+impl Bar {\n+    fn bar() {}\n+}\n+impl Foo for Bar {\n+    fn foo() -> {\n+        Bar\n+    }\n+}\n+fn bar() -> Bar {\n+    <Bar as Foo>::$0\n+}\n+\"#,\n+        expect![[r#\"\n+            fn foo() (as Foo) fn() -> Self\n+        \"#]],\n+    );\n }\n \n #[test]"}, {"sha": "3fb49b45d9888ebb7fcac3d4e4431b3f9f596e75", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -13,7 +13,7 @@ mod html;\n #[cfg(test)]\n mod tests;\n \n-use hir::{InFile, Name, Semantics};\n+use hir::{Name, Semantics};\n use ide_db::{FxHashMap, RootDatabase};\n use syntax::{\n     ast, AstNode, AstToken, NodeOrToken, SyntaxKind::*, SyntaxNode, TextRange, WalkEvent, T,\n@@ -325,7 +325,7 @@ fn traverse(\n             Leave(NodeOrToken::Node(node)) => {\n                 // Doc comment highlighting injection, we do this when leaving the node\n                 // so that we overwrite the highlighting of the doc comment itself.\n-                inject::doc_comment(hl, sema, InFile::new(file_id.into(), &node));\n+                inject::doc_comment(hl, sema, file_id, &node);\n                 continue;\n             }\n         };"}, {"sha": "f376f9fda7a57799c0be9b774a81508a065d2893", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -5,7 +5,8 @@ use std::mem;\n use either::Either;\n use hir::{InFile, Semantics};\n use ide_db::{\n-    active_parameter::ActiveParameter, defs::Definition, rust_doc::is_rust_fence, SymbolKind,\n+    active_parameter::ActiveParameter, base_db::FileId, defs::Definition, rust_doc::is_rust_fence,\n+    SymbolKind,\n };\n use syntax::{\n     ast::{self, AstNode, IsString, QuoteOffsets},\n@@ -81,16 +82,18 @@ pub(super) fn ra_fixture(\n const RUSTDOC_FENCE_LENGTH: usize = 3;\n const RUSTDOC_FENCES: [&str; 2] = [\"```\", \"~~~\"];\n \n-/// Injection of syntax highlighting of doctests.\n+/// Injection of syntax highlighting of doctests and intra doc links.\n pub(super) fn doc_comment(\n     hl: &mut Highlights,\n     sema: &Semantics<'_, RootDatabase>,\n-    InFile { file_id: src_file_id, value: node }: InFile<&SyntaxNode>,\n+    src_file_id: FileId,\n+    node: &SyntaxNode,\n ) {\n     let (attributes, def) = match doc_attributes(sema, node) {\n         Some(it) => it,\n         None => return,\n     };\n+    let src_file_id = src_file_id.into();\n \n     // Extract intra-doc links and emit highlights for them.\n     if let Some((docs, doc_mapping)) = attributes.docs_with_rangemap(sema.db) {"}, {"sha": "8a1d69816e6882aa738d0adbd23ff062c413c454", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/test_data/highlight_module_docs_inline.html", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_inline.html", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_inline.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_inline.html?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -0,0 +1,51 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.label              { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.documentation      { color: #629755; }\n+.intra_doc_link     { font-style: italic; }\n+.injected           { opacity: 0.65 ; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.trait.unsafe       { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n+.mutable.unsafe     { color: #BC8383; text-decoration: underline; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.macro.unsafe       { color: #BC8383; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.derive             { color: #94BFF3; font-style: italic; }\n+.module             { color: #AFD8AF; }\n+.value_param        { color: #DCDCCC; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+.escape_sequence    { color: #94BFF3; }\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.control            { font-style: italic; }\n+.reference          { font-style: italic; font-weight: bold; }\n+\n+.unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n+</style>\n+<pre><code><span class=\"comment documentation\">//! </span><span class=\"struct documentation injected intra_doc_link\">[Struct]</span>\n+<span class=\"comment documentation\">//! This is an intra doc injection test for modules</span>\n+<span class=\"comment documentation\">//! </span><span class=\"struct documentation injected intra_doc_link\">[Struct]</span>\n+<span class=\"comment documentation\">//! This is an intra doc injection test for modules</span>\n+\n+<span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"struct declaration public\">Struct</span><span class=\"semicolon\">;</span>\n+</code></pre>\n\\ No newline at end of file"}, {"sha": "c4c3e3dc2606e5852b5813c76ba9c2bfb31f9b04", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/test_data/highlight_module_docs_outline.html", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_outline.html", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_outline.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_module_docs_outline.html?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -0,0 +1,50 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.label              { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.documentation      { color: #629755; }\n+.intra_doc_link     { font-style: italic; }\n+.injected           { opacity: 0.65 ; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.trait.unsafe       { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n+.mutable.unsafe     { color: #BC8383; text-decoration: underline; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.macro.unsafe       { color: #BC8383; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.derive             { color: #94BFF3; font-style: italic; }\n+.module             { color: #AFD8AF; }\n+.value_param        { color: #DCDCCC; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+.escape_sequence    { color: #94BFF3; }\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.control            { font-style: italic; }\n+.reference          { font-style: italic; font-weight: bold; }\n+\n+.unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n+</style>\n+<pre><code><span class=\"comment documentation\">/// </span><span class=\"struct documentation injected intra_doc_link\">[crate::foo::Struct]</span>\n+<span class=\"comment documentation\">/// This is an intra doc injection test for modules</span>\n+<span class=\"comment documentation\">/// </span><span class=\"struct documentation injected intra_doc_link\">[crate::foo::Struct]</span>\n+<span class=\"comment documentation\">/// This is an intra doc injection test for modules</span>\n+<span class=\"keyword\">mod</span> <span class=\"module declaration\">foo</span><span class=\"semicolon\">;</span>\n+</code></pre>\n\\ No newline at end of file"}, {"sha": "99be7c6648687c7bffd7640d7a1c4736b3d8a2d6", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -915,6 +915,52 @@ fn main() {\n }\n \n #[test]\n+fn test_mod_hl_injection() {\n+    check_highlighting(\n+        r##\"\n+//- /foo.rs\n+//! [Struct]\n+//! This is an intra doc injection test for modules\n+//! [Struct]\n+//! This is an intra doc injection test for modules\n+\n+pub struct Struct;\n+//- /lib.rs crate:foo\n+/// [crate::foo::Struct]\n+/// This is an intra doc injection test for modules\n+/// [crate::foo::Struct]\n+/// This is an intra doc injection test for modules\n+mod foo;\n+\"##,\n+        expect_file![\"./test_data/highlight_module_docs_inline.html\"],\n+        false,\n+    );\n+    check_highlighting(\n+        r##\"\n+//- /lib.rs crate:foo\n+/// [crate::foo::Struct]\n+/// This is an intra doc injection test for modules\n+/// [crate::foo::Struct]\n+/// This is an intra doc injection test for modules\n+mod foo;\n+//- /foo.rs\n+//! [Struct]\n+//! This is an intra doc injection test for modules\n+//! [Struct]\n+//! This is an intra doc injection test for modules\n+\n+pub struct Struct;\n+\"##,\n+        expect_file![\"./test_data/highlight_module_docs_outline.html\"],\n+        false,\n+    );\n+}\n+\n+#[test]\n+#[cfg_attr(\n+    all(unix, not(target_pointer_width = \"64\")),\n+    ignore = \"depends on `DefaultHasher` outputs\"\n+)]\n fn test_rainbow_highlighting() {\n     check_highlighting(\n         r#\""}, {"sha": "d6a706a7cd73a82efc2dad0b97adc7ae4e9623ce", "filename": "src/tools/rust-analyzer/crates/limit/src/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2Fsrc%2Flib.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -2,27 +2,36 @@\n \n #![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n \n+#[cfg(feature = \"tracking\")]\n use std::sync::atomic::AtomicUsize;\n \n /// Represents a struct used to enforce a numerical limit.\n pub struct Limit {\n     upper_bound: usize,\n-    #[allow(unused)]\n+    #[cfg(feature = \"tracking\")]\n     max: AtomicUsize,\n }\n \n impl Limit {\n     /// Creates a new limit.\n     #[inline]\n     pub const fn new(upper_bound: usize) -> Self {\n-        Self { upper_bound, max: AtomicUsize::new(0) }\n+        Self {\n+            upper_bound,\n+            #[cfg(feature = \"tracking\")]\n+            max: AtomicUsize::new(0),\n+        }\n     }\n \n     /// Creates a new limit.\n     #[inline]\n     #[cfg(feature = \"tracking\")]\n     pub const fn new_tracking(upper_bound: usize) -> Self {\n-        Self { upper_bound, max: AtomicUsize::new(1) }\n+        Self {\n+            upper_bound,\n+            #[cfg(feature = \"tracking\")]\n+            max: AtomicUsize::new(1),\n+        }\n     }\n \n     /// Gets the underlying numeric limit."}, {"sha": "8de5d33a1936d42479470854e39bee711f1916a2", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -54,7 +54,7 @@ fn path_for_qualifier(\n     mut qual: CompletedMarker,\n ) -> CompletedMarker {\n     loop {\n-        let use_tree = matches!(p.nth(2), T![*] | T!['{']);\n+        let use_tree = mode == Mode::Use && matches!(p.nth(2), T![*] | T!['{']);\n         if p.at(T![::]) && !use_tree {\n             let path = qual.precede(p);\n             p.bump(T![::]);"}, {"sha": "4c205b9cadac3abd8311f9a7c1ae4d4f113f1b63", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -39,6 +39,8 @@ pub(crate) struct ProcMacroSrv {\n     expanders: HashMap<(PathBuf, SystemTime), dylib::Expander>,\n }\n \n+const EXPANDER_STACK_SIZE: usize = 8 * 1024 * 1024;\n+\n impl ProcMacroSrv {\n     pub fn expand(&mut self, task: ExpandMacro) -> Result<FlatTree, PanicMessage> {\n         let expander = self.expander(task.lib.as_ref()).map_err(|err| {\n@@ -66,13 +68,18 @@ impl ProcMacroSrv {\n         // FIXME: replace this with std's scoped threads once they stabilize\n         // (then remove dependency on crossbeam)\n         let result = crossbeam::scope(|s| {\n-            let res = s\n+            let res = match s\n+                .builder()\n+                .stack_size(EXPANDER_STACK_SIZE)\n+                .name(task.macro_name.clone())\n                 .spawn(|_| {\n                     expander\n                         .expand(&task.macro_name, &macro_body, attributes.as_ref())\n                         .map(|it| FlatTree::new(&it))\n-                })\n-                .join();\n+                }) {\n+                Ok(handle) => handle.join(),\n+                Err(e) => std::panic::resume_unwind(Box::new(e)),\n+            };\n \n             match res {\n                 Ok(res) => res,"}, {"sha": "5d1c013c3275b2fabf86110ec16ac13dc75e0a1f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -66,7 +66,9 @@ pub fn load_workspace(\n     };\n \n     let crate_graph = ws.to_crate_graph(\n-        &mut |_, path: &AbsPath| load_proc_macro(proc_macro_client.as_ref(), path, &[]),\n+        &mut |_, path: &AbsPath| {\n+            load_proc_macro(proc_macro_client.as_ref().map_err(|e| &**e), path, &[])\n+        },\n         &mut |path: &AbsPath| {\n             let contents = loader.load_sync(path);\n             let path = vfs::VfsPath::from(path.to_path_buf());"}, {"sha": "eaab275bc68a41724f20d928d6081e2acbded763", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -303,6 +303,9 @@ impl GlobalState {\n         let files_config = self.config.files();\n         let project_folders = ProjectFolders::new(&self.workspaces, &files_config.exclude);\n \n+        let standalone_server_name =\n+            format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n+\n         if self.proc_macro_clients.is_empty() {\n             if let Some((path, args)) = self.config.proc_macro_srv() {\n                 self.proc_macro_clients = self\n@@ -316,10 +319,8 @@ impl GlobalState {\n                             tracing::info!(\"Found a cargo workspace...\");\n                             if let Some(sysroot) = sysroot.as_ref() {\n                                 tracing::info!(\"Found a cargo workspace with a sysroot...\");\n-                                let server_path = sysroot\n-                                    .root()\n-                                    .join(\"libexec\")\n-                                    .join(\"rust-analyzer-proc-macro-srv\");\n+                                let server_path =\n+                                    sysroot.root().join(\"libexec\").join(&standalone_server_name);\n                                 if std::fs::metadata(&server_path).is_ok() {\n                                     tracing::info!(\n                                         \"And the server exists at {}\",\n@@ -389,7 +390,10 @@ impl GlobalState {\n \n             let mut crate_graph = CrateGraph::default();\n             for (idx, ws) in self.workspaces.iter().enumerate() {\n-                let proc_macro_client = self.proc_macro_clients[idx].as_ref();\n+                let proc_macro_client = match self.proc_macro_clients.get(idx) {\n+                    Some(res) => res.as_ref().map_err(|e| &**e),\n+                    None => Err(\"Proc macros are disabled\"),\n+                };\n                 let mut load_proc_macro = move |crate_name: &str, path: &AbsPath| {\n                     load_proc_macro(\n                         proc_macro_client,\n@@ -573,7 +577,7 @@ impl SourceRootConfig {\n /// Load the proc-macros for the given lib path, replacing all expanders whose names are in `dummy_replace`\n /// with an identity dummy expander.\n pub(crate) fn load_proc_macro(\n-    server: Result<&ProcMacroServer, &String>,\n+    server: Result<&ProcMacroServer, &str>,\n     path: &AbsPath,\n     dummy_replace: &[Box<str>],\n ) -> ProcMacroLoadResult {"}, {"sha": "63309a155219e55ebec99bcfd3b416ede648df38", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -880,7 +880,6 @@ impl ForExpr {\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n-    pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -890,7 +889,6 @@ pub struct IfExpr {\n impl ast::HasAttrs for IfExpr {}\n impl IfExpr {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn else_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![else]) }\n }\n \n@@ -1051,7 +1049,6 @@ pub struct WhileExpr {\n impl ast::HasAttrs for WhileExpr {}\n impl WhileExpr {\n     pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }\n-    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1170,7 +1167,6 @@ pub struct MatchGuard {\n }\n impl MatchGuard {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "bb92c51e9a90ed766bce24344f8ddeeb2337ed8c", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -806,6 +806,19 @@ impl ast::GenericParamList {\n     }\n }\n \n+impl ast::ForExpr {\n+    pub fn iterable(&self) -> Option<ast::Expr> {\n+        // If the iterable is a BlockExpr, check if the body is missing.\n+        // If it is assume the iterable is the expression that is missing instead.\n+        let mut exprs = support::children(self.syntax());\n+        let first = exprs.next();\n+        match first {\n+            Some(ast::Expr::BlockExpr(_)) => exprs.next().and(first),\n+            first => first,\n+        }\n+    }\n+}\n+\n impl ast::HasLoopBody for ast::ForExpr {\n     fn loop_body(&self) -> Option<ast::BlockExpr> {\n         let mut exprs = support::children(self.syntax());\n@@ -815,6 +828,19 @@ impl ast::HasLoopBody for ast::ForExpr {\n     }\n }\n \n+impl ast::WhileExpr {\n+    pub fn condition(&self) -> Option<ast::Expr> {\n+        // If the condition is a BlockExpr, check if the body is missing.\n+        // If it is assume the condition is the expression that is missing instead.\n+        let mut exprs = support::children(self.syntax());\n+        let first = exprs.next();\n+        match first {\n+            Some(ast::Expr::BlockExpr(_)) => exprs.next().and(first),\n+            first => first,\n+        }\n+    }\n+}\n+\n impl ast::HasLoopBody for ast::WhileExpr {\n     fn loop_body(&self) -> Option<ast::BlockExpr> {\n         let mut exprs = support::children(self.syntax());\n@@ -835,3 +861,15 @@ impl From<ast::Adt> for ast::Item {\n         }\n     }\n }\n+\n+impl ast::IfExpr {\n+    pub fn condition(&self) -> Option<ast::Expr> {\n+        support::child(&self.syntax)\n+    }\n+}\n+\n+impl ast::MatchGuard {\n+    pub fn condition(&self) -> Option<ast::Expr> {\n+        support::child(&self.syntax)\n+    }\n+}"}, {"sha": "6d2766225103f7b0aa2406a99939031a973b7274", "filename": "src/tools/rust-analyzer/crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -682,6 +682,8 @@ fn lower_rule(acc: &mut Vec<Field>, grammar: &Grammar, label: Option<&String>, r\n                     | \"value\"\n                     | \"trait\"\n                     | \"self_ty\"\n+                    | \"iterable\"\n+                    | \"condition\"\n             );\n             if manually_implemented {\n                 return;"}, {"sha": "76bbd1e91889e8267f4eb74c8fd4ed10e2ab5dd4", "filename": "src/tools/rust-analyzer/docs/dev/README.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -210,7 +210,8 @@ Release process is handled by `release`, `dist` and `promote` xtasks, `release`\n ./rust-rust-analyzer  # Note the name!\n ```\n \n-Additionally, it assumes that the remote for `rust-analyzer` is called `upstream` (I use `origin` to point to my fork).\n+The remote for `rust-analyzer` must be called `upstream` (I use `origin` to point to my fork).\n+In addition, for `xtask promote` (see below), `rust-rust-analyzer` must have a `rust-analyzer` remote pointing to this repository on GitHub.\n \n `release` calls the GitHub API calls to scrape pull request comments and categorize them in the changelog.\n This step uses the `curl` and `jq` applications, which need to be available in `PATH`.\n@@ -225,13 +226,13 @@ Release steps:\n    * push it to `upstream`. This triggers GitHub Actions which:\n      * runs `cargo xtask dist` to package binaries and VS Code extension\n      * makes a GitHub release\n-     * pushes VS Code extension to the marketplace\n+     * publishes the VS Code extension to the marketplace\n    * call the GitHub API for PR details\n    * create a new changelog in `rust-analyzer.github.io`\n 3. While the release is in progress, fill in the changelog\n 4. Commit & push the changelog\n 5. Tweet\n-6. Inside `rust-analyzer`, run `cargo xtask promote` -- this will create a PR to rust-lang/rust updating rust-analyzer's submodule.\n+6. Inside `rust-analyzer`, run `cargo xtask promote` -- this will create a PR to rust-lang/rust updating rust-analyzer's subtree.\n    Self-approve the PR.\n \n If the GitHub Actions release fails because of a transient problem like a timeout, you can re-run the job from the Actions console."}, {"sha": "17ada5156407e99b3e416303382f4b0ba0da64df", "filename": "src/tools/rust-analyzer/xtask/src/release.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -77,18 +77,12 @@ impl flags::Promote {\n         cmd!(sh, \"git switch master\").run()?;\n         cmd!(sh, \"git fetch upstream\").run()?;\n         cmd!(sh, \"git reset --hard upstream/master\").run()?;\n-        cmd!(sh, \"git submodule update --recursive\").run()?;\n \n         let date = date_iso(sh)?;\n         let branch = format!(\"rust-analyzer-{date}\");\n         cmd!(sh, \"git switch -c {branch}\").run()?;\n-        {\n-            let _dir = sh.push_dir(\"src/tools/rust-analyzer\");\n-            cmd!(sh, \"git fetch origin\").run()?;\n-            cmd!(sh, \"git reset --hard origin/release\").run()?;\n-        }\n-        cmd!(sh, \"git add src/tools/rust-analyzer\").run()?;\n-        cmd!(sh, \"git commit -m':arrow_up: rust-analyzer'\").run()?;\n+        cmd!(sh, \"git subtree pull -P src/tools/rust-analyzer rust-analyzer master\").run()?;\n+\n         if !self.dry_run {\n             cmd!(sh, \"git push -u origin {branch}\").run()?;\n             cmd!("}, {"sha": "b1d8b86496ad0fc630282192239f0fafa9312d8d", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e141246cbbce2a6001f3181d3d0f661bbfd9c7ea/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=e141246cbbce2a6001f3181d3d0f661bbfd9c7ea", "patch": "@@ -79,11 +79,10 @@ crossbeam-utils = { version = \"0.8.0\", features = [\"nightly\"] }\n libc = { version = \"0.2.79\", features = [\"align\"] }\n # Ensure default features of libz-sys, which are disabled in some scenarios.\n libz-sys = { version = \"1.1.2\" }\n-\n-# looks like the only user of deprecated `use_std` feature is `combine`, so this\n-# can be removed if/when https://github.com/Marwes/combine/pull/348 be merged and released.\n+# The only user of memchr's deprecated `use_std` feature is `combine`, so this can be\n+# removed if/when https://github.com/Marwes/combine/pull/348 is merged and released.\n memchr = { version = \"2.5\", features = [\"std\", \"use_std\"] }\n-# same for regex\n+# Ensure default features of regex, which are disabled in some scenarios.\n regex = { version = \"1.5.6\" }\n proc-macro2 = { version = \"1\", features = [\"default\"] }\n quote = { version = \"1\", features = [\"default\"] }"}]}