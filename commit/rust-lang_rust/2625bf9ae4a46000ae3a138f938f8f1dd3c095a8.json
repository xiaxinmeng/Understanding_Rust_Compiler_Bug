{"sha": "2625bf9ae4a46000ae3a138f938f8f1dd3c095a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MjViZjlhZTRhNDYwMDBhZTNhMTM4ZjkzOGY4ZjFkZDNjMDk1YTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-03-10T20:35:24Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-03-23T17:21:54Z"}, "message": "Fix regression in -C rpath that causes failures with symlinks\n\nThe new `relative_from` method no longer supports the case on unix\nwhere both paths are absolute, which `-C rpath` depended on. This\nversion fixes the problem by copying the old path_relative_from\nfunction into the rpath module.\n\nFixes #23140", "tree": {"sha": "c1b384f3845d55d0ece8124ed195a35f317a7c37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1b384f3845d55d0ece8124ed195a35f317a7c37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2625bf9ae4a46000ae3a138f938f8f1dd3c095a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2625bf9ae4a46000ae3a138f938f8f1dd3c095a8", "html_url": "https://github.com/rust-lang/rust/commit/2625bf9ae4a46000ae3a138f938f8f1dd3c095a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2625bf9ae4a46000ae3a138f938f8f1dd3c095a8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0aad7dd4fad8d7e2e2f877a511a637258949597", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0aad7dd4fad8d7e2e2f877a511a637258949597", "html_url": "https://github.com/rust-lang/rust/commit/b0aad7dd4fad8d7e2e2f877a511a637258949597"}], "stats": {"total": 58, "additions": 43, "deletions": 15}, "files": [{"sha": "68d21abb50ef5e74fd21f4a071ac3efa413bfc92", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2625bf9ae4a46000ae3a138f938f8f1dd3c095a8/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2625bf9ae4a46000ae3a138f938f8f1dd3c095a8/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=2625bf9ae4a46000ae3a138f938f8f1dd3c095a8", "patch": "@@ -99,30 +99,58 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String\n     lib.pop();\n     let mut output = (config.realpath)(&cwd.join(&config.out_filename)).unwrap();\n     output.pop();\n-    let relative = relativize(&lib, &output);\n+    let relative = path_relative_from(&lib, &output)\n+        .expect(&format!(\"couldn't create relative path from {:?} to {:?}\", output, lib));\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     format!(\"{}/{}\", prefix,\n             relative.to_str().expect(\"non-utf8 component in path\"))\n }\n \n-fn relativize(path: &Path, rel: &Path) -> PathBuf {\n-    let mut res = PathBuf::new(\"\");\n-    let mut cur = rel;\n-    while !path.starts_with(cur) {\n-        res.push(\"..\");\n-        match cur.parent() {\n-            Some(p) => cur = p,\n-            None => panic!(\"can't create relative paths across filesystems\"),\n+// This routine is adapted from the *old* Path's `path_relative_from`\n+// function, which works differently from the new `relative_from` function.\n+// In particular, this handles the case on unix where both paths are\n+// absolute but with only the root as the common directory.\n+fn path_relative_from(path: &Path, base: &Path) -> Option<PathBuf> {\n+    use std::path::Component;\n+\n+    if path.is_absolute() != base.is_absolute() {\n+        if path.is_absolute() {\n+            Some(PathBuf::new(path))\n+        } else {\n+            None\n         }\n+    } else {\n+        let mut ita = path.components();\n+        let mut itb = base.components();\n+        let mut comps: Vec<Component> = vec![];\n+        loop {\n+            match (ita.next(), itb.next()) {\n+                (None, None) => break,\n+                (Some(a), None) => {\n+                    comps.push(a);\n+                    comps.extend(ita.by_ref());\n+                    break;\n+                }\n+                (None, _) => comps.push(Component::ParentDir),\n+                (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n+                (Some(a), Some(b)) if b == Component::CurDir => comps.push(a),\n+                (Some(_), Some(b)) if b == Component::ParentDir => return None,\n+                (Some(a), Some(_)) => {\n+                    comps.push(Component::ParentDir);\n+                    for _ in itb {\n+                        comps.push(Component::ParentDir);\n+                    }\n+                    comps.push(a);\n+                    comps.extend(ita.by_ref());\n+                    break;\n+                }\n+            }\n+        }\n+        Some(comps.iter().map(|c| c.as_os_str()).collect())\n     }\n-    match path.relative_from(cur) {\n-        Some(s) => { res.push(s); res }\n-        None => panic!(\"couldn't create relative path from {:?} to {:?}\",\n-                       rel, path),\n-    }\n-\n }\n \n+\n fn get_install_prefix_rpath(config: &mut RPathConfig) -> String {\n     let path = (config.get_install_prefix_lib_path)();\n     let path = env::current_dir().unwrap().join(&path);"}]}