{"sha": "2ff117df5096c23b466992a0a3427edf1af3113d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZjExN2RmNTA5NmMyM2I0NjY5OTJhMGEzNDI3ZWRmMWFmMzExM2Q=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-01T13:26:53Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-05T06:58:05Z"}, "message": "rustc/ty: whitespace fixes", "tree": {"sha": "701273dc49b8bdb04448f7ed225759f268c026ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/701273dc49b8bdb04448f7ed225759f268c026ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ff117df5096c23b466992a0a3427edf1af3113d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff117df5096c23b466992a0a3427edf1af3113d", "html_url": "https://github.com/rust-lang/rust/commit/2ff117df5096c23b466992a0a3427edf1af3113d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ff117df5096c23b466992a0a3427edf1af3113d/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8bea5a0a6aef3966008787a25949344f8cf6942", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8bea5a0a6aef3966008787a25949344f8cf6942", "html_url": "https://github.com/rust-lang/rust/commit/b8bea5a0a6aef3966008787a25949344f8cf6942"}], "stats": {"total": 88, "additions": 42, "deletions": 46}, "files": [{"sha": "8738f574148239e37966edc1ef3ef1a90f2f532e", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=2ff117df5096c23b466992a0a3427edf1af3113d", "patch": "@@ -178,19 +178,19 @@ pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n     Ok(ty::GenericPredicates {\n         parent: Decodable::decode(decoder)?,\n         predicates: (0..decoder.read_usize()?).map(|_| {\n-                // Handle shorthands first, if we have an usize > 0x80.\n-                let predicate = if decoder.positioned_at_shorthand() {\n-                    let pos = decoder.read_usize()?;\n-                    assert!(pos >= SHORTHAND_OFFSET);\n-                    let shorthand = pos - SHORTHAND_OFFSET;\n-\n-                    decoder.with_position(shorthand, ty::Predicate::decode)\n-                } else {\n-                    ty::Predicate::decode(decoder)\n-                }?;\n-                Ok((predicate, Decodable::decode(decoder)?))\n-            })\n-            .collect::<Result<Vec<_>, _>>()?,\n+            // Handle shorthands first, if we have an usize > 0x80.\n+            let predicate = if decoder.positioned_at_shorthand() {\n+                let pos = decoder.read_usize()?;\n+                assert!(pos >= SHORTHAND_OFFSET);\n+                let shorthand = pos - SHORTHAND_OFFSET;\n+\n+                decoder.with_position(shorthand, ty::Predicate::decode)\n+            } else {\n+                ty::Predicate::decode(decoder)\n+            }?;\n+            Ok((predicate, Decodable::decode(decoder)?))\n+        })\n+        .collect::<Result<Vec<_>, _>>()?,\n     })\n }\n \n@@ -267,7 +267,7 @@ pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n \n #[inline]\n pub fn decode_allocation<'a, 'tcx, D>(decoder: &mut D)\n-                                 -> Result<&'tcx Allocation, D::Error>\n+    -> Result<&'tcx Allocation, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {"}, {"sha": "daada8891d7a73ac80f37a652678497aed4e90e8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2ff117df5096c23b466992a0a3427edf1af3113d", "patch": "@@ -190,8 +190,8 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             // types/regions in the global interner\n             if local as *const _ as usize == global as *const _ as usize {\n                 bug!(\"Attempted to intern `{:?}` which contains \\\n-                    inference types/regions in the global type context\",\n-                    &ty_struct);\n+                      inference types/regions in the global type context\",\n+                     &ty_struct);\n             }\n \n             // Don't be &mut TyS.\n@@ -272,9 +272,9 @@ fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n \n                     bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n                           TypeckTables with local_id_root {:?}\",\n-                          tcx.hir.node_to_string(node_id),\n-                          DefId::local(hir_id.owner),\n-                          local_id_root)\n+                         tcx.hir.node_to_string(node_id),\n+                         DefId::local(hir_id.owner),\n+                         local_id_root)\n                 });\n             }\n         } else {\n@@ -686,7 +686,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn pat_adjustments_mut(&mut self)\n-                           -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+                               -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n             data: &mut self.pat_adjustments,\n@@ -1199,8 +1199,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let hir_id = hir.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner).or_default();\n             Lrc::get_mut(map).unwrap()\n-                            .insert(hir_id.local_id,\n-                                    Lrc::new(StableVec::new(v)));\n+                             .insert(hir_id.local_id,\n+                                     Lrc::new(StableVec::new(v)));\n         }\n \n         let gcx = &GlobalCtxt {\n@@ -2188,7 +2188,6 @@ macro_rules! sty_debug_print {\n                 };\n                 $(let mut $variant = total;)*\n \n-\n                 for &Interned(t) in tcx.interners.type_.borrow().iter() {\n                     let variant = match t.sty {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n@@ -2207,7 +2206,7 @@ macro_rules! sty_debug_print {\n                 }\n                 println!(\"Ty interner             total           ty region  both\");\n                 $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n-{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                            {ty:4.1}% {region:5.1}% {both:4.1}%\",\n                            stringify!($variant),\n                            uses = $variant.total,\n                            usespc = $variant.total as f64 * 100.0 / total.total as f64,\n@@ -2216,7 +2215,7 @@ macro_rules! sty_debug_print {\n                            both = $variant.both_infer as f64 * 100.0  / total.total as f64);\n                   )*\n                 println!(\"                  total {uses:6}        \\\n-{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                          {ty:4.1}% {region:5.1}% {both:4.1}%\",\n                          uses = total.total,\n                          ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n                          region = total.region_infer as f64 * 100.0  / total.total as f64,\n@@ -2653,7 +2652,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n     pub fn mk_closure(self, closure_id: DefId, closure_substs: ClosureSubsts<'tcx>)\n-                                          -> Ty<'tcx> {\n+                      -> Ty<'tcx> {\n         self.mk_ty(Closure(closure_id, closure_substs))\n     }\n \n@@ -2686,8 +2685,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_ty_param(self,\n-                    index: u32,\n-                    name: InternedString) -> Ty<'tcx> {\n+                       index: u32,\n+                       name: InternedString) -> Ty<'tcx> {\n         self.mk_ty(Param(ParamTy { idx: index, name: name }))\n     }\n "}, {"sha": "0e11d6e0eec02c26ea16370dca38e89c78fccfbd", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=2ff117df5096c23b466992a0a3427edf1af3113d", "patch": "@@ -386,8 +386,8 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_sta\n \n     #[inline]\n     fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          id: SerializedDepNodeIndex)\n-                          -> Option<Self::Value> {\n+                              id: SerializedDepNodeIndex)\n+                              -> Option<Self::Value> {\n         tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n     }\n }"}, {"sha": "7d3ce7307dc8593fd66672f5140fe364ee60c4ba", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=2ff117df5096c23b466992a0a3427edf1af3113d", "patch": "@@ -448,9 +448,9 @@ impl<'sess> OnDiskCache<'sess> {\n             }).collect::<FxHashMap<_,_>>();\n \n             let map_size = prev_cnums.iter()\n-                                    .map(|&(cnum, ..)| cnum)\n-                                    .max()\n-                                    .unwrap_or(0) + 1;\n+                                     .map(|&(cnum, ..)| cnum)\n+                                     .max()\n+                                     .unwrap_or(0) + 1;\n             let mut map = IndexVec::new();\n             map.resize(map_size as usize, None);\n \n@@ -465,7 +465,6 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n }\n \n-\n //- DECODING -------------------------------------------------------------------\n \n /// A decoder that can read the incr. comp. cache. It is similar to the one\n@@ -494,7 +493,7 @@ impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n         file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n             source_map.source_file_by_stable_id(stable_id)\n-                   .expect(\"Failed to lookup SourceFile in new context.\")\n+                .expect(\"Failed to lookup SourceFile in new context.\")\n         }).clone()\n     }\n }\n@@ -761,7 +760,7 @@ for CacheDecoder<'a, 'tcx, 'x> {\n \n struct CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder,\n-          'tcx: 'a,\n+             'tcx: 'a,\n {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     encoder: &'enc mut E,\n@@ -839,9 +838,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx\n         let (file_lo, line_lo, col_lo) = match self.source_map\n                                                    .byte_pos_to_line_and_col(span_data.lo) {\n             Some(pos) => pos,\n-            None => {\n-                return TAG_INVALID_SPAN.encode(self);\n-            }\n+            None => return TAG_INVALID_SPAN.encode(self)\n         };\n \n         if !file_lo.contains(span_data.hi) {"}, {"sha": "5f6fdbddf8fed7d63ba7dccd3382b79ca50a08a7", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff117df5096c23b466992a0a3427edf1af3113d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=2ff117df5096c23b466992a0a3427edf1af3113d", "patch": "@@ -449,14 +449,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let prev_dep_node_index =\n                 self.dep_graph.prev_dep_node_index_of(dep_node);\n             let result = Q::try_load_from_disk(self.global_tcx(),\n-                                                    prev_dep_node_index);\n+                                               prev_dep_node_index);\n \n             // We always expect to find a cached result for things that\n             // can be forced from DepNode.\n             debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n-                            result.is_some(),\n-                            \"Missing on-disk cache entry for {:?}\",\n-                            dep_node);\n+                          result.is_some(),\n+                          \"Missing on-disk cache entry for {:?}\",\n+                          dep_node);\n             result\n         } else {\n             // Some things are never cached on disk.\n@@ -491,7 +491,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n                     self.dep_graph.prev_fingerprint_of(dep_node),\n                     \"Fingerprint for green query instance not loaded \\\n-                        from cache: {:?}\", dep_node);\n+                     from cache: {:?}\", dep_node);\n \n             debug!(\"BEGIN verify_ich({:?})\", dep_node);\n             let mut hcx = self.create_stable_hashing_context();\n@@ -530,8 +530,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //    (see for example #48923)\n         assert!(!self.dep_graph.dep_node_exists(&dep_node),\n                 \"Forcing query with already existing DepNode.\\n\\\n-                    - query-key: {:?}\\n\\\n-                    - dep-node: {:?}\",\n+                 - query-key: {:?}\\n\\\n+                 - dep-node: {:?}\",\n                 key, dep_node);\n \n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);"}]}