{"sha": "d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YmYzYjg1ZDEwNzhmM2EyZGQ0Y2I5ZjAwOWFmMDE4YzJiNGMwNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-13T23:09:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-13T23:09:07Z"}, "message": "auto merge of #4908 : bstrie/rust/rimov3, r=pcwalton\n\nThis patch finishes removing inner vector mutability from the vast majority of the compiler. Exceptions:\r\n\r\n* core::dvec: ideally this entire type will be able to be replaced by `~[]`, but Niko asked me to hold off on removing Dvecs until he makes some fixes to borrowed pointers. \r\n* liveness: liveness.rs is an impenetrable neutron star of deprecated semantics.\r\n* compile-fail: I'm not sure if a lot of these tests are testing inner mutability or mutability in general. I figure that RIMOVing this folder should wait until this syntax is removed from the parser.\r\n\r\nI also took this chance to remove many of the inner-mutability-related functions from core::vec, or as many uses of those functions as possible where still necessary. consume_mut and append_mut have been axed. cast_to_mut and cast_from_mut are still needed in a few places.", "tree": {"sha": "7b1b8b8dc6121350b854cd3496fed65100683313", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b1b8b8dc6121350b854cd3496fed65100683313"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "html_url": "https://github.com/rust-lang/rust/commit/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e6d7871c656145a5530b653882a3ce26f40c163", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6d7871c656145a5530b653882a3ce26f40c163", "html_url": "https://github.com/rust-lang/rust/commit/5e6d7871c656145a5530b653882a3ce26f40c163"}, {"sha": "e6c82c0375e042e062079c056e5e3ac31eb86005", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c82c0375e042e062079c056e5e3ac31eb86005", "html_url": "https://github.com/rust-lang/rust/commit/e6c82c0375e042e062079c056e5e3ac31eb86005"}], "stats": {"total": 219, "additions": 96, "deletions": 123}, "files": [{"sha": "83ab56309c13fb04f2e8156a432f9d95d3b3ee29", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -322,8 +322,8 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n                          ProcRes: ProcRes) {\n \n     // true if we found the error in question\n-    let found_flags = vec::cast_to_mut(vec::from_elem(\n-        vec::len(expected_errors), false));\n+    let mut found_flags = vec::from_elem(\n+        vec::len(expected_errors), false);\n \n     if ProcRes.status == 0 {\n         fatal(~\"process did not return an error status\");"}, {"sha": "e53b7d29ebe7fe8301c570f95e5618043a727257", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -165,7 +165,7 @@ struct SipState {\n     mut v1: u64,\n     mut v2: u64,\n     mut v3: u64,\n-    tail: [mut u8 * 8], // unprocessed bytes\n+    mut tail: [u8 * 8], // unprocessed bytes\n     mut ntail: uint,  // how many bytes in tail are valid\n }\n \n@@ -179,7 +179,7 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n         mut v1 : 0u64,\n         mut v2 : 0u64,\n         mut v3 : 0u64,\n-        tail : [mut 0u8,0,0,0,0,0,0,0],\n+        mut tail : [0u8,0,0,0,0,0,0,0],\n         mut ntail : 0u,\n     };\n     (&state).reset();"}, {"sha": "c1e47439e9280588aa0c7626e17c5ab83f1f908f", "filename": "src/libcore/io.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -56,7 +56,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n \n     /// Read a single byte, returning a negative value for EOF or read error.\n     fn read_byte(&self) -> int;\n@@ -416,7 +416,7 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n }\n \n impl *libc::FILE: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         unsafe {\n             do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n                 assert buf_len >= len;\n@@ -461,7 +461,7 @@ struct Wrapper<T, C> {\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n impl<R: Reader, C> Wrapper<R, C>: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         self.base.read(bytes, len)\n     }\n     fn read_byte(&self) -> int { self.base.read_byte() }\n@@ -528,7 +528,7 @@ pub struct BytesReader {\n }\n \n impl BytesReader: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         let count = uint::min(len, self.bytes.len() - self.pos);\n \n         let view = vec::view(self.bytes, self.pos, self.bytes.len());"}, {"sha": "ce590092db8fc8cfb87e68f97b9c4236f38becb7", "filename": "src/libcore/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -79,7 +79,7 @@ pub fn as_c_charp<T>(s: &str, f: fn(*c_char) -> T) -> T {\n \n pub fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n     -> Option<~str> {\n-    let buf = vec::cast_to_mut(vec::from_elem(TMPBUF_SZ, 0u8 as c_char));\n+    let mut buf = vec::from_elem(TMPBUF_SZ, 0u8 as c_char);\n     do vec::as_mut_buf(buf) |b, sz| {\n         if f(b, sz as size_t) {\n             unsafe {\n@@ -108,7 +108,7 @@ pub mod win32 {\n             let mut res = None;\n             let mut done = false;\n             while !done {\n-                let buf = vec::cast_to_mut(vec::from_elem(n as uint, 0u16));\n+                let mut buf = vec::from_elem(n as uint, 0u16);\n                 do vec::as_mut_buf(buf) |b, _sz| {\n                     let k : DWORD = f(b, TMPBUF_SZ as DWORD);\n                     if k == (0 as DWORD) {\n@@ -1325,7 +1325,7 @@ mod tests {\n           };\n           assert (ostream as uint != 0u);\n           let s = ~\"hello\";\n-          let mut buf = vec::cast_to_mut(str::to_bytes(s) + ~[0 as u8]);\n+          let mut buf = str::to_bytes(s) + ~[0 as u8];\n           do vec::as_mut_buf(buf) |b, _len| {\n               assert (libc::fwrite(b as *c_void, 1u as size_t,\n                                    (str::len(s) + 1u) as size_t, ostream)"}, {"sha": "1881bd784c4cb1ca7c75a7ace10fe02ff4a90e54", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -350,7 +350,7 @@ impl Rng {\n     }\n \n     /// Shuffle a mutable vec in place\n-    fn shuffle_mut<T>(values: &[mut T]) {\n+    fn shuffle_mut<T>(values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place."}, {"sha": "0ef22cfc5ec69c4f85db8f2e9b315d10e1c8784a", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -290,7 +290,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n \n fn read_all(rd: io::Reader) -> ~str {\n     let buf = io::with_bytes_writer(|wr| {\n-        let mut bytes = [mut 0, ..4096];\n+        let mut bytes = [0, ..4096];\n         while !rd.eof() {\n             let nread = rd.read(bytes, bytes.len());\n             wr.write(bytes.view(0, nread));\n@@ -391,7 +391,7 @@ pub fn readclose(fd: c_int) -> ~str {\n         let file = os::fdopen(fd);\n         let reader = io::FILE_reader(file, false);\n         let buf = io::with_bytes_writer(|writer| {\n-            let mut bytes = [mut 0, ..4096];\n+            let mut bytes = [0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n                 writer.write(bytes.view(0, nread));"}, {"sha": "7f02ad79583e32fc5346b1bb11032e330e2130e4", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 15, "deletions": 45, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -558,10 +558,6 @@ pub fn consume<T>(mut v: ~[T], f: fn(uint, v: T)) {\n     }\n }\n \n-pub fn consume_mut<T>(v: ~[mut T], f: fn(uint, v: T)) {\n-    consume(vec::cast_from_mut(v), f)\n-}\n-\n /// Remove the last element from a vector and return it\n pub fn pop<T>(v: &mut ~[T]) -> T {\n     let ln = v.len();\n@@ -728,11 +724,6 @@ pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     v\n }\n \n-#[inline(always)]\n-pub pure fn append_mut<T: Copy>(lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n-    cast_to_mut(append(cast_from_mut(lhs), rhs))\n-}\n-\n /**\n  * Expands a vector in place, initializing the new elements to a given value\n  *\n@@ -1285,12 +1276,12 @@ pub pure fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n  * * a - The index of the first element\n  * * b - The index of the second element\n  */\n-pub fn swap<T>(v: &[mut T], a: uint, b: uint) {\n+pub fn swap<T>(v: &mut [T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n /// Reverse the order of elements in a vector, in place\n-pub fn reverse<T>(v: &[mut T]) {\n+pub fn reverse<T>(v: &mut [T]) {\n     let mut i: uint = 0;\n     let ln = len::<T>(v);\n     while i < ln / 2 { v[i] <-> v[ln - i - 1]; i += 1; }\n@@ -1371,7 +1362,7 @@ pub pure fn each<T>(v: &r/[T], f: fn(&r/T) -> bool) {\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-pub fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n+pub fn each_mut<T>(v: &mut [T], f: fn(elem: &mut T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1541,7 +1532,7 @@ pub pure fn as_const_buf<T,U>(s: &[const T],\n \n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline(always)]\n-pub pure fn as_mut_buf<T,U>(s: &[mut T],\n+pub pure fn as_mut_buf<T,U>(s: &mut [T],\n                         f: fn(*mut T, uint) -> U) -> U {\n \n     unsafe {\n@@ -1653,21 +1644,14 @@ impl<T: Ord> @[T] : Ord {\n pub mod traits {\n     use kinds::Copy;\n     use ops::Add;\n-    use vec::{append, append_mut};\n+    use vec::append;\n \n     impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n         #[inline(always)]\n         pure fn add(&self, rhs: & &self/[const T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n     }\n-\n-    impl<T: Copy> ~[mut T] : Add<&[const T],~[mut T]> {\n-        #[inline(always)]\n-        pure fn add(&self, rhs: & &self/[const T]) -> ~[mut T] {\n-            append_mut(copy *self, (*rhs))\n-        }\n-    }\n }\n \n impl<T> &[const T]: Container {\n@@ -2088,7 +2072,7 @@ pub mod raw {\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    pub unsafe fn to_mut_ptr<T>(v: &[mut T]) -> *mut T {\n+    pub unsafe fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n@@ -2121,7 +2105,7 @@ pub mod raw {\n      * is newly allocated.\n      */\n     #[inline(always)]\n-    pub unsafe fn init_elem<T>(v: &[mut T], i: uint, val: T) {\n+    pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n@@ -2155,7 +2139,7 @@ pub mod raw {\n       * may overlap.\n       */\n     #[inline(always)]\n-    pub unsafe fn copy_memory<T>(dst: &[mut T], src: &[const T],\n+    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[const T],\n                                  count: uint) {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n@@ -2222,7 +2206,7 @@ pub mod bytes {\n       * may overlap.\n       */\n     #[inline(always)]\n-    pub fn copy_memory(dst: &[mut u8], src: &[const u8], count: uint) {\n+    pub fn copy_memory(dst: &mut [u8], src: &[const u8], count: uint) {\n         // Bound checks are done at vec::raw::copy_memory.\n         unsafe { vec::raw::copy_memory(dst, src, count) }\n     }\n@@ -3220,7 +3204,7 @@ mod tests {\n \n     #[test]\n     fn reverse_and_reversed() {\n-        let v: ~[mut int] = ~[mut 10, 20];\n+        let mut v: ~[int] = ~[10, 20];\n         assert (v[0] == 10);\n         assert (v[1] == 20);\n         reverse(v);\n@@ -3235,13 +3219,13 @@ mod tests {\n \n         let v4 = reversed::<int>(~[]);\n         assert (v4 == ~[]);\n-        let v3: ~[mut int] = ~[mut];\n+        let mut v3: ~[int] = ~[];\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n-        let v2 = reversed::<int>(~[mut 10, 20]);\n+        let mut v2 = reversed::<int>(~[10, 20]);\n         assert (v2[0] == 20);\n         assert (v2[1] == 10);\n     }\n@@ -3625,20 +3609,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_consume_mut_fail() {\n-        let v = ~[mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do consume_mut(v) |_i, _elt| {\n-            if i == 2 {\n-                die!()\n-            }\n-            i += 1;\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -3657,7 +3627,7 @@ mod tests {\n     #[ignore(windows)]\n     #[should_fail]\n     fn test_map_fail() {\n-        let v = [mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n         do map(v) |_elt| {\n             if i == 2 {\n@@ -3983,7 +3953,7 @@ mod tests {\n     #[ignore(cfg(windows))]\n     #[should_fail]\n     fn test_as_mut_buf_fail() {\n-        let v = [mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         do as_mut_buf(v) |_buf, _i| {\n             die!()\n         }\n@@ -3994,7 +3964,7 @@ mod tests {\n     #[ignore(cfg(windows))]\n     fn test_copy_memory_oob() {\n         unsafe {\n-            let a = [mut 1, 2, 3, 4];\n+            let mut a = [1, 2, 3, 4];\n             let b = [1, 2, 3, 4, 5];\n             raw::copy_memory(a, b, 5);\n         }"}, {"sha": "d9d3b63b6c9a59d33291f2e548de40930de54d80", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -1002,7 +1002,7 @@ pub fn pick_col(m: &[@Match]) -> uint {\n           _ => 0u\n         }\n     }\n-    let scores = vec::cast_to_mut(vec::from_elem(m[0].pats.len(), 0u));\n+    let mut scores = vec::from_elem(m[0].pats.len(), 0u);\n     for vec::each(m) |br| {\n         let mut i = 0u;\n         for vec::each(br.pats) |p| { scores[i] += score(*p); i += 1u; }"}, {"sha": "00235c32d3c3dfc4da76c7fd0a2c82bba12e1eca", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -127,13 +127,13 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn all_mem(cls: &[mut x86_64_reg_class]) {\n+    fn all_mem(cls: &mut [x86_64_reg_class]) {\n         for uint::range(0, cls.len()) |i| {\n             cls[i] = memory_class;\n         }\n     }\n \n-    fn unify(cls: &[mut x86_64_reg_class],\n+    fn unify(cls: &mut [x86_64_reg_class],\n              i: uint,\n              newv: x86_64_reg_class) {\n         if cls[i] == newv {\n@@ -159,7 +159,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn classify_struct(tys: &[TypeRef],\n-                       cls: &[mut x86_64_reg_class], i: uint,\n+                       cls: &mut [x86_64_reg_class], i: uint,\n                        off: uint) {\n         let mut field_off = off;\n         for vec::each(tys) |ty| {\n@@ -170,7 +170,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn classify(ty: TypeRef,\n-                cls: &[mut x86_64_reg_class], ix: uint,\n+                cls: &mut [x86_64_reg_class], ix: uint,\n                 off: uint) {\n         unsafe {\n             let t_align = ty_align(ty);\n@@ -220,7 +220,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn fixup(ty: TypeRef, cls: &[mut x86_64_reg_class]) {\n+    fn fixup(ty: TypeRef, cls: &mut [x86_64_reg_class]) {\n         unsafe {\n             let mut i = 0u;\n             let llty = llvm::LLVMGetTypeKind(ty) as int;\n@@ -270,14 +270,15 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     let words = (ty_size(ty) + 7) / 8;\n-    let cls = vec::cast_to_mut(vec::from_elem(words, no_class));\n+    let mut cls = vec::from_elem(words, no_class);\n     if words > 4 {\n         all_mem(cls);\n-        return vec::cast_from_mut(move cls);\n+        let cls = cls;\n+        return move cls;\n     }\n     classify(ty, cls, 0, 0);\n     fixup(ty, cls);\n-    return vec::cast_from_mut(move cls);\n+    return move cls;\n }\n \n fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {"}, {"sha": "45b0fa962ad91e5f4a00c70b89a45bda15ce7ba4", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -779,7 +779,7 @@ pub impl LookupContext {\n         /*!\n          *\n          * In the event that we are invoking a method with a receiver\n-         * of a linear borrowed type like `&mut T` or `&[mut T]`,\n+         * of a linear borrowed type like `&mut T` or `&mut [T]`,\n          * we will \"reborrow\" the receiver implicitly.  For example, if\n          * you have a call `r.inc()` and where `r` has type `&mut T`,\n          * then we treat that like `(&mut *r).inc()`.  This avoids"}, {"sha": "d6bd9aa96dd5650d117e3218c44b9eb61a19a82b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -3131,7 +3131,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.len() == 0u { return; }\n-    let tps_used = vec::cast_to_mut(vec::from_elem(tps.len(), false));\n+    let mut tps_used = vec::from_elem(tps.len(), false);\n \n     ty::walk_regions_and_ty(\n         ccx.tcx, ty,"}, {"sha": "e3f8ef1b2b53bd12c13c11f89e4ad2c8a7514372", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -224,7 +224,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n     unsafe {\n         let n_opts = opts.len();\n         fn f(_x: uint) -> ~[Optval] { return ~[]; }\n-        let vals = vec::cast_to_mut(vec::from_fn(n_opts, f));\n+        let mut vals = vec::from_fn(n_opts, f);\n         let mut free: ~[~str] = ~[];\n         let l = args.len();\n         let mut i = 0;\n@@ -339,7 +339,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             i += 1;\n         }\n         return Ok(Matches {opts: vec::from_slice(opts),\n-                   vals: vec::cast_from_mut(move vals),\n+                   vals: move vals,\n                    free: free});\n     }\n }"}, {"sha": "6fe82d554de7585e7f66004bd0e86afc98e5474e", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -52,7 +52,7 @@ pub pure fn md4(msg: &[u8]) -> Quad {\n \n     let mut i = 0u;\n     let e = vec::len(msg);\n-    let x = vec::cast_to_mut(vec::from_elem(16u, 0u32));\n+    let mut x = vec::from_elem(16u, 0u32);\n     while i < e {\n         let aa = a, bb = b, cc = c, dd = d;\n "}, {"sha": "dbfa771e0a256aa433fdfddad420523a97680b9b", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -174,7 +174,7 @@ pub fn concat(v: ~[Rope]) -> Rope {\n     //Copy `v` into a mut vector\n     let mut len = vec::len(v);\n     if len == 0u { return node::Empty; }\n-    let ropes = vec::cast_to_mut(vec::from_elem(len, v[0]));\n+    let mut ropes = vec::from_elem(len, v[0]);\n     for uint::range(1u, len) |i| {\n        ropes[i] = v[i];\n     }\n@@ -719,7 +719,7 @@ pub mod node {\n             //Firstly, split `str` in slices of hint_max_leaf_char_len\n             let mut leaves = uint::div_ceil(char_len, hint_max_leaf_char_len);\n             //Number of leaves\n-            let nodes  = vec::cast_to_mut(vec::from_elem(leaves, candidate));\n+            let mut nodes  = vec::from_elem(leaves, candidate);\n \n             let mut i = 0u;\n             let mut offset = byte_start;\n@@ -832,7 +832,7 @@ pub mod node {\n \n     pub fn serialize_node(node: @Node) -> ~str {\n         unsafe {\n-            let mut buf = vec::cast_to_mut(vec::from_elem(byte_len(node), 0));\n+            let mut buf = vec::from_elem(byte_len(node), 0);\n             let mut offset = 0u;//Current position in the buffer\n             let it = leaf_iterator::start(node);\n             loop {"}, {"sha": "788d1d1012d2a09e67472cb613253fef599b8f03", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -35,21 +35,21 @@ use core::vec;\n /// The SHA-1 interface\n trait Sha1 {\n     /// Provide message input as bytes\n-    fn input(&[const u8]);\n+    fn input(&mut self, &[const u8]);\n     /// Provide message input as string\n-    fn input_str(&str);\n+    fn input_str(&mut self, &str);\n     /**\n      * Read the digest as a vector of 20 bytes. After calling this no further\n      * input may be provided until reset is called.\n      */\n-    fn result() -> ~[u8];\n+    fn result(&mut self) -> ~[u8];\n     /**\n      * Read the digest as a hex string. After calling this no further\n      * input may be provided until reset is called.\n      */\n-    fn result_str() -> ~str;\n+    fn result_str(&mut self) -> ~str;\n     /// Reset the SHA-1 state for reuse\n-    fn reset();\n+    fn reset(&mut self);\n }\n \n // Some unexported constants\n@@ -65,15 +65,15 @@ const k3: u32 = 0xCA62C1D6u32;\n /// Construct a `sha` object\n pub fn sha1() -> Sha1 {\n     struct Sha1State\n-        {h: ~[mut u32],\n-         mut len_low: u32,\n-         mut len_high: u32,\n-         msg_block: ~[mut u8],\n-         mut msg_block_idx: uint,\n-         mut computed: bool,\n-         work_buf: @~[mut u32]};\n+        { h: ~[u32],\n+          len_low: u32,\n+          len_high: u32,\n+          msg_block: ~[u8],\n+          msg_block_idx: uint,\n+          computed: bool,\n+          work_buf: @mut ~[u32]};\n \n-    fn add_input(st: &Sha1State, msg: &[const u8]) {\n+    fn add_input(st: &mut Sha1State, msg: &[const u8]) {\n         assert (!st.computed);\n         for vec::each_const(msg) |element| {\n             st.msg_block[st.msg_block_idx] = *element;\n@@ -89,11 +89,11 @@ pub fn sha1() -> Sha1 {\n             if st.msg_block_idx == msg_block_len { process_msg_block(st); }\n         }\n     }\n-    fn process_msg_block(st: &Sha1State) {\n+    fn process_msg_block(st: &mut Sha1State) {\n         assert (vec::len(st.h) == digest_buf_len);\n         assert (vec::len(*st.work_buf) == work_buf_len);\n         let mut t: int; // Loop counter\n-        let w = st.work_buf;\n+        let mut w = st.work_buf;\n \n         // Initialize the first 16 words of the vector w\n         t = 0;\n@@ -168,7 +168,7 @@ pub fn sha1() -> Sha1 {\n     fn circular_shift(bits: u32, word: u32) -> u32 {\n         return word << bits | word >> 32u32 - bits;\n     }\n-    fn mk_result(st: &Sha1State) -> ~[u8] {\n+    fn mk_result(st: &mut Sha1State) -> ~[u8] {\n         if !(*st).computed { pad_msg(st); (*st).computed = true; }\n         let mut rs: ~[u8] = ~[];\n         for vec::each_mut((*st).h) |ptr_hpart| {\n@@ -191,7 +191,7 @@ pub fn sha1() -> Sha1 {\n      * call process_msg_block() appropriately.  When it returns, it\n      * can be assumed that the message digest has been computed.\n      */\n-    fn pad_msg(st: &Sha1State) {\n+    fn pad_msg(st: &mut Sha1State) {\n         assert (vec::len((*st).msg_block) == msg_block_len);\n \n         /*\n@@ -229,7 +229,7 @@ pub fn sha1() -> Sha1 {\n     }\n \n     impl Sha1State: Sha1 {\n-        fn reset() {\n+        fn reset(&mut self) {\n             assert (vec::len(self.h) == digest_buf_len);\n             self.len_low = 0u32;\n             self.len_high = 0u32;\n@@ -241,31 +241,31 @@ pub fn sha1() -> Sha1 {\n             self.h[4] = 0xC3D2E1F0u32;\n             self.computed = false;\n         }\n-        fn input(msg: &[const u8]) { add_input(&self, msg); }\n-        fn input_str(msg: &str) {\n+        fn input(&mut self, msg: &[const u8]) { add_input(self, msg); }\n+        fn input_str(&mut self, msg: &str) {\n             let bs = str::to_bytes(msg);\n-            add_input(&self, bs);\n+            add_input(self, bs);\n         }\n-        fn result() -> ~[u8] { return mk_result(&self); }\n-        fn result_str() -> ~str {\n-            let rr = mk_result(&self);\n+        fn result(&mut self) -> ~[u8] { return mk_result(self); }\n+        fn result_str(&mut self) -> ~str {\n+            let rr = mk_result(self);\n             let mut s = ~\"\";\n             for vec::each(rr) |b| {\n                 s += uint::to_str_radix(*b as uint, 16u);\n             }\n             return s;\n         }\n     }\n-    let st = Sha1State {\n-        h: vec::cast_to_mut(vec::from_elem(digest_buf_len, 0u32)),\n-        mut len_low: 0u32,\n-        mut len_high: 0u32,\n-        msg_block: vec::cast_to_mut(vec::from_elem(msg_block_len, 0u8)),\n-        mut msg_block_idx: 0u,\n-        mut computed: false,\n-        work_buf: @vec::cast_to_mut(vec::from_elem(work_buf_len, 0u32))\n+    let mut st = Sha1State {\n+         h: vec::from_elem(digest_buf_len, 0u32),\n+         len_low: 0u32,\n+         len_high: 0u32,\n+         msg_block: vec::from_elem(msg_block_len, 0u8),\n+         msg_block_idx: 0u,\n+         computed: false,\n+         work_buf: @mut vec::from_elem(work_buf_len, 0u32)\n     };\n-    let sh = (move st) as Sha1;\n+    let mut sh = (move st) as Sha1;\n     sh.reset();\n     return sh;\n }\n@@ -368,7 +368,7 @@ mod tests {\n             }\n             // Test that it works when accepting the message all at once\n \n-            let sh = sha1::sha1();\n+            let mut sh = sha1::sha1();\n             for vec::each(tests) |t| {\n                 sh.input_str(t.input);\n                 let out = sh.result();"}, {"sha": "9c7d31e15f3fdb4fea778e31a186845bc8c8ec8b", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -455,7 +455,7 @@ impl<T: Copy Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n-        let tmp = vec::cast_to_mut(vec::slice(array, base1, base1+len1));\n+        let mut tmp = vec::slice(array, base1, base1+len1);\n \n         let mut c1 = 0;\n         let mut c2 = base2;\n@@ -558,7 +558,7 @@ impl<T: Copy Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n-        let tmp = vec::cast_to_mut(vec::slice(array, base2, base2+len2));\n+        let mut tmp = vec::slice(array, base2, base2+len2);\n \n         let mut c1 = base1 + len1 - 1;\n         let mut c2 = len2 - 1;"}, {"sha": "69116ace9e860ca0e9b2bb40b045d64631a8d62f", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -242,13 +242,13 @@ fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n }\n \n fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    let sha = sha1::sha1();\n+    let mut sha = sha1::sha1();\n     sha.input_str(json_encode(t));\n     sha.result_str()\n }\n \n fn digest_file(path: &Path) -> ~str {\n-    let sha = sha1::sha1();\n+    let mut sha = sha1::sha1();\n     let s = io::read_whole_file_str(path);\n     sha.input_str(*s.get_ref());\n     sha.result_str()"}, {"sha": "675151cf6c9da8759b03f93db742375b73b9839c", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -14,9 +14,9 @@ extern mod std;\n fn fannkuch(n: int) -> int {\n     fn perm1init(i: uint) -> int { return i as int; }\n \n-    let perm = vec::cast_to_mut(vec::from_elem(n as uint, 0));\n-    let perm1 = vec::cast_to_mut(vec::from_fn(n as uint, |i| perm1init(i)));\n-    let count = vec::cast_to_mut(vec::from_elem(n as uint, 0));\n+    let mut perm = vec::from_elem(n as uint, 0);\n+    let mut perm1 = vec::from_fn(n as uint, |i| perm1init(i));\n+    let mut count = vec::from_elem(n as uint, 0);\n     let mut f = 0;\n     let mut i = 0;\n     let mut k = 0;"}, {"sha": "3afb86210e1b80c8689c6ddb59893b891f7d6212", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -149,7 +149,7 @@ fn main() {\n    // initialize each sequence sorter\n    let sizes = ~[1,2,3,4,6,12,18];\n     let streams = vec::map(sizes, |_sz| Some(stream()));\n-    let streams = vec::cast_to_mut(move streams);\n+    let mut streams = move streams;\n     let mut from_child = ~[];\n     let to_child   = vec::mapi(sizes, |ii, sz| {\n         let sz = *sz;"}, {"sha": "2b9a030fdf4cea000122e4a6ca5c9fdfa624997d", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -45,7 +45,7 @@ fn eval_At_times_u(u: &[const float], Au: &mut [float]) {\n }\n \n fn eval_AtA_times_u(u: &[const float], AtAu: &mut [float]) {\n-    let v = vec::cast_to_mut(vec::from_elem(vec::len(u), 0.0));\n+    let mut v = vec::from_elem(vec::len(u), 0.0);\n     eval_A_times_u(u, v);\n     eval_At_times_u(v, AtAu);\n }\n@@ -62,8 +62,8 @@ fn main() {\n \n     let N = uint::from_str(args[1]).get();\n \n-    let u = vec::cast_to_mut(vec::from_elem(N, 1.0));\n-    let v = vec::cast_to_mut(vec::from_elem(N, 0.0));\n+    let mut u = vec::from_elem(N, 1.0);\n+    let mut v = vec::from_elem(N, 0.0);\n     let mut i = 0u;\n     while i < 10u {\n         eval_AtA_times_u(u, v);"}, {"sha": "1b85bd9646e754d45efef3b3fc0249db452d267c", "filename": "src/test/compile-fail/issue-2548.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -33,8 +33,8 @@ fn main() {\n     {\n         let mut res = foo(x);\n \n-        let mut v = ~[mut];\n-        v = move ~[mut (move res)] + v; //~ ERROR does not fulfill `Copy`\n+        let mut v = ~[];\n+        v = move ~[(move res)] + v; //~ instantiating a type parameter with an incompatible type `foo`, which does not fulfill `Copy`\n         assert (v.len() == 2);\n     }\n "}, {"sha": "6ad3344599734d87f15c3f7e4f8317de0d09249f", "filename": "src/test/run-pass/import-in-block.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-in-block.rs?ref=d5bf3b85d1078f3a2dd4cb9f009af018c2b4c062", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n+    // Once cast_to_mut is removed, pick a better function to import\n+    // for this test!\n     use vec::cast_to_mut;\n     log(debug, vec::len(cast_to_mut(~[1, 2])));\n     {"}]}