{"sha": "3a08713caa55718fafbf9483bec40379fbafd1de", "node_id": "C_kwDOAAsO6NoAKDNhMDg3MTNjYWE1NTcxOGZhZmJmOTQ4M2JlYzQwMzc5ZmJhZmQxZGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-21T15:10:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-21T15:10:27Z"}, "message": "Auto merge of #14619 - HKalbasi:dev3, r=Veykril\n\nFix need-mut large span in closures and a false positive\n\nfix #14612", "tree": {"sha": "892791b0ef7838ef5412de506afe74cb687a3451", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/892791b0ef7838ef5412de506afe74cb687a3451"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a08713caa55718fafbf9483bec40379fbafd1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a08713caa55718fafbf9483bec40379fbafd1de", "html_url": "https://github.com/rust-lang/rust/commit/3a08713caa55718fafbf9483bec40379fbafd1de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a08713caa55718fafbf9483bec40379fbafd1de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0289dfa2611a605975e10dab6d3931c21509f90c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0289dfa2611a605975e10dab6d3931c21509f90c", "html_url": "https://github.com/rust-lang/rust/commit/0289dfa2611a605975e10dab6d3931c21509f90c"}, {"sha": "0c621065fbec4469852570ed3658578e52aca444", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c621065fbec4469852570ed3658578e52aca444", "html_url": "https://github.com/rust-lang/rust/commit/0c621065fbec4469852570ed3658578e52aca444"}], "stats": {"total": 98, "additions": 69, "deletions": 29}, "files": [{"sha": "e7eb967c040686fec2042b86f18145d717d4da5b", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3a08713caa55718fafbf9483bec40379fbafd1de/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a08713caa55718fafbf9483bec40379fbafd1de/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=3a08713caa55718fafbf9483bec40379fbafd1de", "patch": "@@ -18,7 +18,7 @@ use smallvec::SmallVec;\n use stdx::never;\n \n use crate::{\n-    mir::{BorrowKind, ProjectionElem},\n+    mir::{BorrowKind, MirSpan, ProjectionElem},\n     static_lifetime, to_chalk_trait_id,\n     traits::FnTrait,\n     utils::{self, pattern_matching_dereference_count},\n@@ -121,6 +121,22 @@ impl HirPlace {\n         }\n         ty.clone()\n     }\n+\n+    fn capture_kind_of_truncated_place(\n+        &self,\n+        mut current_capture: CaptureKind,\n+        len: usize,\n+    ) -> CaptureKind {\n+        match current_capture {\n+            CaptureKind::ByRef(BorrowKind::Mut { .. }) => {\n+                if self.projections[len..].iter().any(|x| *x == ProjectionElem::Deref) {\n+                    current_capture = CaptureKind::ByRef(BorrowKind::Unique);\n+                }\n+            }\n+            _ => (),\n+        }\n+        current_capture\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n@@ -133,13 +149,15 @@ pub(crate) enum CaptureKind {\n pub(crate) struct CapturedItem {\n     pub(crate) place: HirPlace,\n     pub(crate) kind: CaptureKind,\n+    pub(crate) span: MirSpan,\n     pub(crate) ty: Ty,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub(crate) struct CapturedItemWithoutTy {\n     pub(crate) place: HirPlace,\n     pub(crate) kind: CaptureKind,\n+    pub(crate) span: MirSpan,\n }\n \n impl CapturedItemWithoutTy {\n@@ -155,7 +173,7 @@ impl CapturedItemWithoutTy {\n                 TyKind::Ref(m, static_lifetime(), ty).intern(Interner)\n             }\n         };\n-        CapturedItem { place: self.place, kind: self.kind, ty }\n+        CapturedItem { place: self.place, kind: self.kind, span: self.span, ty }\n     }\n }\n \n@@ -211,14 +229,14 @@ impl InferenceContext<'_> {\n \n     fn ref_expr(&mut self, expr: ExprId) {\n         if let Some(place) = self.place_of_expr(expr) {\n-            self.add_capture(place, CaptureKind::ByRef(BorrowKind::Shared));\n+            self.add_capture(place, CaptureKind::ByRef(BorrowKind::Shared), expr.into());\n         }\n         self.walk_expr(expr);\n     }\n \n-    fn add_capture(&mut self, place: HirPlace, kind: CaptureKind) {\n+    fn add_capture(&mut self, place: HirPlace, kind: CaptureKind, span: MirSpan) {\n         if self.is_upvar(&place) {\n-            self.push_capture(CapturedItemWithoutTy { place, kind });\n+            self.push_capture(CapturedItemWithoutTy { place, kind, span });\n         }\n     }\n \n@@ -227,27 +245,28 @@ impl InferenceContext<'_> {\n             self.add_capture(\n                 place,\n                 CaptureKind::ByRef(BorrowKind::Mut { allow_two_phase_borrow: false }),\n+                expr.into(),\n             );\n         }\n         self.walk_expr(expr);\n     }\n \n     fn consume_expr(&mut self, expr: ExprId) {\n         if let Some(place) = self.place_of_expr(expr) {\n-            self.consume_place(place);\n+            self.consume_place(place, expr.into());\n         }\n         self.walk_expr(expr);\n     }\n \n-    fn consume_place(&mut self, place: HirPlace) {\n+    fn consume_place(&mut self, place: HirPlace, span: MirSpan) {\n         if self.is_upvar(&place) {\n             let ty = place.ty(self).clone();\n             let kind = if self.is_ty_copy(ty) {\n                 CaptureKind::ByRef(BorrowKind::Shared)\n             } else {\n                 CaptureKind::ByValue\n             };\n-            self.push_capture(CapturedItemWithoutTy { place, kind });\n+            self.push_capture(CapturedItemWithoutTy { place, kind, span });\n         }\n     }\n \n@@ -281,9 +300,7 @@ impl InferenceContext<'_> {\n         };\n         if let Some(place) = self.place_of_expr_without_adjust(tgt_expr) {\n             if let Some(place) = apply_adjusts_to_place(place, rest) {\n-                if self.is_upvar(&place) {\n-                    self.push_capture(CapturedItemWithoutTy { place, kind: capture_kind });\n-                }\n+                self.add_capture(place, capture_kind, tgt_expr.into());\n             }\n         }\n         self.walk_expr_with_adjust(tgt_expr, rest);\n@@ -456,12 +473,9 @@ impl InferenceContext<'_> {\n                         \"We sort closures, so we should always have data for inner closures\",\n                     );\n                 let mut cc = mem::take(&mut self.current_captures);\n-                cc.extend(\n-                    captures\n-                        .iter()\n-                        .filter(|x| self.is_upvar(&x.place))\n-                        .map(|x| CapturedItemWithoutTy { place: x.place.clone(), kind: x.kind }),\n-                );\n+                cc.extend(captures.iter().filter(|x| self.is_upvar(&x.place)).map(|x| {\n+                    CapturedItemWithoutTy { place: x.place.clone(), kind: x.kind, span: x.span }\n+                }));\n                 self.current_captures = cc;\n             }\n             Expr::Array(Array::ElementList { elements: exprs, is_assignee_expr: _ })\n@@ -552,8 +566,11 @@ impl InferenceContext<'_> {\n             };\n             match prev_index {\n                 Some(p) => {\n+                    let len = self.current_captures[p].place.projections.len();\n+                    let kind_after_truncate =\n+                        item.place.capture_kind_of_truncated_place(item.kind, len);\n                     self.current_captures[p].kind =\n-                        cmp::max(item.kind, self.current_captures[p].kind);\n+                        cmp::max(kind_after_truncate, self.current_captures[p].kind);\n                 }\n                 None => {\n                     hash_map.insert(item.place.clone(), self.current_captures.len());\n@@ -603,7 +620,7 @@ impl InferenceContext<'_> {\n                 };\n                 match variant {\n                     VariantId::EnumVariantId(_) | VariantId::UnionId(_) => {\n-                        self.consume_place(place)\n+                        self.consume_place(place, pat.into())\n                     }\n                     VariantId::StructId(s) => {\n                         let vd = &*self.db.struct_data(s).variant_data;\n@@ -632,21 +649,21 @@ impl InferenceContext<'_> {\n             | Pat::Slice { .. }\n             | Pat::ConstBlock(_)\n             | Pat::Path(_)\n-            | Pat::Lit(_) => self.consume_place(place),\n+            | Pat::Lit(_) => self.consume_place(place, pat.into()),\n             Pat::Bind { id, subpat: _ } => {\n                 let mode = self.body.bindings[*id].mode;\n                 if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n                     bm = mode;\n                 }\n                 let capture_kind = match bm {\n                     BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n-                        self.consume_place(place);\n+                        self.consume_place(place, pat.into());\n                         return;\n                     }\n                     BindingAnnotation::Ref => BorrowKind::Shared,\n                     BindingAnnotation::RefMut => BorrowKind::Mut { allow_two_phase_borrow: false },\n                 };\n-                self.add_capture(place, CaptureKind::ByRef(capture_kind));\n+                self.add_capture(place, CaptureKind::ByRef(capture_kind), pat.into());\n             }\n             Pat::TupleStruct { path: _, args, ellipsis } => {\n                 pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n@@ -659,7 +676,7 @@ impl InferenceContext<'_> {\n                 };\n                 match variant {\n                     VariantId::EnumVariantId(_) | VariantId::UnionId(_) => {\n-                        self.consume_place(place)\n+                        self.consume_place(place, pat.into())\n                     }\n                     VariantId::StructId(s) => {\n                         let vd = &*self.db.struct_data(s).variant_data;"}, {"sha": "a2e19852a074226083f4380e595b80d899f92004", "filename": "crates/hir-ty/src/layout/tests/closure.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a08713caa55718fafbf9483bec40379fbafd1de/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a08713caa55718fafbf9483bec40379fbafd1de/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs?ref=3a08713caa55718fafbf9483bec40379fbafd1de", "patch": "@@ -105,6 +105,20 @@ fn nested_closures() {\n     }\n }\n \n+#[test]\n+fn capture_specific_fields2() {\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            let x = &mut 2;\n+        ]\n+        || {\n+            *x = 5;\n+            &x;\n+        }\n+    }\n+}\n+\n #[test]\n fn capture_specific_fields() {\n     size_and_align_expr! {"}, {"sha": "687b9835f5764238f208a7b13a013f3b8d266131", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a08713caa55718fafbf9483bec40379fbafd1de/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a08713caa55718fafbf9483bec40379fbafd1de/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=3a08713caa55718fafbf9483bec40379fbafd1de", "patch": "@@ -898,7 +898,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                                 current,\n                                 tmp.clone(),\n                                 Rvalue::Ref(bk.clone(), p),\n-                                expr_id.into(),\n+                                capture.span,\n                             );\n                             operands.push(Operand::Move(tmp));\n                         },"}, {"sha": "9184125286a8d16ee2d9ce5f35bf64768a2384da", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3a08713caa55718fafbf9483bec40379fbafd1de/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a08713caa55718fafbf9483bec40379fbafd1de/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=3a08713caa55718fafbf9483bec40379fbafd1de", "patch": "@@ -773,7 +773,7 @@ fn fn_once(mut x: impl FnOnce(u8) -> u8) -> u8 {\n \n     #[test]\n     fn closure() {\n-        // FIXME: Diagnostic spans are too large\n+        // FIXME: Diagnostic spans are inconsistent inside and outside closure\n         check_diagnostics(\n             r#\"\n         //- minicore: copy, fn\n@@ -786,11 +786,11 @@ fn fn_once(mut x: impl FnOnce(u8) -> u8) -> u8 {\n         fn f() {\n             let x = 5;\n             let closure1 = || { x = 2; };\n-                         //^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+                              //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n             let _ = closure1();\n                   //^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `closure1`\n             let closure2 = || { x = x; };\n-                         //^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+                              //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n             let closure3 = || {\n                 let x = 2;\n                 x = 5;\n@@ -799,7 +799,7 @@ fn fn_once(mut x: impl FnOnce(u8) -> u8) -> u8 {\n             };\n             let x = X;\n             let closure4 = || { x.mutate(); };\n-                         //^^^^^^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+                              //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n         }\n                     \"#,\n         );\n@@ -829,7 +829,7 @@ fn f() {\n             || {\n                 let x = 2;\n                 || { || { x = 5; } }\n-              //^^^^^^^^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+                        //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n             }\n         }\n     };\n@@ -860,6 +860,15 @@ fn f() {\n             let mut x = &mut 5;\n               //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n             let closure1 = || { *x = 2; };\n+            let _ = closure1();\n+                  //^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `closure1`\n+            let mut x = &mut 5;\n+              //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            let closure1 = || { *x = 2; &x; };\n+            let _ = closure1();\n+                  //^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `closure1`\n+            let mut x = &mut 5;\n+            let closure1 = || { *x = 2; &x; x = &mut 3; };\n             let _ = closure1();\n                   //^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `closure1`\n             let mut x = &mut 5;"}]}