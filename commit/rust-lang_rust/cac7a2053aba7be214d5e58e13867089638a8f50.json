{"sha": "cac7a2053aba7be214d5e58e13867089638a8f50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYzdhMjA1M2FiYTdiZTIxNGQ1ZTU4ZTEzODY3MDg5NjM4YThmNTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-28T16:24:28Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-11T23:04:24Z"}, "message": "std: Remove i18n/l10n from format!\n\n* The select/plural methods from format strings are removed\n* The # character no longer needs to be escaped\n* The \\-based escapes have been removed\n* '{{' is now an escape for '{'\n* '}}' is now an escape for '}'\n\nCloses #14810\n[breaking-change]", "tree": {"sha": "8c0af42bd2ab5237a19c04e9777e433805d600df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c0af42bd2ab5237a19c04e9777e433805d600df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cac7a2053aba7be214d5e58e13867089638a8f50", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cac7a2053aba7be214d5e58e13867089638a8f50", "html_url": "https://github.com/rust-lang/rust/commit/cac7a2053aba7be214d5e58e13867089638a8f50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cac7a2053aba7be214d5e58e13867089638a8f50/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9260d41d6e37653bf71b08a041be0310098716a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9260d41d6e37653bf71b08a041be0310098716a", "html_url": "https://github.com/rust-lang/rust/commit/f9260d41d6e37653bf71b08a041be0310098716a"}], "stats": {"total": 1823, "additions": 736, "deletions": 1087}, "files": [{"sha": "c0b3dec086be4ea6e23c3b65517c2a531c3e84b8", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -842,6 +842,7 @@ impl cmp::PartialEq for BitvSet {\n }\n \n impl fmt::Show for BitvSet {\n+    #[cfg(stage0)]\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, r\"\\{\"));\n         let mut first = true;\n@@ -854,6 +855,19 @@ impl fmt::Show for BitvSet {\n         }\n         write!(fmt, r\"\\}\")\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(fmt, \"{{\"));\n+        let mut first = true;\n+        for n in self.iter() {\n+            if !first {\n+                try!(write!(fmt, \", \"));\n+            }\n+            try!(write!(fmt, \"{}\", n));\n+            first = false;\n+        }\n+        write!(fmt, \"}}\")\n+    }\n }\n \n impl<S: hash::Writer> hash::Hash<S> for BitvSet {"}, {"sha": "06c1516f1e0819aafbb5b5f691cb7378591af022", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -185,6 +185,7 @@ impl<V:Clone> SmallIntMap<V> {\n }\n \n impl<V: fmt::Show> fmt::Show for SmallIntMap<V> {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n \n@@ -195,6 +196,17 @@ impl<V: fmt::Show> fmt::Show for SmallIntMap<V> {\n \n         write!(f, r\"\\}\")\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, (k, v)) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}: {}\", k, *v));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n }\n \n macro_rules! iterator {"}, {"sha": "b59caa9375e902208285d30ff005375b62e637bf", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -76,6 +76,7 @@ impl<K: PartialOrd + Ord, V: PartialOrd> PartialOrd for TreeMap<K, V> {\n }\n \n impl<K: Ord + Show, V: Show> Show for TreeMap<K, V> {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n \n@@ -86,6 +87,17 @@ impl<K: Ord + Show, V: Show> Show for TreeMap<K, V> {\n \n         write!(f, r\"\\}\")\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, (k, v)) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}: {}\", *k, *v));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n }\n \n impl<K: Ord, V> Collection for TreeMap<K, V> {\n@@ -574,6 +586,7 @@ impl<T: PartialOrd + Ord> PartialOrd for TreeSet<T> {\n }\n \n impl<T: Ord + Show> Show for TreeSet<T> {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n \n@@ -584,6 +597,17 @@ impl<T: Ord + Show> Show for TreeSet<T> {\n \n         write!(f, r\"\\}\")\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", *x));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n }\n \n impl<T: Ord> Collection for TreeSet<T> {"}, {"sha": "a8d458664b8667be62658a455dcc19bd56c6724d", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 95, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -97,12 +97,6 @@ pub struct Formatter<'a> {\n     args: &'a [Argument<'a>],\n }\n \n-enum CurrentlyFormatting<'a> {\n-    Nothing,\n-    RawString(&'a str),\n-    Number(uint),\n-}\n-\n /// This struct represents the generic \"argument\" which is taken by the Xprintf\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n@@ -279,7 +273,7 @@ pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n         curarg: args.args.iter(),\n     };\n     for piece in args.fmt.iter() {\n-        try!(formatter.run(piece, Nothing));\n+        try!(formatter.run(piece));\n     }\n     Ok(())\n }\n@@ -290,16 +284,9 @@ impl<'a> Formatter<'a> {\n     // at runtime. This consumes all of the compile-time statics generated by\n     // the format! syntax extension.\n \n-    fn run(&mut self, piece: &rt::Piece, cur: CurrentlyFormatting) -> Result {\n+    fn run(&mut self, piece: &rt::Piece) -> Result {\n         match *piece {\n             rt::String(s) => self.buf.write(s.as_bytes()),\n-            rt::CurrentArgument(()) => {\n-                match cur {\n-                    Nothing => Ok(()),\n-                    Number(n) => secret_show(&radix(n, 10), self),\n-                    RawString(s) => self.buf.write(s.as_bytes()),\n-                }\n-            }\n             rt::Argument(ref arg) => {\n                 // Fill in the format parameters into the formatter\n                 self.fill = arg.format.fill;\n@@ -315,10 +302,7 @@ impl<'a> Formatter<'a> {\n                 };\n \n                 // Then actually do some printing\n-                match arg.method {\n-                    None => (value.formatter)(value.value, self),\n-                    Some(ref method) => self.execute(*method, value)\n-                }\n+                (value.formatter)(value.value, self)\n             }\n         }\n     }\n@@ -338,82 +322,6 @@ impl<'a> Formatter<'a> {\n         }\n     }\n \n-    fn execute(&mut self, method: &rt::Method, arg: Argument) -> Result {\n-        match *method {\n-            // Pluralization is selection upon a numeric value specified as the\n-            // parameter.\n-            rt::Plural(offset, ref selectors, ref default) => {\n-                // This is validated at compile-time to be a pointer to a\n-                // '&uint' value.\n-                let value: &uint = unsafe { mem::transmute(arg.value) };\n-                let value = *value;\n-\n-                // First, attempt to match against explicit values without the\n-                // offsetted value\n-                for s in selectors.iter() {\n-                    match s.selector {\n-                        rt::Literal(val) if value == val => {\n-                            return self.runplural(value, s.result);\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                // Next, offset the value and attempt to match against the\n-                // keyword selectors.\n-                let value = value - match offset { Some(i) => i, None => 0 };\n-                for s in selectors.iter() {\n-                    let run = match s.selector {\n-                        rt::Keyword(rt::Zero) => value == 0,\n-                        rt::Keyword(rt::One) => value == 1,\n-                        rt::Keyword(rt::Two) => value == 2,\n-\n-                        // FIXME: Few/Many should have a user-specified boundary\n-                        //      One possible option would be in the function\n-                        //      pointer of the 'arg: Argument' struct.\n-                        rt::Keyword(rt::Few) => value < 8,\n-                        rt::Keyword(rt::Many) => value >= 8,\n-\n-                        rt::Literal(..) => false\n-                    };\n-                    if run {\n-                        return self.runplural(value, s.result);\n-                    }\n-                }\n-\n-                self.runplural(value, *default)\n-            }\n-\n-            // Select is just a matching against the string specified.\n-            rt::Select(ref selectors, ref default) => {\n-                // This is validated at compile-time to be a pointer to a\n-                // string slice,\n-                let value: & &str = unsafe { mem::transmute(arg.value) };\n-                let value = *value;\n-\n-                for s in selectors.iter() {\n-                    if s.selector == value {\n-                        for piece in s.result.iter() {\n-                            try!(self.run(piece, RawString(value)));\n-                        }\n-                        return Ok(());\n-                    }\n-                }\n-                for piece in default.iter() {\n-                    try!(self.run(piece, RawString(value)));\n-                }\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) -> Result {\n-        for piece in pieces.iter() {\n-            try!(self.run(piece, Number(value)));\n-        }\n-        Ok(())\n-    }\n-\n     // Helper methods used for padding and processing formatting arguments that\n     // all formatting traits can use.\n \n@@ -841,9 +749,14 @@ impl Show for () {\n }\n \n impl<T: Copy + Show> Show for Cell<T> {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         write!(f, r\"Cell \\{ value: {} \\}\", self.get())\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        write!(f, \"Cell {{ value: {} }}\", self.get())\n+    }\n }\n \n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,"}, {"sha": "6d3edeabca936a0c0ed982772e7bc54388ba7e67", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 4, "deletions": 36, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -14,21 +14,22 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n+\n+#[cfg(stage0)]\n use option::Option;\n \n #[doc(hidden)]\n pub enum Piece<'a> {\n     String(&'a str),\n-    // FIXME(#8259): this shouldn't require the unit-value here\n-    CurrentArgument(()),\n     Argument(Argument<'a>),\n }\n \n #[doc(hidden)]\n pub struct Argument<'a> {\n     pub position: Position,\n     pub format: FormatSpec,\n-    pub method: Option<&'a Method<'a>>\n+    #[cfg(stage0)]\n+    pub method: Option<uint>,\n }\n \n #[doc(hidden)]\n@@ -80,36 +81,3 @@ pub enum Flag {\n     /// being aware of the sign to be printed.\n     FlagSignAwareZeroPad,\n }\n-\n-#[doc(hidden)]\n-pub enum Method<'a> {\n-    Plural(Option<uint>, &'a [PluralArm<'a>], &'a [Piece<'a>]),\n-    Select(&'a [SelectArm<'a>], &'a [Piece<'a>]),\n-}\n-\n-#[doc(hidden)]\n-pub enum PluralSelector {\n-    Keyword(PluralKeyword),\n-    Literal(uint),\n-}\n-\n-#[doc(hidden)]\n-pub enum PluralKeyword {\n-    Zero,\n-    One,\n-    Two,\n-    Few,\n-    Many,\n-}\n-\n-#[doc(hidden)]\n-pub struct PluralArm<'a> {\n-    pub selector: PluralSelector,\n-    pub result: &'a [Piece<'a>],\n-}\n-\n-#[doc(hidden)]\n-pub struct SelectArm<'a> {\n-    pub selector: &'a str,\n-    pub result: &'a [Piece<'a>],\n-}"}, {"sha": "aa221bde101e5733f6805dae083a2f4dd835521e", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 23, "deletions": 385, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -30,9 +30,6 @@ use std::str;\n pub enum Piece<'a> {\n     /// A literal string which should directly be emitted\n     String(&'a str),\n-    /// A back-reference to whatever the current argument is. This is used\n-    /// inside of a method call to refer back to the original argument.\n-    CurrentArgument,\n     /// This describes that formatting should process the next argument (as\n     /// specified inside) for emission.\n     Argument(Argument<'a>),\n@@ -45,8 +42,6 @@ pub struct Argument<'a> {\n     pub position: Position<'a>,\n     /// How to format the argument\n     pub format: FormatSpec<'a>,\n-    /// If not `None`, what method to invoke on the argument\n-    pub method: Option<Box<Method<'a>>>\n }\n \n /// Specification for the formatting of an argument in the format string.\n@@ -122,76 +117,6 @@ pub enum Count<'a> {\n     CountImplied,\n }\n \n-/// Enum describing all of the possible methods which the formatting language\n-/// currently supports.\n-#[deriving(PartialEq)]\n-pub enum Method<'a> {\n-    /// A plural method selects on an integer over a list of either integer or\n-    /// keyword-defined clauses. The meaning of the keywords is defined by the\n-    /// current locale.\n-    ///\n-    /// An offset is optionally present at the beginning which is used to\n-    /// match against keywords, but it is not matched against the literal\n-    /// integers.\n-    ///\n-    /// The final element of this enum is the default \"other\" case which is\n-    /// always required to be specified.\n-    Plural(Option<uint>, Vec<PluralArm<'a>>, Vec<Piece<'a>>),\n-\n-    /// A select method selects over a string. Each arm is a different string\n-    /// which can be selected for.\n-    ///\n-    /// As with `Plural`, a default \"other\" case is required as well.\n-    Select(Vec<SelectArm<'a>>, Vec<Piece<'a>>),\n-}\n-\n-/// A selector for what pluralization a plural method should take\n-#[deriving(PartialEq, Eq, Hash)]\n-pub enum PluralSelector {\n-    /// One of the plural keywords should be used\n-    Keyword(PluralKeyword),\n-    /// A literal pluralization should be used\n-    Literal(uint),\n-}\n-\n-/// Structure representing one \"arm\" of the `plural` function.\n-#[deriving(PartialEq)]\n-pub struct PluralArm<'a> {\n-    /// A selector can either be specified by a keyword or with an integer\n-    /// literal.\n-    pub selector: PluralSelector,\n-    /// Array of pieces which are the format of this arm\n-    pub result: Vec<Piece<'a>>,\n-}\n-\n-/// Enum of the 5 CLDR plural keywords. There is one more, \"other\", but that\n-/// is specially placed in the `Plural` variant of `Method`.\n-///\n-/// http://www.icu-project.org/apiref/icu4c/classicu_1_1PluralRules.html\n-#[deriving(PartialEq, Eq, Hash, Show)]\n-#[allow(missing_doc)]\n-pub enum PluralKeyword {\n-    /// The plural form for zero objects.\n-    Zero,\n-    /// The plural form for one object.\n-    One,\n-    /// The plural form for two objects.\n-    Two,\n-    /// The plural form for few objects.\n-    Few,\n-    /// The plural form for many objects.\n-    Many,\n-}\n-\n-/// Structure representing one \"arm\" of the `select` function.\n-#[deriving(PartialEq)]\n-pub struct SelectArm<'a> {\n-    /// String selector which guards this arm\n-    pub selector: &'a str,\n-    /// Array of pieces which are the format of this arm\n-    pub result: Vec<Piece<'a>>,\n-}\n-\n /// The parser structure for interpreting the input format string. This is\n /// modelled as an iterator over `Piece` structures to form a stream of tokens\n /// being output.\n@@ -201,35 +126,34 @@ pub struct SelectArm<'a> {\n pub struct Parser<'a> {\n     input: &'a str,\n     cur: str::CharOffsets<'a>,\n-    depth: uint,\n     /// Error messages accumulated during parsing\n     pub errors: Vec<String>,\n }\n \n impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n     fn next(&mut self) -> Option<Piece<'a>> {\n         match self.cur.clone().next() {\n-            Some((_, '#')) => { self.cur.next(); Some(CurrentArgument) }\n-            Some((_, '{')) => {\n+            Some((pos, '{')) => {\n                 self.cur.next();\n-                let ret = Some(Argument(self.argument()));\n-                self.must_consume('}');\n-                ret\n-            }\n-            Some((pos, '\\\\')) => {\n-                self.cur.next();\n-                self.escape(); // ensure it's a valid escape sequence\n-                Some(String(self.string(pos + 1))) // skip the '\\' character\n+                if self.consume('{') {\n+                    Some(String(self.string(pos + 1)))\n+                } else {\n+                    let ret = Some(Argument(self.argument()));\n+                    self.must_consume('}');\n+                    ret\n+                }\n             }\n-            Some((_, '}')) if self.depth == 0 => {\n+            Some((pos, '}')) => {\n                 self.cur.next();\n-                self.err(\"unmatched `}` found\");\n-                None\n-            }\n-            Some((_, '}')) | None => { None }\n-            Some((pos, _)) => {\n-                Some(String(self.string(pos)))\n+                if self.consume('}') {\n+                    Some(String(self.string(pos + 1)))\n+                } else {\n+                    self.err(\"unmatched `}` found\");\n+                    None\n+                }\n             }\n+            Some((pos, _)) => { Some(String(self.string(pos))) }\n+            None => None\n         }\n     }\n }\n@@ -240,7 +164,6 @@ impl<'a> Parser<'a> {\n         Parser {\n             input: s,\n             cur: s.char_indices(),\n-            depth: 0,\n             errors: vec!(),\n         }\n     }\n@@ -285,11 +208,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Attempts to consume any amount of whitespace followed by a character\n-    fn wsconsume(&mut self, c: char) -> bool {\n-        self.ws(); self.consume(c)\n-    }\n-\n     /// Consumes all whitespace characters until the first non-whitespace\n     /// character\n     fn ws(&mut self) {\n@@ -301,32 +219,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Consumes an escape sequence, failing if there is not a valid character\n-    /// to be escaped.\n-    fn escape(&mut self) -> char {\n-        match self.cur.next() {\n-            Some((_, c @ '#')) | Some((_, c @ '{')) |\n-            Some((_, c @ '\\\\')) | Some((_, c @ '}')) => { c }\n-            Some((_, c)) => {\n-                self.err(format!(\"invalid escape character `{}`\",\n-                                 c).as_slice());\n-                c\n-            }\n-            None => {\n-                self.err(\"expected an escape sequence, but format string was \\\n-                           terminated\");\n-                ' '\n-            }\n-        }\n-    }\n-\n     /// Parses all of a string which is to be considered a \"raw literal\" in a\n     /// format string. This is everything outside of the braces.\n     fn string(&mut self, start: uint) -> &'a str {\n         loop {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n-                Some((pos, '\\\\')) | Some((pos, '#')) |\n                 Some((pos, '}')) | Some((pos, '{')) => {\n                     return self.input.slice(start, pos);\n                 }\n@@ -345,7 +243,6 @@ impl<'a> Parser<'a> {\n         Argument {\n             position: self.position(),\n             format: self.format(),\n-            method: self.method(),\n         }\n     }\n \n@@ -440,173 +337,6 @@ impl<'a> Parser<'a> {\n         return spec;\n     }\n \n-    /// Parses a method to be applied to the previously specified argument and\n-    /// its format. The two current supported methods are 'plural' and 'select'\n-    fn method(&mut self) -> Option<Box<Method<'a>>> {\n-        if !self.wsconsume(',') {\n-            return None;\n-        }\n-        self.ws();\n-        match self.word() {\n-            \"select\" => {\n-                self.must_consume(',');\n-                Some(self.select())\n-            }\n-            \"plural\" => {\n-                self.must_consume(',');\n-                Some(self.plural())\n-            }\n-            \"\" => {\n-                self.err(\"expected method after comma\");\n-                return None;\n-            }\n-            method => {\n-                self.err(format!(\"unknown method: `{}`\", method).as_slice());\n-                return None;\n-            }\n-        }\n-    }\n-\n-    /// Parses a 'select' statement (after the initial 'select' word)\n-    fn select(&mut self) -> Box<Method<'a>> {\n-        let mut other = None;\n-        let mut arms = vec!();\n-        // Consume arms one at a time\n-        loop {\n-            self.ws();\n-            let selector = self.word();\n-            if selector == \"\" {\n-                self.err(\"cannot have an empty selector\");\n-                break\n-            }\n-            self.must_consume('{');\n-            self.depth += 1;\n-            let pieces = self.collect();\n-            self.depth -= 1;\n-            self.must_consume('}');\n-            if selector == \"other\" {\n-                if !other.is_none() {\n-                    self.err(\"multiple `other` statements in `select\");\n-                }\n-                other = Some(pieces);\n-            } else {\n-                arms.push(SelectArm { selector: selector, result: pieces });\n-            }\n-            self.ws();\n-            match self.cur.clone().next() {\n-                Some((_, '}')) => { break }\n-                Some(..) | None => {}\n-            }\n-        }\n-        // The \"other\" selector must be present\n-        let other = match other {\n-            Some(arm) => { arm }\n-            None => {\n-                self.err(\"`select` statement must provide an `other` case\");\n-                vec!()\n-            }\n-        };\n-        box Select(arms, other)\n-    }\n-\n-    /// Parses a 'plural' statement (after the initial 'plural' word)\n-    fn plural(&mut self) -> Box<Method<'a>> {\n-        let mut offset = None;\n-        let mut other = None;\n-        let mut arms = vec!();\n-\n-        // First, attempt to parse the 'offset:' field. We know the set of\n-        // selector words which can appear in plural arms, and the only ones\n-        // which start with 'o' are \"other\" and \"offset\", hence look two\n-        // characters deep to see if we can consume the word \"offset\"\n-        self.ws();\n-        let mut it = self.cur.clone();\n-        match it.next() {\n-            Some((_, 'o')) => {\n-                match it.next() {\n-                    Some((_, 'f')) => {\n-                        let word = self.word();\n-                        if word != \"offset\" {\n-                            self.err(format!(\"expected `offset`, found `{}`\",\n-                                             word).as_slice());\n-                        } else {\n-                            self.must_consume(':');\n-                            match self.integer() {\n-                                Some(i) => { offset = Some(i); }\n-                                None => {\n-                                    self.err(\"offset must be an integer\");\n-                                }\n-                            }\n-                        }\n-                    }\n-                    Some(..) | None => {}\n-                }\n-            }\n-            Some(..) | None => {}\n-        }\n-\n-        // Next, generate all the arms\n-        loop {\n-            let mut isother = false;\n-            let selector = if self.wsconsume('=') {\n-                match self.integer() {\n-                    Some(i) => Literal(i),\n-                    None => {\n-                        self.err(\"plural `=` selectors must be followed by an \\\n-                                  integer\");\n-                        Literal(0)\n-                    }\n-                }\n-            } else {\n-                let word = self.word();\n-                match word {\n-                    \"other\" => { isother = true; Keyword(Zero) }\n-                    \"zero\"  => Keyword(Zero),\n-                    \"one\"   => Keyword(One),\n-                    \"two\"   => Keyword(Two),\n-                    \"few\"   => Keyword(Few),\n-                    \"many\"  => Keyword(Many),\n-                    word    => {\n-                        self.err(format!(\"unexpected plural selector `{}`\",\n-                                         word).as_slice());\n-                        if word == \"\" {\n-                            break\n-                        } else {\n-                            Keyword(Zero)\n-                        }\n-                    }\n-                }\n-            };\n-            self.must_consume('{');\n-            self.depth += 1;\n-            let pieces = self.collect();\n-            self.depth -= 1;\n-            self.must_consume('}');\n-            if isother {\n-                if !other.is_none() {\n-                    self.err(\"multiple `other` statements in `select\");\n-                }\n-                other = Some(pieces);\n-            } else {\n-                arms.push(PluralArm { selector: selector, result: pieces });\n-            }\n-            self.ws();\n-            match self.cur.clone().next() {\n-                Some((_, '}')) => { break }\n-                Some(..) | None => {}\n-            }\n-        }\n-\n-        let other = match other {\n-            Some(arm) => { arm }\n-            None => {\n-                self.err(\"`plural` statement must provide an `other` case\");\n-                vec!()\n-            }\n-        };\n-        box Plural(offset, arms, other)\n-    }\n-\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n@@ -715,16 +445,15 @@ mod tests {\n     #[test]\n     fn simple() {\n         same(\"asdf\", [String(\"asdf\")]);\n-        same(\"a\\\\{b\", [String(\"a\"), String(\"{b\")]);\n-        same(\"a\\\\#b\", [String(\"a\"), String(\"#b\")]);\n-        same(\"a\\\\}b\", [String(\"a\"), String(\"}b\")]);\n-        same(\"a\\\\}\", [String(\"a\"), String(\"}\")]);\n-        same(\"\\\\}\", [String(\"}\")]);\n+        same(\"a{{b\", [String(\"a\"), String(\"{b\")]);\n+        same(\"a}}b\", [String(\"a\"), String(\"}b\")]);\n+        same(\"a}}\", [String(\"a\"), String(\"}\")]);\n+        same(\"}}\", [String(\"}\")]);\n+        same(\"\\\\}}\", [String(\"\\\\\"), String(\"}\")]);\n     }\n \n     #[test] fn invalid01() { musterr(\"{\") }\n-    #[test] fn invalid02() { musterr(\"\\\\\") }\n-    #[test] fn invalid03() { musterr(\"\\\\a\") }\n+    #[test] fn invalid02() { musterr(\"}\") }\n     #[test] fn invalid04() { musterr(\"{3a}\") }\n     #[test] fn invalid05() { musterr(\"{:|}\") }\n     #[test] fn invalid06() { musterr(\"{:>>>}\") }\n@@ -734,23 +463,20 @@ mod tests {\n         same(\"{}\", [Argument(Argument {\n             position: ArgumentNext,\n             format: fmtdflt(),\n-            method: None,\n         })]);\n     }\n     #[test]\n     fn format_position() {\n         same(\"{3}\", [Argument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n-            method: None,\n         })]);\n     }\n     #[test]\n     fn format_position_nothing_else() {\n         same(\"{3:}\", [Argument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n-            method: None,\n         })]);\n     }\n     #[test]\n@@ -765,7 +491,6 @@ mod tests {\n                 width: CountImplied,\n                 ty: \"a\",\n             },\n-            method: None,\n         })]);\n     }\n     #[test]\n@@ -780,7 +505,6 @@ mod tests {\n                 width: CountImplied,\n                 ty: \"\",\n             },\n-            method: None,\n         })]);\n         same(\"{3:0<}\", [Argument(Argument {\n             position: ArgumentIs(3),\n@@ -792,7 +516,6 @@ mod tests {\n                 width: CountImplied,\n                 ty: \"\",\n             },\n-            method: None,\n         })]);\n         same(\"{3:*<abcd}\", [Argument(Argument {\n             position: ArgumentIs(3),\n@@ -804,7 +527,6 @@ mod tests {\n                 width: CountImplied,\n                 ty: \"abcd\",\n             },\n-            method: None,\n         })]);\n     }\n     #[test]\n@@ -819,7 +541,6 @@ mod tests {\n                 width: CountIs(10),\n                 ty: \"s\",\n             },\n-            method: None,\n         })]);\n         same(\"{:10$.10s}\", [Argument(Argument {\n             position: ArgumentNext,\n@@ -831,7 +552,6 @@ mod tests {\n                 width: CountIsParam(10),\n                 ty: \"s\",\n             },\n-            method: None,\n         })]);\n         same(\"{:.*s}\", [Argument(Argument {\n             position: ArgumentNext,\n@@ -843,7 +563,6 @@ mod tests {\n                 width: CountImplied,\n                 ty: \"s\",\n             },\n-            method: None,\n         })]);\n         same(\"{:.10$s}\", [Argument(Argument {\n             position: ArgumentNext,\n@@ -855,7 +574,6 @@ mod tests {\n                 width: CountImplied,\n                 ty: \"s\",\n             },\n-            method: None,\n         })]);\n         same(\"{:a$.b$s}\", [Argument(Argument {\n             position: ArgumentNext,\n@@ -867,7 +585,6 @@ mod tests {\n                 width: CountIsName(\"a\"),\n                 ty: \"s\",\n             },\n-            method: None,\n         })]);\n     }\n     #[test]\n@@ -882,7 +599,6 @@ mod tests {\n                 width: CountImplied,\n                 ty: \"\",\n             },\n-            method: None,\n         })]);\n         same(\"{:+#}\", [Argument(Argument {\n             position: ArgumentNext,\n@@ -894,7 +610,6 @@ mod tests {\n                 width: CountImplied,\n                 ty: \"\",\n             },\n-            method: None,\n         })]);\n     }\n     #[test]\n@@ -909,83 +624,6 @@ mod tests {\n                 width: CountImplied,\n                 ty: \"a\",\n             },\n-            method: None,\n         }), String(\" efg\")]);\n     }\n-\n-    #[test]\n-    fn select_simple() {\n-        same(\"{, select, other { haha } }\", [Argument(Argument{\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-            method: Some(box Select(vec![], vec![String(\" haha \")]))\n-        })]);\n-        same(\"{1, select, other { haha } }\", [Argument(Argument{\n-            position: ArgumentIs(1),\n-            format: fmtdflt(),\n-            method: Some(box Select(vec![], vec![String(\" haha \")]))\n-        })]);\n-        same(\"{1, select, other {#} }\", [Argument(Argument{\n-            position: ArgumentIs(1),\n-            format: fmtdflt(),\n-            method: Some(box Select(vec![], vec![CurrentArgument]))\n-        })]);\n-        same(\"{1, select, other {{2, select, other {lol}}} }\", [Argument(Argument{\n-            position: ArgumentIs(1),\n-            format: fmtdflt(),\n-            method: Some(box Select(vec![], vec![Argument(Argument{\n-                position: ArgumentIs(2),\n-                format: fmtdflt(),\n-                method: Some(box Select(vec![], vec![String(\"lol\")]))\n-            })])) // wat\n-        })]);\n-    }\n-\n-    #[test]\n-    fn select_cases() {\n-        same(\"{1, select, a{1} b{2} c{3} other{4} }\", [Argument(Argument{\n-            position: ArgumentIs(1),\n-            format: fmtdflt(),\n-            method: Some(box Select(vec![\n-                SelectArm{ selector: \"a\", result: vec![String(\"1\")] },\n-                SelectArm{ selector: \"b\", result: vec![String(\"2\")] },\n-                SelectArm{ selector: \"c\", result: vec![String(\"3\")] },\n-            ], vec![String(\"4\")]))\n-        })]);\n-    }\n-\n-    #[test] fn badselect01() { musterr(\"{select, }\") }\n-    #[test] fn badselect02() { musterr(\"{1, select}\") }\n-    #[test] fn badselect03() { musterr(\"{1, select, }\") }\n-    #[test] fn badselect04() { musterr(\"{1, select, a {}}\") }\n-    #[test] fn badselect05() { musterr(\"{1, select, other }}\") }\n-    #[test] fn badselect06() { musterr(\"{1, select, other {}\") }\n-    #[test] fn badselect07() { musterr(\"{select, other {}\") }\n-    #[test] fn badselect08() { musterr(\"{1 select, other {}\") }\n-    #[test] fn badselect09() { musterr(\"{:d select, other {}\") }\n-    #[test] fn badselect10() { musterr(\"{1:d select, other {}\") }\n-\n-    #[test]\n-    fn plural_simple() {\n-        same(\"{, plural, other { haha } }\", [Argument(Argument{\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-            method: Some(box Plural(None, vec![], vec![String(\" haha \")]))\n-        })]);\n-        same(\"{:, plural, other { haha } }\", [Argument(Argument{\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-            method: Some(box Plural(None, vec![], vec![String(\" haha \")]))\n-        })]);\n-        same(\"{, plural, offset:1 =2{2} =3{3} many{yes} other{haha} }\",\n-        [Argument(Argument{\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-            method: Some(box Plural(Some(1), vec![\n-                PluralArm{ selector: Literal(2), result: vec![String(\"2\")] },\n-                PluralArm{ selector: Literal(3), result: vec![String(\"3\")] },\n-                PluralArm{ selector: Keyword(Many), result: vec![String(\"yes\")] }\n-            ], vec![String(\"haha\")]))\n-        })]);\n-    }\n }"}, {"sha": "29c807882ecb579f882ae8a31a3a2f8ff9046994", "filename": "src/libregex/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibregex%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibregex%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Fmod.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -634,9 +634,14 @@ impl<'a> Parser<'a> {\n             let closer =\n                 match self.pos('}') {\n                     Some(i) => i,\n+                    #[cfg(stage0)]\n                     None => return self.err(format!(\n                         \"Missing '\\\\}' for unclosed '\\\\{' at position {}\",\n                         self.chari).as_slice()),\n+                    #[cfg(not(stage0))]\n+                    None => return self.err(format!(\n+                        \"Missing '}}' for unclosed '{{' at position {}\",\n+                        self.chari).as_slice()),\n                 };\n             if closer - self.chari + 1 == 0 {\n                 return self.err(\"No Unicode class name found.\")\n@@ -695,11 +700,18 @@ impl<'a> Parser<'a> {\n         let start = self.chari + 2;\n         let closer =\n             match self.pos('}') {\n+                #[cfg(stage0)]\n                 None => {\n                     return self.err(format!(\"Missing '\\\\}' for unclosed \\\n                                              '\\\\{' at position {}\",\n                                             start).as_slice())\n                 }\n+                #[cfg(not(stage0))]\n+                None => {\n+                    return self.err(format!(\"Missing '}}' for unclosed \\\n+                                             '{{' at position {}\",\n+                                            start).as_slice())\n+                }\n                 Some(i) => i,\n             };\n         self.chari = closer;"}, {"sha": "1204a2d97b2983012c7a84636676347a741f3eb4", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -108,6 +108,7 @@ struct Context<'a> {\n }\n \n impl<'a> Context<'a> {\n+    #[cfg(stage0)]\n     fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n         if !self.has_feature(feature) {\n             self.sess.span_err(span, explain);\n@@ -116,6 +117,15 @@ impl<'a> Context<'a> {\n                                                  feature).as_slice());\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n+        if !self.has_feature(feature) {\n+            self.sess.span_err(span, explain);\n+            self.sess.span_note(span, format!(\"add #![feature({})] to the \\\n+                                               crate attributes to enable\",\n+                                              feature).as_slice());\n+        }\n+    }\n \n     fn gate_box(&self, span: Span) {\n         self.gate_feature(\"managed_boxes\", span,"}, {"sha": "dce14099bb365fb08681ef006ac0a67f831f2391", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -63,12 +63,20 @@ struct StandardLibraryInjector<'a> {\n pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n     match option_env!(\"CFG_DISABLE_INJECT_STD_VERSION\") {\n         Some(\"1\") => None,\n+        #[cfg(stage0)]\n         _ => {\n             Some((token::intern_and_get_ident(format!(\"{}\\\\#{}\",\n                                                       krate,\n                                                       VERSION).as_slice()),\n                   ast::CookedStr))\n         }\n+        #[cfg(not(stage0))]\n+        _ => {\n+            Some((token::intern_and_get_ident(format!(\"{}#{}\",\n+                                                      krate,\n+                                                      VERSION).as_slice()),\n+                  ast::CookedStr))\n+        }\n     }\n }\n "}, {"sha": "9e0bea75186db2ec5a9223b661a5165543e052d2", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -146,8 +146,8 @@ impl<'a> Context<'a> {\n                                         self.triple).as_slice());\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n-                    format!(\"crate `{}` path \\\\#{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display()).as_slice());\n+                    format!(\"crate `{}` path {}{}, triple {}: {}\",\n+                            self.ident, \"#\", i+1, got, path.display()).as_slice());\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -156,18 +156,27 @@ impl<'a> Context<'a> {\n             let mismatches = self.rejected_via_hash.iter();\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n-                    format!(\"crate `{}` path \\\\#{}: {}\",\n-                            self.ident, i+1, path.display()).as_slice());\n+                    format!(\"crate `{}` path {}{}: {}\",\n+                            self.ident, \"#\", i+1, path.display()).as_slice());\n             }\n             match self.root {\n                 &None => {}\n+                #[cfg(stage0)]\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n                             format!(\"crate `{}` path \\\\#{}: {}\",\n                                     r.ident, i+1, path.display()).as_slice());\n                     }\n                 }\n+                #[cfg(not(stage0))]\n+                &Some(ref r) => {\n+                    for (i, path) in r.paths().iter().enumerate() {\n+                        self.sess.fileline_note(self.span,\n+                            format!(\"crate `{}` path #{}: {}\",\n+                                    r.ident, i+1, path.display()).as_slice());\n+                    }\n+                }\n             }\n         }\n         self.sess.abort_if_errors();"}, {"sha": "8b36256492fa0e058ea2b910c9c8f624ff219b45", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -47,6 +47,7 @@ pub struct ty_abbrev {\n \n pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n \n+#[cfg(stage0)]\n pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n     match cx.abbrevs.borrow_mut().find(&t) {\n         Some(a) => { w.write(a.s.as_bytes()); return; }\n@@ -70,6 +71,30 @@ pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n         });\n     }\n }\n+#[cfg(not(stage0))]\n+pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n+    match cx.abbrevs.borrow_mut().find(&t) {\n+        Some(a) => { w.write(a.s.as_bytes()); return; }\n+        None => {}\n+    }\n+    let pos = w.tell().unwrap();\n+    enc_sty(w, cx, &ty::get(t).sty);\n+    let end = w.tell().unwrap();\n+    let len = end - pos;\n+    fn estimate_sz(u: u64) -> u64 {\n+        let mut n = u;\n+        let mut len = 0;\n+        while n != 0 { len += 1; n = n >> 4; }\n+        return len;\n+    }\n+    let abbrev_len = 3 + estimate_sz(pos) + estimate_sz(len);\n+    if abbrev_len < len {\n+        // I.e. it's actually an abbreviation.\n+        cx.abbrevs.borrow_mut().insert(t, ty_abbrev {\n+            s: format!(\"#{:x}:{:x}#\", pos, len)\n+        });\n+    }\n+}\n \n fn enc_mutability(w: &mut MemWriter, mt: ast::Mutability) {\n     match mt {"}, {"sha": "3cf7602491ae0be8cae618259bf55e680d5b472f", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -493,10 +493,16 @@ pub fn emit_lint(level: Level, src: LintSource, msg: &str, span: Span,\n \n     let mut note = None;\n     let msg = match src {\n+        #[cfg(stage0)]\n         Default => {\n             format!(\"{}, \\\\#[{}({})] on by default\", msg,\n                 level_to_str(level), lint_str)\n         },\n+        #[cfg(not(stage0))]\n+        Default => {\n+            format!(\"{}, #[{}({})] on by default\", msg,\n+                level_to_str(level), lint_str)\n+        },\n         CommandLine => {\n             format!(\"{} [-{} {}]\", msg,\n                 match level {"}, {"sha": "57c10e19e661a9cb8dd1c5d26ee8968f454ff17d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -1253,13 +1253,22 @@ impl cmt_ {\n }\n \n impl Repr for cmt_ {\n+    #[cfg(stage0)]\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"\\\\{{} id:{} m:{:?} ty:{}\\\\}\",\n                 self.cat.repr(tcx),\n                 self.id,\n                 self.mutbl,\n                 self.ty.repr(tcx))\n     }\n+    #[cfg(not(stage0))]\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"{{{} id:{} m:{:?} ty:{}}}\",\n+                self.cat.repr(tcx),\n+                self.id,\n+                self.mutbl,\n+                self.ty.repr(tcx))\n+    }\n }\n \n impl Repr for categorization {\n@@ -1306,7 +1315,10 @@ impl Repr for InteriorKind {\n             InteriorField(NamedField(fld)) => {\n                 token::get_name(fld).get().to_str()\n             }\n+            #[cfg(stage0)]\n             InteriorField(PositionalField(i)) => format!(\"\\\\#{:?}\", i),\n+            #[cfg(not(stage0))]\n+            InteriorField(PositionalField(i)) => format!(\"#{:?}\", i),\n             InteriorElement(_) => \"[]\".to_string(),\n         }\n     }"}, {"sha": "f61854a7dfac660316d7ad6d7dfa37035911505b", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -642,8 +642,12 @@ impl<'a> PrivacyVisitor<'a> {\n         let msg = match name {\n             NamedField(name) => format!(\"field `{}` of {} is private\",\n                                         token::get_ident(name), struct_desc),\n+            #[cfg(stage0)]\n             UnnamedField(idx) => format!(\"field \\\\#{} of {} is private\",\n                                          idx + 1, struct_desc),\n+            #[cfg(not(stage0))]\n+            UnnamedField(idx) => format!(\"field #{} of {} is private\",\n+                                         idx + 1, struct_desc),\n         };\n         self.tcx.sess.span_err(span, msg.as_slice());\n     }"}, {"sha": "d1c7baf9f177d08028e4e4bd6ec22f13db5857fd", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -4075,6 +4075,7 @@ impl<'a> Resolver<'a> {\n \n             for (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n+                  #[cfg(stage0)]\n                   None => {\n                     self.resolve_error(\n                         p.span,\n@@ -4083,6 +4084,16 @@ impl<'a> Resolver<'a> {\n                                 token::get_name(key),\n                                 i + 1).as_slice());\n                   }\n+                  #[cfg(not(stage0))]\n+                  None => {\n+                    self.resolve_error(\n+                        p.span,\n+                        format!(\"variable `{}` from pattern #1 is \\\n+                                  not bound in pattern #{}\",\n+                                token::get_name(key),\n+                                i + 1).as_slice());\n+                  }\n+                  #[cfg(stage0)]\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.resolve_error(\n@@ -4093,17 +4104,28 @@ impl<'a> Resolver<'a> {\n                                     i + 1).as_slice());\n                     }\n                   }\n+                  #[cfg(not(stage0))]\n+                  Some(binding_i) => {\n+                    if binding_0.binding_mode != binding_i.binding_mode {\n+                        self.resolve_error(\n+                            binding_i.span,\n+                            format!(\"variable `{}` is bound with different \\\n+                                      mode in pattern #{} than in pattern #1\",\n+                                    token::get_name(key),\n+                                    i + 1).as_slice());\n+                    }\n+                  }\n                 }\n             }\n \n             for (&key, &binding) in map_i.iter() {\n                 if !map_0.contains_key(&key) {\n                     self.resolve_error(\n                         binding.span,\n-                        format!(\"variable `{}` from pattern \\\\#{} is \\\n-                                  not bound in pattern \\\\#1\",\n+                        format!(\"variable `{}` from pattern {}{} is \\\n+                                  not bound in pattern {}1\",\n                                 token::get_name(key),\n-                                i + 1).as_slice());\n+                                \"#\", i + 1, \"#\").as_slice());\n                 }\n             }\n         }\n@@ -5108,6 +5130,7 @@ impl<'a> Resolver<'a> {\n                         // structs, which wouldn't result in this error.)\n                         match self.with_no_errors(|this|\n                             this.resolve_path(expr.id, path, TypeNS, false)) {\n+                            #[cfg(stage0)]\n                             Some((DefTy(struct_id), _))\n                               if self.structs.contains_key(&struct_id) => {\n                                 self.resolve_error(expr.span,\n@@ -5121,6 +5144,21 @@ impl<'a> Resolver<'a> {\n                                             `{} \\\\{ /* fields */ \\\\}`?\",\n                                             wrong_name).as_slice());\n \n+                            }\n+                            #[cfg(not(stage0))]\n+                            Some((DefTy(struct_id), _))\n+                              if self.structs.contains_key(&struct_id) => {\n+                                self.resolve_error(expr.span,\n+                                        format!(\"`{}` is a structure name, but \\\n+                                                 this expression \\\n+                                                 uses it like a function name\",\n+                                                wrong_name).as_slice());\n+\n+                                self.session.span_note(expr.span,\n+                                    format!(\"Did you mean to write: \\\n+                                            `{} {{ /* fields */ }}`?\",\n+                                            wrong_name).as_slice());\n+\n                             }\n                             _ => {\n                                 let mut method_scope = false;"}, {"sha": "4078268c6a5d8d43b9b88ce809406f511b6ebcce", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -761,7 +761,8 @@ impl<'a> Builder<'a> {\n     pub fn add_comment(&self, text: &str) {\n         if self.ccx.sess().asm_comments() {\n             let sanitized = text.replace(\"$\", \"\");\n-            let comment_text = format!(\"\\\\# {}\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n+            let comment_text = format!(\"{} {}\", \"#\",\n+                                       sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n             let asm = comment_text.as_slice().with_c_str(|c| {\n                 unsafe {"}, {"sha": "b43b47573b95fa143c230789b96ef4b9a02ed9bd", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -692,7 +692,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n             let mut llforeign_arg = llvm::LLVMGetParam(llwrapfn, foreign_index);\n \n-            debug!(\"llforeign_arg \\\\#{}: {}\",\n+            debug!(\"llforeign_arg {}{}: {}\", \"#\",\n                    i, ccx.tn.val_to_str(llforeign_arg));\n             debug!(\"rust_indirect = {}, foreign_indirect = {}\",\n                    rust_indirect, foreign_indirect);\n@@ -725,7 +725,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                 llvm::LLVMBuildLoad(builder, llforeign_arg, noname())\n             };\n \n-            debug!(\"llrust_arg \\\\#{}: {}\",\n+            debug!(\"llrust_arg {}{}: {}\", \"#\",\n                    i, ccx.tn.val_to_str(llrust_arg));\n             llrust_args.push(llrust_arg);\n         }"}, {"sha": "1edd802f1444e38ea7a8dc6f99815bae02eab276", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -391,12 +391,14 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n                 };\n                 ccx.sess().span_fatal(sp,\n                     format!(\"transmute called on types with different sizes: \\\n-                             {intype} ({insize, plural, =1{# bit} other{# bits}}) to \\\n-                             {outtype} ({outsize, plural, =1{# bit} other{# bits}})\",\n-                            intype = ty_to_str(ccx.tcx(), in_type),\n-                            insize = in_type_size as uint,\n-                            outtype = ty_to_str(ccx.tcx(), out_type),\n-                            outsize = out_type_size as uint).as_slice());\n+                             {} ({} bit{}) to \\\n+                             {} ({} bit{})\",\n+                            ty_to_str(ccx.tcx(), in_type),\n+                            in_type_size,\n+                            if in_type_size == 1 {\"\"} else {\"s\"},\n+                            ty_to_str(ccx.tcx(), out_type),\n+                            out_type_size,\n+                            if out_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n             }\n \n             if !return_type_is_void(ccx, out_type) {"}, {"sha": "6005d4fbda8959db336dd9125c0b77ad13688f1a", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -73,6 +73,7 @@ pub struct VecTypes {\n }\n \n impl VecTypes {\n+    #[cfg(stage0)]\n     pub fn to_str(&self, ccx: &CrateContext) -> String {\n         format!(\"VecTypes \\\\{unit_ty={}, llunit_ty={}, \\\n                  llunit_size={}, llunit_alloc_size={}\\\\}\",\n@@ -81,6 +82,15 @@ impl VecTypes {\n                 ccx.tn.val_to_str(self.llunit_size),\n                 self.llunit_alloc_size)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn to_str(&self, ccx: &CrateContext) -> String {\n+        format!(\"VecTypes {{unit_ty={}, llunit_ty={}, \\\n+                 llunit_size={}, llunit_alloc_size={}}}\",\n+                ty_to_str(ccx.tcx(), self.unit_ty),\n+                ccx.tn.type_to_str(self.llunit_ty),\n+                ccx.tn.val_to_str(self.llunit_size),\n+                self.llunit_alloc_size)\n+    }\n }\n \n pub fn trans_fixed_vstore<'a>("}, {"sha": "3ba3954e445742b497b28c9d44732f5cf6be2051", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -317,7 +317,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n     if did.krate == 0 {\n         format!(\"{}.{}\", name, tstr)\n     } else {\n-        format!(\"{}.{}[\\\\#{}]\", name, tstr, did.krate)\n+        format!(\"{}.{}[{}{}]\", name, tstr, \"#\", did.krate)\n     }\n }\n "}, {"sha": "c2c71ba32f312acda994b18ec029534f64b77616", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -884,29 +884,44 @@ impl Vid for TyVid {\n }\n \n impl fmt::Show for TyVid {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n         write!(f, \"<generic \\\\#{}>\", self.to_uint())\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n+        write!(f, \"<generic #{}>\", self.to_uint())\n+    }\n }\n \n impl Vid for IntVid {\n     fn to_uint(&self) -> uint { let IntVid(v) = *self; v }\n }\n \n impl fmt::Show for IntVid {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"<generic integer \\\\#{}>\", self.to_uint())\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"<generic integer #{}>\", self.to_uint())\n+    }\n }\n \n impl Vid for FloatVid {\n     fn to_uint(&self) -> uint { let FloatVid(v) = *self; v }\n }\n \n impl fmt::Show for FloatVid {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"<generic float \\\\#{}>\", self.to_uint())\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"<generic float #{}>\", self.to_uint())\n+    }\n }\n \n impl Vid for RegionVid {"}, {"sha": "b950d569d56a9e25c6de8652c4020732cf1581a6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -256,13 +256,13 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n     if arg_len > 0 {\n         // N-ary variant.\n         if arg_len != subpats_len {\n-            let s = format!(\"this pattern has \\\n-                             {npat, plural, =1{# field} other{# fields}}, \\\n-                             but the corresponding {kind} has \\\n-                             {narg, plural, =1{# field} other{# fields}}\",\n-                         npat = subpats_len,\n-                         kind = kind_name,\n-                         narg = arg_len);\n+            let s = format!(\"this pattern has {} field{}, \\\n+                             but the corresponding {} has {} field{}\",\n+                         subpats_len,\n+                         if subpats_len == 1 {\"\"} else {\"s\"},\n+                         kind_name,\n+                         arg_len,\n+                         if arg_len == 1 {\"\"} else {\"s\"});\n             tcx.sess.span_err(pat.span, s.as_slice());\n             error_happened = true;\n         }\n@@ -276,11 +276,11 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n         }\n     } else if subpats_len > 0 {\n         tcx.sess.span_err(pat.span,\n-                          format!(\"this pattern has \\\n-                                   {npat, plural, =1{# field} other{# fields}}, \\\n-                                   but the corresponding {kind} has no fields\",\n-                               npat = subpats_len,\n-                               kind = kind_name).as_slice());\n+                          format!(\"this pattern has {} field{}, \\\n+                                   but the corresponding {} has no fields\",\n+                               subpats_len,\n+                               if subpats_len == 1 {\"\"} else {\"s\"},\n+                               kind_name).as_slice());\n         error_happened = true;\n     }\n "}, {"sha": "ba53cbf0cab0628abd7b0d769d4ad5807f7b7cbb", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -1435,6 +1435,7 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn report_static_candidate(&self, idx: uint, did: DefId) {\n         let span = if did.krate == ast::LOCAL_CRATE {\n             self.tcx().map.span(did.node)\n@@ -1448,6 +1449,7 @@ impl<'a> LookupContext<'a> {\n                     ty::item_path_str(self.tcx(), did)).as_slice());\n     }\n \n+    #[cfg(stage0)]\n     fn report_param_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.span,\n@@ -1456,6 +1458,7 @@ impl<'a> LookupContext<'a> {\n                     ty::item_path_str(self.tcx(), did)).as_slice());\n     }\n \n+    #[cfg(stage0)]\n     fn report_trait_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.span,\n@@ -1465,6 +1468,39 @@ impl<'a> LookupContext<'a> {\n                     ty::item_path_str(self.tcx(), did)).as_slice());\n     }\n \n+    #[cfg(not(stage0))]\n+    fn report_static_candidate(&self, idx: uint, did: DefId) {\n+        let span = if did.krate == ast::LOCAL_CRATE {\n+            self.tcx().map.span(did.node)\n+        } else {\n+            self.span\n+        };\n+        self.tcx().sess.span_note(\n+            span,\n+            format!(\"candidate #{} is `{}`\",\n+                    idx + 1u,\n+                    ty::item_path_str(self.tcx(), did)).as_slice());\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn report_param_candidate(&self, idx: uint, did: DefId) {\n+        self.tcx().sess.span_note(\n+            self.span,\n+            format!(\"candidate #{} derives from the bound `{}`\",\n+                    idx + 1u,\n+                    ty::item_path_str(self.tcx(), did)).as_slice());\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn report_trait_candidate(&self, idx: uint, did: DefId) {\n+        self.tcx().sess.span_note(\n+            self.span,\n+            format!(\"candidate #{} derives from the type of the receiver, \\\n+                     which is the trait `{}`\",\n+                    idx + 1u,\n+                    ty::item_path_str(self.tcx(), did)).as_slice());\n+    }\n+\n     fn infcx(&'a self) -> &'a infer::InferCtxt<'a> {\n         &self.fcx.inh.infcx\n     }"}, {"sha": "a6615d6bce9ff455172e7cf84edd765f82a262f4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 96, "deletions": 94, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -902,26 +902,26 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     if num_impl_m_type_params != num_trait_m_type_params {\n         tcx.sess.span_err(\n             impl_m_span,\n-            format!(\"method `{method}` has {nimpl, plural, =1{# type parameter} \\\n-                                                        other{# type parameters}}, \\\n-                     but its trait declaration has {ntrait, plural, =1{# type parameter} \\\n-                                                                 other{# type parameters}}\",\n-                    method = token::get_ident(trait_m.ident),\n-                    nimpl = num_impl_m_type_params,\n-                    ntrait = num_trait_m_type_params).as_slice());\n+            format!(\"method `{}` has {} type parameter{} \\\n+                     but its trait declaration has {} type parameter{}\",\n+                    token::get_ident(trait_m.ident),\n+                    num_impl_m_type_params,\n+                    if num_impl_m_type_params == 1 {\"\"} else {\"s\"},\n+                    num_trait_m_type_params,\n+                    if num_trait_m_type_params == 1 {\"\"} else {\"s\"}).as_slice());\n         return;\n     }\n \n     if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n         tcx.sess.span_err(\n             impl_m_span,\n-            format!(\"method `{method}` has {nimpl, plural, =1{# parameter} \\\n-                                                        other{# parameters}} \\\n-                     but the declaration in trait `{trait}` has {ntrait}\",\n-                 method = token::get_ident(trait_m.ident),\n-                 nimpl = impl_m.fty.sig.inputs.len(),\n-                 trait = ty::item_path_str(tcx, trait_m.def_id),\n-                 ntrait = trait_m.fty.sig.inputs.len()).as_slice());\n+            format!(\"method `{}` has {} parameter{} \\\n+                     but the declaration in trait `{}` has {}\",\n+                 token::get_ident(trait_m.ident),\n+                 impl_m.fty.sig.inputs.len(),\n+                 if impl_m.fty.sig.inputs.len() == 1 {\"\"} else {\"s\"},\n+                 ty::item_path_str(tcx, trait_m.def_id),\n+                 trait_m.fty.sig.inputs.len()).as_slice());\n         return;\n     }\n \n@@ -954,20 +954,19 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         if impl_param_def.bounds.trait_bounds.len() !=\n             trait_param_def.bounds.trait_bounds.len()\n         {\n+            let found = impl_param_def.bounds.trait_bounds.len();\n+            let expected =  trait_param_def.bounds.trait_bounds.len();\n             tcx.sess.span_err(\n                 impl_m_span,\n-                format!(\"in method `{method}`, \\\n-                        type parameter {typaram} has \\\n-                        {nimpl, plural, =1{# trait bound} other{# trait bounds}}, \\\n-                        but the corresponding type parameter in \\\n-                        the trait declaration has \\\n-                        {ntrait, plural, =1{# trait bound} other{# trait bounds}}\",\n-                        method = token::get_ident(trait_m.ident),\n-                        typaram = i,\n-                        nimpl = impl_param_def.bounds.trait_bounds.len(),\n-                        ntrait = trait_param_def.bounds\n-                                                .trait_bounds\n-                                                .len()).as_slice());\n+                format!(\"in method `{}`, type parameter {} has {} trait \\\n+                         bound{}, but the corresponding type parameter in \\\n+                         the trait declaration has {} trait bound{}\",\n+                        token::get_ident(trait_m.ident),\n+                        i,\n+                        found,\n+                        if found == 1 {\"\"} else {\"s\"},\n+                        expected,\n+                        if expected == 1 {\"\"} else {\"s\"}).as_slice());\n             return;\n         }\n     }\n@@ -1526,13 +1525,12 @@ fn check_argument_types(fcx: &FnCtxt,\n             ty::ty_tup(ref arg_types) => {\n                 if arg_types.len() != args.len() {\n                     let msg = format!(\n-                        \"this function takes \\\n-                         {nexpected, plural, =1{# parameter} \\\n-                         other{# parameters}} \\\n-                         but {nsupplied, plural, =1{# parameter was} \\\n-                         other{# parameters were}} supplied\",\n-                         nexpected = arg_types.len(),\n-                         nsupplied = args.len());\n+                        \"this function takes {} parameter{} \\\n+                         but {} parameter{} supplied\",\n+                         arg_types.len(),\n+                         if arg_types.len() == 1 {\"\"} else {\"s\"},\n+                         args.len(),\n+                         if args.len() == 1 {\" was\"} else {\"s were\"});\n                     tcx.sess.span_err(sp, msg.as_slice());\n                     err_args(args.len())\n                 } else {\n@@ -1543,9 +1541,9 @@ fn check_argument_types(fcx: &FnCtxt,\n                 if args.len() != 0 {\n                     let msg = format!(\n                         \"this function takes 0 parameters \\\n-                         but {nsupplied, plural, =1{# parameter was} \\\n-                         other{# parameters were}} supplied\",\n-                         nsupplied = args.len());\n+                         but {} parameter{} supplied\",\n+                         args.len(),\n+                         if args.len() == 1 {\" was\"} else {\"s were\"});\n                     tcx.sess.span_err(sp, msg.as_slice());\n                 }\n                 Vec::new()\n@@ -1566,25 +1564,25 @@ fn check_argument_types(fcx: &FnCtxt,\n             fn_inputs.iter().map(|a| *a).collect()\n         } else {\n             let msg = format!(\n-                \"this function takes at least {nexpected, plural, =1{# parameter} \\\n-                                                               other{# parameters}} \\\n-                 but {nsupplied, plural, =1{# parameter was} \\\n-                                      other{# parameters were}} supplied\",\n-                 nexpected = expected_arg_count,\n-                 nsupplied = supplied_arg_count);\n+                \"this function takes at least {} parameter{} \\\n+                 but {} parameter{} supplied\",\n+                 expected_arg_count,\n+                 if expected_arg_count == 1 {\"\"} else {\"s\"},\n+                 supplied_arg_count,\n+                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n \n             tcx.sess.span_err(sp, msg.as_slice());\n \n             err_args(supplied_arg_count)\n         }\n     } else {\n         let msg = format!(\n-            \"this function takes {nexpected, plural, =1{# parameter} \\\n-                                                  other{# parameters}} \\\n-             but {nsupplied, plural, =1{# parameter was} \\\n-                                  other{# parameters were}} supplied\",\n-             nexpected = expected_arg_count,\n-             nsupplied = supplied_arg_count);\n+            \"this function takes {} parameter{} \\\n+             but {} parameter{} supplied\",\n+             expected_arg_count,\n+             if expected_arg_count == 1 {\"\"} else {\"s\"},\n+             supplied_arg_count,\n+             if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n \n         tcx.sess.span_err(sp, msg.as_slice());\n \n@@ -1932,12 +1930,14 @@ fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n                 function_context.tcx()\n                     .sess\n                     .span_err(path.span,\n-                              format!(\"expected {nexpected, plural, =1{# lifetime parameter} \\\n-                                                                 other{# lifetime parameters}}, \\\n-                                       found {nsupplied, plural, =1{# lifetime parameter} \\\n-                                                              other{# lifetime parameters}}\",\n-                                      nexpected = trait_region_parameter_count,\n-                                      nsupplied = supplied_region_parameter_count).as_slice());\n+                              format!(\"expected {} lifetime parameter{} \\\n+                                       found {} liftime parameter{}\",\n+                                      trait_region_parameter_count,\n+                                      if trait_region_parameter_count == 1 {\"\"}\n+                                        else {\"s\"},\n+                                      supplied_region_parameter_count,\n+                                      if supplied_region_parameter_count == 1 {\"\"}\n+                                        else {\"s\"}).as_slice());\n             }\n \n             // Make sure the number of type parameters supplied on the trait\n@@ -1950,45 +1950,41 @@ fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n             let supplied_ty_param_count = trait_segment.types.len();\n             if supplied_ty_param_count < required_ty_param_count {\n                 let msg = if required_ty_param_count < generics.type_param_defs().len() {\n-                    format!(\"the {trait_or_impl} referenced by this path needs at least \\\n-                             {nexpected, plural, =1{# type parameter} \\\n-                                              other{# type parameters}}, \\\n-                             but {nsupplied, plural, =1{# type parameter} \\\n-                                                  other{# type parameters}} were supplied\",\n-                            trait_or_impl = name,\n-                            nexpected = required_ty_param_count,\n-                            nsupplied = supplied_ty_param_count)\n+                    format!(\"the {} referenced by this path needs at least \\\n+                             {} type parameter{}, but {} type parameters were \\\n+                             supplied\",\n+                            name,\n+                            required_ty_param_count,\n+                            if required_ty_param_count == 1 {\"\"} else {\"s\"},\n+                            supplied_ty_param_count)\n                 } else {\n-                    format!(\"the {trait_or_impl} referenced by this path needs \\\n-                             {nexpected, plural, =1{# type parameter} \\\n-                                              other{# type parameters}}, \\\n-                             but {nsupplied, plural, =1{# type parameter} \\\n-                                                  other{# type parameters}} were supplied\",\n-                            trait_or_impl = name,\n-                            nexpected = required_ty_param_count,\n-                            nsupplied = supplied_ty_param_count)\n+                    format!(\"the {} referenced by this path needs \\\n+                             {} type parameter{}, but {} type parameters were \\\n+                             supplied\",\n+                            name,\n+                            required_ty_param_count,\n+                            if required_ty_param_count == 1 {\"\"} else {\"s\"},\n+                            supplied_ty_param_count)\n                 };\n                 function_context.tcx().sess.span_err(path.span,\n                                                      msg.as_slice())\n             } else if supplied_ty_param_count > formal_ty_param_count {\n                 let msg = if required_ty_param_count < generics.type_param_defs().len() {\n-                    format!(\"the {trait_or_impl} referenced by this path needs at most \\\n-                             {nexpected, plural, =1{# type parameter} \\\n-                                              other{# type parameters}}, \\\n-                             but {nsupplied, plural, =1{# type parameter} \\\n-                                                  other{# type parameters}} were supplied\",\n-                            trait_or_impl = name,\n-                            nexpected = formal_ty_param_count,\n-                            nsupplied = supplied_ty_param_count)\n+                    format!(\"the {} referenced by this path needs at most \\\n+                             {} type parameter{}, but {} type parameters were \\\n+                             supplied\",\n+                            name,\n+                            formal_ty_param_count,\n+                            if formal_ty_param_count == 1 {\"\"} else {\"s\"},\n+                            supplied_ty_param_count)\n                 } else {\n-                    format!(\"the {trait_or_impl} referenced by this path needs \\\n-                             {nexpected, plural, =1{# type parameter} \\\n-                                              other{# type parameters}}, \\\n-                             but {nsupplied, plural, =1{# type parameter} \\\n-                                                  other{# type parameters}} were supplied\",\n-                            trait_or_impl = name,\n-                            nexpected = formal_ty_param_count,\n-                            nsupplied = supplied_ty_param_count)\n+                    format!(\"the {} referenced by this path needs \\\n+                             {} type parameter{}, but {} type parameters were \\\n+                             supplied\",\n+                            name,\n+                            formal_ty_param_count,\n+                            if formal_ty_param_count == 1 {\"\"} else {\"s\"},\n+                            supplied_ty_param_count)\n                 };\n                 function_context.tcx().sess.span_err(path.span,\n                                                      msg.as_slice())\n@@ -2670,8 +2666,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n                 tcx.sess.span_err(span,\n                     format!(\n-                        \"missing {nfields, plural, =1{field} other{fields}}: {fields}\",\n-                        nfields = missing_fields.len(),\n+                        \"missing field{}: {fields}\",\n+                        if missing_fields.len() == 1 {\"\"} else {\"s\"},\n                         fields = missing_fields.connect(\", \")).as_slice());\n              }\n         }\n@@ -4021,12 +4017,12 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         if num_supplied_regions != 0 {\n             fcx.ccx.tcx.sess.span_err(\n                 span,\n-                format!(\"expected {nexpected, plural, =1{# lifetime parameter} \\\n-                                                   other{# lifetime parameters}}, \\\n-                         found {nsupplied, plural, =1{# lifetime parameter} \\\n-                                                other{# lifetime parameters}}\",\n-                        nexpected = num_expected_regions,\n-                        nsupplied = num_supplied_regions).as_slice());\n+                format!(\"expected {} lifetime parameter{}, \\\n+                         found {} lifetime parameter{}\",\n+                        num_expected_regions,\n+                        if num_expected_regions == 1 {\"\"} else {\"s\"},\n+                        num_supplied_regions,\n+                        if num_supplied_regions == 1 {\"\"} else {\"s\"}).as_slice());\n         }\n \n         fcx.infcx().region_vars_for_defs(span, tpt.generics.region_param_defs.as_slice())\n@@ -4296,10 +4292,16 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n \n     ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {\n+                #[cfg(stage0)]\n                 ty::ty_param(param_ty {idx, ..}) => {\n                     debug!(\"Found use of ty param \\\\#{}\", idx);\n                     *tps_used.get_mut(idx) = true;\n                 }\n+                #[cfg(not(stage0))]\n+                ty::ty_param(param_ty {idx, ..}) => {\n+                    debug!(\"Found use of ty param #{}\", idx);\n+                    *tps_used.get_mut(idx) = true;\n+                }\n                 _ => ()\n             }\n         });"}, {"sha": "546eaa1fceb740d5f39715ee2e306ab66607f66c", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -386,8 +386,8 @@ fn search_for_vtable(vcx: &VtableContext,\n         // some value of U) with some_trait<T>. This would fail if T\n         // and U weren't compatible.\n \n-        debug!(\"(checking vtable) \\\\#2 relating trait \\\n-                ty {} to of_trait_ref {}\",\n+        debug!(\"(checking vtable) {}2 relating trait \\\n+                ty {} to of_trait_ref {}\", \"#\",\n                vcx.infcx.trait_ref_to_str(&*trait_ref),\n                vcx.infcx.trait_ref_to_str(&*of_trait_ref));\n "}, {"sha": "8ea15d2542047d50ace71e012b02a66c55ab0e5a", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -1323,7 +1323,7 @@ impl<'a> RegionVarBindings<'a> {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            debug!(\"---- {} Iteration \\\\#{}\", tag, iteration);\n+            debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n             for (constraint, _) in self.constraints.borrow().iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {"}, {"sha": "5be1b7ba791224306a1dc5953e0a16db58281d56", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -61,9 +61,14 @@ impl<V:InferStr> InferStr for Bound<V> {\n }\n \n impl<T:InferStr> InferStr for Bounds<T> {\n+    #[cfg(stage0)]\n     fn inf_str(&self, cx: &InferCtxt) -> String {\n         format!(\"\\\\{{} <: {}\\\\}\", self.lb.inf_str(cx), self.ub.inf_str(cx))\n     }\n+    #[cfg(not(stage0))]\n+    fn inf_str(&self, cx: &InferCtxt) -> String {\n+        format!(\"{{{} <: {}}}\", self.lb.inf_str(cx), self.ub.inf_str(cx))\n+    }\n }\n \n impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {"}, {"sha": "56fc79fa5e7023387c6d2751358dae6aceeaa11e", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -232,11 +232,18 @@ pub struct impl_res {\n }\n \n impl Repr for impl_res {\n+    #[cfg(stage0)]\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"impl_res \\\\{trait_vtables={}, self_vtables={}\\\\}\",\n                 self.trait_vtables.repr(tcx),\n                 self.self_vtables.repr(tcx))\n     }\n+    #[cfg(not(stage0))]\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"impl_res {{trait_vtables={}, self_vtables={}}}\",\n+                self.trait_vtables.repr(tcx),\n+                self.self_vtables.repr(tcx))\n+    }\n }\n \n pub type impl_vtable_map = RefCell<DefIdMap<impl_res>>;"}, {"sha": "ff57747256e19f418820cb52c4cc8659ed281560", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -95,9 +95,14 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n \n       ReFree(ref fr) => {\n         let prefix = match fr.bound_region {\n+          #[cfg(stage0)]\n           BrAnon(idx) => {\n               format!(\"the anonymous lifetime \\\\#{} defined on\", idx + 1)\n           }\n+          #[cfg(not(stage0))]\n+          BrAnon(idx) => {\n+              format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+          }\n           BrFresh(_) => \"an anonymous lifetime defined on\".to_string(),\n           _ => {\n               format!(\"the lifetime {} as defined on\",\n@@ -375,7 +380,10 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n               Some(def) => token::get_ident(def.ident).get().to_string(),\n               // This can only happen when a type mismatch error happens and\n               // the actual type has more type parameters than the expected one.\n-              None => format!(\"<generic \\\\#{}>\", id)\n+              #[cfg(stage0)]\n+              None => format!(\"<generic \\\\#{}>\", id),\n+              #[cfg(not(stage0))]\n+              None => format!(\"<generic #{}>\", id),\n           };\n           if !cx.sess.verbose() {\n               ident\n@@ -729,11 +737,18 @@ impl Repr for ast::DefId {\n }\n \n impl Repr for ty::ty_param_bounds_and_ty {\n+    #[cfg(stage0)]\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"ty_param_bounds_and_ty \\\\{generics: {}, ty: {}\\\\}\",\n                 self.generics.repr(tcx),\n                 self.ty.repr(tcx))\n     }\n+    #[cfg(not(stage0))]\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"ty_param_bounds_and_ty {{generics: {}, ty: {}}}\",\n+                self.generics.repr(tcx),\n+                self.ty.repr(tcx))\n+    }\n }\n \n impl Repr for ty::Generics {\n@@ -800,12 +815,20 @@ impl Repr for ast::Visibility {\n }\n \n impl Repr for ty::BareFnTy {\n+    #[cfg(stage0)]\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"BareFnTy \\\\{fn_style: {:?}, abi: {}, sig: {}\\\\}\",\n                 self.fn_style,\n                 self.abi.to_str(),\n                 self.sig.repr(tcx))\n     }\n+    #[cfg(not(stage0))]\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"BareFnTy {{fn_style: {:?}, abi: {}, sig: {}}}\",\n+                self.fn_style,\n+                self.abi.to_str(),\n+                self.sig.repr(tcx))\n+    }\n }\n \n impl Repr for ty::FnSig {\n@@ -815,12 +838,20 @@ impl Repr for ty::FnSig {\n }\n \n impl Repr for typeck::MethodCallee {\n+    #[cfg(stage0)]\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"MethodCallee \\\\{origin: {}, ty: {}, {}\\\\}\",\n                 self.origin.repr(tcx),\n                 self.ty.repr(tcx),\n                 self.substs.repr(tcx))\n     }\n+    #[cfg(not(stage0))]\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"MethodCallee {{origin: {}, ty: {}, {}}}\",\n+                self.origin.repr(tcx),\n+                self.ty.repr(tcx),\n+                self.substs.repr(tcx))\n+    }\n }\n \n impl Repr for typeck::MethodOrigin {"}, {"sha": "a71f702caca1fac2865aed72469f6f2d819378e7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -348,8 +348,7 @@ impl fmt::Show for clean::Type {\n             clean::Self(..) => f.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => primitive_link(f, prim, prim.to_str()),\n             clean::Closure(ref decl, ref region) => {\n-                write!(f, \"{style}{lifetimes}|{args}|{bounds}\\\n-                           {arrow, select, yes{ -&gt; {ret}} other{}}\",\n+                write!(f, \"{style}{lifetimes}|{args}|{bounds}{arrow}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_string()\n@@ -358,10 +357,9 @@ impl fmt::Show for clean::Type {\n                        },\n                        args = decl.decl.inputs,\n                        arrow = match decl.decl.output {\n-                           clean::Primitive(clean::Nil) => \"no\",\n-                           _ => \"yes\",\n+                           clean::Primitive(clean::Nil) => \"\".to_string(),\n+                           _ => format!(\" -&gt; {}\", decl.decl.output),\n                        },\n-                       ret = decl.decl.output,\n                        bounds = {\n                            let mut ret = String::new();\n                            match *region {\n@@ -389,8 +387,7 @@ impl fmt::Show for clean::Type {\n                        })\n             }\n             clean::Proc(ref decl) => {\n-                write!(f, \"{style}{lifetimes}proc({args}){bounds}\\\n-                           {arrow, select, yes{ -&gt; {ret}} other{}}\",\n+                write!(f, \"{style}{lifetimes}proc({args}){bounds}{arrow}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_string()\n@@ -409,10 +406,9 @@ impl fmt::Show for clean::Type {\n                                m.collect::<Vec<String>>().connect(\" + \"))\n                        },\n                        arrow = match decl.decl.output {\n-                           clean::Primitive(clean::Nil) => \"no\",\n-                           _ => \"yes\",\n-                       },\n-                       ret = decl.decl.output)\n+                           clean::Primitive(clean::Nil) => \"\".to_string(),\n+                           _ => format!(\" -&gt; {}\", decl.decl.output)\n+                       })\n             }\n             clean::BareFunction(ref decl) => {\n                 write!(f, \"{}{}fn{}{}\",\n@@ -468,13 +464,12 @@ impl fmt::Show for clean::Arguments {\n \n impl fmt::Show for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n+        write!(f, \"({args}){arrow}\",\n                args = self.inputs,\n                arrow = match self.output {\n-                   clean::Primitive(clean::Nil) => \"no\",\n-                   _ => \"yes\"\n-               },\n-               ret = self.output)\n+                   clean::Primitive(clean::Nil) => \"\".to_string(),\n+                   _ => format!(\" -&gt; {}\", self.output),\n+               })\n     }\n }\n \n@@ -502,14 +497,12 @@ impl<'a> fmt::Show for Method<'a> {\n             }\n             args.push_str(format!(\"{}\", input.type_).as_slice());\n         }\n-        write!(f,\n-               \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n+        write!(f, \"({args}){arrow}\",\n                args = args,\n                arrow = match d.output {\n-                   clean::Primitive(clean::Nil) => \"no\",\n-                   _ => \"yes\"\n-               },\n-               ret = d.output)\n+                   clean::Primitive(clean::Nil) => \"\".to_string(),\n+                   _ => format!(\" -&gt; {}\", d.output),\n+               })\n     }\n }\n \n@@ -545,14 +538,14 @@ impl fmt::Show for clean::ViewPath {\n                 write!(f, \"use {}::*;\", *src)\n             }\n             clean::ImportList(ref src, ref names) => {\n-                try!(write!(f, \"use {}::\\\\{\", *src));\n+                try!(write!(f, \"use {}::{{\", *src));\n                 for (i, n) in names.iter().enumerate() {\n                     if i > 0 {\n                         try!(write!(f, \", \"));\n                     }\n                     try!(write!(f, \"{}\", *n));\n                 }\n-                write!(f, \"\\\\};\")\n+                write!(f, \"}};\")\n             }\n         }\n     }"}, {"sha": "dffb2118b931861a2676c99697e0c5ed857241cb", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -43,7 +43,7 @@ r##\"<!DOCTYPE html>\n           rel='stylesheet' type='text/css'>\n     <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}main.css\">\n \n-    {favicon, select, none{} other{<link rel=\"shortcut icon\" href=\"#\">}}\n+    {favicon}\n </head>\n <body>\n     <!--[if lte IE 8]>\n@@ -54,10 +54,7 @@ r##\"<!DOCTYPE html>\n     <![endif]-->\n \n     <section class=\"sidebar\">\n-        {logo, select, none{} other{\n-            <a href='{root_path}{krate}/index.html'><img src='#' alt='' width='100'></a>\n-        }}\n-\n+        {logo}\n         {sidebar}\n     </section>\n \n@@ -122,9 +119,20 @@ r##\"<!DOCTYPE html>\n     content   = *t,\n     root_path = page.root_path,\n     ty        = page.ty,\n-    logo      = nonestr(layout.logo.as_slice()),\n+    logo      = if layout.logo.len() == 0 {\n+        \"\".to_string()\n+    } else {\n+        format!(\"<a href='{}{}/index.html'>\\\n+                 <img src='{}' alt='' width='100'></a>\",\n+                page.root_path, layout.krate,\n+                layout.logo)\n+    },\n     title     = page.title,\n-    favicon   = nonestr(layout.favicon.as_slice()),\n+    favicon   = if layout.favicon.len() == 0 {\n+        \"\".to_string()\n+    } else {\n+        format!(r#\"<link rel=\"shortcut icon\" href=\"{}\">\"#, layout.favicon)\n+    },\n     sidebar   = *sidebar,\n     krate     = layout.krate,\n     play_url  = layout.playground_url,\n@@ -136,10 +144,6 @@ r##\"<!DOCTYPE html>\n     )\n }\n \n-fn nonestr<'a>(s: &'a str) -> &'a str {\n-    if s == \"\" { \"none\" } else { s }\n-}\n-\n pub fn redirect(dst: &mut io::Writer, url: &str) -> io::IoResult<()> {\n     write!(dst,\n r##\"<!DOCTYPE html>"}, {"sha": "0cacf2f824faa3c4f1a6696b8655a1b45281a41a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -260,9 +260,13 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         // Render the HTML\n         let text = format!(r#\"<h{lvl} id=\"{id}\" class='section-header'><a\n-                           href=\"\\#{id}\">{sec_len,plural,=0{}other{{sec} }}{}</a></h{lvl}>\"#,\n+                           href=\"\\#{id}\">{sec}{}</a></h{lvl}>\"#,\n                            s, lvl = level, id = id,\n-                           sec_len = sec.len(), sec = sec);\n+                           sec = if sec.len() == 0 {\n+                               sec.to_string()\n+                           } else {\n+                               format!(\"{} \", sec)\n+                           });\n \n         text.with_c_str(|p| unsafe { hoedown_buffer_puts(ob, p) });\n     }"}, {"sha": "541af97ba431b853126524c3be8a4ec842d5adb1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -399,7 +399,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n \n     // Collect the index into a string\n     let mut w = MemWriter::new();\n-    try!(write!(&mut w, r#\"searchIndex['{}'] = \\{\"items\":[\"#, krate.name));\n+    try!(write!(&mut w, r#\"searchIndex['{}'] = {{\"items\":[\"#, krate.name));\n \n     let mut lastpath = \"\".to_string();\n     for (i, item) in cache.search_index.iter().enumerate() {\n@@ -439,7 +439,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n                     short, *fqp.last().unwrap()));\n     }\n \n-    try!(write!(&mut w, r\"]\\};\"));\n+    try!(write!(&mut w, \"]}};\"));\n \n     Ok(str::from_utf8(w.unwrap().as_slice()).unwrap().to_string())\n }\n@@ -498,7 +498,7 @@ fn write_shared(cx: &Context,\n     let all_indexes = try!(collect(&dst, krate.name.as_slice(),\n                                    \"searchIndex\"));\n     let mut w = try!(File::create(&dst));\n-    try!(writeln!(&mut w, r\"var searchIndex = \\{\\};\"));\n+    try!(writeln!(&mut w, \"var searchIndex = {{}};\"));\n     try!(writeln!(&mut w, \"{}\", search_index));\n     for index in all_indexes.iter() {\n         try!(writeln!(&mut w, \"{}\", *index));\n@@ -534,7 +534,7 @@ fn write_shared(cx: &Context,\n \n         try!(mkdir(&mydst.dir_path()));\n         let mut f = BufferedWriter::new(try!(File::create(&mydst)));\n-        try!(writeln!(&mut f, r\"(function() \\{var implementors = \\{\\};\"));\n+        try!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"));\n \n         for implementor in all_implementors.iter() {\n             try!(write!(&mut f, \"{}\", *implementor));\n@@ -558,7 +558,7 @@ fn write_shared(cx: &Context,\n                 window.pending_implementors = implementors;\n             }\n         \"));\n-        try!(writeln!(&mut f, r\"\\})()\"));\n+        try!(writeln!(&mut f, r\"}})()\"));\n     }\n     Ok(())\n }\n@@ -1178,7 +1178,7 @@ impl<'a> Item<'a> {\n                         self.item.source.loline,\n                         self.item.source.hiline)\n             };\n-            Some(format!(\"{root}src/{krate}/{path}.html\\\\#{href}\",\n+            Some(format!(\"{root}src/{krate}/{path}.html#{href}\",\n                          root = self.cx.root_path,\n                          krate = self.cx.layout.krate,\n                          path = path.connect(\"/\"),\n@@ -1423,7 +1423,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             };\n             try!(write!(w,\n                         \"<h2 id='{id}' class='section-header'>\\\n-                        <a href=\\\"\\\\#{id}\\\">{name}</a></h2>\\n<table>\",\n+                        <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n                         id = short, name = name));\n         }\n \n@@ -1538,9 +1538,9 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     let provided = t.methods.iter().filter(|m| !m.is_req()).collect::<Vec<&clean::TraitMethod>>();\n \n     if t.methods.len() == 0 {\n-        try!(write!(w, \"\\\\{ \\\\}\"));\n+        try!(write!(w, \"{{ }}\"));\n     } else {\n-        try!(write!(w, \"\\\\{\\n\"));\n+        try!(write!(w, \"{{\\n\"));\n         for m in required.iter() {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m.item()));\n@@ -1552,9 +1552,9 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         for m in provided.iter() {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m.item()));\n-            try!(write!(w, \" \\\\{ ... \\\\}\\n\"));\n+            try!(write!(w, \" {{ ... }}\\n\"));\n         }\n-        try!(write!(w, \"\\\\}\"));\n+        try!(write!(w, \"}}\"));\n     }\n     try!(write!(w, \"</pre>\"));\n \n@@ -1627,7 +1627,7 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n     fn fun(w: &mut fmt::Formatter, it: &clean::Item, fn_style: ast::FnStyle,\n            g: &clean::Generics, selfty: &clean::SelfTy,\n            d: &clean::FnDecl) -> fmt::Result {\n-        write!(w, \"{}fn <a href='\\\\#{ty}.{name}' class='fnname'>{name}</a>\\\n+        write!(w, \"{}fn <a href='#{ty}.{name}' class='fnname'>{name}</a>\\\n                    {generics}{decl}\",\n                match fn_style {\n                    ast::UnsafeFn => \"unsafe \",\n@@ -1693,9 +1693,9 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n                   it.name.get_ref().as_slice(),\n                   e.generics));\n     if e.variants.len() == 0 && !e.variants_stripped {\n-        try!(write!(w, \" \\\\{\\\\}\"));\n+        try!(write!(w, \" {{}}\"));\n     } else {\n-        try!(write!(w, \" \\\\{\\n\"));\n+        try!(write!(w, \" {{\\n\"));\n         for v in e.variants.iter() {\n             try!(write!(w, \"    \"));\n             let name = v.name.get_ref().as_slice();\n@@ -1732,7 +1732,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         if e.variants_stripped {\n             try!(write!(w, \"    // some variants omitted\\n\"));\n         }\n-        try!(write!(w, \"\\\\}\"));\n+        try!(write!(w, \"}}\"));\n     }\n     try!(write!(w, \"</pre>\"));\n \n@@ -1799,7 +1799,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     }\n     match ty {\n         doctree::Plain => {\n-            try!(write!(w, \" \\\\{\\n{}\", tab));\n+            try!(write!(w, \" {{\\n{}\", tab));\n             let mut fields_stripped = false;\n             for field in fields.iter() {\n                 match field.inner {\n@@ -1820,7 +1820,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             if fields_stripped {\n                 try!(write!(w, \"    // some fields omitted\\n{}\", tab));\n             }\n-            try!(write!(w, \"\\\\}\"));\n+            try!(write!(w, \"}}\"));\n         }\n         doctree::Tuple | doctree::Newtype => {\n             try!(write!(w, \"(\"));\n@@ -1979,7 +1979,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n         let len = cx.current.len() - if it.is_mod() {1} else {0};\n         for (i, name) in cx.current.iter().take(len).enumerate() {\n             if i > 0 {\n-                try!(write!(fmt, \"&\\\\#8203;::\"));\n+                try!(write!(fmt, \"&#8203;::\"));\n             }\n             try!(write!(fmt, \"<a href='{}index.html'>{}</a>\",\n                           cx.root_path\n@@ -1998,22 +1998,18 @@ impl<'a> fmt::Show for Sidebar<'a> {\n             try!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n             for item in items.iter() {\n                 let curty = shortty(cur).to_static_str();\n-                let class = if cur.name.get_ref() == item && short == curty {\n-                    \"current\"\n-                } else {\n-                    \"\"\n-                };\n-                try!(write!(w, \"<a class='{ty} {class}' href='{curty, select,\n-                                mod{../}\n-                                other{}\n-                           }{tysel, select,\n-                                mod{{name}/index.html}\n-                                other{#.{name}.html}\n-                           }'>{name}</a><br/>\",\n+                let class = if cur.name.get_ref() == item &&\n+                               short == curty { \"current\" } else { \"\" };\n+                try!(write!(w, \"<a class='{ty} {class}' href='{href}{path}'>\\\n+                                {name}</a><br/>\",\n                        ty = short,\n-                       tysel = short,\n                        class = class,\n-                       curty = curty,\n+                       href = if curty == \"mod\" {\"../\"} else {\"\"},\n+                       path = if short == \"mod\" {\n+                           format!(\"{}/index.html\", item.as_slice())\n+                       } else {\n+                           format!(\"{}.{}.html\", short, item.as_slice())\n+                       },\n                        name = item.as_slice()));\n             }\n             try!(write!(w, \"</div>\"));"}, {"sha": "f8b2bd3ff9ff4cbacb9fa36c9f3027cc505b67bb", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -430,6 +430,7 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n                  _name: &str,\n                  f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult { f(self) }\n \n+    #[cfg(stage0)]\n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _id: uint,\n@@ -448,6 +449,25 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n             write!(self.wr, \"]\\\\}\")\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn emit_enum_variant(&mut self,\n+                         name: &str,\n+                         _id: uint,\n+                         cnt: uint,\n+                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+        // enums are encoded as strings or objects\n+        // Bunny => \"Bunny\"\n+        // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n+        if cnt == 0 {\n+            write!(self.wr, \"{}\", escape_str(name))\n+        } else {\n+            try!(write!(self.wr, \"{{\\\"variant\\\":\"));\n+            try!(write!(self.wr, \"{}\", escape_str(name)));\n+            try!(write!(self.wr, \",\\\"fields\\\":[\"));\n+            try!(f(self));\n+            write!(self.wr, \"]}}\")\n+        }\n+    }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n@@ -473,6 +493,7 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n+    #[cfg(stage0)]\n     fn emit_struct(&mut self,\n                    _: &str,\n                    _: uint,\n@@ -481,6 +502,15 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         try!(f(self));\n         write!(self.wr, r\"\\}\")\n     }\n+    #[cfg(not(stage0))]\n+    fn emit_struct(&mut self,\n+                   _: &str,\n+                   _: uint,\n+                   f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+        try!(write!(self.wr, \"{{\"));\n+        try!(f(self));\n+        write!(self.wr, \"}}\")\n+    }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n@@ -533,11 +563,18 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         f(self)\n     }\n \n+    #[cfg(stage0)]\n     fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         try!(write!(self.wr, r\"\\{\"));\n         try!(f(self));\n         write!(self.wr, r\"\\}\")\n     }\n+    #[cfg(not(stage0))]\n+    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+        try!(write!(self.wr, \"{{\"));\n+        try!(f(self));\n+        write!(self.wr, \"}}\")\n+    }\n \n     fn emit_map_elt_key(&mut self,\n                         idx: uint,\n@@ -670,6 +707,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n     }\n \n \n+    #[cfg(stage0)]\n     fn emit_struct(&mut self,\n                    _: &str,\n                    len: uint,\n@@ -684,6 +722,21 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent))\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn emit_struct(&mut self,\n+                   _: &str,\n+                   len: uint,\n+                   f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+        if len == 0 {\n+            write!(self.wr, \"{{}}\")\n+        } else {\n+            try!(write!(self.wr, \"{{\"));\n+            self.indent += 2;\n+            try!(f(self));\n+            self.indent -= 2;\n+            write!(self.wr, \"\\n{}}}\", spaces(self.indent))\n+        }\n+    }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n@@ -755,6 +808,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         f(self)\n     }\n \n+    #[cfg(stage0)]\n     fn emit_map(&mut self,\n                 len: uint,\n                 f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n@@ -768,6 +822,20 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent))\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn emit_map(&mut self,\n+                len: uint,\n+                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+        if len == 0 {\n+            write!(self.wr, \"{{}}\")\n+        } else {\n+            try!(write!(self.wr, \"{{\"));\n+            self.indent += 2;\n+            try!(f(self));\n+            self.indent -= 2;\n+            write!(self.wr, \"\\n{}}}\", spaces(self.indent))\n+        }\n+    }\n \n     fn emit_map_elt_key(&mut self,\n                         idx: uint,"}, {"sha": "f11e68c7a46712ed586b6710ebc4832dd4879876", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -1424,6 +1424,7 @@ impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V,\n impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {}\n \n impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n \n@@ -1434,6 +1435,17 @@ impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H>\n \n         write!(f, r\"\\}\")\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, (k, v)) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}: {}\", *k, *v));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n@@ -1617,6 +1629,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n }\n \n impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n \n@@ -1627,6 +1640,17 @@ impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n \n         write!(f, r\"\\}\")\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", *x));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {"}, {"sha": "0075a50f38974294d2226af2f6725afacc903a25", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -208,6 +208,7 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n     /// Return a string that lists the key-value pairs from most-recently\n     /// used to least-recently used.\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n         let mut cur = self.head;\n@@ -224,6 +225,25 @@ impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n         }\n         write!(f, r\"\\}\")\n     }\n+    /// Return a string that lists the key-value pairs from most-recently\n+    /// used to least-recently used.\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+        let mut cur = self.head;\n+        for i in range(0, self.len()) {\n+            if i > 0 { try!(write!(f, \", \")) }\n+            unsafe {\n+                cur = (*cur).next;\n+                try!(write!(f, \"{}\", (*cur).key));\n+            }\n+            try!(write!(f, \": \"));\n+            unsafe {\n+                try!(write!(f, \"{}\", (*cur).value));\n+            }\n+        }\n+        write!(f, r\"}}\")\n+    }\n }\n \n impl<K: Hash + Eq, V> Collection for LruCache<K, V> {"}, {"sha": "af76defc8f610c2564c9dffba858b170e7503229", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 4, "deletions": 82, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -317,76 +317,6 @@ checks provided by the compiler. The `format_args!` macro is the only method of\n safely creating these structures, but they can be unsafely created with the\n constructor provided.\n \n-## Internationalization\n-\n-The formatting syntax supported by the `format!` extension supports\n-internationalization by providing \"methods\" which execute various different\n-outputs depending on the input. The syntax and methods provided are similar to\n-other internationalization systems, so again nothing should seem alien.\n-Currently two methods are supported by this extension: \"select\" and \"plural\".\n-\n-Each method will execute one of a number of clauses, and then the value of the\n-clause will become what's the result of the argument's format. Inside of the\n-cases, nested argument strings may be provided, but all formatting arguments\n-must not be done through implicit positional means. All arguments inside of each\n-case of a method must be explicitly selected by their name or their integer\n-position.\n-\n-Furthermore, whenever a case is running, the special character `#` can be used\n-to reference the string value of the argument which was selected upon. As an\n-example:\n-\n-```rust\n-format!(\"{0, select, other{#}}\", \"hello\"); // => \"hello\"\n-```\n-\n-This example is the equivalent of `{0:s}` essentially.\n-\n-### Select\n-\n-The select method is a switch over a `&str` parameter, and the parameter *must*\n-be of the type `&str`. An example of the syntax is:\n-\n-```text\n-{0, select, male{...} female{...} other{...}}\n-```\n-\n-Breaking this down, the `0`-th argument is selected upon with the `select`\n-method, and then a number of cases follow. Each case is preceded by an\n-identifier which is the match-clause to execute the given arm. In this case,\n-there are two explicit cases, `male` and `female`. The case will be executed if\n-the string argument provided is an exact match to the case selected.\n-\n-The `other` case is also a required case for all `select` methods. This arm will\n-be executed if none of the other arms matched the word being selected over.\n-\n-### Plural\n-\n-The plural method is a switch statement over a `uint` parameter, and the\n-parameter *must* be a `uint`. A plural method in its full glory can be specified\n-as:\n-\n-```text\n-{0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n-```\n-\n-To break this down, the first `0` indicates that this method is selecting over\n-the value of the first positional parameter to the format string. Next, the\n-`plural` method is being executed. An optionally-supplied `offset` is then given\n-which indicates a number to subtract from argument `0` when matching. This is\n-then followed by a list of cases.\n-\n-Each case is allowed to supply a specific value to match upon with the syntax\n-`=N`. This case is executed if the value at argument `0` matches N exactly,\n-without taking the offset into account. A case may also be specified by one of\n-five keywords: `zero`, `one`, `two`, `few`, and `many`. These cases are matched\n-on after argument `0` has the offset taken into account. Currently the\n-definitions of `many` and `few` are hardcoded, but they are in theory defined by\n-the current locale.\n-\n-Finally, all `plural` methods must have an `other` case supplied which will be\n-executed if none of the other cases match.\n-\n ## Syntax\n \n The syntax for the formatting language used is drawn from other languages, so it\n@@ -396,7 +326,7 @@ actual grammar for the formatting syntax is:\n \n ```text\n format_string := <text> [ format <text> ] *\n-format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n+format := '{' [ argument ] [ ':' format_spec ] '}'\n argument := integer | identifier\n \n format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n@@ -408,13 +338,6 @@ precision := count | '*'\n type := identifier | ''\n count := parameter | integer\n parameter := integer '$'\n-\n-function_spec := plural | select\n-select := 'select' ',' ( identifier arm ) *\n-plural := 'plural' ',' [ 'offset:' integer ] ( selector arm ) *\n-selector := '=' integer | keyword\n-keyword := 'zero' | 'one' | 'two' | 'few' | 'many' | 'other'\n-arm := '{' format_string '}'\n ```\n \n ## Formatting Parameters\n@@ -483,10 +406,9 @@ should be printed.\n \n ## Escaping\n \n-The literal characters `{`, `}`, or `#` may be included in a string by\n-preceding them with the `\\` character. Since `\\` is already an\n-escape character in Rust strings, a string literal using this escape\n-will look like `\"\\\\{\"`.\n+The literal characters `{` and `}` may be included in a string by preceding them\n+with the same character. For example, the `{` character is escaped with `{{` and\n+the `}` character is escaped with `}}`.\n \n */\n "}, {"sha": "5a1d60192fc24afe045441c506ddfae2f83d3479", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -899,10 +899,16 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n             // \\\\?\\D:\\\n             Path::new(repr.slice_from(4))\n         }\n+        #[cfg(stage0)]\n         Some(VerbatimUNCPrefix(_,_)) => {\n             // \\\\?\\UNC\\server\\share\n             Path::new(format!(r\"\\\\{}\", repr.slice_from(7)))\n         }\n+        #[cfg(not(stage0))]\n+        Some(VerbatimUNCPrefix(_,_)) => {\n+            // \\\\?\\UNC\\server\\share\n+            Path::new(format!(r\"\\{}\", repr.slice_from(7)))\n+        }\n     };\n     if new_path.prefix.is_none() {\n         // \\\\?\\UNC\\server is a VerbatimUNCPrefix"}, {"sha": "d5e0a4e80d4480d59b2c63844ccd0f34d12989e1", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -32,6 +32,7 @@ pub struct CrateId {\n }\n \n impl fmt::Show for CrateId {\n+    #[cfg(stage0)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{}\", self.path));\n         let version = match self.version {\n@@ -47,6 +48,22 @@ impl fmt::Show for CrateId {\n             write!(f, \"\\\\#{}:{}\", self.name, version)\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{}\", self.path));\n+        let version = match self.version {\n+            None => \"0.0\",\n+            Some(ref version) => version.as_slice(),\n+        };\n+        if self.path == self.name ||\n+                self.path\n+                    .as_slice()\n+                    .ends_with(format!(\"/{}\", self.name).as_slice()) {\n+            write!(f, \"#{}\", version)\n+        } else {\n+            write!(f, \"#{}:{}\", self.name, version)\n+        }\n+    }\n }\n \n impl FromStr for CrateId {"}, {"sha": "a982e4c103458fc11c64c7d2d3bee9c79e9b226e", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -143,6 +143,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     inputs.push((constraint, input));\n                 }\n             }\n+            #[cfg(stage0)]\n             Clobbers => {\n                 let mut clobs = Vec::new();\n                 while p.token != token::EOF &&\n@@ -164,6 +165,28 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n                 cons = clobs.connect(\",\");\n             }\n+            #[cfg(not(stage0))]\n+            Clobbers => {\n+                let mut clobs = Vec::new();\n+                while p.token != token::EOF &&\n+                      p.token != token::COLON &&\n+                      p.token != token::MOD_SEP {\n+\n+                    if clobs.len() != 0 {\n+                        p.eat(&token::COMMA);\n+                    }\n+\n+                    let (s, _str_style) = p.parse_str();\n+                    let clob = format!(\"~{{{}}}\", s);\n+                    clobs.push(clob);\n+\n+                    if OPTIONS.iter().any(|opt| s.equiv(opt)) {\n+                        cx.span_warn(p.last_span, \"expected a clobber, but found an option\");\n+                    }\n+                }\n+\n+                cons = clobs.connect(\",\");\n+            }\n             Options => {\n                 let (option, _str_style) = p.parse_str();\n "}, {"sha": "8e673ff2465980eb5c345c89db2cc4e5c07f8d69", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -100,7 +100,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n             } else {\n                 // normal struct/struct variant\n \n-                format_string.push_str(\" \\\\{\");\n+                format_string.push_str(\" {{\");\n \n                 for (i, field) in fields.iter().enumerate() {\n                     if i != 0 { format_string.push_str(\",\"); }\n@@ -113,7 +113,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                     exprs.push(field.self_);\n                 }\n \n-                format_string.push_str(\" \\\\}\");\n+                format_string.push_str(\" }}\");\n             }\n         }\n         _ => unreachable!()"}, {"sha": "d3b73cbe33af60f181a9dbeb37df5f5c682f398b", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 180, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -19,7 +19,7 @@ use parse::token;\n use rsparse = parse;\n \n use parse = fmt_macros;\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::gc::Gc;\n \n #[deriving(PartialEq)]\n@@ -165,13 +165,6 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn verify_piece(&mut self, p: &parse::Piece) {\n         match *p {\n             parse::String(..) => {}\n-            parse::CurrentArgument => {\n-                if self.nest_level == 0 {\n-                    self.ecx.span_err(self.fmtsp,\n-                                      \"`#` reference used with nothing to \\\n-                                       reference back to\");\n-                }\n-            }\n             parse::Argument(ref arg) => {\n                 // width/precision first, if they have implicit positional\n                 // parameters it makes more sense to consume them first.\n@@ -192,24 +185,12 @@ impl<'a, 'b> Context<'a, 'b> {\n                     parse::ArgumentNamed(s) => Named(s.to_string()),\n                 };\n \n-                // and finally the method being applied\n-                match arg.method {\n-                    None => {\n-                        let ty = Known(arg.format.ty.to_string());\n-                        self.verify_arg_type(pos, ty);\n-                    }\n-                    Some(ref method) => { self.verify_method(pos, *method); }\n-                }\n+                let ty = Known(arg.format.ty.to_string());\n+                self.verify_arg_type(pos, ty);\n             }\n         }\n     }\n \n-    fn verify_pieces(&mut self, pieces: &[parse::Piece]) {\n-        for piece in pieces.iter() {\n-            self.verify_piece(piece);\n-        }\n-    }\n-\n     fn verify_count(&mut self, c: parse::Count) {\n         match c {\n             parse::CountImplied | parse::CountIs(..) => {}\n@@ -238,53 +219,6 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn verify_method(&mut self, pos: Position, m: &parse::Method) {\n-        self.nest_level += 1;\n-        match *m {\n-            parse::Plural(_, ref arms, ref default) => {\n-                let mut seen_cases = HashSet::new();\n-                self.verify_arg_type(pos, Unsigned);\n-                for arm in arms.iter() {\n-                    if !seen_cases.insert(arm.selector) {\n-                        match arm.selector {\n-                            parse::Keyword(name) => {\n-                                self.ecx.span_err(self.fmtsp,\n-                                                  format!(\"duplicate \\\n-                                                           selector `{}`\",\n-                                                          name).as_slice());\n-                            }\n-                            parse::Literal(idx) => {\n-                                self.ecx.span_err(self.fmtsp,\n-                                                  format!(\"duplicate \\\n-                                                           selector `={}`\",\n-                                                          idx).as_slice());\n-                            }\n-                        }\n-                    }\n-                    self.verify_pieces(arm.result.as_slice());\n-                }\n-                self.verify_pieces(default.as_slice());\n-            }\n-            parse::Select(ref arms, ref default) => {\n-                self.verify_arg_type(pos, String);\n-                let mut seen_cases = HashSet::new();\n-                for arm in arms.iter() {\n-                    if !seen_cases.insert(arm.selector) {\n-                        self.ecx.span_err(self.fmtsp,\n-                                          format!(\"duplicate selector `{}`\",\n-                                                  arm.selector).as_slice());\n-                    } else if arm.selector == \"\" {\n-                        self.ecx.span_err(self.fmtsp,\n-                                          \"empty selector in `select`\");\n-                    }\n-                    self.verify_pieces(arm.result.as_slice());\n-                }\n-                self.verify_pieces(default.as_slice());\n-            }\n-        }\n-        self.nest_level -= 1;\n-    }\n-\n     fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n         match arg {\n             Exact(arg) => {\n@@ -400,23 +334,6 @@ impl<'a, 'b> Context<'a, 'b> {\n           self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s))\n     }\n \n-    fn none(&self) -> Gc<ast::Expr> {\n-        let none = self.ecx.path_global(self.fmtsp, vec!(\n-                self.ecx.ident_of(\"std\"),\n-                self.ecx.ident_of(\"option\"),\n-                self.ecx.ident_of(\"None\")));\n-        self.ecx.expr_path(none)\n-    }\n-\n-    fn some(&self, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n-        let p = self.ecx.path_global(self.fmtsp, vec!(\n-                self.ecx.ident_of(\"std\"),\n-                self.ecx.ident_of(\"option\"),\n-                self.ecx.ident_of(\"Some\")));\n-        let p = self.ecx.expr_path(p);\n-        self.ecx.expr_call(self.fmtsp, p, vec!(e))\n-    }\n-\n     fn trans_count(&self, c: parse::Count) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n         match c {\n@@ -448,86 +365,6 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn trans_method(&mut self, method: &parse::Method) -> Gc<ast::Expr> {\n-        let sp = self.fmtsp;\n-        let method = match *method {\n-            parse::Select(ref arms, ref default) => {\n-                let arms = arms.iter().map(|arm| {\n-                        let p = self.ecx.path_global(sp, self.rtpath(\"SelectArm\"));\n-                        let result = arm.result.iter().map(|p| {\n-                            self.trans_piece(p)\n-                        }).collect();\n-                        let s = token::intern_and_get_ident(arm.selector);\n-                        let selector = self.ecx.expr_str(sp, s);\n-                        self.ecx.expr_struct(sp, p, vec!(\n-                                self.ecx.field_imm(sp,\n-                                                   self.ecx.ident_of(\"selector\"),\n-                                                   selector),\n-                                self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n-                                                   self.ecx.expr_vec_slice(sp, result))))\n-                    }).collect();\n-                let default = default.iter().map(|p| {\n-                        self.trans_piece(p)\n-                    }).collect();\n-                self.ecx.expr_call_global(sp, self.rtpath(\"Select\"), vec!(\n-                        self.ecx.expr_vec_slice(sp, arms),\n-                        self.ecx.expr_vec_slice(sp, default)))\n-            }\n-            parse::Plural(offset, ref arms, ref default) => {\n-                let offset = match offset {\n-                    Some(i) => { self.some(self.ecx.expr_uint(sp, i)) }\n-                    None => { self.none() }\n-                };\n-                let arms = arms.iter().map(|arm| {\n-                        let p = self.ecx.path_global(sp, self.rtpath(\"PluralArm\"));\n-                        let result = arm.result.iter().map(|p| {\n-                                self.trans_piece(p)\n-                            }).collect();\n-                        let (lr, selarg) = match arm.selector {\n-                            parse::Keyword(t) => {\n-                                let p = self.rtpath(t.to_str().as_slice());\n-                                let p = self.ecx.path_global(sp, p);\n-                                (self.rtpath(\"Keyword\"), self.ecx.expr_path(p))\n-                            }\n-                            parse::Literal(i) => {\n-                                (self.rtpath(\"Literal\"), self.ecx.expr_uint(sp, i))\n-                            }\n-                        };\n-                        let selector = self.ecx.expr_call_global(sp,\n-                                                                 lr, vec!(selarg));\n-                        self.ecx.expr_struct(sp, p, vec!(\n-                                self.ecx.field_imm(sp,\n-                                                   self.ecx.ident_of(\"selector\"),\n-                                                   selector),\n-                                self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n-                                                   self.ecx.expr_vec_slice(sp, result))))\n-                    }).collect();\n-                let default = default.iter().map(|p| {\n-                        self.trans_piece(p)\n-                    }).collect();\n-                self.ecx.expr_call_global(sp, self.rtpath(\"Plural\"), vec!(\n-                        offset,\n-                        self.ecx.expr_vec_slice(sp, arms),\n-                        self.ecx.expr_vec_slice(sp, default)))\n-            }\n-        };\n-        let life = self.ecx.lifetime(sp, self.ecx.ident_of(\"static\").name);\n-        let ty = self.ecx.ty_path(self.ecx.path_all(\n-                sp,\n-                true,\n-                self.rtpath(\"Method\"),\n-                vec!(life),\n-                Vec::new()\n-                    ), None);\n-        let st = ast::ItemStatic(ty, ast::MutImmutable, method);\n-        let static_name = self.ecx.ident_of(format!(\"__STATIC_METHOD_{}\",\n-                                                    self.method_statics\n-                                                        .len()).as_slice());\n-        let item = self.ecx.item(sp, static_name, self.static_attrs(), st);\n-        self.method_statics.push(item);\n-        self.ecx.expr_ident(sp, static_name)\n-    }\n-\n     /// Translate a `parse::Piece` to a static `rt::Piece`\n     fn trans_piece(&mut self, piece: &parse::Piece) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n@@ -540,10 +377,6 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.ecx.expr_str(sp, s)\n                 ))\n             }\n-            parse::CurrentArgument => {\n-                let nil = self.ecx.expr_lit(sp, ast::LitNil);\n-                self.ecx.expr_call_global(sp, self.rtpath(\"CurrentArgument\"), vec!(nil))\n-            }\n             parse::Argument(ref arg) => {\n                 // Translate the position\n                 let pos = match arg.position {\n@@ -596,19 +429,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width)));\n \n-                // Translate the method (if any)\n-                let method = match arg.method {\n-                    None => { self.none() }\n-                    Some(ref m) => {\n-                        let m = self.trans_method(*m);\n-                        self.some(self.ecx.expr_addr_of(sp, m))\n-                    }\n-                };\n                 let path = self.ecx.path_global(sp, self.rtpath(\"Argument\"));\n                 let s = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"method\"), method)));\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt)));\n                 self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), vec!(s))\n             }\n         }"}, {"sha": "c4990255719f304f564faf9073520b591e2c96b8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -129,11 +129,13 @@ fn generic_extension(cx: &ExtCtxt,\n                      rhses: &[Rc<NamedMatch>])\n                      -> Box<MacResult> {\n     if cx.trace_macros() {\n-        println!(\"{}! \\\\{ {} \\\\}\",\n+        println!(\"{}! {} {} {}\",\n                  token::get_ident(name),\n+                 \"{\",\n                  print::pprust::tt_to_str(&TTDelim(Rc::new(arg.iter()\n                                                               .map(|x| (*x).clone())\n-                                                              .collect()))));\n+                                                              .collect()))),\n+                 \"}\");\n     }\n \n     // Which arm's failure should we report? (the one furthest along)"}, {"sha": "112cdb26131d22077b07093b7f528601dfea6c1c", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -89,11 +89,18 @@ impl<'a> ParserAttr for Parser<'a> {\n                 let hi = self.span.hi;\n                 (mk_sp(lo, hi), meta_item, style)\n             }\n+            #[cfg(stage0)]\n             _ => {\n                 let token_str = self.this_token_to_str();\n                 self.fatal(format!(\"expected `\\\\#` but found `{}`\",\n                                    token_str).as_slice());\n             }\n+            #[cfg(not(stage0))]\n+            _ => {\n+                let token_str = self.this_token_to_str();\n+                self.fatal(format!(\"expected `#` but found `{}`\",\n+                                   token_str).as_slice());\n+            }\n         };\n \n         if permit_inner && self.eat(&token::SEMI) {"}, {"sha": "282f4065e4ff125fc5043140b18285364dfbe693", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -1208,11 +1208,18 @@ impl<'a> Parser<'a> {\n                 })\n               }\n \n+              #[cfg(stage0)]\n               _ => {\n                   let token_str = p.this_token_to_str();\n                   p.fatal((format!(\"expected `;` or `\\\\{` but found `{}`\",\n                                    token_str)).as_slice())\n               }\n+              #[cfg(not(stage0))]\n+              _ => {\n+                  let token_str = p.this_token_to_str();\n+                  p.fatal((format!(\"expected `;` or `{{` but found `{}`\",\n+                                   token_str)).as_slice())\n+              }\n             }\n         })\n     }\n@@ -2738,7 +2745,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 if self.token != token::RBRACE {\n                     let token_str = self.this_token_to_str();\n-                    self.fatal(format!(\"expected `\\\\}`, found `{}`\",\n+                    self.fatal(format!(\"expected `{}`, found `{}`\", \"}\",\n                                        token_str).as_slice())\n                 }\n                 etc = true;\n@@ -3148,6 +3155,7 @@ impl<'a> Parser<'a> {\n             // consuming more tokens).\n             let (bra, ket) = match token::close_delimiter_for(&self.token) {\n                 Some(ket) => (self.token.clone(), ket),\n+                #[cfg(stage0)]\n                 None      => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n@@ -3161,6 +3169,20 @@ impl<'a> Parser<'a> {\n                                        ident_str,\n                                        tok_str).as_slice())\n                 }\n+                #[cfg(not(stage0))]\n+                None      => {\n+                    // we only expect an ident if we didn't parse one\n+                    // above.\n+                    let ident_str = if id == token::special_idents::invalid {\n+                        \"identifier, \"\n+                    } else {\n+                        \"\"\n+                    };\n+                    let tok_str = self.this_token_to_str();\n+                    self.fatal(format!(\"expected {}`(` or `{{`, but found `{}`\",\n+                                       ident_str,\n+                                       tok_str).as_slice())\n+                }\n             };\n \n             let tts = self.parse_unspanned_seq(\n@@ -4040,8 +4062,8 @@ impl<'a> Parser<'a> {\n             fields = Vec::new();\n         } else {\n             let token_str = self.this_token_to_str();\n-            self.fatal(format!(\"expected `\\\\{`, `(`, or `;` after struct \\\n-                                name but found `{}`\",\n+            self.fatal(format!(\"expected `{}`, `(`, or `;` after struct \\\n+                                name but found `{}`\", \"{\",\n                                token_str).as_slice())\n         }\n \n@@ -4068,12 +4090,20 @@ impl<'a> Parser<'a> {\n                 self.bump();\n             }\n             token::RBRACE => {}\n+            #[cfg(stage0)]\n             _ => {\n                 let token_str = self.this_token_to_str();\n                 self.span_fatal(self.span,\n                                 format!(\"expected `,`, or `\\\\}` but found `{}`\",\n                                         token_str).as_slice())\n             }\n+            #[cfg(not(stage0))]\n+            _ => {\n+                let token_str = self.this_token_to_str();\n+                self.span_fatal(self.span,\n+                                format!(\"expected `,`, or `}}` but found `{}`\",\n+                                        token_str).as_slice())\n+            }\n         }\n         a_var\n     }\n@@ -4683,7 +4713,7 @@ impl<'a> Parser<'a> {\n \n             let token_str = self.this_token_to_str();\n             self.span_fatal(self.span,\n-                            format!(\"expected `\\\\{` or `fn` but found `{}`\",\n+                            format!(\"expected `{}` or `fn` but found `{}`\", \"{\",\n                                     token_str).as_slice());\n         }\n "}, {"sha": "de70ac6f592b910b71ae53d397e860397e32c8e0", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -645,15 +645,15 @@ mod test {\n     fn test_comparison_ops() {\n         let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n         for &(op, bs) in v.iter() {\n-            let s = format!(\"%\\\\{1\\\\}%\\\\{2\\\\}%{}%d\", op);\n+            let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), vec!('0' as u8 + bs[0]));\n-            let s = format!(\"%\\\\{1\\\\}%\\\\{1\\\\}%{}%d\", op);\n+            let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), vec!('0' as u8 + bs[1]));\n-            let s = format!(\"%\\\\{2\\\\}%\\\\{1\\\\}%{}%d\", op);\n+            let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), vec!('0' as u8 + bs[2]));"}, {"sha": "d07e5662feb1c52582185b7db59c82c1a2680024", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -416,7 +416,7 @@ pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n         v = v + char_step;\n         c += 1;\n     }\n-    try!(write!(w, r\"\\#\"));\n+    try!(write!(w, \"#\"));\n     c += 1;\n     while c < range_width && v < q3 {\n         try!(write!(w, \"*\"));"}, {"sha": "a3329a90e9b227c7cfa109bc4bb031f76f435134", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -845,7 +845,7 @@ impl fmt::Show for Url {\n \n         match self.fragment {\n             Some(ref fragment) => {\n-                write!(f, \"\\\\#{}\", encode_component(fragment.as_slice()))\n+                write!(f, \"#{}\", encode_component(fragment.as_slice()))\n             }\n             None => Ok(()),\n         }\n@@ -861,7 +861,7 @@ impl fmt::Show for Path {\n \n         match self.fragment {\n             Some(ref fragment) => {\n-                write!(f, \"\\\\#{}\", encode_component(fragment.as_slice()))\n+                write!(f, \"#{}\", encode_component(fragment.as_slice()))\n             }\n             None => Ok(())\n         }"}, {"sha": "84735ec78ce7ed1da161d8e845c034ac011a76c8", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -27,47 +27,11 @@ fn main() {\n     format!(\"{foo:d} {foo:s}\", foo=1); //~ ERROR: redeclared with type `s`\n \n     format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n-    format!(\"#\");                      //~ ERROR: `#` reference used\n     format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n \n-    format!(\"{0, select, a{} a{} other{}}\", \"a\");    //~ ERROR: duplicate selector\n-    format!(\"{0, plural, =1{} =1{} other{}}\", 1u);   //~ ERROR: duplicate selector\n-    format!(\"{0, plural, one{} one{} other{}}\", 1u); //~ ERROR: duplicate selector\n-\n     // bad syntax of the format string\n \n     format!(\"{\"); //~ ERROR: expected `}` but string was terminated\n-    format!(\"\\\\ \"); //~ ERROR: invalid escape\n-    format!(\"\\\\\"); //~ ERROR: expected an escape\n-\n-    format!(\"{0, }\", 1); //~ ERROR: expected method\n-    format!(\"{0, foo}\", 1); //~ ERROR: unknown method\n-    format!(\"{0, select}\", \"a\"); //~ ERROR: expected `,` but found `}`\n-    format!(\"{0, plural}\", 1); //~ ERROR: expected `,` but found `}`\n-\n-    format!(\"{0, select, a{{}\", 1); //~ ERROR: expected `}` but string was terminated\n-    format!(\"{0, select, {} other{}}\", \"a\"); //~ ERROR: empty selector\n-    format!(\"{0, select, other{} other{}}\", \"a\"); //~ ERROR: multiple `other`\n-    format!(\"{0, plural, offset: other{}}\", \"a\"); //~ ERROR: must be an integer\n-    format!(\"{0, plural, offset 1 other{}}\", \"a\"); //~ ERROR: expected `:` but found `1`\n-    format!(\"{0, plural, =a{} other{}}\", \"a\"); //~ ERROR: followed by an integer\n-    format!(\"{0, plural, a{} other{}}\", \"a\"); //~ ERROR: unexpected plural\n-    format!(\"{0, select, a{}}\", \"a\"); //~ ERROR: must provide an `other`\n-    format!(\"{0, plural, =1{}}\", \"a\"); //~ ERROR: must provide an `other`\n-\n-    format!(\"{0, plural, other{{0:s}}}\", \"a\"); //~ ERROR: previously used as\n-    format!(\"{:s} {0, plural, other{}}\", \"a\"); //~ ERROR: argument used to\n-    format!(\"{0, select, other{}} \\\n-             {0, plural, other{}}\", \"a\");\n-    //~^ ERROR: declared with multiple formats\n-\n-    // It should be illegal to use implicit placement arguments nested inside of\n-    // format strings because otherwise the \"internal pointer of which argument\n-    // is next\" would be invalidated if different cases had different numbers of\n-    // arguments.\n-    format!(\"{1, select, other{{}}}\", 1, \"a\"); //~ ERROR: cannot use implicit\n-    format!(\"{1, plural, other{{}}}\", 1, 1); //~ ERROR: cannot use implicit\n-    format!(\"{0, plural, other{{1:.*d}}}\", 1, 2); //~ ERROR: cannot use implicit\n \n     format!(\"foo } bar\"); //~ ERROR: unmatched `}` found\n     format!(\"foo }\"); //~ ERROR: unmatched `}` found"}, {"sha": "21c2d4b5934df5e950506145b4d4fb6b0b1fb027", "filename": "src/test/compile-fail/ifmt-bad-plural.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9260d41d6e37653bf71b08a041be0310098716a/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9260d41d6e37653bf71b08a041be0310098716a/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs?ref=f9260d41d6e37653bf71b08a041be0310098716a", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    format!(\"{0, plural, other{}}\", \"a\");\n-    //~^ ERROR: expected uint but found\n-}"}, {"sha": "273b58be653dde2ae1b676b3ce127656311217c2", "filename": "src/test/compile-fail/ifmt-bad-select.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9260d41d6e37653bf71b08a041be0310098716a/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9260d41d6e37653bf71b08a041be0310098716a/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs?ref=f9260d41d6e37653bf71b08a041be0310098716a", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    format!(\"{0, select, other{}}\", 2);\n-    //~^ ERROR: mismatched types: expected `&&str` but found `&<generic integer #0>` (expected &-ptr\n-}"}, {"sha": "f957fbae65ca065b3ae97afbca608a56f39e8044", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -42,7 +42,7 @@ fn main() {\n \n         {\n             let _ = write!(&mut File::create(&main_file).unwrap(),\n-                           r\"\\#![feature(non_ascii_idents)] fn main() \\{ {} \\}\",\n+                           \"#![feature(non_ascii_idents)] fn main() {{ {} }}\",\n                            // random string of length n\n                            range(0, n).map(|_| random_char()).collect::<String>());\n         }"}, {"sha": "113f13dc4bf4092d79ccf8bc8c91006224afd8be", "filename": "src/test/run-pass/const-region-ptrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -16,7 +16,7 @@ static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n \n pub fn main() {\n     println!(\"x = {}\", *x);\n-    println!(\"y = \\\\{a: {}, b: {}\\\\}\", y.a, *(y.b));\n+    println!(\"y = {{a: {}, b: {}}}\", y.a, *(y.b));\n     assert_eq!(*x, 10);\n     assert_eq!(*(y.b), 10);\n }"}, {"sha": "484b93ba098440a9f27d732c7c352d82c9a458f5", "filename": "src/test/run-pass/format-no-uppercase-statics.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9260d41d6e37653bf71b08a041be0310098716a/src%2Ftest%2Frun-pass%2Fformat-no-uppercase-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9260d41d6e37653bf71b08a041be0310098716a/src%2Ftest%2Frun-pass%2Fformat-no-uppercase-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fformat-no-uppercase-statics.rs?ref=f9260d41d6e37653bf71b08a041be0310098716a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![deny(non_uppercase_statics)]\n-\n-pub fn main() {\n-    println!(\"I generate statics with {0, select, other{#}}\", \"weird names\");\n-}"}, {"sha": "bf108dbe4d886b30a3a3fac9a83608c7950343d6", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -48,7 +48,7 @@ pub fn main() {\n     // Various edge cases without formats\n     t!(format!(\"\"), \"\");\n     t!(format!(\"hello\"), \"hello\");\n-    t!(format!(\"hello \\\\{\"), \"hello {\");\n+    t!(format!(\"hello {{\"), \"hello {\");\n \n     // default formatters should work\n     t!(format!(\"{}\", 1.0f32), \"1\");\n@@ -81,18 +81,6 @@ pub fn main() {\n     t!(format!(\"{foo_bar}\", foo_bar=1), \"1\");\n     t!(format!(\"{:d}\", 5 + 5), \"10\");\n \n-    // Methods should probably work\n-    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n-    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n-    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n-    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n-    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n-    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n-    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n-    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n-    t!(format!(\"{1, select, a{#{0:s}} other{#}}\", \"b\", \"a\"), \"ab\");\n-    t!(format!(\"{1, select, a{#{0}} other{#}}\", \"c\", \"b\"), \"b\");\n-\n     // Formatting strings and their arguments\n     t!(format!(\"{:s}\", \"a\"), \"a\");\n     t!(format!(\"{:4s}\", \"a\"), \"a   \");\n@@ -136,10 +124,8 @@ pub fn main() {\n     t!(format!(\"{:+10.3e}\", -1.2345e6f64), \"  -1.234e6\");\n \n     // Escaping\n-    t!(format!(\"\\\\{\"), \"{\");\n-    t!(format!(\"\\\\}\"), \"}\");\n-    t!(format!(\"\\\\#\"), \"#\");\n-    t!(format!(\"\\\\\\\\\"), \"\\\\\");\n+    t!(format!(\"{{\"), \"{\");\n+    t!(format!(\"}}\"), \"}\");\n \n     test_write();\n     test_print();"}, {"sha": "9fd6e9616757edbcc5a17b68fc5ae25c53a072f4", "filename": "src/test/run-pass/new-impl-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50", "patch": "@@ -17,7 +17,7 @@ struct Thingy {\n \n impl fmt::Show for Thingy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"\\\\{ x: {}, y: {} \\\\}\", self.x, self.y)\n+        write!(f, \"{{ x: {}, y: {} }}\", self.x, self.y)\n     }\n }\n "}, {"sha": "da0c9eed9e6e86ddaebfec10bf08a648cd692134", "filename": "src/test/run-pass/raw-str.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-pass%2Fraw-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac7a2053aba7be214d5e58e13867089638a8f50/src%2Ftest%2Frun-pass%2Fraw-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fraw-str.rs?ref=cac7a2053aba7be214d5e58e13867089638a8f50"}]}