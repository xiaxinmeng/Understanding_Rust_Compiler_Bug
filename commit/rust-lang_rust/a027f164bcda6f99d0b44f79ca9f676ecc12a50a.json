{"sha": "a027f164bcda6f99d0b44f79ca9f676ecc12a50a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMjdmMTY0YmNkYTZmOTlkMGI0NGY3OWNhOWY2NzZlY2MxMmE1MGE=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-08-30T06:45:06Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-10-29T16:09:20Z"}, "message": "Check repr attribute consistency at check time, not translation.\n\nNote that raising an error during trans doesn't stop the compile or cause\nrustc to exit with a failure status, currently, so this is of more than\ncosmetic importance.", "tree": {"sha": "c628b9523625e777cc47a13246ac50e38ad8ad58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c628b9523625e777cc47a13246ac50e38ad8ad58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a027f164bcda6f99d0b44f79ca9f676ecc12a50a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a027f164bcda6f99d0b44f79ca9f676ecc12a50a", "html_url": "https://github.com/rust-lang/rust/commit/a027f164bcda6f99d0b44f79ca9f676ecc12a50a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a027f164bcda6f99d0b44f79ca9f676ecc12a50a/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8c08763ec12b0e693f400390957249c1f6583b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c08763ec12b0e693f400390957249c1f6583b9", "html_url": "https://github.com/rust-lang/rust/commit/c8c08763ec12b0e693f400390957249c1f6583b9"}], "stats": {"total": 80, "additions": 64, "deletions": 16}, "files": [{"sha": "687af6e6c8c97305f965157f30df60cab1ad8096", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a027f164bcda6f99d0b44f79ca9f676ecc12a50a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a027f164bcda6f99d0b44f79ca9f676ecc12a50a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=a027f164bcda6f99d0b44f79ca9f676ecc12a50a", "patch": "@@ -150,6 +150,8 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n \n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n+                // (Typechecking will reject discriminant-sizing attrs.)\n+                assert_eq!(hint, attr::ReprAny);\n                 return Univariant(mk_struct(cx, [], false), false);\n             }\n \n@@ -165,13 +167,6 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n                 return mk_cenum(cx, hint, &bounds);\n             }\n \n-            if cases.len() == 1 {\n-                // Equivalent to a struct/tuple/newtype.\n-                // FIXME: should this conflict with a discriminant size hint?\n-                assert_eq!(cases[0].discr, 0);\n-                return Univariant(mk_struct(cx, cases[0].tys, false), false)\n-            }\n-\n             // Since there's at least one\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n@@ -181,8 +176,15 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n                                  ty::item_path_str(cx.tcx, def_id)))\n             }\n \n-            if cases.len() == 2 {\n-                // FIXME: disable if size hint present?\n+            if cases.len() == 1 {\n+                // Equivalent to a struct/tuple/newtype.\n+                // (Typechecking will reject discriminant-sizing attrs.)\n+                assert_eq!(hint, attr::ReprAny);\n+                return Univariant(mk_struct(cx, cases[0].tys, false), false)\n+            }\n+\n+            if cases.len() == 2 && hint == attr::ReprAny {\n+                // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx) {\n@@ -205,7 +207,6 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             }\n \n             // The general case.\n-            let hint = ty::lookup_repr_hint(cx.tcx, def_id);\n             assert!((cases.len() - 1) as i64 >= 0);\n             let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n@@ -307,7 +308,7 @@ fn range_to_inttype(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> In\n     match hint {\n         attr::ReprInt(span, ity) => {\n             if !bounds_usable(cx, ity, bounds) {\n-                cx.sess.span_err(span, \"representation hint insufficient for discriminant range\")\n+                cx.sess.span_bug(span, \"representation hint insufficient for discriminant range\")\n             }\n             return ity;\n         }\n@@ -365,6 +366,7 @@ fn ty_of_inttype(ity: IntType) -> ty::t {\n     }\n }\n \n+\n /**\n  * Returns the fields of a struct for the given representation.\n  * All nominal types are LLVM structs, in order to be able to use"}, {"sha": "15660618f8e149c2f39b1d95f58a022328b9ff1e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a027f164bcda6f99d0b44f79ca9f676ecc12a50a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a027f164bcda6f99d0b44f79ca9f676ecc12a50a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a027f164bcda6f99d0b44f79ca9f676ecc12a50a", "patch": "@@ -121,6 +121,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n use syntax::ast_util;\n+use syntax::attr;\n use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::opt_vec::OptVec;\n@@ -3159,9 +3160,38 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                            sp: Span,\n                            vs: &[ast::variant],\n                            id: ast::NodeId) {\n+\n+    fn disr_in_range(ccx: @mut CrateCtxt,\n+                     ty: attr::IntType,\n+                     disr: ty::Disr) -> bool {\n+        fn uint_in_range(ccx: @mut CrateCtxt, ty: ast::uint_ty, disr: ty::Disr) -> bool {\n+            match ty {\n+                ast::ty_u8 => disr as u8 as Disr == disr,\n+                ast::ty_u16 => disr as u16 as Disr == disr,\n+                ast::ty_u32 => disr as u32 as Disr == disr,\n+                ast::ty_u64 => disr as u64 as Disr == disr,\n+                ast::ty_u => uint_in_range(ccx, ccx.tcx.sess.targ_cfg.uint_type, disr)\n+            }\n+        }\n+        fn int_in_range(ccx: @mut CrateCtxt, ty: ast::int_ty, disr: ty::Disr) -> bool {\n+            match ty {\n+                ast::ty_i8 => disr as i8 as Disr == disr,\n+                ast::ty_i16 => disr as i16 as Disr == disr,\n+                ast::ty_i32 => disr as i32 as Disr == disr,\n+                ast::ty_i64 => disr as i64 as Disr == disr,\n+                ast::ty_i => int_in_range(ccx, ccx.tcx.sess.targ_cfg.int_type, disr)\n+            }\n+        }\n+        match ty {\n+            attr::UnsignedInt(ty) => uint_in_range(ccx, ty, disr),\n+            attr::SignedInt(ty) => int_in_range(ccx, ty, disr)\n+        }\n+    }\n+\n     fn do_check(ccx: @mut CrateCtxt,\n                 vs: &[ast::variant],\n-                id: ast::NodeId)\n+                id: ast::NodeId,\n+                hint: attr::ReprAttr)\n                 -> ~[@ty::VariantInfo] {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n@@ -3203,9 +3233,20 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                 None => ()\n             };\n \n-            // Check for duplicate discriminator values\n+            // Check for duplicate discriminant values\n             if disr_vals.contains(&current_disr_val) {\n-                ccx.tcx.sess.span_err(v.span, \"discriminator value already exists\");\n+                ccx.tcx.sess.span_err(v.span, \"discriminant value already exists\");\n+            }\n+            // Check for unrepresentable discriminant values\n+            match hint {\n+                attr::ReprAny | attr::ReprExtern => (),\n+                attr::ReprInt(sp, ity) => {\n+                    if !disr_in_range(ccx, ity, current_disr_val) {\n+                        ccx.tcx.sess.span_err(v.span,\n+                                              \"discriminant value outside specified type\");\n+                        ccx.tcx.sess.span_note(sp, \"discriminant type specified here\");\n+                    }\n+                }\n             }\n             disr_vals.push(current_disr_val);\n \n@@ -3219,8 +3260,13 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     }\n \n     let rty = ty::node_id_to_type(ccx.tcx, id);\n+    let hint = ty::lookup_repr_hint(ccx.tcx, ast::DefId { crate: ast::LOCAL_CRATE, node: id });\n+    if hint != attr::ReprAny && vs.len() <= 1 {\n+        ccx.tcx.sess.span_err(sp, format!(\"unsupported representation for {}variant enum\",\n+                                          if vs.len() == 1 { \"uni\" } else { \"zero-\" }))\n+    }\n \n-    let variants = do_check(ccx, vs, id);\n+    let variants = do_check(ccx, vs, id, hint);\n \n     // cache so that ty::enum_variants won't repeat this work\n     ccx.tcx.enum_var_cache.insert(local_def(id), @variants);"}, {"sha": "d0608ec4c19273db2eab7f7c85ad94260e77b03d", "filename": "src/test/compile-fail/tag-variant-disr-dup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a027f164bcda6f99d0b44f79ca9f676ecc12a50a/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a027f164bcda6f99d0b44f79ca9f676ecc12a50a/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs?ref=a027f164bcda6f99d0b44f79ca9f676ecc12a50a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//error-pattern:discriminator value already exists\n+//error-pattern:discriminant value already exists\n \n // black and white have the same discriminator value ...\n "}]}