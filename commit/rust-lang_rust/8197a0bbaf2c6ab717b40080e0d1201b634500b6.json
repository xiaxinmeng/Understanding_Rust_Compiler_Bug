{"sha": "8197a0bbaf2c6ab717b40080e0d1201b634500b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxOTdhMGJiYWYyYzZhYjcxN2I0MDA4MGUwZDEyMDFiNjM0NTAwYjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-10-20T01:44:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-10-21T20:02:34Z"}, "message": "rustc: Move bytecode compression into codegen\n\nThis commit moves compression of the bytecode from the `link` module to the\n`write` module, namely allowing it to be (a) cached by incremental compilation\nand (b) produced in parallel. The parallelization may show up as some nice wins\nduring normal compilation and the caching in incremental mode should be\nbeneficial for incremental compiles! (no more need to recompress the entire\ncrate's bitcode on all builds)", "tree": {"sha": "7805ffa566494649a23c099633986d21325373e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7805ffa566494649a23c099633986d21325373e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8197a0bbaf2c6ab717b40080e0d1201b634500b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8197a0bbaf2c6ab717b40080e0d1201b634500b6", "html_url": "https://github.com/rust-lang/rust/commit/8197a0bbaf2c6ab717b40080e0d1201b634500b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8197a0bbaf2c6ab717b40080e0d1201b634500b6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff8773d7be45699fe1aa847b83d096e1c00a516b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff8773d7be45699fe1aa847b83d096e1c00a516b", "html_url": "https://github.com/rust-lang/rust/commit/ff8773d7be45699fe1aa847b83d096e1c00a516b"}], "stats": {"total": 368, "additions": 193, "deletions": 175}, "files": [{"sha": "0fdb6dc068dd985f9fb143b5f1a228a391bb9e74", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=8197a0bbaf2c6ab717b40080e0d1201b634500b6", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHashingContextProvider};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::env;\n use std::hash::Hash;\n@@ -647,7 +646,14 @@ impl DepGraph {\n pub struct WorkProduct {\n     pub cgu_name: String,\n     /// Saved files associated with this CGU\n-    pub saved_files: Vec<(OutputType, String)>,\n+    pub saved_files: Vec<(WorkProductFileKind, String)>,\n+}\n+\n+#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable)]\n+pub enum WorkProductFileKind {\n+    Object,\n+    Bytecode,\n+    BytecodeCompressed,\n }\n \n pub(super) struct CurrentDepGraph {"}, {"sha": "fe0212423f6efcd0d5ce95ac390cd96bb0cd309c", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=8197a0bbaf2c6ab717b40080e0d1201b634500b6", "patch": "@@ -21,6 +21,7 @@ mod serialized;\n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, label_strs};\n pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor};\n+pub use self::graph::WorkProductFileKind;\n pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;"}, {"sha": "f23b8dc85b8bb6de03439f2363cd9abbd899d24d", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=8197a0bbaf2c6ab717b40080e0d1201b634500b6", "patch": "@@ -11,29 +11,33 @@\n //! This module contains files for saving intermediate work-products.\n \n use persist::fs::*;\n-use rustc::dep_graph::{WorkProduct, WorkProductId, DepGraph};\n+use rustc::dep_graph::{WorkProduct, WorkProductId, DepGraph, WorkProductFileKind};\n use rustc::session::Session;\n-use rustc::session::config::OutputType;\n use rustc::util::fs::link_or_copy;\n use std::path::PathBuf;\n use std::fs as std_fs;\n \n pub fn save_trans_partition(sess: &Session,\n                             dep_graph: &DepGraph,\n                             cgu_name: &str,\n-                            files: &[(OutputType, PathBuf)]) {\n+                            files: &[(WorkProductFileKind, PathBuf)]) {\n     debug!(\"save_trans_partition({:?},{:?})\",\n            cgu_name,\n            files);\n     if sess.opts.incremental.is_none() {\n-        return;\n+        return\n     }\n     let work_product_id = WorkProductId::from_cgu_name(cgu_name);\n \n     let saved_files: Option<Vec<_>> =\n         files.iter()\n              .map(|&(kind, ref path)| {\n-                 let file_name = format!(\"cgu-{}.{}\", cgu_name, kind.extension());\n+                 let extension = match kind {\n+                     WorkProductFileKind::Object => \"o\",\n+                     WorkProductFileKind::Bytecode => \"bc\",\n+                     WorkProductFileKind::BytecodeCompressed => \"bc-compressed\",\n+                 };\n+                 let file_name = format!(\"cgu-{}.{}\", cgu_name, extension);\n                  let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n                  match link_or_copy(path, &path_in_incr_dir) {\n                      Ok(_) => Some((kind, file_name)),"}, {"sha": "b203bd640cf1467fb79441dcdb83e146b7b06c1f", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 45, "deletions": 93, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=8197a0bbaf2c6ab717b40080e0d1201b634500b6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::archive::{ArchiveBuilder, ArchiveConfig};\n-use super::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n+use super::bytecode::RLIB_BYTECODE_EXTENSION;\n use super::linker::Linker;\n use super::command::Command;\n use super::rpath::RPathConfig;\n@@ -37,7 +37,7 @@ use std::env;\n use std::ffi::OsString;\n use std::fmt;\n use std::fs::{self, File};\n-use std::io::{self, Read, Write, BufWriter};\n+use std::io::{self, Write, BufWriter};\n use std::path::{Path, PathBuf};\n use std::process::{Output, Stdio};\n use std::str;\n@@ -126,14 +126,6 @@ fn command_path(sess: &Session) -> OsString {\n     env::join_paths(new_path).unwrap()\n }\n \n-fn metadata_obj(outputs: &OutputFilenames) -> PathBuf {\n-    outputs.temp_path(OutputType::Object, Some(METADATA_MODULE_NAME))\n-}\n-\n-fn allocator_obj(outputs: &OutputFilenames) -> PathBuf {\n-    outputs.temp_path(OutputType::Object, Some(ALLOCATOR_MODULE_NAME))\n-}\n-\n pub fn remove(sess: &Session, path: &Path) {\n     match fs::remove_file(path) {\n         Ok(..) => {}\n@@ -175,13 +167,23 @@ pub fn link_binary(sess: &Session,\n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n         if sess.opts.output_types.should_trans() {\n-            for obj in trans.modules.iter() {\n-                remove(sess, &obj.object);\n+            for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+                remove(sess, obj);\n             }\n         }\n-        remove(sess, &metadata_obj(outputs));\n-        if trans.allocator_module.is_some() {\n-            remove(sess, &allocator_obj(outputs));\n+        for obj in trans.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n+            remove(sess, obj);\n+        }\n+        if let Some(ref obj) = trans.metadata_module.object {\n+            remove(sess, obj);\n+        }\n+        if let Some(ref allocator) = trans.allocator_module {\n+            if let Some(ref obj) = allocator.object {\n+                remove(sess, obj);\n+            }\n+            if let Some(ref bc) = allocator.bytecode_compressed {\n+                remove(sess, bc);\n+            }\n         }\n     }\n \n@@ -256,8 +258,8 @@ fn link_binary_output(sess: &Session,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n                       crate_name: &str) -> Vec<PathBuf> {\n-    for module in trans.modules.iter() {\n-        check_file_is_writeable(&module.object, sess);\n+    for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        check_file_is_writeable(obj, sess);\n     }\n \n     let tmpdir = match TempDir::new(\"rustc\") {\n@@ -280,20 +282,14 @@ fn link_binary_output(sess: &Session,\n                 link_rlib(sess,\n                           trans,\n                           RlibFlavor::Normal,\n-                          outputs,\n                           &out_filename,\n                           tmpdir.path()).build();\n             }\n             config::CrateTypeStaticlib => {\n-                link_staticlib(sess,\n-                               trans,\n-                               outputs,\n-                               &out_filename,\n-                               tmpdir.path());\n+                link_staticlib(sess, trans, &out_filename, tmpdir.path());\n             }\n             _ => {\n-                link_natively(sess, crate_type, &out_filename,\n-                              trans, outputs, tmpdir.path());\n+                link_natively(sess, crate_type, &out_filename, trans, tmpdir.path());\n             }\n         }\n         out_filenames.push(out_filename);\n@@ -349,14 +345,13 @@ enum RlibFlavor {\n fn link_rlib<'a>(sess: &'a Session,\n                  trans: &CrateTranslation,\n                  flavor: RlibFlavor,\n-                 outputs: &OutputFilenames,\n                  out_filename: &Path,\n                  tmpdir: &Path) -> ArchiveBuilder<'a> {\n     info!(\"preparing rlib to {:?}\", out_filename);\n     let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n \n-    for module in trans.modules.iter() {\n-        ab.add_file(&module.object);\n+    for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        ab.add_file(obj);\n     }\n \n     // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n@@ -421,56 +416,9 @@ fn link_rlib<'a>(sess: &'a Session,\n             ab.add_file(&metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted\n-            // into the archive.  If codegen_units > 1, we insert each of the\n-            // bitcode files.\n-            for module in trans.modules.iter() {\n-                // Note that we make sure that the bytecode filename in the\n-                // archive is never exactly 16 bytes long by adding a 16 byte\n-                // extension to it. This is to work around a bug in LLDB that\n-                // would cause it to crash if the name of a file in an archive\n-                // was exactly 16 bytes.\n-                let bc_filename = module.object.with_extension(\"bc\");\n-                let bc_encoded_filename = tmpdir.join({\n-                    module.object.with_extension(RLIB_BYTECODE_EXTENSION).file_name().unwrap()\n-                });\n-\n-                let mut bc_data = Vec::new();\n-                match fs::File::open(&bc_filename).and_then(|mut f| {\n-                    f.read_to_end(&mut bc_data)\n-                }) {\n-                    Ok(..) => {}\n-                    Err(e) => sess.fatal(&format!(\"failed to read bytecode: {}\",\n-                                                 e))\n-                }\n-\n-                let encoded = bytecode::encode(&module.llmod_id, &bc_data);\n-\n-                let mut bc_file_deflated = match fs::File::create(&bc_encoded_filename) {\n-                    Ok(file) => file,\n-                    Err(e) => {\n-                        sess.fatal(&format!(\"failed to create compressed \\\n-                                             bytecode file: {}\", e))\n-                    }\n-                };\n-\n-                match bc_file_deflated.write_all(&encoded) {\n-                    Ok(()) => {}\n-                    Err(e) => {\n-                        sess.fatal(&format!(\"failed to write compressed \\\n-                                             bytecode: {}\", e));\n-                    }\n-                };\n-\n-                ab.add_file(&bc_encoded_filename);\n-\n-                // See the bottom of back::write::run_passes for an explanation\n-                // of when we do and don't keep .#module-name#.bc files around.\n-                let user_wants_numbered_bitcode =\n-                        sess.opts.output_types.contains_key(&OutputType::Bitcode) &&\n-                        sess.codegen_units() > 1;\n-                if !sess.opts.cg.save_temps && !user_wants_numbered_bitcode {\n-                    remove(sess, &bc_filename);\n-                }\n+            // into the archive.\n+            for bytecode in trans.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n+                ab.add_file(bytecode);\n             }\n \n             // After adding all files to the archive, we need to update the\n@@ -482,8 +430,11 @@ fn link_rlib<'a>(sess: &'a Session,\n         }\n \n         RlibFlavor::StaticlibBase => {\n-            if trans.allocator_module.is_some() {\n-                ab.add_file(&allocator_obj(outputs));\n+            let obj = trans.allocator_module\n+                .as_ref()\n+                .and_then(|m| m.object.as_ref());\n+            if let Some(obj) = obj {\n+                ab.add_file(obj);\n             }\n         }\n     }\n@@ -505,13 +456,11 @@ fn link_rlib<'a>(sess: &'a Session,\n // metadata file).\n fn link_staticlib(sess: &Session,\n                   trans: &CrateTranslation,\n-                  outputs: &OutputFilenames,\n                   out_filename: &Path,\n                   tempdir: &Path) {\n     let mut ab = link_rlib(sess,\n                            trans,\n                            RlibFlavor::StaticlibBase,\n-                           outputs,\n                            out_filename,\n                            tempdir);\n     let mut all_native_libs = vec![];\n@@ -616,7 +565,6 @@ fn link_natively(sess: &Session,\n                  crate_type: config::CrateType,\n                  out_filename: &Path,\n                  trans: &CrateTranslation,\n-                 outputs: &OutputFilenames,\n                  tmpdir: &Path) {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let flavor = sess.linker_flavor();\n@@ -656,7 +604,7 @@ fn link_natively(sess: &Session,\n     {\n         let mut linker = trans.linker_info.to_linker(cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n-                  out_filename, outputs, trans);\n+                  out_filename, trans);\n         cmd = linker.finalize();\n     }\n     if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n@@ -878,7 +826,6 @@ fn link_args(cmd: &mut Linker,\n              crate_type: config::CrateType,\n              tmpdir: &Path,\n              out_filename: &Path,\n-             outputs: &OutputFilenames,\n              trans: &CrateTranslation) {\n \n     // The default library location, we need this to find the runtime.\n@@ -889,8 +836,8 @@ fn link_args(cmd: &mut Linker,\n     let t = &sess.target.target;\n \n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n-    for module in trans.modules.iter() {\n-        cmd.add_object(&module.object);\n+    for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        cmd.add_object(obj);\n     }\n     cmd.output_filename(out_filename);\n \n@@ -913,11 +860,16 @@ fn link_args(cmd: &mut Linker,\n     // object file, so we link that in here.\n     if crate_type == config::CrateTypeDylib ||\n        crate_type == config::CrateTypeProcMacro {\n-        cmd.add_object(&metadata_obj(outputs));\n+        if let Some(obj) = trans.metadata_module.object.as_ref() {\n+            cmd.add_object(obj);\n+        }\n     }\n \n-    if trans.allocator_module.is_some() {\n-        cmd.add_object(&allocator_obj(outputs));\n+    let obj = trans.allocator_module\n+        .as_ref()\n+        .and_then(|m| m.object.as_ref());\n+    if let Some(obj) = obj {\n+        cmd.add_object(obj);\n     }\n \n     // Try to strip as much out of the generated object by removing unused\n@@ -1185,9 +1137,9 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n         for f in archive.src_files() {\n             if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n-                    archive.remove_file(&f);\n-                    continue\n-                }\n+                archive.remove_file(&f);\n+                continue\n+            }\n         }\n \n         archive.build();"}, {"sha": "48c3fd638c36ba52711b9b2c801bb5360a76fb23", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=8197a0bbaf2c6ab717b40080e0d1201b634500b6", "patch": "@@ -343,8 +343,7 @@ fn thin_lto(diag_handler: &Handler,\n             info!(\"local module: {} - {}\", i, module.llmod_id);\n             let llvm = module.llvm().expect(\"can't lto pretranslated module\");\n             let name = CString::new(module.llmod_id.clone()).unwrap();\n-            let buffer = llvm::LLVMRustThinLTOBufferCreate(llvm.llmod);\n-            let buffer = ThinBuffer(buffer);\n+            let buffer = ThinBuffer::new(llvm.llmod);\n             thin_modules.push(llvm::ThinLTOModule {\n                 identifier: name.as_ptr(),\n                 data: buffer.data().as_ptr(),\n@@ -499,13 +498,13 @@ unsafe impl Send for ModuleBuffer {}\n unsafe impl Sync for ModuleBuffer {}\n \n impl ModuleBuffer {\n-    fn new(m: ModuleRef) -> ModuleBuffer {\n+    pub fn new(m: ModuleRef) -> ModuleBuffer {\n         ModuleBuffer(unsafe {\n             llvm::LLVMRustModuleBufferCreate(m)\n         })\n     }\n \n-    fn data(&self) -> &[u8] {\n+    pub fn data(&self) -> &[u8] {\n         unsafe {\n             let ptr = llvm::LLVMRustModuleBufferPtr(self.0);\n             let len = llvm::LLVMRustModuleBufferLen(self.0);\n@@ -545,13 +544,20 @@ impl Drop for ThinData {\n     }\n }\n \n-struct ThinBuffer(*mut llvm::ThinLTOBuffer);\n+pub struct ThinBuffer(*mut llvm::ThinLTOBuffer);\n \n unsafe impl Send for ThinBuffer {}\n unsafe impl Sync for ThinBuffer {}\n \n impl ThinBuffer {\n-    fn data(&self) -> &[u8] {\n+    pub fn new(m: ModuleRef) -> ThinBuffer {\n+        unsafe {\n+            let buffer = llvm::LLVMRustThinLTOBufferCreate(m);\n+            ThinBuffer(buffer)\n+        }\n+    }\n+\n+    pub fn data(&self) -> &[u8] {\n         unsafe {\n             let ptr = llvm::LLVMRustThinLTOBufferPtr(self.0) as *const _;\n             let len = llvm::LLVMRustThinLTOBufferLen(self.0);"}, {"sha": "5550ab9fa55e6752863dc192fd75f9d29ee8eec9", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 93, "deletions": 62, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=8197a0bbaf2c6ab717b40080e0d1201b634500b6", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::lto;\n+use back::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n+use back::lto::{self, ModuleBuffer, ThinBuffer};\n use back::link::{self, get_linker, remove};\n use back::linker::LinkerInfo;\n use back::symbol_export::ExportedSymbols;\n use base;\n use consts;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n-use rustc::dep_graph::DepGraph;\n+use rustc::dep_graph::{DepGraph, WorkProductFileKind};\n use rustc::middle::cstore::{LinkMeta, EncodedMetadata};\n use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n                              AllPasses, Sanitizer};\n@@ -44,7 +45,7 @@ use rustc_demangle;\n \n use std::any::Any;\n use std::ffi::{CString, CStr};\n-use std::fs;\n+use std::fs::{self, File};\n use std::io;\n use std::io::Write;\n use std::mem;\n@@ -228,6 +229,7 @@ pub struct ModuleConfig {\n     // Flags indicating which outputs to produce.\n     emit_no_opt_bc: bool,\n     emit_bc: bool,\n+    emit_bc_compressed: bool,\n     emit_lto_bc: bool,\n     emit_ir: bool,\n     emit_asm: bool,\n@@ -257,6 +259,7 @@ impl ModuleConfig {\n \n             emit_no_opt_bc: false,\n             emit_bc: false,\n+            emit_bc_compressed: false,\n             emit_lto_bc: false,\n             emit_ir: false,\n             emit_asm: false,\n@@ -627,20 +630,34 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n     let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n \n-    if write_bc {\n-        let bc_out_c = path2cstr(&bc_out);\n-        if llvm::LLVMRustThinLTOAvailable() {\n-            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                llvm::LLVMRustWriteThinBitcodeToFile(\n-                    cpm,\n-                    llmod,\n-                    bc_out_c.as_ptr(),\n-                )\n-            });\n+\n+    if write_bc || config.emit_bc_compressed {\n+        let thin;\n+        let old;\n+        let data = if llvm::LLVMRustThinLTOAvailable() {\n+            thin = ThinBuffer::new(llmod);\n+            thin.data()\n         } else {\n-            llvm::LLVMWriteBitcodeToFile(llmod, bc_out_c.as_ptr());\n+            old = ModuleBuffer::new(llmod);\n+            old.data()\n+        };\n+        timeline.record(\"make-bc\");\n+\n+        if write_bc {\n+            if let Err(e) = File::create(&bc_out).and_then(|mut f| f.write_all(data)) {\n+                diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+            }\n+            timeline.record(\"write-bc\");\n+        }\n+\n+        if config.emit_bc_compressed {\n+            let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n+            let data = bytecode::encode(&mtrans.llmod_id, data);\n+            if let Err(e) = File::create(&dst).and_then(|mut f| f.write_all(&data)) {\n+                diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+            }\n+            timeline.record(\"compress-bc\");\n         }\n-        timeline.record(\"bc\");\n     }\n \n     time(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n@@ -736,6 +753,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     drop(handlers);\n     Ok(mtrans.into_compiled_module(config.emit_obj,\n                                    config.emit_bc,\n+                                   config.emit_bc_compressed,\n                                    &cgcx.output_filenames))\n }\n \n@@ -822,11 +840,12 @@ pub fn start_async_translation(tcx: TyCtxt,\n         allocator_config.emit_bc = true;\n     }\n \n-    // Emit bitcode files for the crate if we're emitting an rlib.\n-    // Whenever an rlib is created, the bitcode is inserted into the\n-    // archive in order to allow LTO against it.\n+    // Emit compressed bitcode files for the crate if we're emitting an rlib.\n+    // Whenever an rlib is created, the bitcode is inserted into the archive in\n+    // order to allow LTO against it.\n     if need_crate_bitcode_for_rlib(sess) {\n-        modules_config.emit_bc = true;\n+        modules_config.emit_bc_compressed = true;\n+        allocator_config.emit_bc_compressed = true;\n     }\n \n     for output_type in output_types_override.keys() {\n@@ -906,29 +925,25 @@ pub fn start_async_translation(tcx: TyCtxt,\n \n fn copy_module_artifacts_into_incr_comp_cache(sess: &Session,\n                                               dep_graph: &DepGraph,\n-                                              compiled_modules: &CompiledModules,\n-                                              crate_output: &OutputFilenames) {\n+                                              compiled_modules: &CompiledModules) {\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n \n     for module in compiled_modules.modules.iter() {\n         let mut files = vec![];\n \n-        if module.emit_obj {\n-            let path = crate_output.temp_path(OutputType::Object, Some(&module.name));\n-            files.push((OutputType::Object, path));\n+        if let Some(ref path) = module.object {\n+            files.push((WorkProductFileKind::Object, path.clone()));\n         }\n-\n-        if module.emit_bc {\n-            let path = crate_output.temp_path(OutputType::Bitcode, Some(&module.name));\n-            files.push((OutputType::Bitcode, path));\n+        if let Some(ref path) = module.bytecode {\n+            files.push((WorkProductFileKind::Bytecode, path.clone()));\n+        }\n+        if let Some(ref path) = module.bytecode_compressed {\n+            files.push((WorkProductFileKind::BytecodeCompressed, path.clone()));\n         }\n \n-        save_trans_partition(sess,\n-                             dep_graph,\n-                             &module.name,\n-                             &files);\n+        save_trans_partition(sess, dep_graph, &module.name, &files);\n     }\n }\n \n@@ -1032,8 +1047,6 @@ fn produce_final_output_artifacts(sess: &Session,\n         // well.\n \n         // Specific rules for keeping .#module-name#.bc:\n-        //  - If we're building an rlib (`needs_crate_bitcode`), then keep\n-        //    it.\n         //  - If the user requested bitcode (`user_wants_bitcode`), and\n         //    codegen_units > 1, then keep it.\n         //  - If the user requested bitcode but codegen_units == 1, then we\n@@ -1043,41 +1056,37 @@ fn produce_final_output_artifacts(sess: &Session,\n         // If you change how this works, also update back::link::link_rlib,\n         // where .#module-name#.bc files are (maybe) deleted after making an\n         // rlib.\n-        let needs_crate_bitcode = need_crate_bitcode_for_rlib(sess);\n         let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n \n-        let keep_numbered_bitcode = needs_crate_bitcode ||\n-                (user_wants_bitcode && sess.codegen_units() > 1);\n+        let keep_numbered_bitcode = user_wants_bitcode && sess.codegen_units() > 1;\n \n         let keep_numbered_objects = needs_crate_object ||\n                 (user_wants_objects && sess.codegen_units() > 1);\n \n         for module in compiled_modules.modules.iter() {\n-            let module_name = Some(&module.name[..]);\n-\n-            if module.emit_obj && !keep_numbered_objects {\n-                let path = crate_output.temp_path(OutputType::Object, module_name);\n-                remove(sess, &path);\n+            if let Some(ref path) = module.object {\n+                if !keep_numbered_objects {\n+                    remove(sess, path);\n+                }\n             }\n \n-            if module.emit_bc && !keep_numbered_bitcode {\n-                let path = crate_output.temp_path(OutputType::Bitcode, module_name);\n-                remove(sess, &path);\n+            if let Some(ref path) = module.bytecode {\n+                if !keep_numbered_bitcode {\n+                    remove(sess, path);\n+                }\n             }\n         }\n \n-        if compiled_modules.metadata_module.emit_bc && !user_wants_bitcode {\n-            let path = crate_output.temp_path(OutputType::Bitcode,\n-                                              Some(&compiled_modules.metadata_module.name));\n-            remove(sess, &path);\n-        }\n-\n-        if let Some(ref allocator_module) = compiled_modules.allocator_module {\n-            if allocator_module.emit_bc && !user_wants_bitcode {\n-                let path = crate_output.temp_path(OutputType::Bitcode,\n-                                                  Some(&allocator_module.name));\n+        if !user_wants_bitcode {\n+            if let Some(ref path) = compiled_modules.metadata_module.bytecode {\n                 remove(sess, &path);\n             }\n+\n+            if let Some(ref allocator_module) = compiled_modules.allocator_module {\n+                if let Some(ref path) = allocator_module.bytecode {\n+                    remove(sess, path);\n+                }\n+            }\n         }\n     }\n \n@@ -1149,8 +1158,28 @@ fn execute_work_item(cgcx: &CodegenContext,\n                                         .as_ref()\n                                         .unwrap();\n         let name = &mtrans.name;\n+        let mut object = None;\n+        let mut bytecode = None;\n+        let mut bytecode_compressed = None;\n         for (kind, saved_file) in wp.saved_files {\n-            let obj_out = cgcx.output_filenames.temp_path(kind, Some(name));\n+            let obj_out = match kind {\n+                WorkProductFileKind::Object => {\n+                    let path = cgcx.output_filenames.temp_path(OutputType::Object, Some(name));\n+                    object = Some(path.clone());\n+                    path\n+                }\n+                WorkProductFileKind::Bytecode => {\n+                    let path = cgcx.output_filenames.temp_path(OutputType::Bitcode, Some(name));\n+                    bytecode = Some(path.clone());\n+                    path\n+                }\n+                WorkProductFileKind::BytecodeCompressed => {\n+                    let path = cgcx.output_filenames.temp_path(OutputType::Bitcode, Some(name))\n+                        .with_extension(RLIB_BYTECODE_EXTENSION);\n+                    bytecode_compressed = Some(path.clone());\n+                    path\n+                }\n+            };\n             let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n                                                &saved_file);\n             debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n@@ -1167,16 +1196,18 @@ fn execute_work_item(cgcx: &CodegenContext,\n                 }\n             }\n         }\n-        let object = cgcx.output_filenames.temp_path(OutputType::Object, Some(name));\n+        assert_eq!(object.is_some(), config.emit_obj);\n+        assert_eq!(bytecode.is_some(), config.emit_bc);\n+        assert_eq!(bytecode_compressed.is_some(), config.emit_bc_compressed);\n \n         Ok(WorkItemResult::Compiled(CompiledModule {\n-            object,\n             llmod_id: mtrans.llmod_id.clone(),\n             name: module_name,\n             kind: ModuleKind::Regular,\n             pre_existing: true,\n-            emit_bc: config.emit_bc,\n-            emit_obj: config.emit_obj,\n+            object,\n+            bytecode,\n+            bytecode_compressed,\n         }))\n     } else {\n         debug!(\"llvm-optimizing {:?}\", module_name);\n@@ -2053,8 +2084,7 @@ impl OngoingCrateTranslation {\n \n         copy_module_artifacts_into_incr_comp_cache(sess,\n                                                    dep_graph,\n-                                                   &compiled_modules,\n-                                                   &self.output_filenames);\n+                                                   &compiled_modules);\n         produce_final_output_artifacts(sess,\n                                        &compiled_modules,\n                                        &self.output_filenames);\n@@ -2075,6 +2105,7 @@ impl OngoingCrateTranslation {\n \n             modules: compiled_modules.modules,\n             allocator_module: compiled_modules.allocator_module,\n+            metadata_module: compiled_modules.metadata_module,\n         };\n \n         if self.no_integrated_as {"}, {"sha": "93f2eef76d18d9c3d60fdcff97c5fca1420102b9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8197a0bbaf2c6ab717b40080e0d1201b634500b6/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=8197a0bbaf2c6ab717b40080e0d1201b634500b6", "patch": "@@ -64,6 +64,7 @@ extern crate serialize;\n extern crate cc; // Used to locate MSVC\n \n pub use base::trans_crate;\n+use back::bytecode::RLIB_BYTECODE_EXTENSION;\n \n pub use metadata::LlvmMetadataLoader;\n pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n@@ -90,7 +91,7 @@ mod diagnostics;\n \n pub mod back {\n     mod archive;\n-    mod bytecode;\n+    pub mod bytecode;\n     mod command;\n     pub(crate) mod linker;\n     pub mod link;\n@@ -227,21 +228,37 @@ impl ModuleTranslation {\n     pub fn into_compiled_module(self,\n                                 emit_obj: bool,\n                                 emit_bc: bool,\n+                                emit_bc_compressed: bool,\n                                 outputs: &OutputFilenames) -> CompiledModule {\n         let pre_existing = match self.source {\n             ModuleSource::Preexisting(_) => true,\n             ModuleSource::Translated(_) => false,\n         };\n-        let object = outputs.temp_path(OutputType::Object, Some(&self.name));\n+        let object = if emit_obj {\n+            Some(outputs.temp_path(OutputType::Object, Some(&self.name)))\n+        } else {\n+            None\n+        };\n+        let bytecode = if emit_bc {\n+            Some(outputs.temp_path(OutputType::Bitcode, Some(&self.name)))\n+        } else {\n+            None\n+        };\n+        let bytecode_compressed = if emit_bc_compressed {\n+            Some(outputs.temp_path(OutputType::Bitcode, Some(&self.name))\n+                    .with_extension(RLIB_BYTECODE_EXTENSION))\n+        } else {\n+            None\n+        };\n \n         CompiledModule {\n             llmod_id: self.llmod_id,\n             name: self.name.clone(),\n             kind: self.kind,\n             pre_existing,\n-            emit_obj,\n-            emit_bc,\n             object,\n+            bytecode,\n+            bytecode_compressed,\n         }\n     }\n }\n@@ -250,11 +267,11 @@ impl ModuleTranslation {\n pub struct CompiledModule {\n     pub name: String,\n     pub llmod_id: String,\n-    pub object: PathBuf,\n     pub kind: ModuleKind,\n     pub pre_existing: bool,\n-    pub emit_obj: bool,\n-    pub emit_bc: bool,\n+    pub object: Option<PathBuf>,\n+    pub bytecode: Option<PathBuf>,\n+    pub bytecode_compressed: Option<PathBuf>,\n }\n \n pub enum ModuleSource {\n@@ -289,6 +306,7 @@ pub struct CrateTranslation {\n     pub crate_name: Symbol,\n     pub modules: Vec<CompiledModule>,\n     allocator_module: Option<CompiledModule>,\n+    metadata_module: CompiledModule,\n     pub link: rustc::middle::cstore::LinkMeta,\n     pub metadata: rustc::middle::cstore::EncodedMetadata,\n     windows_subsystem: Option<String>,"}]}