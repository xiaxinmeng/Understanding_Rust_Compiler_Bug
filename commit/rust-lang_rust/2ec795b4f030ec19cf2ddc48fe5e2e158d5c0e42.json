{"sha": "2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYzc5NWI0ZjAzMGVjMTljZjJkZGM0OGZlNWUyZTE1OGQ1YzBlNDI=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-09-20T11:26:10Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-09-24T19:03:55Z"}, "message": "Add detection of unused enum variants", "tree": {"sha": "c5ca465bb749f2080b34c5223bf8e8500b23ec40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5ca465bb749f2080b34c5223bf8e8500b23ec40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42", "html_url": "https://github.com/rust-lang/rust/commit/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42/comments", "author": null, "committer": null, "parents": [{"sha": "9e3bf02c381c9d4dd6b5ace6815febab3b89fecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e3bf02c381c9d4dd6b5ace6815febab3b89fecf", "html_url": "https://github.com/rust-lang/rust/commit/9e3bf02c381c9d4dd6b5ace6815febab3b89fecf"}], "stats": {"total": 149, "additions": 110, "deletions": 39}, "files": [{"sha": "7110c5f5720fce8d6e1b774a0e3900acf69cd1aa", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 62, "deletions": 36, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42", "patch": "@@ -13,21 +13,20 @@\n // from live codes are live, and everything else is dead.\n \n use middle::def;\n-use lint;\n+use middle::pat_util;\n use middle::privacy;\n use middle::ty;\n use middle::typeck;\n+use lint;\n use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, is_local, PostExpansionMethod};\n-use syntax::attr::AttrMetaMethods;\n-use syntax::attr;\n+use syntax::attr::{mod, AttrMetaMethods};\n use syntax::codemap;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n+use syntax::visit::{mod, Visitor};\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live NodeItem that is a\n@@ -51,7 +50,8 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: &'a ty::ctxt<'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n-    struct_has_extern_repr: bool\n+    struct_has_extern_repr: bool,\n+    ignore_paths: bool\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n@@ -61,7 +61,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             worklist: worklist,\n             tcx: tcx,\n             live_symbols: box HashSet::new(),\n-            struct_has_extern_repr: false\n+            struct_has_extern_repr: false,\n+            ignore_paths: false\n         }\n     }\n \n@@ -73,19 +74,18 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n-        let def = match self.tcx.def_map.borrow().find(id) {\n-            Some(&def) => def,\n-            None => return\n-        };\n-        let def_id = match def {\n-            def::DefVariant(enum_id, _, _) => Some(enum_id),\n-            def::DefPrimTy(_) => None,\n-            _ => Some(def.def_id())\n-        };\n-        match def_id {\n-            Some(def_id) => self.check_def_id(def_id),\n-            None => (),\n-        }\n+        self.tcx.def_map.borrow().find(id).map(|def| {\n+            match def {\n+                &def::DefPrimTy(_) => (),\n+                &def::DefVariant(enum_id, variant_id, _) => {\n+                    self.check_def_id(enum_id);\n+                    self.check_def_id(variant_id);\n+                }\n+                _ => {\n+                    self.check_def_id(def.def_id());\n+                }\n+            }\n+        });\n     }\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n@@ -275,22 +275,27 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, pat: &ast::Pat) {\n+        let def_map = &self.tcx.def_map;\n         match pat.node {\n             ast::PatStruct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields.as_slice());\n             }\n-            ast::PatIdent(_, _, _) => {\n+            _ if pat_util::pat_is_const(def_map, pat) => {\n                 // it might be the only use of a static:\n                 self.lookup_and_handle_definition(&pat.id)\n             }\n             _ => ()\n         }\n \n+        self.ignore_paths = true;\n         visit::walk_pat(self, pat);\n+        self.ignore_paths = false;\n     }\n \n     fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n-        self.lookup_and_handle_definition(&id);\n+        if !self.ignore_paths {\n+            self.lookup_and_handle_definition(&id);\n+        }\n         visit::walk_path(self, path);\n     }\n \n@@ -330,15 +335,19 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n struct LifeSeeder {\n-    worklist: Vec<ast::NodeId> ,\n+    worklist: Vec<ast::NodeId>\n }\n \n impl<'v> Visitor<'v> for LifeSeeder {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        if has_allow_dead_code_or_lang_attr(item.attrs.as_slice()) {\n+        let allow_dead_code = has_allow_dead_code_or_lang_attr(item.attrs.as_slice());\n+        if allow_dead_code {\n             self.worklist.push(item.id);\n         }\n         match item.node {\n+            ast::ItemEnum(ref enum_def, _) if allow_dead_code => {\n+                self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n+            }\n             ast::ItemImpl(_, Some(ref _trait_ref), _, ref impl_items) => {\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n@@ -415,16 +424,6 @@ fn find_live(tcx: &ty::ctxt,\n     symbol_visitor.live_symbols\n }\n \n-fn should_warn(item: &ast::Item) -> bool {\n-    match item.node {\n-        ast::ItemStatic(..)\n-        | ast::ItemFn(..)\n-        | ast::ItemEnum(..)\n-        | ast::ItemStruct(..) => true,\n-        _ => false\n-    }\n-}\n-\n fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n     match item.node {\n         ast::ItemStruct(ref struct_def, _) => struct_def.ctor_id,\n@@ -438,6 +437,18 @@ struct DeadVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n+    fn should_warn_about_item(&mut self, item: &ast::Item) -> bool {\n+        let should_warn = match item.node {\n+            ast::ItemStatic(..)\n+            | ast::ItemFn(..)\n+            | ast::ItemEnum(..)\n+            | ast::ItemStruct(..) => true,\n+            _ => false\n+        };\n+        let ctor_id = get_struct_ctor_id(item);\n+        should_warn && !self.symbol_is_live(item.id, ctor_id)\n+    }\n+\n     fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n         let is_named = node.ident().is_some();\n         let field_type = ty::node_id_to_type(self.tcx, node.id);\n@@ -451,6 +462,11 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             && !has_allow_dead_code_or_lang_attr(node.attrs.as_slice())\n     }\n \n+    fn should_warn_about_variant(&mut self, variant: &ast::Variant_) -> bool {\n+        !self.symbol_is_live(variant.id, None)\n+            && !has_allow_dead_code_or_lang_attr(variant.attrs.as_slice())\n+    }\n+\n     // id := node id of an item's definition.\n     // ctor_id := `Some` if the item is a struct_ctor (tuple struct),\n     //            `None` otherwise.\n@@ -506,9 +522,19 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        let ctor_id = get_struct_ctor_id(item);\n-        if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {\n+        if self.should_warn_about_item(item) {\n             self.warn_dead_code(item.id, item.span, item.ident);\n+        } else {\n+            match item.node {\n+                ast::ItemEnum(ref enum_def, _) => {\n+                    for variant in enum_def.variants.iter() {\n+                        if self.should_warn_about_variant(&variant.node) {\n+                            self.warn_dead_code(variant.node.id, variant.span, variant.node.name);\n+                        }\n+                    }\n+                },\n+                _ => ()\n+            }\n         }\n         visit::walk_item(self, item);\n     }"}, {"sha": "8c40ea2afe2e73fb36c70d4c87d9aa4a32940858", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42", "patch": "@@ -63,8 +63,12 @@ pub struct PubStruct2 {\n pub enum pub_enum { foo1, bar1 }\n pub enum pub_enum2 { a(*const StructUsedInEnum) }\n pub enum pub_enum3 { Foo = STATIC_USED_IN_ENUM_DISCRIMINANT }\n+\n enum priv_enum { foo2, bar2 } //~ ERROR: code is never used\n-enum used_enum { foo3, bar3 }\n+enum used_enum {\n+    foo3,\n+    bar3 //~ ERROR code is never used\n+}\n \n fn f<T>() {}\n "}, {"sha": "826faad32c9af2ac897c9dd7fcb02949297ca1a3", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42", "patch": "@@ -28,8 +28,8 @@ fn field_read(f: Foo) -> uint {\n }\n \n enum XYZ {\n-    X,\n-    Y {\n+    X, //~ ERROR variant is never used\n+    Y { //~ ERROR variant is never used\n         a: String,\n         b: int //~ ERROR: code is never used\n     },"}, {"sha": "c26ae1a702316d942642f0a1b96470e144ba80c6", "filename": "src/test/compile-fail/lint-dead-code-5.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42/src%2Ftest%2Fcompile-fail%2Flint-dead-code-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42/src%2Ftest%2Fcompile-fail%2Flint-dead-code-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-5.rs?ref=2ec795b4f030ec19cf2ddc48fe5e2e158d5c0e42", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(struct_variant)]\n+#![allow(unused_variable)]\n+#![deny(dead_code)]\n+\n+enum Enum1 {\n+    Variant1(int),\n+    Variant2 //~ ERROR: code is never used\n+}\n+\n+enum Enum2 {\n+    Variant3(bool),\n+    #[allow(dead_code)]\n+    Variant4(int),\n+    Variant5 { _x: int }, //~ ERROR: variant is never used: `Variant5`\n+    Variant6(int), //~ ERROR: variant is never used: `Variant6`\n+    _Variant7,\n+}\n+\n+enum Enum3 { //~ ERROR: enum is never used\n+    Variant8,\n+    Variant9\n+}\n+\n+fn main() {\n+    let v = Variant1(1);\n+    match v {\n+        Variant1(_) => (),\n+        Variant2 => ()\n+    }\n+    let x = Variant3(true);\n+}"}]}