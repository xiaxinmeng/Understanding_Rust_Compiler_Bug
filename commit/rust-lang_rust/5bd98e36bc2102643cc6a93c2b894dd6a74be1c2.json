{"sha": "5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "node_id": "C_kwDOAAsO6NoAKDViZDk4ZTM2YmMyMTAyNjQzY2M2YTkzYzJiODk0ZGQ2YTc0YmUxYzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-03T12:13:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-03T12:13:25Z"}, "message": "Auto merge of #13335 - lowr:patch/change-generic-param-order, r=Veykril\n\ninternal: change generic parameter order\n\ntl;dr: This PR changes the `Substitution` for trait items and methods like so:\n\n```rust\ntrait Trait<TP, const CP: usize> { // note the implicit Self as first parameter\n  type Type<TC, const CC: usize>;\n  fn f<TC, const CC: usize>() {}\n}\nimpl<TP, const CP: usize> S {\n  fn f<TC, const CC: usize>() {}\n}\n```\n\n- before this PR: `[Self, TP, CP, TC, CC]` for each trait item, `[TP, CP, TC, CC]` for `S::f`\n- after this PR: `[TC, CC, Self, TP, CP]` for each trait item, `[TC, CC, TP, CP]` for `S::f`\n\n---\n\nThis PR \"inverts\" the generic parameters/arguments of an item and its parent. This is to fulfill [chalk's expectation](https://github.com/rust-lang/chalk/blob/d875af0ff196dd6430b5f5fd87a640fa5ab59d1e/chalk-solve/src/rust_ir.rs#L498-L502) on the order of generic arguments in `Substitution`s for generic associated types and it's one step forward for GATs support (hopefully). Although chalk doesn't put any constraint for other items, it feels more natural to get everything aligned than special casing GATs.\n\nOne complication is that `TyBuilder` now demands its users to pass in parent's `Substitution` upon construction unless it's obvious that the the item has no parent (e.g. an ADT never has parent). All users *should* already know the parent of the item in question, and without this, it cannot be easily reasoned about whether we're pushing the argument for the item or for its parent.\n\nSome additional notes:\n- f8f5a5ea5788a846013545d63c9b46fd70cc4f7c: This isn't related to the change, but I felt it's nicer.\n\n- 78977cd86cd17e008f94f8579d6a5aaebe46e69b: There's one major change here other than the generic param order: Default arguments are now bound by the same `Binder` as the item in question rather than a `Binder` limited to parameters they can refer to (i.e. arguments that syntactically appear before them). Now that the order of generic parameters is changed, it would be somewhat complicated to make such `Binder`s as before, and the \"full\" `Binder`s shouldn't be a problem because we already make sure that the default arguments don't refer to the generic arguments after them with `fallback_bound_vars()`.\n\n- 7556f74b1691276d12e4cf96eb2df8f74836cdc1: This is split from 4385d3dcd0df7713b3a35f31f11034f0a570adbd to make it easy to revert if it turns out that the GATs with const generics panic is actually not resolved with this PR. cc #11878 #11957", "tree": {"sha": "2bbea222fe65b3ca195f893999e70f3cf317582c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bbea222fe65b3ca195f893999e70f3cf317582c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "html_url": "https://github.com/rust-lang/rust/commit/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f087ebe6e7c80da747ecd4d7e1673a27c6729d34", "url": "https://api.github.com/repos/rust-lang/rust/commits/f087ebe6e7c80da747ecd4d7e1673a27c6729d34", "html_url": "https://github.com/rust-lang/rust/commit/f087ebe6e7c80da747ecd4d7e1673a27c6729d34"}, {"sha": "7556f74b1691276d12e4cf96eb2df8f74836cdc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7556f74b1691276d12e4cf96eb2df8f74836cdc1", "html_url": "https://github.com/rust-lang/rust/commit/7556f74b1691276d12e4cf96eb2df8f74836cdc1"}], "stats": {"total": 797, "additions": 444, "deletions": 353}, "files": [{"sha": "02332ea80d883f1ed9a036750a2305387ca464b5", "filename": "crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -123,13 +123,14 @@ fn deref_by_trait(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n     let projection = {\n-        let b = TyBuilder::assoc_type_projection(db, target);\n+        let b = TyBuilder::subst_for_def(db, deref_trait, None);\n         if b.remaining() != 1 {\n             // the Target type + Deref trait should only have one generic parameter,\n             // namely Deref's Self type\n             return None;\n         }\n-        b.push(ty).build()\n+        let deref_subst = b.push(ty).build();\n+        TyBuilder::assoc_type_projection(db, target, Some(deref_subst)).build()\n     };\n \n     // Check that the type implements Deref at all"}, {"sha": "c0052258ee03700df1719928f9a2bce4ab7f972a", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 119, "deletions": 102, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -6,7 +6,7 @@ use chalk_ir::{\n     cast::{Cast, CastTo, Caster},\n     fold::TypeFoldable,\n     interner::HasInterner,\n-    AdtId, BoundVar, DebruijnIndex, Scalar,\n+    AdtId, DebruijnIndex, Scalar,\n };\n use hir_def::{\n     builtin_type::BuiltinType, generics::TypeOrConstParamData, ConstParamId, DefWithBodyId,\n@@ -16,9 +16,9 @@ use smallvec::SmallVec;\n \n use crate::{\n     consteval::unknown_const_as_generic, db::HirDatabase, infer::unify::InferenceTable, primitive,\n-    to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, CallableSig, ConstData,\n-    ConstValue, GenericArg, GenericArgData, Interner, ProjectionTy, Substitution, TraitRef, Ty,\n-    TyDefId, TyExt, TyKind, ValueTyDefId,\n+    to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, BoundVar, CallableSig,\n+    GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt, TyKind,\n+    ValueTyDefId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -34,31 +34,51 @@ pub struct TyBuilder<D> {\n     data: D,\n     vec: SmallVec<[GenericArg; 2]>,\n     param_kinds: SmallVec<[ParamKind; 2]>,\n+    parent_subst: Substitution,\n }\n \n impl<A> TyBuilder<A> {\n     fn with_data<B>(self, data: B) -> TyBuilder<B> {\n-        TyBuilder { data, param_kinds: self.param_kinds, vec: self.vec }\n+        TyBuilder {\n+            data,\n+            vec: self.vec,\n+            param_kinds: self.param_kinds,\n+            parent_subst: self.parent_subst,\n+        }\n     }\n }\n \n impl<D> TyBuilder<D> {\n-    fn new(data: D, param_kinds: SmallVec<[ParamKind; 2]>) -> TyBuilder<D> {\n-        TyBuilder { data, vec: SmallVec::with_capacity(param_kinds.len()), param_kinds }\n+    fn new(\n+        data: D,\n+        param_kinds: SmallVec<[ParamKind; 2]>,\n+        parent_subst: Option<Substitution>,\n+    ) -> Self {\n+        let parent_subst = parent_subst.unwrap_or_else(|| Substitution::empty(Interner));\n+        Self { data, vec: SmallVec::with_capacity(param_kinds.len()), param_kinds, parent_subst }\n+    }\n+\n+    fn new_empty(data: D) -> Self {\n+        TyBuilder::new(data, SmallVec::new(), None)\n     }\n \n     fn build_internal(self) -> (D, Substitution) {\n         assert_eq!(self.vec.len(), self.param_kinds.len());\n         for (a, e) in self.vec.iter().zip(self.param_kinds.iter()) {\n             self.assert_match_kind(a, e);\n         }\n-        let subst = Substitution::from_iter(Interner, self.vec);\n+        let subst = Substitution::from_iter(\n+            Interner,\n+            self.vec.into_iter().chain(self.parent_subst.iter(Interner).cloned()),\n+        );\n         (self.data, subst)\n     }\n \n     pub fn push(mut self, arg: impl CastTo<GenericArg>) -> Self {\n+        assert!(self.remaining() > 0);\n         let arg = arg.cast(Interner);\n         let expected_kind = &self.param_kinds[self.vec.len()];\n+\n         let arg_kind = match arg.data(Interner) {\n             chalk_ir::GenericArgData::Ty(_) => ParamKind::Type,\n             chalk_ir::GenericArgData::Lifetime(_) => panic!(\"Got lifetime in TyBuilder::push\"),\n@@ -68,7 +88,9 @@ impl<D> TyBuilder<D> {\n             }\n         };\n         assert_eq!(*expected_kind, arg_kind);\n+\n         self.vec.push(arg);\n+\n         self\n     }\n \n@@ -79,20 +101,12 @@ impl<D> TyBuilder<D> {\n     pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n         // self.fill is inlined to make borrow checker happy\n         let mut this = self;\n-        let other = this.param_kinds.iter().skip(this.vec.len());\n+        let other = &this.param_kinds[this.vec.len()..];\n         let filler = (starting_from..).zip(other).map(|(idx, kind)| match kind {\n-            ParamKind::Type => {\n-                GenericArgData::Ty(TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner))\n-                    .intern(Interner)\n+            ParamKind::Type => BoundVar::new(debruijn, idx).to_ty(Interner).cast(Interner),\n+            ParamKind::Const(ty) => {\n+                BoundVar::new(debruijn, idx).to_const(Interner, ty.clone()).cast(Interner)\n             }\n-            ParamKind::Const(ty) => GenericArgData::Const(\n-                ConstData {\n-                    value: ConstValue::BoundVar(BoundVar::new(debruijn, idx)),\n-                    ty: ty.clone(),\n-                }\n-                .intern(Interner),\n-            )\n-            .intern(Interner),\n         });\n         this.vec.extend(filler.take(this.remaining()).casted(Interner));\n         assert_eq!(this.remaining(), 0);\n@@ -102,8 +116,8 @@ impl<D> TyBuilder<D> {\n     pub fn fill_with_unknown(self) -> Self {\n         // self.fill is inlined to make borrow checker happy\n         let mut this = self;\n-        let filler = this.param_kinds.iter().skip(this.vec.len()).map(|x| match x {\n-            ParamKind::Type => GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner),\n+        let filler = this.param_kinds[this.vec.len()..].iter().map(|x| match x {\n+            ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n             ParamKind::Const(ty) => unknown_const_as_generic(ty.clone()),\n         });\n         this.vec.extend(filler.casted(Interner));\n@@ -113,33 +127,17 @@ impl<D> TyBuilder<D> {\n \n     pub(crate) fn fill_with_inference_vars(self, table: &mut InferenceTable<'_>) -> Self {\n         self.fill(|x| match x {\n-            ParamKind::Type => GenericArgData::Ty(table.new_type_var()).intern(Interner),\n-            ParamKind::Const(ty) => {\n-                GenericArgData::Const(table.new_const_var(ty.clone())).intern(Interner)\n-            }\n+            ParamKind::Type => table.new_type_var().cast(Interner),\n+            ParamKind::Const(ty) => table.new_const_var(ty.clone()).cast(Interner),\n         })\n     }\n \n     pub fn fill(mut self, filler: impl FnMut(&ParamKind) -> GenericArg) -> Self {\n-        self.vec.extend(self.param_kinds.iter().skip(self.vec.len()).map(filler));\n+        self.vec.extend(self.param_kinds[self.vec.len()..].iter().map(filler));\n         assert_eq!(self.remaining(), 0);\n         self\n     }\n \n-    pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n-        assert!(self.vec.is_empty());\n-        assert!(parent_substs.len(Interner) <= self.param_kinds.len());\n-        self.extend(parent_substs.iter(Interner).cloned());\n-        self\n-    }\n-\n-    fn extend(&mut self, it: impl Iterator<Item = GenericArg> + Clone) {\n-        for x in it.clone().zip(self.param_kinds.iter().skip(self.vec.len())) {\n-            self.assert_match_kind(&x.0, &x.1);\n-        }\n-        self.vec.extend(it);\n-    }\n-\n     fn assert_match_kind(&self, a: &chalk_ir::GenericArg<Interner>, e: &ParamKind) {\n         match (a.data(Interner), e) {\n             (chalk_ir::GenericArgData::Ty(_), ParamKind::Type)\n@@ -188,53 +186,44 @@ impl TyBuilder<()> {\n         params.placeholder_subst(db)\n     }\n \n-    pub fn subst_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> TyBuilder<()> {\n-        let def = def.into();\n-        let params = generics(db.upcast(), def);\n-        TyBuilder::new(\n-            (),\n-            params\n-                .iter()\n-                .map(|(id, data)| match data {\n-                    TypeOrConstParamData::TypeParamData(_) => ParamKind::Type,\n-                    TypeOrConstParamData::ConstParamData(_) => {\n-                        ParamKind::Const(db.const_param_ty(ConstParamId::from_unchecked(id)))\n-                    }\n-                })\n-                .collect(),\n-        )\n+    pub fn subst_for_def(\n+        db: &dyn HirDatabase,\n+        def: impl Into<GenericDefId>,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<()> {\n+        let generics = generics(db.upcast(), def.into());\n+        // FIXME: this assertion should hold but some adjustment around\n+        // `ValueTyDefId::EnumVariantId` is needed.\n+        // assert!(generics.parent_generics().is_some() == parent_subst.is_some());\n+        let params = generics\n+            .iter_self()\n+            .map(|(id, data)| match data {\n+                TypeOrConstParamData::TypeParamData(_) => ParamKind::Type,\n+                TypeOrConstParamData::ConstParamData(_) => {\n+                    ParamKind::Const(db.const_param_ty(ConstParamId::from_unchecked(id)))\n+                }\n+            })\n+            .collect();\n+        TyBuilder::new((), params, parent_subst)\n     }\n \n     /// Creates a `TyBuilder` to build `Substitution` for a generator defined in `parent`.\n     ///\n     /// A generator's substitution consists of:\n-    /// - generic parameters in scope on `parent`\n     /// - resume type of generator\n     /// - yield type of generator ([`Generator::Yield`](std::ops::Generator::Yield))\n     /// - return type of generator ([`Generator::Return`](std::ops::Generator::Return))\n+    /// - generic parameters in scope on `parent`\n     /// in this order.\n     ///\n     /// This method prepopulates the builder with placeholder substitution of `parent`, so you\n     /// should only push exactly 3 `GenericArg`s before building.\n     pub fn subst_for_generator(db: &dyn HirDatabase, parent: DefWithBodyId) -> TyBuilder<()> {\n-        let parent_subst = match parent.as_generic_def_id() {\n-            Some(parent) => generics(db.upcast(), parent).placeholder_subst(db),\n-            // Static initializers *may* contain generators.\n-            None => Substitution::empty(Interner),\n-        };\n-        let builder = TyBuilder::new(\n-            (),\n-            parent_subst\n-                .iter(Interner)\n-                .map(|arg| match arg.constant(Interner) {\n-                    Some(c) => ParamKind::Const(c.data(Interner).ty.clone()),\n-                    None => ParamKind::Type,\n-                })\n-                // These represent resume type, yield type, and return type of generator.\n-                .chain(std::iter::repeat(ParamKind::Type).take(3))\n-                .collect(),\n-        );\n-        builder.use_parent_substs(&parent_subst)\n+        let parent_subst =\n+            parent.as_generic_def_id().map(|p| generics(db.upcast(), p).placeholder_subst(db));\n+        // These represent resume type, yield type, and return type of generator.\n+        let params = std::iter::repeat(ParamKind::Type).take(3).collect();\n+        TyBuilder::new((), params, parent_subst)\n     }\n \n     pub fn build(self) -> Substitution {\n@@ -245,24 +234,35 @@ impl TyBuilder<()> {\n \n impl TyBuilder<hir_def::AdtId> {\n     pub fn adt(db: &dyn HirDatabase, def: hir_def::AdtId) -> TyBuilder<hir_def::AdtId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+        TyBuilder::subst_for_def(db, def, None).with_data(def)\n     }\n \n     pub fn fill_with_defaults(\n         mut self,\n         db: &dyn HirDatabase,\n         mut fallback: impl FnMut() -> Ty,\n     ) -> Self {\n+        // Note that we're building ADT, so we never have parent generic parameters.\n         let defaults = db.generic_defaults(self.data.into());\n+        let dummy_ty = TyKind::Error.intern(Interner).cast(Interner);\n         for default_ty in defaults.iter().skip(self.vec.len()) {\n-            if let GenericArgData::Ty(x) = default_ty.skip_binders().data(Interner) {\n+            // NOTE(skip_binders): we only check if the arg type is error type.\n+            if let Some(x) = default_ty.skip_binders().ty(Interner) {\n                 if x.is_unknown() {\n                     self.vec.push(fallback().cast(Interner));\n                     continue;\n                 }\n-            };\n-            // each default can depend on the previous parameters\n-            let subst_so_far = Substitution::from_iter(Interner, self.vec.clone());\n+            }\n+            // Each default can only depend on the previous parameters.\n+            // FIXME: we don't handle const generics here.\n+            let subst_so_far = Substitution::from_iter(\n+                Interner,\n+                self.vec\n+                    .iter()\n+                    .cloned()\n+                    .chain(iter::repeat(dummy_ty.clone()))\n+                    .take(self.param_kinds.len()),\n+            );\n             self.vec.push(default_ty.clone().substitute(Interner, &subst_so_far).cast(Interner));\n         }\n         self\n@@ -277,7 +277,7 @@ impl TyBuilder<hir_def::AdtId> {\n pub struct Tuple(usize);\n impl TyBuilder<Tuple> {\n     pub fn tuple(size: usize) -> TyBuilder<Tuple> {\n-        TyBuilder::new(Tuple(size), iter::repeat(ParamKind::Type).take(size).collect())\n+        TyBuilder::new(Tuple(size), iter::repeat(ParamKind::Type).take(size).collect(), None)\n     }\n \n     pub fn build(self) -> Ty {\n@@ -288,7 +288,7 @@ impl TyBuilder<Tuple> {\n \n impl TyBuilder<TraitId> {\n     pub fn trait_ref(db: &dyn HirDatabase, def: TraitId) -> TyBuilder<TraitId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+        TyBuilder::subst_for_def(db, def, None).with_data(def)\n     }\n \n     pub fn build(self) -> TraitRef {\n@@ -298,8 +298,12 @@ impl TyBuilder<TraitId> {\n }\n \n impl TyBuilder<TypeAliasId> {\n-    pub fn assoc_type_projection(db: &dyn HirDatabase, def: TypeAliasId) -> TyBuilder<TypeAliasId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+    pub fn assoc_type_projection(\n+        db: &dyn HirDatabase,\n+        def: TypeAliasId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<TypeAliasId> {\n+        TyBuilder::subst_for_def(db, def, parent_subst).with_data(def)\n     }\n \n     pub fn build(self) -> ProjectionTy {\n@@ -309,35 +313,48 @@ impl TyBuilder<TypeAliasId> {\n }\n \n impl<T: HasInterner<Interner = Interner> + TypeFoldable<Interner>> TyBuilder<Binders<T>> {\n-    fn subst_binders(b: Binders<T>) -> Self {\n-        let param_kinds = b\n-            .binders\n-            .iter(Interner)\n-            .map(|x| match x {\n-                chalk_ir::VariableKind::Ty(_) => ParamKind::Type,\n-                chalk_ir::VariableKind::Lifetime => panic!(\"Got lifetime parameter\"),\n-                chalk_ir::VariableKind::Const(ty) => ParamKind::Const(ty.clone()),\n-            })\n-            .collect();\n-        TyBuilder::new(b, param_kinds)\n-    }\n-\n     pub fn build(self) -> T {\n         let (b, subst) = self.build_internal();\n         b.substitute(Interner, &subst)\n     }\n }\n \n impl TyBuilder<Binders<Ty>> {\n-    pub fn def_ty(db: &dyn HirDatabase, def: TyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.ty(def))\n+    pub fn def_ty(\n+        db: &dyn HirDatabase,\n+        def: TyDefId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<Binders<Ty>> {\n+        let poly_ty = db.ty(def);\n+        let id: GenericDefId = match def {\n+            TyDefId::BuiltinType(_) => {\n+                assert!(parent_subst.is_none());\n+                return TyBuilder::new_empty(poly_ty);\n+            }\n+            TyDefId::AdtId(id) => id.into(),\n+            TyDefId::TypeAliasId(id) => id.into(),\n+        };\n+        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_ty)\n     }\n \n     pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.impl_self_ty(def))\n+        TyBuilder::subst_for_def(db, def, None).with_data(db.impl_self_ty(def))\n     }\n \n-    pub fn value_ty(db: &dyn HirDatabase, def: ValueTyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.value_ty(def))\n+    pub fn value_ty(\n+        db: &dyn HirDatabase,\n+        def: ValueTyDefId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<Binders<Ty>> {\n+        let poly_value_ty = db.value_ty(def);\n+        let id = match def.to_generic_def_id() {\n+            Some(id) => id,\n+            None => {\n+                // static items\n+                assert!(parent_subst.is_none());\n+                return TyBuilder::new_empty(poly_value_ty);\n+            }\n+        };\n+        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_value_ty)\n     }\n }"}, {"sha": "3f3f8f7d0f2a2ac9d82b02fdb0439dd978713f0c", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -382,13 +382,12 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // `resume_type`, `yield_type`, and `return_type` of the generator in question.\n         let subst = TyBuilder::subst_for_generator(self.db, parent).fill_with_unknown().build();\n \n-        let len = subst.len(Interner);\n         let input_output = rust_ir::GeneratorInputOutputDatum {\n-            resume_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, len - 3))\n+            resume_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n                 .intern(Interner),\n-            yield_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, len - 2))\n+            yield_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 1))\n                 .intern(Interner),\n-            return_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, len - 1))\n+            return_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 2))\n                 .intern(Interner),\n             // FIXME: calculate upvars\n             upvars: vec![],\n@@ -476,10 +475,15 @@ pub(crate) fn associated_ty_data_query(\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::ParamLoweringMode::Variable);\n-    let pro_ty = TyBuilder::assoc_type_projection(db, type_alias)\n+\n+    let trait_subst = TyBuilder::subst_for_def(db, trait_, None)\n+        .fill_with_bound_vars(crate::DebruijnIndex::INNERMOST, generic_params.len_self())\n+        .build();\n+    let pro_ty = TyBuilder::assoc_type_projection(db, type_alias, Some(trait_subst))\n         .fill_with_bound_vars(crate::DebruijnIndex::INNERMOST, 0)\n         .build();\n     let self_ty = TyKind::Alias(AliasTy::Projection(pro_ty)).intern(Interner);\n+\n     let mut bounds: Vec<_> = type_alias_data\n         .bounds\n         .iter()"}, {"sha": "4f0e9dbf1e4e9f1ab313bf3bec2d533c8ae4c2f6", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -152,7 +152,7 @@ impl TyExt for Ty {\n             TyKind::FnDef(def, parameters) => {\n                 let callable_def = db.lookup_intern_callable_def((*def).into());\n                 let sig = db.callable_item_signature(callable_def);\n-                Some(sig.substitute(Interner, &parameters))\n+                Some(sig.substitute(Interner, parameters))\n             }\n             TyKind::Closure(.., substs) => {\n                 let sig_param = substs.at(Interner, 0).assert_ty_ref(Interner);"}, {"sha": "7f0baf49dadce9e510a0b133d811b2fde49ff19c", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -27,7 +27,7 @@ use crate::{\n     db::HirDatabase,\n     from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n     mapping::from_chalk,\n-    primitive, subst_prefix, to_assoc_type_id,\n+    primitive, to_assoc_type_id,\n     utils::{self, generics},\n     AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstValue, DomainGoal,\n     GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives, Mutability,\n@@ -506,8 +506,15 @@ impl HirDisplay for Ty {\n                     let total_len = parent_params + self_param + type_params + const_params;\n                     // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n                     if total_len > 0 {\n+                        // `parameters` are in the order of fn's params (including impl traits),\n+                        // parent's params (those from enclosing impl or trait, if any).\n+                        let parameters = parameters.as_slice(Interner);\n+                        let fn_params_len = self_param + type_params + const_params;\n+                        let fn_params = parameters.get(..fn_params_len);\n+                        let parent_params = parameters.get(parameters.len() - parent_params..);\n+                        let params = parent_params.into_iter().chain(fn_params).flatten();\n                         write!(f, \"<\")?;\n-                        f.write_joined(&parameters.as_slice(Interner)[..total_len], \", \")?;\n+                        f.write_joined(params, \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 }\n@@ -579,9 +586,8 @@ impl HirDisplay for Ty {\n                                         Some(x) => x,\n                                         None => return true,\n                                     };\n-                                    let actual_default = default_parameter\n-                                        .clone()\n-                                        .substitute(Interner, &subst_prefix(parameters, i));\n+                                    let actual_default =\n+                                        default_parameter.clone().substitute(Interner, &parameters);\n                                     parameter != &actual_default\n                                 }\n                                 let mut default_from = 0;"}, {"sha": "31e56dec62593770bb938e2ddaa7dc7f6b39731c", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -26,8 +26,8 @@ use hir_def::{\n     path::{path, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n-    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule, Lookup,\n-    TraitId, TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n+    ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{name, Name};\n use itertools::Either;\n@@ -713,6 +713,8 @@ impl<'a> InferenceContext<'a> {\n         &mut self,\n         inner_ty: Ty,\n         assoc_ty: Option<TypeAliasId>,\n+        // FIXME(GATs): these are args for the trait ref, args for assoc type itself should be\n+        // handled when we support them.\n         params: &[GenericArg],\n     ) -> Ty {\n         match assoc_ty {\n@@ -804,7 +806,18 @@ impl<'a> InferenceContext<'a> {\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n             }\n             TypeNs::TypeAliasId(it) => {\n-                let ty = TyBuilder::def_ty(self.db, it.into())\n+                let container = it.lookup(self.db.upcast()).container;\n+                let parent_subst = match container {\n+                    ItemContainerId::TraitId(id) => {\n+                        let subst = TyBuilder::subst_for_def(self.db, id, None)\n+                            .fill_with_inference_vars(&mut self.table)\n+                            .build();\n+                        Some(subst)\n+                    }\n+                    // Type aliases do not exist in impls.\n+                    _ => None,\n+                };\n+                let ty = TyBuilder::def_ty(self.db, it.into(), parent_subst)\n                     .fill_with_inference_vars(&mut self.table)\n                     .build();\n                 self.resolve_variant_on_alias(ty, unresolved, path)"}, {"sha": "f56108b26c45bdaea3096f4616828c28ba260d12", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -987,11 +987,13 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n-            self.db.trait_data(self.resolve_lang_item(lang_item)?.as_trait()?).method_by_name(&name)\n+        let trait_func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+            let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;\n+            let func = self.db.trait_data(trait_id).method_by_name(&name)?;\n+            Some((trait_id, func))\n         });\n-        let func = match func {\n-            Some(func) => func,\n+        let (trait_, func) = match trait_func {\n+            Some(it) => it,\n             None => {\n                 let rhs_ty = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone());\n                 let rhs_ty = self.infer_expr_coerce(rhs, &Expectation::from_option(rhs_ty));\n@@ -1001,7 +1003,9 @@ impl<'a> InferenceContext<'a> {\n             }\n         };\n \n-        let subst = TyBuilder::subst_for_def(self.db, func)\n+        // HACK: We can use this substitution for the function because the function itself doesn't\n+        // have its own generic parameters.\n+        let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n             .push(lhs_ty.clone())\n             .push(rhs_ty.clone())\n             .build();\n@@ -1280,19 +1284,7 @@ impl<'a> InferenceContext<'a> {\n         assert_eq!(self_params, 0); // method shouldn't have another Self param\n         let total_len = parent_params + type_params + const_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n-        // Parent arguments are unknown\n-        for (id, param) in def_generics.iter_parent() {\n-            match param {\n-                TypeOrConstParamData::TypeParamData(_) => {\n-                    substs.push(GenericArgData::Ty(self.table.new_type_var()).intern(Interner));\n-                }\n-                TypeOrConstParamData::ConstParamData(_) => {\n-                    let ty = self.db.const_param_ty(ConstParamId::from_unchecked(id));\n-                    substs\n-                        .push(GenericArgData::Const(self.table.new_const_var(ty)).intern(Interner));\n-                }\n-            }\n-        }\n+\n         // handle provided arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n@@ -1301,7 +1293,7 @@ impl<'a> InferenceContext<'a> {\n                 .iter()\n                 .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n                 .take(type_params + const_params)\n-                .zip(def_generics.iter_id().skip(parent_params))\n+                .zip(def_generics.iter_id())\n             {\n                 if let Some(g) = generic_arg_to_chalk(\n                     self.db,\n@@ -1325,6 +1317,9 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n         };\n+\n+        // Handle everything else as unknown. This also handles generic arguments for the method's\n+        // parent (impl or trait), which should come after those for the method.\n         for (id, data) in def_generics.iter().skip(substs.len()) {\n             match data {\n                 TypeOrConstParamData::TypeParamData(_) => {\n@@ -1362,9 +1357,13 @@ impl<'a> InferenceContext<'a> {\n                 CallableDefId::FunctionId(f) => {\n                     if let ItemContainerId::TraitId(trait_) = f.lookup(self.db.upcast()).container {\n                         // construct a TraitRef\n-                        let substs = crate::subst_prefix(\n-                            &*parameters,\n-                            generics(self.db.upcast(), trait_.into()).len(),\n+                        let params_len = parameters.len(Interner);\n+                        let trait_params_len = generics(self.db.upcast(), trait_.into()).len();\n+                        let substs = Substitution::from_iter(\n+                            Interner,\n+                            // The generic parameters for the trait come after those for the\n+                            // function.\n+                            &parameters.as_slice(Interner)[params_len - trait_params_len..],\n                         );\n                         self.push_obligation(\n                             TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs }"}, {"sha": "7a4754cdc7bb899848ea9b032825945407e13850", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -12,8 +12,8 @@ use crate::{\n     builder::ParamKind,\n     consteval,\n     method_resolution::{self, VisibleFromModule},\n-    GenericArgData, Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n-    ValueTyDefId,\n+    utils::generics,\n+    Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind, ValueTyDefId,\n };\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n@@ -96,17 +96,21 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::GenericParam(it) => return Some(self.db.const_param_ty(it)),\n         };\n \n-        let parent_substs = self_subst.unwrap_or_else(|| Substitution::empty(Interner));\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let substs = ctx.substs_from_path(path, typable, true);\n-        let mut it = substs.as_slice(Interner)[parent_substs.len(Interner)..].iter().cloned();\n-        let ty = TyBuilder::value_ty(self.db, typable)\n-            .use_parent_substs(&parent_substs)\n+        let substs = substs.as_slice(Interner);\n+        let parent_substs = self_subst.or_else(|| {\n+            let generics = generics(self.db.upcast(), typable.to_generic_def_id()?);\n+            let parent_params_len = generics.parent_generics()?.len();\n+            let parent_args = &substs[substs.len() - parent_params_len..];\n+            Some(Substitution::from_iter(Interner, parent_args))\n+        });\n+        let parent_substs_len = parent_substs.as_ref().map_or(0, |s| s.len(Interner));\n+        let mut it = substs.iter().take(substs.len() - parent_substs_len).cloned();\n+        let ty = TyBuilder::value_ty(self.db, typable, parent_substs)\n             .fill(|x| {\n                 it.next().unwrap_or_else(|| match x {\n-                    ParamKind::Type => {\n-                        GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n-                    }\n+                    ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n                     ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })\n@@ -249,7 +253,7 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let substs = match container {\n                     ItemContainerId::ImplId(impl_id) => {\n-                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id)\n+                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n                             .fill_with_inference_vars(&mut self.table)\n                             .build();\n                         let impl_self_ty ="}, {"sha": "6ccd0b215c6e480e72e17ed62a663ffc2d02ad9c", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -598,11 +598,14 @@ impl<'a> InferenceTable<'a> {\n             .build();\n \n         let projection = {\n-            let b = TyBuilder::assoc_type_projection(self.db, output_assoc_type);\n+            let b = TyBuilder::subst_for_def(self.db, fn_once_trait, None);\n             if b.remaining() != 2 {\n                 return None;\n             }\n-            b.push(ty.clone()).push(arg_ty).build()\n+            let fn_once_subst = b.push(ty.clone()).push(arg_ty).build();\n+\n+            TyBuilder::assoc_type_projection(self.db, output_assoc_type, Some(fn_once_subst))\n+                .build()\n         };\n \n         let trait_env = self.trait_env.env.clone();"}, {"sha": "0a4b1dfda105555888fbcc9248101e241d379236", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 129, "deletions": 81, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -306,7 +306,7 @@ impl<'a> TyLoweringContext<'a> {\n                         // FIXME we're probably doing something wrong here\n                         self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n                         let (\n-                            parent_params,\n+                            _parent_params,\n                             self_params,\n                             list_params,\n                             const_params,\n@@ -319,7 +319,7 @@ impl<'a> TyLoweringContext<'a> {\n                         };\n                         TyKind::BoundVar(BoundVar::new(\n                             self.in_binders,\n-                            idx as usize + parent_params + self_params + list_params + const_params,\n+                            idx as usize + self_params + list_params + const_params,\n                         ))\n                         .intern(Interner)\n                     }\n@@ -499,14 +499,31 @@ impl<'a> TyLoweringContext<'a> {\n                 .intern(Interner)\n             }\n             TypeNs::SelfType(impl_id) => {\n-                let generics = generics(self.db.upcast(), impl_id.into());\n-                let substs = match self.type_param_mode {\n-                    ParamLoweringMode::Placeholder => generics.placeholder_subst(self.db),\n+                let def =\n+                    self.resolver.generic_def().expect(\"impl should have generic param scope\");\n+                let generics = generics(self.db.upcast(), def);\n+\n+                match self.type_param_mode {\n+                    ParamLoweringMode::Placeholder => {\n+                        // `def` can be either impl itself or item within, and we need impl itself\n+                        // now.\n+                        let generics = generics.parent_generics().unwrap_or(&generics);\n+                        let subst = generics.placeholder_subst(self.db);\n+                        self.db.impl_self_ty(impl_id).substitute(Interner, &subst)\n+                    }\n                     ParamLoweringMode::Variable => {\n-                        generics.bound_vars_subst(self.db, self.in_binders)\n+                        let starting_from = match def {\n+                            GenericDefId::ImplId(_) => 0,\n+                            // `def` is an item within impl. We need to substitute `BoundVar`s but\n+                            // remember that they are for parent (i.e. impl) generic params so they\n+                            // come after our own params.\n+                            _ => generics.len_self(),\n+                        };\n+                        TyBuilder::impl_self_ty(self.db, impl_id)\n+                            .fill_with_bound_vars(self.in_binders, starting_from)\n+                            .build()\n                     }\n-                };\n-                self.db.impl_self_ty(impl_id).substitute(Interner, &substs)\n+                }\n             }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(self.db.upcast(), adt.into());\n@@ -636,67 +653,54 @@ impl<'a> TyLoweringContext<'a> {\n         infer_args: bool,\n     ) -> Substitution {\n         let last = path.segments().last().expect(\"path should have at least one segment\");\n-        let (segment, generic_def) = match resolved {\n-            ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n-            ValueTyDefId::StructId(it) => (last, Some(it.into())),\n-            ValueTyDefId::UnionId(it) => (last, Some(it.into())),\n-            ValueTyDefId::ConstId(it) => (last, Some(it.into())),\n-            ValueTyDefId::StaticId(_) => (last, None),\n-            ValueTyDefId::EnumVariantId(var) => {\n+        let generic_def = resolved.to_generic_def_id();\n+        let segment = match resolved {\n+            ValueTyDefId::EnumVariantId(_) => {\n                 // the generic args for an enum variant may be either specified\n                 // on the segment referring to the enum, or on the segment\n                 // referring to the variant. So `Option::<T>::None` and\n                 // `Option::None::<T>` are both allowed (though the former is\n                 // preferred). See also `def_ids_for_path_segments` in rustc.\n                 let len = path.segments().len();\n                 let penultimate = len.checked_sub(2).and_then(|idx| path.segments().get(idx));\n-                let segment = match penultimate {\n+                match penultimate {\n                     Some(segment) if segment.args_and_bindings.is_some() => segment,\n                     _ => last,\n-                };\n-                (segment, Some(var.parent.into()))\n+                }\n             }\n+            _ => last,\n         };\n         self.substs_from_path_segment(segment, generic_def, infer_args, None)\n     }\n \n     fn substs_from_path_segment(\n         &self,\n         segment: PathSegment<'_>,\n-        def_generic: Option<GenericDefId>,\n+        def: Option<GenericDefId>,\n         infer_args: bool,\n         explicit_self_ty: Option<Ty>,\n     ) -> Substitution {\n+        // Remember that the item's own generic args come before its parent's.\n         let mut substs = Vec::new();\n-        let def_generics = if let Some(def) = def_generic {\n-            generics(self.db.upcast(), def)\n+        let def = if let Some(d) = def {\n+            d\n         } else {\n             return Substitution::empty(Interner);\n         };\n+        let def_generics = generics(self.db.upcast(), def);\n         let (parent_params, self_params, type_params, const_params, impl_trait_params) =\n             def_generics.provenance_split();\n-        let total_len =\n-            parent_params + self_params + type_params + const_params + impl_trait_params;\n+        let item_len = self_params + type_params + const_params + impl_trait_params;\n+        let total_len = parent_params + item_len;\n \n-        let ty_error = GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner);\n+        let ty_error = TyKind::Error.intern(Interner).cast(Interner);\n \n         let mut def_generic_iter = def_generics.iter_id();\n \n-        for _ in 0..parent_params {\n-            if let Some(eid) = def_generic_iter.next() {\n-                match eid {\n-                    Either::Left(_) => substs.push(ty_error.clone()),\n-                    Either::Right(x) => {\n-                        substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n-                    }\n-                }\n-            }\n-        }\n-\n         let fill_self_params = || {\n             for x in explicit_self_ty\n                 .into_iter()\n-                .map(|x| GenericArgData::Ty(x).intern(Interner))\n+                .map(|x| x.cast(Interner))\n                 .chain(iter::repeat(ty_error.clone()))\n                 .take(self_params)\n             {\n@@ -757,37 +761,40 @@ impl<'a> TyLoweringContext<'a> {\n             fill_self_params();\n         }\n \n+        // These params include those of parent.\n+        let remaining_params: SmallVec<[_; 2]> = def_generic_iter\n+            .map(|eid| match eid {\n+                Either::Left(_) => ty_error.clone(),\n+                Either::Right(x) => unknown_const_as_generic(self.db.const_param_ty(x)),\n+            })\n+            .collect();\n+        assert_eq!(remaining_params.len() + substs.len(), total_len);\n+\n         // handle defaults. In expression or pattern path segments without\n         // explicitly specified type arguments, missing type arguments are inferred\n         // (i.e. defaults aren't used).\n         if !infer_args || had_explicit_args {\n-            if let Some(def_generic) = def_generic {\n-                let defaults = self.db.generic_defaults(def_generic);\n-                assert_eq!(total_len, defaults.len());\n-\n-                for default_ty in defaults.iter().skip(substs.len()) {\n-                    // each default can depend on the previous parameters\n-                    let substs_so_far = Substitution::from_iter(Interner, substs.clone());\n-                    if let Some(_id) = def_generic_iter.next() {\n-                        substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n-                    }\n-                }\n+            let defaults = self.db.generic_defaults(def);\n+            assert_eq!(total_len, defaults.len());\n+            let parent_from = item_len - substs.len();\n+\n+            for (idx, default_ty) in defaults[substs.len()..item_len].iter().enumerate() {\n+                // each default can depend on the previous parameters\n+                let substs_so_far = Substitution::from_iter(\n+                    Interner,\n+                    substs.iter().cloned().chain(remaining_params[idx..].iter().cloned()),\n+                );\n+                substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n             }\n-        }\n \n-        // add placeholders for args that were not provided\n-        // FIXME: emit diagnostics in contexts where this is not allowed\n-        for eid in def_generic_iter {\n-            match eid {\n-                Either::Left(_) => substs.push(ty_error.clone()),\n-                Either::Right(x) => {\n-                    substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n-                }\n-            }\n+            // Keep parent's params as unknown.\n+            let mut remaining_params = remaining_params;\n+            substs.extend(remaining_params.drain(parent_from..));\n+        } else {\n+            substs.extend(remaining_params);\n         }\n-        // If this assert fails, it means you pushed into subst but didn't call .next() of def_generic_iter\n-        assert_eq!(substs.len(), total_len);\n \n+        assert_eq!(substs.len(), total_len);\n         Substitution::from_iter(Interner, substs)\n     }\n \n@@ -1168,10 +1175,18 @@ fn named_associated_type_shorthand_candidates<R>(\n             }\n             // Handle `Self::Type` referring to own associated type in trait definitions\n             if let GenericDefId::TraitId(trait_id) = param_id.parent() {\n-                let generics = generics(db.upcast(), trait_id.into());\n-                if generics.params.type_or_consts[param_id.local_id()].is_trait_self() {\n+                let trait_generics = generics(db.upcast(), trait_id.into());\n+                if trait_generics.params.type_or_consts[param_id.local_id()].is_trait_self() {\n+                    let def_generics = generics(db.upcast(), def);\n+                    let starting_idx = match def {\n+                        GenericDefId::TraitId(_) => 0,\n+                        // `def` is an item within trait. We need to substitute `BoundVar`s but\n+                        // remember that they are for parent (i.e. trait) generic params so they\n+                        // come after our own params.\n+                        _ => def_generics.len_self(),\n+                    };\n                     let trait_ref = TyBuilder::trait_ref(db, trait_id)\n-                        .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n+                        .fill_with_bound_vars(DebruijnIndex::INNERMOST, starting_idx)\n                         .build();\n                     return search(trait_ref);\n                 }\n@@ -1413,6 +1428,7 @@ pub(crate) fn generic_defaults_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let generic_params = generics(db.upcast(), def);\n+    let parent_start_idx = generic_params.len_self();\n \n     let defaults = generic_params\n         .iter()\n@@ -1425,19 +1441,17 @@ pub(crate) fn generic_defaults_query(\n                     let val = unknown_const_as_generic(\n                         db.const_param_ty(ConstParamId::from_unchecked(id)),\n                     );\n-                    return crate::make_binders_with_count(db, idx, &generic_params, val);\n+                    return make_binders(db, &generic_params, val);\n                 }\n             };\n             let mut ty =\n                 p.default.as_ref().map_or(TyKind::Error.intern(Interner), |t| ctx.lower_ty(t));\n \n             // Each default can only refer to previous parameters.\n-            // type variable default referring to parameter coming\n-            // after it. This is forbidden (FIXME: report\n-            // diagnostic)\n-            ty = fallback_bound_vars(ty, idx);\n-            let val = GenericArgData::Ty(ty).intern(Interner);\n-            crate::make_binders_with_count(db, idx, &generic_params, val)\n+            // Type variable default referring to parameter coming\n+            // after it is forbidden (FIXME: report diagnostic)\n+            ty = fallback_bound_vars(ty, idx, parent_start_idx);\n+            crate::make_binders(db, &generic_params, ty.cast(Interner))\n         })\n         .collect();\n \n@@ -1454,15 +1468,14 @@ pub(crate) fn generic_defaults_recover(\n     // we still need one default per parameter\n     let defaults = generic_params\n         .iter_id()\n-        .enumerate()\n-        .map(|(count, id)| {\n+        .map(|id| {\n             let val = match id {\n                 itertools::Either::Left(_) => {\n                     GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n                 }\n                 itertools::Either::Right(id) => unknown_const_as_generic(db.const_param_ty(id)),\n             };\n-            crate::make_binders_with_count(db, count, &generic_params, val)\n+            crate::make_binders(db, &generic_params, val)\n         })\n         .collect();\n \n@@ -1641,6 +1654,19 @@ pub enum ValueTyDefId {\n }\n impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for ValueTyDefId);\n \n+impl ValueTyDefId {\n+    pub(crate) fn to_generic_def_id(self) -> Option<GenericDefId> {\n+        match self {\n+            Self::FunctionId(id) => Some(id.into()),\n+            Self::StructId(id) => Some(id.into()),\n+            Self::UnionId(id) => Some(id.into()),\n+            Self::EnumVariantId(var) => Some(var.parent.into()),\n+            Self::ConstId(id) => Some(id.into()),\n+            Self::StaticId(_) => None,\n+        }\n+    }\n+}\n+\n /// Build the declared type of an item. This depends on the namespace; e.g. for\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values\n@@ -1824,26 +1850,48 @@ pub(crate) fn const_or_path_to_chalk(\n     }\n }\n \n-/// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n-/// num_vars_to_keep) by `TyKind::Unknown`.\n+/// Replaces any 'free' `BoundVar`s in `s` by `TyKind::Error` from the perspective of generic\n+/// parameter whose index is `param_index`. A `BoundVar` is free when it is or (syntactically)\n+/// appears after the generic parameter of `param_index`.\n fn fallback_bound_vars<T: TypeFoldable<Interner> + HasInterner<Interner = Interner>>(\n     s: T,\n-    num_vars_to_keep: usize,\n+    param_index: usize,\n+    parent_start: usize,\n ) -> T {\n+    // Keep in mind that parent generic parameters, if any, come *after* those of the item in\n+    // question. In the diagrams below, `c*` and `p*` represent generic parameters of the item and\n+    // its parent respectively.\n+    let is_allowed = |index| {\n+        if param_index < parent_start {\n+            // The parameter of `param_index` is one from the item in question. Any parent generic\n+            // parameters or the item's generic parameters that come before `param_index` is\n+            // allowed.\n+            // [c1, .., cj, .., ck, p1, .., pl] where cj is `param_index`\n+            //  ^^^^^^              ^^^^^^^^^^ these are allowed\n+            !(param_index..parent_start).contains(&index)\n+        } else {\n+            // The parameter of `param_index` is one from the parent generics. Only parent generic\n+            // parameters that come before `param_index` are allowed.\n+            // [c1, .., ck, p1, .., pj, .., pl] where pj is `param_index`\n+            //              ^^^^^^ these are allowed\n+            (parent_start..param_index).contains(&index)\n+        }\n+    };\n+\n     crate::fold_free_vars(\n         s,\n         |bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                TyKind::Error.intern(Interner)\n-            } else {\n+            if bound.index_if_innermost().map_or(true, is_allowed) {\n                 bound.shifted_in_from(binders).to_ty(Interner)\n+            } else {\n+                TyKind::Error.intern(Interner)\n             }\n         },\n         |ty, bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                unknown_const(ty.clone())\n-            } else {\n+            if bound.index_if_innermost().map_or(true, is_allowed) {\n                 bound.shifted_in_from(binders).to_const(Interner, ty)\n+            } else {\n+                unknown_const(ty.clone())\n             }\n         },\n     )"}, {"sha": "5998680dcd395390dcee0197baf6c8b6052a8acb", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -654,7 +654,7 @@ fn find_matching_impl(\n         let r = table.run_in_snapshot(|table| {\n             let impl_data = db.impl_data(impl_);\n             let substs =\n-                TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n+                TyBuilder::subst_for_def(db, impl_, None).fill_with_inference_vars(table).build();\n             let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n \n             table\n@@ -1147,10 +1147,9 @@ fn is_valid_candidate(\n             }));\n             if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n                 let self_ty_matches = table.run_in_snapshot(|table| {\n-                    let subst =\n-                        TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n-                    let expected_self_ty =\n-                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n+                    let expected_self_ty = TyBuilder::impl_self_ty(db, impl_id)\n+                        .fill_with_inference_vars(table)\n+                        .build();\n                     table.unify(&expected_self_ty, &self_ty)\n                 });\n                 if !self_ty_matches {\n@@ -1186,31 +1185,26 @@ fn is_valid_fn_candidate(\n \n     table.run_in_snapshot(|table| {\n         let container = fn_id.lookup(db.upcast()).container;\n-        let impl_subst = match container {\n+        let (impl_subst, expect_self_ty) = match container {\n             ItemContainerId::ImplId(it) => {\n-                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+                let subst =\n+                    TyBuilder::subst_for_def(db, it, None).fill_with_inference_vars(table).build();\n+                let self_ty = db.impl_self_ty(it).substitute(Interner, &subst);\n+                (subst, self_ty)\n             }\n             ItemContainerId::TraitId(it) => {\n-                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+                let subst =\n+                    TyBuilder::subst_for_def(db, it, None).fill_with_inference_vars(table).build();\n+                let self_ty = subst.at(Interner, 0).assert_ty_ref(Interner).clone();\n+                (subst, self_ty)\n             }\n             _ => unreachable!(),\n         };\n \n-        let fn_subst = TyBuilder::subst_for_def(db, fn_id)\n-            .use_parent_substs(&impl_subst)\n+        let fn_subst = TyBuilder::subst_for_def(db, fn_id, Some(impl_subst.clone()))\n             .fill_with_inference_vars(table)\n             .build();\n \n-        let expect_self_ty = match container {\n-            ItemContainerId::TraitId(_) => fn_subst.at(Interner, 0).assert_ty_ref(Interner).clone(),\n-            ItemContainerId::ImplId(impl_id) => {\n-                fn_subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n-            }\n-            // We should only get called for associated items (impl/trait)\n-            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                unreachable!()\n-            }\n-        };\n         check_that!(table.unify(&expect_self_ty, self_ty));\n \n         if let Some(receiver_ty) = receiver_ty {"}, {"sha": "16ba3dd6e3c97a87953df6f9103af984c2a98121", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -1488,7 +1488,6 @@ fn regression_11688_4() {\n \n #[test]\n fn gat_crash_1() {\n-    cov_mark::check!(ignore_gats);\n     check_no_mismatches(\n         r#\"\n trait ATrait {}\n@@ -1527,30 +1526,22 @@ unsafe impl Storage for InlineStorage {\n \n #[test]\n fn gat_crash_3() {\n-    // FIXME: This test currently crashes rust analyzer in a debug build but not in a\n-    // release build (i.e. for the user). With the assumption that tests will always be run\n-    // in debug mode, we catch the unwind and expect that it panicked. See the\n-    // [`crate::utils::generics`] function for more information.\n-    cov_mark::check!(ignore_gats);\n-    std::panic::catch_unwind(|| {\n-        check_no_mismatches(\n-            r#\"\n+    check_no_mismatches(\n+        r#\"\n trait Collection {\n-    type Item;\n-    type Member<T>: Collection<Item = T>;\n-    fn add(&mut self, value: Self::Item) -> Result<(), Self::Error>;\n+type Item;\n+type Member<T>: Collection<Item = T>;\n+fn add(&mut self, value: Self::Item) -> Result<(), Self::Error>;\n }\n struct ConstGen<T, const N: usize> {\n-    data: [T; N],\n+data: [T; N],\n }\n impl<T, const N: usize> Collection for ConstGen<T, N> {\n-    type Item = T;\n-    type Member<U> = ConstGen<U, N>;\n+type Item = T;\n+type Member<U> = ConstGen<U, N>;\n }\n-        \"#,\n-        );\n-    })\n-    .expect_err(\"must panic\");\n+    \"#,\n+    );\n }\n \n #[test]"}, {"sha": "e54bcb421a222222b8a21be500079c034ce737f2", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 38, "deletions": 63, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -4,7 +4,7 @@\n use std::iter;\n \n use base_db::CrateId;\n-use chalk_ir::{fold::Shift, BoundVar, DebruijnIndex};\n+use chalk_ir::{cast::Cast, fold::Shift, BoundVar, DebruijnIndex};\n use hir_def::{\n     db::DefDatabase,\n     generics::{\n@@ -24,8 +24,7 @@ use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n use crate::{\n-    db::HirDatabase, ChalkTraitId, ConstData, ConstValue, GenericArgData, Interner, Substitution,\n-    TraitRef, TraitRefExt, TyKind, WhereClause,\n+    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, WhereClause,\n };\n \n pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n@@ -174,31 +173,6 @@ pub(super) fn associated_type_by_name_including_super_traits(\n \n pub(crate) fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {\n     let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n-    if parent_generics.is_some() && matches!(def, GenericDefId::TypeAliasId(_)) {\n-        let params = db.generic_params(def);\n-        let parent_params = &parent_generics.as_ref().unwrap().params;\n-        let has_consts =\n-            params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n-        let parent_has_consts =\n-            parent_params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n-        return if has_consts || parent_has_consts {\n-            // XXX: treat const generic associated types as not existing to avoid crashes\n-            // (#11769)\n-            //\n-            // Note: Also crashes when the parent has const generics (also even if the GAT\n-            // doesn't use them), see `tests::regression::gat_crash_3` for an example.\n-            // Avoids that by disabling GATs when the parent (i.e. `impl` block) has\n-            // const generics (#12193).\n-            //\n-            // Chalk expects the inner associated type's parameters to come\n-            // *before*, not after the trait's generics as we've always done it.\n-            // Adapting to this requires a larger refactoring\n-            cov_mark::hit!(ignore_gats);\n-            Generics { def, params: Interned::new(Default::default()), parent_generics }\n-        } else {\n-            Generics { def, params, parent_generics }\n-        };\n-    }\n     Generics { def, params: db.generic_params(def), parent_generics }\n }\n \n@@ -221,36 +195,49 @@ impl Generics {\n         })\n     }\n \n-    /// Iterator over types and const params of parent, then self.\n+    /// Iterator over types and const params of self, then parent.\n     pub(crate) fn iter<'a>(\n         &'a self,\n     ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         let to_toc_id = |it: &'a Generics| {\n             move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p)\n         };\n-        self.parent_generics()\n-            .into_iter()\n-            .flat_map(move |it| it.params.iter().map(to_toc_id(it)))\n-            .chain(self.params.iter().map(to_toc_id(self)))\n+        self.params.iter().map(to_toc_id(self)).chain(self.iter_parent())\n+    }\n+\n+    /// Iterate over types and const params without parent params.\n+    pub(crate) fn iter_self<'a>(\n+        &'a self,\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+        let to_toc_id = |it: &'a Generics| {\n+            move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p)\n+        };\n+        self.params.iter().map(to_toc_id(self))\n     }\n \n     /// Iterator over types and const params of parent.\n     pub(crate) fn iter_parent<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         self.parent_generics().into_iter().flat_map(|it| {\n             let to_toc_id =\n                 move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p);\n             it.params.iter().map(to_toc_id)\n         })\n     }\n \n+    /// Returns total number of generic parameters in scope, including those from parent.\n     pub(crate) fn len(&self) -> usize {\n         let parent = self.parent_generics().map_or(0, Generics::len);\n         let child = self.params.type_or_consts.len();\n         parent + child\n     }\n \n+    /// Returns numbers of generic parameters excluding those from parent.\n+    pub(crate) fn len_self(&self) -> usize {\n+        self.params.type_or_consts.len()\n+    }\n+\n     /// (parent total, self param, type param list, const param list, impl trait)\n     pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize, usize) {\n         let ty_iter = || self.params.iter().filter_map(|x| x.1.type_param());\n@@ -275,15 +262,17 @@ impl Generics {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) =\n                 self.params.iter().enumerate().find(|(_, (idx, _))| *idx == param.local_id)?;\n-            let parent_len = self.parent_generics().map_or(0, Generics::len);\n-            Some((parent_len + idx, data))\n+            Some((idx, data))\n         } else {\n-            self.parent_generics().and_then(|g| g.find_param(param))\n+            self.parent_generics()\n+                .and_then(|g| g.find_param(param))\n+                // Remember that parent parameters come after parameters for self.\n+                .map(|(idx, data)| (self.len_self() + idx, data))\n         }\n     }\n \n-    fn parent_generics(&self) -> Option<&Generics> {\n-        self.parent_generics.as_ref().map(|it| &**it)\n+    pub(crate) fn parent_generics(&self) -> Option<&Generics> {\n+        self.parent_generics.as_deref()\n     }\n \n     /// Returns a Substitution that replaces each parameter by a bound variable.\n@@ -295,18 +284,10 @@ impl Generics {\n         Substitution::from_iter(\n             Interner,\n             self.iter_id().enumerate().map(|(idx, id)| match id {\n-                Either::Left(_) => GenericArgData::Ty(\n-                    TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner),\n-                )\n-                .intern(Interner),\n-                Either::Right(id) => GenericArgData::Const(\n-                    ConstData {\n-                        value: ConstValue::BoundVar(BoundVar::new(debruijn, idx)),\n-                        ty: db.const_param_ty(id),\n-                    }\n-                    .intern(Interner),\n-                )\n-                .intern(Interner),\n+                Either::Left(_) => BoundVar::new(debruijn, idx).to_ty(Interner).cast(Interner),\n+                Either::Right(id) => BoundVar::new(debruijn, idx)\n+                    .to_const(Interner, db.const_param_ty(id))\n+                    .cast(Interner),\n             }),\n         )\n     }\n@@ -316,18 +297,12 @@ impl Generics {\n         Substitution::from_iter(\n             Interner,\n             self.iter_id().map(|id| match id {\n-                Either::Left(id) => GenericArgData::Ty(\n-                    TyKind::Placeholder(crate::to_placeholder_idx(db, id.into())).intern(Interner),\n-                )\n-                .intern(Interner),\n-                Either::Right(id) => GenericArgData::Const(\n-                    ConstData {\n-                        value: ConstValue::Placeholder(crate::to_placeholder_idx(db, id.into())),\n-                        ty: db.const_param_ty(id),\n-                    }\n-                    .intern(Interner),\n-                )\n-                .intern(Interner),\n+                Either::Left(id) => {\n+                    crate::to_placeholder_idx(db, id.into()).to_ty(Interner).cast(Interner)\n+                }\n+                Either::Right(id) => crate::to_placeholder_idx(db, id.into())\n+                    .to_const(Interner, db.const_param_ty(id))\n+                    .cast(Interner),\n             }),\n         )\n     }"}, {"sha": "e08dd8dadebc5759dd38fc4ae061933712caf718", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -61,7 +61,6 @@ use hir_ty::{\n     diagnostics::BodyValidationDiagnostic,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n-    subst_prefix,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n     GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n@@ -1090,7 +1089,7 @@ impl Adt {\n     pub fn ty_with_args(self, db: &dyn HirDatabase, args: &[Type]) -> Type {\n         let id = AdtId::from(self);\n         let mut it = args.iter().map(|t| t.ty.clone());\n-        let ty = TyBuilder::def_ty(db, id.into())\n+        let ty = TyBuilder::def_ty(db, id.into(), None)\n             .fill(|x| {\n                 let r = it.next().unwrap_or_else(|| TyKind::Error.intern(Interner));\n                 match x {\n@@ -2547,7 +2546,7 @@ impl TypeParam {\n         let resolver = self.id.parent().resolver(db.upcast());\n         let ty = params.get(local_idx)?.clone();\n         let subst = TyBuilder::placeholder_subst(db, self.id.parent());\n-        let ty = ty.substitute(Interner, &subst_prefix(&subst, local_idx));\n+        let ty = ty.substitute(Interner, &subst);\n         match ty.data(Interner) {\n             GenericArgData::Ty(x) => Some(Type::new_with_resolver_inner(db, &resolver, x.clone())),\n             _ => None,\n@@ -2801,7 +2800,18 @@ impl Type {\n     }\n \n     fn from_def(db: &dyn HirDatabase, def: impl HasResolver + Into<TyDefId>) -> Type {\n-        let ty = TyBuilder::def_ty(db, def.into()).fill_with_unknown().build();\n+        let ty_def = def.into();\n+        let parent_subst = match ty_def {\n+            TyDefId::TypeAliasId(id) => match id.lookup(db.upcast()).container {\n+                ItemContainerId::TraitId(id) => {\n+                    let subst = TyBuilder::subst_for_def(db, id, None).fill_with_unknown().build();\n+                    Some(subst)\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        let ty = TyBuilder::def_ty(db, ty_def, parent_subst).fill_with_unknown().build();\n         Type::new(db, def, ty)\n     }\n \n@@ -2941,7 +2951,11 @@ impl Type {\n         alias: TypeAlias,\n     ) -> Option<Type> {\n         let mut args = args.iter();\n-        let projection = TyBuilder::assoc_type_projection(db, alias.id)\n+        let trait_id = match alias.id.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(id) => id,\n+            _ => unreachable!(\"non assoc type alias reached in normalize_trait_assoc_type()\"),\n+        };\n+        let parent_subst = TyBuilder::subst_for_def(db, trait_id, None)\n             .push(self.ty.clone())\n             .fill(|x| {\n                 // FIXME: this code is not covered in tests.\n@@ -2953,6 +2967,8 @@ impl Type {\n                 }\n             })\n             .build();\n+        // FIXME: We don't handle GATs yet.\n+        let projection = TyBuilder::assoc_type_projection(db, alias.id, Some(parent_subst)).build();\n \n         let ty = db.normalize_projection(projection, self.env.clone());\n         if ty.is_unknown() {"}, {"sha": "07bae2b38c796b3ee6698ae09785e61e71bcf7a9", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd98e36bc2102643cc6a93c2b894dd6a74be1c2/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=5bd98e36bc2102643cc6a93c2b894dd6a74be1c2", "patch": "@@ -22,7 +22,7 @@ use hir_def::{\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n     AsMacroCall, AssocItemId, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId,\n-    Lookup, ModuleDefId, VariantId,\n+    Lookup, ModuleDefId, TraitId, VariantId,\n };\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander,\n@@ -302,10 +302,15 @@ impl SourceAnalyzer {\n             }\n         }\n \n+        let future_trait = db\n+            .lang_item(self.resolver.krate(), hir_expand::name![future_trait].to_smol_str())?\n+            .as_trait()?;\n         let poll_fn = db\n             .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n             .as_function()?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, poll_fn).push(ty.clone()).build();\n+        // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n         Some(self.resolve_impl_method_or_trait_def(db, poll_fn, &substs))\n     }\n \n@@ -321,8 +326,10 @@ impl SourceAnalyzer {\n         };\n         let ty = self.ty_of_expr(db, &prefix_expr.expr()?.into())?;\n \n-        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        // HACK: subst for all methods coincides with that for their trait because the methods\n+        // don't have any generic parameters, so we skip building another subst for the methods.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -337,8 +344,10 @@ impl SourceAnalyzer {\n \n         let lang_item_name = name![index];\n \n-        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn)\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        // HACK: subst for all methods coincides with that for their trait because the methods\n+        // don't have any generic parameters, so we skip building another subst for the methods.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n             .push(base_ty.clone())\n             .push(index_ty.clone())\n             .build();\n@@ -354,10 +363,14 @@ impl SourceAnalyzer {\n         let lhs = self.ty_of_expr(db, &binop_expr.lhs()?.into())?;\n         let rhs = self.ty_of_expr(db, &binop_expr.rhs()?.into())?;\n \n-        let op_fn = lang_names_for_bin_op(op)\n+        let (op_trait, op_fn) = lang_names_for_bin_op(op)\n             .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n-        let substs =\n-            hir_ty::TyBuilder::subst_for_def(db, op_fn).push(lhs.clone()).push(rhs.clone()).build();\n+        // HACK: subst for `index()` coincides with that for `Index` because `index()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `index()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n+            .push(lhs.clone())\n+            .push(rhs.clone())\n+            .build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -371,7 +384,13 @@ impl SourceAnalyzer {\n \n         let op_fn =\n             db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+        let op_trait = match op_fn.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(id) => id,\n+            _ => return None,\n+        };\n+        // HACK: subst for `branch()` coincides with that for `Try` because `branch()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `branch()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -799,9 +818,10 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         lang_trait: &Name,\n         method_name: &Name,\n-    ) -> Option<FunctionId> {\n-        db.trait_data(db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?)\n-            .method_by_name(method_name)\n+    ) -> Option<(TraitId, FunctionId)> {\n+        let trait_id = db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?;\n+        let fn_id = db.trait_data(trait_id).method_by_name(method_name)?;\n+        Some((trait_id, fn_id))\n     }\n \n     fn ty_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<&Ty> {"}]}