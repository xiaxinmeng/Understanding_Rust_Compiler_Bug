{"sha": "3d8778d767f0dde6fe2bc9459f21ead8e124d8cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkODc3OGQ3NjdmMGRkZTZmZTJiYzk0NTlmMjFlYWQ4ZTEyNGQ4Y2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-26T08:36:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-26T08:36:23Z"}, "message": "Auto merge of #68522 - estebank:impl-trait-sugg-2, r=oli-obk\n\nFurther improve `impl Trait`/`dyn Trait` suggestions\n\nAfter reading [_Returning Trait Objects_ by Bryce Fisher-Fleig](https://bryce.fisher-fleig.org/blog/returning-trait-objects/), [I noticed that](https://www.reddit.com/r/rust/comments/esueur/returning_trait_objects/ffczl4k/) #68195 had a few bugs due to not ignoring `ty::Error`.\n\n- Account for `ty::Error`.\n- Account for `if`/`else` and `match` blocks when pointing at return types and referencing their types.\n- Increase the multiline suggestion output from 6 lines to 20.", "tree": {"sha": "275bf8e6df726e09789e7143b3ee5e1ecb0baf46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/275bf8e6df726e09789e7143b3ee5e1ecb0baf46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb", "html_url": "https://github.com/rust-lang/rust/commit/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe1e81561aa1c0ba5779709d081107ea0bfa08e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe1e81561aa1c0ba5779709d081107ea0bfa08e5", "html_url": "https://github.com/rust-lang/rust/commit/fe1e81561aa1c0ba5779709d081107ea0bfa08e5"}, {"sha": "16709f032cfaa0b37a83bc798f0dd4a30d2b2c0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/16709f032cfaa0b37a83bc798f0dd4a30d2b2c0c", "html_url": "https://github.com/rust-lang/rust/commit/16709f032cfaa0b37a83bc798f0dd4a30d2b2c0c"}], "stats": {"total": 285, "additions": 262, "deletions": 23}, "files": [{"sha": "72629c6a3cffabd73389ca49a9fbe1fcf6910335", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=3d8778d767f0dde6fe2bc9459f21ead8e124d8cb", "patch": "@@ -601,17 +601,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // Visit to make sure there's a single `return` type to suggest `impl Trait`,\n         // otherwise suggest using `Box<dyn Trait>` or an enum.\n-        let mut visitor = ReturnsVisitor(vec![]);\n+        let mut visitor = ReturnsVisitor::default();\n         visitor.visit_body(&body);\n \n         let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n \n-        let mut ret_types = visitor.0.iter().filter_map(|expr| tables.node_type_opt(expr.hir_id));\n-        let (last_ty, all_returns_have_same_type) =\n-            ret_types.clone().fold((None, true), |(last_ty, mut same), returned_ty| {\n-                same &= last_ty.map_or(true, |ty| ty == returned_ty);\n-                (Some(returned_ty), same)\n-            });\n+        let mut ret_types = visitor\n+            .returns\n+            .iter()\n+            .filter_map(|expr| tables.node_type_opt(expr.hir_id))\n+            .map(|ty| self.resolve_vars_if_possible(&ty));\n+        let (last_ty, all_returns_have_same_type) = ret_types.clone().fold(\n+            (None, true),\n+            |(last_ty, mut same): (std::option::Option<Ty<'_>>, bool), ty| {\n+                let ty = self.resolve_vars_if_possible(&ty);\n+                same &= last_ty.map_or(true, |last_ty| last_ty == ty) && ty.kind != ty::Error;\n+                (Some(ty), same)\n+            },\n+        );\n         let all_returns_conform_to_trait =\n             if let Some(ty_ret_ty) = tables.node_type_opt(ret_ty.hir_id) {\n                 match ty_ret_ty.kind {\n@@ -626,7 +633,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             })\n                         })\n                     }\n-                    _ => true,\n+                    _ => false,\n                 }\n             } else {\n                 true\n@@ -676,7 +683,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n                 // Get all the return values and collect their span and suggestion.\n                 let mut suggestions = visitor\n-                    .0\n+                    .returns\n                     .iter()\n                     .map(|expr| {\n                         (\n@@ -736,10 +743,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         {\n             let body = hir.body(*body_id);\n             // Point at all the `return`s in the function as they have failed trait bounds.\n-            let mut visitor = ReturnsVisitor(vec![]);\n+            let mut visitor = ReturnsVisitor::default();\n             visitor.visit_body(&body);\n             let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n-            for expr in &visitor.0 {\n+            for expr in &visitor.returns {\n                 if let Some(returned_ty) = tables.node_type_opt(expr.hir_id) {\n                     let ty = self.resolve_vars_if_possible(&returned_ty);\n                     err.span_label(expr.span, &format!(\"this returned value is of type `{}`\", ty));\n@@ -1716,7 +1723,11 @@ pub fn suggest_constraining_type_param(\n \n /// Collect all the returned expressions within the input expression.\n /// Used to point at the return spans when we want to suggest some change to them.\n-struct ReturnsVisitor<'v>(Vec<&'v hir::Expr<'v>>);\n+#[derive(Default)]\n+struct ReturnsVisitor<'v> {\n+    returns: Vec<&'v hir::Expr<'v>>,\n+    in_block_tail: bool,\n+}\n \n impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n     type Map = rustc::hir::map::Map<'v>;\n@@ -1726,17 +1737,41 @@ impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n     }\n \n     fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n-        if let hir::ExprKind::Ret(Some(ex)) = ex.kind {\n-            self.0.push(ex);\n+        // Visit every expression to detect `return` paths, either through the function's tail\n+        // expression or `return` statements. We walk all nodes to find `return` statements, but\n+        // we only care about tail expressions when `in_block_tail` is `true`, which means that\n+        // they're in the return path of the function body.\n+        match ex.kind {\n+            hir::ExprKind::Ret(Some(ex)) => {\n+                self.returns.push(ex);\n+            }\n+            hir::ExprKind::Block(block, _) if self.in_block_tail => {\n+                self.in_block_tail = false;\n+                for stmt in block.stmts {\n+                    hir::intravisit::walk_stmt(self, stmt);\n+                }\n+                self.in_block_tail = true;\n+                if let Some(expr) = block.expr {\n+                    self.visit_expr(expr);\n+                }\n+            }\n+            hir::ExprKind::Match(_, arms, _) if self.in_block_tail => {\n+                for arm in arms {\n+                    self.visit_expr(arm.body);\n+                }\n+            }\n+            // We need to walk to find `return`s in the entire body.\n+            _ if !self.in_block_tail => hir::intravisit::walk_expr(self, ex),\n+            _ => self.returns.push(ex),\n         }\n-        hir::intravisit::walk_expr(self, ex);\n     }\n \n     fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n+        assert!(!self.in_block_tail);\n         if body.generator_kind().is_none() {\n             if let hir::ExprKind::Block(block, None) = body.value.kind {\n-                if let Some(expr) = block.expr {\n-                    self.0.push(expr);\n+                if block.expr.is_some() {\n+                    self.in_block_tail = true;\n                 }\n             }\n         }"}, {"sha": "7218730538a4b40c54ee013aa74d9ac4ab2bf160", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=3d8778d767f0dde6fe2bc9459f21ead8e124d8cb", "patch": "@@ -456,9 +456,14 @@ impl Emitter for SilentEmitter {\n     fn emit_diagnostic(&mut self, _: &Diagnostic) {}\n }\n \n-/// maximum number of lines we will print for each error; arbitrary.\n+/// Maximum number of lines we will print for each error; arbitrary.\n pub const MAX_HIGHLIGHT_LINES: usize = 6;\n-/// maximum number of suggestions to be shown\n+/// Maximum number of lines we will print for a multiline suggestion; arbitrary.\n+///\n+/// This should be replaced with a more involved mechanism to output multiline suggestions that\n+/// more closely mimmics the regular diagnostic output, where irrelevant code lines are elided.\n+pub const MAX_SUGGESTION_HIGHLIGHT_LINES: usize = 6;\n+/// Maximum number of suggestions to be shown\n ///\n /// Arbitrary, but taken from trait import suggestion limit\n pub const MAX_SUGGESTIONS: usize = 4;\n@@ -1521,7 +1526,7 @@ impl EmitterWriter {\n             draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n             let mut line_pos = 0;\n             let mut lines = complete.lines();\n-            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+            for line in lines.by_ref().take(MAX_SUGGESTION_HIGHLIGHT_LINES) {\n                 // Print the span column to avoid confusion\n                 buffer.puts(\n                     row_num,"}, {"sha": "08bab5734fd7a0a3c01d0d7bfb9969da8a2c20e7", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs?ref=3d8778d767f0dde6fe2bc9459f21ead8e124d8cb", "patch": "@@ -22,6 +22,39 @@ fn bal() -> dyn Trait { //~ ERROR E0746\n     }\n     42\n }\n+fn bax() -> dyn Trait { //~ ERROR E0746\n+    if true {\n+        Struct\n+    } else {\n+        42\n+    }\n+}\n+fn bam() -> Box<dyn Trait> {\n+    if true {\n+        return Struct; //~ ERROR mismatched types\n+    }\n+    42 //~ ERROR mismatched types\n+}\n+fn baq() -> Box<dyn Trait> {\n+    if true {\n+        return 0; //~ ERROR mismatched types\n+    }\n+    42 //~ ERROR mismatched types\n+}\n+fn baz() -> Box<dyn Trait> {\n+    if true {\n+        Struct //~ ERROR mismatched types\n+    } else {\n+        42 //~ ERROR mismatched types\n+    }\n+}\n+fn baw() -> Box<dyn Trait> {\n+    if true {\n+        0 //~ ERROR mismatched types\n+    } else {\n+        42 //~ ERROR mismatched types\n+    }\n+}\n \n // Suggest using `impl Trait`\n fn bat() -> dyn Trait { //~ ERROR E0746\n@@ -30,5 +63,12 @@ fn bat() -> dyn Trait { //~ ERROR E0746\n     }\n     42\n }\n+fn bay() -> dyn Trait { //~ ERROR E0746\n+    if true {\n+        0\n+    } else {\n+        42\n+    }\n+}\n \n fn main() {}"}, {"sha": "664a897c593fc90f252dc951c3b50bcec23f4c7f", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "modified", "additions": 161, "deletions": 2, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=3d8778d767f0dde6fe2bc9459f21ead8e124d8cb", "patch": "@@ -96,7 +96,154 @@ LL |     Box::new(42)\n    |\n \n error[E0746]: return type cannot have an unboxed trait object\n-  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:27:13\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:25:13\n+   |\n+LL | fn bax() -> dyn Trait {\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl Trait` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn bax() -> Box<dyn Trait> {\n+LL |     if true {\n+LL |         Box::new(Struct)\n+LL |     } else {\n+LL |         Box::new(42)\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:34:16\n+   |\n+LL | fn bam() -> Box<dyn Trait> {\n+   |             -------------- expected `std::boxed::Box<(dyn Trait + 'static)>` because of return type\n+LL |     if true {\n+LL |         return Struct;\n+   |                ^^^^^^\n+   |                |\n+   |                expected struct `std::boxed::Box`, found struct `Struct`\n+   |                help: store this in the heap by calling `Box::new`: `Box::new(Struct)`\n+   |\n+   = note: expected struct `std::boxed::Box<(dyn Trait + 'static)>`\n+              found struct `Struct`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:36:5\n+   |\n+LL | fn bam() -> Box<dyn Trait> {\n+   |             -------------- expected `std::boxed::Box<(dyn Trait + 'static)>` because of return type\n+...\n+LL |     42\n+   |     ^^\n+   |     |\n+   |     expected struct `std::boxed::Box`, found integer\n+   |     help: store this in the heap by calling `Box::new`: `Box::new(42)`\n+   |\n+   = note: expected struct `std::boxed::Box<(dyn Trait + 'static)>`\n+                found type `{integer}`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:40:16\n+   |\n+LL | fn baq() -> Box<dyn Trait> {\n+   |             -------------- expected `std::boxed::Box<(dyn Trait + 'static)>` because of return type\n+LL |     if true {\n+LL |         return 0;\n+   |                ^\n+   |                |\n+   |                expected struct `std::boxed::Box`, found integer\n+   |                help: store this in the heap by calling `Box::new`: `Box::new(0)`\n+   |\n+   = note: expected struct `std::boxed::Box<(dyn Trait + 'static)>`\n+                found type `{integer}`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:42:5\n+   |\n+LL | fn baq() -> Box<dyn Trait> {\n+   |             -------------- expected `std::boxed::Box<(dyn Trait + 'static)>` because of return type\n+...\n+LL |     42\n+   |     ^^\n+   |     |\n+   |     expected struct `std::boxed::Box`, found integer\n+   |     help: store this in the heap by calling `Box::new`: `Box::new(42)`\n+   |\n+   = note: expected struct `std::boxed::Box<(dyn Trait + 'static)>`\n+                found type `{integer}`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:46:9\n+   |\n+LL | fn baz() -> Box<dyn Trait> {\n+   |             -------------- expected `std::boxed::Box<(dyn Trait + 'static)>` because of return type\n+LL |     if true {\n+LL |         Struct\n+   |         ^^^^^^\n+   |         |\n+   |         expected struct `std::boxed::Box`, found struct `Struct`\n+   |         help: store this in the heap by calling `Box::new`: `Box::new(Struct)`\n+   |\n+   = note: expected struct `std::boxed::Box<(dyn Trait + 'static)>`\n+              found struct `Struct`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:48:9\n+   |\n+LL | fn baz() -> Box<dyn Trait> {\n+   |             -------------- expected `std::boxed::Box<(dyn Trait + 'static)>` because of return type\n+...\n+LL |         42\n+   |         ^^\n+   |         |\n+   |         expected struct `std::boxed::Box`, found integer\n+   |         help: store this in the heap by calling `Box::new`: `Box::new(42)`\n+   |\n+   = note: expected struct `std::boxed::Box<(dyn Trait + 'static)>`\n+                found type `{integer}`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:53:9\n+   |\n+LL | fn baw() -> Box<dyn Trait> {\n+   |             -------------- expected `std::boxed::Box<(dyn Trait + 'static)>` because of return type\n+LL |     if true {\n+LL |         0\n+   |         ^\n+   |         |\n+   |         expected struct `std::boxed::Box`, found integer\n+   |         help: store this in the heap by calling `Box::new`: `Box::new(0)`\n+   |\n+   = note: expected struct `std::boxed::Box<(dyn Trait + 'static)>`\n+                found type `{integer}`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:55:9\n+   |\n+LL | fn baw() -> Box<dyn Trait> {\n+   |             -------------- expected `std::boxed::Box<(dyn Trait + 'static)>` because of return type\n+...\n+LL |         42\n+   |         ^^\n+   |         |\n+   |         expected struct `std::boxed::Box`, found integer\n+   |         help: store this in the heap by calling `Box::new`: `Box::new(42)`\n+   |\n+   = note: expected struct `std::boxed::Box<(dyn Trait + 'static)>`\n+                found type `{integer}`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:60:13\n    |\n LL | fn bat() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n@@ -107,7 +254,19 @@ help: return `impl Trait` instead, as all return paths are of type `{integer}`,\n LL | fn bat() -> impl Trait {\n    |             ^^^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:66:13\n+   |\n+LL | fn bay() -> dyn Trait {\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `{integer}`, which implements `Trait`\n+   |\n+LL | fn bay() -> impl Trait {\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to 19 previous errors\n \n Some errors have detailed explanations: E0277, E0308, E0746.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "08e16f46936455417b7605703356f2dbd57a3c75", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=3d8778d767f0dde6fe2bc9459f21ead8e124d8cb", "patch": "@@ -5,7 +5,7 @@ LL | fn should_ret_unit() -> impl T {\n    |                         ^^^^^^ the trait `T` is not implemented for `()`\n LL |\n LL |     panic!()\n-   |     -------- this returned value is of type `()`\n+   |     -------- this returned value is of type `!`\n    |\n    = note: the return type of a function must have a statically known size\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)"}]}