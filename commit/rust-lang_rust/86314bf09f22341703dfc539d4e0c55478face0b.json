{"sha": "86314bf09f22341703dfc539d4e0c55478face0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MzE0YmYwOWYyMjM0MTcwM2RmYzUzOWQ0ZTBjNTU0NzhmYWNlMGI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-10T03:14:44Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: more refactoring of visual formatting", "tree": {"sha": "a65176da04a61cbc3531757ec52ef0f292b91670", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a65176da04a61cbc3531757ec52ef0f292b91670"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86314bf09f22341703dfc539d4e0c55478face0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86314bf09f22341703dfc539d4e0c55478face0b", "html_url": "https://github.com/rust-lang/rust/commit/86314bf09f22341703dfc539d4e0c55478face0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86314bf09f22341703dfc539d4e0c55478face0b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92701552bcdcd29dd93f72bd5055f96caf2d25c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/92701552bcdcd29dd93f72bd5055f96caf2d25c6", "html_url": "https://github.com/rust-lang/rust/commit/92701552bcdcd29dd93f72bd5055f96caf2d25c6"}], "stats": {"total": 70, "additions": 31, "deletions": 39}, "files": [{"sha": "9f06b240c7ce50185dc5f335dab7144b3738b089", "filename": "src/chains.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/86314bf09f22341703dfc539d4e0c55478face0b/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86314bf09f22341703dfc539d4e0c55478face0b/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=86314bf09f22341703dfc539d4e0c55478face0b", "patch": "@@ -189,9 +189,9 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         shape.block_indent(context.config.tab_spaces())\n     }.with_max_width(context.config);\n \n-    let mut rewrites: Vec<String> = Vec::with_capacity(children.len());\n+    let mut rewrites: Vec<String> = Vec::with_capacity(children.len() + 2);\n     rewrites.push(root_rewrite);\n-    let mut is_block_like = Vec::with_capacity(children.len());\n+    let mut is_block_like = Vec::with_capacity(children.len() + 2);\n     is_block_like.push(root_ends_with_block);\n     for item in children {\n         let rewrite = rewrite_chain_subexpr(&item.expr, context, child_shape)?;\n@@ -314,60 +314,53 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n     Some(result)\n }\n \n-fn rewrite_chain_visual(mut chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let last = chain.children.pop().unwrap();\n-\n+fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     let parent_shape = if is_block_expr(context, &chain.parent.expr, \"\\n\") {\n         shape.visual_indent(0)\n     } else {\n         shape\n     };\n-    let parent_rewrite = chain.parent.expr\n+    let mut children: &[_] = &chain.children;\n+    let mut root_rewrite = chain.parent.expr\n         .rewrite(context, parent_shape)\n         .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n-    let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n \n-    let other_child_shape = shape.visual_indent(0).with_max_width(context.config);\n+    if !root_rewrite.contains('\\n') && is_continuable(&chain.parent.expr) {\n+        let item = &children[0];\n+        let overhead = last_line_width(&root_rewrite);\n+        let shape = parent_shape.offset_left(overhead)?;\n+        let rewrite = rewrite_chain_subexpr(&item.expr, context, shape)?;\n+        root_rewrite.push_str(&rewrite);\n+        root_rewrite.push_str(&\"?\".repeat(item.tries));\n+        children = &children[1..];\n+        if children.is_empty() {\n+            return Some(root_rewrite);\n+        }\n+    }\n \n-    // Decide how to layout the rest of the chain. `extend` is true if we can\n-    // put the first non-parent item on the same line as the parent.\n-    let extend = !parent_rewrite_contains_newline && is_continuable(&chain.parent.expr);\n+    let last = &children[children.len() - 1];\n+    children = &children[..children.len() - 1];\n \n-    let first_child_shape = if extend {\n-        let overhead = last_line_width(&parent_rewrite);\n-        parent_shape.offset_left(overhead)?\n-    } else {\n-        other_child_shape\n-    };\n-    debug!(\n-        \"child_shapes {:?} {:?}\",\n-        first_child_shape, other_child_shape\n-    );\n+    let child_shape = shape.visual_indent(0).with_max_width(context.config);\n \n-    let mut rewrites: Vec<String> = Vec::with_capacity(chain.children.len());\n-    for (i, item) in chain.children.iter().enumerate() {\n-        let shape = if i == 0 {\n-            first_child_shape\n-        } else {\n-            other_child_shape\n-        };\n-        let rewrite = rewrite_chain_subexpr(&item.expr, context, shape)?;\n+    let mut rewrites: Vec<String> = Vec::with_capacity(children.len() + 2);\n+    rewrites.push(root_rewrite);\n+    for item in chain.children.iter() {\n+        let rewrite = rewrite_chain_subexpr(&item.expr, context, child_shape)?;\n         rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n     }\n \n     // Total of all items excluding the last.\n-    let almost_total = rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len() + last.tries;\n-    let one_line_budget = if rewrites.is_empty() {\n+    let almost_total = rewrites.iter().fold(0, |a, b| a + b.len()) + last.tries;\n+    let one_line_budget = if rewrites.len() == 1 {\n         shape.width\n     } else {\n         min(shape.width, context.config.width_heuristics().chain_width)\n     };\n-    let all_in_one_line = !parent_rewrite_contains_newline\n-        && rewrites.iter().all(|s| !s.contains('\\n'))\n+    let all_in_one_line = rewrites.iter().all(|s| !s.contains('\\n'))\n         && almost_total < one_line_budget;\n-    let last_shape =\n-        other_child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n+    let last_shape = child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n \n     // Rewrite the last child. The last child of a chain requires special treatment. We need to\n     // know whether 'overflowing' the last child make a better formatting:\n@@ -445,19 +438,18 @@ fn rewrite_chain_visual(mut chain: Chain, context: &RewriteContext, shape: Shape\n     last_subexpr_str = last_subexpr_str.or_else(|| rewrite_chain_subexpr(&last.expr, context, last_shape));\n     rewrites.push(last_subexpr_str?);\n \n-    let connector = if fits_single_line && !parent_rewrite_contains_newline {\n+    let connector = if fits_single_line && all_in_one_line {\n         // Yay, we can put everything on one line.\n         Cow::from(\"\")\n     } else {\n         // Use new lines.\n         if *context.force_one_line_chain.borrow() {\n             return None;\n         }\n-        other_child_shape.indent.to_string_with_newline(context.config)\n+        child_shape.indent.to_string_with_newline(context.config)\n     };\n \n-    let result = format!(\"{}{}{}\",\n-        parent_rewrite,\n+    let result = format!(\"{}{}\",\n         join_rewrites_vis(&rewrites, &connector),\n         \"?\".repeat(last.tries),\n     );"}]}