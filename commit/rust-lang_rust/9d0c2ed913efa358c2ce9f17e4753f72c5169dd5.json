{"sha": "9d0c2ed913efa358c2ce9f17e4753f72c5169dd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMGMyZWQ5MTNlZmEzNThjMmNlOWYxN2U0NzUzZjcyYzUxNjlkZDU=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-11T22:20:14Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Factor out `SplitVarLenSlice` used for slice splitting", "tree": {"sha": "068545efb3f7eacfb3b76998b1d597a1b0139105", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/068545efb3f7eacfb3b76998b1d597a1b0139105"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d0c2ed913efa358c2ce9f17e4753f72c5169dd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d0c2ed913efa358c2ce9f17e4753f72c5169dd5", "html_url": "https://github.com/rust-lang/rust/commit/9d0c2ed913efa358c2ce9f17e4753f72c5169dd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d0c2ed913efa358c2ce9f17e4753f72c5169dd5/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7948f919108b43d69debcf7ed57d8944407463dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7948f919108b43d69debcf7ed57d8944407463dd", "html_url": "https://github.com/rust-lang/rust/commit/7948f919108b43d69debcf7ed57d8944407463dd"}], "stats": {"total": 222, "additions": 117, "deletions": 105}, "files": [{"sha": "3c6cade1634fdc92eba03de41f74b5d908dcdd1d", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 117, "deletions": 105, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/9d0c2ed913efa358c2ce9f17e4753f72c5169dd5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0c2ed913efa358c2ce9f17e4753f72c5169dd5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=9d0c2ed913efa358c2ce9f17e4753f72c5169dd5", "patch": "@@ -403,129 +403,141 @@ impl Slice {\n         self.kind.arity()\n     }\n \n-    /// The exhaustiveness-checking paper does not include any details on\n-    /// checking variable-length slice patterns. However, they may be\n-    /// matched by an infinite collection of fixed-length array patterns.\n-    ///\n-    /// Checking the infinite set directly would take an infinite amount\n-    /// of time. However, it turns out that for each finite set of\n-    /// patterns `P`, all sufficiently large array lengths are equivalent:\n-    ///\n-    /// Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n-    /// to exactly the subset `P\u209c` of `P` can be transformed to a slice\n-    /// `s\u2098` for each sufficiently-large length `m` that applies to exactly\n-    /// the same subset of `P`.\n-    ///\n-    /// Because of that, each witness for reachability-checking of one\n-    /// of the sufficiently-large lengths can be transformed to an\n-    /// equally-valid witness of any other length, so we only have\n-    /// to check slices of the \"minimal sufficiently-large length\"\n-    /// and less.\n-    ///\n-    /// Note that the fact that there is a *single* `s\u2098` for each `m`\n-    /// not depending on the specific pattern in `P` is important: if\n-    /// you look at the pair of patterns\n-    ///     `[true, ..]`\n-    ///     `[.., false]`\n-    /// Then any slice of length \u22651 that matches one of these two\n-    /// patterns can be trivially turned to a slice of any\n-    /// other length \u22651 that matches them and vice-versa,\n-    /// but the slice of length 2 `[false, true]` that matches neither\n-    /// of these patterns can't be turned to a slice from length 1 that\n-    /// matches neither of these patterns, so we have to consider\n-    /// slices from length 2 there.\n-    ///\n-    /// Now, to see that that length exists and find it, observe that slice\n-    /// patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n-    /// \"variable-length\" patterns (`[_, .., _]`).\n-    ///\n-    /// For fixed-length patterns, all slices with lengths *longer* than\n-    /// the pattern's length have the same outcome (of not matching), so\n-    /// as long as `L` is greater than the pattern's length we can pick\n-    /// any `s\u2098` from that length and get the same result.\n-    ///\n-    /// For variable-length patterns, the situation is more complicated,\n-    /// because as seen above the precise value of `s\u2098` matters.\n-    ///\n-    /// However, for each variable-length pattern `p` with a prefix of length\n-    /// `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n-    /// `sl\u209a` elements are examined.\n-    ///\n-    /// Therefore, as long as `L` is positive (to avoid concerns about empty\n-    /// types), all elements after the maximum prefix length and before\n-    /// the maximum suffix length are not examined by any variable-length\n-    /// pattern, and therefore can be added/removed without affecting\n-    /// them - creating equivalent patterns from any sufficiently-large\n-    /// length.\n-    ///\n-    /// Of course, if fixed-length patterns exist, we must be sure\n-    /// that our length is large enough to miss them all, so\n-    /// we can pick `L = max(max(FIXED_LEN)+1, max(PREFIX_LEN) + max(SUFFIX_LEN))`\n-    ///\n-    /// for example, with the above pair of patterns, all elements\n-    /// but the first and last can be added/removed, so any\n-    /// witness of length \u22652 (say, `[false, false, true]`) can be\n-    /// turned to a witness from any other length \u22652.\n+    /// Split this slice, as described at the top of the file.\n     fn split<'p, 'tcx>(self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n         let (self_prefix, self_suffix) = match self.kind {\n             VarLen(self_prefix, self_suffix) => (self_prefix, self_suffix),\n             _ => return smallvec![Slice(self)],\n         };\n \n-        let head_ctors = pcx.matrix.head_ctors(pcx.cx).filter(|c| !c.is_wildcard());\n+        let mut split_self = SplitVarLenSlice::new(self_prefix, self_suffix, self.array_len);\n+        let slices = pcx.matrix.head_ctors(pcx.cx).filter_map(|c| c.as_slice()).map(|s| s.kind);\n+        split_self.split(slices);\n+        split_self.iter().map(Slice).collect()\n+    }\n \n-        let mut max_prefix_len = self_prefix;\n-        let mut max_suffix_len = self_suffix;\n-        let mut max_fixed_len = 0;\n+    /// See `Constructor::is_covered_by`\n+    fn is_covered_by(self, other: Self) -> bool {\n+        other.kind.covers_length(self.arity())\n+    }\n+}\n \n-        for ctor in head_ctors {\n-            if let Slice(slice) = ctor {\n-                match slice.kind {\n-                    FixedLen(len) => {\n-                        max_fixed_len = cmp::max(max_fixed_len, len);\n-                    }\n-                    VarLen(prefix, suffix) => {\n-                        max_prefix_len = cmp::max(max_prefix_len, prefix);\n-                        max_suffix_len = cmp::max(max_suffix_len, suffix);\n-                    }\n+/// The exhaustiveness-checking paper does not include any details on checking variable-length\n+/// slice patterns. However, they may be matched by an infinite collection of fixed-length array\n+/// patterns.\n+///\n+/// Checking the infinite set directly would take an infinite amount of time. However, it turns out\n+/// that for each finite set of patterns `P`, all sufficiently large array lengths are equivalent:\n+///\n+/// Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies to exactly the subset\n+/// `P\u209c` of `P` can be transformed to a slice `s\u2098` for each sufficiently-large length `m` that\n+/// applies to exactly the same subset of `P`.\n+///\n+/// Because of that, each witness for reachability-checking of one of the sufficiently-large\n+/// lengths can be transformed to an equally-valid witness of any other length, so we only have to\n+/// check slices of the \"minimal sufficiently-large length\" and less.\n+///\n+/// Note that the fact that there is a *single* `s\u2098` for each `m` not depending on the specific\n+/// pattern in `P` is important: if you look at the pair of patterns `[true, ..]` `[.., false]`\n+/// Then any slice of length \u22651 that matches one of these two patterns can be trivially turned to a\n+/// slice of any other length \u22651 that matches them and vice-versa, but the slice of length 2\n+/// `[false, true]` that matches neither of these patterns can't be turned to a slice from length 1\n+/// that matches neither of these patterns, so we have to consider slices from length 2 there.\n+///\n+/// Now, to see that that length exists and find it, observe that slice patterns are either\n+/// \"fixed-length\" patterns (`[_, _, _]`) or \"variable-length\" patterns (`[_, .., _]`).\n+///\n+/// For fixed-length patterns, all slices with lengths *longer* than the pattern's length have the\n+/// same outcome (of not matching), so as long as `L` is greater than the pattern's length we can\n+/// pick any `s\u2098` from that length and get the same result.\n+///\n+/// For variable-length patterns, the situation is more complicated, because as seen above the\n+/// precise value of `s\u2098` matters.\n+///\n+/// However, for each variable-length pattern `p` with a prefix of length `pl\u209a` and suffix of\n+/// length `sl\u209a`, only the first `pl\u209a` and the last `sl\u209a` elements are examined.\n+///\n+/// Therefore, as long as `L` is positive (to avoid concerns about empty types), all elements after\n+/// the maximum prefix length and before the maximum suffix length are not examined by any\n+/// variable-length pattern, and therefore can be added/removed without affecting them - creating\n+/// equivalent patterns from any sufficiently-large length.\n+///\n+/// Of course, if fixed-length patterns exist, we must be sure that our length is large enough to\n+/// miss them all, so we can pick `L = max(max(FIXED_LEN)+1, max(PREFIX_LEN) + max(SUFFIX_LEN))`\n+///\n+/// `max_slice` below will be made to have arity `L`.\n+///\n+/// For example, with the above pair of patterns, all elements but the first and last can be\n+/// added/removed, so any witness of length \u22652 (say, `[false, false, true]`) can be turned to a\n+/// witness from any other length \u22652.\n+#[derive(Debug)]\n+struct SplitVarLenSlice {\n+    /// If the type is an array, this is its size.\n+    array_len: Option<u64>,\n+    /// The arity of the input slice.\n+    arity: u64,\n+    /// The smallest slice bigger than any slice seen. `max_slice.arity()` is the length `L`\n+    /// described above.\n+    max_slice: SliceKind,\n+}\n+\n+impl SplitVarLenSlice {\n+    fn new(prefix: u64, suffix: u64, array_len: Option<u64>) -> Self {\n+        SplitVarLenSlice { array_len, arity: prefix + suffix, max_slice: VarLen(prefix, suffix) }\n+    }\n+\n+    /// Pass a set of slices relative to which to split this one.\n+    fn split(&mut self, slices: impl Iterator<Item = SliceKind>) {\n+        let (max_prefix_len, max_suffix_len) = match &mut self.max_slice {\n+            VarLen(prefix, suffix) => (prefix, suffix),\n+            FixedLen(_) => return, // No need to split\n+        };\n+        // We grow `self.max_slice` to be larger than all slices encountered, as described above.\n+        // For diagnostics, we keep the prefix and suffix lengths separate, but grow them so that\n+        // `L = max_prefix_len + max_suffix_len`.\n+        let mut max_fixed_len = 0;\n+        for slice in slices {\n+            match slice {\n+                FixedLen(len) => {\n+                    max_fixed_len = cmp::max(max_fixed_len, len);\n+                }\n+                VarLen(prefix, suffix) => {\n+                    *max_prefix_len = cmp::max(*max_prefix_len, prefix);\n+                    *max_suffix_len = cmp::max(*max_suffix_len, suffix);\n                 }\n-            } else {\n-                bug!(\"unexpected ctor for slice type: {:?}\", ctor);\n             }\n         }\n-\n-        // For diagnostics, we keep the prefix and suffix lengths separate, so in the case\n-        // where `max_fixed_len + 1` is the largest, we adapt `max_prefix_len` accordingly,\n-        // so that `L = max_prefix_len + max_suffix_len`.\n-        if max_fixed_len + 1 >= max_prefix_len + max_suffix_len {\n+        // We want `L = max(L, max_fixed_len + 1)`, modulo the fact that we keep prefix and\n+        // suffix separate.\n+        if max_fixed_len + 1 >= *max_prefix_len + *max_suffix_len {\n             // The subtraction can't overflow thanks to the above check.\n-            // The new `max_prefix_len` is also guaranteed to be larger than its previous\n-            // value.\n-            max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n+            // The new `max_prefix_len` is larger than its previous value.\n+            *max_prefix_len = max_fixed_len + 1 - *max_suffix_len;\n         }\n \n-        let final_slice = VarLen(max_prefix_len, max_suffix_len);\n-        let final_slice = Slice::new(self.array_len, final_slice);\n+        // We cap the arity of `max_slice` at the array size.\n         match self.array_len {\n-            Some(_) => smallvec![Slice(final_slice)],\n-            None => {\n-                // `self` originally covered the range `(self.arity()..infinity)`. We split that\n-                // range into two: lengths smaller than `final_slice.arity()` are treated\n-                // independently as fixed-lengths slices, and lengths above are captured by\n-                // `final_slice`.\n-                let smaller_lengths = (self.arity()..final_slice.arity()).map(FixedLen);\n-                smaller_lengths\n-                    .map(|kind| Slice::new(self.array_len, kind))\n-                    .chain(Some(final_slice))\n-                    .map(Slice)\n-                    .collect()\n-            }\n+            Some(len) if self.max_slice.arity() >= len => self.max_slice = FixedLen(len),\n+            _ => {}\n         }\n     }\n \n-    /// See `Constructor::is_covered_by`\n-    fn is_covered_by(self, other: Self) -> bool {\n-        other.kind.covers_length(self.arity())\n+    /// Iterate over the partition of this slice.\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Slice> + Captures<'a> {\n+        let smaller_lengths = match self.array_len {\n+            // The only admissible fixed-length slice is one of the array size. Whether `max_slice`\n+            // is fixed-length or variable-length, it will be the only relevant slice to output\n+            // here.\n+            Some(_) => (0..0), // empty range\n+            // We cover all arities in the range `(self.arity..infinity)`. We split that range into\n+            // two: lengths smaller than `max_slice.arity()` are treated independently as\n+            // fixed-lengths slices, and lengths above are captured by `max_slice`.\n+            None => self.arity..self.max_slice.arity(),\n+        };\n+        smaller_lengths\n+            .map(FixedLen)\n+            .chain(once(self.max_slice))\n+            .map(move |kind| Slice::new(self.array_len, kind))\n     }\n }\n "}]}