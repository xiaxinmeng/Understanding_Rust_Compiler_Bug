{"sha": "3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMGQ2ZWUyNzFhMzRkMjMyOTIzNWI5YTA0Y2Y0YTQyMWQ5MDI2Y2Q=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-01T22:40:56Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-01T22:59:01Z"}, "message": "liballoc: Unconfigure tests during normal build\n\nRemove additional libcore-like restrictions from liballoc, turns out the testing works ok if the tests are a part of liballoc itself.", "tree": {"sha": "bdd574c1b42fe28031d69a18d7f7694ce8742021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdd574c1b42fe28031d69a18d7f7694ce8742021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "html_url": "https://github.com/rust-lang/rust/commit/3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "310b9fc76002066feb89dcfbf8e88b34fe5f4ad3", "url": "https://api.github.com/repos/rust-lang/rust/commits/310b9fc76002066feb89dcfbf8e88b34fe5f4ad3", "html_url": "https://github.com/rust-lang/rust/commit/310b9fc76002066feb89dcfbf8e88b34fe5f4ad3"}], "stats": {"total": 3389, "additions": 1682, "deletions": 1707}, "files": [{"sha": "dc7fd1adc295895016dd2c71f34df41355ca02ea", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -10,6 +10,9 @@ use core::usize;\n #[doc(inline)]\n pub use core::alloc::*;\n \n+#[cfg(test)]\n+mod tests;\n+\n extern \"Rust\" {\n     // These are the magic symbols to call the global allocator.  rustc generates\n     // them from the `#[global_allocator]` attribute if there is one, or uses the\n@@ -244,36 +247,3 @@ pub fn handle_alloc_error(layout: Layout) -> ! {\n     }\n     unsafe { oom_impl(layout) }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use test::Bencher;\n-    use crate::boxed::Box;\n-    use crate::alloc::{Global, Alloc, Layout, handle_alloc_error};\n-\n-    #[test]\n-    fn allocate_zeroed() {\n-        unsafe {\n-            let layout = Layout::from_size_align(1024, 1).unwrap();\n-            let ptr = Global.alloc_zeroed(layout.clone())\n-                .unwrap_or_else(|_| handle_alloc_error(layout));\n-\n-            let mut i = ptr.cast::<u8>().as_ptr();\n-            let end = i.add(layout.size());\n-            while i < end {\n-                assert_eq!(*i, 0);\n-                i = i.offset(1);\n-            }\n-            Global.dealloc(ptr, layout);\n-        }\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn alloc_owned_small(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = box 10;\n-        })\n-    }\n-}"}, {"sha": "c69f4e49ee1e3994e6621496129e54fceea84e52", "filename": "src/liballoc/alloc/tests.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -0,0 +1,30 @@\n+use super::*;\n+\n+extern crate test;\n+use test::Bencher;\n+use crate::boxed::Box;\n+\n+#[test]\n+fn allocate_zeroed() {\n+    unsafe {\n+        let layout = Layout::from_size_align(1024, 1).unwrap();\n+        let ptr = Global.alloc_zeroed(layout.clone())\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n+\n+        let mut i = ptr.cast::<u8>().as_ptr();\n+        let end = i.add(layout.size());\n+        while i < end {\n+            assert_eq!(*i, 0);\n+            i = i.offset(1);\n+        }\n+        Global.dealloc(ptr, layout);\n+    }\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn alloc_owned_small(b: &mut Bencher) {\n+    b.iter(|| {\n+        let _: Box<_> = box 10;\n+    })\n+}"}, {"sha": "a14a3fe9994abb59c517411f62ec9400ad22a6ef", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 3, "deletions": 270, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -23,6 +23,9 @@ use core::ptr::NonNull;\n use crate::boxed::Box;\n use super::SpecExtend;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A doubly-linked list with owned nodes.\n ///\n /// The `LinkedList` allows pushing and popping elements at either end\n@@ -1244,273 +1247,3 @@ unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::thread;\n-    use std::vec::Vec;\n-\n-    use rand::{thread_rng, RngCore};\n-\n-    use super::{LinkedList, Node};\n-\n-    #[cfg(test)]\n-    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n-        v.iter().cloned().collect()\n-    }\n-\n-    pub fn check_links<T>(list: &LinkedList<T>) {\n-        unsafe {\n-            let mut len = 0;\n-            let mut last_ptr: Option<&Node<T>> = None;\n-            let mut node_ptr: &Node<T>;\n-            match list.head {\n-                None => {\n-                    // tail node should also be None.\n-                    assert!(list.tail.is_none());\n-                    assert_eq!(0, list.len);\n-                    return;\n-                }\n-                Some(node) => node_ptr = &*node.as_ptr(),\n-            }\n-            loop {\n-                match (last_ptr, node_ptr.prev) {\n-                    (None, None) => {}\n-                    (None, _) => panic!(\"prev link for head\"),\n-                    (Some(p), Some(pptr)) => {\n-                        assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n-                    }\n-                    _ => panic!(\"prev link is none, not good\"),\n-                }\n-                match node_ptr.next {\n-                    Some(next) => {\n-                        last_ptr = Some(node_ptr);\n-                        node_ptr = &*next.as_ptr();\n-                        len += 1;\n-                    }\n-                    None => {\n-                        len += 1;\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            // verify that the tail node points to the last node.\n-            let tail = list.tail.as_ref().expect(\"some tail node\").as_ref();\n-            assert_eq!(tail as *const Node<T>, node_ptr as *const Node<T>);\n-            // check that len matches interior links.\n-            assert_eq!(len, list.len);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        // Empty to empty\n-        {\n-            let mut m = LinkedList::<i32>::new();\n-            let mut n = LinkedList::new();\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 0);\n-            assert_eq!(n.len(), 0);\n-        }\n-        // Non-empty to empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            n.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            assert_eq!(n.len(), 0);\n-            check_links(&m);\n-        }\n-        // Empty to non-empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            m.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-\n-        // Non-empty to non-empty\n-        let v = vec![1, 2, 3, 4, 5];\n-        let u = vec![9, 8, 1, 2, 3, 4, 5];\n-        let mut m = list_from(&v);\n-        let mut n = list_from(&u);\n-        m.append(&mut n);\n-        check_links(&m);\n-        let mut sum = v;\n-        sum.extend_from_slice(&u);\n-        assert_eq!(sum.len(), m.len());\n-        for elt in sum {\n-            assert_eq!(m.pop_front(), Some(elt))\n-        }\n-        assert_eq!(n.len(), 0);\n-        // let's make sure it's working properly, since we\n-        // did some direct changes to private members\n-        n.push_back(3);\n-        assert_eq!(n.len(), 1);\n-        assert_eq!(n.pop_front(), Some(3));\n-        check_links(&n);\n-    }\n-\n-    #[test]\n-    fn test_insert_prev() {\n-        let mut m = list_from(&[0, 2, 4, 6, 8]);\n-        let len = m.len();\n-        {\n-            let mut it = m.iter_mut();\n-            it.insert_next(-2);\n-            loop {\n-                match it.next() {\n-                    None => break,\n-                    Some(elt) => {\n-                        it.insert_next(*elt + 1);\n-                        match it.peek_next() {\n-                            Some(x) => assert_eq!(*x, *elt + 2),\n-                            None => assert_eq!(8, *elt),\n-                        }\n-                    }\n-                }\n-            }\n-            it.insert_next(0);\n-            it.insert_next(1);\n-        }\n-        check_links(&m);\n-        assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(),\n-                   [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg(not(miri))] // Miri does not support threads\n-    fn test_send() {\n-        let n = list_from(&[1, 2, 3]);\n-        thread::spawn(move || {\n-                check_links(&n);\n-                let a: &[_] = &[&1, &2, &3];\n-                assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n-            })\n-            .join()\n-            .ok()\n-            .unwrap();\n-    }\n-\n-    #[test]\n-    fn test_fuzz() {\n-        for _ in 0..25 {\n-            fuzz_test(3);\n-            fuzz_test(16);\n-            #[cfg(not(miri))] // Miri is too slow\n-            fuzz_test(189);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_26021() {\n-        // There was a bug in split_off that failed to null out the RHS's head's prev ptr.\n-        // This caused the RHS's dtor to walk up into the LHS at drop and delete all of\n-        // its nodes.\n-        //\n-        // https://github.com/rust-lang/rust/issues/26021\n-        let mut v1 = LinkedList::new();\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        let _ = v1.split_off(3); // Dropping this now should not cause laundry consumption\n-        assert_eq!(v1.len(), 3);\n-\n-        assert_eq!(v1.iter().len(), 3);\n-        assert_eq!(v1.iter().collect::<Vec<_>>().len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        let mut v1 = LinkedList::new();\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-\n-        // test all splits\n-        for ix in 0..1 + v1.len() {\n-            let mut a = v1.clone();\n-            let b = a.split_off(ix);\n-            check_links(&a);\n-            check_links(&b);\n-            a.extend(b);\n-            assert_eq!(v1, a);\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    fn fuzz_test(sz: i32) {\n-        let mut m: LinkedList<_> = LinkedList::new();\n-        let mut v = vec![];\n-        for i in 0..sz {\n-            check_links(&m);\n-            let r: u8 = thread_rng().next_u32() as u8;\n-            match r % 6 {\n-                0 => {\n-                    m.pop_back();\n-                    v.pop();\n-                }\n-                1 => {\n-                    if !v.is_empty() {\n-                        m.pop_front();\n-                        v.remove(0);\n-                    }\n-                }\n-                2 | 4 => {\n-                    m.push_front(-i);\n-                    v.insert(0, -i);\n-                }\n-                3 | 5 | _ => {\n-                    m.push_back(i);\n-                    v.push(i);\n-                }\n-            }\n-        }\n-\n-        check_links(&m);\n-\n-        let mut i = 0;\n-        for (a, &b) in m.into_iter().zip(&v) {\n-            i += 1;\n-            assert_eq!(a, b);\n-        }\n-        assert_eq!(i, v.len());\n-    }\n-\n-    #[test]\n-    fn drain_filter_test() {\n-        let mut m: LinkedList<u32> = LinkedList::new();\n-        m.extend(&[1, 2, 3, 4, 5, 6]);\n-        let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n-\n-        check_links(&m);\n-\n-        assert_eq!(deleted, &[1, 2, 3]);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n-    }\n-\n-    #[test]\n-    fn drain_to_empty_test() {\n-        let mut m: LinkedList<u32> = LinkedList::new();\n-        m.extend(&[1, 2, 3, 4, 5, 6]);\n-        let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n-\n-        check_links(&m);\n-\n-        assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n-    }\n-}"}, {"sha": "953b0d4eb28ee99c56a9bd3fc92f2348a714ea15", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -0,0 +1,265 @@\n+use super::*;\n+\n+use std::thread;\n+use std::vec::Vec;\n+\n+use rand::{thread_rng, RngCore};\n+\n+fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n+    v.iter().cloned().collect()\n+}\n+\n+pub fn check_links<T>(list: &LinkedList<T>) {\n+    unsafe {\n+        let mut len = 0;\n+        let mut last_ptr: Option<&Node<T>> = None;\n+        let mut node_ptr: &Node<T>;\n+        match list.head {\n+            None => {\n+                // tail node should also be None.\n+                assert!(list.tail.is_none());\n+                assert_eq!(0, list.len);\n+                return;\n+            }\n+            Some(node) => node_ptr = &*node.as_ptr(),\n+        }\n+        loop {\n+            match (last_ptr, node_ptr.prev) {\n+                (None, None) => {}\n+                (None, _) => panic!(\"prev link for head\"),\n+                (Some(p), Some(pptr)) => {\n+                    assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n+                }\n+                _ => panic!(\"prev link is none, not good\"),\n+            }\n+            match node_ptr.next {\n+                Some(next) => {\n+                    last_ptr = Some(node_ptr);\n+                    node_ptr = &*next.as_ptr();\n+                    len += 1;\n+                }\n+                None => {\n+                    len += 1;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // verify that the tail node points to the last node.\n+        let tail = list.tail.as_ref().expect(\"some tail node\").as_ref();\n+        assert_eq!(tail as *const Node<T>, node_ptr as *const Node<T>);\n+        // check that len matches interior links.\n+        assert_eq!(len, list.len);\n+    }\n+}\n+\n+#[test]\n+fn test_append() {\n+    // Empty to empty\n+    {\n+        let mut m = LinkedList::<i32>::new();\n+        let mut n = LinkedList::new();\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(n.len(), 0);\n+    }\n+    // Non-empty to empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        n.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        assert_eq!(n.len(), 0);\n+        check_links(&m);\n+    }\n+    // Empty to non-empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        m.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        check_links(&m);\n+    }\n+\n+    // Non-empty to non-empty\n+    let v = vec![1, 2, 3, 4, 5];\n+    let u = vec![9, 8, 1, 2, 3, 4, 5];\n+    let mut m = list_from(&v);\n+    let mut n = list_from(&u);\n+    m.append(&mut n);\n+    check_links(&m);\n+    let mut sum = v;\n+    sum.extend_from_slice(&u);\n+    assert_eq!(sum.len(), m.len());\n+    for elt in sum {\n+        assert_eq!(m.pop_front(), Some(elt))\n+    }\n+    assert_eq!(n.len(), 0);\n+    // let's make sure it's working properly, since we\n+    // did some direct changes to private members\n+    n.push_back(3);\n+    assert_eq!(n.len(), 1);\n+    assert_eq!(n.pop_front(), Some(3));\n+    check_links(&n);\n+}\n+\n+#[test]\n+fn test_insert_prev() {\n+    let mut m = list_from(&[0, 2, 4, 6, 8]);\n+    let len = m.len();\n+    {\n+        let mut it = m.iter_mut();\n+        it.insert_next(-2);\n+        loop {\n+            match it.next() {\n+                None => break,\n+                Some(elt) => {\n+                    it.insert_next(*elt + 1);\n+                    match it.peek_next() {\n+                        Some(x) => assert_eq!(*x, *elt + 2),\n+                        None => assert_eq!(8, *elt),\n+                    }\n+                }\n+            }\n+        }\n+        it.insert_next(0);\n+        it.insert_next(1);\n+    }\n+    check_links(&m);\n+    assert_eq!(m.len(), 3 + len * 2);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(),\n+                [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn test_send() {\n+    let n = list_from(&[1, 2, 3]);\n+    thread::spawn(move || {\n+            check_links(&n);\n+            let a: &[_] = &[&1, &2, &3];\n+            assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n+        })\n+        .join()\n+        .ok()\n+        .unwrap();\n+}\n+\n+#[test]\n+fn test_fuzz() {\n+    for _ in 0..25 {\n+        fuzz_test(3);\n+        fuzz_test(16);\n+        #[cfg(not(miri))] // Miri is too slow\n+        fuzz_test(189);\n+    }\n+}\n+\n+#[test]\n+fn test_26021() {\n+    // There was a bug in split_off that failed to null out the RHS's head's prev ptr.\n+    // This caused the RHS's dtor to walk up into the LHS at drop and delete all of\n+    // its nodes.\n+    //\n+    // https://github.com/rust-lang/rust/issues/26021\n+    let mut v1 = LinkedList::new();\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    let _ = v1.split_off(3); // Dropping this now should not cause laundry consumption\n+    assert_eq!(v1.len(), 3);\n+\n+    assert_eq!(v1.iter().len(), 3);\n+    assert_eq!(v1.iter().collect::<Vec<_>>().len(), 3);\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    let mut v1 = LinkedList::new();\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+\n+    // test all splits\n+    for ix in 0..1 + v1.len() {\n+        let mut a = v1.clone();\n+        let b = a.split_off(ix);\n+        check_links(&a);\n+        check_links(&b);\n+        a.extend(b);\n+        assert_eq!(v1, a);\n+    }\n+}\n+\n+#[cfg(test)]\n+fn fuzz_test(sz: i32) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    let mut v = vec![];\n+    for i in 0..sz {\n+        check_links(&m);\n+        let r: u8 = thread_rng().next_u32() as u8;\n+        match r % 6 {\n+            0 => {\n+                m.pop_back();\n+                v.pop();\n+            }\n+            1 => {\n+                if !v.is_empty() {\n+                    m.pop_front();\n+                    v.remove(0);\n+                }\n+            }\n+            2 | 4 => {\n+                m.push_front(-i);\n+                v.insert(0, -i);\n+            }\n+            3 | 5 | _ => {\n+                m.push_back(i);\n+                v.push(i);\n+            }\n+        }\n+    }\n+\n+    check_links(&m);\n+\n+    let mut i = 0;\n+    for (a, &b) in m.into_iter().zip(&v) {\n+        i += 1;\n+        assert_eq!(a, b);\n+    }\n+    assert_eq!(i, v.len());\n+}\n+\n+#[test]\n+fn drain_filter_test() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n+\n+    check_links(&m);\n+\n+    assert_eq!(deleted, &[1, 2, 3]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n+}\n+\n+#[test]\n+fn drain_to_empty_test() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n+\n+    check_links(&m);\n+\n+    assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+}"}, {"sha": "9240346ace93169a39ecce59759c86cbb32d79be", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 3, "deletions": 386, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! A double-ended queue implemented with a growable ring buffer.\n //!\n //! This queue has `O(1)` amortized inserts and removals from both ends of the\n@@ -24,6 +22,9 @@ use crate::collections::CollectionAllocErr;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n #[cfg(target_pointer_width = \"16\")]\n@@ -2838,387 +2839,3 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use ::test;\n-\n-    use super::VecDeque;\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_push_back_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_back(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_push_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_front(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_back());\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_front());\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn test_swap_front_back_remove() {\n-        fn test(back: bool) {\n-            // This test checks that every single combination of tail position and length is tested.\n-            // Capacity 15 should be large enough to cover every case.\n-            let mut tester = VecDeque::with_capacity(15);\n-            let usable_cap = tester.capacity();\n-            let final_len = usable_cap / 2;\n-\n-            for len in 0..final_len {\n-                let expected: VecDeque<_> = if back {\n-                    (0..len).collect()\n-                } else {\n-                    (0..len).rev().collect()\n-                };\n-                for tail_pos in 0..usable_cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    if back {\n-                        for i in 0..len * 2 {\n-                            tester.push_front(i);\n-                        }\n-                        for i in 0..len {\n-                            assert_eq!(tester.swap_remove_back(i), Some(len * 2 - 1 - i));\n-                        }\n-                    } else {\n-                        for i in 0..len * 2 {\n-                            tester.push_back(i);\n-                        }\n-                        for i in 0..len {\n-                            let idx = tester.len() - 1 - i;\n-                            assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n-                        }\n-                    }\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-        test(true);\n-        test(false);\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        // This test checks that every single combination of tail position, length, and\n-        // insertion position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-\n-        // len is the length *after* insertion\n-        for len in 1..cap {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..cap {\n-                for to_insert in 0..len {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i != to_insert {\n-                            tester.push_back(i);\n-                        }\n-                    }\n-                    tester.insert(to_insert, to_insert);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        // This test checks that every single combination of tail position, length, and\n-        // removal position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *after* removal\n-        for len in 0..cap - 1 {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..cap {\n-                for to_remove in 0..=len {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i == to_remove {\n-                            tester.push_back(1234);\n-                        }\n-                        tester.push_back(i);\n-                    }\n-                    if to_remove == len {\n-                        tester.push_back(1234);\n-                    }\n-                    tester.remove(to_remove);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_drain() {\n-        let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n-\n-        let cap = tester.capacity();\n-        for len in 0..=cap {\n-            for tail in 0..=cap {\n-                for drain_start in 0..=len {\n-                    for drain_end in drain_start..=len {\n-                        tester.tail = tail;\n-                        tester.head = tail;\n-                        for i in 0..len {\n-                            tester.push_back(i);\n-                        }\n-\n-                        // Check that we drain the correct values\n-                        let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n-                        let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n-                        assert_eq!(drained, drained_expected);\n-\n-                        // We shouldn't have changed the capacity or made the\n-                        // head or tail out of bounds\n-                        assert_eq!(tester.capacity(), cap);\n-                        assert!(tester.tail < tester.cap());\n-                        assert!(tester.head < tester.cap());\n-\n-                        // We should see the correct values in the VecDeque\n-                        let expected: VecDeque<_> = (0..drain_start)\n-                            .chain(drain_end..len)\n-                            .collect();\n-                        assert_eq!(expected, tester);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_shrink_to_fit() {\n-        // This test checks that every single combination of head and tail position,\n-        // is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-        tester.reserve(63);\n-        let max_cap = tester.capacity();\n-\n-        for len in 0..=cap {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..=max_cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n-                tester.reserve(63);\n-                for i in 0..len {\n-                    tester.push_back(i);\n-                }\n-                tester.shrink_to_fit();\n-                assert!(tester.capacity() <= cap);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n-                assert_eq!(tester, expected);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        // This test checks that every single combination of tail position, length, and\n-        // split position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *before* splitting\n-        for len in 0..cap {\n-            // index to split at\n-            for at in 0..=len {\n-                // 0, 1, 2, .., at - 1 (may be empty)\n-                let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n-                // at, at + 1, .., len - 1 (may be empty)\n-                let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n-\n-                for tail_pos in 0..cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        tester.push_back(i);\n-                    }\n-                    let result = tester.split_off(at);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert!(result.tail < result.cap());\n-                    assert!(result.head < result.cap());\n-                    assert_eq!(tester, expected_self);\n-                    assert_eq!(result, expected_other);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        use crate::vec::Vec;\n-        for cap in 0..35 {\n-            for len in 0..=cap {\n-                let mut vec = Vec::with_capacity(cap);\n-                vec.extend(0..len);\n-\n-                let vd = VecDeque::from(vec.clone());\n-                assert!(vd.cap().is_power_of_two());\n-                assert_eq!(vd.len(), vec.len());\n-                assert!(vd.into_iter().eq(vec));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_vec_from_vecdeque() {\n-        use crate::vec::Vec;\n-\n-        fn create_vec_and_test_convert(capacity: usize, offset: usize, len: usize) {\n-            let mut vd = VecDeque::with_capacity(capacity);\n-            for _ in 0..offset {\n-                vd.push_back(0);\n-                vd.pop_front();\n-            }\n-            vd.extend(0..len);\n-\n-            let vec: Vec<_> = Vec::from(vd.clone());\n-            assert_eq!(vec.len(), vd.len());\n-            assert!(vec.into_iter().eq(vd));\n-        }\n-\n-        #[cfg(not(miri))] // Miri is too slow\n-        let max_pwr = 7;\n-        #[cfg(miri)]\n-        let max_pwr = 5;\n-\n-        for cap_pwr in 0..max_pwr {\n-            // Make capacity as a (2^x)-1, so that the ring size is 2^x\n-            let cap = (2i32.pow(cap_pwr) - 1) as usize;\n-\n-            // In these cases there is enough free space to solve it with copies\n-            for len in 0..((cap + 1) / 2) {\n-                // Test contiguous cases\n-                for offset in 0..(cap - len) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap - len)..(cap - (len / 2)) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap - (len / 2))..cap {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-            }\n-\n-            // Now there's not (necessarily) space to straighten the ring with simple copies,\n-            // the ring will use swapping when:\n-            // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n-            //  right block size  >   free space    &&      left block size       >    free space\n-            for len in ((cap + 1) / 2)..cap {\n-                // Test contiguous cases\n-                for offset in 0..(cap - len) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap - len)..(cap - (len / 2)) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap - (len / 2))..cap {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn issue_53529() {\n-        use crate::boxed::Box;\n-\n-        let mut dst = VecDeque::new();\n-        dst.push_front(Box::new(1));\n-        dst.push_front(Box::new(2));\n-        assert_eq!(*dst.pop_back().unwrap(), 1);\n-\n-        let mut src = VecDeque::new();\n-        src.push_front(Box::new(2));\n-        dst.append(&mut src);\n-        for a in dst {\n-            assert_eq!(*a, 2);\n-        }\n-    }\n-\n-}"}, {"sha": "d25352399796e684ec503bc05ed8b1597ed48806", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -0,0 +1,379 @@\n+use super::*;\n+\n+use ::test;\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_push_back_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_back(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_push_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_front(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_pop_back_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_back());\n+        }\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_pop_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_front());\n+        }\n+    })\n+}\n+\n+#[test]\n+fn test_swap_front_back_remove() {\n+    fn test(back: bool) {\n+        // This test checks that every single combination of tail position and length is tested.\n+        // Capacity 15 should be large enough to cover every case.\n+        let mut tester = VecDeque::with_capacity(15);\n+        let usable_cap = tester.capacity();\n+        let final_len = usable_cap / 2;\n+\n+        for len in 0..final_len {\n+            let expected: VecDeque<_> = if back {\n+                (0..len).collect()\n+            } else {\n+                (0..len).rev().collect()\n+            };\n+            for tail_pos in 0..usable_cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                if back {\n+                    for i in 0..len * 2 {\n+                        tester.push_front(i);\n+                    }\n+                    for i in 0..len {\n+                        assert_eq!(tester.swap_remove_back(i), Some(len * 2 - 1 - i));\n+                    }\n+                } else {\n+                    for i in 0..len * 2 {\n+                        tester.push_back(i);\n+                    }\n+                    for i in 0..len {\n+                        let idx = tester.len() - 1 - i;\n+                        assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n+                    }\n+                }\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+    test(true);\n+    test(false);\n+}\n+\n+#[test]\n+fn test_insert() {\n+    // This test checks that every single combination of tail position, length, and\n+    // insertion position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+\n+    // len is the length *after* insertion\n+    for len in 1..cap {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..cap {\n+            for to_insert in 0..len {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i != to_insert {\n+                        tester.push_back(i);\n+                    }\n+                }\n+                tester.insert(to_insert, to_insert);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_remove() {\n+    // This test checks that every single combination of tail position, length, and\n+    // removal position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *after* removal\n+    for len in 0..cap - 1 {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..cap {\n+            for to_remove in 0..=len {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i == to_remove {\n+                        tester.push_back(1234);\n+                    }\n+                    tester.push_back(i);\n+                }\n+                if to_remove == len {\n+                    tester.push_back(1234);\n+                }\n+                tester.remove(to_remove);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_drain() {\n+    let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+    let cap = tester.capacity();\n+    for len in 0..=cap {\n+        for tail in 0..=cap {\n+            for drain_start in 0..=len {\n+                for drain_end in drain_start..=len {\n+                    tester.tail = tail;\n+                    tester.head = tail;\n+                    for i in 0..len {\n+                        tester.push_back(i);\n+                    }\n+\n+                    // Check that we drain the correct values\n+                    let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n+                    let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n+                    assert_eq!(drained, drained_expected);\n+\n+                    // We shouldn't have changed the capacity or made the\n+                    // head or tail out of bounds\n+                    assert_eq!(tester.capacity(), cap);\n+                    assert!(tester.tail < tester.cap());\n+                    assert!(tester.head < tester.cap());\n+\n+                    // We should see the correct values in the VecDeque\n+                    let expected: VecDeque<_> = (0..drain_start)\n+                        .chain(drain_end..len)\n+                        .collect();\n+                    assert_eq!(expected, tester);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_shrink_to_fit() {\n+    // This test checks that every single combination of head and tail position,\n+    // is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+    tester.reserve(63);\n+    let max_cap = tester.capacity();\n+\n+    for len in 0..=cap {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..=max_cap {\n+            tester.tail = tail_pos;\n+            tester.head = tail_pos;\n+            tester.reserve(63);\n+            for i in 0..len {\n+                tester.push_back(i);\n+            }\n+            tester.shrink_to_fit();\n+            assert!(tester.capacity() <= cap);\n+            assert!(tester.tail < tester.cap());\n+            assert!(tester.head < tester.cap());\n+            assert_eq!(tester, expected);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    // This test checks that every single combination of tail position, length, and\n+    // split position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *before* splitting\n+    for len in 0..cap {\n+        // index to split at\n+        for at in 0..=len {\n+            // 0, 1, 2, .., at - 1 (may be empty)\n+            let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n+            // at, at + 1, .., len - 1 (may be empty)\n+            let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n+\n+            for tail_pos in 0..cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    tester.push_back(i);\n+                }\n+                let result = tester.split_off(at);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert!(result.tail < result.cap());\n+                assert!(result.head < result.cap());\n+                assert_eq!(tester, expected_self);\n+                assert_eq!(result, expected_other);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    use crate::vec::Vec;\n+    for cap in 0..35 {\n+        for len in 0..=cap {\n+            let mut vec = Vec::with_capacity(cap);\n+            vec.extend(0..len);\n+\n+            let vd = VecDeque::from(vec.clone());\n+            assert!(vd.cap().is_power_of_two());\n+            assert_eq!(vd.len(), vec.len());\n+            assert!(vd.into_iter().eq(vec));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_vec_from_vecdeque() {\n+    use crate::vec::Vec;\n+\n+    fn create_vec_and_test_convert(capacity: usize, offset: usize, len: usize) {\n+        let mut vd = VecDeque::with_capacity(capacity);\n+        for _ in 0..offset {\n+            vd.push_back(0);\n+            vd.pop_front();\n+        }\n+        vd.extend(0..len);\n+\n+        let vec: Vec<_> = Vec::from(vd.clone());\n+        assert_eq!(vec.len(), vd.len());\n+        assert!(vec.into_iter().eq(vd));\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    let max_pwr = 7;\n+    #[cfg(miri)]\n+    let max_pwr = 5;\n+\n+    for cap_pwr in 0..max_pwr {\n+        // Make capacity as a (2^x)-1, so that the ring size is 2^x\n+        let cap = (2i32.pow(cap_pwr) - 1) as usize;\n+\n+        // In these cases there is enough free space to solve it with copies\n+        for len in 0..((cap + 1) / 2) {\n+            // Test contiguous cases\n+            for offset in 0..(cap - len) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at end of buffer is bigger than block at start\n+            for offset in (cap - len)..(cap - (len / 2)) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at start of buffer is bigger than block at end\n+            for offset in (cap - (len / 2))..cap {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+        }\n+\n+        // Now there's not (necessarily) space to straighten the ring with simple copies,\n+        // the ring will use swapping when:\n+        // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n+        //  right block size  >   free space    &&      left block size       >    free space\n+        for len in ((cap + 1) / 2)..cap {\n+            // Test contiguous cases\n+            for offset in 0..(cap - len) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at end of buffer is bigger than block at start\n+            for offset in (cap - len)..(cap - (len / 2)) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at start of buffer is bigger than block at end\n+            for offset in (cap - (len / 2))..cap {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn issue_53529() {\n+    use crate::boxed::Box;\n+\n+    let mut dst = VecDeque::new();\n+    dst.push_front(Box::new(1));\n+    dst.push_front(Box::new(2));\n+    assert_eq!(*dst.pop_back().unwrap(), 1);\n+\n+    let mut src = VecDeque::new();\n+    src.push_front(Box::new(2));\n+    dst.append(&mut src);\n+    for a in dst {\n+        assert_eq!(*a, 2);\n+    }\n+}"}, {"sha": "0abab45e920cc8bd7ad88ac2b6551b857804bc2c", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 3, "deletions": 79, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -11,6 +11,9 @@ use crate::alloc::{Alloc, Layout, Global, handle_alloc_error};\n use crate::collections::CollectionAllocErr::{self, *};\n use crate::boxed::Box;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n@@ -748,82 +751,3 @@ fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n fn capacity_overflow() -> ! {\n     panic!(\"capacity overflow\")\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn allocator_param() {\n-        use crate::alloc::AllocErr;\n-\n-        // Writing a test of integration between third-party\n-        // allocators and RawVec is a little tricky because the RawVec\n-        // API does not expose fallible allocation methods, so we\n-        // cannot check what happens when allocator is exhausted\n-        // (beyond detecting a panic).\n-        //\n-        // Instead, this just checks that the RawVec methods do at\n-        // least go through the Allocator API when it reserves\n-        // storage.\n-\n-        // A dumb allocator that consumes a fixed amount of fuel\n-        // before allocation attempts start failing.\n-        struct BoundedAlloc { fuel: usize }\n-        unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-                let size = layout.size();\n-                if size > self.fuel {\n-                    return Err(AllocErr);\n-                }\n-                match Global.alloc(layout) {\n-                    ok @ Ok(_) => { self.fuel -= size; ok }\n-                    err @ Err(_) => err,\n-                }\n-            }\n-            unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-                Global.dealloc(ptr, layout)\n-            }\n-        }\n-\n-        let a = BoundedAlloc { fuel: 500 };\n-        let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n-        assert_eq!(v.a.fuel, 450);\n-        v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n-        assert_eq!(v.a.fuel, 250);\n-    }\n-\n-    #[test]\n-    fn reserve_does_not_overallocate() {\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            // First `reserve` allocates like `reserve_exact`\n-            v.reserve(0, 9);\n-            assert_eq!(9, v.capacity());\n-        }\n-\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            v.reserve(0, 7);\n-            assert_eq!(7, v.capacity());\n-            // 97 if more than double of 7, so `reserve` should work\n-            // like `reserve_exact`.\n-            v.reserve(7, 90);\n-            assert_eq!(97, v.capacity());\n-        }\n-\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            v.reserve(0, 12);\n-            assert_eq!(12, v.capacity());\n-            v.reserve(12, 3);\n-            // 3 is less than half of 12, so `reserve` must grow\n-            // exponentially. At the time of writing this test grow\n-            // factor is 2, so new capacity is 24, however, grow factor\n-            // of 1.5 is OK too. Hence `>= 18` in assert.\n-            assert!(v.capacity() >= 12 + 12 / 2);\n-        }\n-    }\n-\n-\n-}"}, {"sha": "c389898d1ef0450c3bdf3f168b45fbb40e71e089", "filename": "src/liballoc/raw_vec/tests.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -0,0 +1,73 @@\n+use super::*;\n+\n+#[test]\n+fn allocator_param() {\n+    use crate::alloc::AllocErr;\n+\n+    // Writing a test of integration between third-party\n+    // allocators and RawVec is a little tricky because the RawVec\n+    // API does not expose fallible allocation methods, so we\n+    // cannot check what happens when allocator is exhausted\n+    // (beyond detecting a panic).\n+    //\n+    // Instead, this just checks that the RawVec methods do at\n+    // least go through the Allocator API when it reserves\n+    // storage.\n+\n+    // A dumb allocator that consumes a fixed amount of fuel\n+    // before allocation attempts start failing.\n+    struct BoundedAlloc { fuel: usize }\n+    unsafe impl Alloc for BoundedAlloc {\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+            let size = layout.size();\n+            if size > self.fuel {\n+                return Err(AllocErr);\n+            }\n+            match Global.alloc(layout) {\n+                ok @ Ok(_) => { self.fuel -= size; ok }\n+                err @ Err(_) => err,\n+            }\n+        }\n+        unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+            Global.dealloc(ptr, layout)\n+        }\n+    }\n+\n+    let a = BoundedAlloc { fuel: 500 };\n+    let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n+    assert_eq!(v.a.fuel, 450);\n+    v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n+    assert_eq!(v.a.fuel, 250);\n+}\n+\n+#[test]\n+fn reserve_does_not_overallocate() {\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        // First `reserve` allocates like `reserve_exact`\n+        v.reserve(0, 9);\n+        assert_eq!(9, v.capacity());\n+    }\n+\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        v.reserve(0, 7);\n+        assert_eq!(7, v.capacity());\n+        // 97 if more than double of 7, so `reserve` should work\n+        // like `reserve_exact`.\n+        v.reserve(7, 90);\n+        assert_eq!(97, v.capacity());\n+    }\n+\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        v.reserve(0, 12);\n+        assert_eq!(12, v.capacity());\n+        v.reserve(12, 3);\n+        // 3 is less than half of 12, so `reserve` must grow\n+        // exponentially. At the time of writing this test grow\n+        // factor is 2, so new capacity is 24, however, grow factor\n+        // of 1.5 is OK too. Hence `>= 18` in assert.\n+        assert!(v.capacity() >= 12 + 12 / 2);\n+    }\n+}"}, {"sha": "e33aac3af474e4435093d95cda8b6e45efdbf664", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 430, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -252,6 +252,9 @@ use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use crate::string::String;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n     weak: Cell<usize>,\n@@ -1851,436 +1854,6 @@ impl<T: ?Sized> RcBoxPtr<T> for RcBox<T> {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use super::{Rc, Weak};\n-    use std::boxed::Box;\n-    use std::cell::RefCell;\n-    use std::option::Option::{self, None, Some};\n-    use std::result::Result::{Err, Ok};\n-    use std::mem::drop;\n-    use std::clone::Clone;\n-    use std::convert::From;\n-\n-    #[test]\n-    fn test_clone() {\n-        let x = Rc::new(RefCell::new(5));\n-        let y = x.clone();\n-        *x.borrow_mut() = 20;\n-        assert_eq!(*y.borrow(), 20);\n-    }\n-\n-    #[test]\n-    fn test_simple() {\n-        let x = Rc::new(5);\n-        assert_eq!(*x, 5);\n-    }\n-\n-    #[test]\n-    fn test_simple_clone() {\n-        let x = Rc::new(5);\n-        let y = x.clone();\n-        assert_eq!(*x, 5);\n-        assert_eq!(*y, 5);\n-    }\n-\n-    #[test]\n-    fn test_destructor() {\n-        let x: Rc<Box<_>> = Rc::new(box 5);\n-        assert_eq!(**x, 5);\n-    }\n-\n-    #[test]\n-    fn test_live() {\n-        let x = Rc::new(5);\n-        let y = Rc::downgrade(&x);\n-        assert!(y.upgrade().is_some());\n-    }\n-\n-    #[test]\n-    fn test_dead() {\n-        let x = Rc::new(5);\n-        let y = Rc::downgrade(&x);\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn weak_self_cyclic() {\n-        struct Cycle {\n-            x: RefCell<Option<Weak<Cycle>>>,\n-        }\n-\n-        let a = Rc::new(Cycle { x: RefCell::new(None) });\n-        let b = Rc::downgrade(&a.clone());\n-        *a.x.borrow_mut() = Some(b);\n-\n-        // hopefully we don't double-free (or leak)...\n-    }\n-\n-    #[test]\n-    fn is_unique() {\n-        let x = Rc::new(3);\n-        assert!(Rc::is_unique(&x));\n-        let y = x.clone();\n-        assert!(!Rc::is_unique(&x));\n-        drop(y);\n-        assert!(Rc::is_unique(&x));\n-        let w = Rc::downgrade(&x);\n-        assert!(!Rc::is_unique(&x));\n-        drop(w);\n-        assert!(Rc::is_unique(&x));\n-    }\n-\n-    #[test]\n-    fn test_strong_count() {\n-        let a = Rc::new(0);\n-        assert!(Rc::strong_count(&a) == 1);\n-        let w = Rc::downgrade(&a);\n-        assert!(Rc::strong_count(&a) == 1);\n-        let b = w.upgrade().expect(\"upgrade of live rc failed\");\n-        assert!(Rc::strong_count(&b) == 2);\n-        assert!(Rc::strong_count(&a) == 2);\n-        drop(w);\n-        drop(a);\n-        assert!(Rc::strong_count(&b) == 1);\n-        let c = b.clone();\n-        assert!(Rc::strong_count(&b) == 2);\n-        assert!(Rc::strong_count(&c) == 2);\n-    }\n-\n-    #[test]\n-    fn test_weak_count() {\n-        let a = Rc::new(0);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 0);\n-        let w = Rc::downgrade(&a);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 1);\n-        drop(w);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 0);\n-        let c = a.clone();\n-        assert!(Rc::strong_count(&a) == 2);\n-        assert!(Rc::weak_count(&a) == 0);\n-        drop(c);\n-    }\n-\n-    #[test]\n-    fn weak_counts() {\n-        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n-        assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n-\n-        let a = Rc::new(0);\n-        let w = Rc::downgrade(&a);\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(1));\n-        let w2 = w.clone();\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(2));\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(2));\n-        drop(w);\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        let a2 = a.clone();\n-        assert_eq!(Weak::strong_count(&w2), 2);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(a2);\n-        drop(a);\n-        assert_eq!(Weak::strong_count(&w2), 0);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(w2);\n-    }\n-\n-    #[test]\n-    fn try_unwrap() {\n-        let x = Rc::new(3);\n-        assert_eq!(Rc::try_unwrap(x), Ok(3));\n-        let x = Rc::new(4);\n-        let _y = x.clone();\n-        assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n-        let x = Rc::new(5);\n-        let _w = Rc::downgrade(&x);\n-        assert_eq!(Rc::try_unwrap(x), Ok(5));\n-    }\n-\n-    #[test]\n-    fn into_from_raw() {\n-        let x = Rc::new(box \"hello\");\n-        let y = x.clone();\n-\n-        let x_ptr = Rc::into_raw(x);\n-        drop(y);\n-        unsafe {\n-            assert_eq!(**x_ptr, \"hello\");\n-\n-            let x = Rc::from_raw(x_ptr);\n-            assert_eq!(**x, \"hello\");\n-\n-            assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_from_raw_unsized() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let rc: Rc<str> = Rc::from(\"foo\");\n-\n-        let ptr = Rc::into_raw(rc.clone());\n-        let rc2 = unsafe { Rc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }, \"foo\");\n-        assert_eq!(rc, rc2);\n-\n-        let rc: Rc<dyn Display> = Rc::new(123);\n-\n-        let ptr = Rc::into_raw(rc.clone());\n-        let rc2 = unsafe { Rc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n-        assert_eq!(rc2.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn get_mut() {\n-        let mut x = Rc::new(3);\n-        *Rc::get_mut(&mut x).unwrap() = 4;\n-        assert_eq!(*x, 4);\n-        let y = x.clone();\n-        assert!(Rc::get_mut(&mut x).is_none());\n-        drop(y);\n-        assert!(Rc::get_mut(&mut x).is_some());\n-        let _w = Rc::downgrade(&x);\n-        assert!(Rc::get_mut(&mut x).is_none());\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_make_unique() {\n-        let mut cow0 = Rc::new(75);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *Rc::make_mut(&mut cow0));\n-        assert!(75 == *Rc::make_mut(&mut cow1));\n-        assert!(75 == *Rc::make_mut(&mut cow2));\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-        *Rc::make_mut(&mut cow1) += 2;\n-        *Rc::make_mut(&mut cow2) += 3;\n-\n-        assert!(76 == *cow0);\n-        assert!(77 == *cow1);\n-        assert!(78 == *cow2);\n-\n-        // none should point to the same backing memory\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 != *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_unique2() {\n-        let mut cow0 = Rc::new(75);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 == *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_weak() {\n-        let mut cow0 = Rc::new(75);\n-        let cow1_weak = Rc::downgrade(&cow0);\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1_weak.upgrade().unwrap());\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(cow1_weak.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let foo = Rc::new(75);\n-        assert_eq!(format!(\"{:?}\", foo), \"75\");\n-    }\n-\n-    #[test]\n-    fn test_unsized() {\n-        let foo: Rc<[i32]> = Rc::new([1, 2, 3]);\n-        assert_eq!(foo, foo.clone());\n-    }\n-\n-    #[test]\n-    fn test_from_owned() {\n-        let foo = 123;\n-        let foo_rc = Rc::from(foo);\n-        assert!(123 == *foo_rc);\n-    }\n-\n-    #[test]\n-    fn test_new_weak() {\n-        let foo: Weak<usize> = Weak::new();\n-        assert!(foo.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_ptr_eq() {\n-        let five = Rc::new(5);\n-        let same_five = five.clone();\n-        let other_five = Rc::new(5);\n-\n-        assert!(Rc::ptr_eq(&five, &same_five));\n-        assert!(!Rc::ptr_eq(&five, &other_five));\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-        let r: Rc<str> = Rc::from(\"foo\");\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_copy_from_slice() {\n-        let s: &[u32] = &[1, 2, 3];\n-        let r: Rc<[u32]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_clone_from_slice() {\n-        #[derive(Clone, Debug, Eq, PartialEq)]\n-        struct X(u32);\n-\n-        let s: &[X] = &[X(1), X(2), X(3)];\n-        let r: Rc<[X]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], s);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clone_from_slice_panic() {\n-        use std::string::{String, ToString};\n-\n-        struct Fail(u32, String);\n-\n-        impl Clone for Fail {\n-            fn clone(&self) -> Fail {\n-                if self.0 == 2 {\n-                    panic!();\n-                }\n-                Fail(self.0, self.1.clone())\n-            }\n-        }\n-\n-        let s: &[Fail] = &[\n-            Fail(0, \"foo\".to_string()),\n-            Fail(1, \"bar\".to_string()),\n-            Fail(2, \"baz\".to_string()),\n-        ];\n-\n-        // Should panic, but not cause memory corruption\n-        let _r: Rc<[Fail]> = Rc::from(s);\n-    }\n-\n-    #[test]\n-    fn test_from_box() {\n-        let b: Box<u32> = box 123;\n-        let r: Rc<u32> = Rc::from(b);\n-\n-        assert_eq!(*r, 123);\n-    }\n-\n-    #[test]\n-    fn test_from_box_str() {\n-        use std::string::String;\n-\n-        let s = String::from(\"foo\").into_boxed_str();\n-        let r: Rc<str> = Rc::from(s);\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_slice() {\n-        let s = vec![1, 2, 3].into_boxed_slice();\n-        let r: Rc<[u32]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let b: Box<dyn Display> = box 123;\n-        let r: Rc<dyn Display> = Rc::from(b);\n-\n-        assert_eq!(r.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait_zero_sized() {\n-        use std::fmt::Debug;\n-\n-        let b: Box<dyn Debug> = box ();\n-        let r: Rc<dyn Debug> = Rc::from(b);\n-\n-        assert_eq!(format!(\"{:?}\", r), \"()\");\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        let v = vec![1, 2, 3];\n-        let r: Rc<[u32]> = Rc::from(v);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_downcast() {\n-        use std::any::Any;\n-\n-        let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n-        let r2: Rc<dyn Any> = Rc::new(\"abc\");\n-\n-        assert!(r1.clone().downcast::<u32>().is_err());\n-\n-        let r1i32 = r1.downcast::<i32>();\n-        assert!(r1i32.is_ok());\n-        assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n-\n-        assert!(r2.clone().downcast::<i32>().is_err());\n-\n-        let r2str = r2.downcast::<&'static str>();\n-        assert!(r2str.is_ok());\n-        assert_eq!(r2str.unwrap(), Rc::new(\"abc\"));\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Rc<T> {\n     fn borrow(&self) -> &T {"}, {"sha": "72816a5c120c80843bdfd3455af725e8747f39d5", "filename": "src/liballoc/rc/tests.rs", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -0,0 +1,427 @@\n+use super::*;\n+\n+use std::boxed::Box;\n+use std::cell::RefCell;\n+use std::option::Option::{self, None, Some};\n+use std::result::Result::{Err, Ok};\n+use std::mem::drop;\n+use std::clone::Clone;\n+use std::convert::From;\n+\n+#[test]\n+fn test_clone() {\n+    let x = Rc::new(RefCell::new(5));\n+    let y = x.clone();\n+    *x.borrow_mut() = 20;\n+    assert_eq!(*y.borrow(), 20);\n+}\n+\n+#[test]\n+fn test_simple() {\n+    let x = Rc::new(5);\n+    assert_eq!(*x, 5);\n+}\n+\n+#[test]\n+fn test_simple_clone() {\n+    let x = Rc::new(5);\n+    let y = x.clone();\n+    assert_eq!(*x, 5);\n+    assert_eq!(*y, 5);\n+}\n+\n+#[test]\n+fn test_destructor() {\n+    let x: Rc<Box<_>> = Rc::new(box 5);\n+    assert_eq!(**x, 5);\n+}\n+\n+#[test]\n+fn test_live() {\n+    let x = Rc::new(5);\n+    let y = Rc::downgrade(&x);\n+    assert!(y.upgrade().is_some());\n+}\n+\n+#[test]\n+fn test_dead() {\n+    let x = Rc::new(5);\n+    let y = Rc::downgrade(&x);\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn weak_self_cyclic() {\n+    struct Cycle {\n+        x: RefCell<Option<Weak<Cycle>>>,\n+    }\n+\n+    let a = Rc::new(Cycle { x: RefCell::new(None) });\n+    let b = Rc::downgrade(&a.clone());\n+    *a.x.borrow_mut() = Some(b);\n+\n+    // hopefully we don't double-free (or leak)...\n+}\n+\n+#[test]\n+fn is_unique() {\n+    let x = Rc::new(3);\n+    assert!(Rc::is_unique(&x));\n+    let y = x.clone();\n+    assert!(!Rc::is_unique(&x));\n+    drop(y);\n+    assert!(Rc::is_unique(&x));\n+    let w = Rc::downgrade(&x);\n+    assert!(!Rc::is_unique(&x));\n+    drop(w);\n+    assert!(Rc::is_unique(&x));\n+}\n+\n+#[test]\n+fn test_strong_count() {\n+    let a = Rc::new(0);\n+    assert!(Rc::strong_count(&a) == 1);\n+    let w = Rc::downgrade(&a);\n+    assert!(Rc::strong_count(&a) == 1);\n+    let b = w.upgrade().expect(\"upgrade of live rc failed\");\n+    assert!(Rc::strong_count(&b) == 2);\n+    assert!(Rc::strong_count(&a) == 2);\n+    drop(w);\n+    drop(a);\n+    assert!(Rc::strong_count(&b) == 1);\n+    let c = b.clone();\n+    assert!(Rc::strong_count(&b) == 2);\n+    assert!(Rc::strong_count(&c) == 2);\n+}\n+\n+#[test]\n+fn test_weak_count() {\n+    let a = Rc::new(0);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 0);\n+    let w = Rc::downgrade(&a);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 1);\n+    drop(w);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 0);\n+    let c = a.clone();\n+    assert!(Rc::strong_count(&a) == 2);\n+    assert!(Rc::weak_count(&a) == 0);\n+    drop(c);\n+}\n+\n+#[test]\n+fn weak_counts() {\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n+\n+    let a = Rc::new(0);\n+    let w = Rc::downgrade(&a);\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(1));\n+    let w2 = w.clone();\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    drop(w);\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    let a2 = a.clone();\n+    assert_eq!(Weak::strong_count(&w2), 2);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(a2);\n+    drop(a);\n+    assert_eq!(Weak::strong_count(&w2), 0);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(w2);\n+}\n+\n+#[test]\n+fn try_unwrap() {\n+    let x = Rc::new(3);\n+    assert_eq!(Rc::try_unwrap(x), Ok(3));\n+    let x = Rc::new(4);\n+    let _y = x.clone();\n+    assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    let x = Rc::new(5);\n+    let _w = Rc::downgrade(&x);\n+    assert_eq!(Rc::try_unwrap(x), Ok(5));\n+}\n+\n+#[test]\n+fn into_from_raw() {\n+    let x = Rc::new(box \"hello\");\n+    let y = x.clone();\n+\n+    let x_ptr = Rc::into_raw(x);\n+    drop(y);\n+    unsafe {\n+        assert_eq!(**x_ptr, \"hello\");\n+\n+        let x = Rc::from_raw(x_ptr);\n+        assert_eq!(**x, \"hello\");\n+\n+        assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+    }\n+}\n+\n+#[test]\n+fn test_into_from_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let rc: Rc<str> = Rc::from(\"foo\");\n+\n+    let ptr = Rc::into_raw(rc.clone());\n+    let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert_eq!(rc, rc2);\n+\n+    let rc: Rc<dyn Display> = Rc::new(123);\n+\n+    let ptr = Rc::into_raw(rc.clone());\n+    let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert_eq!(rc2.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn get_mut() {\n+    let mut x = Rc::new(3);\n+    *Rc::get_mut(&mut x).unwrap() = 4;\n+    assert_eq!(*x, 4);\n+    let y = x.clone();\n+    assert!(Rc::get_mut(&mut x).is_none());\n+    drop(y);\n+    assert!(Rc::get_mut(&mut x).is_some());\n+    let _w = Rc::downgrade(&x);\n+    assert!(Rc::get_mut(&mut x).is_none());\n+}\n+\n+#[test]\n+fn test_cowrc_clone_make_unique() {\n+    let mut cow0 = Rc::new(75);\n+    let mut cow1 = cow0.clone();\n+    let mut cow2 = cow1.clone();\n+\n+    assert!(75 == *Rc::make_mut(&mut cow0));\n+    assert!(75 == *Rc::make_mut(&mut cow1));\n+    assert!(75 == *Rc::make_mut(&mut cow2));\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+    *Rc::make_mut(&mut cow1) += 2;\n+    *Rc::make_mut(&mut cow2) += 3;\n+\n+    assert!(76 == *cow0);\n+    assert!(77 == *cow1);\n+    assert!(78 == *cow2);\n+\n+    // none should point to the same backing memory\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 != *cow2);\n+}\n+\n+#[test]\n+fn test_cowrc_clone_unique2() {\n+    let mut cow0 = Rc::new(75);\n+    let cow1 = cow0.clone();\n+    let cow2 = cow1.clone();\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    // cow1 and cow2 should share the same contents\n+    // cow0 should have a unique reference\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 == *cow2);\n+}\n+\n+#[test]\n+fn test_cowrc_clone_weak() {\n+    let mut cow0 = Rc::new(75);\n+    let cow1_weak = Rc::downgrade(&cow0);\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1_weak.upgrade().unwrap());\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(cow1_weak.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_show() {\n+    let foo = Rc::new(75);\n+    assert_eq!(format!(\"{:?}\", foo), \"75\");\n+}\n+\n+#[test]\n+fn test_unsized() {\n+    let foo: Rc<[i32]> = Rc::new([1, 2, 3]);\n+    assert_eq!(foo, foo.clone());\n+}\n+\n+#[test]\n+fn test_from_owned() {\n+    let foo = 123;\n+    let foo_rc = Rc::from(foo);\n+    assert!(123 == *foo_rc);\n+}\n+\n+#[test]\n+fn test_new_weak() {\n+    let foo: Weak<usize> = Weak::new();\n+    assert!(foo.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_ptr_eq() {\n+    let five = Rc::new(5);\n+    let same_five = five.clone();\n+    let other_five = Rc::new(5);\n+\n+    assert!(Rc::ptr_eq(&five, &same_five));\n+    assert!(!Rc::ptr_eq(&five, &other_five));\n+}\n+\n+#[test]\n+fn test_from_str() {\n+    let r: Rc<str> = Rc::from(\"foo\");\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_copy_from_slice() {\n+    let s: &[u32] = &[1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_clone_from_slice() {\n+    #[derive(Clone, Debug, Eq, PartialEq)]\n+    struct X(u32);\n+\n+    let s: &[X] = &[X(1), X(2), X(3)];\n+    let r: Rc<[X]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], s);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clone_from_slice_panic() {\n+    use std::string::{String, ToString};\n+\n+    struct Fail(u32, String);\n+\n+    impl Clone for Fail {\n+        fn clone(&self) -> Fail {\n+            if self.0 == 2 {\n+                panic!();\n+            }\n+            Fail(self.0, self.1.clone())\n+        }\n+    }\n+\n+    let s: &[Fail] = &[\n+        Fail(0, \"foo\".to_string()),\n+        Fail(1, \"bar\".to_string()),\n+        Fail(2, \"baz\".to_string()),\n+    ];\n+\n+    // Should panic, but not cause memory corruption\n+    let _r: Rc<[Fail]> = Rc::from(s);\n+}\n+\n+#[test]\n+fn test_from_box() {\n+    let b: Box<u32> = box 123;\n+    let r: Rc<u32> = Rc::from(b);\n+\n+    assert_eq!(*r, 123);\n+}\n+\n+#[test]\n+fn test_from_box_str() {\n+    use std::string::String;\n+\n+    let s = String::from(\"foo\").into_boxed_str();\n+    let r: Rc<str> = Rc::from(s);\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_from_box_slice() {\n+    let s = vec![1, 2, 3].into_boxed_slice();\n+    let r: Rc<[u32]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_from_box_trait() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let b: Box<dyn Display> = box 123;\n+    let r: Rc<dyn Display> = Rc::from(b);\n+\n+    assert_eq!(r.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_from_box_trait_zero_sized() {\n+    use std::fmt::Debug;\n+\n+    let b: Box<dyn Debug> = box ();\n+    let r: Rc<dyn Debug> = Rc::from(b);\n+\n+    assert_eq!(format!(\"{:?}\", r), \"()\");\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    let v = vec![1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(v);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_downcast() {\n+    use std::any::Any;\n+\n+    let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n+    let r2: Rc<dyn Any> = Rc::new(\"abc\");\n+\n+    assert!(r1.clone().downcast::<u32>().is_err());\n+\n+    let r1i32 = r1.downcast::<i32>();\n+    assert!(r1i32.is_ok());\n+    assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n+\n+    assert!(r2.clone().downcast::<i32>().is_err());\n+\n+    let r2str = r2.downcast::<&'static str>();\n+    assert!(r2str.is_ok());\n+    assert_eq!(r2str.unwrap(), Rc::new(\"abc\"));\n+}"}, {"sha": "e11873218e8a41f7522f14bfdcd896df54f5c007", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 3, "deletions": 483, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -30,6 +30,9 @@ use crate::rc::is_dangling;\n use crate::string::String;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A soft limit on the amount of references that may be made to an `Arc`.\n ///\n /// Going above this limit will abort your program (although not\n@@ -1915,489 +1918,6 @@ impl<'a, T: 'a + Clone> ArcFromIter<&'a T, slice::Iter<'a, T>> for Arc<[T]> {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use std::boxed::Box;\n-    use std::clone::Clone;\n-    use std::sync::mpsc::channel;\n-    use std::mem::drop;\n-    use std::ops::Drop;\n-    use std::option::Option::{self, None, Some};\n-    use std::sync::atomic::{self, Ordering::{Acquire, SeqCst}};\n-    use std::thread;\n-    use std::sync::Mutex;\n-    use std::convert::From;\n-\n-    use super::{Arc, Weak};\n-    use crate::vec::Vec;\n-\n-    struct Canary(*mut atomic::AtomicUsize);\n-\n-    impl Drop for Canary {\n-        fn drop(&mut self) {\n-            unsafe {\n-                match *self {\n-                    Canary(c) => {\n-                        (*c).fetch_add(1, SeqCst);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg(not(miri))] // Miri does not support threads\n-    fn manually_share_arc() {\n-        let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        let arc_v = Arc::new(v);\n-\n-        let (tx, rx) = channel();\n-\n-        let _t = thread::spawn(move || {\n-            let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n-            assert_eq!((*arc_v)[3], 4);\n-        });\n-\n-        tx.send(arc_v.clone()).unwrap();\n-\n-        assert_eq!((*arc_v)[2], 3);\n-        assert_eq!((*arc_v)[4], 5);\n-    }\n-\n-    #[test]\n-    fn test_arc_get_mut() {\n-        let mut x = Arc::new(3);\n-        *Arc::get_mut(&mut x).unwrap() = 4;\n-        assert_eq!(*x, 4);\n-        let y = x.clone();\n-        assert!(Arc::get_mut(&mut x).is_none());\n-        drop(y);\n-        assert!(Arc::get_mut(&mut x).is_some());\n-        let _w = Arc::downgrade(&x);\n-        assert!(Arc::get_mut(&mut x).is_none());\n-    }\n-\n-    #[test]\n-    fn weak_counts() {\n-        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n-        assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n-\n-        let a = Arc::new(0);\n-        let w = Arc::downgrade(&a);\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(1));\n-        let w2 = w.clone();\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(2));\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(2));\n-        drop(w);\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        let a2 = a.clone();\n-        assert_eq!(Weak::strong_count(&w2), 2);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(a2);\n-        drop(a);\n-        assert_eq!(Weak::strong_count(&w2), 0);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(w2);\n-    }\n-\n-    #[test]\n-    fn try_unwrap() {\n-        let x = Arc::new(3);\n-        assert_eq!(Arc::try_unwrap(x), Ok(3));\n-        let x = Arc::new(4);\n-        let _y = x.clone();\n-        assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n-        let x = Arc::new(5);\n-        let _w = Arc::downgrade(&x);\n-        assert_eq!(Arc::try_unwrap(x), Ok(5));\n-    }\n-\n-    #[test]\n-    fn into_from_raw() {\n-        let x = Arc::new(box \"hello\");\n-        let y = x.clone();\n-\n-        let x_ptr = Arc::into_raw(x);\n-        drop(y);\n-        unsafe {\n-            assert_eq!(**x_ptr, \"hello\");\n-\n-            let x = Arc::from_raw(x_ptr);\n-            assert_eq!(**x, \"hello\");\n-\n-            assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_from_raw_unsized() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let arc: Arc<str> = Arc::from(\"foo\");\n-\n-        let ptr = Arc::into_raw(arc.clone());\n-        let arc2 = unsafe { Arc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }, \"foo\");\n-        assert_eq!(arc, arc2);\n-\n-        let arc: Arc<dyn Display> = Arc::new(123);\n-\n-        let ptr = Arc::into_raw(arc.clone());\n-        let arc2 = unsafe { Arc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n-        assert_eq!(arc2.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_make_mut() {\n-        let mut cow0 = Arc::new(75);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *Arc::make_mut(&mut cow0));\n-        assert!(75 == *Arc::make_mut(&mut cow1));\n-        assert!(75 == *Arc::make_mut(&mut cow2));\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-        *Arc::make_mut(&mut cow1) += 2;\n-        *Arc::make_mut(&mut cow2) += 3;\n-\n-        assert!(76 == *cow0);\n-        assert!(77 == *cow1);\n-        assert!(78 == *cow2);\n-\n-        // none should point to the same backing memory\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 != *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_unique2() {\n-        let mut cow0 = Arc::new(75);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-        assert!(76 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 == *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_weak() {\n-        let mut cow0 = Arc::new(75);\n-        let cow1_weak = Arc::downgrade(&cow0);\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1_weak.upgrade().unwrap());\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(cow1_weak.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_live() {\n-        let x = Arc::new(5);\n-        let y = Arc::downgrade(&x);\n-        assert!(y.upgrade().is_some());\n-    }\n-\n-    #[test]\n-    fn test_dead() {\n-        let x = Arc::new(5);\n-        let y = Arc::downgrade(&x);\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn weak_self_cyclic() {\n-        struct Cycle {\n-            x: Mutex<Option<Weak<Cycle>>>,\n-        }\n-\n-        let a = Arc::new(Cycle { x: Mutex::new(None) });\n-        let b = Arc::downgrade(&a.clone());\n-        *a.x.lock().unwrap() = Some(b);\n-\n-        // hopefully we don't double-free (or leak)...\n-    }\n-\n-    #[test]\n-    fn drop_arc() {\n-        let mut canary = atomic::AtomicUsize::new(0);\n-        let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        drop(x);\n-        assert!(canary.load(Acquire) == 1);\n-    }\n-\n-    #[test]\n-    fn drop_arc_weak() {\n-        let mut canary = atomic::AtomicUsize::new(0);\n-        let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        let arc_weak = Arc::downgrade(&arc);\n-        assert!(canary.load(Acquire) == 0);\n-        drop(arc);\n-        assert!(canary.load(Acquire) == 1);\n-        drop(arc_weak);\n-    }\n-\n-    #[test]\n-    fn test_strong_count() {\n-        let a = Arc::new(0);\n-        assert!(Arc::strong_count(&a) == 1);\n-        let w = Arc::downgrade(&a);\n-        assert!(Arc::strong_count(&a) == 1);\n-        let b = w.upgrade().expect(\"\");\n-        assert!(Arc::strong_count(&b) == 2);\n-        assert!(Arc::strong_count(&a) == 2);\n-        drop(w);\n-        drop(a);\n-        assert!(Arc::strong_count(&b) == 1);\n-        let c = b.clone();\n-        assert!(Arc::strong_count(&b) == 2);\n-        assert!(Arc::strong_count(&c) == 2);\n-    }\n-\n-    #[test]\n-    fn test_weak_count() {\n-        let a = Arc::new(0);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let w = Arc::downgrade(&a);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 1);\n-        let x = w.clone();\n-        assert!(Arc::weak_count(&a) == 2);\n-        drop(w);\n-        drop(x);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let c = a.clone();\n-        assert!(Arc::strong_count(&a) == 2);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let d = Arc::downgrade(&c);\n-        assert!(Arc::weak_count(&c) == 1);\n-        assert!(Arc::strong_count(&c) == 2);\n-\n-        drop(a);\n-        drop(c);\n-        drop(d);\n-    }\n-\n-    #[test]\n-    fn show_arc() {\n-        let a = Arc::new(5);\n-        assert_eq!(format!(\"{:?}\", a), \"5\");\n-    }\n-\n-    // Make sure deriving works with Arc<T>\n-    #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n-    struct Foo {\n-        inner: Arc<i32>,\n-    }\n-\n-    #[test]\n-    fn test_unsized() {\n-        let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n-        assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n-        let y = Arc::downgrade(&x.clone());\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_from_owned() {\n-        let foo = 123;\n-        let foo_arc = Arc::from(foo);\n-        assert!(123 == *foo_arc);\n-    }\n-\n-    #[test]\n-    fn test_new_weak() {\n-        let foo: Weak<usize> = Weak::new();\n-        assert!(foo.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_ptr_eq() {\n-        let five = Arc::new(5);\n-        let same_five = five.clone();\n-        let other_five = Arc::new(5);\n-\n-        assert!(Arc::ptr_eq(&five, &same_five));\n-        assert!(!Arc::ptr_eq(&five, &other_five));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg(not(miri))] // Miri does not support threads\n-    fn test_weak_count_locked() {\n-        let mut a = Arc::new(atomic::AtomicBool::new(false));\n-        let a2 = a.clone();\n-        let t = thread::spawn(move || {\n-            for _i in 0..1000000 {\n-                Arc::get_mut(&mut a);\n-            }\n-            a.store(true, SeqCst);\n-        });\n-\n-        while !a2.load(SeqCst) {\n-            let n = Arc::weak_count(&a2);\n-            assert!(n < 2, \"bad weak count: {}\", n);\n-        }\n-        t.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-        let r: Arc<str> = Arc::from(\"foo\");\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_copy_from_slice() {\n-        let s: &[u32] = &[1, 2, 3];\n-        let r: Arc<[u32]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_clone_from_slice() {\n-        #[derive(Clone, Debug, Eq, PartialEq)]\n-        struct X(u32);\n-\n-        let s: &[X] = &[X(1), X(2), X(3)];\n-        let r: Arc<[X]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], s);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clone_from_slice_panic() {\n-        use std::string::{String, ToString};\n-\n-        struct Fail(u32, String);\n-\n-        impl Clone for Fail {\n-            fn clone(&self) -> Fail {\n-                if self.0 == 2 {\n-                    panic!();\n-                }\n-                Fail(self.0, self.1.clone())\n-            }\n-        }\n-\n-        let s: &[Fail] = &[\n-            Fail(0, \"foo\".to_string()),\n-            Fail(1, \"bar\".to_string()),\n-            Fail(2, \"baz\".to_string()),\n-        ];\n-\n-        // Should panic, but not cause memory corruption\n-        let _r: Arc<[Fail]> = Arc::from(s);\n-    }\n-\n-    #[test]\n-    fn test_from_box() {\n-        let b: Box<u32> = box 123;\n-        let r: Arc<u32> = Arc::from(b);\n-\n-        assert_eq!(*r, 123);\n-    }\n-\n-    #[test]\n-    fn test_from_box_str() {\n-        use std::string::String;\n-\n-        let s = String::from(\"foo\").into_boxed_str();\n-        let r: Arc<str> = Arc::from(s);\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_slice() {\n-        let s = vec![1, 2, 3].into_boxed_slice();\n-        let r: Arc<[u32]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let b: Box<dyn Display> = box 123;\n-        let r: Arc<dyn Display> = Arc::from(b);\n-\n-        assert_eq!(r.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait_zero_sized() {\n-        use std::fmt::Debug;\n-\n-        let b: Box<dyn Debug> = box ();\n-        let r: Arc<dyn Debug> = Arc::from(b);\n-\n-        assert_eq!(format!(\"{:?}\", r), \"()\");\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        let v = vec![1, 2, 3];\n-        let r: Arc<[u32]> = Arc::from(v);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_downcast() {\n-        use std::any::Any;\n-\n-        let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n-        let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n-\n-        assert!(r1.clone().downcast::<u32>().is_err());\n-\n-        let r1i32 = r1.downcast::<i32>();\n-        assert!(r1i32.is_ok());\n-        assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n-\n-        assert!(r2.clone().downcast::<i32>().is_err());\n-\n-        let r2str = r2.downcast::<&'static str>();\n-        assert!(r2str.is_ok());\n-        assert_eq!(r2str.unwrap(), Arc::new(\"abc\"));\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n     fn borrow(&self) -> &T {"}, {"sha": "2e0c62f50c1678f7e2b6eefa695baa9e3b612707", "filename": "src/liballoc/sync/tests.rs", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -0,0 +1,480 @@\n+use super::*;\n+\n+use std::boxed::Box;\n+use std::clone::Clone;\n+use std::sync::mpsc::channel;\n+use std::mem::drop;\n+use std::ops::Drop;\n+use std::option::Option::{self, None, Some};\n+use std::sync::atomic::{self, Ordering::{Acquire, SeqCst}};\n+use std::thread;\n+use std::sync::Mutex;\n+use std::convert::From;\n+\n+use crate::vec::Vec;\n+\n+struct Canary(*mut atomic::AtomicUsize);\n+\n+impl Drop for Canary {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match *self {\n+                Canary(c) => {\n+                    (*c).fetch_add(1, SeqCst);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn manually_share_arc() {\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let arc_v = Arc::new(v);\n+\n+    let (tx, rx) = channel();\n+\n+    let _t = thread::spawn(move || {\n+        let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n+        assert_eq!((*arc_v)[3], 4);\n+    });\n+\n+    tx.send(arc_v.clone()).unwrap();\n+\n+    assert_eq!((*arc_v)[2], 3);\n+    assert_eq!((*arc_v)[4], 5);\n+}\n+\n+#[test]\n+fn test_arc_get_mut() {\n+    let mut x = Arc::new(3);\n+    *Arc::get_mut(&mut x).unwrap() = 4;\n+    assert_eq!(*x, 4);\n+    let y = x.clone();\n+    assert!(Arc::get_mut(&mut x).is_none());\n+    drop(y);\n+    assert!(Arc::get_mut(&mut x).is_some());\n+    let _w = Arc::downgrade(&x);\n+    assert!(Arc::get_mut(&mut x).is_none());\n+}\n+\n+#[test]\n+fn weak_counts() {\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n+\n+    let a = Arc::new(0);\n+    let w = Arc::downgrade(&a);\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(1));\n+    let w2 = w.clone();\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    drop(w);\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    let a2 = a.clone();\n+    assert_eq!(Weak::strong_count(&w2), 2);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(a2);\n+    drop(a);\n+    assert_eq!(Weak::strong_count(&w2), 0);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(w2);\n+}\n+\n+#[test]\n+fn try_unwrap() {\n+    let x = Arc::new(3);\n+    assert_eq!(Arc::try_unwrap(x), Ok(3));\n+    let x = Arc::new(4);\n+    let _y = x.clone();\n+    assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+    let x = Arc::new(5);\n+    let _w = Arc::downgrade(&x);\n+    assert_eq!(Arc::try_unwrap(x), Ok(5));\n+}\n+\n+#[test]\n+fn into_from_raw() {\n+    let x = Arc::new(box \"hello\");\n+    let y = x.clone();\n+\n+    let x_ptr = Arc::into_raw(x);\n+    drop(y);\n+    unsafe {\n+        assert_eq!(**x_ptr, \"hello\");\n+\n+        let x = Arc::from_raw(x_ptr);\n+        assert_eq!(**x, \"hello\");\n+\n+        assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+    }\n+}\n+\n+#[test]\n+fn test_into_from_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let arc: Arc<str> = Arc::from(\"foo\");\n+\n+    let ptr = Arc::into_raw(arc.clone());\n+    let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert_eq!(arc, arc2);\n+\n+    let arc: Arc<dyn Display> = Arc::new(123);\n+\n+    let ptr = Arc::into_raw(arc.clone());\n+    let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert_eq!(arc2.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_cowarc_clone_make_mut() {\n+    let mut cow0 = Arc::new(75);\n+    let mut cow1 = cow0.clone();\n+    let mut cow2 = cow1.clone();\n+\n+    assert!(75 == *Arc::make_mut(&mut cow0));\n+    assert!(75 == *Arc::make_mut(&mut cow1));\n+    assert!(75 == *Arc::make_mut(&mut cow2));\n+\n+    *Arc::make_mut(&mut cow0) += 1;\n+    *Arc::make_mut(&mut cow1) += 2;\n+    *Arc::make_mut(&mut cow2) += 3;\n+\n+    assert!(76 == *cow0);\n+    assert!(77 == *cow1);\n+    assert!(78 == *cow2);\n+\n+    // none should point to the same backing memory\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 != *cow2);\n+}\n+\n+#[test]\n+fn test_cowarc_clone_unique2() {\n+    let mut cow0 = Arc::new(75);\n+    let cow1 = cow0.clone();\n+    let cow2 = cow1.clone();\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    *Arc::make_mut(&mut cow0) += 1;\n+    assert!(76 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    // cow1 and cow2 should share the same contents\n+    // cow0 should have a unique reference\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 == *cow2);\n+}\n+\n+#[test]\n+fn test_cowarc_clone_weak() {\n+    let mut cow0 = Arc::new(75);\n+    let cow1_weak = Arc::downgrade(&cow0);\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1_weak.upgrade().unwrap());\n+\n+    *Arc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(cow1_weak.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_live() {\n+    let x = Arc::new(5);\n+    let y = Arc::downgrade(&x);\n+    assert!(y.upgrade().is_some());\n+}\n+\n+#[test]\n+fn test_dead() {\n+    let x = Arc::new(5);\n+    let y = Arc::downgrade(&x);\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn weak_self_cyclic() {\n+    struct Cycle {\n+        x: Mutex<Option<Weak<Cycle>>>,\n+    }\n+\n+    let a = Arc::new(Cycle { x: Mutex::new(None) });\n+    let b = Arc::downgrade(&a.clone());\n+    *a.x.lock().unwrap() = Some(b);\n+\n+    // hopefully we don't double-free (or leak)...\n+}\n+\n+#[test]\n+fn drop_arc() {\n+    let mut canary = atomic::AtomicUsize::new(0);\n+    let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n+    drop(x);\n+    assert!(canary.load(Acquire) == 1);\n+}\n+\n+#[test]\n+fn drop_arc_weak() {\n+    let mut canary = atomic::AtomicUsize::new(0);\n+    let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n+    let arc_weak = Arc::downgrade(&arc);\n+    assert!(canary.load(Acquire) == 0);\n+    drop(arc);\n+    assert!(canary.load(Acquire) == 1);\n+    drop(arc_weak);\n+}\n+\n+#[test]\n+fn test_strong_count() {\n+    let a = Arc::new(0);\n+    assert!(Arc::strong_count(&a) == 1);\n+    let w = Arc::downgrade(&a);\n+    assert!(Arc::strong_count(&a) == 1);\n+    let b = w.upgrade().expect(\"\");\n+    assert!(Arc::strong_count(&b) == 2);\n+    assert!(Arc::strong_count(&a) == 2);\n+    drop(w);\n+    drop(a);\n+    assert!(Arc::strong_count(&b) == 1);\n+    let c = b.clone();\n+    assert!(Arc::strong_count(&b) == 2);\n+    assert!(Arc::strong_count(&c) == 2);\n+}\n+\n+#[test]\n+fn test_weak_count() {\n+    let a = Arc::new(0);\n+    assert!(Arc::strong_count(&a) == 1);\n+    assert!(Arc::weak_count(&a) == 0);\n+    let w = Arc::downgrade(&a);\n+    assert!(Arc::strong_count(&a) == 1);\n+    assert!(Arc::weak_count(&a) == 1);\n+    let x = w.clone();\n+    assert!(Arc::weak_count(&a) == 2);\n+    drop(w);\n+    drop(x);\n+    assert!(Arc::strong_count(&a) == 1);\n+    assert!(Arc::weak_count(&a) == 0);\n+    let c = a.clone();\n+    assert!(Arc::strong_count(&a) == 2);\n+    assert!(Arc::weak_count(&a) == 0);\n+    let d = Arc::downgrade(&c);\n+    assert!(Arc::weak_count(&c) == 1);\n+    assert!(Arc::strong_count(&c) == 2);\n+\n+    drop(a);\n+    drop(c);\n+    drop(d);\n+}\n+\n+#[test]\n+fn show_arc() {\n+    let a = Arc::new(5);\n+    assert_eq!(format!(\"{:?}\", a), \"5\");\n+}\n+\n+// Make sure deriving works with Arc<T>\n+#[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n+struct Foo {\n+    inner: Arc<i32>,\n+}\n+\n+#[test]\n+fn test_unsized() {\n+    let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n+    assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n+    let y = Arc::downgrade(&x.clone());\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_from_owned() {\n+    let foo = 123;\n+    let foo_arc = Arc::from(foo);\n+    assert!(123 == *foo_arc);\n+}\n+\n+#[test]\n+fn test_new_weak() {\n+    let foo: Weak<usize> = Weak::new();\n+    assert!(foo.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_ptr_eq() {\n+    let five = Arc::new(5);\n+    let same_five = five.clone();\n+    let other_five = Arc::new(5);\n+\n+    assert!(Arc::ptr_eq(&five, &same_five));\n+    assert!(!Arc::ptr_eq(&five, &other_five));\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn test_weak_count_locked() {\n+    let mut a = Arc::new(atomic::AtomicBool::new(false));\n+    let a2 = a.clone();\n+    let t = thread::spawn(move || {\n+        for _i in 0..1000000 {\n+            Arc::get_mut(&mut a);\n+        }\n+        a.store(true, SeqCst);\n+    });\n+\n+    while !a2.load(SeqCst) {\n+        let n = Arc::weak_count(&a2);\n+        assert!(n < 2, \"bad weak count: {}\", n);\n+    }\n+    t.join().unwrap();\n+}\n+\n+#[test]\n+fn test_from_str() {\n+    let r: Arc<str> = Arc::from(\"foo\");\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_copy_from_slice() {\n+    let s: &[u32] = &[1, 2, 3];\n+    let r: Arc<[u32]> = Arc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_clone_from_slice() {\n+    #[derive(Clone, Debug, Eq, PartialEq)]\n+    struct X(u32);\n+\n+    let s: &[X] = &[X(1), X(2), X(3)];\n+    let r: Arc<[X]> = Arc::from(s);\n+\n+    assert_eq!(&r[..], s);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clone_from_slice_panic() {\n+    use std::string::{String, ToString};\n+\n+    struct Fail(u32, String);\n+\n+    impl Clone for Fail {\n+        fn clone(&self) -> Fail {\n+            if self.0 == 2 {\n+                panic!();\n+            }\n+            Fail(self.0, self.1.clone())\n+        }\n+    }\n+\n+    let s: &[Fail] = &[\n+        Fail(0, \"foo\".to_string()),\n+        Fail(1, \"bar\".to_string()),\n+        Fail(2, \"baz\".to_string()),\n+    ];\n+\n+    // Should panic, but not cause memory corruption\n+    let _r: Arc<[Fail]> = Arc::from(s);\n+}\n+\n+#[test]\n+fn test_from_box() {\n+    let b: Box<u32> = box 123;\n+    let r: Arc<u32> = Arc::from(b);\n+\n+    assert_eq!(*r, 123);\n+}\n+\n+#[test]\n+fn test_from_box_str() {\n+    use std::string::String;\n+\n+    let s = String::from(\"foo\").into_boxed_str();\n+    let r: Arc<str> = Arc::from(s);\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_from_box_slice() {\n+    let s = vec![1, 2, 3].into_boxed_slice();\n+    let r: Arc<[u32]> = Arc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_from_box_trait() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let b: Box<dyn Display> = box 123;\n+    let r: Arc<dyn Display> = Arc::from(b);\n+\n+    assert_eq!(r.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_from_box_trait_zero_sized() {\n+    use std::fmt::Debug;\n+\n+    let b: Box<dyn Debug> = box ();\n+    let r: Arc<dyn Debug> = Arc::from(b);\n+\n+    assert_eq!(format!(\"{:?}\", r), \"()\");\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    let v = vec![1, 2, 3];\n+    let r: Arc<[u32]> = Arc::from(v);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_downcast() {\n+    use std::any::Any;\n+\n+    let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n+    let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n+\n+    assert!(r1.clone().downcast::<u32>().is_err());\n+\n+    let r1i32 = r1.downcast::<i32>();\n+    assert!(r1i32.is_ok());\n+    assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n+\n+    assert!(r2.clone().downcast::<i32>().is_err());\n+\n+    let r2str = r2.downcast::<&'static str>();\n+    assert!(r2str.is_ok());\n+    assert_eq!(r2str.unwrap(), Arc::new(\"abc\"));\n+}"}, {"sha": "6286945ad26b528bd36b7ac3842f51ae528021fc", "filename": "src/tools/tidy/src/unit_tests.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0d6ee271a34d2329235b9a04cf4a421d9026cd/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs?ref=3d0d6ee271a34d2329235b9a04cf4a421d9026cd", "patch": "@@ -1,47 +1,35 @@\n-//! Tidy check to ensure `#[test]` and `#[bench]` are not used directly inside\n-//! `libcore` or `liballoc`.\n+//! Tidy check to ensure `#[test]` and `#[bench]` are not used directly inside `libcore`.\n //!\n-//! `#![no_std]` libraries cannot be tested directly due to duplicating lang\n-//! items. All tests and benchmarks must be written externally in `libcore/{tests,benches}`\n-//! or `liballoc/{tests,benches}`.\n+//! `#![no_core]` libraries cannot be tested directly due to duplicating lang\n+//! items. All tests and benchmarks must be written externally in `libcore/{tests,benches}`.\n //!\n-//! Outside of libcore and liballoc tests and benchmarks should be outlined into separate files\n+//! Outside of libcore tests and benchmarks should be outlined into separate files\n //! named `tests.rs` or `benches.rs`, or directories named `tests` or `benches` unconfigured\n //! during normal build.\n \n use std::path::Path;\n \n pub fn check(root_path: &Path, bad: &mut bool) {\n     let libcore = &root_path.join(\"libcore\");\n-    let liballoc = &root_path.join(\"liballoc\");\n     let libcore_tests = &root_path.join(\"libcore/tests\");\n-    let liballoc_tests = &root_path.join(\"liballoc/tests\");\n     let libcore_benches = &root_path.join(\"libcore/benches\");\n-    let liballoc_benches = &root_path.join(\"liballoc/benches\");\n-    let is_core_or_alloc = |path: &Path| {\n-        let is_core = path.starts_with(libcore) &&\n-                      !(path.starts_with(libcore_tests) || path.starts_with(libcore_benches));\n-        let is_alloc = path.starts_with(liballoc) &&\n-                       !(path.starts_with(liballoc_tests) || path.starts_with(liballoc_benches));\n-        is_core || is_alloc\n+    let is_core = |path: &Path| {\n+        path.starts_with(libcore) &&\n+        !(path.starts_with(libcore_tests) || path.starts_with(libcore_benches))\n     };\n-    let fixme = [\n-        \"liballoc\",\n-        \"libstd\",\n-    ];\n \n     let mut skip = |path: &Path| {\n         let file_name = path.file_name().unwrap_or_default();\n         if path.is_dir() {\n             super::filter_dirs(path) ||\n             path.ends_with(\"src/test\") ||\n             path.ends_with(\"src/doc\") ||\n-            (file_name == \"tests\" || file_name == \"benches\") && !is_core_or_alloc(path) ||\n-            fixme.iter().any(|p| path.ends_with(p))\n+            path.ends_with(\"src/libstd\") || // FIXME?\n+            (file_name == \"tests\" || file_name == \"benches\") && !is_core(path)\n         } else {\n             let extension = path.extension().unwrap_or_default();\n             extension != \"rs\" ||\n-            (file_name == \"tests.rs\" || file_name == \"benches.rs\") && !is_core_or_alloc(path)\n+            (file_name == \"tests.rs\" || file_name == \"benches.rs\") && !is_core(path)\n         }\n     };\n \n@@ -51,7 +39,6 @@ pub fn check(root_path: &Path, bad: &mut bool) {\n         &mut |entry, contents| {\n             let path = entry.path();\n             let is_libcore = path.starts_with(libcore);\n-            let is_liballoc = path.starts_with(liballoc);\n             for (i, line) in contents.lines().enumerate() {\n                 let line = line.trim();\n                 let is_test = || line.contains(\"#[test]\") && !line.contains(\"`#[test]\");\n@@ -60,9 +47,6 @@ pub fn check(root_path: &Path, bad: &mut bool) {\n                     let explanation = if is_libcore {\n                         \"libcore unit tests and benchmarks must be placed into \\\n                          `libcore/tests` or `libcore/benches`\"\n-                    } else if is_liballoc {\n-                        \"liballoc unit tests and benchmarks must be placed into \\\n-                         `liballoc/tests` or `liballoc/benches`\"\n                     } else {\n                         \"unit tests and benchmarks must be placed into \\\n                          separate files or directories named \\"}]}