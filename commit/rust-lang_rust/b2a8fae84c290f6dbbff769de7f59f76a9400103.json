{"sha": "b2a8fae84c290f6dbbff769de7f59f76a9400103", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYThmYWU4NGMyOTBmNmRiYmZmNzY5ZGU3ZjU5Zjc2YTk0MDAxMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-27T06:41:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-27T06:41:31Z"}, "message": "auto merge of #13783 : wackywendell/rust/permfix, r=kballard\n\nI filed bugs #13734 and #13759 recently, and then realized I could probably fix them myself. This does exactly that, with a couple additional modifications and additions to the test-suite to pick up on that.\r\n\r\nI've never done this before, so please feel free to tell me all the things I'm doing wrong or could be doing better.", "tree": {"sha": "fe78ebfb22a7186469561126aa2c4f81e0267998", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe78ebfb22a7186469561126aa2c4f81e0267998"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2a8fae84c290f6dbbff769de7f59f76a9400103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2a8fae84c290f6dbbff769de7f59f76a9400103", "html_url": "https://github.com/rust-lang/rust/commit/b2a8fae84c290f6dbbff769de7f59f76a9400103", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2a8fae84c290f6dbbff769de7f59f76a9400103/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ffe56ce38d8680fa3c1a7cfd6f8bde609e4bc7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ffe56ce38d8680fa3c1a7cfd6f8bde609e4bc7a", "html_url": "https://github.com/rust-lang/rust/commit/3ffe56ce38d8680fa3c1a7cfd6f8bde609e4bc7a"}, {"sha": "b7d0feb90cc1466fd0e419b6513b0617b2f3c695", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7d0feb90cc1466fd0e419b6513b0617b2f3c695", "html_url": "https://github.com/rust-lang/rust/commit/b7d0feb90cc1466fd0e419b6513b0617b2f3c695"}], "stats": {"total": 55, "additions": 48, "deletions": 7}, "files": [{"sha": "f5e064942e68bcbfe553bee6991d6de8cb56832e", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b2a8fae84c290f6dbbff769de7f59f76a9400103/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a8fae84c290f6dbbff769de7f59f76a9400103/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=b2a8fae84c290f6dbbff769de7f59f76a9400103", "patch": "@@ -307,6 +307,7 @@ pub struct ElementSwaps {\n     sdir: ~[SizeDirection],\n     /// If true, emit the last swap that returns the sequence to initial state\n     emit_reset: bool,\n+    swaps_made : uint,\n }\n \n impl ElementSwaps {\n@@ -319,7 +320,8 @@ impl ElementSwaps {\n             emit_reset: true,\n             sdir: range(0, length)\n                     .map(|i| SizeDirection{ size: i, dir: Neg })\n-                    .collect::<~[_]>()\n+                    .collect::<~[_]>(),\n+            swaps_made: 0\n         }\n     }\n }\n@@ -358,16 +360,30 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n                         x.dir = match x.dir { Pos => Neg, Neg => Pos };\n                     }\n                 }\n+                self.swaps_made += 1;\n                 Some((i, j))\n             },\n-            None => if self.emit_reset && self.sdir.len() > 1 {\n+            None => if self.emit_reset {\n                 self.emit_reset = false;\n-                Some((0, 1))\n-            } else {\n-                None\n-            }\n+                if self.sdir.len() > 1 {\n+                    // The last swap\n+                    self.swaps_made += 1;\n+                    Some((0, 1))\n+                } else {\n+                    // Vector is of the form [] or [x], and the only permutation is itself\n+                    self.swaps_made += 1;\n+                    Some((0,0))\n+                }\n+            } else { None }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        // For a vector of size n, there are exactly n! permutations.\n+        let n = range(2, self.sdir.len() + 1).product();\n+        (n - self.swaps_made, Some(n - self.swaps_made))\n+    }\n }\n \n /// An Iterator that uses `ElementSwaps` to iterate through\n@@ -388,13 +404,19 @@ impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n     fn next(&mut self) -> Option<~[T]> {\n         match self.swaps.next() {\n             None => None,\n+            Some((0,0)) => Some(self.v.clone()),\n             Some((a, b)) => {\n                 let elt = self.v.clone();\n                 self.v.swap(a, b);\n                 Some(elt)\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.swaps.size_hint()\n+    }\n }\n \n /// An iterator over the (overlapping) slices of length `size` within\n@@ -2767,19 +2789,33 @@ mod tests {\n         {\n             let v: [int, ..0] = [];\n             let mut it = v.permutations();\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 1);\n+            assert_eq!(max_opt.unwrap(), 1);\n+            assert_eq!(it.next(), Some(v.as_slice().to_owned()));\n             assert_eq!(it.next(), None);\n         }\n         {\n             let v = [\"Hello\".to_owned()];\n             let mut it = v.permutations();\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 1);\n+            assert_eq!(max_opt.unwrap(), 1);\n+            assert_eq!(it.next(), Some(v.as_slice().to_owned()));\n             assert_eq!(it.next(), None);\n         }\n         {\n             let v = [1, 2, 3];\n             let mut it = v.permutations();\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 3*2);\n+            assert_eq!(max_opt.unwrap(), 3*2);\n             assert_eq!(it.next(), Some(~[1,2,3]));\n             assert_eq!(it.next(), Some(~[1,3,2]));\n             assert_eq!(it.next(), Some(~[3,1,2]));\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 3);\n+            assert_eq!(max_opt.unwrap(), 3);\n             assert_eq!(it.next(), Some(~[3,2,1]));\n             assert_eq!(it.next(), Some(~[2,3,1]));\n             assert_eq!(it.next(), Some(~[2,1,3]));\n@@ -2789,10 +2825,15 @@ mod tests {\n             // check that we have N! permutations\n             let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n             let mut amt = 0;\n-            for _perm in v.permutations() {\n+            let mut it = v.permutations();\n+            let (min_size, max_opt) = it.size_hint();\n+            for _perm in it {\n                 amt += 1;\n             }\n+            assert_eq!(amt, it.swaps.swaps_made);\n+            assert_eq!(amt, min_size);\n             assert_eq!(amt, 2 * 3 * 4 * 5 * 6);\n+            assert_eq!(amt, max_opt.unwrap());\n         }\n     }\n "}]}