{"sha": "3ccd35cd70eed139de411f9533d406c498ed4d62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjY2QzNWNkNzBlZWQxMzlkZTQxMWY5NTMzZDQwNmM0OThlZDRkNjI=", "commit": {"author": {"name": "Sean McArthur", "email": "sean@seanmonstar.com", "date": "2019-03-15T21:55:04Z"}, "committer": {"name": "Sean McArthur", "email": "sean@seanmonstar.com", "date": "2019-04-01T18:23:40Z"}, "message": "resolve all in scope trait aliases, then elaborate their bounds", "tree": {"sha": "d82c8e581f1d0edfaf56bd5c4b4de6ef1cce7679", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d82c8e581f1d0edfaf56bd5c4b4de6ef1cce7679"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ccd35cd70eed139de411f9533d406c498ed4d62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ccd35cd70eed139de411f9533d406c498ed4d62", "html_url": "https://github.com/rust-lang/rust/commit/3ccd35cd70eed139de411f9533d406c498ed4d62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ccd35cd70eed139de411f9533d406c498ed4d62/comments", "author": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2b6734ea40dcd53e1bdad6d8dc3e31c0fec929a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b6734ea40dcd53e1bdad6d8dc3e31c0fec929a", "html_url": "https://github.com/rust-lang/rust/commit/a2b6734ea40dcd53e1bdad6d8dc3e31c0fec929a"}], "stats": {"total": 211, "additions": 166, "deletions": 45}, "files": [{"sha": "fdfb21a605f7f325168aa2c582b6e1f8d3e272b2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3ccd35cd70eed139de411f9533d406c498ed4d62", "patch": "@@ -1195,13 +1195,6 @@ impl<'a> ModuleData<'a> {\n         }\n     }\n \n-    fn is_trait_alias(&self) -> bool {\n-        match self.kind {\n-            ModuleKind::Def(Def::TraitAlias(_), _) => true,\n-            _ => false,\n-        }\n-    }\n-\n     fn nearest_item_scope(&'a self) -> Module<'a> {\n         if self.is_trait() { self.parent.unwrap() } else { self }\n     }\n@@ -1359,7 +1352,7 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    // We sometimes need to treat variants as `pub` for backwards compatibility\n+    // We sometimes need to treat variants as `pub` for backwards compatibility.\n     fn pseudo_vis(&self) -> ty::Visibility {\n         if self.is_variant() && self.def().def_id().is_local() {\n             ty::Visibility::Public\n@@ -2717,7 +2710,7 @@ impl<'a> Resolver<'a> {\n     {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n-        // plain insert (no renaming, types are not currently hygienic....)\n+        // Plain insert (no renaming, since types are not currently hygienic)\n         self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n@@ -4386,18 +4379,37 @@ impl<'a> Resolver<'a> {\n         }\n \n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            let module = binding.module().unwrap();\n-            let mut ident = ident;\n-            if ident.span.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n-                continue\n-            }\n-            if self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                false,\n-                module.span,\n-            ).is_ok() {\n+            // Traits have pseudo-modules that can be used to search for the given ident.\n+            if let Some(module) = binding.module() {\n+                let mut ident = ident;\n+                if ident.span.glob_adjust(\n+                    module.expansion,\n+                    binding.span.ctxt().modern(),\n+                ).is_none() {\n+                    continue\n+                }\n+                if self.resolve_ident_in_module_unadjusted(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    false,\n+                    module.span,\n+                ).is_ok() {\n+                    let import_id = match binding.kind {\n+                        NameBindingKind::Import { directive, .. } => {\n+                            self.maybe_unused_trait_imports.insert(directive.id);\n+                            self.add_to_glob_map(&directive, trait_name);\n+                            Some(directive.id)\n+                        }\n+                        _ => None,\n+                    };\n+                    let trait_def_id = module.def_id().unwrap();\n+                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_id });\n+                }\n+            } else if let Def::TraitAlias(_) = binding.def() {\n+                // For now, just treat all trait aliases as possible candidates, since we don't\n+                // know if the ident is somewhere in the transitive bounds.\n+\n                 let import_id = match binding.kind {\n                     NameBindingKind::Import { directive, .. } => {\n                         self.maybe_unused_trait_imports.insert(directive.id);\n@@ -4406,8 +4418,10 @@ impl<'a> Resolver<'a> {\n                     }\n                     _ => None,\n                 };\n-                let trait_def_id = module.def_id().unwrap();\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: import_id });\n+                let trait_def_id = binding.def().def_id();\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id });\n+            } else {\n+                bug!(\"candidate is not trait or trait alias?\")\n             }\n         }\n     }\n@@ -4843,7 +4857,6 @@ impl<'a> Resolver<'a> {\n         let container = match parent.kind {\n             ModuleKind::Def(Def::Mod(_), _) => \"module\",\n             ModuleKind::Def(Def::Trait(_), _) => \"trait\",\n-            ModuleKind::Def(Def::TraitAlias(_), _) => \"trait alias\",\n             ModuleKind::Block(..) => \"block\",\n             _ => \"enum\",\n         };\n@@ -4872,7 +4885,6 @@ impl<'a> Resolver<'a> {\n             (TypeNS, _) if old_binding.is_extern_crate() => \"extern crate\",\n             (TypeNS, Some(module)) if module.is_normal() => \"module\",\n             (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n-            (TypeNS, Some(module)) if module.is_trait_alias() => \"trait alias\",\n             (TypeNS, _) => \"type\",\n         };\n "}, {"sha": "05597de2735ef63ab4695ef2421b609a23972cdf", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=3ccd35cd70eed139de411f9533d406c498ed4d62", "patch": "@@ -1245,7 +1245,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         self.populate_module_if_necessary(module);\n \n-        if let Some(Def::Trait(_)) = module.def() {\n+        if module.is_trait() {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n         } else if module.def_id() == directive.parent_scope.module.def_id()  {"}, {"sha": "48fa26e5882fe50f284461c4c741fe8d31eb6900", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3ccd35cd70eed139de411f9533d406c498ed4d62", "patch": "@@ -895,20 +895,36 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let trait_substs = self.fresh_item_substs(trait_def_id);\n         let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n \n-        for item in self.impl_or_trait_item(trait_def_id) {\n-            // Check whether `trait_def_id` defines a method with suitable name:\n-            if !self.has_applicable_self(&item) {\n-                debug!(\"method has inapplicable self\");\n-                self.record_static_candidate(TraitSource(trait_def_id));\n-                continue;\n-            }\n+        if self.tcx.is_trait_alias(trait_def_id) {\n+            // For trait aliases, assume all super-traits are relevant.\n+            let bounds = iter::once(trait_ref.to_poly_trait_ref());\n+            self.elaborate_bounds(bounds, |this, new_trait_ref, item| {\n+                let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n+\n+                let (xform_self_ty, xform_ret_ty) =\n+                    this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n+                this.push_candidate(Candidate {\n+                    xform_self_ty, xform_ret_ty, item, import_id,\n+                    kind: TraitCandidate(new_trait_ref),\n+                }, true);\n+            });\n+        } else {\n+            debug_assert!(self.tcx.is_trait(trait_def_id));\n+            for item in self.impl_or_trait_item(trait_def_id) {\n+                // Check whether `trait_def_id` defines a method with suitable name.\n+                if !self.has_applicable_self(&item) {\n+                    debug!(\"method has inapplicable self\");\n+                    self.record_static_candidate(TraitSource(trait_def_id));\n+                    continue;\n+                }\n \n-            let (xform_self_ty, xform_ret_ty) =\n-                self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n-            self.push_candidate(Candidate {\n-                xform_self_ty, xform_ret_ty, item, import_id,\n-                kind: TraitCandidate(trait_ref),\n-            }, false);\n+                let (xform_self_ty, xform_ret_ty) =\n+                    self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n+                self.push_candidate(Candidate {\n+                    xform_self_ty, xform_ret_ty, item, import_id,\n+                    kind: TraitCandidate(trait_ref),\n+                }, false);\n+            }\n         }\n         Ok(())\n     }\n@@ -929,7 +945,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             .filter(|&name| set.insert(name))\n             .collect();\n \n-        // sort them by the name so we have a stable result\n+        // Sort them by the name so we have a stable result.\n         names.sort_by_cached_key(|n| n.as_str());\n         names\n     }\n@@ -944,6 +960,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return r;\n         }\n \n+        debug!(\"pick: actual search failed, assemble diagnotics\");\n+\n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n         let private_candidate = self.private_candidate.take();\n         let unsatisfied_predicates = mem::replace(&mut self.unsatisfied_predicates, vec![]);"}, {"sha": "b49614eedb15f136a452043bedb1b959584f1ff7", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3ccd35cd70eed139de411f9533d406c498ed4d62", "patch": "@@ -748,9 +748,13 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n \n     impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n         fn visit_item(&mut self, i: &'v hir::Item) {\n-            if let hir::ItemKind::Trait(..) = i.node {\n-                let def_id = self.map.local_def_id_from_hir_id(i.hir_id);\n-                self.traits.push(def_id);\n+            match i.node {\n+                hir::ItemKind::Trait(..) |\n+                hir::ItemKind::TraitAlias(..) => {\n+                    let def_id = self.map.local_def_id_from_hir_id(i.hir_id);\n+                    self.traits.push(def_id);\n+                }\n+                _ => ()\n             }\n         }\n \n@@ -772,7 +776,8 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n                            external_mods: &mut FxHashSet<DefId>,\n                            def: Def) {\n         match def {\n-            Def::Trait(def_id) => {\n+            Def::Trait(def_id) |\n+            Def::TraitAlias(def_id) => {\n                 traits.push(def_id);\n             }\n             Def::Mod(def_id) => {"}, {"sha": "9e412215512c90bc4e978bea8116d88a8637a9ee", "filename": "src/test/run-pass/traits/auxiliary/trait_alias.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Frun-pass%2Ftraits%2Fauxiliary%2Ftrait_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Frun-pass%2Ftraits%2Fauxiliary%2Ftrait_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fauxiliary%2Ftrait_alias.rs?ref=3ccd35cd70eed139de411f9533d406c498ed4d62", "patch": "@@ -0,0 +1,13 @@\n+#![feature(trait_alias)]\n+\n+pub trait Hello {\n+    fn hello(&self);\n+}\n+\n+pub struct Hi;\n+\n+impl Hello for Hi {\n+    fn hello(&self) {}\n+}\n+\n+pub trait Greet = Hello;"}, {"sha": "975542ab49b591edc531efb3b5047a901eaafeae", "filename": "src/test/run-pass/traits/trait-alias-import-cross-crate.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import-cross-crate.rs?ref=3ccd35cd70eed139de411f9533d406c498ed4d62", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+// aux-build:trait_alias.rs\n+\n+#![feature(trait_alias)]\n+\n+extern crate trait_alias;\n+\n+// Import only the alias, not the real trait.\n+use trait_alias::{Greet, Hi};\n+\n+fn main() {\n+    let hi = Hi;\n+    hi.hello(); // From `Hello`, via `Greet` alias.\n+}"}, {"sha": "7d63320b9aad433a225b5b139030e1b5be67ebc4", "filename": "src/test/run-pass/traits/trait-alias-import.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-import.rs?ref=3ccd35cd70eed139de411f9533d406c498ed4d62", "patch": "@@ -14,10 +14,25 @@ mod inner {\n     pub trait Bar = Foo;\n }\n \n+mod two {\n+    pub trait A {\n+        fn foo();\n+    }\n+\n+    impl A for u8 {\n+        fn foo() {}\n+    }\n+}\n+\n // Import only the alias, not the `Foo` trait.\n use inner::{Bar, Qux};\n \n+// Declaring an alias also brings in aliased methods.\n+trait Two = two::A;\n+\n fn main() {\n     let q = Qux;\n-    q.foo();\n+    q.foo(); // From Bar.\n+\n+    u8::foo(); // From A.\n }"}, {"sha": "28409e0c662775a88d86f42b31ff0d573f98b08d", "filename": "src/test/ui/traits/trait-alias-ambiguous.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.rs?ref=3ccd35cd70eed139de411f9533d406c498ed4d62", "patch": "@@ -0,0 +1,24 @@\n+#![feature(trait_alias)]\n+\n+mod inner {\n+    pub trait A { fn foo(&self); }\n+    pub trait B { fn foo(&self); }\n+\n+    impl A for u8 {\n+        fn foo(&self) {}\n+    }\n+    impl B for u8 {\n+        fn foo(&self) {}\n+    }\n+\n+    pub trait C = A + B;\n+}\n+\n+use inner::C;\n+\n+fn main() {\n+    let t = 1u8;\n+    t.foo(); //~ ERROR E0034\n+\n+    inner::A::foo(&t); // ok\n+}"}, {"sha": "b7443269b882d63509ef4a8063b540fa0144ed23", "filename": "src/test/ui/traits/trait-alias-ambiguous.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ccd35cd70eed139de411f9533d406c498ed4d62/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr?ref=3ccd35cd70eed139de411f9533d406c498ed4d62", "patch": "@@ -0,0 +1,20 @@\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/trait-alias-ambiguous.rs:21:7\n+   |\n+LL |     t.foo();\n+   |       ^^^ multiple `foo` found\n+   |\n+note: candidate #1 is defined in an impl of the trait `inner::A` for the type `u8`\n+  --> $DIR/trait-alias-ambiguous.rs:8:9\n+   |\n+LL |         fn foo(&self) {}\n+   |         ^^^^^^^^^^^^^\n+note: candidate #2 is defined in an impl of the trait `inner::B` for the type `u8`\n+  --> $DIR/trait-alias-ambiguous.rs:11:9\n+   |\n+LL |         fn foo(&self) {}\n+   |         ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0034`."}]}