{"sha": "9ca42a56000d261be74db41339beff06bc6088c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYTQyYTU2MDAwZDI2MWJlNzRkYjQxMzM5YmVmZjA2YmM2MDg4Yzk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-15T01:41:21Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-16T01:12:00Z"}, "message": "or-patterns: liveness: generalize + remove `top_pats_hack`.", "tree": {"sha": "0fda34624d6a61b8d78bb33819569d6bb196484b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fda34624d6a61b8d78bb33819569d6bb196484b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ca42a56000d261be74db41339beff06bc6088c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ca42a56000d261be74db41339beff06bc6088c9", "html_url": "https://github.com/rust-lang/rust/commit/9ca42a56000d261be74db41339beff06bc6088c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ca42a56000d261be74db41339beff06bc6088c9/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc5fe6d520683e847d1d5fd2a4544e2a5dba9ab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc5fe6d520683e847d1d5fd2a4544e2a5dba9ab4", "html_url": "https://github.com/rust-lang/rust/commit/cc5fe6d520683e847d1d5fd2a4544e2a5dba9ab4"}], "stats": {"total": 316, "additions": 141, "deletions": 175}, "files": [{"sha": "b68886ba62c2d316728c1d5aaf2e1e6d6993a96a", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9ca42a56000d261be74db41339beff06bc6088c9/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca42a56000d261be74db41339beff06bc6088c9/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=9ca42a56000d261be74db41339beff06bc6088c9", "patch": "@@ -77,6 +77,34 @@ impl hir::Pat {\n         });\n     }\n \n+    /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n+    /// `match foo() { Some(a) => (), None => () }`.\n+    ///\n+    /// When encountering an or-pattern `p_0 | ... | p_n` only `p_0` will be visited.\n+    pub fn each_binding_or_first<F>(&self, c: &mut F)\n+        where F: FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n+    {\n+        match &self.node {\n+            PatKind::Binding(bm,  _, ident, sub) => {\n+                c(*bm, self.hir_id, self.span, *ident);\n+                sub.iter().for_each(|p| p.each_binding_or_first(c));\n+            }\n+            PatKind::Or(ps) => ps[0].each_binding_or_first(c),\n+            PatKind::Struct(_, fs, _) => fs.iter().for_each(|f| f.pat.each_binding_or_first(c)),\n+            PatKind::TupleStruct(_, ps, _) | PatKind::Tuple(ps, _) => {\n+                ps.iter().for_each(|p| p.each_binding_or_first(c));\n+            }\n+            PatKind::Box(p) | PatKind::Ref(p, _) => p.each_binding_or_first(c),\n+            PatKind::Slice(before, slice, after) => {\n+                before.iter()\n+                      .chain(slice.iter())\n+                      .chain(after.iter())\n+                      .for_each(|p| p.each_binding_or_first(c));\n+            }\n+            PatKind::Wild | PatKind::Lit(_) | PatKind::Range(..) | PatKind::Path(_) => {}\n+        }\n+    }\n+\n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n     pub fn contains_bindings(&self) -> bool {"}, {"sha": "9afd147ae34e2071a5bef10f2a4f1b2a2827dd2a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 113, "deletions": 175, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/9ca42a56000d261be74db41339beff06bc6088c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca42a56000d261be74db41339beff06bc6088c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9ca42a56000d261be74db41339beff06bc6088c9", "patch": "@@ -96,7 +96,11 @@\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n+use crate::hir;\n+use crate::hir::{Expr, HirId};\n use crate::hir::def::*;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use crate::hir::Node;\n use crate::hir::ptr::P;\n use crate::ty::{self, TyCtxt};\n@@ -105,20 +109,16 @@ use crate::lint;\n use crate::util::nodemap::{HirIdMap, HirIdSet};\n \n use errors::Applicability;\n-use std::collections::{BTreeMap, VecDeque};\n+use rustc_data_structures::fx::FxIndexMap;\n+use std::collections::VecDeque;\n use std::{fmt, u32};\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use crate::hir;\n-use crate::hir::{Expr, HirId};\n-use crate::hir::def_id::DefId;\n-use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n-\n #[derive(Copy, Clone, PartialEq)]\n struct Variable(u32);\n \n@@ -727,35 +727,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.ir.variable(hir_id, span)\n     }\n \n-    fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, HirId),\n-    {\n-        pat.each_binding(|_bm, hir_id, sp, n| {\n-            let ln = self.live_node(hir_id, sp);\n-            let var = self.variable(hir_id, n.span);\n-            f(self, ln, var, n.span, hir_id);\n-        })\n-    }\n-\n-    fn arm_pats_bindings<F>(&mut self, pat: Option<&hir::Pat>, f: F) where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, HirId),\n-    {\n-        if let Some(pat) = pat {\n-            self.pat_bindings(pat, f);\n-        }\n-    }\n-\n-    fn define_bindings_in_pat(&mut self, pat: &hir::Pat, succ: LiveNode)\n-                              -> LiveNode {\n-        self.define_bindings_in_arm_pats(Some(pat), succ)\n-    }\n-\n-    fn define_bindings_in_arm_pats(&mut self, pat: Option<&hir::Pat>, succ: LiveNode)\n-                                   -> LiveNode {\n-        let mut succ = succ;\n-        self.arm_pats_bindings(pat, |this, ln, var, _sp, _id| {\n-            this.init_from_succ(ln, succ);\n-            this.define(ln, var);\n+    fn define_bindings_in_pat(&mut self, pat: &hir::Pat, mut succ: LiveNode) -> LiveNode {\n+        // In an or-pattern, only consider the first pattern; any later patterns\n+        // must have the same bindings, and we also consider the first pattern\n+        // to be the \"authoritative\" set of ids.\n+        pat.each_binding_or_first(&mut |_, hir_id, pat_sp, ident| {\n+            let ln = self.live_node(hir_id, pat_sp);\n+            let var = self.variable(hir_id, ident.span);\n+            self.init_from_succ(ln, succ);\n+            self.define(ln, var);\n             succ = ln;\n         });\n         succ\n@@ -1069,12 +1049,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         arm.guard.as_ref().map(|hir::Guard::If(e)| &**e),\n                         body_succ\n                     );\n-                    // only consider the first pattern; any later patterns must have\n-                    // the same bindings, and we also consider the first pattern to be\n-                    // the \"authoritative\" set of ids\n-                    let arm_succ =\n-                        self.define_bindings_in_arm_pats(arm.top_pats_hack().first().map(|p| &**p),\n-                                                         guard_succ);\n+                    let arm_succ = self.define_bindings_in_pat(&arm.pat, guard_succ);\n                     self.merge_from_succ(ln, arm_succ, first_merge);\n                     first_merge = false;\n                 };\n@@ -1381,74 +1356,36 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        check_local(self, l);\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        check_expr(self, ex);\n-    }\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n-        check_arm(self, a);\n-    }\n-}\n+    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+        self.check_unused_vars_in_pat(&local.pat, None, |spans, hir_id, ln, var| {\n+            if local.init.is_some() {\n+                self.warn_about_dead_assign(spans, hir_id, ln, var);\n+            }\n+        });\n \n-fn check_local<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, local: &'tcx hir::Local) {\n-    match local.init {\n-        Some(_) => {\n-            this.warn_about_unused_or_dead_vars_in_pat(&local.pat);\n-        },\n-        None => {\n-            this.pat_bindings(&local.pat, |this, ln, var, sp, id| {\n-                let span = local.pat.simple_ident().map_or(sp, |ident| ident.span);\n-                this.warn_about_unused(vec![span], id, ln, var);\n-            })\n-        }\n+        intravisit::walk_local(self, local);\n     }\n \n-    intravisit::walk_local(this, local);\n-}\n-\n-fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-    // Only consider the variable from the first pattern; any later patterns must have\n-    // the same bindings, and we also consider the first pattern to be the \"authoritative\" set of\n-    // ids. However, we should take the spans of variables with the same name from the later\n-    // patterns so the suggestions to prefix with underscores will apply to those too.\n-    let mut vars: BTreeMap<String, (LiveNode, Variable, HirId, Vec<Span>)> = Default::default();\n-\n-    for pat in arm.top_pats_hack() {\n-        this.arm_pats_bindings(Some(&*pat), |this, ln, var, sp, id| {\n-            let name = this.ir.variable_name(var);\n-            vars.entry(name)\n-                .and_modify(|(.., spans)| {\n-                    spans.push(sp);\n-                })\n-                .or_insert_with(|| {\n-                    (ln, var, id, vec![sp])\n-                });\n-        });\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+        check_expr(self, ex);\n     }\n \n-    for (_, (ln, var, id, spans)) in vars {\n-        this.warn_about_unused(spans, id, ln, var);\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n+        self.check_unused_vars_in_pat(&arm.pat, None, |_, _, _, _| {});\n+        intravisit::walk_arm(self, arm);\n     }\n-\n-    intravisit::walk_arm(this, arm);\n }\n \n-fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n+fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n         hir::ExprKind::Assign(ref l, _) => {\n             this.check_place(&l);\n-\n-            intravisit::walk_expr(this, expr);\n         }\n \n         hir::ExprKind::AssignOp(_, ref l, _) => {\n             if !this.tables.is_method_call(expr) {\n                 this.check_place(&l);\n             }\n-\n-            intravisit::walk_expr(this, expr);\n         }\n \n         hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n@@ -1463,8 +1400,6 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n                 }\n                 this.visit_expr(output);\n             }\n-\n-            intravisit::walk_expr(this, expr);\n         }\n \n         // no correctness conditions related to liveness\n@@ -1477,13 +1412,13 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n         hir::ExprKind::Lit(_) | hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n         hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n         hir::ExprKind::Closure(..) | hir::ExprKind::Path(_) | hir::ExprKind::Yield(..) |\n-        hir::ExprKind::Box(..) | hir::ExprKind::Type(..) | hir::ExprKind::Err => {\n-            intravisit::walk_expr(this, expr);\n-        }\n+        hir::ExprKind::Box(..) | hir::ExprKind::Type(..) | hir::ExprKind::Err => {}\n     }\n+\n+    intravisit::walk_expr(this, expr);\n }\n \n-impl<'a, 'tcx> Liveness<'a, 'tcx> {\n+impl<'tcx> Liveness<'_, 'tcx> {\n     fn check_place(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n@@ -1496,7 +1431,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         // as being used.\n                         let ln = self.live_node(expr.hir_id, expr.span);\n                         let var = self.variable(var_hid, expr.span);\n-                        self.warn_about_dead_assign(expr.span, expr.hir_id, ln, var);\n+                        self.warn_about_dead_assign(vec![expr.span], expr.hir_id, ln, var);\n                     }\n                 }\n             }\n@@ -1518,109 +1453,112 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n-        for param in &body.params {\n-            param.pat.each_binding(|_bm, hir_id, _, ident| {\n-                let sp = ident.span;\n-                let var = self.variable(hir_id, sp);\n-                // Ignore unused self.\n-                if ident.name != kw::SelfLower {\n-                    if !self.warn_about_unused(vec![sp], hir_id, entry_ln, var) {\n-                        if self.live_on_entry(entry_ln, var).is_none() {\n-                            self.report_dead_assign(hir_id, sp, var, true);\n-                        }\n-                    }\n+        for p in &body.params {\n+            self.check_unused_vars_in_pat(&p.pat, Some(entry_ln), |spans, hir_id, ln, var| {\n+                if self.live_on_entry(ln, var).is_none() {\n+                    self.report_dead_assign(hir_id, spans, var, true);\n                 }\n-            })\n+            });\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &hir::Pat) {\n-        self.pat_bindings(pat, |this, ln, var, sp, id| {\n-            if !this.warn_about_unused(vec![sp], id, ln, var) {\n-                this.warn_about_dead_assign(sp, id, ln, var);\n+    fn check_unused_vars_in_pat(\n+        &self,\n+        pat: &hir::Pat,\n+        entry_ln: Option<LiveNode>,\n+        on_used_on_entry: impl Fn(Vec<Span>, HirId, LiveNode, Variable),\n+    ) {\n+        // In an or-pattern, only consider the variable; any later patterns must have the same\n+        // bindings, and we also consider the first pattern to be the \"authoritative\" set of ids.\n+        // However, we should take the spans of variables with the same name from the later\n+        // patterns so the suggestions to prefix with underscores will apply to those too.\n+        let mut vars: FxIndexMap<String, (LiveNode, Variable, HirId, Vec<Span>)> = <_>::default();\n+\n+        pat.each_binding(|_, hir_id, pat_sp, ident| {\n+            let ln = entry_ln.unwrap_or_else(|| self.live_node(hir_id, pat_sp));\n+            let var = self.variable(hir_id, ident.span);\n+            vars.entry(self.ir.variable_name(var))\n+                .and_modify(|(.., spans)| spans.push(ident.span))\n+                .or_insert_with(|| (ln, var, hir_id, vec![ident.span]));\n+        });\n+\n+        for (_, (ln, var, id, spans)) in vars {\n+            if self.used_on_entry(ln, var) {\n+                on_used_on_entry(spans, id, ln, var);\n+            } else {\n+                self.report_unused(spans, id, ln, var);\n             }\n-        })\n+        }\n     }\n \n-    fn warn_about_unused(&self,\n-                         spans: Vec<Span>,\n-                         hir_id: HirId,\n-                         ln: LiveNode,\n-                         var: Variable)\n-                         -> bool {\n-        if !self.used_on_entry(ln, var) {\n-            let r = self.should_warn(var);\n-            if let Some(name) = r {\n-                // annoying: for parameters in funcs like `fn(x: i32)\n-                // {ret}`, there is only one node, so asking about\n-                // assigned_on_exit() is not meaningful.\n-                let is_assigned = if ln == self.s.exit_ln {\n-                    false\n-                } else {\n-                    self.assigned_on_exit(ln, var).is_some()\n-                };\n+    fn report_unused(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n+        if let Some(name) = self.should_warn(var).filter(|name| name != \"self\") {\n+            // annoying: for parameters in funcs like `fn(x: i32)\n+            // {ret}`, there is only one node, so asking about\n+            // assigned_on_exit() is not meaningful.\n+            let is_assigned = if ln == self.s.exit_ln {\n+                false\n+            } else {\n+                self.assigned_on_exit(ln, var).is_some()\n+            };\n \n-                if is_assigned {\n-                    self.ir.tcx.lint_hir_note(\n-                        lint::builtin::UNUSED_VARIABLES,\n-                        hir_id,\n-                        spans,\n-                        &format!(\"variable `{}` is assigned to, but never used\", name),\n-                        &format!(\"consider using `_{}` instead\", name),\n-                    );\n-                } else if name != \"self\" {\n-                    let mut err = self.ir.tcx.struct_span_lint_hir(\n-                        lint::builtin::UNUSED_VARIABLES,\n-                        hir_id,\n-                        spans.clone(),\n-                        &format!(\"unused variable: `{}`\", name),\n-                    );\n+            if is_assigned {\n+                self.ir.tcx.lint_hir_note(\n+                    lint::builtin::UNUSED_VARIABLES,\n+                    hir_id,\n+                    spans,\n+                    &format!(\"variable `{}` is assigned to, but never used\", name),\n+                    &format!(\"consider using `_{}` instead\", name),\n+                );\n+            } else {\n+                let mut err = self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_VARIABLES,\n+                    hir_id,\n+                    spans.clone(),\n+                    &format!(\"unused variable: `{}`\", name),\n+                );\n+\n+                if self.ir.variable_is_shorthand(var) {\n+                    if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n+                        // Handle `ref` and `ref mut`.\n+                        let spans = spans.iter()\n+                            .map(|_span| (pat.span, format!(\"{}: _\", name)))\n+                            .collect();\n \n-                    if self.ir.variable_is_shorthand(var) {\n-                        if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n-                            // Handle `ref` and `ref mut`.\n-                            let spans = spans.iter()\n-                                .map(|_span| (pat.span, format!(\"{}: _\", name)))\n-                                .collect();\n-\n-                            err.multipart_suggestion(\n-                                \"try ignoring the field\",\n-                                spans,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    } else {\n                         err.multipart_suggestion(\n-                            \"consider prefixing with an underscore\",\n-                            spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n+                            \"try ignoring the field\",\n+                            spans,\n                             Applicability::MachineApplicable,\n                         );\n                     }\n-\n-                    err.emit()\n+                } else {\n+                    err.multipart_suggestion(\n+                        \"consider prefixing with an underscore\",\n+                        spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n+\n+                err.emit()\n             }\n-            true\n-        } else {\n-            false\n         }\n     }\n \n-    fn warn_about_dead_assign(&self, sp: Span, hir_id: HirId, ln: LiveNode, var: Variable) {\n+    fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n-            self.report_dead_assign(hir_id, sp, var, false);\n+            self.report_dead_assign(hir_id, spans, var, false);\n         }\n     }\n \n-    fn report_dead_assign(&self, hir_id: HirId, sp: Span, var: Variable, is_argument: bool) {\n+    fn report_dead_assign(&self, hir_id: HirId, spans: Vec<Span>, var: Variable, is_argument: bool) {\n         if let Some(name) = self.should_warn(var) {\n             if is_argument {\n-                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, spans,\n                 &format!(\"value passed to `{}` is never read\", name))\n                 .help(\"maybe it is overwritten before being read?\")\n                 .emit();\n             } else {\n-                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, spans,\n                 &format!(\"value assigned to `{}` is never read\", name))\n                 .help(\"maybe it is overwritten before being read?\")\n                 .emit();"}]}