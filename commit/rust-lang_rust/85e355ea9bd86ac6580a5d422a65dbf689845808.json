{"sha": "85e355ea9bd86ac6580a5d422a65dbf689845808", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZTM1NWVhOWJkODZhYzY1ODBhNWQ0MjJhNjVkYmY2ODk4NDU4MDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-24T06:51:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-24T06:51:17Z"}, "message": "Auto merge of #80919 - cjgillot:defkey-span, r=oli-obk\n\nGenerate metadata by iterating on DefId instead of traversing the HIR tree 1/N\n\nSample from #80347.", "tree": {"sha": "2c849754899ea52c67b42163e413cfcaf3050426", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c849754899ea52c67b42163e413cfcaf3050426"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85e355ea9bd86ac6580a5d422a65dbf689845808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85e355ea9bd86ac6580a5d422a65dbf689845808", "html_url": "https://github.com/rust-lang/rust/commit/85e355ea9bd86ac6580a5d422a65dbf689845808", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85e355ea9bd86ac6580a5d422a65dbf689845808/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "446cbc9db080c63c8742c418bcaa44c808f7e033", "url": "https://api.github.com/repos/rust-lang/rust/commits/446cbc9db080c63c8742c418bcaa44c808f7e033", "html_url": "https://github.com/rust-lang/rust/commit/446cbc9db080c63c8742c418bcaa44c808f7e033"}, {"sha": "97ee7c7e5ab5b70453920e105530dd8a2a4391d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/97ee7c7e5ab5b70453920e105530dd8a2a4391d9", "html_url": "https://github.com/rust-lang/rust/commit/97ee7c7e5ab5b70453920e105530dd8a2a4391d9"}], "stats": {"total": 570, "additions": 305, "deletions": 265}, "files": [{"sha": "6a1b9bdbb94914f4cae548192790a71f47835411", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -419,6 +419,10 @@ impl Definitions {\n     pub fn add_parent_module_of_macro_def(&mut self, expn_id: ExpnId, module: DefId) {\n         self.parent_modules_of_macro_defs.insert(expn_id, module);\n     }\n+\n+    pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n+        self.def_id_to_hir_id.iter_enumerated().map(|(k, _)| k)\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]"}, {"sha": "e3c353907985757ff09593b609820e4cd7b6af50", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 24, "deletions": 54, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -618,43 +618,6 @@ impl MetadataBlob {\n     }\n }\n \n-impl EntryKind {\n-    fn def_kind(&self) -> DefKind {\n-        match *self {\n-            EntryKind::AnonConst(..) => DefKind::AnonConst,\n-            EntryKind::Const(..) => DefKind::Const,\n-            EntryKind::AssocConst(..) => DefKind::AssocConst,\n-            EntryKind::ImmStatic\n-            | EntryKind::MutStatic\n-            | EntryKind::ForeignImmStatic\n-            | EntryKind::ForeignMutStatic => DefKind::Static,\n-            EntryKind::Struct(_, _) => DefKind::Struct,\n-            EntryKind::Union(_, _) => DefKind::Union,\n-            EntryKind::Fn(_) | EntryKind::ForeignFn(_) => DefKind::Fn,\n-            EntryKind::AssocFn(_) => DefKind::AssocFn,\n-            EntryKind::Type => DefKind::TyAlias,\n-            EntryKind::TypeParam => DefKind::TyParam,\n-            EntryKind::ConstParam => DefKind::ConstParam,\n-            EntryKind::OpaqueTy => DefKind::OpaqueTy,\n-            EntryKind::AssocType(_) => DefKind::AssocTy,\n-            EntryKind::Mod(_) => DefKind::Mod,\n-            EntryKind::Variant(_) => DefKind::Variant,\n-            EntryKind::Trait(_) => DefKind::Trait,\n-            EntryKind::TraitAlias => DefKind::TraitAlias,\n-            EntryKind::Enum(..) => DefKind::Enum,\n-            EntryKind::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n-            EntryKind::ProcMacro(kind) => DefKind::Macro(kind),\n-            EntryKind::ForeignType => DefKind::ForeignTy,\n-            EntryKind::Impl(_) => DefKind::Impl,\n-            EntryKind::Closure => DefKind::Closure,\n-            EntryKind::ForeignMod => DefKind::ForeignMod,\n-            EntryKind::GlobalAsm => DefKind::GlobalAsm,\n-            EntryKind::Field => DefKind::Field,\n-            EntryKind::Generator(_) => DefKind::Generator,\n-        }\n-    }\n-}\n-\n impl CrateRoot<'_> {\n     crate fn is_proc_macro_crate(&self) -> bool {\n         self.proc_macro_data.is_some()\n@@ -685,21 +648,6 @@ impl CrateRoot<'_> {\n }\n \n impl<'a, 'tcx> CrateMetadataRef<'a> {\n-    fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n-        self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n-    }\n-\n-    fn kind(&self, item_id: DefIndex) -> EntryKind {\n-        self.maybe_kind(item_id).unwrap_or_else(|| {\n-            bug!(\n-                \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n-                item_id,\n-                self.root.name,\n-                self.cnum,\n-            )\n-        })\n-    }\n-\n     fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n@@ -736,8 +684,30 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.try_item_ident(item_index, sess).unwrap()\n     }\n \n-    fn def_kind(&self, index: DefIndex) -> DefKind {\n-        self.kind(index).def_kind()\n+    fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n+        self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n+    }\n+\n+    fn kind(&self, item_id: DefIndex) -> EntryKind {\n+        self.maybe_kind(item_id).unwrap_or_else(|| {\n+            bug!(\n+                \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n+                item_id,\n+                self.root.name,\n+                self.cnum,\n+            )\n+        })\n+    }\n+\n+    fn def_kind(&self, item_id: DefIndex) -> DefKind {\n+        self.root.tables.def_kind.get(self, item_id).map(|k| k.decode(self)).unwrap_or_else(|| {\n+            bug!(\n+                \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n+                item_id,\n+                self.root.name,\n+                self.cnum,\n+            )\n+        })\n     }\n \n     fn get_span(&self, index: DefIndex, sess: &Session) -> Span {"}, {"sha": "828c025d38d0bfe62a1874f28e09fd38540adc98", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -130,7 +130,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     static_mutability => { cdata.static_mutability(def_id.index) }\n     generator_kind => { cdata.generator_kind(def_id.index) }\n-    def_kind => { cdata.def_kind(def_id.index) }\n+    opt_def_kind => { Some(cdata.def_kind(def_id.index)) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n     def_ident_span => {\n         cdata.try_item_ident(def_id.index, &tcx.sess).ok().map(|ident| ident.span)"}, {"sha": "3961adacecae8cecfffd6cec7507e4bbe137aae5", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 197, "deletions": 148, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -1,13 +1,12 @@\n use crate::rmeta::table::{FixedSizeEncoding, TableBuilder};\n use crate::rmeta::*;\n \n-use rustc_ast as ast;\n use rustc_data_structures::fingerprint::{Fingerprint, FingerprintEncoder};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, Lrc};\n use rustc_hir as hir;\n-use rustc_hir::def::CtorKind;\n+use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -437,7 +436,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module, &krate.item.attrs);\n+        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module);\n \n         // Proc-macro crates only export proc-macro items, which are looked\n         // up using `proc_macro_data`\n@@ -580,6 +579,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Encode the items.\n         i = self.position();\n+        self.encode_def_ids();\n         self.encode_info_for_items();\n         let item_bytes = self.position() - i;\n \n@@ -715,7 +715,107 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n+fn should_encode_visibility(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::AssocTy\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::Static\n+        | DefKind::Ctor(..)\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Macro(..)\n+        | DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::OpaqueTy\n+        | DefKind::Impl\n+        | DefKind::Field => true,\n+        DefKind::TyParam\n+        | DefKind::ConstParam\n+        | DefKind::LifetimeParam\n+        | DefKind::AnonConst\n+        | DefKind::GlobalAsm\n+        | DefKind::Closure\n+        | DefKind::Generator\n+        | DefKind::ExternCrate => false,\n+    }\n+}\n+\n+fn should_encode_stability(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Mod\n+        | DefKind::Ctor(..)\n+        | DefKind::Variant\n+        | DefKind::Field\n+        | DefKind::Struct\n+        | DefKind::AssocTy\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::TyParam\n+        | DefKind::ConstParam\n+        | DefKind::Static\n+        | DefKind::Const\n+        | DefKind::Fn\n+        | DefKind::ForeignMod\n+        | DefKind::TyAlias\n+        | DefKind::OpaqueTy\n+        | DefKind::Enum\n+        | DefKind::Union\n+        | DefKind::Impl\n+        | DefKind::Trait\n+        | DefKind::TraitAlias\n+        | DefKind::Macro(..)\n+        | DefKind::ForeignTy => true,\n+        DefKind::Use\n+        | DefKind::LifetimeParam\n+        | DefKind::AnonConst\n+        | DefKind::GlobalAsm\n+        | DefKind::Closure\n+        | DefKind::Generator\n+        | DefKind::ExternCrate => false,\n+    }\n+}\n+\n impl EncodeContext<'a, 'tcx> {\n+    fn encode_def_ids(&mut self) {\n+        if self.is_proc_macro {\n+            return;\n+        }\n+        let tcx = self.tcx;\n+        let hir = tcx.hir();\n+        for local_id in hir.iter_local_def_id() {\n+            let def_id = local_id.to_def_id();\n+            let def_kind = tcx.opt_def_kind(local_id);\n+            let def_kind = if let Some(def_kind) = def_kind { def_kind } else { continue };\n+            record!(self.tables.def_kind[def_id] <- match def_kind {\n+                // Replace Ctor by the enclosing object to avoid leaking details in children crates.\n+                DefKind::Ctor(CtorOf::Struct, _) => DefKind::Struct,\n+                DefKind::Ctor(CtorOf::Variant, _) => DefKind::Variant,\n+                def_kind => def_kind,\n+            });\n+            record!(self.tables.span[def_id] <- tcx.def_span(def_id));\n+            record!(self.tables.attributes[def_id] <- tcx.get_attrs(def_id));\n+            record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n+            if should_encode_visibility(def_kind) {\n+                record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n+            }\n+            if should_encode_stability(def_kind) {\n+                self.encode_stability(def_id);\n+                self.encode_const_stability(def_id);\n+                self.encode_deprecation(def_id);\n+            }\n+        }\n+    }\n+\n     fn encode_variances_of(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n         record!(self.tables.variances[def_id] <- &self.tcx.variances_of(def_id)[..]);\n@@ -740,17 +840,11 @@ impl EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.tables.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n-        record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n         record!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n         self.encode_ident_span(def_id, variant.ident);\n-        self.encode_stability(def_id);\n-        self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n@@ -780,10 +874,6 @@ impl EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n-        self.encode_stability(def_id);\n-        self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -799,7 +889,7 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_mir_for_ctfe(def_id.expect_local());\n     }\n \n-    fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>, attrs: &[ast::Attribute]) {\n+    fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>) {\n         let tcx = self.tcx;\n         let local_def_id = tcx.hir().local_def_id(id);\n         let def_id = local_def_id.to_def_id();\n@@ -832,18 +922,13 @@ impl EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.tables.attributes[def_id] <- attrs);\n         if self.is_proc_macro {\n             record!(self.tables.children[def_id] <- &[]);\n         } else {\n             record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n                 tcx.hir().local_def_id(item_id.id).local_def_index\n             }));\n         }\n-        self.encode_stability(def_id);\n-        self.encode_deprecation(def_id);\n     }\n \n     fn encode_field(\n@@ -852,24 +937,14 @@ impl EncodeContext<'a, 'tcx> {\n         variant_index: VariantIdx,\n         field_index: usize,\n     ) {\n-        let tcx = self.tcx;\n         let variant = &adt_def.variants[variant_index];\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n         debug!(\"EncodeContext::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir().local_def_id_to_hir_id(variant.def_id.expect_local());\n-        let variant_data = tcx.hir().expect_variant_data(variant_id);\n-\n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.tables.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n-        record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n         self.encode_ident_span(def_id, field.ident);\n-        self.encode_stability(def_id);\n-        self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n@@ -889,11 +964,6 @@ impl EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n-        self.encode_stability(def_id);\n-        self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -955,29 +1025,25 @@ impl EncodeContext<'a, 'tcx> {\n             hir::Defaultness::Final => span_bug!(ast_item.span, \"traits cannot have final items\"),\n         };\n \n-        record!(self.tables.kind[def_id] <- match trait_item.kind {\n+        match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let rendered = rustc_hir_pretty::to_string(\n                     &(&self.tcx.hir() as &dyn intravisit::Map<'_>),\n-                    |s| s.print_trait_item(ast_item)\n+                    |s| s.print_trait_item(ast_item),\n                 );\n                 let rendered_const = self.lazy(RenderedConst(rendered));\n \n-                EntryKind::AssocConst(\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocConst(\n                     container,\n                     Default::default(),\n                     rendered_const,\n-                )\n+                ));\n             }\n             ty::AssocKind::Fn => {\n                 let fn_data = if let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind {\n                     let param_names = match *m {\n-                        hir::TraitFn::Required(ref names) => {\n-                            self.encode_fn_param_names(names)\n-                        }\n-                        hir::TraitFn::Provided(body) => {\n-                            self.encode_fn_param_names_for_body(body)\n-                        }\n+                        hir::TraitFn::Required(ref names) => self.encode_fn_param_names(names),\n+                        hir::TraitFn::Provided(body) => self.encode_fn_param_names_for_body(body),\n                     };\n                     FnData {\n                         asyncness: m_sig.header.asyncness,\n@@ -987,24 +1053,18 @@ impl EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::AssocFn(self.lazy(AssocFnData {\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocFn(self.lazy(AssocFnData {\n                     fn_data,\n                     container,\n                     has_self: trait_item.fn_has_self_parameter,\n-                }))\n+                })));\n             }\n             ty::AssocKind::Type => {\n                 self.encode_explicit_item_bounds(def_id);\n-                EntryKind::AssocType(container)\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocType(container));\n             }\n-        });\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- ast_item.span);\n-        record!(self.tables.attributes[def_id] <- ast_item.attrs);\n+        }\n         self.encode_ident_span(def_id, ast_item.ident);\n-        self.encode_stability(def_id);\n-        self.encode_const_stability(def_id);\n-        self.encode_deprecation(def_id);\n         match trait_item.kind {\n             ty::AssocKind::Const | ty::AssocKind::Fn => {\n                 self.encode_item_type(def_id);\n@@ -1068,15 +1128,16 @@ impl EncodeContext<'a, 'tcx> {\n             }\n         };\n \n-        record!(self.tables.kind[def_id] <- match impl_item.kind {\n+        match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n                     let qualifs = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n \n-                    EntryKind::AssocConst(\n+                    record!(self.tables.kind[def_id] <- EntryKind::AssocConst(\n                         container,\n                         qualifs,\n                         self.encode_rendered_const_for_body(body_id))\n+                    );\n                 } else {\n                     bug!()\n                 }\n@@ -1091,21 +1152,17 @@ impl EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::AssocFn(self.lazy(AssocFnData {\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocFn(self.lazy(AssocFnData {\n                     fn_data,\n                     container,\n                     has_self: impl_item.fn_has_self_parameter,\n-                }))\n+                })));\n             }\n-            ty::AssocKind::Type => EntryKind::AssocType(container)\n-        });\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- ast_item.span);\n-        record!(self.tables.attributes[def_id] <- ast_item.attrs);\n+            ty::AssocKind::Type => {\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocType(container));\n+            }\n+        }\n         self.encode_ident_span(def_id, impl_item.ident);\n-        self.encode_stability(def_id);\n-        self.encode_const_stability(def_id);\n-        self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -1235,15 +1292,12 @@ impl EncodeContext<'a, 'tcx> {\n \n         self.encode_ident_span(def_id, item.ident);\n \n-        record!(self.tables.kind[def_id] <- match item.kind {\n+        let entry_kind = match item.kind {\n             hir::ItemKind::Static(_, hir::Mutability::Mut, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n                 let qualifs = self.tcx.at(item.span).mir_const_qualif(def_id);\n-                EntryKind::Const(\n-                    qualifs,\n-                    self.encode_rendered_const_for_body(body_id)\n-                )\n+                EntryKind::Const(qualifs, self.encode_rendered_const_for_body(body_id))\n             }\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 let data = FnData {\n@@ -1255,7 +1309,7 @@ impl EncodeContext<'a, 'tcx> {\n                 EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.hir_id, m, &item.attrs);\n+                return self.encode_info_for_mod(item.hir_id, m);\n             }\n             hir::ItemKind::ForeignMod { .. } => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1272,61 +1326,61 @@ impl EncodeContext<'a, 'tcx> {\n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n-                let ctor = struct_def.ctor_hir_id().map(|ctor_hir_id| {\n-                    self.tcx.hir().local_def_id(ctor_hir_id).local_def_index\n-                });\n-\n-                EntryKind::Struct(self.lazy(VariantData {\n-                    ctor_kind: variant.ctor_kind,\n-                    discr: variant.discr,\n-                    ctor,\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                }), adt_def.repr)\n+                let ctor = struct_def\n+                    .ctor_hir_id()\n+                    .map(|ctor_hir_id| self.tcx.hir().local_def_id(ctor_hir_id).local_def_index);\n+\n+                EntryKind::Struct(\n+                    self.lazy(VariantData {\n+                        ctor_kind: variant.ctor_kind,\n+                        discr: variant.discr,\n+                        ctor,\n+                        is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n+                    }),\n+                    adt_def.repr,\n+                )\n             }\n             hir::ItemKind::Union(..) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let variant = adt_def.non_enum_variant();\n \n-                EntryKind::Union(self.lazy(VariantData {\n-                    ctor_kind: variant.ctor_kind,\n-                    discr: variant.discr,\n-                    ctor: None,\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                }), adt_def.repr)\n+                EntryKind::Union(\n+                    self.lazy(VariantData {\n+                        ctor_kind: variant.ctor_kind,\n+                        discr: variant.discr,\n+                        ctor: None,\n+                        is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n+                    }),\n+                    adt_def.repr,\n+                )\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, .. }) => {\n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 let polarity = self.tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(self.tcx, def_id).ok()\n-                        .and_then(|mut an| an.nth(1).and_then(|node| {\n-                            match node {\n-                                specialization_graph::Node::Impl(parent) => Some(parent),\n-                                _ => None,\n-                            }\n-                        }))\n+                    trait_def.ancestors(self.tcx, def_id).ok().and_then(|mut an| {\n+                        an.nth(1).and_then(|node| match node {\n+                            specialization_graph::Node::Impl(parent) => Some(parent),\n+                            _ => None,\n+                        })\n+                    })\n                 } else {\n                     None\n                 };\n \n                 // if this is an impl of `CoerceUnsized`, create its\n                 // \"unsized info\", else just store None\n-                let coerce_unsized_info =\n-                    trait_ref.and_then(|t| {\n-                        if Some(t.def_id) == self.tcx.lang_items().coerce_unsized_trait() {\n-                            Some(self.tcx.at(item.span).coerce_unsized_info(def_id))\n-                        } else {\n-                            None\n-                        }\n-                    });\n+                let coerce_unsized_info = trait_ref.and_then(|t| {\n+                    if Some(t.def_id) == self.tcx.lang_items().coerce_unsized_trait() {\n+                        Some(self.tcx.at(item.span).coerce_unsized_info(def_id))\n+                    } else {\n+                        None\n+                    }\n+                });\n \n-                let data = ImplData {\n-                    polarity,\n-                    defaultness,\n-                    parent_impl: parent,\n-                    coerce_unsized_info,\n-                };\n+                let data =\n+                    ImplData { polarity, defaultness, parent_impl: parent, coerce_unsized_info };\n \n                 EntryKind::Impl(self.lazy(data))\n             }\n@@ -1343,13 +1397,11 @@ impl EncodeContext<'a, 'tcx> {\n                 EntryKind::Trait(self.lazy(data))\n             }\n             hir::ItemKind::TraitAlias(..) => EntryKind::TraitAlias,\n-            hir::ItemKind::ExternCrate(_) |\n-            hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n-        });\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.tables.attributes[def_id] <- item.attrs);\n-        record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n+            hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {\n+                bug!(\"cannot encode info for item {:?}\", item)\n+            }\n+        };\n+        record!(self.tables.kind[def_id] <- entry_kind);\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n             hir::ItemKind::ForeignMod { items, .. } => record!(self.tables.children[def_id] <-\n@@ -1383,9 +1435,6 @@ impl EncodeContext<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        self.encode_stability(def_id);\n-        self.encode_const_stability(def_id);\n-        self.encode_deprecation(def_id);\n         match item.kind {\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n@@ -1466,17 +1515,11 @@ impl EncodeContext<'a, 'tcx> {\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id).to_def_id();\n         record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- macro_def.span);\n-        record!(self.tables.attributes[def_id] <- macro_def.attrs);\n         self.encode_ident_span(def_id, macro_def.ident);\n-        self.encode_stability(def_id);\n-        self.encode_deprecation(def_id);\n     }\n \n     fn encode_info_for_generic_param(&mut self, def_id: DefId, kind: EntryKind, encode_type: bool) {\n         record!(self.tables.kind[def_id] <- kind);\n-        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         if encode_type {\n             self.encode_item_type(def_id);\n         }\n@@ -1490,18 +1533,18 @@ impl EncodeContext<'a, 'tcx> {\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let ty = self.tcx.typeck(def_id).node_type(hir_id);\n \n-        record!(self.tables.kind[def_id.to_def_id()] <- match ty.kind() {\n+        match ty.kind() {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n-                EntryKind::Generator(data)\n+                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Generator(data));\n             }\n \n-            ty::Closure(..) => EntryKind::Closure,\n+            ty::Closure(..) => {\n+                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Closure);\n+            }\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n-        });\n-        record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n-        record!(self.tables.attributes[def_id.to_def_id()] <- &self.tcx.get_attrs(def_id.to_def_id())[..]);\n+        }\n         self.encode_item_type(def_id.to_def_id());\n         if let ty::Closure(def_id, substs) = *ty.kind() {\n             record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n@@ -1525,7 +1568,6 @@ impl EncodeContext<'a, 'tcx> {\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n         record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst(qualifs, const_data));\n-        record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id.to_def_id());\n         self.encode_generics(def_id.to_def_id());\n         self.encode_explicit_predicates(def_id.to_def_id());\n@@ -1575,6 +1617,15 @@ impl EncodeContext<'a, 'tcx> {\n             let stability = tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).copied();\n             let macros = self.lazy(hir.krate().proc_macros.iter().map(|p| p.owner.local_def_index));\n \n+            record!(self.tables.def_kind[LOCAL_CRATE.as_def_id()] <- DefKind::Mod);\n+            record!(self.tables.span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n+            record!(self.tables.attributes[LOCAL_CRATE.as_def_id()] <- tcx.get_attrs(LOCAL_CRATE.as_def_id()));\n+            record!(self.tables.visibility[LOCAL_CRATE.as_def_id()] <- tcx.visibility(LOCAL_CRATE.as_def_id()));\n+            if let Some(stability) = stability {\n+                record!(self.tables.stability[LOCAL_CRATE.as_def_id()] <- stability);\n+            }\n+            self.encode_deprecation(LOCAL_CRATE.as_def_id());\n+\n             // Normally, this information is encoded when we walk the items\n             // defined in this crate. However, we skip doing that for proc-macro crates,\n             // so we manually encode just the information that we need\n@@ -1606,6 +1657,7 @@ impl EncodeContext<'a, 'tcx> {\n                 def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n \n                 let def_id = DefId::local(id);\n+                record!(self.tables.def_kind[def_id] <- DefKind::Macro(macro_kind));\n                 record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n                 record!(self.tables.attributes[def_id] <- attrs);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n@@ -1773,7 +1825,7 @@ impl EncodeContext<'a, 'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n-        record!(self.tables.kind[def_id] <- match nitem.kind {\n+        match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n@@ -1784,19 +1836,19 @@ impl EncodeContext<'a, 'tcx> {\n                     },\n                     param_names: self.encode_fn_param_names(names),\n                 };\n-                EntryKind::ForeignFn(self.lazy(data))\n+                record!(self.tables.kind[def_id] <- EntryKind::ForeignFn(self.lazy(data)));\n             }\n-            hir::ForeignItemKind::Static(_, hir::Mutability::Mut) => EntryKind::ForeignMutStatic,\n-            hir::ForeignItemKind::Static(_, hir::Mutability::Not) => EntryKind::ForeignImmStatic,\n-            hir::ForeignItemKind::Type => EntryKind::ForeignType,\n-        });\n-        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n-        record!(self.tables.span[def_id] <- nitem.span);\n-        record!(self.tables.attributes[def_id] <- nitem.attrs);\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Mut) => {\n+                record!(self.tables.kind[def_id] <- EntryKind::ForeignMutStatic);\n+            }\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Not) => {\n+                record!(self.tables.kind[def_id] <- EntryKind::ForeignImmStatic);\n+            }\n+            hir::ForeignItemKind::Type => {\n+                record!(self.tables.kind[def_id] <- EntryKind::ForeignType);\n+            }\n+        }\n         self.encode_ident_span(def_id, nitem.ident);\n-        self.encode_stability(def_id);\n-        self.encode_const_stability(def_id);\n-        self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         self.encode_inherent_implementations(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n@@ -1862,15 +1914,12 @@ impl EncodeContext<'a, 'tcx> {\n             let def_id = self.tcx.hir().local_def_id(param.hir_id);\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => continue,\n-                GenericParamKind::Type { ref default, .. } => {\n+                GenericParamKind::Type { default, .. } => {\n                     self.encode_info_for_generic_param(\n                         def_id.to_def_id(),\n                         EntryKind::TypeParam,\n                         default.is_some(),\n                     );\n-                    if default.is_some() {\n-                        self.encode_stability(def_id.to_def_id());\n-                    }\n                 }\n                 GenericParamKind::Const { .. } => {\n                     self.encode_info_for_generic_param("}, {"sha": "b44c3bfcac647ca0c4616311ad94bab471c0a0c5", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -6,7 +6,7 @@ use rustc_attr as attr;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_hir as hir;\n-use rustc_hir::def::CtorKind;\n+use rustc_hir::def::{CtorKind, DefKind};\n use rustc_hir::def_id::{DefId, DefIndex, DefPathHash};\n use rustc_hir::definitions::DefKey;\n use rustc_hir::lang_items;\n@@ -279,6 +279,7 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n+    def_kind: Table<DefIndex, Lazy<DefKind>>,\n     kind: Table<DefIndex, Lazy<EntryKind>>,\n     visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n     span: Table<DefIndex, Lazy<Span>>,"}, {"sha": "9b01a64de841503660ae47c4d00ada9bd0c1c0e1", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 54, "deletions": 46, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -1,7 +1,6 @@\n use self::collector::NodeCollector;\n \n use crate::hir::{Owner, OwnerNodes};\n-use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n use rustc_data_structures::svh::Svh;\n@@ -183,14 +182,18 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions.opt_local_def_id_to_hir_id(def_id)\n     }\n \n-    pub fn def_kind(&self, local_def_id: LocalDefId) -> DefKind {\n+    pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n+        self.tcx.definitions.iter_local_def_id()\n+    }\n+\n+    pub fn opt_def_kind(&self, local_def_id: LocalDefId) -> Option<DefKind> {\n         // FIXME(eddyb) support `find` on the crate root.\n         if local_def_id.to_def_id().index == CRATE_DEF_INDEX {\n-            return DefKind::Mod;\n+            return Some(DefKind::Mod);\n         }\n \n         let hir_id = self.local_def_id_to_hir_id(local_def_id);\n-        match self.get(hir_id) {\n+        let def_kind = match self.find(hir_id)? {\n             Node::Item(item) => match item.kind {\n                 ItemKind::Static(..) => DefKind::Static,\n                 ItemKind::Const(..) => DefKind::Const,\n@@ -249,6 +252,7 @@ impl<'hir> Map<'hir> {\n                 GenericParamKind::Type { .. } => DefKind::TyParam,\n                 GenericParamKind::Const { .. } => DefKind::ConstParam,\n             },\n+            Node::Crate(_) => DefKind::Mod,\n             Node::Stmt(_)\n             | Node::PathSegment(_)\n             | Node::Ty(_)\n@@ -260,9 +264,14 @@ impl<'hir> Map<'hir> {\n             | Node::Arm(_)\n             | Node::Lifetime(_)\n             | Node::Visibility(_)\n-            | Node::Block(_)\n-            | Node::Crate(_) => bug!(\"def_kind: unsupported node: {}\", self.node_to_string(hir_id)),\n-        }\n+            | Node::Block(_) => return None,\n+        };\n+        Some(def_kind)\n+    }\n+\n+    pub fn def_kind(&self, local_def_id: LocalDefId) -> DefKind {\n+        self.opt_def_kind(local_def_id)\n+            .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", local_def_id))\n     }\n \n     fn find_entry(&self, id: HirId) -> Option<Entry<'hir>> {\n@@ -514,9 +523,7 @@ impl<'hir> Map<'hir> {\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     pub fn find(&self, hir_id: HirId) -> Option<Node<'hir>> {\n-        self.find_entry(hir_id).and_then(|entry| {\n-            if let Node::Crate(..) = entry.node { None } else { Some(entry.node) }\n-        })\n+        self.find_entry(hir_id).map(|entry| entry.node)\n     }\n \n     /// Similar to `get_parent`; returns the parent HIR Id, or just `hir_id` if there\n@@ -848,50 +855,55 @@ impl<'hir> Map<'hir> {\n     /// Gets the span of the definition of the specified HIR node.\n     /// This is used by `tcx.get_span`\n     pub fn span(&self, hir_id: HirId) -> Span {\n-        match self.find_entry(hir_id).map(|entry| entry.node) {\n-            Some(Node::Param(param)) => param.span,\n-            Some(Node::Item(item)) => match &item.kind {\n+        self.opt_span(hir_id)\n+            .unwrap_or_else(|| bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id))\n+    }\n+\n+    pub fn opt_span(&self, hir_id: HirId) -> Option<Span> {\n+        let span = match self.find_entry(hir_id)?.node {\n+            Node::Param(param) => param.span,\n+            Node::Item(item) => match &item.kind {\n                 ItemKind::Fn(sig, _, _) => sig.span,\n                 _ => item.span,\n             },\n-            Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n-            Some(Node::TraitItem(trait_item)) => match &trait_item.kind {\n+            Node::ForeignItem(foreign_item) => foreign_item.span,\n+            Node::TraitItem(trait_item) => match &trait_item.kind {\n                 TraitItemKind::Fn(sig, _) => sig.span,\n                 _ => trait_item.span,\n             },\n-            Some(Node::ImplItem(impl_item)) => match &impl_item.kind {\n+            Node::ImplItem(impl_item) => match &impl_item.kind {\n                 ImplItemKind::Fn(sig, _) => sig.span,\n                 _ => impl_item.span,\n             },\n-            Some(Node::Variant(variant)) => variant.span,\n-            Some(Node::Field(field)) => field.span,\n-            Some(Node::AnonConst(constant)) => self.body(constant.body).value.span,\n-            Some(Node::Expr(expr)) => expr.span,\n-            Some(Node::Stmt(stmt)) => stmt.span,\n-            Some(Node::PathSegment(seg)) => seg.ident.span,\n-            Some(Node::Ty(ty)) => ty.span,\n-            Some(Node::TraitRef(tr)) => tr.path.span,\n-            Some(Node::Binding(pat)) => pat.span,\n-            Some(Node::Pat(pat)) => pat.span,\n-            Some(Node::Arm(arm)) => arm.span,\n-            Some(Node::Block(block)) => block.span,\n-            Some(Node::Ctor(..)) => match self.find(self.get_parent_node(hir_id)) {\n-                Some(Node::Item(item)) => item.span,\n-                Some(Node::Variant(variant)) => variant.span,\n+            Node::Variant(variant) => variant.span,\n+            Node::Field(field) => field.span,\n+            Node::AnonConst(constant) => self.body(constant.body).value.span,\n+            Node::Expr(expr) => expr.span,\n+            Node::Stmt(stmt) => stmt.span,\n+            Node::PathSegment(seg) => seg.ident.span,\n+            Node::Ty(ty) => ty.span,\n+            Node::TraitRef(tr) => tr.path.span,\n+            Node::Binding(pat) => pat.span,\n+            Node::Pat(pat) => pat.span,\n+            Node::Arm(arm) => arm.span,\n+            Node::Block(block) => block.span,\n+            Node::Ctor(..) => match self.find(self.get_parent_node(hir_id))? {\n+                Node::Item(item) => item.span,\n+                Node::Variant(variant) => variant.span,\n                 _ => unreachable!(),\n             },\n-            Some(Node::Lifetime(lifetime)) => lifetime.span,\n-            Some(Node::GenericParam(param)) => param.span,\n-            Some(Node::Visibility(&Spanned {\n+            Node::Lifetime(lifetime) => lifetime.span,\n+            Node::GenericParam(param) => param.span,\n+            Node::Visibility(&Spanned {\n                 node: VisibilityKind::Restricted { ref path, .. },\n                 ..\n-            })) => path.span,\n-            Some(Node::Visibility(v)) => bug!(\"unexpected Visibility {:?}\", v),\n-            Some(Node::Local(local)) => local.span,\n-            Some(Node::MacroDef(macro_def)) => macro_def.span,\n-            Some(Node::Crate(item)) => item.span,\n-            None => bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id),\n-        }\n+            }) => path.span,\n+            Node::Visibility(v) => bug!(\"unexpected Visibility {:?}\", v),\n+            Node::Local(local) => local.span,\n+            Node::MacroDef(macro_def) => macro_def.span,\n+            Node::Crate(item) => item.span,\n+        };\n+        Some(span)\n     }\n \n     /// Like `hir.span()`, but includes the body of function items\n@@ -907,7 +919,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n-        id.as_local().map(|id| self.span(self.local_def_id_to_hir_id(id)))\n+        id.as_local().and_then(|id| self.opt_span(self.local_def_id_to_hir_id(id)))\n     }\n \n     pub fn res_span(&self, res: Res) -> Option<Span> {\n@@ -1101,7 +1113,3 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n         None => format!(\"unknown node{}\", id_str),\n     }\n }\n-\n-pub fn provide(providers: &mut Providers) {\n-    providers.def_kind = |tcx, def_id| tcx.hir().def_kind(def_id.expect_local());\n-}"}, {"sha": "e96f3f2a29475bd8e54ba0503e8941f0163d9b76", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n+use rustc_span::DUMMY_SP;\n \n pub struct Owner<'tcx> {\n     parent: HirId,\n@@ -77,6 +78,7 @@ pub fn provide(providers: &mut Providers) {\n     };\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n+    providers.def_span = |tcx, def_id| tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP);\n     providers.fn_arg_names = |tcx, id| {\n         let hir = tcx.hir();\n         let hir_id = hir.local_def_id_to_hir_id(id.expect_local());\n@@ -92,5 +94,5 @@ pub fn provide(providers: &mut Providers) {\n             span_bug!(hir.span(hir_id), \"fn_arg_names: unexpected item {:?}\", id);\n         }\n     };\n-    map::provide(providers);\n+    providers.opt_def_kind = |tcx, def_id| tcx.hir().opt_def_kind(def_id.expect_local());\n }"}, {"sha": "e23d04f8211f32299bbfae259a5d88376ec1945a", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -878,7 +878,7 @@ rustc_queries! {\n             cache_on_disk_if { true }\n         }\n \n-        query def_kind(def_id: DefId) -> DefKind {\n+        query opt_def_kind(def_id: DefId) -> Option<DefKind> {\n             desc { |tcx| \"looking up definition kind of `{}`\", tcx.def_path_str(def_id) }\n         }\n "}, {"sha": "f580cb14dc988cf7dd4989ef97a094dbc3076aa1", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -130,3 +130,19 @@ mod sealed {\n }\n \n use sealed::IntoQueryParam;\n+\n+impl TyCtxt<'tcx> {\n+    pub fn def_kind(self, def_id: impl IntoQueryParam<DefId>) -> DefKind {\n+        let def_id = def_id.into_query_param();\n+        self.opt_def_kind(def_id)\n+            .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", def_id))\n+    }\n+}\n+\n+impl TyCtxtAt<'tcx> {\n+    pub fn def_kind(self, def_id: impl IntoQueryParam<DefId>) -> DefKind {\n+        let def_id = def_id.into_query_param();\n+        self.opt_def_kind(def_id)\n+            .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", def_id))\n+    }\n+}"}, {"sha": "eb24c51c54c3574e72a8da2ec7a3f4fc3904bb4c", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -307,6 +307,7 @@ impl<'tcx> ReachableContext<'tcx> {\n             | Node::Ctor(..)\n             | Node::Field(_)\n             | Node::Ty(_)\n+            | Node::Crate(_)\n             | Node::MacroDef(_) => {}\n             _ => {\n                 bug!("}, {"sha": "77aa4413409126590c71c29ef6cb7f9962453e2e", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -218,10 +218,6 @@ fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssociatedItems<'_> {\n     ty::AssociatedItems::new(items)\n }\n \n-fn def_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {\n-    tcx.hir().span_if_local(def_id).unwrap()\n-}\n-\n fn def_ident_span(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Span> {\n     tcx.hir().get_if_local(def_id).and_then(|node| node.ident()).map(|ident| ident.span)\n }\n@@ -495,7 +491,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         associated_item_def_ids,\n         associated_items,\n         adt_sized_constraint,\n-        def_span,\n         def_ident_span,\n         param_env,\n         param_env_reveal_all_normalized,"}, {"sha": "540e076c7e4c62b1f1eaadbadf0154c193f22f16", "filename": "src/test/ui/lint/lint-const-item-mutation.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85e355ea9bd86ac6580a5d422a65dbf689845808/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/85e355ea9bd86ac6580a5d422a65dbf689845808/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr?ref=85e355ea9bd86ac6580a5d422a65dbf689845808", "patch": "@@ -109,14 +109,8 @@ LL |     VEC.push(0);\n note: mutable reference created due to call to this method\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n-LL | /     pub fn push(&mut self, value: T) {\n-LL | |         // This will panic or abort if we would allocate > isize::MAX bytes\n-LL | |         // or if the length increment would overflow for zero-sized types.\n-LL | |         if self.len == self.buf.capacity() {\n-...  |\n-LL | |         }\n-LL | |     }\n-   | |_____^\n+LL |     pub fn push(&mut self, value: T) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: `const` item defined here\n   --> $DIR/lint-const-item-mutation.rs:31:1\n    |"}]}