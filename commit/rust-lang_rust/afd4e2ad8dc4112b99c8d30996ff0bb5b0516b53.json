{"sha": "afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZDRlMmFkOGRjNDExMmI5OWM4ZDMwOTk2ZmYwYmI1YjA1MTZiNTM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-13T19:30:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-25T03:59:53Z"}, "message": "rustuv: Get all tests passing again after refactor\n\nAll tests except for the homing tests are now working again with the\nlibrustuv/libgreen refactoring. The homing-related tests are currently commented\nout and now placed in the rustuv::homing module.\n\nI plan on refactoring scheduler pool spawning in order to enable more homing\ntests in a future commit.", "tree": {"sha": "9e4bd858bbb5e3c0b3526c0976d0ca032217c16a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e4bd858bbb5e3c0b3526c0976d0ca032217c16a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "html_url": "https://github.com/rust-lang/rust/commit/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5d9b2ca6d9a360112f06b3044897c22736c52b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5d9b2ca6d9a360112f06b3044897c22736c52b8", "html_url": "https://github.com/rust-lang/rust/commit/f5d9b2ca6d9a360112f06b3044897c22736c52b8"}], "stats": {"total": 599, "additions": 286, "deletions": 313}, "files": [{"sha": "f6fad524b5c68f5d2257d292349191af1df7b50b", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -186,10 +186,12 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n mod test {\n     use std::io::net::ip::{SocketAddr, Ipv4Addr};\n     use super::super::local_loop;\n+    use super::GetAddrInfoRequest;\n \n     #[test]\n     fn getaddrinfo_test() {\n-        match GetAddrInfoRequest::run(local_loop(), Some(\"localhost\"), None, None) {\n+        let loop_ = &mut local_loop().loop_;\n+        match GetAddrInfoRequest::run(loop_, Some(\"localhost\"), None, None) {\n             Ok(infos) => {\n                 let mut found_local = false;\n                 let local_addr = &SocketAddr {\n@@ -207,9 +209,10 @@ mod test {\n \n     #[test]\n     fn issue_10663() {\n+        let loop_ = &mut local_loop().loop_;\n         // Something should happen here, but this certainly shouldn't cause\n         // everything to die. The actual outcome we don't care too much about.\n-        GetAddrInfoRequest::run(local_loop(), Some(\"irc.n0v4.com\"), None,\n+        GetAddrInfoRequest::run(loop_, Some(\"irc.n0v4.com\"), None,\n                                 None);\n     }\n }"}, {"sha": "0c353785982e6e7bcc5d9d0cddf43b03834a9c65", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -127,15 +127,15 @@ impl Drop for AsyncWatcher {\n mod test_remote {\n     use std::rt::rtio::Callback;\n     use std::rt::thread::Thread;\n-    use std::rt::tube::Tube;\n \n+    use super::AsyncWatcher;\n     use super::super::local_loop;\n \n     // Make sure that we can fire watchers in remote threads and that they\n     // actually trigger what they say they will.\n     #[test]\n     fn smoke_test() {\n-        struct MyCallback(Option<Tube<int>>);\n+        struct MyCallback(Option<Chan<int>>);\n         impl Callback for MyCallback {\n             fn call(&mut self) {\n                 // this can get called more than once, but we only want to send\n@@ -146,16 +146,17 @@ mod test_remote {\n             }\n         }\n \n-        let mut tube = Tube::new();\n-        let cb = ~MyCallback(Some(tube.clone()));\n-        let watcher = AsyncWatcher::new(local_loop(), cb as ~Callback);\n+        let (port, chan) = Chan::new();\n+        let cb = ~MyCallback(Some(chan));\n+        let watcher = AsyncWatcher::new(&mut local_loop().loop_,\n+                                        cb as ~Callback);\n \n         let thread = do Thread::start {\n             let mut watcher = watcher;\n             watcher.fire();\n         };\n \n-        assert_eq!(tube.recv(), 1);\n+        assert_eq!(port.recv(), 1);\n         thread.join();\n     }\n }"}, {"sha": "059bf072a1a403636880aa9b64b7db667582d5fc", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -448,7 +448,11 @@ mod test {\n     use std::io;\n     use std::str;\n     use std::vec;\n-    use l = super::super::local_loop;\n+    use super::FsRequest;\n+    use super::super::Loop;\n+    use super::super::local_loop;\n+\n+    fn l() -> &mut Loop { &mut local_loop().loop_ }\n \n     #[test]\n     fn file_test_full_simple_sync() {\n@@ -459,7 +463,7 @@ mod test {\n \n         {\n             // open/create\n-            let result = FsRequest::open(l(), &path_str.to_c_str(),\n+            let result = FsRequest::open(local_loop(), &path_str.to_c_str(),\n                                          create_flags as int, mode as int);\n             assert!(result.is_ok());\n             let result = result.unwrap();\n@@ -472,7 +476,7 @@ mod test {\n \n         {\n             // re-open\n-            let result = FsRequest::open(l(), &path_str.to_c_str(),\n+            let result = FsRequest::open(local_loop(), &path_str.to_c_str(),\n                                          read_flags as int, 0);\n             assert!(result.is_ok());\n             let result = result.unwrap();\n@@ -499,7 +503,7 @@ mod test {\n         let create_flags = (O_RDWR | O_CREAT) as int;\n         let mode = (S_IWUSR | S_IRUSR) as int;\n \n-        let result = FsRequest::open(l(), path, create_flags, mode);\n+        let result = FsRequest::open(local_loop(), path, create_flags, mode);\n         assert!(result.is_ok());\n         let file = result.unwrap();\n "}, {"sha": "d09dfae0b29a4c0774c433e27c0dfcd27ebc831e", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -142,3 +142,124 @@ impl Drop for HomingMissile {\n         self.check(\"task moved away from the home scheduler\");\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    // On one thread, create a udp socket. Then send that socket to another\n+    // thread and destroy the socket on the remote thread. This should make sure\n+    // that homing kicks in for the socket to go back home to the original\n+    // thread, close itself, and then come back to the last thread.\n+    //#[test]\n+    //fn test_homing_closes_correctly() {\n+    //    let (port, chan) = Chan::new();\n+\n+    //    do task::spawn_sched(task::SingleThreaded) {\n+    //        let listener = UdpWatcher::bind(local_loop(), next_test_ip4()).unwrap();\n+    //        chan.send(listener);\n+    //    }\n+\n+    //    do task::spawn_sched(task::SingleThreaded) {\n+    //        port.recv();\n+    //    }\n+    //}\n+\n+    // This is a bit of a crufty old test, but it has its uses.\n+    //#[test]\n+    //fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n+    //    use std::cast;\n+    //    use std::rt::local::Local;\n+    //    use std::rt::rtio::{EventLoop, IoFactory};\n+    //    use std::rt::sched::Scheduler;\n+    //    use std::rt::sched::{Shutdown, TaskFromFriend};\n+    //    use std::rt::sleeper_list::SleeperList;\n+    //    use std::rt::task::Task;\n+    //    use std::rt::task::UnwindResult;\n+    //    use std::rt::thread::Thread;\n+    //    use std::rt::deque::BufferPool;\n+    //    use std::unstable::run_in_bare_thread;\n+    //    use uvio::UvEventLoop;\n+\n+    //    do run_in_bare_thread {\n+    //        let sleepers = SleeperList::new();\n+    //        let mut pool = BufferPool::new();\n+    //        let (worker1, stealer1) = pool.deque();\n+    //        let (worker2, stealer2) = pool.deque();\n+    //        let queues = ~[stealer1, stealer2];\n+\n+    //        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n+    //        let mut sched1 = ~Scheduler::new(loop1, worker1, queues.clone(),\n+    //                                         sleepers.clone());\n+    //        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n+    //        let mut sched2 = ~Scheduler::new(loop2, worker2, queues.clone(),\n+    //                                         sleepers.clone());\n+\n+    //        let handle1 = sched1.make_handle();\n+    //        let handle2 = sched2.make_handle();\n+    //        let tasksFriendHandle = sched2.make_handle();\n+\n+    //        let on_exit: proc(UnwindResult) = proc(exit_status) {\n+    //            let mut handle1 = handle1;\n+    //            let mut handle2 = handle2;\n+    //            handle1.send(Shutdown);\n+    //            handle2.send(Shutdown);\n+    //            assert!(exit_status.is_success());\n+    //        };\n+\n+    //        unsafe fn local_io() -> &'static mut IoFactory {\n+    //            let mut sched = Local::borrow(None::<Scheduler>);\n+    //            let io = sched.get().event_loop.io();\n+    //            cast::transmute(io.unwrap())\n+    //        }\n+\n+    //        let test_function: proc() = proc() {\n+    //            let io = unsafe { local_io() };\n+    //            let addr = next_test_ip4();\n+    //            let maybe_socket = io.udp_bind(addr);\n+    //            // this socket is bound to this event loop\n+    //            assert!(maybe_socket.is_ok());\n+\n+    //            // block self on sched1\n+    //            let scheduler: ~Scheduler = Local::take();\n+    //            let mut tasksFriendHandle = Some(tasksFriendHandle);\n+    //            scheduler.deschedule_running_task_and_then(|_, task| {\n+    //                // unblock task\n+    //                task.wake().map(|task| {\n+    //                    // send self to sched2\n+    //                    tasksFriendHandle.take_unwrap()\n+    //                                     .send(TaskFromFriend(task));\n+    //                });\n+    //                // sched1 should now sleep since it has nothing else to do\n+    //            })\n+    //            // sched2 will wake up and get the task as we do nothing else,\n+    //            // the function ends and the socket goes out of scope sched2\n+    //            // will start to run the destructor the destructor will first\n+    //            // block the task, set it's home as sched1, then enqueue it\n+    //            // sched2 will dequeue the task, see that it has a home, and\n+    //            // send it to sched1 sched1 will wake up, exec the close\n+    //            // function on the correct loop, and then we're done\n+    //        };\n+\n+    //        let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None,\n+    //                                            test_function);\n+    //        main_task.death.on_exit = Some(on_exit);\n+\n+    //        let null_task = ~do Task::new_root(&mut sched2.stack_pool, None) {\n+    //            // nothing\n+    //        };\n+\n+    //        let main_task = main_task;\n+    //        let sched1 = sched1;\n+    //        let thread1 = do Thread::start {\n+    //            sched1.bootstrap(main_task);\n+    //        };\n+\n+    //        let sched2 = sched2;\n+    //        let thread2 = do Thread::start {\n+    //            sched2.bootstrap(null_task);\n+    //        };\n+\n+    //        thread1.join();\n+    //        thread2.join();\n+    //    }\n+    //}\n+}"}, {"sha": "44b74d050965ac6b4424379b632a094bfb16bb87", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 59, "deletions": 28, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -97,71 +97,102 @@ impl Drop for IdleWatcher {\n \n #[cfg(test)]\n mod test {\n-    use std::rt::tube::Tube;\n-    use std::rt::rtio::{Callback, PausableIdleCallback};\n+    use std::cast;\n+    use std::cell::RefCell;\n+    use std::rc::Rc;\n+    use std::rt::rtio::{Callback, PausibleIdleCallback};\n+    use std::rt::task::{BlockedTask, Task};\n+    use std::rt::local::Local;\n+    use super::IdleWatcher;\n     use super::super::local_loop;\n \n-    struct MyCallback(Tube<int>, int);\n+    type Chan = Rc<RefCell<(Option<BlockedTask>, uint)>>;\n+\n+    struct MyCallback(Rc<RefCell<(Option<BlockedTask>, uint)>>, uint);\n     impl Callback for MyCallback {\n         fn call(&mut self) {\n-            match *self {\n-                MyCallback(ref mut tube, val) => tube.send(val)\n-            }\n+            let task = match *self {\n+                MyCallback(ref rc, n) => {\n+                    let mut slot = rc.borrow().borrow_mut();\n+                    match *slot.get() {\n+                        (ref mut task, ref mut val) => {\n+                            *val = n;\n+                            task.take_unwrap()\n+                        }\n+                    }\n+                }\n+            };\n+            task.wake().map(|t| t.reawaken(true));\n         }\n     }\n \n+    fn mk(v: uint) -> (~IdleWatcher, Chan) {\n+        let rc = Rc::from_send(RefCell::new((None, 0)));\n+        let cb = ~MyCallback(rc.clone(), v);\n+        let cb = cb as ~Callback:;\n+        let cb = unsafe { cast::transmute(cb) };\n+        (IdleWatcher::new(&mut local_loop().loop_, cb), rc)\n+    }\n+\n+    fn sleep(chan: &Chan) -> uint {\n+        let task: ~Task = Local::take();\n+        task.deschedule(1, |task| {\n+            let mut slot = chan.borrow().borrow_mut();\n+            match *slot.get() {\n+                (ref mut slot, _) => {\n+                    assert!(slot.is_none());\n+                    *slot = Some(task);\n+                }\n+            }\n+            Ok(())\n+        });\n+\n+        let slot = chan.borrow().borrow();\n+        match *slot.get() { (_, n) => n }\n+    }\n+\n     #[test]\n     fn not_used() {\n-        let cb = ~MyCallback(Tube::new(), 1);\n-        let _idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (_idle, _chan) = mk(1);\n     }\n \n     #[test]\n     fn smoke_test() {\n-        let mut tube = Tube::new();\n-        let cb = ~MyCallback(tube.clone(), 1);\n-        let mut idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (mut idle, chan) = mk(1);\n         idle.resume();\n-        tube.recv();\n+        assert_eq!(sleep(&chan), 1);\n     }\n \n     #[test] #[should_fail]\n     fn smoke_fail() {\n-        let tube = Tube::new();\n-        let cb = ~MyCallback(tube.clone(), 1);\n-        let mut idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (mut idle, _chan) = mk(1);\n         idle.resume();\n         fail!();\n     }\n \n     #[test]\n     fn fun_combinations_of_methods() {\n-        let mut tube = Tube::new();\n-        let cb = ~MyCallback(tube.clone(), 1);\n-        let mut idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (mut idle, chan) = mk(1);\n         idle.resume();\n-        tube.recv();\n+        assert_eq!(sleep(&chan), 1);\n         idle.pause();\n         idle.resume();\n         idle.resume();\n-        tube.recv();\n+        assert_eq!(sleep(&chan), 1);\n         idle.pause();\n         idle.pause();\n         idle.resume();\n-        tube.recv();\n+        assert_eq!(sleep(&chan), 1);\n     }\n \n     #[test]\n     fn pause_pauses() {\n-        let mut tube = Tube::new();\n-        let cb = ~MyCallback(tube.clone(), 1);\n-        let mut idle1 = IdleWatcher::new(local_loop(), cb as ~Callback);\n-        let cb = ~MyCallback(tube.clone(), 2);\n-        let mut idle2 = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (mut idle1, chan1) = mk(1);\n+        let (mut idle2, chan2) = mk(2);\n         idle2.resume();\n-        assert_eq!(tube.recv(), 2);\n+        assert_eq!(sleep(&chan2), 2);\n         idle2.pause();\n         idle1.resume();\n-        assert_eq!(tube.recv(), 1);\n+        assert_eq!(sleep(&chan1), 1);\n     }\n }"}, {"sha": "49d695ea3fbb1bead4d99ed596796251ba1772b4", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -43,6 +43,8 @@ via `close` and `delete` methods.\n \n #[feature(macro_rules)];\n \n+#[cfg(test)] extern mod green;\n+\n use std::cast;\n use std::io;\n use std::io::IoError;\n@@ -392,15 +394,17 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n }\n \n+// This function is full of lies!\n #[cfg(test)]\n-fn local_loop() -> &'static mut Loop {\n+fn local_loop() -> &'static mut uvio::UvIoFactory {\n     unsafe {\n         cast::transmute({\n-            let mut sched = Local::borrow(None::<Scheduler>);\n+            let mut task = Local::borrow(None::<Task>);\n+            let mut io = task.get().local_io().unwrap();\n             let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n-                cast::transmute(sched.get().event_loop.io().unwrap());\n+                cast::transmute(io.get());\n             uvio\n-        }.uv_loop())\n+        })\n     }\n }\n "}, {"sha": "85e9202c1fa609791beea0875d7dfdefe0f18b0e", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 70, "deletions": 264, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -86,21 +86,19 @@ pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n     }\n }\n \n-#[cfg(test)]\n #[test]\n fn test_ip4_conversion() {\n-    use std::rt;\n-    let ip4 = rt::test::next_test_ip4();\n+    use std::io::net::ip::{SocketAddr, Ipv4Addr};\n+    let ip4 = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 4824 };\n     socket_addr_as_sockaddr(ip4, |addr| {\n         assert_eq!(ip4, sockaddr_to_socket_addr(addr));\n     })\n }\n \n-#[cfg(test)]\n #[test]\n fn test_ip6_conversion() {\n-    use std::rt;\n-    let ip6 = rt::test::next_test_ip6();\n+    use std::io::net::ip::{SocketAddr, Ipv6Addr};\n+    let ip6 = SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: 4824 };\n     socket_addr_as_sockaddr(ip6, |addr| {\n         assert_eq!(ip6, sockaddr_to_socket_addr(addr));\n     })\n@@ -634,16 +632,13 @@ impl Drop for UdpWatcher {\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-/// UV request support\n-////////////////////////////////////////////////////////////////////////////////\n-\n #[cfg(test)]\n mod test {\n     use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,\n                         RtioUdpSocket};\n-    use std::task;\n+    use std::io::test::{next_test_ip4, next_test_ip6};\n \n+    use super::{UdpWatcher, TcpWatcher, TcpListener};\n     use super::super::local_loop;\n \n     #[test]\n@@ -834,20 +829,18 @@ mod test {\n             }\n         }\n \n-        do spawn {\n-            port.recv();\n-            let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n-            let mut buf = [0, .. 2048];\n-            let mut total_bytes_read = 0;\n-            while total_bytes_read < MAX {\n-                let nread = stream.read(buf).unwrap();\n-                total_bytes_read += nread;\n-                for i in range(0u, nread) {\n-                    assert_eq!(buf[i], 1);\n-                }\n+        port.recv();\n+        let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n+        let mut buf = [0, .. 2048];\n+        let mut total_bytes_read = 0;\n+        while total_bytes_read < MAX {\n+            let nread = stream.read(buf).unwrap();\n+            total_bytes_read += nread;\n+            for i in range(0u, nread) {\n+                assert_eq!(buf[i], 1);\n             }\n-            uvdebug!(\"read {} bytes total\", total_bytes_read);\n         }\n+        uvdebug!(\"read {} bytes total\", total_bytes_read);\n     }\n \n     #[test]\n@@ -913,65 +906,35 @@ mod test {\n             assert!(total_bytes_sent >= MAX);\n         }\n \n-        do spawn {\n-            let l = local_loop();\n-            let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n-            let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n-            let (port, chan) = (p2, c1);\n-            port.recv();\n-            chan.send(());\n-            let mut total_bytes_recv = 0;\n-            let mut buf = [0, .. 2048];\n-            while total_bytes_recv < MAX {\n-                // ask for more\n-                assert!(client_out.sendto([1], server_in_addr).is_ok());\n-                // wait for data\n-                let res = client_in.recvfrom(buf);\n-                assert!(res.is_ok());\n-                let (nread, src) = res.unwrap();\n-                assert_eq!(src, server_out_addr);\n-                total_bytes_recv += nread;\n-                for i in range(0u, nread) {\n-                    assert_eq!(buf[i], 1);\n-                }\n+        let l = local_loop();\n+        let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n+        let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n+        let (port, chan) = (p2, c1);\n+        port.recv();\n+        chan.send(());\n+        let mut total_bytes_recv = 0;\n+        let mut buf = [0, .. 2048];\n+        while total_bytes_recv < MAX {\n+            // ask for more\n+            assert!(client_out.sendto([1], server_in_addr).is_ok());\n+            // wait for data\n+            let res = client_in.recvfrom(buf);\n+            assert!(res.is_ok());\n+            let (nread, src) = res.unwrap();\n+            assert_eq!(src, server_out_addr);\n+            total_bytes_recv += nread;\n+            for i in range(0u, nread) {\n+                assert_eq!(buf[i], 1);\n             }\n-            // tell the server we're done\n-            assert!(client_out.sendto([0], server_in_addr).is_ok());\n         }\n+        // tell the server we're done\n+        assert!(client_out.sendto([0], server_in_addr).is_ok());\n     }\n \n     #[test]\n     fn test_read_and_block() {\n         let addr = next_test_ip4();\n-        let (port, chan) = Chan::new();\n-\n-        do spawn {\n-            let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n-            let (port2, chan2) = Chan::new();\n-            chan.send(port2);\n-            let mut stream = acceptor.accept().unwrap();\n-            let mut buf = [0, .. 2048];\n-\n-            let expected = 32;\n-            let mut current = 0;\n-            let mut reads = 0;\n-\n-            while current < expected {\n-                let nread = stream.read(buf).unwrap();\n-                for i in range(0u, nread) {\n-                    let val = buf[i] as uint;\n-                    assert_eq!(val, current % 8);\n-                    current += 1;\n-                }\n-                reads += 1;\n-\n-                chan2.send(());\n-            }\n-\n-            // Make sure we had multiple reads\n-            assert!(reads > 1);\n-        }\n+        let (port, chan) = Chan::<Port<()>>::new();\n \n         do spawn {\n             let port2 = port.recv();\n@@ -983,13 +946,39 @@ mod test {\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             port2.recv();\n         }\n+\n+        let listener = TcpListener::bind(local_loop(), addr).unwrap();\n+        let mut acceptor = listener.listen().unwrap();\n+        let (port2, chan2) = Chan::new();\n+        chan.send(port2);\n+        let mut stream = acceptor.accept().unwrap();\n+        let mut buf = [0, .. 2048];\n+\n+        let expected = 32;\n+        let mut current = 0;\n+        let mut reads = 0;\n+\n+        while current < expected {\n+            let nread = stream.read(buf).unwrap();\n+            for i in range(0u, nread) {\n+                let val = buf[i] as uint;\n+                assert_eq!(val, current % 8);\n+                current += 1;\n+            }\n+            reads += 1;\n+\n+            chan2.try_send(());\n+        }\n+\n+        // Make sure we had multiple reads\n+        assert!(reads > 1);\n     }\n \n     #[test]\n     fn test_simple_tcp_server_and_client_on_diff_threads() {\n         let addr = next_test_ip4();\n \n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             let mut stream = acceptor.accept().unwrap();\n@@ -1001,131 +990,11 @@ mod test {\n             }\n         }\n \n-        do task::spawn_sched(task::SingleThreaded) {\n-            let mut stream = TcpWatcher::connect(local_loop(), addr);\n-            while stream.is_err() {\n-                stream = TcpWatcher::connect(local_loop(), addr);\n-            }\n-            stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n-        }\n-    }\n-\n-    // On one thread, create a udp socket. Then send that socket to another\n-    // thread and destroy the socket on the remote thread. This should make sure\n-    // that homing kicks in for the socket to go back home to the original\n-    // thread, close itself, and then come back to the last thread.\n-    #[test]\n-    fn test_homing_closes_correctly() {\n-        let (port, chan) = Chan::new();\n-\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let listener = UdpWatcher::bind(local_loop(), next_test_ip4()).unwrap();\n-            chan.send(listener);\n-        }\n-\n-        do task::spawn_sched(task::SingleThreaded) {\n-            port.recv();\n-        }\n-    }\n-\n-    // This is a bit of a crufty old test, but it has its uses.\n-    #[test]\n-    fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n-        use std::cast;\n-        use std::rt::local::Local;\n-        use std::rt::rtio::{EventLoop, IoFactory};\n-        use std::rt::sched::Scheduler;\n-        use std::rt::sched::{Shutdown, TaskFromFriend};\n-        use std::rt::sleeper_list::SleeperList;\n-        use std::rt::task::Task;\n-        use std::rt::thread::Thread;\n-        use std::rt::deque::BufferPool;\n-        use std::task::TaskResult;\n-        use std::unstable::run_in_bare_thread;\n-        use uvio::UvEventLoop;\n-\n-        do run_in_bare_thread {\n-            let sleepers = SleeperList::new();\n-            let mut pool = BufferPool::new();\n-            let (worker1, stealer1) = pool.deque();\n-            let (worker2, stealer2) = pool.deque();\n-            let queues = ~[stealer1, stealer2];\n-\n-            let loop1 = ~UvEventLoop::new() as ~EventLoop;\n-            let mut sched1 = ~Scheduler::new(loop1, worker1, queues.clone(),\n-                                             sleepers.clone());\n-            let loop2 = ~UvEventLoop::new() as ~EventLoop;\n-            let mut sched2 = ~Scheduler::new(loop2, worker2, queues.clone(),\n-                                             sleepers.clone());\n-\n-            let handle1 = sched1.make_handle();\n-            let handle2 = sched2.make_handle();\n-            let tasksFriendHandle = sched2.make_handle();\n-\n-            let on_exit: proc(TaskResult) = proc(exit_status) {\n-                let mut handle1 = handle1;\n-                let mut handle2 = handle2;\n-                handle1.send(Shutdown);\n-                handle2.send(Shutdown);\n-                assert!(exit_status.is_ok());\n-            };\n-\n-            unsafe fn local_io() -> &'static mut IoFactory {\n-                let mut sched = Local::borrow(None::<Scheduler>);\n-                let io = sched.get().event_loop.io();\n-                cast::transmute(io.unwrap())\n-            }\n-\n-            let test_function: proc() = proc() {\n-                let io = unsafe { local_io() };\n-                let addr = next_test_ip4();\n-                let maybe_socket = io.udp_bind(addr);\n-                // this socket is bound to this event loop\n-                assert!(maybe_socket.is_ok());\n-\n-                // block self on sched1\n-                let scheduler: ~Scheduler = Local::take();\n-                let mut tasksFriendHandle = Some(tasksFriendHandle);\n-                scheduler.deschedule_running_task_and_then(|_, task| {\n-                    // unblock task\n-                    task.wake().map(|task| {\n-                        // send self to sched2\n-                        tasksFriendHandle.take_unwrap()\n-                                         .send(TaskFromFriend(task));\n-                    });\n-                    // sched1 should now sleep since it has nothing else to do\n-                })\n-                // sched2 will wake up and get the task as we do nothing else,\n-                // the function ends and the socket goes out of scope sched2\n-                // will start to run the destructor the destructor will first\n-                // block the task, set it's home as sched1, then enqueue it\n-                // sched2 will dequeue the task, see that it has a home, and\n-                // send it to sched1 sched1 will wake up, exec the close\n-                // function on the correct loop, and then we're done\n-            };\n-\n-            let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None,\n-                                                test_function);\n-            main_task.death.on_exit = Some(on_exit);\n-\n-            let null_task = ~do Task::new_root(&mut sched2.stack_pool, None) {\n-                // nothing\n-            };\n-\n-            let main_task = main_task;\n-            let sched1 = sched1;\n-            let thread1 = do Thread::start {\n-                sched1.bootstrap(main_task);\n-            };\n-\n-            let sched2 = sched2;\n-            let thread2 = do Thread::start {\n-                sched2.bootstrap(null_task);\n-            };\n-\n-            thread1.join();\n-            thread2.join();\n+        let mut stream = TcpWatcher::connect(local_loop(), addr);\n+        while stream.is_err() {\n+            stream = TcpWatcher::connect(local_loop(), addr);\n         }\n+        stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n     }\n \n     #[should_fail] #[test]\n@@ -1167,75 +1036,12 @@ mod test {\n         // force the handle to be created on a different scheduler, failure in\n         // the original task will force a homing operation back to this\n         // scheduler.\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             let w = UdpWatcher::bind(local_loop(), addr).unwrap();\n             chan.send(w);\n         }\n \n         let _w = port.recv();\n         fail!();\n     }\n-\n-    #[should_fail]\n-    #[test]\n-    #[ignore(reason = \"linked failure\")]\n-    fn linked_failure1() {\n-        let (port, chan) = Chan::new();\n-        let addr = next_test_ip4();\n-\n-        do spawn {\n-            let w = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut w = w.listen().unwrap();\n-            chan.send(());\n-            w.accept();\n-        }\n-\n-        port.recv();\n-        fail!();\n-    }\n-\n-    #[should_fail]\n-    #[test]\n-    #[ignore(reason = \"linked failure\")]\n-    fn linked_failure2() {\n-        let (port, chan) = Chan::new();\n-        let addr = next_test_ip4();\n-\n-        do spawn {\n-            let w = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut w = w.listen().unwrap();\n-            chan.send(());\n-            let mut buf = [0];\n-            w.accept().unwrap().read(buf);\n-        }\n-\n-        port.recv();\n-        let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n-\n-        fail!();\n-    }\n-\n-    #[should_fail]\n-    #[test]\n-    #[ignore(reason = \"linked failure\")]\n-    fn linked_failure3() {\n-        let (port, chan) = Chan::new();\n-        let addr = next_test_ip4();\n-\n-        do spawn {\n-            let chan = chan;\n-            let w = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut w = w.listen().unwrap();\n-            chan.send(());\n-            let mut conn = w.accept().unwrap();\n-            chan.send(());\n-            let buf = [0, ..65536];\n-            conn.write(buf);\n-        }\n-\n-        port.recv();\n-        let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n-        port.recv();\n-        fail!();\n-    }\n }"}, {"sha": "0bc198a4a3f5d9193b6652654c093b40f291e49f", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -235,8 +235,9 @@ impl HomingIO for PipeAcceptor {\n #[cfg(test)]\n mod tests {\n     use std::rt::rtio::{RtioUnixListener, RtioUnixAcceptor, RtioPipe};\n-    use std::rt::test::next_test_unix;\n+    use std::io::test::next_test_unix;\n \n+    use super::{PipeWatcher, PipeListener};\n     use super::super::local_loop;\n \n     #[test]"}, {"sha": "b53acd4ebd693dab6faa64f0f53c83cb2aefc735", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -52,7 +52,7 @@ impl SignalWatcher {\n extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n     let s: &mut SignalWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n     assert_eq!(signum as int, s.signal as int);\n-    s.channel.send_deferred(s.signal);\n+    s.channel.try_send_deferred(s.signal);\n }\n \n impl HomingIO for SignalWatcher {\n@@ -76,6 +76,7 @@ impl Drop for SignalWatcher {\n mod test {\n     use super::super::local_loop;\n     use std::io::signal;\n+    use super::SignalWatcher;\n \n     #[test]\n     fn closing_channel_during_drop_doesnt_kill_everything() {"}, {"sha": "d3a190df8be6ad6153f34bfbc9ea0f2f68ec2ce9", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -179,6 +179,7 @@ impl Drop for TimerWatcher {\n mod test {\n     use std::rt::rtio::RtioTimer;\n     use super::super::local_loop;\n+    use super::TimerWatcher;\n \n     #[test]\n     fn oneshot() {"}, {"sha": "57bb0cfdc7af8f109cc076fe5b4ec91ba10b6d24", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -102,6 +102,7 @@ pub extern \"C\" fn new_loop() -> ~rtio::EventLoop {\n \n #[test]\n fn test_callback_run_once() {\n+    use std::rt::rtio::EventLoop;\n     do run_in_bare_thread {\n         let mut event_loop = UvEventLoop::new();\n         let mut count = 0;"}, {"sha": "2d52986294d1c6884ea61e843e433e6c3d2d3083", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "patch": "@@ -313,9 +313,8 @@ pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n pub use self::process::Process;\n \n-/// Testing helpers\n-#[cfg(test)]\n-mod test;\n+/// Various utility functions useful for writing I/O tests\n+pub mod test;\n \n /// Synchronous, non-blocking filesystem operations.\n pub mod fs;"}]}