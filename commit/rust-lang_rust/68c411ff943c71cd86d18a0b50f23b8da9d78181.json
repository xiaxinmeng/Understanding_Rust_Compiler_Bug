{"sha": "68c411ff943c71cd86d18a0b50f23b8da9d78181", "node_id": "C_kwDOAAsO6NoAKDY4YzQxMWZmOTQzYzcxY2Q4NmQxOGEwYjUwZjIzYjhkYTlkNzgxODE", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-03T23:01:44Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-03T23:09:50Z"}, "message": "Move `ManualMap` into `Matches` lint pass", "tree": {"sha": "1f777bff2ec2a234e50f5a1f56345a42988958cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f777bff2ec2a234e50f5a1f56345a42988958cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68c411ff943c71cd86d18a0b50f23b8da9d78181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68c411ff943c71cd86d18a0b50f23b8da9d78181", "html_url": "https://github.com/rust-lang/rust/commit/68c411ff943c71cd86d18a0b50f23b8da9d78181", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68c411ff943c71cd86d18a0b50f23b8da9d78181/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67cb5ec29f0e1adb55f945a8acea20c47f586c56", "url": "https://api.github.com/repos/rust-lang/rust/commits/67cb5ec29f0e1adb55f945a8acea20c47f586c56", "html_url": "https://github.com/rust-lang/rust/commit/67cb5ec29f0e1adb55f945a8acea20c47f586c56"}], "stats": {"total": 660, "additions": 339, "deletions": 321}, "files": [{"sha": "d4ec046d0bb08b2100dc3cc585123b473c2ce2d2", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=68c411ff943c71cd86d18a0b50f23b8da9d78181", "patch": "@@ -133,7 +133,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(main_recursion::MAIN_RECURSION),\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n     LintId::of(manual_bits::MANUAL_BITS),\n-    LintId::of(manual_map::MANUAL_MAP),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(manual_strip::MANUAL_STRIP),\n     LintId::of(map_clone::MAP_CLONE),\n@@ -142,6 +141,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+    LintId::of(matches::MANUAL_MAP),\n     LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),"}, {"sha": "4cf38e8ab15bce8672b74da20a69c2c2f9b5370e", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=68c411ff943c71cd86d18a0b50f23b8da9d78181", "patch": "@@ -250,7 +250,6 @@ store.register_lints(&[\n     manual_assert::MANUAL_ASSERT,\n     manual_async_fn::MANUAL_ASYNC_FN,\n     manual_bits::MANUAL_BITS,\n-    manual_map::MANUAL_MAP,\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n     manual_ok_or::MANUAL_OK_OR,\n     manual_strip::MANUAL_STRIP,\n@@ -261,6 +260,7 @@ store.register_lints(&[\n     match_result_ok::MATCH_RESULT_OK,\n     matches::COLLAPSIBLE_MATCH,\n     matches::INFALLIBLE_DESTRUCTURING_MATCH,\n+    matches::MANUAL_MAP,\n     matches::MANUAL_UNWRAP_OR,\n     matches::MATCH_AS_REF,\n     matches::MATCH_BOOL,"}, {"sha": "35575351784a287786eba32e8b2b7dfc3934227f", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=68c411ff943c71cd86d18a0b50f23b8da9d78181", "patch": "@@ -45,12 +45,12 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(main_recursion::MAIN_RECURSION),\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n     LintId::of(manual_bits::MANUAL_BITS),\n-    LintId::of(manual_map::MANUAL_MAP),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(map_clone::MAP_CLONE),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+    LintId::of(matches::MANUAL_MAP),\n     LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),\n     LintId::of(matches::MATCH_OVERLAPPING_ARM),\n     LintId::of(matches::MATCH_REF_PATS),"}, {"sha": "c924bfe2ad6113baccd6d7bc4ecd6a3988286764", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=68c411ff943c71cd86d18a0b50f23b8da9d78181", "patch": "@@ -279,7 +279,6 @@ mod main_recursion;\n mod manual_assert;\n mod manual_async_fn;\n mod manual_bits;\n-mod manual_map;\n mod manual_non_exhaustive;\n mod manual_ok_or;\n mod manual_strip;\n@@ -845,7 +844,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n     store.register_late_pass(|| Box::new(redundant_slicing::RedundantSlicing));\n     store.register_late_pass(|| Box::new(from_str_radix_10::FromStrRadix10));\n-    store.register_late_pass(|| Box::new(manual_map::ManualMap));\n     store.register_late_pass(move || Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n     store.register_late_pass(|| Box::new(bool_assert_comparison::BoolAssertComparison));\n     store.register_early_pass(move || Box::new(module_style::ModStyle));"}, {"sha": "230ae029ed9d28978eeb256c40604e24e0df1d81", "filename": "clippy_lints/src/manual_map.rs", "status": "removed", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=67cb5ec29f0e1adb55f945a8acea20c47f586c56", "patch": "@@ -1,316 +0,0 @@\n-use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::IfLetOrMatch;\n-use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n-use clippy_utils::{\n-    can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n-    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n-};\n-use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n-    QPath, UnsafeSource,\n-};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, SyntaxContext};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usages of `match` which could be implemented using `map`\n-    ///\n-    /// ### Why is this bad?\n-    /// Using the `map` method is clearer and more concise.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// match Some(0) {\n-    ///     Some(x) => Some(x + 1),\n-    ///     None => None,\n-    /// };\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// Some(0).map(|x| x + 1);\n-    /// ```\n-    #[clippy::version = \"1.52.0\"]\n-    pub MANUAL_MAP,\n-    style,\n-    \"reimplementation of `map`\"\n-}\n-\n-declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ManualMap {\n-    #[expect(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let (scrutinee, then_pat, then_body, else_pat, else_body) = match IfLetOrMatch::parse(cx, expr) {\n-            Some(IfLetOrMatch::IfLet(scrutinee, pat, body, Some(r#else))) => (scrutinee, pat, body, None, r#else),\n-            Some(IfLetOrMatch::Match(\n-                scrutinee,\n-                [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }],\n-                _,\n-            )) => (scrutinee, arm1.pat, arm1.body, Some(arm2.pat), arm2.body),\n-            _ => return,\n-        };\n-        if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n-            return;\n-        }\n-\n-        let (scrutinee_ty, ty_ref_count, ty_mutability) =\n-            peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-        if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n-            && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n-        {\n-            return;\n-        }\n-\n-        let expr_ctxt = expr.span.ctxt();\n-        let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-            try_parse_pattern(cx, then_pat, expr_ctxt),\n-            else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n-        ) {\n-            (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-                (else_body, pattern, ref_count, true)\n-            },\n-            (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-                (else_body, pattern, ref_count, false)\n-            },\n-            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n-                (then_body, pattern, ref_count, true)\n-            },\n-            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n-                (then_body, pattern, ref_count, false)\n-            },\n-            _ => return,\n-        };\n-\n-        // Top level or patterns aren't allowed in closures.\n-        if matches!(some_pat.kind, PatKind::Or(_)) {\n-            return;\n-        }\n-\n-        let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n-            Some(expr) => expr,\n-            None => return,\n-        };\n-\n-        // These two lints will go back and forth with each other.\n-        if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n-            && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n-        {\n-            return;\n-        }\n-\n-        // `map` won't perform any adjustments.\n-        if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n-            return;\n-        }\n-\n-        // Determine which binding mode to use.\n-        let explicit_ref = some_pat.contains_explicit_ref_binding();\n-        let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n-\n-        let as_ref_str = match binding_ref {\n-            Some(Mutability::Mut) => \".as_mut()\",\n-            Some(Mutability::Not) => \".as_ref()\",\n-            None => \"\",\n-        };\n-\n-        match can_move_expr_to_closure(cx, some_expr.expr) {\n-            Some(captures) => {\n-                // Check if captures the closure will need conflict with borrows made in the scrutinee.\n-                // TODO: check all the references made in the scrutinee expression. This will require interacting\n-                // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n-                if let Some(binding_ref_mutability) = binding_ref {\n-                    let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n-                        ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n-                        _ => None,\n-                    });\n-                    if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n-                        match captures.get(l) {\n-                            Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n-                            Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n-                                return;\n-                            },\n-                            Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n-                        }\n-                    }\n-                }\n-            },\n-            None => return,\n-        };\n-\n-        let mut app = Applicability::MachineApplicable;\n-\n-        // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-        // it's being passed by value.\n-        let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-        let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-        let scrutinee_str =\n-            if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-                format!(\"({})\", scrutinee_str)\n-            } else {\n-                scrutinee_str.into()\n-            };\n-\n-        let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-            if_chain! {\n-                if !some_expr.needs_unsafe_block;\n-                if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n-                if func.span.ctxt() == some_expr.expr.span.ctxt();\n-                then {\n-                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                } else {\n-                    if path_to_local_id(some_expr.expr, id)\n-                        && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                        && binding_ref.is_some()\n-                    {\n-                        return;\n-                    }\n-\n-                    // `ref` and `ref mut` annotations were handled earlier.\n-                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                        \"mut \"\n-                    } else {\n-                        \"\"\n-                    };\n-                    let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n-                    if some_expr.needs_unsafe_block {\n-                        format!(\"|{}{}| unsafe {{ {} }}\", annotation, some_binding, expr_snip)\n-                    } else {\n-                        format!(\"|{}{}| {}\", annotation, some_binding, expr_snip)\n-                    }\n-                }\n-            }\n-        } else if !is_wild_none && explicit_ref.is_none() {\n-            // TODO: handle explicit reference annotations.\n-            let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n-            let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n-            if some_expr.needs_unsafe_block {\n-                format!(\"|{}| unsafe {{ {} }}\", pat_snip, expr_snip)\n-            } else {\n-                format!(\"|{}| {}\", pat_snip, expr_snip)\n-            }\n-        } else {\n-            // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-            return;\n-        };\n-\n-        span_lint_and_sugg(\n-            cx,\n-            MANUAL_MAP,\n-            expr.span,\n-            \"manual implementation of `Option::map`\",\n-            \"try this\",\n-            if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n-                format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n-            } else {\n-                format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n-            },\n-            app,\n-        );\n-    }\n-}\n-\n-// Checks whether the expression could be passed as a function, or whether a closure is needed.\n-// Returns the function to be passed to `map` if it exists.\n-fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    match expr.kind {\n-        ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding)\n-                && cx.typeck_results().expr_adjustments(arg).is_empty()\n-                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n-        {\n-            Some(func)\n-        },\n-        _ => None,\n-    }\n-}\n-\n-enum OptionPat<'a> {\n-    Wild,\n-    None,\n-    Some {\n-        // The pattern contained in the `Some` tuple.\n-        pattern: &'a Pat<'a>,\n-        // The number of references before the `Some` tuple.\n-        // e.g. `&&Some(_)` has a ref count of 2.\n-        ref_count: usize,\n-    },\n-}\n-\n-struct SomeExpr<'tcx> {\n-    expr: &'tcx Expr<'tcx>,\n-    needs_unsafe_block: bool,\n-}\n-\n-// Try to parse into a recognized `Option` pattern.\n-// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n-    fn f<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        pat: &'tcx Pat<'_>,\n-        ref_count: usize,\n-        ctxt: SyntaxContext,\n-    ) -> Option<OptionPat<'tcx>> {\n-        match pat.kind {\n-            PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n-            PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n-            {\n-                Some(OptionPat::Some { pattern, ref_count })\n-            },\n-            _ => None,\n-        }\n-    }\n-    f(cx, pat, 0, ctxt)\n-}\n-\n-// Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n-fn get_some_expr<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    needs_unsafe_block: bool,\n-    ctxt: SyntaxContext,\n-) -> Option<SomeExpr<'tcx>> {\n-    // TODO: Allow more complex expressions.\n-    match expr.kind {\n-        ExprKind::Call(\n-            Expr {\n-                kind: ExprKind::Path(ref qpath),\n-                ..\n-            },\n-            [arg],\n-        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n-            expr: arg,\n-            needs_unsafe_block,\n-        }),\n-        ExprKind::Block(\n-            Block {\n-                stmts: [],\n-                expr: Some(expr),\n-                rules,\n-                ..\n-            },\n-            _,\n-        ) => get_some_expr(\n-            cx,\n-            expr,\n-            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n-            ctxt,\n-        ),\n-        _ => None,\n-    }\n-}\n-\n-// Checks for the `None` value.\n-fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n-}"}, {"sha": "542905a2d763cffa4879b4f75d7acefa3e4aa7a3", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=68c411ff943c71cd86d18a0b50f23b8da9d78181", "patch": "@@ -0,0 +1,306 @@\n+use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n+use clippy_utils::{\n+    can_move_expr_to_closure, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id, peel_blocks,\n+    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+};\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n+    QPath, UnsafeSource,\n+};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, SyntaxContext};\n+\n+use super::MANUAL_MAP;\n+\n+pub(super) fn check_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'_>],\n+) {\n+    if let [arm1, arm2] = arms\n+        && arm1.guard.is_none()\n+        && arm2.guard.is_none()\n+    {\n+        check(cx, expr, scrutinee, arm1.pat, arm1.body, Some(arm2.pat), arm2.body);\n+    }\n+}\n+\n+pub(super) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    then_expr: &'tcx Expr<'_>,\n+    else_expr: &'tcx Expr<'_>,\n+) {\n+    check(cx, expr, let_expr, let_pat, then_expr, None, else_expr);\n+}\n+\n+#[expect(clippy::too_many_lines)]\n+fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    then_pat: &'tcx Pat<'_>,\n+    then_body: &'tcx Expr<'_>,\n+    else_pat: Option<&'tcx Pat<'_>>,\n+    else_body: &'tcx Expr<'_>,\n+) {\n+    let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+        peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n+    {\n+        return;\n+    }\n+\n+    let expr_ctxt = expr.span.ctxt();\n+    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+        try_parse_pattern(cx, then_pat, expr_ctxt),\n+        else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+    ) {\n+        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, false)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, false)\n+        },\n+        _ => return,\n+    };\n+\n+    // Top level or patterns aren't allowed in closures.\n+    if matches!(some_pat.kind, PatKind::Or(_)) {\n+        return;\n+    }\n+\n+    let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n+        Some(expr) => expr,\n+        None => return,\n+    };\n+\n+    // These two lints will go back and forth with each other.\n+    if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n+        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+    {\n+        return;\n+    }\n+\n+    // `map` won't perform any adjustments.\n+    if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n+        return;\n+    }\n+\n+    // Determine which binding mode to use.\n+    let explicit_ref = some_pat.contains_explicit_ref_binding();\n+    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+\n+    let as_ref_str = match binding_ref {\n+        Some(Mutability::Mut) => \".as_mut()\",\n+        Some(Mutability::Not) => \".as_ref()\",\n+        None => \"\",\n+    };\n+\n+    match can_move_expr_to_closure(cx, some_expr.expr) {\n+        Some(captures) => {\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if let Some(binding_ref_mutability) = binding_ref {\n+                let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                    match captures.get(l) {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n+                            return;\n+                        },\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n+        },\n+        None => return,\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n+\n+    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+    // it's being passed by value.\n+    let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+        format!(\"({})\", scrutinee_str)\n+    } else {\n+        scrutinee_str.into()\n+    };\n+\n+    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+        if_chain! {\n+            if !some_expr.needs_unsafe_block;\n+            if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n+            if func.span.ctxt() == some_expr.expr.span.ctxt();\n+            then {\n+                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+            } else {\n+                if path_to_local_id(some_expr.expr, id)\n+                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                    && binding_ref.is_some()\n+                {\n+                    return;\n+                }\n+\n+                // `ref` and `ref mut` annotations were handled earlier.\n+                let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                };\n+                let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n+                if some_expr.needs_unsafe_block {\n+                    format!(\"|{}{}| unsafe {{ {} }}\", annotation, some_binding, expr_snip)\n+                } else {\n+                    format!(\"|{}{}| {}\", annotation, some_binding, expr_snip)\n+                }\n+            }\n+        }\n+    } else if !is_wild_none && explicit_ref.is_none() {\n+        // TODO: handle explicit reference annotations.\n+        let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n+        let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n+        if some_expr.needs_unsafe_block {\n+            format!(\"|{}| unsafe {{ {} }}\", pat_snip, expr_snip)\n+        } else {\n+            format!(\"|{}| {}\", pat_snip, expr_snip)\n+        }\n+    } else {\n+        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+        return;\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        MANUAL_MAP,\n+        expr.span,\n+        \"manual implementation of `Option::map`\",\n+        \"try this\",\n+        if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n+            format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n+        } else {\n+            format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n+        },\n+        app,\n+    );\n+}\n+\n+// Checks whether the expression could be passed as a function, or whether a closure is needed.\n+// Returns the function to be passed to `map` if it exists.\n+fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    match expr.kind {\n+        ExprKind::Call(func, [arg])\n+            if path_to_local_id(arg, binding)\n+                && cx.typeck_results().expr_adjustments(arg).is_empty()\n+                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n+        {\n+            Some(func)\n+        },\n+        _ => None,\n+    }\n+}\n+\n+enum OptionPat<'a> {\n+    Wild,\n+    None,\n+    Some {\n+        // The pattern contained in the `Some` tuple.\n+        pattern: &'a Pat<'a>,\n+        // The number of references before the `Some` tuple.\n+        // e.g. `&&Some(_)` has a ref count of 2.\n+        ref_count: usize,\n+    },\n+}\n+\n+struct SomeExpr<'tcx> {\n+    expr: &'tcx Expr<'tcx>,\n+    needs_unsafe_block: bool,\n+}\n+\n+// Try to parse into a recognized `Option` pattern.\n+// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n+fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+    fn f<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        pat: &'tcx Pat<'_>,\n+        ref_count: usize,\n+        ctxt: SyntaxContext,\n+    ) -> Option<OptionPat<'tcx>> {\n+        match pat.kind {\n+            PatKind::Wild => Some(OptionPat::Wild),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n+            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n+            PatKind::TupleStruct(ref qpath, [pattern], _)\n+                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n+            {\n+                Some(OptionPat::Some { pattern, ref_count })\n+            },\n+            _ => None,\n+        }\n+    }\n+    f(cx, pat, 0, ctxt)\n+}\n+\n+// Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n+fn get_some_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    needs_unsafe_block: bool,\n+    ctxt: SyntaxContext,\n+) -> Option<SomeExpr<'tcx>> {\n+    // TODO: Allow more complex expressions.\n+    match expr.kind {\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(ref qpath),\n+                ..\n+            },\n+            [arg],\n+        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n+            expr: arg,\n+            needs_unsafe_block,\n+        }),\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: Some(expr),\n+                rules,\n+                ..\n+            },\n+            _,\n+        ) => get_some_expr(\n+            cx,\n+            expr,\n+            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+            ctxt,\n+        ),\n+        _ => None,\n+    }\n+}\n+\n+// Checks for the `None` value.\n+fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n+}"}, {"sha": "d1e42f39e470dde07bdf5daee81a034846d5dd97", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c411ff943c71cd86d18a0b50f23b8da9d78181/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=68c411ff943c71cd86d18a0b50f23b8da9d78181", "patch": "@@ -10,6 +10,7 @@ use rustc_span::{Span, SpanData, SyntaxContext};\n \n mod collapsible_match;\n mod infallible_destructuring_match;\n+mod manual_map;\n mod manual_unwrap_or;\n mod match_as_ref;\n mod match_bool;\n@@ -861,6 +862,30 @@ declare_clippy_lint! {\n     \"return errors explicitly rather than hiding them behind a `?`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of `match` which could be implemented using `map`\n+    ///\n+    /// ### Why is this bad?\n+    /// Using the `map` method is clearer and more concise.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// match Some(0) {\n+    ///     Some(x) => Some(x + 1),\n+    ///     None => None,\n+    /// };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// Some(0).map(|x| x + 1);\n+    /// ```\n+    #[clippy::version = \"1.52.0\"]\n+    pub MANUAL_MAP,\n+    style,\n+    \"reimplementation of `map`\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -901,6 +926,7 @@ impl_lint_pass!(Matches => [\n     MATCH_STR_CASE_MISMATCH,\n     SIGNIFICANT_DROP_IN_SCRUTINEE,\n     TRY_ERR,\n+    MANUAL_MAP,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -949,6 +975,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n \n                     if !in_constant(cx, expr.hir_id) {\n                         manual_unwrap_or::check(cx, expr, ex, arms);\n+                        manual_map::check_match(cx, expr, ex, arms);\n                     }\n \n                     if self.infallible_destructuring_match_linted {\n@@ -973,6 +1000,9 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                             else_expr,\n                         );\n                     }\n+                    if !in_constant(cx, expr.hir_id) {\n+                        manual_map::check_if_let(cx, expr, if_let.let_pat, if_let.let_expr, if_let.if_then, else_expr);\n+                    }\n                 }\n                 redundant_pattern_match::check_if_let(\n                     cx,"}]}