{"sha": "757ed07f374edfe93be5c9084ac5c44ba738e1b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1N2VkMDdmMzc0ZWRmZTkzYmU1YzkwODRhYzVjNDRiYTczOGUxYjI=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-01-07T10:36:57Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-01-11T10:18:44Z"}, "message": "Apply review feedback", "tree": {"sha": "e3d914597ed811ab5da6691ab050c5a817542d54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3d914597ed811ab5da6691ab050c5a817542d54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/757ed07f374edfe93be5c9084ac5c44ba738e1b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/757ed07f374edfe93be5c9084ac5c44ba738e1b2", "html_url": "https://github.com/rust-lang/rust/commit/757ed07f374edfe93be5c9084ac5c44ba738e1b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/757ed07f374edfe93be5c9084ac5c44ba738e1b2/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed217a53ff959414e9c723d8fecf80bc797a5a77", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed217a53ff959414e9c723d8fecf80bc797a5a77", "html_url": "https://github.com/rust-lang/rust/commit/ed217a53ff959414e9c723d8fecf80bc797a5a77"}], "stats": {"total": 41, "additions": 22, "deletions": 19}, "files": [{"sha": "fbadf4ac6a058dd50e1d4a01789c917f3132b600", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/757ed07f374edfe93be5c9084ac5c44ba738e1b2/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757ed07f374edfe93be5c9084ac5c44ba738e1b2/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=757ed07f374edfe93be5c9084ac5c44ba738e1b2", "patch": "@@ -53,6 +53,10 @@ pub fn payload() -> *mut u8 {\n }\n \n struct Exception {\n+    // This needs to be an Option because the object's lifetime follows C++\n+    // semantics: when catch_unwind moves the Box out of the exception it must\n+    // still leave the exception object in a valid state because its destructor\n+    // is still going to be called by __cxa_end_catch..\n     data: Option<Box<dyn Any + Send>>,\n }\n "}, {"sha": "f1d0080472a01a6dbadb8849ca5a90ad440e1bc7", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/757ed07f374edfe93be5c9084ac5c44ba738e1b2/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757ed07f374edfe93be5c9084ac5c44ba738e1b2/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=757ed07f374edfe93be5c9084ac5c44ba738e1b2", "patch": "@@ -224,33 +224,28 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n // used as the result of the exception copy. This is used by the C++ runtime to\n // support capturing exceptions with std::exception_ptr, which we can't support\n // because Box<dyn Any> isn't clonable.\n-cfg_if::cfg_if! {\n-    if #[cfg(target_arch = \"x86\")] {\n-        unsafe extern \"thiscall\" fn exception_cleanup(e: *mut [u64; 2]) {\n-            if (*e)[0] != 0 {\n-                cleanup(*e);\n-            }\n-        }\n-        #[unwind(allowed)]\n-        unsafe extern \"thiscall\" fn exception_copy(_dest: *mut [u64; 2],\n-                                                   _src: *mut [u64; 2])\n-                                                   -> *mut [u64; 2] {\n-            panic!(\"Rust panics cannot be copied\");\n-        }\n-    } else {\n-        unsafe extern \"C\" fn exception_cleanup(e: *mut [u64; 2]) {\n+macro_rules! define_cleanup {\n+    ($abi:tt) => {\n+        unsafe extern $abi fn exception_cleanup(e: *mut [u64; 2]) {\n             if (*e)[0] != 0 {\n                 cleanup(*e);\n             }\n         }\n         #[unwind(allowed)]\n-        unsafe extern \"C\" fn exception_copy(_dest: *mut [u64; 2],\n-                                            _src: *mut [u64; 2])\n-                                            -> *mut [u64; 2] {\n+        unsafe extern $abi fn exception_copy(_dest: *mut [u64; 2],\n+                                             _src: *mut [u64; 2])\n+                                             -> *mut [u64; 2] {\n             panic!(\"Rust panics cannot be copied\");\n         }\n     }\n }\n+cfg_if::cfg_if! {\n+   if #[cfg(target_arch = \"x86\")] {\n+       define_cleanup!(\"thiscall\");\n+   } else {\n+       define_cleanup!(\"C\");\n+   }\n+}\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     use core::intrinsics::atomic_store;"}, {"sha": "031837c1efbe814da24c7843022d3bb3cb710c0f", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/757ed07f374edfe93be5c9084ac5c44ba738e1b2/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757ed07f374edfe93be5c9084ac5c44ba738e1b2/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=757ed07f374edfe93be5c9084ac5c44ba738e1b2", "patch": "@@ -953,7 +953,9 @@ fn codegen_msvc_try(\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n         // The flag value of 8 indicates that we are catching the exception by\n-        // reference instead of by value.\n+        // reference instead of by value. We can't use catch by value because\n+        // that requires copying the exception object, which we don't support\n+        // since our exception object effectively contains a Box.\n         //\n         // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n         let flags = bx.const_i32(8);\n@@ -970,6 +972,8 @@ fn codegen_msvc_try(\n         catchpad.store(payload, local_ptr, i64_align);\n \n         // Clear the first word of the exception so avoid double-dropping it.\n+        // This will be read by the destructor which is implicitly called at the\n+        // end of the catch block by the runtime.\n         let payload_0_ptr = catchpad.inbounds_gep(payload_ptr, &[bx.const_i32(0), bx.const_i32(0)]);\n         catchpad.store(bx.const_u64(0), payload_0_ptr, i64_align);\n "}]}