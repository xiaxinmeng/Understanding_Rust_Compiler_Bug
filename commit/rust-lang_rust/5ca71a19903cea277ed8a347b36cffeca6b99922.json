{"sha": "5ca71a19903cea277ed8a347b36cffeca6b99922", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYTcxYTE5OTAzY2VhMjc3ZWQ4YTM0N2IzNmNmZmVjYTZiOTk5MjI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-13T11:00:34Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-13T11:00:34Z"}, "message": "Make block-local trait impls work\n\nAs long as either the trait or the implementing type are defined in the\nsame block.", "tree": {"sha": "20862ee6b7faf2a13ed810af4e8a80ff2cfbab83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20862ee6b7faf2a13ed810af4e8a80ff2cfbab83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ca71a19903cea277ed8a347b36cffeca6b99922", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ca71a19903cea277ed8a347b36cffeca6b99922", "html_url": "https://github.com/rust-lang/rust/commit/5ca71a19903cea277ed8a347b36cffeca6b99922", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ca71a19903cea277ed8a347b36cffeca6b99922/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adbee621a75f47e0da4f30d7205dfce009138865", "url": "https://api.github.com/repos/rust-lang/rust/commits/adbee621a75f47e0da4f30d7205dfce009138865", "html_url": "https://github.com/rust-lang/rust/commit/adbee621a75f47e0da4f30d7205dfce009138865"}], "stats": {"total": 190, "additions": 154, "deletions": 36}, "files": [{"sha": "bb174aec810ce4cb4bf17ed3fa399c04da20a227", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=5ca71a19903cea277ed8a347b36cffeca6b99922", "patch": "@@ -112,6 +112,10 @@ impl ModuleId {\n         self.def_map(db).containing_module(self.local_id)\n     }\n \n+    pub fn containing_block(&self) -> Option<BlockId> {\n+        self.block\n+    }\n+\n     /// Returns `true` if this module represents a block expression.\n     ///\n     /// Returns `false` if this module is a submodule *inside* a block expression\n@@ -581,6 +585,18 @@ impl HasModule for GenericDefId {\n     }\n }\n \n+impl HasModule for TypeAliasId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n+        self.lookup(db).module(db)\n+    }\n+}\n+\n+impl HasModule for TraitId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n+        self.lookup(db).container\n+    }\n+}\n+\n impl HasModule for StaticLoc {\n     fn module(&self, _db: &dyn db::DefDatabase) -> ModuleId {\n         self.container"}, {"sha": "a4c09c742aa5ff7d4c3c516450c5ab1d97e8333a", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=5ca71a19903cea277ed8a347b36cffeca6b99922", "patch": "@@ -10,16 +10,16 @@ use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n use base_db::CrateId;\n use hir_def::{\n     lang_item::{lang_attr, LangItemTarget},\n-    AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId,\n+    AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, ModuleId, TypeAliasId,\n };\n use hir_expand::name::name;\n \n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n-    from_assoc_type_id, from_chalk_trait_id, make_only_type_binders,\n+    from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id, make_only_type_binders,\n     mapping::{from_chalk, ToChalk, TypeAliasAsValue},\n-    method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n+    method_resolution::{TraitImpls, TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::ChalkContext,\n     utils::generics,\n@@ -105,27 +105,47 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             _ => self_ty_fp.as_ref().map(std::slice::from_ref).unwrap_or(&[]),\n         };\n \n+        fn local_impls(db: &dyn HirDatabase, module: ModuleId) -> Option<Arc<TraitImpls>> {\n+            db.trait_impls_in_block(module.containing_block()?)\n+        }\n+\n         // Note: Since we're using impls_for_trait, only impls where the trait\n-        // can be resolved should ever reach Chalk. Symbol\u2019s value as variable is void: impl_datum relies on that\n+        // can be resolved should ever reach Chalk. impl_datum relies on that\n         // and will panic if the trait can't be resolved.\n         let in_deps = self.db.trait_impls_in_deps(self.krate);\n         let in_self = self.db.trait_impls_in_crate(self.krate);\n-        let impl_maps = [in_deps, in_self];\n+        let trait_module = trait_.module(self.db.upcast());\n+        let type_module = match self_ty_fp {\n+            Some(TyFingerprint::Adt(adt_id)) => Some(adt_id.module(self.db.upcast())),\n+            Some(TyFingerprint::ForeignType(type_id)) => {\n+                Some(from_foreign_def_id(type_id).module(self.db.upcast()))\n+            }\n+            Some(TyFingerprint::Dyn(trait_id)) => Some(trait_id.module(self.db.upcast())),\n+            _ => None,\n+        };\n+        let impl_maps = [\n+            Some(in_deps),\n+            Some(in_self),\n+            local_impls(self.db, trait_module),\n+            type_module.and_then(|m| local_impls(self.db, m)),\n+        ];\n \n         let id_to_chalk = |id: hir_def::ImplId| id.to_chalk(self.db);\n \n         let result: Vec<_> = if fps.is_empty() {\n             debug!(\"Unrestricted search for {:?} impls...\", trait_);\n             impl_maps\n                 .iter()\n-                .flat_map(|crate_impl_defs| crate_impl_defs.for_trait(trait_).map(id_to_chalk))\n+                .filter_map(|o| o.as_ref())\n+                .flat_map(|impls| impls.for_trait(trait_).map(id_to_chalk))\n                 .collect()\n         } else {\n             impl_maps\n                 .iter()\n-                .flat_map(|crate_impl_defs| {\n+                .filter_map(|o| o.as_ref())\n+                .flat_map(|impls| {\n                     fps.iter().flat_map(move |fp| {\n-                        crate_impl_defs.for_trait_and_self_ty(trait_, *fp).map(id_to_chalk)\n+                        impls.for_trait_and_self_ty(trait_, *fp).map(id_to_chalk)\n                     })\n                 })\n                 .collect()"}, {"sha": "b9003c413bbe92e115bdc4fdf31d27de79b9b60c", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=5ca71a19903cea277ed8a347b36cffeca6b99922", "patch": "@@ -5,8 +5,8 @@ use std::sync::Arc;\n \n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n-    db::DefDatabase, expr::ExprId, ConstParamId, DefWithBodyId, FunctionId, GenericDefId, ImplId,\n-    LifetimeParamId, LocalFieldId, TypeParamId, VariantId,\n+    db::DefDatabase, expr::ExprId, BlockId, ConstParamId, DefWithBodyId, FunctionId, GenericDefId,\n+    ImplId, LifetimeParamId, LocalFieldId, TypeParamId, VariantId,\n };\n use la_arena::ArenaMap;\n \n@@ -79,6 +79,9 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(TraitImpls::trait_impls_in_crate_query)]\n     fn trait_impls_in_crate(&self, krate: CrateId) -> Arc<TraitImpls>;\n \n+    #[salsa::invoke(TraitImpls::trait_impls_in_block_query)]\n+    fn trait_impls_in_block(&self, krate: BlockId) -> Option<Arc<TraitImpls>>;\n+\n     #[salsa::invoke(TraitImpls::trait_impls_in_deps_query)]\n     fn trait_impls_in_deps(&self, krate: CrateId) -> Arc<TraitImpls>;\n "}, {"sha": "3d233b1e20abf93a6ed726536cd2e2c580bd9bf0", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=5ca71a19903cea277ed8a347b36cffeca6b99922", "patch": "@@ -8,7 +8,7 @@ use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n-    lang_item::LangItemTarget, nameres::DefMap, AssocContainerId, AssocItemId, FunctionId,\n+    lang_item::LangItemTarget, nameres::DefMap, AssocContainerId, AssocItemId, BlockId, FunctionId,\n     GenericDefId, HasModule, ImplId, Lookup, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n@@ -139,35 +139,47 @@ impl TraitImpls {\n         let mut impls = Self { map: FxHashMap::default() };\n \n         let crate_def_map = db.crate_def_map(krate);\n-        collect_def_map(db, &crate_def_map, &mut impls);\n+        impls.collect_def_map(db, &crate_def_map);\n \n         return Arc::new(impls);\n+    }\n \n-        fn collect_def_map(db: &dyn HirDatabase, def_map: &DefMap, impls: &mut TraitImpls) {\n-            for (_module_id, module_data) in def_map.modules() {\n-                for impl_id in module_data.scope.impls() {\n-                    let target_trait = match db.impl_trait(impl_id) {\n-                        Some(tr) => tr.skip_binders().hir_trait_id(),\n-                        None => continue,\n-                    };\n-                    let self_ty = db.impl_self_ty(impl_id);\n-                    let self_ty_fp = TyFingerprint::for_trait_impl(self_ty.skip_binders());\n-                    impls\n-                        .map\n-                        .entry(target_trait)\n-                        .or_default()\n-                        .entry(self_ty_fp)\n-                        .or_default()\n-                        .push(impl_id);\n-                }\n+    pub(crate) fn trait_impls_in_block_query(\n+        db: &dyn HirDatabase,\n+        block: BlockId,\n+    ) -> Option<Arc<Self>> {\n+        let _p = profile::span(\"trait_impls_in_block_query\");\n+        let mut impls = Self { map: FxHashMap::default() };\n \n-                // To better support custom derives, collect impls in all unnamed const items.\n-                // const _: () = { ... };\n-                for konst in module_data.scope.unnamed_consts() {\n-                    let body = db.body(konst.into());\n-                    for (_, block_def_map) in body.blocks(db.upcast()) {\n-                        collect_def_map(db, &block_def_map, impls);\n-                    }\n+        let block_def_map = db.block_def_map(block)?;\n+        impls.collect_def_map(db, &block_def_map);\n+\n+        return Some(Arc::new(impls));\n+    }\n+\n+    fn collect_def_map(&mut self, db: &dyn HirDatabase, def_map: &DefMap) {\n+        for (_module_id, module_data) in def_map.modules() {\n+            for impl_id in module_data.scope.impls() {\n+                let target_trait = match db.impl_trait(impl_id) {\n+                    Some(tr) => tr.skip_binders().hir_trait_id(),\n+                    None => continue,\n+                };\n+                let self_ty = db.impl_self_ty(impl_id);\n+                let self_ty_fp = TyFingerprint::for_trait_impl(self_ty.skip_binders());\n+                self.map\n+                    .entry(target_trait)\n+                    .or_default()\n+                    .entry(self_ty_fp)\n+                    .or_default()\n+                    .push(impl_id);\n+            }\n+\n+            // To better support custom derives, collect impls in all unnamed const items.\n+            // const _: () = { ... };\n+            for konst in module_data.scope.unnamed_consts() {\n+                let body = db.body(konst.into());\n+                for (_, block_def_map) in body.blocks(db.upcast()) {\n+                    self.collect_def_map(db, &block_def_map);\n                 }\n             }\n         }"}, {"sha": "6bcede4c46a5e383983ce586ff75f28fe5d6823e", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca71a19903cea277ed8a347b36cffeca6b99922/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=5ca71a19903cea277ed8a347b36cffeca6b99922", "patch": "@@ -3740,3 +3740,70 @@ mod future {\n \"#,\n     );\n }\n+\n+#[test]\n+fn local_impl_1() {\n+    check_types(\n+        r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+}\n+\n+fn test() {\n+    struct S;\n+    impl Trait<u32> for S {\n+        fn foo(&self) { 0 }\n+    }\n+\n+    S.foo();\n+ // ^^^^^^^ u32\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn local_impl_2() {\n+    check_types(\n+        r#\"\n+struct S;\n+\n+fn test() {\n+    trait Trait<T> {\n+        fn foo(&self) -> T;\n+    }\n+    impl Trait<u32> for S {\n+        fn foo(&self) { 0 }\n+    }\n+\n+    S.foo();\n+ // ^^^^^^^ u32\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn local_impl_3() {\n+    check_types(\n+        r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+}\n+\n+fn test() {\n+    struct S1;\n+    {\n+        struct S2;\n+\n+        impl Trait<S1> for S2 {\n+            fn foo(&self) { S1 }\n+        }\n+\n+        S2.foo();\n+     // ^^^^^^^^ S1\n+    }\n+}\n+\"#,\n+    );\n+}"}]}