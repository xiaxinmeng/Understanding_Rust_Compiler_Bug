{"sha": "38814fc03900c2adceb021472027aed28b5714ed", "node_id": "C_kwDOAAsO6NoAKDM4ODE0ZmMwMzkwMGMyYWRjZWIwMjE0NzIwMjdhZWQyOGI1NzE0ZWQ", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-06-24T11:19:23Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-06-24T11:19:23Z"}, "message": "small refactor", "tree": {"sha": "e7dc15e4036f373612a5325a5de5f13fb8c050dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7dc15e4036f373612a5325a5de5f13fb8c050dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38814fc03900c2adceb021472027aed28b5714ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38814fc03900c2adceb021472027aed28b5714ed", "html_url": "https://github.com/rust-lang/rust/commit/38814fc03900c2adceb021472027aed28b5714ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38814fc03900c2adceb021472027aed28b5714ed/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e3221a927ed77e81652fafa5256335212755e60", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e3221a927ed77e81652fafa5256335212755e60", "html_url": "https://github.com/rust-lang/rust/commit/2e3221a927ed77e81652fafa5256335212755e60"}], "stats": {"total": 191, "additions": 96, "deletions": 95}, "files": [{"sha": "3f854554f4d04f8cfba1950993f8371de746a23d", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 96, "deletions": 95, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/38814fc03900c2adceb021472027aed28b5714ed/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38814fc03900c2adceb021472027aed28b5714ed/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=38814fc03900c2adceb021472027aed28b5714ed", "patch": "@@ -1,3 +1,4 @@\n+use crate::thir::cx::region::Scope;\n use crate::thir::cx::Cx;\n use crate::thir::util::UserAnnotatedTyHelpers;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -158,6 +159,100 @@ impl<'tcx> Cx<'tcx> {\n         Expr { temp_lifetime, ty: adjustment.target, span, kind }\n     }\n \n+    fn mirror_expr_cast(\n+        &mut self,\n+        source: &'tcx hir::Expr<'tcx>,\n+        temp_lifetime: Option<Scope>,\n+        span: Span,\n+    ) -> ExprKind<'tcx> {\n+        let tcx = self.tcx;\n+\n+        // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n+        // using a coercion (or is a no-op).\n+        if self.typeck_results().is_coercion_cast(source.hir_id) {\n+            // Convert the lexpr to a vexpr.\n+            ExprKind::Use { source: self.mirror_expr(source) }\n+        } else if self.typeck_results().expr_ty(source).is_region_ptr() {\n+            // Special cased so that we can type check that the element\n+            // type of the source matches the pointed to type of the\n+            // destination.\n+            ExprKind::Pointer {\n+                source: self.mirror_expr(source),\n+                cast: PointerCast::ArrayToPointer,\n+            }\n+        } else {\n+            // check whether this is casting an enum variant discriminant\n+            // to prevent cycles, we refer to the discriminant initializer\n+            // which is always an integer and thus doesn't need to know the\n+            // enum's layout (or its tag type) to compute it during const eval\n+            // Example:\n+            // enum Foo {\n+            //     A,\n+            //     B = A as isize + 4,\n+            // }\n+            // The correct solution would be to add symbolic computations to miri,\n+            // so we wouldn't have to compute and store the actual value\n+\n+            let hir::ExprKind::Path(ref qpath) = source.kind else {\n+                return ExprKind::Cast { source: self.mirror_expr(source)};\n+            };\n+\n+            let res = self.typeck_results().qpath_res(qpath, source.hir_id);\n+            let (discr_did, discr_offset, discr_ty, substs) = {\n+                let ty = self.typeck_results().node_type(source.hir_id);\n+                let ty::Adt(adt_def, substs) = ty.kind() else {\n+                    return ExprKind::Cast { source: self.mirror_expr(source)};\n+                };\n+                let Res::Def(\n+                            DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n+                            variant_ctor_id,\n+                        ) = res else {\n+                            return ExprKind::Cast { source: self.mirror_expr(source)};\n+                        };\n+\n+                let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n+                let (d, o) = adt_def.discriminant_def_for_variant(idx);\n+                use rustc_middle::ty::util::IntTypeExt;\n+                let ty = adt_def.repr().discr_type();\n+                let ty = ty.to_ty(tcx);\n+                (d, o, ty, substs)\n+            };\n+\n+            let param_env_ty = self.param_env.and(discr_ty);\n+            let size = tcx\n+                .layout_of(param_env_ty)\n+                .unwrap_or_else(|e| {\n+                    panic!(\"could not compute layout for {:?}: {:?}\", param_env_ty, e)\n+                })\n+                .size;\n+\n+            let lit = ScalarInt::try_from_uint(discr_offset as u128, size).unwrap();\n+            let kind = ExprKind::NonHirLiteral { lit, user_ty: None };\n+            let offset = self.thir.exprs.push(Expr { temp_lifetime, ty: discr_ty, span, kind });\n+\n+            let source = match discr_did {\n+                Some(did) => {\n+                    // in case we are offsetting from a computed discriminant\n+                    // and not the beginning of discriminants (which is always `0`)\n+\n+                    let kind = ExprKind::NamedConst { def_id: did, substs, user_ty: None };\n+                    let lhs =\n+                        self.thir.exprs.push(Expr { temp_lifetime, ty: discr_ty, span, kind });\n+                    let bin = ExprKind::Binary { op: BinOp::Add, lhs, rhs: offset };\n+                    self.thir.exprs.push(Expr {\n+                        temp_lifetime,\n+                        ty: discr_ty,\n+                        span: span,\n+                        kind: bin,\n+                    })\n+                }\n+                None => offset,\n+            };\n+\n+            ExprKind::Cast { source }\n+        }\n+    }\n+\n     fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n         let tcx = self.tcx;\n         let expr_ty = self.typeck_results().expr_ty(expr);\n@@ -604,101 +699,7 @@ impl<'tcx> Cx<'tcx> {\n                     expr, cast_ty.hir_id, user_ty,\n                 );\n \n-                // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n-                // using a coercion (or is a no-op).\n-                let cast = if self.typeck_results().is_coercion_cast(source.hir_id) {\n-                    // Convert the lexpr to a vexpr.\n-                    ExprKind::Use { source: self.mirror_expr(source) }\n-                } else if self.typeck_results().expr_ty(source).is_region_ptr() {\n-                    // Special cased so that we can type check that the element\n-                    // type of the source matches the pointed to type of the\n-                    // destination.\n-                    ExprKind::Pointer {\n-                        source: self.mirror_expr(source),\n-                        cast: PointerCast::ArrayToPointer,\n-                    }\n-                } else {\n-                    // check whether this is casting an enum variant discriminant\n-                    // to prevent cycles, we refer to the discriminant initializer\n-                    // which is always an integer and thus doesn't need to know the\n-                    // enum's layout (or its tag type) to compute it during const eval\n-                    // Example:\n-                    // enum Foo {\n-                    //     A,\n-                    //     B = A as isize + 4,\n-                    // }\n-                    // The correct solution would be to add symbolic computations to miri,\n-                    // so we wouldn't have to compute and store the actual value\n-                    let var = if let hir::ExprKind::Path(ref qpath) = source.kind {\n-                        let res = self.typeck_results().qpath_res(qpath, source.hir_id);\n-                        self.typeck_results().node_type(source.hir_id).ty_adt_def().and_then(\n-                            |adt_def| match res {\n-                                Res::Def(\n-                                    DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n-                                    variant_ctor_id,\n-                                ) => {\n-                                    let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n-                                    let (d, o) = adt_def.discriminant_def_for_variant(idx);\n-                                    use rustc_middle::ty::util::IntTypeExt;\n-                                    let ty = adt_def.repr().discr_type();\n-                                    let ty = ty.to_ty(tcx);\n-                                    Some((d, o, ty))\n-                                }\n-                                _ => None,\n-                            },\n-                        )\n-                    } else {\n-                        None\n-                    };\n-                    debug!(?var);\n-                    let substs = self.typeck_results.node_substs(source.hir_id);\n-                    debug!(?substs);\n-\n-                    let source = if let Some((did, offset, var_ty)) = var {\n-                        let param_env_ty = self.param_env.and(var_ty);\n-                        let size = tcx\n-                            .layout_of(param_env_ty)\n-                            .unwrap_or_else(|e| {\n-                                panic!(\"could not compute layout for {:?}: {:?}\", param_env_ty, e)\n-                            })\n-                            .size;\n-                        let lit = ScalarInt::try_from_uint(offset as u128, size).unwrap();\n-                        let kind = ExprKind::NonHirLiteral { lit, user_ty: None };\n-                        let offset = self.thir.exprs.push(Expr {\n-                            temp_lifetime,\n-                            ty: var_ty,\n-                            span: expr.span,\n-                            kind,\n-                        });\n-                        match did {\n-                            Some(did) => {\n-                                // in case we are offsetting from a computed discriminant\n-                                // and not the beginning of discriminants (which is always `0`)\n-\n-                                let kind =\n-                                    ExprKind::NamedConst { def_id: did, substs, user_ty: None };\n-                                let lhs = self.thir.exprs.push(Expr {\n-                                    temp_lifetime,\n-                                    ty: var_ty,\n-                                    span: expr.span,\n-                                    kind,\n-                                });\n-                                let bin = ExprKind::Binary { op: BinOp::Add, lhs, rhs: offset };\n-                                self.thir.exprs.push(Expr {\n-                                    temp_lifetime,\n-                                    ty: var_ty,\n-                                    span: expr.span,\n-                                    kind: bin,\n-                                })\n-                            }\n-                            None => offset,\n-                        }\n-                    } else {\n-                        self.mirror_expr(source)\n-                    };\n-\n-                    ExprKind::Cast { source: source }\n-                };\n+                let cast = self.mirror_expr_cast(*source, temp_lifetime, expr.span);\n \n                 if let Some(user_ty) = user_ty {\n                     // NOTE: Creating a new Expr and wrapping a Cast inside of it may be"}]}