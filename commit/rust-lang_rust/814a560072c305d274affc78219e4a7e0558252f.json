{"sha": "814a560072c305d274affc78219e4a7e0558252f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNGE1NjAwNzJjMzA1ZDI3NGFmZmM3ODIxOWU0YTdlMDU1ODI1MmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-29T14:57:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-29T14:57:17Z"}, "message": "Auto merge of #84233 - jyn514:track-path-prefix, r=michaelwoerister\n\nAdd TRACKED_NO_CRATE_HASH and use it for `--remap-path-prefix`\n\nI verified locally that this fixes https://github.com/rust-lang/rust/issues/66955.\n\nr? `@Aaron1011` (feel free to reassign)", "tree": {"sha": "c1aadd35d918a49e5de31c3e7293b6e8772df9c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1aadd35d918a49e5de31c3e7293b6e8772df9c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/814a560072c305d274affc78219e4a7e0558252f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/814a560072c305d274affc78219e4a7e0558252f", "html_url": "https://github.com/rust-lang/rust/commit/814a560072c305d274affc78219e4a7e0558252f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/814a560072c305d274affc78219e4a7e0558252f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10a51c0ac07ee5c5388d075c8209c8bef51069cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/10a51c0ac07ee5c5388d075c8209c8bef51069cf", "html_url": "https://github.com/rust-lang/rust/commit/10a51c0ac07ee5c5388d075c8209c8bef51069cf"}, {"sha": "5a692a7838046a53c80536f4102071010d222bf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a692a7838046a53c80536f4102071010d222bf6", "html_url": "https://github.com/rust-lang/rust/commit/5a692a7838046a53c80536f4102071010d222bf6"}], "stats": {"total": 435, "additions": 251, "deletions": 184}, "files": [{"sha": "2661afd7ffc3b32d5a72d88043863cd5664224da", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -104,7 +104,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     // Fortunately, we just checked that this isn't the case.\n     let path = dep_graph_path_from(&sess.incr_comp_session_dir());\n     let report_incremental_info = sess.opts.debugging_opts.incremental_info;\n-    let expected_hash = sess.opts.dep_tracking_hash();\n+    let expected_hash = sess.opts.dep_tracking_hash(false);\n \n     let mut prev_work_products = FxHashMap::default();\n     let nightly_build = sess.is_nightly_build();"}, {"sha": "1484088837a4be1cf03c61a5e8fc9bbb46b2c54e", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -219,7 +219,7 @@ pub fn build_dep_graph(\n     }\n \n     // First encode the commandline arguments hash\n-    if let Err(err) = sess.opts.dep_tracking_hash().encode(&mut encoder) {\n+    if let Err(err) = sess.opts.dep_tracking_hash(false).encode(&mut encoder) {\n         sess.err(&format!(\n             \"failed to write dependency graph hash `{}`: {}\",\n             path_buf.display(),"}, {"sha": "d8c1a7a26822085b60b5ec80dff19f1caea65baa", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 78, "deletions": 65, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -19,6 +19,7 @@ use rustc_span::symbol::sym;\n use rustc_span::SourceFileHashAlgorithm;\n use rustc_target::spec::{CodeModel, LinkerFlavor, MergeFunctions, PanicStrategy};\n use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, TlsModel};\n+\n use std::collections::{BTreeMap, BTreeSet};\n use std::iter::FromIterator;\n use std::num::NonZeroUsize;\n@@ -74,6 +75,27 @@ fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n     BTreeMap::from_iter(entries.into_iter())\n }\n \n+fn assert_same_clone(x: &Options) {\n+    assert_eq!(x.dep_tracking_hash(true), x.clone().dep_tracking_hash(true));\n+    assert_eq!(x.dep_tracking_hash(false), x.clone().dep_tracking_hash(false));\n+}\n+\n+fn assert_same_hash(x: &Options, y: &Options) {\n+    assert_eq!(x.dep_tracking_hash(true), y.dep_tracking_hash(true));\n+    assert_eq!(x.dep_tracking_hash(false), y.dep_tracking_hash(false));\n+    // Check clone\n+    assert_same_clone(x);\n+    assert_same_clone(y);\n+}\n+\n+fn assert_different_hash(x: &Options, y: &Options) {\n+    assert_ne!(x.dep_tracking_hash(true), y.dep_tracking_hash(true));\n+    assert_ne!(x.dep_tracking_hash(false), y.dep_tracking_hash(false));\n+    // Check clone\n+    assert_same_clone(x);\n+    assert_same_clone(y);\n+}\n+\n // When the user supplies --test we should implicitly supply --cfg test\n #[test]\n fn test_switch_implies_cfg_test() {\n@@ -130,14 +152,9 @@ fn test_output_types_tracking_hash_different_paths() {\n     v2.output_types = OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"/some/thing\")))]);\n     v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n \n-    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-    assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_different_hash(&v1, &v2);\n+    assert_different_hash(&v1, &v3);\n+    assert_different_hash(&v2, &v3);\n }\n \n #[test]\n@@ -155,10 +172,7 @@ fn test_output_types_tracking_hash_different_construction_order() {\n         (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n     ]);\n \n-    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n }\n \n #[test]\n@@ -182,14 +196,9 @@ fn test_externs_tracking_hash_different_construction_order() {\n         (String::from(\"d\"), new_public_extern_entry(vec![\"f\", \"e\"])),\n     ]));\n \n-    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-    assert_eq!(v1.dep_tracking_hash(), v3.dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v3.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n+    assert_same_hash(&v1, &v3);\n+    assert_same_hash(&v2, &v3);\n }\n \n #[test]\n@@ -219,14 +228,9 @@ fn test_lints_tracking_hash_different_values() {\n         (String::from(\"d\"), Level::Deny),\n     ];\n \n-    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-    assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_different_hash(&v1, &v2);\n+    assert_different_hash(&v1, &v3);\n+    assert_different_hash(&v2, &v3);\n }\n \n #[test]\n@@ -248,11 +252,7 @@ fn test_lints_tracking_hash_different_construction_order() {\n         (String::from(\"d\"), Level::Forbid),\n     ];\n \n-    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n }\n \n #[test]\n@@ -292,15 +292,9 @@ fn test_search_paths_tracking_hash_different_order() {\n     v4.search_paths.push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n     v4.search_paths.push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n \n-    assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() == v4.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n+    assert_same_hash(&v1, &v3);\n+    assert_same_hash(&v1, &v4);\n }\n \n #[test]\n@@ -338,15 +332,9 @@ fn test_native_libs_tracking_hash_different_values() {\n         (String::from(\"c\"), None, NativeLibKind::Unspecified),\n     ];\n \n-    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+    assert_different_hash(&v1, &v2);\n+    assert_different_hash(&v1, &v3);\n+    assert_different_hash(&v1, &v4);\n }\n \n #[test]\n@@ -374,14 +362,9 @@ fn test_native_libs_tracking_hash_different_order() {\n         (String::from(\"b\"), None, NativeLibKind::Framework),\n     ];\n \n-    assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n-    assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n-    assert!(v2.dep_tracking_hash() == v3.dep_tracking_hash());\n-\n-    // Check clone\n-    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_same_hash(&v1, &v2);\n+    assert_same_hash(&v1, &v3);\n+    assert_same_hash(&v2, &v3);\n }\n \n #[test]\n@@ -391,8 +374,9 @@ fn test_codegen_options_tracking_hash() {\n \n     macro_rules! untracked {\n         ($name: ident, $non_default_value: expr) => {\n+            assert_ne!(opts.cg.$name, $non_default_value);\n             opts.cg.$name = $non_default_value;\n-            assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+            assert_same_hash(&reference, &opts);\n         };\n     }\n \n@@ -416,8 +400,9 @@ fn test_codegen_options_tracking_hash() {\n     macro_rules! tracked {\n         ($name: ident, $non_default_value: expr) => {\n             opts = reference.clone();\n+            assert_ne!(opts.cg.$name, $non_default_value);\n             opts.cg.$name = $non_default_value;\n-            assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+            assert_different_hash(&reference, &opts);\n         };\n     }\n \n@@ -454,15 +439,42 @@ fn test_codegen_options_tracking_hash() {\n     tracked!(target_feature, String::from(\"all the features, all of them\"));\n }\n \n+#[test]\n+fn test_top_level_options_tracked_no_crate() {\n+    let reference = Options::default();\n+    let mut opts;\n+\n+    macro_rules! tracked {\n+        ($name: ident, $non_default_value: expr) => {\n+            opts = reference.clone();\n+            assert_ne!(opts.$name, $non_default_value);\n+            opts.$name = $non_default_value;\n+            // The crate hash should be the same\n+            assert_eq!(reference.dep_tracking_hash(true), opts.dep_tracking_hash(true));\n+            // The incremental hash should be different\n+            assert_ne!(reference.dep_tracking_hash(false), opts.dep_tracking_hash(false));\n+        };\n+    }\n+\n+    // Make sure that changing a [TRACKED_NO_CRATE_HASH] option leaves the crate hash unchanged but changes the incremental hash.\n+    // This list is in alphabetical order.\n+    tracked!(remap_path_prefix, vec![(\"/home/bors/rust\".into(), \"src\".into())]);\n+    tracked!(\n+        real_rust_source_base_dir,\n+        Some(\"/home/bors/rust/.rustup/toolchains/nightly/lib/rustlib/src/rust\".into())\n+    );\n+}\n+\n #[test]\n fn test_debugging_options_tracking_hash() {\n     let reference = Options::default();\n     let mut opts = Options::default();\n \n     macro_rules! untracked {\n         ($name: ident, $non_default_value: expr) => {\n+            assert_ne!(opts.debugging_opts.$name, $non_default_value);\n             opts.debugging_opts.$name = $non_default_value;\n-            assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+            assert_same_hash(&reference, &opts);\n         };\n     }\n \n@@ -471,7 +483,7 @@ fn test_debugging_options_tracking_hash() {\n     untracked!(ast_json, true);\n     untracked!(ast_json_noexpand, true);\n     untracked!(borrowck, String::from(\"other\"));\n-    untracked!(deduplicate_diagnostics, true);\n+    untracked!(deduplicate_diagnostics, false);\n     untracked!(dep_tasks, true);\n     untracked!(dont_buffer_diagnostics, true);\n     untracked!(dump_dep_graph, true);\n@@ -515,7 +527,7 @@ fn test_debugging_options_tracking_hash() {\n     untracked!(self_profile_events, Some(vec![String::new()]));\n     untracked!(span_debug, true);\n     untracked!(span_free_formats, true);\n-    untracked!(strip, Strip::None);\n+    untracked!(strip, Strip::Debuginfo);\n     untracked!(terminal_width, Some(80));\n     untracked!(threads, 99);\n     untracked!(time, true);\n@@ -532,8 +544,9 @@ fn test_debugging_options_tracking_hash() {\n     macro_rules! tracked {\n         ($name: ident, $non_default_value: expr) => {\n             opts = reference.clone();\n+            assert_ne!(opts.debugging_opts.$name, $non_default_value);\n             opts.debugging_opts.$name = $non_default_value;\n-            assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+            assert_different_hash(&reference, &opts);\n         };\n     }\n "}, {"sha": "2ade1bb4f95de29ca3233568c7a289a6f82e0ffe", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -1617,7 +1617,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .map(Path::new)\n             .filter(|_| {\n                 // Only spend time on further checks if we have what to translate *to*.\n-                sess.real_rust_source_base_dir.is_some()\n+                sess.opts.real_rust_source_base_dir.is_some()\n             })\n             .filter(|virtual_dir| {\n                 // Don't translate away `/rustc/$hash` if we're still remapping to it,\n@@ -1629,11 +1629,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             debug!(\n                 \"try_to_translate_virtual_to_real(name={:?}): \\\n                  virtual_rust_source_base_dir={:?}, real_rust_source_base_dir={:?}\",\n-                name, virtual_rust_source_base_dir, sess.real_rust_source_base_dir,\n+                name, virtual_rust_source_base_dir, sess.opts.real_rust_source_base_dir,\n             );\n \n             if let Some(virtual_dir) = virtual_rust_source_base_dir {\n-                if let Some(real_dir) = &sess.real_rust_source_base_dir {\n+                if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n                     if let rustc_span::FileName::Real(old_name) = name {\n                         if let rustc_span::RealFileName::Named(one_path) = old_name {\n                             if let Ok(rest) = one_path.strip_prefix(virtual_dir) {"}, {"sha": "4cd126988f91f3aec5bad20945f7a7e4c06fb587", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -943,7 +943,7 @@ pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> &'tcx Indexe\n         intravisit::walk_crate(&mut collector, tcx.untracked_crate);\n \n         let crate_disambiguator = tcx.sess.local_crate_disambiguator();\n-        let cmdline_args = tcx.sess.opts.dep_tracking_hash();\n+        let cmdline_args = tcx.sess.opts.dep_tracking_hash(true);\n         collector.finalize_and_compute_crate_hash(crate_disambiguator, &*tcx.cstore, cmdline_args)\n     };\n "}, {"sha": "1f5cb5b8abc8c0c9a39d0552b241a26e53efbb8c", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -156,7 +156,7 @@ pub enum InstrumentCoverage {\n     Off,\n }\n \n-#[derive(Clone, PartialEq, Hash)]\n+#[derive(Clone, PartialEq, Hash, Debug)]\n pub enum LinkerPluginLto {\n     LinkerPlugin(PathBuf),\n     LinkerPluginAuto,\n@@ -172,7 +172,7 @@ impl LinkerPluginLto {\n     }\n }\n \n-#[derive(Clone, PartialEq, Hash)]\n+#[derive(Clone, PartialEq, Hash, Debug)]\n pub enum SwitchWithOptPath {\n     Enabled(Option<PathBuf>),\n     Disabled,\n@@ -702,6 +702,7 @@ impl Default for Options {\n             cli_forced_codegen_units: None,\n             cli_forced_thinlto_off: false,\n             remap_path_prefix: Vec::new(),\n+            real_rust_source_base_dir: None,\n             edition: DEFAULT_EDITION,\n             json_artifact_notifications: false,\n             json_unused_externs: false,\n@@ -778,7 +779,7 @@ pub enum CrateType {\n \n impl_stable_hash_via_hash!(CrateType);\n \n-#[derive(Clone, Hash)]\n+#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n pub enum Passes {\n     Some(Vec<String>),\n     All,\n@@ -1980,6 +1981,34 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n     }\n \n+    // Try to find a directory containing the Rust `src`, for more details see\n+    // the doc comment on the `real_rust_source_base_dir` field.\n+    let tmp_buf;\n+    let sysroot = match &sysroot_opt {\n+        Some(s) => s,\n+        None => {\n+            tmp_buf = crate::filesearch::get_or_default_sysroot();\n+            &tmp_buf\n+        }\n+    };\n+    let real_rust_source_base_dir = {\n+        // This is the location used by the `rust-src` `rustup` component.\n+        let mut candidate = sysroot.join(\"lib/rustlib/src/rust\");\n+        if let Ok(metadata) = candidate.symlink_metadata() {\n+            // Replace the symlink rustbuild creates, with its destination.\n+            // We could try to use `fs::canonicalize` instead, but that might\n+            // produce unnecessarily verbose path.\n+            if metadata.file_type().is_symlink() {\n+                if let Ok(symlink_dest) = std::fs::read_link(&candidate) {\n+                    candidate = symlink_dest;\n+                }\n+            }\n+        }\n+\n+        // Only use this directory if it has a file we can expect to always find.\n+        if candidate.join(\"library/std/src/lib.rs\").is_file() { Some(candidate) } else { None }\n+    };\n+\n     Options {\n         crate_types,\n         optimize: opt_level,\n@@ -2010,6 +2039,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         cli_forced_codegen_units: codegen_units,\n         cli_forced_thinlto_off: disable_thinlto,\n         remap_path_prefix,\n+        real_rust_source_base_dir,\n         edition,\n         json_artifact_notifications,\n         json_unused_externs,\n@@ -2374,6 +2404,7 @@ crate mod dep_tracking {\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n+    impl_dep_tracking_hash_for_sortable_vec_of!((PathBuf, PathBuf));\n     impl_dep_tracking_hash_for_sortable_vec_of!(CrateType);\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, lint::Level));\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, Option<String>, NativeLibKind));"}, {"sha": "1c2a7f7716d2176f954653ca4e087fee475afb6b", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 127, "deletions": 77, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -20,73 +20,112 @@ use std::num::NonZeroUsize;\n use std::path::PathBuf;\n use std::str;\n \n-macro_rules! hash_option {\n-    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => {{}};\n-    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => {{\n+macro_rules! insert {\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr) => {\n         if $sub_hashes\n             .insert(stringify!($opt_name), $opt_expr as &dyn dep_tracking::DepTrackingHash)\n             .is_some()\n         {\n             panic!(\"duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n         }\n+    };\n+}\n+\n+macro_rules! hash_opt {\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, $_for_crate_hash: ident, [UNTRACKED]) => {{}};\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, $_for_crate_hash: ident, [TRACKED]) => {{ insert!($opt_name, $opt_expr, $sub_hashes) }};\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, $for_crate_hash: ident, [TRACKED_NO_CRATE_HASH]) => {{\n+        if !$for_crate_hash {\n+            insert!($opt_name, $opt_expr, $sub_hashes)\n+        }\n     }};\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, $_for_crate_hash: ident, [SUBSTRUCT]) => {{}};\n+}\n+\n+macro_rules! hash_substruct {\n+    ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [UNTRACKED]) => {{}};\n+    ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [TRACKED]) => {{}};\n+    ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [TRACKED_NO_CRATE_HASH]) => {{}};\n+    ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [SUBSTRUCT]) => {\n+        use crate::config::dep_tracking::DepTrackingHash;\n+        $opt_expr.dep_tracking_hash($for_crate_hash, $error_format).hash($hasher, $error_format);\n+    };\n }\n \n macro_rules! top_level_options {\n-    (pub struct Options { $(\n-        $opt:ident : $t:ty [$dep_tracking_marker:ident $($warn_val:expr, $warn_text:expr)*],\n+    ( $( #[$top_level_attr:meta] )* pub struct Options { $(\n+        $( #[$attr:meta] )*\n+        $opt:ident : $t:ty [$dep_tracking_marker:ident],\n     )* } ) => (\n         #[derive(Clone)]\n+        $( #[$top_level_attr] )*\n         pub struct Options {\n-            $(pub $opt: $t),*\n+            $(\n+                $( #[$attr] )*\n+                pub $opt: $t\n+            ),*\n         }\n \n         impl Options {\n-            pub fn dep_tracking_hash(&self) -> u64 {\n+            pub fn dep_tracking_hash(&self, for_crate_hash: bool) -> u64 {\n                 let mut sub_hashes = BTreeMap::new();\n                 $({\n-                    hash_option!($opt,\n-                                 &self.$opt,\n-                                 &mut sub_hashes,\n-                                 [$dep_tracking_marker $($warn_val,\n-                                                         $warn_text,\n-                                                         self.error_format)*]);\n+                    hash_opt!($opt,\n+                                &self.$opt,\n+                                &mut sub_hashes,\n+                                for_crate_hash,\n+                                [$dep_tracking_marker]);\n                 })*\n                 let mut hasher = DefaultHasher::new();\n                 dep_tracking::stable_hash(sub_hashes,\n                                           &mut hasher,\n                                           self.error_format);\n+                $({\n+                    hash_substruct!($opt,\n+                        &self.$opt,\n+                        self.error_format,\n+                        for_crate_hash,\n+                        &mut hasher,\n+                        [$dep_tracking_marker]);\n+                })*\n                 hasher.finish()\n             }\n         }\n     );\n }\n \n-// The top-level command-line options struct.\n-//\n-// For each option, one has to specify how it behaves with regard to the\n-// dependency tracking system of incremental compilation. This is done via the\n-// square-bracketed directive after the field type. The options are:\n-//\n-// [TRACKED]\n-// A change in the given field will cause the compiler to completely clear the\n-// incremental compilation cache before proceeding.\n-//\n-// [UNTRACKED]\n-// Incremental compilation is not influenced by this option.\n-//\n-// If you add a new option to this struct or one of the sub-structs like\n-// `CodegenOptions`, think about how it influences incremental compilation. If in\n-// doubt, specify [TRACKED], which is always \"correct\" but might lead to\n-// unnecessary re-compilation.\n top_level_options!(\n+    /// The top-level command-line options struct.\n+    ///\n+    /// For each option, one has to specify how it behaves with regard to the\n+    /// dependency tracking system of incremental compilation. This is done via the\n+    /// square-bracketed directive after the field type. The options are:\n+    ///\n+    /// - `[TRACKED]`\n+    /// A change in the given field will cause the compiler to completely clear the\n+    /// incremental compilation cache before proceeding.\n+    ///\n+    /// - `[TRACKED_NO_CRATE_HASH]`\n+    /// Same as `[TRACKED]`, but will not affect the crate hash. This is useful for options that only\n+    /// affect the incremental cache.\n+    ///\n+    /// - `[UNTRACKED]`\n+    /// Incremental compilation is not influenced by this option.\n+    ///\n+    /// - `[SUBSTRUCT]`\n+    /// Second-level sub-structs containing more options.\n+    ///\n+    /// If you add a new option to this struct or one of the sub-structs like\n+    /// `CodegenOptions`, think about how it influences incremental compilation. If in\n+    /// doubt, specify `[TRACKED]`, which is always \"correct\" but might lead to\n+    /// unnecessary re-compilation.\n     pub struct Options {\n-        // The crate config requested for the session, which may be combined\n-        // with additional crate configurations during the compile process.\n+        /// The crate config requested for the session, which may be combined\n+        /// with additional crate configurations during the compile process.\n         crate_types: Vec<CrateType> [TRACKED],\n         optimize: OptLevel [TRACKED],\n-        // Include the `debug_assertions` flag in dependency tracking, since it\n-        // can influence whether overflow checks are done or not.\n+        /// Include the `debug_assertions` flag in dependency tracking, since it\n+        /// can influence whether overflow checks are done or not.\n         debug_assertions: bool [TRACKED],\n         debuginfo: DebugInfo [TRACKED],\n         lint_opts: Vec<(String, lint::Level)> [TRACKED],\n@@ -102,52 +141,60 @@ top_level_options!(\n         test: bool [TRACKED],\n         error_format: ErrorOutputType [UNTRACKED],\n \n-        // If `Some`, enable incremental compilation, using the given\n-        // directory to store intermediate results.\n+        /// If `Some`, enable incremental compilation, using the given\n+        /// directory to store intermediate results.\n         incremental: Option<PathBuf> [UNTRACKED],\n \n-        debugging_opts: DebuggingOptions [TRACKED],\n+        debugging_opts: DebuggingOptions [SUBSTRUCT],\n         prints: Vec<PrintRequest> [UNTRACKED],\n-        // Determines which borrow checker(s) to run. This is the parsed, sanitized\n-        // version of `debugging_opts.borrowck`, which is just a plain string.\n+        /// Determines which borrow checker(s) to run. This is the parsed, sanitized\n+        /// version of `debugging_opts.borrowck`, which is just a plain string.\n         borrowck_mode: BorrowckMode [UNTRACKED],\n-        cg: CodegenOptions [TRACKED],\n+        cg: CodegenOptions [SUBSTRUCT],\n         externs: Externs [UNTRACKED],\n         extern_dep_specs: ExternDepSpecs [UNTRACKED],\n         crate_name: Option<String> [TRACKED],\n-        // An optional name to use as the crate for std during std injection,\n-        // written `extern crate name as std`. Defaults to `std`. Used by\n-        // out-of-tree drivers.\n+        /// An optional name to use as the crate for std during std injection,\n+        /// written `extern crate name as std`. Defaults to `std`. Used by\n+        /// out-of-tree drivers.\n         alt_std_name: Option<String> [TRACKED],\n-        // Indicates how the compiler should treat unstable features.\n+        /// Indicates how the compiler should treat unstable features.\n         unstable_features: UnstableFeatures [TRACKED],\n \n-        // Indicates whether this run of the compiler is actually rustdoc. This\n-        // is currently just a hack and will be removed eventually, so please\n-        // try to not rely on this too much.\n+        /// Indicates whether this run of the compiler is actually rustdoc. This\n+        /// is currently just a hack and will be removed eventually, so please\n+        /// try to not rely on this too much.\n         actually_rustdoc: bool [TRACKED],\n \n-        // Control path trimming.\n+        /// Control path trimming.\n         trimmed_def_paths: TrimmedDefPaths [TRACKED],\n \n-        // Specifications of codegen units / ThinLTO which are forced as a\n-        // result of parsing command line options. These are not necessarily\n-        // what rustc was invoked with, but massaged a bit to agree with\n-        // commands like `--emit llvm-ir` which they're often incompatible with\n-        // if we otherwise use the defaults of rustc.\n+        /// Specifications of codegen units / ThinLTO which are forced as a\n+        /// result of parsing command line options. These are not necessarily\n+        /// what rustc was invoked with, but massaged a bit to agree with\n+        /// commands like `--emit llvm-ir` which they're often incompatible with\n+        /// if we otherwise use the defaults of rustc.\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n         cli_forced_thinlto_off: bool [UNTRACKED],\n \n-        // Remap source path prefixes in all output (messages, object files, debug, etc.).\n-        remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n+        /// Remap source path prefixes in all output (messages, object files, debug, etc.).\n+        remap_path_prefix: Vec<(PathBuf, PathBuf)> [TRACKED_NO_CRATE_HASH],\n+        /// Base directory containing the `src/` for the Rust standard library, and\n+        /// potentially `rustc` as well, if we can can find it. Right now it's always\n+        /// `$sysroot/lib/rustlib/src/rust` (i.e. the `rustup` `rust-src` component).\n+        ///\n+        /// This directory is what the virtual `/rustc/$hash` is translated back to,\n+        /// if Rust was built with path remapping to `/rustc/$hash` enabled\n+        /// (the `rust.remap-debuginfo` option in `config.toml`).\n+        real_rust_source_base_dir: Option<PathBuf> [TRACKED_NO_CRATE_HASH],\n \n         edition: Edition [TRACKED],\n \n-        // `true` if we're emitting JSON blobs about each artifact produced\n-        // by the compiler.\n+        /// `true` if we're emitting JSON blobs about each artifact produced\n+        /// by the compiler.\n         json_artifact_notifications: bool [TRACKED],\n \n-        // `true` if we're emitting a JSON blob containing the unused externs\n+        /// `true` if we're emitting a JSON blob containing the unused externs\n         json_unused_externs: bool [UNTRACKED],\n \n         pretty: Option<PpMode> [UNTRACKED],\n@@ -166,18 +213,18 @@ macro_rules! options {\n     ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n      $buildfn:ident, $prefix:expr, $outputname:expr,\n      $stat:ident, $mod_desc:ident, $mod_set:ident,\n-     $($opt:ident : $t:ty = (\n+     $($( #[$attr:meta] )* $opt:ident : $t:ty = (\n         $init:expr,\n         $parse:ident,\n-        [$dep_tracking_marker:ident $(($dep_warn_val:expr, $dep_warn_text:expr))*],\n+        [$dep_tracking_marker:ident],\n         $desc:expr)\n      ),* ,) =>\n (\n     #[derive(Clone)]\n     pub struct $struct_name { $(pub $opt: $t),* }\n \n     pub fn $defaultfn() -> $struct_name {\n-        $struct_name { $($opt: $init),* }\n+        $struct_name { $( $( #[$attr] )* $opt: $init),* }\n     }\n \n     pub fn $buildfn(matches: &getopts::Matches, error_format: ErrorOutputType) -> $struct_name\n@@ -219,18 +266,21 @@ macro_rules! options {\n         return op;\n     }\n \n-    impl dep_tracking::DepTrackingHash for $struct_name {\n-        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+    impl $struct_name {\n+        fn dep_tracking_hash(&self, _for_crate_hash: bool, error_format: ErrorOutputType) -> u64 {\n             let mut sub_hashes = BTreeMap::new();\n             $({\n-                hash_option!($opt,\n-                             &self.$opt,\n-                             &mut sub_hashes,\n-                             [$dep_tracking_marker $($dep_warn_val,\n-                                                     $dep_warn_text,\n-                                                     error_format)*]);\n+                hash_opt!($opt,\n+                            &self.$opt,\n+                            &mut sub_hashes,\n+                            _for_crate_hash,\n+                            [$dep_tracking_marker]);\n             })*\n-            dep_tracking::stable_hash(sub_hashes, hasher, error_format);\n+            let mut hasher = DefaultHasher::new();\n+            dep_tracking::stable_hash(sub_hashes,\n+                                        &mut hasher,\n+                                        error_format);\n+            hasher.finish()\n         }\n     }\n \n@@ -1128,7 +1178,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n         parse_switch_with_opt_path, [UNTRACKED],\n         \"run the self profiler and output the raw event data\"),\n-    // keep this in sync with the event filter names in librustc_data_structures/profiling.rs\n+    /// keep this in sync with the event filter names in librustc_data_structures/profiling.rs\n     self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n         \"specify the events recorded by the self profiler;\n         for example: `-Z self-profile-events=default,query-keys`\n@@ -1140,7 +1190,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"show spans for compiler debugging (expr|pat|ty)\"),\n     span_debug: bool = (false, parse_bool, [UNTRACKED],\n         \"forward proc_macro::Span's `Debug` impl to `Span`\"),\n-    // o/w tests have closure@path\n+    /// o/w tests have closure@path\n     span_free_formats: bool = (false, parse_bool, [UNTRACKED],\n         \"exclude spans when debug-printing compiler state (default: no)\"),\n     src_hash_algorithm: Option<SourceFileHashAlgorithm> = (None, parse_src_file_hash, [TRACKED],\n@@ -1161,10 +1211,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"select processor to schedule for (`rustc --print target-cpus` for details)\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n-    // We default to 1 here since we want to behave like\n-    // a sequential compiler for now. This'll likely be adjusted\n-    // in the future. Note that -Zthreads=0 is the way to get\n-    // the num_cpus behavior.\n+    /// We default to 1 here since we want to behave like\n+    /// a sequential compiler for now. This'll likely be adjusted\n+    /// in the future. Note that -Zthreads=0 is the way to get\n+    /// the num_cpus behavior.\n     threads: usize = (1, parse_threads, [UNTRACKED],\n         \"use a thread pool with N threads\"),\n     time: bool = (false, parse_bool, [UNTRACKED],\n@@ -1220,7 +1270,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     // - compiler/rustc_interface/src/tests.rs\n }\n \n-#[derive(Clone, Hash)]\n+#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n pub enum WasiExecModel {\n     Command,\n     Reactor,"}, {"sha": "e7dfc4b8c4128335042d63ae4fe2ca5ea380cc92", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -214,15 +214,6 @@ pub struct Session {\n     /// drown everything else in noise.\n     miri_unleashed_features: Lock<Vec<(Span, Option<Symbol>)>>,\n \n-    /// Base directory containing the `src/` for the Rust standard library, and\n-    /// potentially `rustc` as well, if we can can find it. Right now it's always\n-    /// `$sysroot/lib/rustlib/src/rust` (i.e. the `rustup` `rust-src` component).\n-    ///\n-    /// This directory is what the virtual `/rustc/$hash` is translated back to,\n-    /// if Rust was built with path remapping to `/rustc/$hash` enabled\n-    /// (the `rust.remap-debuginfo` option in `config.toml`).\n-    pub real_rust_source_base_dir: Option<PathBuf>,\n-\n     /// Architecture to use for interpreting asm!.\n     pub asm_arch: Option<InlineAsmArch>,\n \n@@ -1390,26 +1381,6 @@ pub fn build_session(\n         _ => CtfeBacktrace::Disabled,\n     });\n \n-    // Try to find a directory containing the Rust `src`, for more details see\n-    // the doc comment on the `real_rust_source_base_dir` field.\n-    let real_rust_source_base_dir = {\n-        // This is the location used by the `rust-src` `rustup` component.\n-        let mut candidate = sysroot.join(\"lib/rustlib/src/rust\");\n-        if let Ok(metadata) = candidate.symlink_metadata() {\n-            // Replace the symlink rustbuild creates, with its destination.\n-            // We could try to use `fs::canonicalize` instead, but that might\n-            // produce unnecessarily verbose path.\n-            if metadata.file_type().is_symlink() {\n-                if let Ok(symlink_dest) = std::fs::read_link(&candidate) {\n-                    candidate = symlink_dest;\n-                }\n-            }\n-        }\n-\n-        // Only use this directory if it has a file we can expect to always find.\n-        if candidate.join(\"library/std/src/lib.rs\").is_file() { Some(candidate) } else { None }\n-    };\n-\n     let asm_arch =\n         if target_cfg.allow_asm { InlineAsmArch::from_str(&target_cfg.arch).ok() } else { None };\n \n@@ -1453,7 +1424,6 @@ pub fn build_session(\n         system_library_path: OneThread::new(RefCell::new(Default::default())),\n         ctfe_backtrace,\n         miri_unleashed_features: Lock::new(Default::default()),\n-        real_rust_source_base_dir,\n         asm_arch,\n         target_features: FxHashSet::default(),\n         known_attrs: Lock::new(MarkedAttrs::new()),"}, {"sha": "35b7183db7fac4f19fae1bb96ba5c97a81e9e595", "filename": "src/test/incremental/commandline-args.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/src%2Ftest%2Fincremental%2Fcommandline-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/src%2Ftest%2Fincremental%2Fcommandline-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcommandline-args.rs?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -2,20 +2,23 @@\n // the cache while changing an untracked one doesn't.\n \n // ignore-asmjs wasm2js does not support source maps yet\n-// revisions:rpass1 rpass2 rpass3\n+// revisions:rpass1 rpass2 rpass3 rpass4\n // compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n \n #![rustc_partition_codegened(module=\"commandline_args\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"commandline_args\", cfg=\"rpass3\")]\n+#![rustc_partition_codegened(module=\"commandline_args\", cfg=\"rpass4\")]\n \n // Between revisions 1 and 2, we are changing the debuginfo-level, which should\n // invalidate the cache. Between revisions 2 and 3, we are adding `--verbose`\n-// which should have no effect on the cache:\n+// which should have no effect on the cache. Between revisions, we are adding\n+// `--remap-path-prefix` which should invalidate the cache:\n //[rpass1] compile-flags: -C debuginfo=0\n //[rpass2] compile-flags: -C debuginfo=2\n //[rpass3] compile-flags: -C debuginfo=2 --verbose\n+//[rpass4] compile-flags: -C debuginfo=2 --verbose --remap-path-prefix=/home/bors/rust=src\n \n pub fn main() {\n     // empty"}, {"sha": "371f94715a8c1623b18bd7f2e82a6fa82e67db04", "filename": "src/test/run-make-fulldeps/incr-add-rust-src-component/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814a560072c305d274affc78219e4a7e0558252f/src%2Ftest%2Frun-make-fulldeps%2Fincr-add-rust-src-component%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/814a560072c305d274affc78219e4a7e0558252f/src%2Ftest%2Frun-make-fulldeps%2Fincr-add-rust-src-component%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fincr-add-rust-src-component%2FMakefile?ref=814a560072c305d274affc78219e4a7e0558252f", "patch": "@@ -1,7 +1,7 @@\n -include ../tools.mk\n \n # rust-lang/rust#70924: Test that if we add rust-src component in between two\n-# incremetnal compiles, the compiler does not ICE on the second.\n+# incremental compiles, the compiler does not ICE on the second.\n \n # This test uses `ln -s` rather than copying to save testing time, but its\n # usage doesn't work on windows. So ignore windows."}]}