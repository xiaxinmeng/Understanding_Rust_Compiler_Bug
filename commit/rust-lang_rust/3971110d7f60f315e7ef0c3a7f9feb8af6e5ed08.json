{"sha": "3971110d7f60f315e7ef0c3a7f9feb8af6e5ed08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NzExMTBkN2Y2MGYzMTVlN2VmMGMzYTdmOWZlYjhhZjZlNWVkMDg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-01T23:04:22Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-01T23:04:22Z"}, "message": "Guh. Actually commit the staged undo-of-indentation. Forgotten git staging wins again.", "tree": {"sha": "146642f0762cf6f24b7bae82bb5a1b28c24f707e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/146642f0762cf6f24b7bae82bb5a1b28c24f707e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3971110d7f60f315e7ef0c3a7f9feb8af6e5ed08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3971110d7f60f315e7ef0c3a7f9feb8af6e5ed08", "html_url": "https://github.com/rust-lang/rust/commit/3971110d7f60f315e7ef0c3a7f9feb8af6e5ed08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3971110d7f60f315e7ef0c3a7f9feb8af6e5ed08/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9", "html_url": "https://github.com/rust-lang/rust/commit/7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9"}], "stats": {"total": 112, "additions": 56, "deletions": 56}, "files": [{"sha": "e9695b3508a90ec791ae965daf5cd262f11a55ab", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/3971110d7f60f315e7ef0c3a7f9feb8af6e5ed08/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3971110d7f60f315e7ef0c3a7f9feb8af6e5ed08/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3971110d7f60f315e7ef0c3a7f9feb8af6e5ed08", "patch": "@@ -161,7 +161,7 @@ fn sep() -> str {\n }\n \n fn extend_path(@crate_ctxt cx, str name) -> @crate_ctxt {\n-    ret @rec(path = cx.path + vec(name) with *cx);\n+  ret @rec(path = cx.path + vec(name) with *cx);\n }\n \n fn path_name(vec[str] path) -> str {\n@@ -529,7 +529,7 @@ fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n }\n \n fn type_of_explicit_args(@crate_ctxt cx,\n-                         vec[ty.arg] inputs) -> vec[TypeRef] {\n+                     vec[ty.arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = vec();\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(arg.ty)) {\n@@ -765,7 +765,7 @@ fn type_of_arg(@crate_ctxt cx, &ty.arg arg) -> TypeRef {\n }\n \n fn type_of_ty_params_opt_and_ty(@crate_ctxt ccx, ty.ty_params_opt_and_ty tpt)\n-    -> TypeRef {\n+        -> TypeRef {\n     alt (tpt._1.struct) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             auto ty_params = option.get[vec[ast.def_id]](tpt._0);\n@@ -914,7 +914,7 @@ fn decl_fastcall_fn(ModuleRef llmod, str name, TypeRef llty) -> ValueRef {\n }\n \n fn decl_internal_fastcall_fn(ModuleRef llmod,\n-                             str name, TypeRef llty) -> ValueRef {\n+                            str name, TypeRef llty) -> ValueRef {\n     auto llfn = decl_fn(llmod, name, lib.llvm.LLVMFastCallConv, llty);\n     llvm.LLVMSetLinkage(llfn, lib.llvm.LLVMInternalLinkage as llvm.Linkage);\n     ret llfn;\n@@ -963,7 +963,7 @@ fn get_extern_const(&hashmap[str, ValueRef] externs,\n }\n \n fn get_simple_extern_fn(&hashmap[str, ValueRef] externs,\n-                        ModuleRef llmod, str name, int n_args) -> ValueRef {\n+                     ModuleRef llmod, str name, int n_args) -> ValueRef {\n     auto inputs = _vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n     auto t = T_fn(inputs, output);\n@@ -1361,7 +1361,7 @@ fn GEP_tag(@block_ctxt cx,\n            &ast.def_id variant_id,\n            vec[@ty.t] ty_substs,\n            int ix)\n-    -> result {\n+        -> result {\n     auto ty_params = tag_ty_params(cx.fcx.ccx, tag_id);\n     auto variant = tag_variant_with_id(cx.fcx.ccx, tag_id, variant_id);\n \n@@ -1410,7 +1410,7 @@ fn GEP_tag(@block_ctxt cx,\n \n \n fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n-    -> result {\n+        -> result {\n     // FIXME: need a table to collect tydesc globals.\n     auto tydesc = C_int(0);\n     auto rslt = trans_upcall(cx, \"upcall_malloc\", vec(llsize, tydesc));\n@@ -1600,10 +1600,10 @@ fn declare_tydesc(@crate_ctxt cx, @ty.t t) {\n                         as llvm.Linkage);\n \n     auto info = rec(\n-                    tydesc=gvar,\n-                    take_glue=take_glue,\n-                    drop_glue=drop_glue\n-                    );\n+        tydesc=gvar,\n+        take_glue=take_glue,\n+        drop_glue=drop_glue\n+    );\n \n     cx.tydescs.insert(t, @info);\n }\n@@ -2098,17 +2098,17 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                                 auto v = vec(C_int(0), C_int(j as int));\n \n                                 auto rslt = GEP_tag(variant_cx, llunion_a_ptr,\n-                                                    tid, variant.id, tps, j);\n+                                    tid, variant.id, tps, j);\n                                 auto llfldp_a = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n                                 rslt = GEP_tag(variant_cx, llunion_b_ptr, tid,\n-                                               variant.id, tps, j);\n+                                    variant.id, tps, j);\n                                 auto llfldp_b = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n                                 auto ty_subst = ty.substitute_ty_params(\n-                                                                        ty_params, tps, a.ty);\n+                                    ty_params, tps, a.ty);\n \n                                 auto llfld_a =\n                                     load_scalar_or_boxed(variant_cx,\n@@ -2330,8 +2330,8 @@ fn call_tydesc_glue(@block_ctxt cx, ValueRef v, @ty.t t, int field) {\n }\n \n fn take_ty(@block_ctxt cx,\n-           ValueRef v,\n-           @ty.t t) -> result {\n+                    ValueRef v,\n+                    @ty.t t) -> result {\n     if (!ty.type_is_scalar(t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_take_glue_off);\n     }\n@@ -3163,11 +3163,11 @@ fn trans_for(@block_ctxt cx,\n // Searches through a block for all references to locals or upvars in this\n // frame and returns the list of definition IDs thus found.\n fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n-    -> vec[ast.def_id] {\n+        -> vec[ast.def_id] {\n     type env = @rec(\n-                    mutable vec[ast.def_id] refs,\n-                    hashmap[ast.def_id,()] decls\n-                    );\n+        mutable vec[ast.def_id] refs,\n+        hashmap[ast.def_id,()] decls\n+    );\n \n     fn fold_expr_path(&env e, &common.span sp, &ast.path p,\n                       &option.t[ast.def] d, ast.ann a) -> @ast.expr {\n@@ -3182,18 +3182,18 @@ fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n     }\n \n     fn fold_decl_local(&env e, &common.span sp, @ast.local local)\n-        -> @ast.decl {\n+            -> @ast.decl {\n         e.decls.insert(local.id, ());\n         ret @fold.respan[ast.decl_](sp, ast.decl_local(local));\n     }\n \n     auto fep = fold_expr_path;\n     auto fdl = fold_decl_local;\n     auto fld = @rec(\n-                    fold_expr_path=fep,\n-                    fold_decl_local=fdl\n-                    with *fold.new_identity_fold[env]()\n-                    );\n+        fold_expr_path=fep,\n+        fold_decl_local=fdl\n+        with *fold.new_identity_fold[env]()\n+    );\n \n     let vec[ast.def_id] refs = vec();\n     let hashmap[ast.def_id,()] decls = new_def_hash[()]();\n@@ -3320,7 +3320,7 @@ fn trans_for_each(@block_ctxt cx,\n                                           plain_ty(ty.ty_nil), 0u);\n \n     let ValueRef lliterbody = decl_internal_fastcall_fn(cx.fcx.ccx.llmod,\n-                                                        s, iter_body_llty);\n+                                                       s, iter_body_llty);\n \n     // FIXME: handle ty params properly.\n     let vec[ast.ty_param] ty_params = vec();\n@@ -3332,7 +3332,7 @@ fn trans_for_each(@block_ctxt cx,\n     // Populate the upvars from the environment.\n     auto llremoteenvptr = bcx.build.PointerCast(fcx.llenv, llenvptrty);\n     auto llremotebindingsptrptr = bcx.build.GEP(llremoteenvptr,\n-                                                vec(C_int(0), C_int(abi.box_rc_field_body), C_int(2)));\n+        vec(C_int(0), C_int(abi.box_rc_field_body), C_int(2)));\n     auto llremotebindingsptr = bcx.build.Load(llremotebindingsptrptr);\n \n     auto i = 0u;\n@@ -3377,7 +3377,7 @@ fn trans_for_each(@block_ctxt cx,\n             auto env_cell = cx.build.GEP(pair, vec(C_int(0),\n                                                    C_int(abi.fn_field_box)));\n             auto llenvblobptr = cx.build.PointerCast(llenvptr,\n-                                                     T_opaque_closure_ptr(cx.fcx.ccx.tn));\n+                T_opaque_closure_ptr(cx.fcx.ccx.tn));\n             cx.build.Store(llenvblobptr, env_cell);\n \n             // log \"lliterbody: \" + val_str(cx.fcx.ccx.tn, lliterbody);\n@@ -3448,7 +3448,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n \n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n             auto lltagptr = cx.build.PointerCast(llval,\n-                                                 T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n \n             auto lldiscrimptr = cx.build.GEP(lltagptr,\n                                              vec(C_int(0), C_int(0)));\n@@ -3479,7 +3479,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n \n             if (_vec.len[@ast.pat](subpats) > 0u) {\n                 auto llblobptr = matched_cx.build.GEP(lltagptr,\n-                                                      vec(C_int(0), C_int(1)));\n+                    vec(C_int(0), C_int(1)));\n                 auto i = 0;\n                 for (@ast.pat subpat in subpats) {\n                     auto rslt = GEP_tag(matched_cx, llblobptr, vdef._0,\n@@ -3529,7 +3529,7 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n             auto vdef = option.get[ast.variant_def](vdef_opt);\n \n             auto lltagptr = cx.build.PointerCast(llval,\n-                                                 T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n             auto llblobptr = cx.build.GEP(lltagptr, vec(C_int(0), C_int(1)));\n \n             auto ty_param_substs = node_ann_ty_params(ann);\n@@ -3625,7 +3625,7 @@ fn lval_generic_fn(@block_ctxt cx,\n                    ty.ty_params_and_ty tpt,\n                    ast.def_id fn_id,\n                    &ast.ann ann)\n-    -> lval_result {\n+        -> lval_result {\n     auto lv;\n     if (cx.fcx.ccx.sess.get_targ_crate_num() == fn_id._0) {\n         // Internal reference.\n@@ -3704,12 +3704,12 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_fn(?did)) {\n                     auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n-                                                           cx.fcx.ccx.type_cache, did);\n+                        cx.fcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_obj(?did)) {\n                     auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n-                                                           cx.fcx.ccx.type_cache, did);\n+                        cx.fcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n@@ -3746,10 +3746,10 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                             lltagty = type_of(cx.fcx.ccx, tag_ty);\n                         }\n                         auto lltagptr = alloc_result.bcx.build.PointerCast(\n-                                                                           lltagblob, T_ptr(lltagty));\n+                            lltagblob, T_ptr(lltagty));\n \n                         auto lldiscrimptr = alloc_result.bcx.build.GEP(\n-                                                                       lltagptr, vec(C_int(0), C_int(0)));\n+                            lltagptr, vec(C_int(0), C_int(0)));\n                         alloc_result.bcx.build.Store(lldiscrim, lldiscrimptr);\n \n                         ret lval_val(alloc_result.bcx, lltagptr);\n@@ -3762,7 +3762,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_native_fn(?did)) {\n                     auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n-                                                           cx.fcx.ccx.type_cache, did);\n+                        cx.fcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (_) {\n@@ -3898,7 +3898,7 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n         } else if (ty.type_is_native(t)) {\n             e_res.val = e_res.bcx.build.IntToPtr(e_res.val, lldsttype);\n         } else if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n-                   llvm.LLVMGetIntTypeWidth(llsrctype)) {\n+            llvm.LLVMGetIntTypeWidth(llsrctype)) {\n             if (ty.type_is_signed(t)) {\n                 // Widening signed cast.\n                 e_res.val =\n@@ -4435,11 +4435,11 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n     auto llretslot = args_res._2;\n \n     /*\n-      log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n+    log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n \n-      for (ValueRef arg in llargs) {\n-      log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n-      }\n+    for (ValueRef arg in llargs) {\n+        log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n+    }\n     */\n \n     bcx.build.FastCall(faddr, llargs);\n@@ -4499,11 +4499,11 @@ fn trans_call_self(@block_ctxt cx, @ast.expr f,\n     auto llretslot = args_res._2;\n \n     /*\n-      log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n+    log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n \n-      for (ValueRef arg in llargs) {\n-      log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n-      }\n+    for (ValueRef arg in llargs) {\n+        log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n+    }\n     */\n \n     bcx.build.FastCall(faddr, llargs);\n@@ -5152,7 +5152,7 @@ fn trans_recv(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n \n     // FIXME: calculate copy init-ness in typestate.\n     ret recv_val(bcx, data.res.val, rhs, unit_ty, DROP_EXISTING);\n-}\n+ }\n \n fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n             @ty.t unit_ty, copy_action action) -> result {\n@@ -5629,14 +5629,14 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, ValueRef llself) {\n     box_ptr = bcx.build.PointerCast(box_ptr, llobj_box_ty);\n \n     auto obj_typarams = bcx.build.GEP(box_ptr,\n-                                      vec(C_int(0),\n-                                          C_int(abi.box_rc_field_body),\n-                                          C_int(abi.obj_body_elt_typarams)));\n+                                     vec(C_int(0),\n+                                         C_int(abi.box_rc_field_body),\n+                                         C_int(abi.obj_body_elt_typarams)));\n \n     // The object fields immediately follow the type parameters, so we skip\n     // over them to get the pointer.\n     auto obj_fields = bcx.build.Add(vp2i(bcx, obj_typarams),\n-                                    llsize_of(llvm.LLVMGetElementType(val_ty(obj_typarams))));\n+        llsize_of(llvm.LLVMGetElementType(val_ty(obj_typarams))));\n \n     // If we can (i.e. the type is statically sized), then cast the resulting\n     // fields pointer to the appropriate LLVM type. If not, just leave it as\n@@ -5938,12 +5938,12 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n         auto llargptr = bcx.build.PointerCast(fcx.llargs.get(va.id),\n-                                              val_ty(lldestptr));\n+            val_ty(lldestptr));\n \n         auto arg_ty = arg_tys.(i).ty;\n         auto llargval;\n         if (ty.type_is_structural(arg_ty) ||\n-            ty.type_has_dynamic_size(arg_ty)) {\n+                ty.type_has_dynamic_size(arg_ty)) {\n             llargval = llargptr;\n         } else {\n             llargval = bcx.build.Load(llargptr);\n@@ -6098,7 +6098,7 @@ fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n }\n \n fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, &ast.ann ann)\n-    -> TypeRef {\n+        -> TypeRef {\n     auto x = node_ann_type(cx, ann);\n     alt (x.struct) {\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n@@ -6118,7 +6118,7 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n     auto wrapper_type = native_fn_wrapper_type(cx, num_ty_param, ann);\n     let str s = mangle_name_by_seq(cx, \"wrapper\");\n     let ValueRef wrapper_fn = decl_internal_fastcall_fn(cx.llmod, s,\n-                                                        wrapper_type);\n+                                                       wrapper_type);\n \n     // Declare the global constant pair that points to it.\n     auto wrapper_pair_type = T_fn_pair(cx.tn, wrapper_type);\n@@ -6873,7 +6873,7 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n     put_vec_fill(copy_src_cx, llnew_vec,\n                  copy_src_cx.build.Add(vec_fill(copy_src_cx,\n                                                 llnew_vec),\n-                                       n_bytes));\n+                                        n_bytes));\n \n     // Write new_vec back through the alias we were given.\n     copy_src_cx.build.Store(llnew_vec, lldst_vec_ptr);"}]}