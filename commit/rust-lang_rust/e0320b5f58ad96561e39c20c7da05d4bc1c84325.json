{"sha": "e0320b5f58ad96561e39c20c7da05d4bc1c84325", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMzIwYjVmNThhZDk2NTYxZTM5YzIwYzdkYTA1ZDRiYzFjODQzMjU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-05T22:07:53Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-05T22:13:20Z"}, "message": "validation: port more checks to the pattern-based macro (and give it the shorter name)", "tree": {"sha": "bfffde2e866b300cb3b5663b02157d2455a2ca6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfffde2e866b300cb3b5663b02157d2455a2ca6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0320b5f58ad96561e39c20c7da05d4bc1c84325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0320b5f58ad96561e39c20c7da05d4bc1c84325", "html_url": "https://github.com/rust-lang/rust/commit/e0320b5f58ad96561e39c20c7da05d4bc1c84325", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0320b5f58ad96561e39c20c7da05d4bc1c84325/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04689e22e946879f2f5e2c73849d2f4e1f2b4b32", "url": "https://api.github.com/repos/rust-lang/rust/commits/04689e22e946879f2f5e2c73849d2f4e1f2b4b32", "html_url": "https://github.com/rust-lang/rust/commit/04689e22e946879f2f5e2c73849d2f4e1f2b4b32"}], "stats": {"total": 84, "additions": 54, "deletions": 30}, "files": [{"sha": "1c4309dbe3a5b2bee9cc4d03e24eef3843a4a547", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0320b5f58ad96561e39c20c7da05d4bc1c84325/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0320b5f58ad96561e39c20c7da05d4bc1c84325/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=e0320b5f58ad96561e39c20c7da05d4bc1c84325", "patch": "@@ -380,6 +380,8 @@ pub enum UndefinedBehaviorInfo {\n     InvalidDiscriminant(ScalarMaybeUndef),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n+    /// Using a string that is not valid UTF-8,\n+    InvalidStr(std::str::Utf8Error),\n     /// Using uninitialized data where it is not allowed.\n     InvalidUndefBytes(Option<Pointer>),\n     /// Working with a local that is not currently live.\n@@ -446,6 +448,9 @@ impl fmt::Display for UndefinedBehaviorInfo {\n             InvalidFunctionPointer(p) => {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }\n+            InvalidStr(err) => {\n+                write!(f, \"this string is not valid UTF-8: {}\", err)\n+            }\n             InvalidUndefBytes(Some(p)) => write!(\n                 f,\n                 \"reading uninitialized memory at {}, but this operation requires initialized memory\","}, {"sha": "e8ef330c76cf0b123e599482b3e42b26447cc50e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0320b5f58ad96561e39c20c7da05d4bc1c84325/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0320b5f58ad96561e39c20c7da05d4bc1c84325/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e0320b5f58ad96561e39c20c7da05d4bc1c84325", "patch": "@@ -328,7 +328,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n         let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| err_ub_format!(\"this string is not valid UTF-8: {}\", err))?;\n+            .map_err(|err| err_ub!(InvalidStr(err)))?;\n         Ok(str)\n     }\n "}, {"sha": "620333f430429bce563c0aaaad76456954dc78ea", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e0320b5f58ad96561e39c20c7da05d4bc1c84325/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0320b5f58ad96561e39c20c7da05d4bc1c84325/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=e0320b5f58ad96561e39c20c7da05d4bc1c84325", "patch": "@@ -38,20 +38,20 @@ macro_rules! throw_validation_failure {\n }\n \n /// Returns a validation failure for any Err value of $e.\n-// FIXME: Replace all usages of try_validation! with try_validation_pat!.\n-macro_rules! try_validation {\n+// FIXME: Replace all usages of try_validation_catchall! with try_validation!.\n+macro_rules! try_validation_catchall {\n     ($e:expr, $what:expr, $where:expr $(, $expected:expr )?) => {{\n-        try_validation_pat!($e, $where, {\n+        try_validation!($e, $where,\n             _ => { \"{}\", $what } $( expected { \"{}\", $expected } )?,\n-        })\n+        )\n     }};\n }\n /// Like try_validation, but will throw a validation error if any of the patterns in $p are\n /// matched. Other errors are passed back to the caller, unchanged. This lets you use the patterns\n /// as a kind of validation blacklist:\n ///\n /// ```\n-/// let v = try_validation_pat!(some_fn(), some_path, {\n+/// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"some failure\" },\n /// });\n /// // Failures that match $p are thrown up as validation errors, but other errors are passed back\n@@ -61,7 +61,7 @@ macro_rules! try_validation {\n /// An additional expected parameter can also be added to the failure message:\n ///\n /// ```\n-/// let v = try_validation_pat!(some_fn(), some_path, {\n+/// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"some failure\" } expected { \"something that wasn't a failure\" },\n /// });\n /// ```\n@@ -70,14 +70,15 @@ macro_rules! try_validation {\n /// the format string in directly:\n ///\n /// ```\n-/// let v = try_validation_pat!(some_fn(), some_path, {\n+/// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"{:?}\", some_failure } expected { \"{}\", expected_value },\n /// });\n /// ```\n ///\n-macro_rules! try_validation_pat {\n-    ($e:expr, $where:expr, { $( $p:pat )|+ =>\n-        { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? $( , )?}) => {{\n+macro_rules! try_validation {\n+    ($e:expr, $where:expr,\n+     $( $p:pat )|+ => { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? $( , )?\n+    ) => {{\n         match $e {\n             Ok(x) => x,\n             // We catch the error and turn it into a validation failure. We are okay with\n@@ -303,21 +304,28 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         match tail.kind {\n             ty::Dynamic(..) => {\n                 let vtable = meta.unwrap_meta();\n+                // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n                 try_validation!(\n-                    self.ecx.memory.check_ptr_access(\n+                    self.ecx.memory.check_ptr_access_align(\n                         vtable,\n                         3 * self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n-                        self.ecx.tcx.data_layout.pointer_align.abi,\n+                        Some(self.ecx.tcx.data_layout.pointer_align.abi),\n+                        CheckInAllocMsg::InboundsTest,\n                     ),\n-                    \"dangling or unaligned vtable pointer in wide pointer or too small vtable\",\n-                    self.path\n+                    self.path,\n+                    err_ub!(PointerOutOfBounds { .. }) |\n+                    err_ub!(AlignmentCheckFailed { .. }) |\n+                    err_ub!(DanglingIntPointer(..)) |\n+                    err_unsup!(ReadBytesAsPointer) => {\n+                        \"dangling or unaligned vtable pointer in wide pointer or too small vtable\"\n+                    },\n                 );\n-                try_validation!(\n+                try_validation_catchall!(\n                     self.ecx.read_drop_type_from_vtable(vtable),\n                     \"invalid drop fn in vtable\",\n                     self.path\n                 );\n-                try_validation!(\n+                try_validation_catchall!(\n                     self.ecx.read_size_and_align_from_vtable(vtable),\n                     \"invalid size or align in vtable\",\n                     self.path\n@@ -327,8 +335,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             ty::Slice(..) | ty::Str => {\n                 let _len = try_validation!(\n                     meta.unwrap_meta().to_machine_usize(self.ecx),\n-                    \"non-integer slice length in wide pointer\",\n-                    self.path\n+                    self.path,\n+                    err_unsup!(ReadPointerAsBytes) => { \"non-integer slice length in wide pointer\" },\n                 );\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n@@ -354,8 +362,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         // Check metadata early, for better diagnostics\n         let place = try_validation!(\n             self.ecx.ref_to_mplace(value),\n-            format_args!(\"uninitialized {}\", kind),\n-            self.path\n+            self.path,\n+            err_ub!(InvalidUndefBytes(..)) => { \"uninitialized {}\", kind },\n         );\n         if place.layout.is_unsized() {\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n@@ -376,6 +384,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // alignment and size determined by the layout (size will be 0,\n             // alignment should take attributes into account).\n             .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n+        // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n         let ptr: Option<_> = match self.ecx.memory.check_ptr_access_align(\n             place.ptr,\n             size,\n@@ -489,12 +498,20 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         match ty.kind {\n             ty::Bool => {\n                 let value = self.ecx.read_scalar(value)?;\n-                try_validation!(value.to_bool(), value, self.path, \"a boolean\");\n+                try_validation!(\n+                    value.to_bool(),\n+                    self.path,\n+                    err_ub!(InvalidBool(..)) => { \"{}\", value } expected { \"a boolean\" },\n+                );\n                 Ok(true)\n             }\n             ty::Char => {\n                 let value = self.ecx.read_scalar(value)?;\n-                try_validation!(value.to_char(), value, self.path, \"a valid unicode codepoint\");\n+                try_validation!(\n+                    value.to_char(),\n+                    self.path,\n+                    err_ub!(InvalidChar(..)) => { \"{}\", value } expected { \"a valid unicode codepoint\" },\n+                );\n                 Ok(true)\n             }\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n@@ -521,9 +538,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // We are conservative with undef for integers, but try to\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n-                let place = try_validation_pat!(self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?), self.path, {\n+                let place = try_validation!(\n+                    self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?),\n+                    self.path,\n                     err_ub!(InvalidUndefBytes(..)) => { \"uninitialized raw pointer\" },\n-                });\n+                );\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n@@ -539,7 +558,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             }\n             ty::FnPtr(_sig) => {\n                 let value = self.ecx.read_scalar(value)?;\n-                let _fn = try_validation!(\n+                let _fn = try_validation_catchall!(\n                     value.not_undef().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n                     value,\n                     self.path,\n@@ -598,9 +617,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         // At least one value is excluded. Get the bits.\n         let value = try_validation!(\n             value.not_undef(),\n-            value,\n             self.path,\n-            format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi),)\n+            err_ub!(InvalidUndefBytes(..)) => { \"{}\", value }\n+                expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },\n         );\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n             Err(ptr) => {\n@@ -761,8 +780,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n                 try_validation!(\n                     self.ecx.read_str(mplace),\n-                    \"uninitialized or non-UTF-8 data in str\",\n-                    self.path\n+                    self.path,\n+                    err_ub!(InvalidStr(..)) => { \"uninitialized or non-UTF-8 data in str\" },\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)"}]}