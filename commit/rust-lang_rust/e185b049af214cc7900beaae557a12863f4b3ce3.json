{"sha": "e185b049af214cc7900beaae557a12863f4b3ce3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxODViMDQ5YWYyMTRjYzc5MDBiZWFhZTU1N2ExMjg2M2Y0YjNjZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-18T19:41:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-18T19:41:59Z"}, "message": "auto merge of #8545 : blake2-ppc/rust/iterbytes, r=alexcrichton\n\nAddress issue #5257, for example these values all had the same hash value:\r\n\r\n\t(\"aaa\", \"bbb\", \"ccc\")\r\n\t(\"aaab\", \"bb\", \"ccc\")\r\n\t(\"aaabbb\", \"\", \"ccc\")\r\n\r\nIterBytes for &[A] now includes the length, before calling iter_bytes on\r\neach element.\r\n\r\nIterBytes for &str is now terminated by a byte that does not appear in\r\nUTF-8. This way only one more byte is processed when hashing strings.", "tree": {"sha": "4347d5393e9a4df2b053b03007397973a6760939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4347d5393e9a4df2b053b03007397973a6760939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e185b049af214cc7900beaae557a12863f4b3ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e185b049af214cc7900beaae557a12863f4b3ce3", "html_url": "https://github.com/rust-lang/rust/commit/e185b049af214cc7900beaae557a12863f4b3ce3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e185b049af214cc7900beaae557a12863f4b3ce3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88bd2155d780d2d7d976ff271b6bb25a9b03e119", "url": "https://api.github.com/repos/rust-lang/rust/commits/88bd2155d780d2d7d976ff271b6bb25a9b03e119", "html_url": "https://github.com/rust-lang/rust/commit/88bd2155d780d2d7d976ff271b6bb25a9b03e119"}, {"sha": "bfa1331cd7fb4a8a74ede969abe22004d0232184", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa1331cd7fb4a8a74ede969abe22004d0232184", "html_url": "https://github.com/rust-lang/rust/commit/bfa1331cd7fb4a8a74ede969abe22004d0232184"}], "stats": {"total": 150, "additions": 89, "deletions": 61}, "files": [{"sha": "f3df42f7a4386ae70a87be1f6f2daa7b03646031", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e185b049af214cc7900beaae557a12863f4b3ce3/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e185b049af214cc7900beaae557a12863f4b3ce3/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=e185b049af214cc7900beaae557a12863f4b3ce3", "patch": "@@ -409,6 +409,14 @@ mod tests {\n \n     use uint;\n \n+    // Hash just the bytes of the slice, without length prefix\n+    struct Bytes<'self>(&'self [u8]);\n+    impl<'self> IterBytes for Bytes<'self> {\n+        fn iter_bytes(&self, _lsb0: bool, f: &fn(&[u8]) -> bool) -> bool {\n+            f(**self)\n+        }\n+    }\n+\n     #[test]\n     fn test_siphash() {\n         let vecs : [[u8, ..8], ..64] = [\n@@ -496,7 +504,7 @@ mod tests {\n         while t < 64 {\n             debug!(\"siphash test %?\", t);\n             let vec = u8to64_le!(vecs[t], 0);\n-            let out = buf.hash_keyed(k0, k1);\n+            let out = Bytes(buf.as_slice()).hash_keyed(k0, k1);\n             debug!(\"got %?, expected %?\", out, vec);\n             assert_eq!(vec, out);\n \n@@ -587,4 +595,18 @@ mod tests {\n     fn test_float_hashes_of_zero() {\n         assert_eq!(0.0.hash(), (-0.0).hash());\n     }\n+\n+    #[test]\n+    fn test_hash_no_concat_alias() {\n+        let s = (\"aa\", \"bb\");\n+        let t = (\"aabb\", \"\");\n+        let u = (\"a\", \"abb\");\n+\n+        let v = (&[1u8], &[0u8, 0], &[0u8]);\n+        let w = (&[1u8, 0, 0, 0], &[], &[]);\n+\n+        assert!(v != w);\n+        assert!(s.hash() != t.hash() && s.hash() != u.hash());\n+        assert!(v.hash() != w.hash());\n+    }\n }"}, {"sha": "1cfbf841537c5504f30f365848bc202076fd5610", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e185b049af214cc7900beaae557a12863f4b3ce3/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e185b049af214cc7900beaae557a12863f4b3ce3/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=e185b049af214cc7900beaae557a12863f4b3ce3", "patch": "@@ -376,7 +376,6 @@ static ASCII_UPPER_MAP: &'static [u8] = &[\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use to_bytes::ToBytes;\n     use str::from_char;\n \n     macro_rules! v2ascii (\n@@ -445,7 +444,6 @@ mod tests {\n \n     #[test]\n     fn test_ascii_to_bytes() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).to_bytes(false), ~[40u8, 32u8, 59u8]);\n         assert_eq!(v2ascii!(~[40, 32, 59]).into_bytes(), ~[40u8, 32u8, 59u8]);\n     }\n "}, {"sha": "198c09964bb6ff274354d4f8b559afeaaaf5a1ac", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e185b049af214cc7900beaae557a12863f4b3ce3/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e185b049af214cc7900beaae557a12863f4b3ce3/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=e185b049af214cc7900beaae557a12863f4b3ce3", "patch": "@@ -15,37 +15,43 @@ The `ToBytes` and `IterBytes` traits\n */\n \n use cast;\n+use container::Container;\n use io;\n use io::Writer;\n use iterator::Iterator;\n use option::{None, Option, Some};\n-use str::StrSlice;\n-use vec::ImmutableVector;\n+use str::{Str, StrSlice};\n+use vec::{Vector, ImmutableVector};\n \n pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n \n-/**\n- * A trait to implement in order to make a type hashable;\n- * This works in combination with the trait `Hash::Hash`, and\n- * may in the future be merged with that trait or otherwise\n- * modified when default methods and trait inheritance are\n- * completed.\n- */\n+///\n+/// A trait to implement in order to make a type hashable;\n+/// This works in combination with the trait `std::hash::Hash`, and\n+/// may in the future be merged with that trait or otherwise\n+/// modified when default methods and trait inheritance are\n+/// completed.\n+///\n+/// IterBytes should be implemented so that the extent of the\n+/// produced byte stream can be discovered, given the original\n+/// type.\n+/// For example, the IterBytes implementation for vectors emits\n+/// its length first, and enums should emit their discriminant.\n+///\n pub trait IterBytes {\n-    /**\n-     * Call the provided callback `f` one or more times with\n-     * byte-slices that should be used when computing a hash\n-     * value or otherwise \"flattening\" the structure into\n-     * a sequence of bytes. The `lsb0` parameter conveys\n-     * whether the caller is asking for little-endian bytes\n-     * (`true`) or big-endian (`false`); this should only be\n-     * relevant in implementations that represent a single\n-     * multi-byte datum such as a 32 bit integer or 64 bit\n-     * floating-point value. It can be safely ignored for\n-     * larger structured types as they are usually processed\n-     * left-to-right in declaration order, regardless of\n-     * underlying memory endianness.\n-     */\n+    /// Call the provided callback `f` one or more times with\n+    /// byte-slices that should be used when computing a hash\n+    /// value or otherwise \"flattening\" the structure into\n+    /// a sequence of bytes. The `lsb0` parameter conveys\n+    /// whether the caller is asking for little-endian bytes\n+    /// (`true`) or big-endian (`false`); this should only be\n+    /// relevant in implementations that represent a single\n+    /// multi-byte datum such as a 32 bit integer or 64 bit\n+    /// floating-point value. It can be safely ignored for\n+    /// larger structured types as they are usually processed\n+    /// left-to-right in declaration order, regardless of\n+    /// underlying memory endianness.\n+    ///\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool;\n }\n \n@@ -224,74 +230,76 @@ impl IterBytes for f64 {\n impl<'self,A:IterBytes> IterBytes for &'self [A] {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        self.len().iter_bytes(lsb0, |b| f(b)) &&\n         self.iter().advance(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n     }\n }\n \n-impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n-  #[inline]\n-  fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-    match *self {\n-      (ref a, ref b) => { a.iter_bytes(lsb0, |b| f(b)) &&\n-                          b.iter_bytes(lsb0, |b| f(b)) }\n-    }\n-  }\n-}\n-\n-impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n-  #[inline]\n-  fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-    match *self {\n-      (ref a, ref b, ref c) => {\n-        a.iter_bytes(lsb0, |b| f(b)) &&\n-        b.iter_bytes(lsb0, |b| f(b)) &&\n-        c.iter_bytes(lsb0, |b| f(b))\n-      }\n+impl<A: IterBytes> IterBytes for (A, ) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        match *self {\n+            (ref a, ) => a.iter_bytes(lsb0, |b| f(b))\n+        }\n     }\n-  }\n }\n \n-// Move this to vec, probably.\n-fn borrow<'x,A>(a: &'x [A]) -> &'x [A] {\n-    a\n-}\n+macro_rules! iter_bytes_tuple(\n+    ($($A:ident),+) => (\n+        impl<$($A: IterBytes),+> IterBytes for ($($A),+) {\n+            fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+                match *self {\n+                    ($(ref $A),+) => {\n+                        $(\n+                            $A .iter_bytes(lsb0, |b| f(b))\n+                        )&&+\n+                    }\n+                }\n+            }\n+        }\n+    )\n+)\n+\n+iter_bytes_tuple!(A, B)\n+iter_bytes_tuple!(A, B, C)\n+iter_bytes_tuple!(A, B, C, D)\n+iter_bytes_tuple!(A, B, C, D, E)\n+iter_bytes_tuple!(A, B, C, D, E, F)\n+iter_bytes_tuple!(A, B, C, D, E, F, G)\n+iter_bytes_tuple!(A, B, C, D, E, F, G, H)\n \n impl<A:IterBytes> IterBytes for ~[A] {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        borrow(*self).iter_bytes(lsb0, f)\n+        self.as_slice().iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for @[A] {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        borrow(*self).iter_bytes(lsb0, f)\n+        self.as_slice().iter_bytes(lsb0, f)\n     }\n }\n \n impl<'self> IterBytes for &'self str {\n     #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        f(self.as_bytes())\n+        // Terminate the string with a byte that does not appear in UTF-8\n+        f(self.as_bytes()) && f([0xFF])\n     }\n }\n \n impl IterBytes for ~str {\n     #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        // this should possibly include the null terminator, but that\n-        // breaks .find_equiv on hashmaps.\n-        f(self.as_bytes())\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        self.as_slice().iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for @str {\n     #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        // this should possibly include the null terminator, but that\n-        // breaks .find_equiv on hashmaps.\n-        f(self.as_bytes())\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        self.as_slice().iter_bytes(lsb0, f)\n     }\n }\n "}]}