{"sha": "c0100ce84698dde68a25f05aa4271d84f547c50c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMTAwY2U4NDY5OGRkZTY4YTI1ZjA1YWE0MjcxZDg0ZjU0N2M1MGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-05T11:06:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-05T11:06:35Z"}, "message": "Auto merge of #25113 - pnkfelix:dropck-itemless-traits, r=huonw\n\nGeneralize dropck to ignore item-less traits\r\n\r\nFix #24805.\r\n\r\n(This is the reopened + rebased version of PR #24898)", "tree": {"sha": "ca816d87abaf20cb92ad8f73236cb2d88cceb58c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca816d87abaf20cb92ad8f73236cb2d88cceb58c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0100ce84698dde68a25f05aa4271d84f547c50c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0100ce84698dde68a25f05aa4271d84f547c50c", "html_url": "https://github.com/rust-lang/rust/commit/c0100ce84698dde68a25f05aa4271d84f547c50c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0100ce84698dde68a25f05aa4271d84f547c50c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31e3cb7c4e8895fff23aa67e1cd6b58d798cdac4", "url": "https://api.github.com/repos/rust-lang/rust/commits/31e3cb7c4e8895fff23aa67e1cd6b58d798cdac4", "html_url": "https://github.com/rust-lang/rust/commit/31e3cb7c4e8895fff23aa67e1cd6b58d798cdac4"}, {"sha": "f40d9d9ea09f1e40e215fc380279b576327eaba2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f40d9d9ea09f1e40e215fc380279b576327eaba2", "html_url": "https://github.com/rust-lang/rust/commit/f40d9d9ea09f1e40e215fc380279b576327eaba2"}], "stats": {"total": 273, "additions": 238, "deletions": 35}, "files": [{"sha": "8545e73c4f932e67238f38cf8a84c2b31d020294", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c0100ce84698dde68a25f05aa4271d84f547c50c/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0100ce84698dde68a25f05aa4271d84f547c50c/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=c0100ce84698dde68a25f05aa4271d84f547c50c", "patch": "@@ -450,45 +450,57 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n             let dtor_typescheme = ty::lookup_item_type(rcx.tcx(), impl_did);\n             let dtor_generics = dtor_typescheme.generics;\n-            let dtor_predicates = ty::lookup_predicates(rcx.tcx(), impl_did);\n-\n-            let has_pred_of_interest = dtor_predicates.predicates.iter().any(|pred| {\n-                // In `impl<T> Drop where ...`, we automatically\n-                // assume some predicate will be meaningful and thus\n-                // represents a type through which we could reach\n-                // borrowed data. However, there can be implicit\n-                // predicates (namely for Sized), and so we still need\n-                // to walk through and filter out those cases.\n-\n-                let result = match *pred {\n-                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                        let def_id = t_pred.trait_ref.def_id;\n-                        match rcx.tcx().lang_items.to_builtin_kind(def_id) {\n-                            // Issue 24895: deliberately do not include `BoundCopy` here.\n-                            Some(ty::BoundSend) |\n-                            Some(ty::BoundSized) |\n-                            Some(ty::BoundSync) => false,\n-                            _ => true,\n+\n+            let mut has_pred_of_interest = false;\n+\n+            let mut seen_items = Vec::new();\n+            let mut items_to_inspect = vec![impl_did];\n+            'items: while let Some(item_def_id) = items_to_inspect.pop() {\n+                if seen_items.contains(&item_def_id) {\n+                    continue;\n+                }\n+\n+                for pred in ty::lookup_predicates(rcx.tcx(), item_def_id).predicates {\n+                    let result = match pred {\n+                        ty::Predicate::Equate(..) |\n+                        ty::Predicate::RegionOutlives(..) |\n+                        ty::Predicate::TypeOutlives(..) |\n+                        ty::Predicate::Projection(..) => {\n+                            // For now, assume all these where-clauses\n+                            // may give drop implementation capabilty\n+                            // to access borrowed data.\n+                            true\n                         }\n-                    }\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::TypeOutlives(..) |\n-                    ty::Predicate::Projection(..) => {\n-                        // we assume all of these where-clauses may\n-                        // give the drop implementation the capabilty\n-                        // to access borrowed data.\n-                        true\n-                    }\n-                };\n \n-                if result {\n-                    debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n-                           typ.repr(rcx.tcx()), pred.repr(rcx.tcx()));\n+                        ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                            let def_id = t_pred.trait_ref.def_id;\n+                            if ty::trait_items(rcx.tcx(), def_id).len() != 0 {\n+                                // If trait has items, assume it adds\n+                                // capability to access borrowed data.\n+                                true\n+                            } else {\n+                                // Trait without items is itself\n+                                // uninteresting from POV of dropck.\n+                                //\n+                                // However, may have parent w/ items;\n+                                // so schedule checking of predicates,\n+                                items_to_inspect.push(def_id);\n+                                // and say \"no capability found\" for now.\n+                                false\n+                            }\n+                        }\n+                    };\n+\n+                    if result {\n+                        has_pred_of_interest = true;\n+                        debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n+                               typ.repr(rcx.tcx()), pred.repr(rcx.tcx()));\n+                        break 'items;\n+                    }\n                 }\n \n-                result\n-            });\n+                seen_items.push(item_def_id);\n+            }\n \n             // In `impl<'a> Drop ...`, we automatically assume\n             // `'a` is meaningful and thus represents a bound"}, {"sha": "37ef81e6866efd4c72722442175a20b73ff11357", "filename": "src/test/compile-fail/issue-24805-dropck-child-has-items-via-parent.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c0100ce84698dde68a25f05aa4271d84f547c50c/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-child-has-items-via-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0100ce84698dde68a25f05aa4271d84f547c50c/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-child-has-items-via-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-child-has-items-via-parent.rs?ref=c0100ce84698dde68a25f05aa4271d84f547c50c", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that child trait who only has items via its *parent* trait\n+// does cause dropck to inject extra region constraints.\n+\n+#![allow(non_camel_case_types)]\n+\n+trait Parent { fn foo(&self); }\n+trait Child: Parent { }\n+\n+impl Parent for i32 { fn foo(&self) { } }\n+impl<'a> Parent for &'a D_Child<i32> {\n+    fn foo(&self) {\n+        println!(\"accessing child value: {}\", self.0);\n+    }\n+}\n+\n+impl Child for i32 { }\n+impl<'a> Child for &'a D_Child<i32> { }\n+\n+struct D_Child<T:Child>(T);\n+impl <T:Child> Drop for D_Child<T> { fn drop(&mut self) { self.0.foo() } }\n+\n+fn f_child() {\n+    // `_d` and `d1` are assigned the *same* lifetime by region inference ...\n+    let (_d, d1);\n+\n+    d1 = D_Child(1);\n+    // ... we store a reference to `d1` within `_d` ...\n+    _d = D_Child(&d1); //~ ERROR `d1` does not live long enough\n+\n+    // ... dropck *should* complain, because Drop of _d could (and\n+    // does) access the already dropped `d1` via the `foo` method.\n+}\n+\n+fn main() {\n+    f_child();\n+}"}, {"sha": "0da1b9fc6e196644300e048fc9e2a5fd6637d911", "filename": "src/test/compile-fail/issue-24805-dropck-trait-has-items.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c0100ce84698dde68a25f05aa4271d84f547c50c/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-trait-has-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0100ce84698dde68a25f05aa4271d84f547c50c/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-trait-has-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-trait-has-items.rs?ref=c0100ce84698dde68a25f05aa4271d84f547c50c", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that traits with various kinds of associated items cause\n+// dropck to inject extra region constraints.\n+\n+#![allow(non_camel_case_types)]\n+\n+trait HasSelfMethod { fn m1(&self) { } }\n+trait HasMethodWithSelfArg { fn m2(x: &Self) { } }\n+trait HasType { type Something; }\n+\n+impl HasSelfMethod for i32 { }\n+impl HasMethodWithSelfArg for i32 { }\n+impl HasType for i32 { type Something = (); }\n+\n+impl<'a,T> HasSelfMethod for &'a T { }\n+impl<'a,T> HasMethodWithSelfArg for &'a T { }\n+impl<'a,T> HasType for &'a T { type Something = (); }\n+\n+// e.g. `impl_drop!(Send, D_Send)` expands to:\n+//   ```rust\n+//   struct D_Send<T:Send>(T);\n+//   impl<T:Send> Drop for D_Send<T> { fn drop(&mut self) { } }\n+//   ```\n+macro_rules! impl_drop {\n+    ($Bound:ident, $Id:ident) => {\n+        struct $Id<T:$Bound>(T);\n+        impl <T:$Bound> Drop for $Id<T> { fn drop(&mut self) { } }\n+    }\n+}\n+\n+impl_drop!{HasSelfMethod,        D_HasSelfMethod}\n+impl_drop!{HasMethodWithSelfArg, D_HasMethodWithSelfArg}\n+impl_drop!{HasType,              D_HasType}\n+\n+fn f_sm() {\n+    let (_d, d1);\n+    d1 = D_HasSelfMethod(1);\n+    _d = D_HasSelfMethod(&d1); //~ ERROR `d1` does not live long enough\n+}\n+fn f_mwsa() {\n+    let (_d, d1);\n+    d1 = D_HasMethodWithSelfArg(1);\n+    _d = D_HasMethodWithSelfArg(&d1); //~ ERROR `d1` does not live long enough\n+}\n+fn f_t() {\n+    let (_d, d1);\n+    d1 = D_HasType(1);\n+    _d = D_HasType(&d1); //~ ERROR `d1` does not live long enough\n+}\n+\n+fn main() {\n+    f_sm();\n+    f_mwsa();\n+    f_t();\n+}"}, {"sha": "4512bcc2000bf56971654451e65708d932dc58d9", "filename": "src/test/run-pass/issue-24805-dropck-itemless.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c0100ce84698dde68a25f05aa4271d84f547c50c/src%2Ftest%2Frun-pass%2Fissue-24805-dropck-itemless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0100ce84698dde68a25f05aa4271d84f547c50c/src%2Ftest%2Frun-pass%2Fissue-24805-dropck-itemless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24805-dropck-itemless.rs?ref=c0100ce84698dde68a25f05aa4271d84f547c50c", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that item-less traits do not cause dropck to inject extra\n+// region constraints.\n+\n+#![allow(non_camel_case_types)]\n+\n+trait UserDefined { }\n+\n+impl UserDefined for i32 { }\n+impl<'a, T> UserDefined for &'a T { }\n+\n+// e.g. `impl_drop!(Send, D_Send)` expands to:\n+//   ```rust\n+//   struct D_Send<T:Send>(T);\n+//   impl<T:Send> Drop for D_Send<T> { fn drop(&mut self) { } }\n+//   ```\n+macro_rules! impl_drop {\n+    ($Bound:ident, $Id:ident) => {\n+        struct $Id<T:$Bound>(T);\n+        impl <T:$Bound> Drop for $Id<T> { fn drop(&mut self) { } }\n+    }\n+}\n+\n+impl_drop!{Send,         D_Send}\n+impl_drop!{Sized,        D_Sized}\n+\n+// See note below regarding Issue 24895\n+// impl_drop!{Copy,         D_Copy}\n+\n+impl_drop!{Sync,         D_Sync}\n+impl_drop!{UserDefined,  D_UserDefined}\n+\n+macro_rules! body {\n+    ($id:ident) => { {\n+        // `_d` and `d1` are assigned the *same* lifetime by region inference ...\n+        let (_d, d1);\n+\n+        d1 = $id(1);\n+        // ... we store a reference to `d1` within `_d` ...\n+        _d = $id(&d1);\n+\n+        // ... a *conservative* dropck will thus complain, because it\n+        // thinks Drop of _d could access the already dropped `d1`.\n+    } }\n+}\n+\n+fn f_send() { body!(D_Send) }\n+fn f_sized() { body!(D_Sized) }\n+fn f_sync() { body!(D_Sync) }\n+\n+// Issue 24895: Copy: Clone implies `impl<T:Copy> Drop for ...` can\n+// access a user-defined clone() method, which causes this test case\n+// to fail.\n+//\n+// If 24895 is resolved by removing the `Copy: Clone` relationship,\n+// then this definition and the call below should be uncommented. If\n+// it is resolved by deciding to keep the `Copy: Clone` relationship,\n+// then this comment and the associated bits of code can all be\n+// removed.\n+\n+// fn f_copy() { body!(D_Copy) }\n+\n+fn f_userdefined() { body!(D_UserDefined) }\n+\n+fn main() {\n+    f_send();\n+    f_sized();\n+    // See note above regarding Issue 24895.\n+    // f_copy();\n+    f_sync();\n+    f_userdefined();\n+}"}]}