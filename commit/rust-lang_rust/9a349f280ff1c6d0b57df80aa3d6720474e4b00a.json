{"sha": "9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMzQ5ZjI4MGZmMWM2ZDBiNTdkZjgwYWEzZDY3MjA0NzRlNGIwMGE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-16T17:52:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-16T17:52:29Z"}, "message": "Merge #7295\n\n7295: Share import_assets and related entities r=matklad a=SomeoneToIgnore\n\nPart of https://github.com/rust-analyzer/rust-analyzer/pull/7293\r\nAddresses https://github.com/rust-analyzer/rust-analyzer/pull/7293#issuecomment-761569558\r\n\r\nPrepares `import_assets` and related to be used later for the trait fuzzy importing.\r\nAlso moves fuzzy imports into a separate completion module and renames them, as suggested in https://github.com/rust-analyzer/rust-analyzer/pull/7293#discussion_r558896685\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "23bbb365f31438949358a576bc9467fa70fa874e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23bbb365f31438949358a576bc9467fa70fa874e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgAyfdCRBK7hj4Ov3rIwAAdHIIADA4H+8zl+9300XAPAZ5Zb6v\n93+MZ3kL5V+iOt7PFTUx6MtaNlmirpBZdSURw5q2aq66mcyxe6YIqb+e1/mLKeuZ\n/O4gQvybNO5sLmd7y+/fzMVpQ2HdJw6agJukWU0+5hyFmuI92I/uqsUCssusGqOP\nlsk7j7lJRUXPisLnUbJTj1pEYV6cgmIM1Jp/SxsnaUllQnDUiWrzOexaINl8WffG\nxN26s2RNG5ZSVqLaqJlBI5jkc5N1kjW82cIl69SCNrxsDYYiy0/54s4PBuZ1Q05b\n5k7hF/1H6Ebg/vAiRCu1qmCNdCeQmi/scWxl+u+9F+fzHzdskHP66EnpAunn/u4=\n=WfM9\n-----END PGP SIGNATURE-----\n", "payload": "tree 23bbb365f31438949358a576bc9467fa70fa874e\nparent 3782c78d7558633be5483a04aa1c098fe76100b9\nparent 497fc232e7d90d8d39c7a13742dd85d758dc2f72\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610819549 +0000\ncommitter GitHub <noreply@github.com> 1610819549 +0000\n\nMerge #7295\n\n7295: Share import_assets and related entities r=matklad a=SomeoneToIgnore\n\nPart of https://github.com/rust-analyzer/rust-analyzer/pull/7293\r\nAddresses https://github.com/rust-analyzer/rust-analyzer/pull/7293#issuecomment-761569558\r\n\r\nPrepares `import_assets` and related to be used later for the trait fuzzy importing.\r\nAlso moves fuzzy imports into a separate completion module and renames them, as suggested in https://github.com/rust-analyzer/rust-analyzer/pull/7293#discussion_r558896685\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "html_url": "https://github.com/rust-lang/rust/commit/9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3782c78d7558633be5483a04aa1c098fe76100b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3782c78d7558633be5483a04aa1c098fe76100b9", "html_url": "https://github.com/rust-lang/rust/commit/3782c78d7558633be5483a04aa1c098fe76100b9"}, {"sha": "497fc232e7d90d8d39c7a13742dd85d758dc2f72", "url": "https://api.github.com/repos/rust-lang/rust/commits/497fc232e7d90d8d39c7a13742dd85d758dc2f72", "html_url": "https://github.com/rust-lang/rust/commit/497fc232e7d90d8d39c7a13742dd85d758dc2f72"}], "stats": {"total": 758, "additions": 421, "deletions": 337}, "files": [{"sha": "9cabf037c0e5046b051b22123d244f47d70d3bec", "filename": "crates/assists/src/assist_config.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fassist_config.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -4,7 +4,7 @@\n //! module, and we use to statically check that we only produce snippet\n //! assists if we are allowed to.\n \n-use ide_db::helpers::{insert_use::MergeBehavior, SnippetCap};\n+use ide_db::helpers::{insert_use::InsertUseConfig, SnippetCap};\n \n use crate::AssistKind;\n \n@@ -14,9 +14,3 @@ pub struct AssistConfig {\n     pub allowed: Option<Vec<AssistKind>>,\n     pub insert_use: InsertUseConfig,\n }\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-pub struct InsertUseConfig {\n-    pub merge: Option<MergeBehavior>,\n-    pub prefix_kind: hir::PrefixKind,\n-}"}, {"sha": "4e2a4fcd9657c169339ef21234a1f41bb6f3c931", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -1,13 +1,11 @@\n use ide_db::helpers::{\n+    import_assets::{ImportAssets, ImportCandidate},\n     insert_use::{insert_use, ImportScope},\n     mod_path_to_ast,\n };\n use syntax::ast;\n \n-use crate::{\n-    utils::import_assets::{ImportAssets, ImportCandidate},\n-    AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n-};\n+use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n \n // Feature: Auto Import\n //\n@@ -121,8 +119,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n fn import_group_message(import_candidate: &ImportCandidate) -> GroupLabel {\n     let name = match import_candidate {\n-        ImportCandidate::UnqualifiedName(candidate)\n-        | ImportCandidate::QualifierStart(candidate) => format!(\"Import {}\", &candidate.name),\n+        ImportCandidate::Path(candidate) => format!(\"Import {}\", &candidate.name),\n         ImportCandidate::TraitAssocItem(candidate) => {\n             format!(\"Import a trait for item {}\", &candidate.name)\n         }"}, {"sha": "a7d9fd4dc2f617a63a1208fd282d29d8f8d7330b", "filename": "crates/assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -1,7 +1,10 @@\n use std::iter;\n \n use hir::AsName;\n-use ide_db::helpers::mod_path_to_ast;\n+use ide_db::helpers::{\n+    import_assets::{ImportAssets, ImportCandidate},\n+    mod_path_to_ast,\n+};\n use ide_db::RootDatabase;\n use syntax::{\n     ast,\n@@ -12,7 +15,6 @@ use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n-    utils::import_assets::{ImportAssets, ImportCandidate},\n     AssistId, AssistKind, GroupLabel,\n };\n \n@@ -53,17 +55,18 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n \n     let qualify_candidate = match candidate {\n-        ImportCandidate::QualifierStart(_) => {\n-            mark::hit!(qualify_path_qualifier_start);\n-            let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n-            let (prev_segment, segment) = (path.qualifier()?.segment()?, path.segment()?);\n-            QualifyCandidate::QualifierStart(segment, prev_segment.generic_arg_list())\n-        }\n-        ImportCandidate::UnqualifiedName(_) => {\n-            mark::hit!(qualify_path_unqualified_name);\n-            let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n-            let generics = path.segment()?.generic_arg_list();\n-            QualifyCandidate::UnqualifiedName(generics)\n+        ImportCandidate::Path(candidate) => {\n+            if candidate.qualifier.is_some() {\n+                mark::hit!(qualify_path_qualifier_start);\n+                let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+                let (prev_segment, segment) = (path.qualifier()?.segment()?, path.segment()?);\n+                QualifyCandidate::QualifierStart(segment, prev_segment.generic_arg_list())\n+            } else {\n+                mark::hit!(qualify_path_unqualified_name);\n+                let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n+                let generics = path.segment()?.generic_arg_list();\n+                QualifyCandidate::UnqualifiedName(generics)\n+            }\n         }\n         ImportCandidate::TraitAssocItem(_) => {\n             mark::hit!(qualify_path_trait_assoc_item);\n@@ -186,16 +189,21 @@ fn item_as_trait(item: hir::ItemInNs) -> Option<hir::Trait> {\n \n fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n     let name = match candidate {\n-        ImportCandidate::UnqualifiedName(it) | ImportCandidate::QualifierStart(it) => &it.name,\n+        ImportCandidate::Path(it) => &it.name,\n         ImportCandidate::TraitAssocItem(it) | ImportCandidate::TraitMethod(it) => &it.name,\n     };\n     GroupLabel(format!(\"Qualify {}\", name))\n }\n \n fn label(candidate: &ImportCandidate, import: &hir::ModPath) -> String {\n     match candidate {\n-        ImportCandidate::UnqualifiedName(_) => format!(\"Qualify as `{}`\", &import),\n-        ImportCandidate::QualifierStart(_) => format!(\"Qualify with `{}`\", &import),\n+        ImportCandidate::Path(candidate) => {\n+            if candidate.qualifier.is_some() {\n+                format!(\"Qualify with `{}`\", &import)\n+            } else {\n+                format!(\"Qualify as `{}`\", &import)\n+            }\n+        }\n         ImportCandidate::TraitAssocItem(_) => format!(\"Qualify `{}`\", &import),\n         ImportCandidate::TraitMethod(_) => format!(\"Qualify with cast as `{}`\", &import),\n     }"}, {"sha": "14178a6510f3096fe12d57fb7e006c4970feca44", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -24,7 +24,7 @@ use syntax::TextRange;\n \n pub(crate) use crate::assist_context::{AssistContext, Assists};\n \n-pub use assist_config::{AssistConfig, InsertUseConfig};\n+pub use assist_config::AssistConfig;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum AssistKind {"}, {"sha": "32bd8698b1ff3307a038ba32ba7deb8dd26fa888", "filename": "crates/assists/src/tests.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -3,16 +3,17 @@ mod generated;\n use hir::Semantics;\n use ide_db::{\n     base_db::{fixture::WithFixture, FileId, FileRange, SourceDatabaseExt},\n-    helpers::{insert_use::MergeBehavior, SnippetCap},\n+    helpers::{\n+        insert_use::{InsertUseConfig, MergeBehavior},\n+        SnippetCap,\n+    },\n     source_change::FileSystemEdit,\n     RootDatabase,\n };\n use syntax::TextRange;\n use test_utils::{assert_eq_text, extract_offset, extract_range};\n \n-use crate::{\n-    handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, Assists, InsertUseConfig,\n-};\n+use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, Assists};\n use stdx::{format_to, trim_indent};\n \n pub(crate) const TEST_CONFIG: AssistConfig = AssistConfig {"}, {"sha": "fc9f83bab4793f6aa400f4875ecdfca5eade5a51", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -1,5 +1,4 @@\n //! Assorted functions shared by several assists.\n-pub(crate) mod import_assets;\n \n use std::ops;\n "}, {"sha": "c3ce6e51d54b73fdc245a9eade122a0a167a0dd3", "filename": "crates/completion/src/completions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -13,6 +13,7 @@ pub(crate) mod postfix;\n pub(crate) mod macro_in_item_position;\n pub(crate) mod trait_impl;\n pub(crate) mod mod_;\n+pub(crate) mod flyimport;\n \n use hir::{ModPath, ScopeDef, Type};\n "}, {"sha": "22280963845cdf33725367bcf0d3680ec36f4bcf", "filename": "crates/completion/src/completions/flyimport.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -0,0 +1,291 @@\n+//! Feature: completion with imports-on-the-fly\n+//!\n+//! When completing names in the current scope, proposes additional imports from other modules or crates,\n+//! if they can be qualified in the scope and their name contains all symbols from the completion input\n+//! (case-insensitive, in any order or places).\n+//!\n+//! ```\n+//! fn main() {\n+//!     pda$0\n+//! }\n+//! # pub mod std { pub mod marker { pub struct PhantomData { } } }\n+//! ```\n+//! ->\n+//! ```\n+//! use std::marker::PhantomData;\n+//!\n+//! fn main() {\n+//!     PhantomData\n+//! }\n+//! # pub mod std { pub mod marker { pub struct PhantomData { } } }\n+//! ```\n+//!\n+//! .Fuzzy search details\n+//!\n+//! To avoid an excessive amount of the results returned, completion input is checked for inclusion in the names only\n+//! (i.e. in `HashMap` in the `std::collections::HashMap` path).\n+//! For the same reasons, avoids searching for any imports for inputs with their length less that 2 symbols.\n+//!\n+//! .Import configuration\n+//!\n+//! It is possible to configure how use-trees are merged with the `importMergeBehavior` setting.\n+//! Mimics the corresponding behavior of the `Auto Import` feature.\n+//!\n+//! .LSP and performance implications\n+//!\n+//! The feature is enabled only if the LSP client supports LSP protocol version 3.16+ and reports the `additionalTextEdits`\n+//! (case sensitive) resolve client capability in its client capabilities.\n+//! This way the server is able to defer the costly computations, doing them for a selected completion item only.\n+//! For clients with no such support, all edits have to be calculated on the completion request, including the fuzzy search completion ones,\n+//! which might be slow ergo the feature is automatically disabled.\n+//!\n+//! .Feature toggle\n+//!\n+//! The feature can be forcefully turned off in the settings with the `rust-analyzer.completion.enableAutoimportCompletions` flag.\n+//! Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corredponding\n+//! capability enabled.\n+\n+use either::Either;\n+use hir::{ModPath, ScopeDef};\n+use ide_db::{helpers::insert_use::ImportScope, imports_locator};\n+use syntax::AstNode;\n+use test_utils::mark;\n+\n+use crate::{\n+    context::CompletionContext,\n+    render::{render_resolution_with_import, RenderContext},\n+    ImportEdit,\n+};\n+\n+use super::Completions;\n+\n+pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+    if !ctx.config.enable_autoimport_completions {\n+        return None;\n+    }\n+    if ctx.attribute_under_caret.is_some() || ctx.mod_declaration_under_caret.is_some() {\n+        return None;\n+    }\n+    let potential_import_name = ctx.token.to_string();\n+    if potential_import_name.len() < 2 {\n+        return None;\n+    }\n+    let _p = profile::span(\"import_on_the_fly\").detail(|| potential_import_name.to_string());\n+\n+    let current_module = ctx.scope.module()?;\n+    let anchor = ctx.name_ref_syntax.as_ref()?;\n+    let import_scope = ImportScope::find_insert_use_container(anchor.syntax(), &ctx.sema)?;\n+\n+    let user_input_lowercased = potential_import_name.to_lowercase();\n+    let mut all_mod_paths = imports_locator::find_similar_imports(\n+        &ctx.sema,\n+        ctx.krate?,\n+        Some(40),\n+        potential_import_name,\n+        true,\n+        true,\n+    )\n+    .filter_map(|import_candidate| {\n+        Some(match import_candidate {\n+            Either::Left(module_def) => {\n+                (current_module.find_use_path(ctx.db, module_def)?, ScopeDef::ModuleDef(module_def))\n+            }\n+            Either::Right(macro_def) => {\n+                (current_module.find_use_path(ctx.db, macro_def)?, ScopeDef::MacroDef(macro_def))\n+            }\n+        })\n+    })\n+    .filter(|(mod_path, _)| mod_path.len() > 1)\n+    .collect::<Vec<_>>();\n+\n+    all_mod_paths.sort_by_cached_key(|(mod_path, _)| {\n+        compute_fuzzy_completion_order_key(mod_path, &user_input_lowercased)\n+    });\n+\n+    acc.add_all(all_mod_paths.into_iter().filter_map(|(import_path, definition)| {\n+        render_resolution_with_import(\n+            RenderContext::new(ctx),\n+            ImportEdit { import_path, import_scope: import_scope.clone() },\n+            &definition,\n+        )\n+    }));\n+    Some(())\n+}\n+\n+fn compute_fuzzy_completion_order_key(\n+    proposed_mod_path: &ModPath,\n+    user_input_lowercased: &str,\n+) -> usize {\n+    mark::hit!(certain_fuzzy_order_test);\n+    let proposed_import_name = match proposed_mod_path.segments.last() {\n+        Some(name) => name.to_string().to_lowercase(),\n+        None => return usize::MAX,\n+    };\n+    match proposed_import_name.match_indices(user_input_lowercased).next() {\n+        Some((first_matching_index, _)) => first_matching_index,\n+        None => usize::MAX,\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+    use test_utils::mark;\n+\n+    use crate::{\n+        item::CompletionKind,\n+        test_utils::{check_edit, completion_list},\n+    };\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list(ra_fixture, CompletionKind::Magic);\n+        expect.assert_eq(&actual);\n+    }\n+\n+    #[test]\n+    fn function_fuzzy_completion() {\n+        check_edit(\n+            \"stdin\",\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod io {\n+    pub fn stdin() {}\n+};\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    stdi$0\n+}\n+\"#,\n+            r#\"\n+use dep::io::stdin;\n+\n+fn main() {\n+    stdin()$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_fuzzy_completion() {\n+        check_edit(\n+            \"macro_with_curlies!\",\n+            r#\"\n+//- /lib.rs crate:dep\n+/// Please call me as macro_with_curlies! {}\n+#[macro_export]\n+macro_rules! macro_with_curlies {\n+    () => {}\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    curli$0\n+}\n+\"#,\n+            r#\"\n+use dep::macro_with_curlies;\n+\n+fn main() {\n+    macro_with_curlies! {$0}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_fuzzy_completion() {\n+        check_edit(\n+            \"ThirdStruct\",\n+            r#\"\n+//- /lib.rs crate:dep\n+pub struct FirstStruct;\n+pub mod some_module {\n+    pub struct SecondStruct;\n+    pub struct ThirdStruct;\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::{FirstStruct, some_module::SecondStruct};\n+\n+fn main() {\n+    this$0\n+}\n+\"#,\n+            r#\"\n+use dep::{FirstStruct, some_module::{SecondStruct, ThirdStruct}};\n+\n+fn main() {\n+    ThirdStruct\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fuzzy_completions_come_in_specific_order() {\n+        mark::check!(certain_fuzzy_order_test);\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub struct FirstStruct;\n+pub mod some_module {\n+    // already imported, omitted\n+    pub struct SecondStruct;\n+    // does not contain all letters from the query, omitted\n+    pub struct UnrelatedOne;\n+    // contains all letters from the query, but not in sequence, displayed last\n+    pub struct ThiiiiiirdStruct;\n+    // contains all letters from the query, but not in the beginning, displayed second\n+    pub struct AfterThirdStruct;\n+    // contains all letters from the query in the begginning, displayed first\n+    pub struct ThirdStruct;\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::{FirstStruct, some_module::SecondStruct};\n+\n+fn main() {\n+    hir$0\n+}\n+\"#,\n+            expect![[r#\"\n+                st dep::some_module::ThirdStruct\n+                st dep::some_module::AfterThirdStruct\n+                st dep::some_module::ThiiiiiirdStruct\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_propose_names_in_scope() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::test_mod::TestStruct;\n+fn main() {\n+    TestSt$0\n+}\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+}"}, {"sha": "ac5596ca49d598483450ac79fc772d5ef0a3d5e3", "filename": "crates/completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 3, "deletions": 248, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -2,17 +2,11 @@\n \n use std::iter;\n \n-use either::Either;\n-use hir::{Adt, ModPath, ModuleDef, ScopeDef, Type};\n-use ide_db::helpers::insert_use::ImportScope;\n-use ide_db::imports_locator;\n+use hir::{Adt, ModuleDef, ScopeDef, Type};\n use syntax::AstNode;\n use test_utils::mark;\n \n-use crate::{\n-    render::{render_resolution_with_import, RenderContext},\n-    CompletionContext, Completions, ImportEdit,\n-};\n+use crate::{CompletionContext, Completions};\n \n pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n     if !(ctx.is_trivial_path || ctx.is_pat_binding_or_const) {\n@@ -45,10 +39,6 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         }\n         acc.add_resolution(ctx, name.to_string(), &res)\n     });\n-\n-    if ctx.config.enable_autoimport_completions {\n-        fuzzy_completion(acc, ctx);\n-    }\n }\n \n fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &Type) {\n@@ -77,124 +67,13 @@ fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &T\n     }\n }\n \n-// Feature: Fuzzy Completion and Autoimports\n-//\n-// When completing names in the current scope, proposes additional imports from other modules or crates,\n-// if they can be qualified in the scope and their name contains all symbols from the completion input\n-// (case-insensitive, in any order or places).\n-//\n-// ```\n-// fn main() {\n-//     pda$0\n-// }\n-// # pub mod std { pub mod marker { pub struct PhantomData { } } }\n-// ```\n-// ->\n-// ```\n-// use std::marker::PhantomData;\n-//\n-// fn main() {\n-//     PhantomData\n-// }\n-// # pub mod std { pub mod marker { pub struct PhantomData { } } }\n-// ```\n-//\n-// .Fuzzy search details\n-//\n-// To avoid an excessive amount of the results returned, completion input is checked for inclusion in the names only\n-// (i.e. in `HashMap` in the `std::collections::HashMap` path).\n-// For the same reasons, avoids searching for any imports for inputs with their length less that 2 symbols.\n-//\n-// .Merge Behavior\n-//\n-// It is possible to configure how use-trees are merged with the `importMergeBehavior` setting.\n-// Mimics the corresponding behavior of the `Auto Import` feature.\n-//\n-// .LSP and performance implications\n-//\n-// The feature is enabled only if the LSP client supports LSP protocol version 3.16+ and reports the `additionalTextEdits`\n-// (case sensitive) resolve client capability in its client capabilities.\n-// This way the server is able to defer the costly computations, doing them for a selected completion item only.\n-// For clients with no such support, all edits have to be calculated on the completion request, including the fuzzy search completion ones,\n-// which might be slow ergo the feature is automatically disabled.\n-//\n-// .Feature toggle\n-//\n-// The feature can be forcefully turned off in the settings with the `rust-analyzer.completion.enableAutoimportCompletions` flag.\n-// Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corredponding\n-// capability enabled.\n-fn fuzzy_completion(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let potential_import_name = ctx.token.to_string();\n-    let _p = profile::span(\"fuzzy_completion\").detail(|| potential_import_name.clone());\n-\n-    if potential_import_name.len() < 2 {\n-        return None;\n-    }\n-\n-    let current_module = ctx.scope.module()?;\n-    let anchor = ctx.name_ref_syntax.as_ref()?;\n-    let import_scope = ImportScope::find_insert_use_container(anchor.syntax(), &ctx.sema)?;\n-\n-    let user_input_lowercased = potential_import_name.to_lowercase();\n-    let mut all_mod_paths = imports_locator::find_similar_imports(\n-        &ctx.sema,\n-        ctx.krate?,\n-        Some(40),\n-        potential_import_name,\n-        true,\n-        true,\n-    )\n-    .filter_map(|import_candidate| {\n-        Some(match import_candidate {\n-            Either::Left(module_def) => {\n-                (current_module.find_use_path(ctx.db, module_def)?, ScopeDef::ModuleDef(module_def))\n-            }\n-            Either::Right(macro_def) => {\n-                (current_module.find_use_path(ctx.db, macro_def)?, ScopeDef::MacroDef(macro_def))\n-            }\n-        })\n-    })\n-    .filter(|(mod_path, _)| mod_path.len() > 1)\n-    .collect::<Vec<_>>();\n-\n-    all_mod_paths.sort_by_cached_key(|(mod_path, _)| {\n-        compute_fuzzy_completion_order_key(mod_path, &user_input_lowercased)\n-    });\n-\n-    acc.add_all(all_mod_paths.into_iter().filter_map(|(import_path, definition)| {\n-        render_resolution_with_import(\n-            RenderContext::new(ctx),\n-            ImportEdit { import_path, import_scope: import_scope.clone() },\n-            &definition,\n-        )\n-    }));\n-    Some(())\n-}\n-\n-fn compute_fuzzy_completion_order_key(\n-    proposed_mod_path: &ModPath,\n-    user_input_lowercased: &str,\n-) -> usize {\n-    mark::hit!(certain_fuzzy_order_test);\n-    let proposed_import_name = match proposed_mod_path.segments.last() {\n-        Some(name) => name.to_string().to_lowercase(),\n-        None => return usize::MAX,\n-    };\n-    match proposed_import_name.match_indices(user_input_lowercased).next() {\n-        Some((first_matching_index, _)) => first_matching_index,\n-        None => usize::MAX,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n     use test_utils::mark;\n \n     use crate::{\n-        test_utils::{\n-            check_edit, check_edit_with_config, completion_list_with_config, TEST_CONFIG,\n-        },\n+        test_utils::{check_edit, completion_list_with_config, TEST_CONFIG},\n         CompletionConfig, CompletionKind,\n     };\n \n@@ -855,128 +734,4 @@ impl My$0\n             \"#]],\n         )\n     }\n-\n-    #[test]\n-    fn function_fuzzy_completion() {\n-        check_edit_with_config(\n-            TEST_CONFIG,\n-            \"stdin\",\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod io {\n-    pub fn stdin() {}\n-};\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    stdi$0\n-}\n-\"#,\n-            r#\"\n-use dep::io::stdin;\n-\n-fn main() {\n-    stdin()$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn macro_fuzzy_completion() {\n-        check_edit_with_config(\n-            TEST_CONFIG,\n-            \"macro_with_curlies!\",\n-            r#\"\n-//- /lib.rs crate:dep\n-/// Please call me as macro_with_curlies! {}\n-#[macro_export]\n-macro_rules! macro_with_curlies {\n-    () => {}\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    curli$0\n-}\n-\"#,\n-            r#\"\n-use dep::macro_with_curlies;\n-\n-fn main() {\n-    macro_with_curlies! {$0}\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn struct_fuzzy_completion() {\n-        check_edit_with_config(\n-            TEST_CONFIG,\n-            \"ThirdStruct\",\n-            r#\"\n-//- /lib.rs crate:dep\n-pub struct FirstStruct;\n-pub mod some_module {\n-    pub struct SecondStruct;\n-    pub struct ThirdStruct;\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::{FirstStruct, some_module::SecondStruct};\n-\n-fn main() {\n-    this$0\n-}\n-\"#,\n-            r#\"\n-use dep::{FirstStruct, some_module::{SecondStruct, ThirdStruct}};\n-\n-fn main() {\n-    ThirdStruct\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fuzzy_completions_come_in_specific_order() {\n-        mark::check!(certain_fuzzy_order_test);\n-        check_with_config(\n-            TEST_CONFIG,\n-            r#\"\n-//- /lib.rs crate:dep\n-pub struct FirstStruct;\n-pub mod some_module {\n-    // already imported, omitted\n-    pub struct SecondStruct;\n-    // does not contain all letters from the query, omitted\n-    pub struct UnrelatedOne;\n-    // contains all letters from the query, but not in sequence, displayed last\n-    pub struct ThiiiiiirdStruct;\n-    // contains all letters from the query, but not in the beginning, displayed second\n-    pub struct AfterThirdStruct;\n-    // contains all letters from the query in the begginning, displayed first\n-    pub struct ThirdStruct;\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::{FirstStruct, some_module::SecondStruct};\n-\n-fn main() {\n-    hir$0\n-}\n-\"#,\n-            expect![[r#\"\n-                fn main()           fn main()\n-                st SecondStruct\n-                st FirstStruct\n-                md dep\n-                st dep::some_module::ThirdStruct\n-                st dep::some_module::AfterThirdStruct\n-                st dep::some_module::ThiiiiiirdStruct\n-            \"#]],\n-        );\n-    }\n }"}, {"sha": "58fc700f33d5c00ce75567fc317b2b1285645b5f", "filename": "crates/completion/src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fconfig.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -4,7 +4,7 @@\n //! module, and we use to statically check that we only produce snippet\n //! completions if we are allowed to.\n \n-use ide_db::helpers::{insert_use::MergeBehavior, SnippetCap};\n+use ide_db::helpers::{insert_use::InsertUseConfig, SnippetCap};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct CompletionConfig {\n@@ -13,5 +13,5 @@ pub struct CompletionConfig {\n     pub add_call_parenthesis: bool,\n     pub add_call_argument_snippets: bool,\n     pub snippet_cap: Option<SnippetCap>,\n-    pub merge: Option<MergeBehavior>,\n+    pub insert_use: InsertUseConfig,\n }"}, {"sha": "ee1b822e7c04e9a78865b9f3b28d619a477e0ac5", "filename": "crates/completion/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Flib.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -127,6 +127,7 @@ pub fn completions(\n     completions::macro_in_item_position::complete_macro_in_item_position(&mut acc, &ctx);\n     completions::trait_impl::complete_trait_impl(&mut acc, &ctx);\n     completions::mod_::complete_mod(&mut acc, &ctx);\n+    completions::flyimport::import_on_the_fly(&mut acc, &ctx);\n \n     Some(acc)\n }\n@@ -153,7 +154,9 @@ pub fn resolve_completion_edits(\n         })\n         .find(|mod_path| mod_path.to_string() == full_import_path)?;\n \n-    ImportEdit { import_path, import_scope }.to_text_edit(config.merge).map(|edit| vec![edit])\n+    ImportEdit { import_path, import_scope }\n+        .to_text_edit(config.insert_use.merge)\n+        .map(|edit| vec![edit])\n }\n \n #[cfg(test)]"}, {"sha": "820dd01d1f7e7855d1b76b406e1500b84bdef020", "filename": "crates/completion/src/render.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -51,11 +51,16 @@ pub(crate) fn render_resolution_with_import<'a>(\n     import_edit: ImportEdit,\n     resolution: &ScopeDef,\n ) -> Option<CompletionItem> {\n-    Render::new(ctx).render_resolution(\n-        import_edit.import_path.segments.last()?.to_string(),\n-        Some(import_edit),\n-        resolution,\n-    )\n+    Render::new(ctx)\n+        .render_resolution(\n+            import_edit.import_path.segments.last()?.to_string(),\n+            Some(import_edit),\n+            resolution,\n+        )\n+        .map(|mut item| {\n+            item.completion_kind = CompletionKind::Magic;\n+            item\n+        })\n }\n \n /// Interface for data and methods required for items rendering."}, {"sha": "6ea6da9893c8bfb60bae3eb4f4dfa38ecc09a3a9", "filename": "crates/completion/src/test_utils.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -1,9 +1,12 @@\n //! Runs completion for testing purposes.\n \n-use hir::Semantics;\n+use hir::{PrefixKind, Semantics};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n-    helpers::{insert_use::MergeBehavior, SnippetCap},\n+    helpers::{\n+        insert_use::{InsertUseConfig, MergeBehavior},\n+        SnippetCap,\n+    },\n     RootDatabase,\n };\n use itertools::Itertools;\n@@ -19,7 +22,10 @@ pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n     add_call_parenthesis: true,\n     add_call_argument_snippets: true,\n     snippet_cap: SnippetCap::new(true),\n-    merge: Some(MergeBehavior::Full),\n+    insert_use: InsertUseConfig {\n+        merge: Some(MergeBehavior::Full),\n+        prefix_kind: PrefixKind::Plain,\n+    },\n };\n \n /// Creates analysis from a multi-file fixture, returns positions marked with $0.\n@@ -110,7 +116,7 @@ pub(crate) fn check_edit_with_config(\n \n     let mut combined_edit = completion.text_edit().to_owned();\n     if let Some(import_text_edit) =\n-        completion.import_to_add().and_then(|edit| edit.to_text_edit(config.merge))\n+        completion.import_to_add().and_then(|edit| edit.to_text_edit(config.insert_use.merge))\n     {\n         combined_edit.union(import_text_edit).expect(\n             \"Failed to apply completion resolve changes: change ranges overlap, but should not\","}, {"sha": "f8d69382e03356f2ef38c95e70ff992dfd71529c", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -80,7 +80,7 @@ pub use crate::{\n         HlRange,\n     },\n };\n-pub use assists::{Assist, AssistConfig, AssistId, AssistKind, InsertUseConfig};\n+pub use assists::{Assist, AssistConfig, AssistId, AssistKind};\n pub use completion::{\n     CompletionConfig, CompletionItem, CompletionItemKind, CompletionScore, ImportEdit,\n     InsertTextFormat,"}, {"sha": "0dcc4dd29dbda85949abf16735bf7b55ba260c15", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -1,5 +1,6 @@\n //! A module with ide helpers for high-level ide features.\n pub mod insert_use;\n+pub mod import_assets;\n \n use hir::{Crate, Enum, Module, ScopeDef, Semantics, Trait};\n use syntax::ast::{self, make};"}, {"sha": "edc3da318e02611d021935a8e59b3e549fc1019a", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "renamed", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -1,19 +1,17 @@\n //! Look up accessible paths for items.\n use either::Either;\n use hir::{AsAssocItem, AssocItemContainer, ModuleDef, Semantics};\n-use ide_db::{imports_locator, RootDatabase};\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode, SyntaxNode};\n \n-use crate::assist_config::InsertUseConfig;\n+use crate::{imports_locator, RootDatabase};\n+\n+use super::insert_use::InsertUseConfig;\n \n #[derive(Debug)]\n-pub(crate) enum ImportCandidate {\n-    /// Simple name like 'HashMap'\n-    UnqualifiedName(PathImportCandidate),\n-    /// First part of the qualified name.\n-    /// For 'std::collections::HashMap', that will be 'std'.\n-    QualifierStart(PathImportCandidate),\n+pub enum ImportCandidate {\n+    // A path, qualified (`std::collections::HashMap`) or not (`HashMap`).\n+    Path(PathImportCandidate),\n     /// A trait associated function (with no self parameter) or associated constant.\n     /// For 'test_mod::TestEnum::test_function', `ty` is the `test_mod::TestEnum` expression type\n     /// and `name` is the `test_function`\n@@ -25,25 +23,26 @@ pub(crate) enum ImportCandidate {\n }\n \n #[derive(Debug)]\n-pub(crate) struct TraitImportCandidate {\n-    pub(crate) ty: hir::Type,\n-    pub(crate) name: ast::NameRef,\n+pub struct TraitImportCandidate {\n+    pub ty: hir::Type,\n+    pub name: ast::NameRef,\n }\n \n #[derive(Debug)]\n-pub(crate) struct PathImportCandidate {\n-    pub(crate) name: ast::NameRef,\n+pub struct PathImportCandidate {\n+    pub qualifier: Option<ast::Path>,\n+    pub name: ast::NameRef,\n }\n \n #[derive(Debug)]\n-pub(crate) struct ImportAssets {\n+pub struct ImportAssets {\n     import_candidate: ImportCandidate,\n     module_with_name_to_import: hir::Module,\n     syntax_under_caret: SyntaxNode,\n }\n \n impl ImportAssets {\n-    pub(crate) fn for_method_call(\n+    pub fn for_method_call(\n         method_call: ast::MethodCallExpr,\n         sema: &Semantics<RootDatabase>,\n     ) -> Option<Self> {\n@@ -56,7 +55,7 @@ impl ImportAssets {\n         })\n     }\n \n-    pub(crate) fn for_regular_path(\n+    pub fn for_regular_path(\n         path_under_caret: ast::Path,\n         sema: &Semantics<RootDatabase>,\n     ) -> Option<Self> {\n@@ -73,24 +72,23 @@ impl ImportAssets {\n         })\n     }\n \n-    pub(crate) fn syntax_under_caret(&self) -> &SyntaxNode {\n+    pub fn syntax_under_caret(&self) -> &SyntaxNode {\n         &self.syntax_under_caret\n     }\n \n-    pub(crate) fn import_candidate(&self) -> &ImportCandidate {\n+    pub fn import_candidate(&self) -> &ImportCandidate {\n         &self.import_candidate\n     }\n \n     fn get_search_query(&self) -> &str {\n         match &self.import_candidate {\n-            ImportCandidate::UnqualifiedName(candidate)\n-            | ImportCandidate::QualifierStart(candidate) => candidate.name.text(),\n+            ImportCandidate::Path(candidate) => candidate.name.text(),\n             ImportCandidate::TraitAssocItem(candidate)\n             | ImportCandidate::TraitMethod(candidate) => candidate.name.text(),\n         }\n     }\n \n-    pub(crate) fn search_for_imports(\n+    pub fn search_for_imports(\n         &self,\n         sema: &Semantics<RootDatabase>,\n         config: &InsertUseConfig,\n@@ -101,7 +99,7 @@ impl ImportAssets {\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n     #[allow(dead_code)]\n-    pub(crate) fn search_for_relative_paths(\n+    pub fn search_for_relative_paths(\n         &self,\n         sema: &Semantics<RootDatabase>,\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n@@ -253,10 +251,14 @@ impl ImportCandidate {\n                     _ => return None,\n                 }\n             } else {\n-                ImportCandidate::QualifierStart(PathImportCandidate { name: qualifier_start })\n+                ImportCandidate::Path(PathImportCandidate {\n+                    qualifier: Some(qualifier),\n+                    name: qualifier_start,\n+                })\n             }\n         } else {\n-            ImportCandidate::UnqualifiedName(PathImportCandidate {\n+            ImportCandidate::Path(PathImportCandidate {\n+                qualifier: None,\n                 name: segment.syntax().descendants().find_map(ast::NameRef::cast)?,\n             })\n         };", "previous_filename": "crates/assists/src/utils/import_assets.rs"}, {"sha": "877d4f1c79a53de5cf2cb9359c914d1eba173a6c", "filename": "crates/ide_db/src/helpers/insert_use.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -15,6 +15,12 @@ use syntax::{\n };\n use test_utils::mark;\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub struct InsertUseConfig {\n+    pub merge: Option<MergeBehavior>,\n+    pub prefix_kind: hir::PrefixKind,\n+}\n+\n #[derive(Debug, Clone)]\n pub enum ImportScope {\n     File(ast::SourceFile),"}, {"sha": "d111fba9257f13c5da3c5321bda9dee2f955a228", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -12,6 +12,8 @@ use crate::{\n use either::Either;\n use rustc_hash::FxHashSet;\n \n+const QUERY_SEARCH_LIMIT: usize = 40;\n+\n pub fn find_exact_imports<'a>(\n     sema: &Semantics<'a, RootDatabase>,\n     krate: Crate,\n@@ -24,11 +26,11 @@ pub fn find_exact_imports<'a>(\n         {\n             let mut local_query = symbol_index::Query::new(name_to_import.clone());\n             local_query.exact();\n-            local_query.limit(40);\n+            local_query.limit(QUERY_SEARCH_LIMIT);\n             local_query\n         },\n         import_map::Query::new(name_to_import)\n-            .limit(40)\n+            .limit(QUERY_SEARCH_LIMIT)\n             .name_only()\n             .search_mode(import_map::SearchMode::Equals)\n             .case_sensitive(),"}, {"sha": "a02c8327fe2f77fb4befda9e85addbabbba5a045", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -3,6 +3,7 @@\n use std::{env, path::PathBuf, str::FromStr, sync::Arc, time::Instant};\n \n use anyhow::{bail, format_err, Result};\n+use hir::PrefixKind;\n use ide::{\n     Analysis, AnalysisHost, Change, CompletionConfig, DiagnosticsConfig, FilePosition, LineCol,\n };\n@@ -11,7 +12,7 @@ use ide_db::{\n         salsa::{Database, Durability},\n         FileId,\n     },\n-    helpers::SnippetCap,\n+    helpers::{insert_use::InsertUseConfig, SnippetCap},\n };\n use vfs::AbsPathBuf;\n \n@@ -96,7 +97,7 @@ impl BenchCmd {\n                         add_call_parenthesis: true,\n                         add_call_argument_snippets: true,\n                         snippet_cap: SnippetCap::new(true),\n-                        merge: None,\n+                        insert_use: InsertUseConfig { merge: None, prefix_kind: PrefixKind::Plain },\n                     };\n                     let res = do_work(&mut host, file_id, |analysis| {\n                         analysis.completions(&options, file_position)"}, {"sha": "ce9655818c6821bb122d140135b6e22526ccf68d", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -11,11 +11,11 @@ use std::{convert::TryFrom, ffi::OsString, iter, path::PathBuf};\n \n use flycheck::FlycheckConfig;\n use hir::PrefixKind;\n-use ide::{\n-    AssistConfig, CompletionConfig, DiagnosticsConfig, HoverConfig, InlayHintsConfig,\n-    InsertUseConfig,\n+use ide::{AssistConfig, CompletionConfig, DiagnosticsConfig, HoverConfig, InlayHintsConfig};\n+use ide_db::helpers::{\n+    insert_use::{InsertUseConfig, MergeBehavior},\n+    SnippetCap,\n };\n-use ide_db::helpers::{insert_use::MergeBehavior, SnippetCap};\n use itertools::Itertools;\n use lsp_types::{ClientCapabilities, MarkupKind};\n use project_model::{CargoConfig, ProjectJson, ProjectJsonData, ProjectManifest};\n@@ -542,11 +542,18 @@ impl Config {\n             max_length: self.data.inlayHints_maxLength,\n         }\n     }\n-    fn merge_behavior(&self) -> Option<MergeBehavior> {\n-        match self.data.assist_importMergeBehavior {\n-            MergeBehaviorDef::None => None,\n-            MergeBehaviorDef::Full => Some(MergeBehavior::Full),\n-            MergeBehaviorDef::Last => Some(MergeBehavior::Last),\n+    fn insert_use_config(&self) -> InsertUseConfig {\n+        InsertUseConfig {\n+            merge: match self.data.assist_importMergeBehavior {\n+                MergeBehaviorDef::None => None,\n+                MergeBehaviorDef::Full => Some(MergeBehavior::Full),\n+                MergeBehaviorDef::Last => Some(MergeBehavior::Last),\n+            },\n+            prefix_kind: match self.data.assist_importPrefix {\n+                ImportPrefixDef::Plain => PrefixKind::Plain,\n+                ImportPrefixDef::ByCrate => PrefixKind::ByCrate,\n+                ImportPrefixDef::BySelf => PrefixKind::BySelf,\n+            },\n         }\n     }\n     pub fn completion(&self) -> CompletionConfig {\n@@ -556,7 +563,7 @@ impl Config {\n                 && completion_item_edit_resolve(&self.caps),\n             add_call_parenthesis: self.data.completion_addCallParenthesis,\n             add_call_argument_snippets: self.data.completion_addCallArgumentSnippets,\n-            merge: self.merge_behavior(),\n+            insert_use: self.insert_use_config(),\n             snippet_cap: SnippetCap::new(try_or!(\n                 self.caps\n                     .text_document\n@@ -575,7 +582,11 @@ impl Config {\n             snippet_cap: SnippetCap::new(self.experimental(\"snippetTextEdit\")),\n             allowed: None,\n             insert_use: InsertUseConfig {\n-                merge: self.merge_behavior(),\n+                merge: match self.data.assist_importMergeBehavior {\n+                    MergeBehaviorDef::None => None,\n+                    MergeBehaviorDef::Full => Some(MergeBehavior::Full),\n+                    MergeBehaviorDef::Last => Some(MergeBehavior::Last),\n+                },\n                 prefix_kind: match self.data.assist_importPrefix {\n                     ImportPrefixDef::Plain => PrefixKind::Plain,\n                     ImportPrefixDef::ByCrate => PrefixKind::ByCrate,"}, {"sha": "1ff2d3fea659a76ca95a289c0a7981d3a1a42b3d", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a349f280ff1c6d0b57df80aa3d6720474e4b00a/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=9a349f280ff1c6d0b57df80aa3d6720474e4b00a", "patch": "@@ -861,8 +861,9 @@ pub(crate) fn rename_error(err: RenameError) -> crate::LspError {\n \n #[cfg(test)]\n mod tests {\n+    use hir::PrefixKind;\n     use ide::Analysis;\n-    use ide_db::helpers::SnippetCap;\n+    use ide_db::helpers::{insert_use::InsertUseConfig, SnippetCap};\n \n     use super::*;\n \n@@ -887,7 +888,7 @@ mod tests {\n                     add_call_parenthesis: true,\n                     add_call_argument_snippets: true,\n                     snippet_cap: SnippetCap::new(true),\n-                    merge: None,\n+                    insert_use: InsertUseConfig { merge: None, prefix_kind: PrefixKind::Plain },\n                 },\n                 ide_db::base_db::FilePosition { file_id, offset },\n             )"}]}