{"sha": "4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZDgxZDBiZDlhYzIzZWFhNTMzMzVmMDNlMTJlZjUyZTVmY2I4ZDA=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-29T06:19:56Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-08-31T03:44:40Z"}, "message": "Refactoring: use context.budget()", "tree": {"sha": "ac370c47a670db2c9b7355c4c426b4adc9e12186", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac370c47a670db2c9b7355c4c426b4adc9e12186"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0", "html_url": "https://github.com/rust-lang/rust/commit/4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16894b9cd2573291d31c1e1a3b529ffa51a97ce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/16894b9cd2573291d31c1e1a3b529ffa51a97ce1", "html_url": "https://github.com/rust-lang/rust/commit/16894b9cd2573291d31c1e1a3b529ffa51a97ce1"}], "stats": {"total": 98, "additions": 19, "deletions": 79}, "files": [{"sha": "8c81aed87e6119a4ab2ff5f52ef33fb2e1796a74", "filename": "src/items.rs", "status": "modified", "additions": 19, "deletions": 79, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0", "patch": "@@ -533,11 +533,7 @@ pub fn format_impl(\n         let where_budget = if result.contains('\\n') {\n             context.config.max_width()\n         } else {\n-            context\n-                .config\n-                .max_width()\n-                .checked_sub(last_line_width(&result))\n-                .unwrap_or(0)\n+            context.budget(last_line_width(&result))\n         };\n         let option = WhereClauseOption::snuggled(&ref_and_type);\n         let where_clause_str = try_opt!(rewrite_where_clause(\n@@ -756,11 +752,7 @@ fn format_impl_ref_and_type(\n         };\n         let used_space = last_line_width(&result) + trait_ref_overhead + curly_brace_overhead;\n         // 1 = space before the type.\n-        let budget = context\n-            .config\n-            .max_width()\n-            .checked_sub(used_space + 1)\n-            .unwrap_or(0);\n+        let budget = context.budget(used_space + 1);\n         if let Some(self_ty_str) = self_ty.rewrite(context, Shape::legacy(budget, offset)) {\n             if !self_ty_str.contains('\\n') {\n                 if trait_ref.is_some() {\n@@ -781,7 +773,7 @@ fn format_impl_ref_and_type(\n         if trait_ref.is_some() {\n             result.push_str(\"for \");\n         }\n-        let budget = context.config.max_width() - last_line_width(&result);\n+        let budget = context.budget(last_line_width(&result));\n         let type_offset = match context.config.where_style() {\n             Style::Legacy => new_line_offset + trait_ref_overhead,\n             Style::Rfc => new_line_offset,\n@@ -925,12 +917,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             Density::Tall\n         };\n \n-        let where_budget = try_opt!(\n-            context\n-                .config\n-                .max_width()\n-                .checked_sub(last_line_width(&result))\n-        );\n+        let where_budget = context.budget(last_line_width(&result));\n         let pos_before_where = if type_param_bounds.is_empty() {\n             generics.where_clause.span.lo()\n         } else {\n@@ -1076,11 +1063,7 @@ pub fn format_struct_struct(\n             let overhead = if fields.is_empty() { 3 } else { 2 };\n             if (context.config.item_brace_style() == BraceStyle::AlwaysNextLine &&\n                 !fields.is_empty()) ||\n-                context\n-                    .config\n-                    .max_width()\n-                    .checked_sub(result.len())\n-                    .unwrap_or(0) < overhead\n+                context.config.max_width() < overhead + result.len()\n             {\n                 format!(\"\\n{}{{\", offset.block_only().to_string(context.config))\n             } else {\n@@ -1118,11 +1101,7 @@ pub fn format_struct_struct(\n     }\n \n     // 3 = ` ` and ` }`\n-    let one_line_budget = context\n-        .config\n-        .max_width()\n-        .checked_sub(result.len() + 3 + offset.width())\n-        .unwrap_or(0);\n+    let one_line_budget = context.budget(result.len() + 3 + offset.width());\n     let one_line_budget =\n         one_line_width.map_or(0, |one_line_width| min(one_line_width, one_line_budget));\n \n@@ -1282,12 +1261,7 @@ pub fn rewrite_type_alias(\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n-    let where_budget = try_opt!(\n-        context\n-            .config\n-            .max_width()\n-            .checked_sub(last_line_width(&result))\n-    );\n+    let where_budget = context.budget(last_line_width(&result));\n     let option = WhereClauseOption::snuggled(&result);\n     let where_clause_str = try_opt!(rewrite_where_clause(\n         context,\n@@ -1310,11 +1284,7 @@ pub fn rewrite_type_alias(\n     let line_width = last_line_width(&result);\n     // This checked_sub may fail as the extra space after '=' is not taken into account\n     // In that case the budget is set to 0 which will make ty.rewrite retry on a new line\n-    let budget = context\n-        .config\n-        .max_width()\n-        .checked_sub(indent.width() + line_width + \";\".len())\n-        .unwrap_or(0);\n+    let budget = context.budget(indent.width() + line_width + \";\".len());\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n     let ty_str = try_opt!(\n@@ -1327,12 +1297,7 @@ pub fn rewrite_type_alias(\n                 let type_indent = indent.block_indent(context.config);\n                 result.push('\\n');\n                 result.push_str(&type_indent.to_string(context.config));\n-                let budget = try_opt!(\n-                    context\n-                        .config\n-                        .max_width()\n-                        .checked_sub(type_indent.width() + \";\".len())\n-                );\n+                let budget = context.budget(type_indent.width() + \";\".len());\n                 ty.rewrite(context, Shape::legacy(budget, type_indent))\n             })\n     );\n@@ -1516,7 +1481,7 @@ pub fn rewrite_static(\n     if let Some(expr) = expr_opt {\n         let lhs = format!(\"{}{} =\", prefix, ty_str);\n         // 1 = ;\n-        let remaining_width = context.config.max_width() - offset.block_indent - 1;\n+        let remaining_width = context.budget(offset.block_indent + 1);\n         rewrite_assign_rhs(\n             context,\n             lhs,\n@@ -1563,7 +1528,7 @@ pub fn rewrite_associated_type(\n         let ty_str = try_opt!(ty.rewrite(\n             context,\n             Shape::legacy(\n-                context.config.max_width() - indent.block_indent - prefix.len() - 2,\n+                context.budget(indent.block_indent + prefix.len() + 2),\n                 indent.block_only(),\n             ),\n         ));\n@@ -1771,11 +1736,7 @@ fn rewrite_fn_base(\n         2\n     };\n     let used_width = last_line_used_width(&result, indent.width());\n-    let one_line_budget = context\n-        .config\n-        .max_width()\n-        .checked_sub(used_width + overhead)\n-        .unwrap_or(0);\n+    let one_line_budget = context.budget(used_width + overhead);\n     let shape = Shape {\n         width: one_line_budget,\n         indent: indent,\n@@ -2011,11 +1972,7 @@ fn rewrite_fn_base(\n     };\n \n     if where_clause.predicates.len() == 1 && should_compress_where {\n-        let budget = context\n-            .config\n-            .max_width()\n-            .checked_sub(last_line_used_width(&result, indent.width()))\n-            .unwrap_or(0);\n+        let budget = context.budget(last_line_used_width(&result, indent.width()));\n         if let Some(where_clause_str) = rewrite_where_clause(\n             context,\n             where_clause,\n@@ -2294,27 +2251,19 @@ fn compute_budgets_for_args(\n             // 1 = `;`\n             used_space += 1;\n         }\n-        let one_line_budget = context\n-            .config\n-            .max_width()\n-            .checked_sub(used_space)\n-            .unwrap_or(0);\n+        let one_line_budget = context.budget(used_space);\n \n         if one_line_budget > 0 {\n             // 4 = \"() {\".len()\n             let (indent, multi_line_budget) = match context.config.fn_args_layout() {\n                 IndentStyle::Block => {\n                     let indent = indent.block_indent(context.config);\n-                    let budget =\n-                        try_opt!(context.config.max_width().checked_sub(indent.width() + 1));\n-                    (indent, budget)\n+                    (indent, context.budget(indent.width() + 1))\n                 }\n                 IndentStyle::Visual => {\n                     let indent = indent + result.len() + 1;\n                     let multi_line_overhead = indent.width() + if newline_brace { 2 } else { 4 };\n-                    let budget =\n-                        try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n-                    (indent, budget)\n+                    (indent, context.budget(multi_line_overhead))\n                 }\n             };\n \n@@ -2330,8 +2279,7 @@ fn compute_budgets_for_args(\n         // Account for `)` and possibly ` {`.\n         IndentStyle::Visual => new_indent.width() + if ret_str_len == 0 { 1 } else { 3 },\n     };\n-    let max_space = try_opt!(context.config.max_width().checked_sub(used_space));\n-    Some((0, max_space, new_indent))\n+    Some((0, context.budget(used_space), new_indent))\n }\n \n fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause, has_body: bool) -> bool {\n@@ -2744,11 +2692,7 @@ fn format_generics(\n     let mut result = try_opt!(rewrite_generics(context, generics, shape, span));\n \n     let same_line_brace = if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n-        let budget = context\n-            .config\n-            .max_width()\n-            .checked_sub(last_line_used_width(&result, offset.width()))\n-            .unwrap_or(0);\n+        let budget = context.budget(last_line_used_width(&result, offset.width()));\n         let option = WhereClauseOption::snuggled(&result);\n         let where_clause_str = try_opt!(rewrite_where_clause(\n             context,\n@@ -2769,11 +2713,7 @@ fn format_generics(\n             brace_style != BraceStyle::AlwaysNextLine\n     };\n     let total_used_width = last_line_used_width(&result, used_width);\n-    let remaining_budget = context\n-        .config\n-        .max_width()\n-        .checked_sub(total_used_width)\n-        .unwrap_or(0);\n+    let remaining_budget = context.budget(total_used_width);\n     // If the same line brace if forced, it indicates that we are rewriting an item with empty body,\n     // and hence we take the closer into account as well for one line budget.\n     // We assume that the closer has the same length as the opener."}]}