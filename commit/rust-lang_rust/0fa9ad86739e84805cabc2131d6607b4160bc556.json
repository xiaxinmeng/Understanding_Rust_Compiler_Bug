{"sha": "0fa9ad86739e84805cabc2131d6607b4160bc556", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmYTlhZDg2NzM5ZTg0ODA1Y2FiYzIxMzFkNjYwN2I0MTYwYmM1NTY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-07-10T01:28:00Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-07-15T19:59:48Z"}, "message": "rustpkg: Handle local git repositories\n\nrustpkg can now build code from a local git repository. In the\ncase where the local repo is in a directory not in the RUST_PATH,\nit checks out the repository into a directory in the first workspace\nin the RUST_PATH.\n\nThe tests no longer try to connect to github.com, which should\nsolve some of the sporadic failures we've been seeing.", "tree": {"sha": "0b0b89343702eb0798dec1e5c14ee1cce6e4f409", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b0b89343702eb0798dec1e5c14ee1cce6e4f409"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fa9ad86739e84805cabc2131d6607b4160bc556", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fa9ad86739e84805cabc2131d6607b4160bc556", "html_url": "https://github.com/rust-lang/rust/commit/0fa9ad86739e84805cabc2131d6607b4160bc556", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fa9ad86739e84805cabc2131d6607b4160bc556/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c22f6587049a13c74e1c07e0f6590ba356a3be9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c22f6587049a13c74e1c07e0f6590ba356a3be9", "html_url": "https://github.com/rust-lang/rust/commit/9c22f6587049a13c74e1c07e0f6590ba356a3be9"}], "stats": {"total": 481, "additions": 378, "deletions": 103}, "files": [{"sha": "17cb3521eb7da29bcaa5721dc6dd2e8ddad7ec85", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -28,8 +28,8 @@ pub fn build_lib(sysroot: @Path, root: Path, dest: Path, name: ~str, version: Ve\n \n     let pkg_src = PkgSrc {\n         root: root,\n-        dst_dir: dest,\n-        id: PkgId{ version: version, ..PkgId::new(name)},\n+        dst_dir: dest.clone(),\n+        id: PkgId{ version: version, ..PkgId::new(name, &dest.pop())},\n         libs: ~[mk_crate(lib)],\n         mains: ~[],\n         tests: ~[],\n@@ -42,8 +42,8 @@ pub fn build_exe(sysroot: @Path, root: Path, dest: Path, name: ~str, version: Ve\n                  main: Path) {\n     let pkg_src = PkgSrc {\n         root: root,\n-        dst_dir: dest,\n-        id: PkgId{ version: version, ..PkgId::new(name)},\n+        dst_dir: dest.clone(),\n+        id: PkgId{ version: version, ..PkgId::new(name, &dest.pop())},\n         libs: ~[],\n         mains: ~[mk_crate(main)],\n         tests: ~[],\n@@ -62,7 +62,7 @@ pub fn install_lib(sysroot: @Path,\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     debug!(\"workspace = %s\", workspace.to_str());\n     // make a PkgSrc\n-    let pkg_id = PkgId{ version: version, ..PkgId::new(name)};\n+    let pkg_id = PkgId{ version: version, ..PkgId::new(name, &workspace)};\n     let build_dir = workspace.push(\"build\");\n     let dst_dir = build_dir.push_rel(&*pkg_id.local_path);\n     let pkg_src = PkgSrc {\n@@ -81,7 +81,7 @@ pub fn install_lib(sysroot: @Path,\n \n pub fn install_exe(sysroot: @Path, workspace: Path, name: ~str, version: Version) {\n     default_ctxt(sysroot).install(&workspace, &PkgId{ version: version,\n-                                            ..PkgId::new(name)});\n+                                            ..PkgId::new(name, &workspace)});\n \n }\n "}, {"sha": "6b28b7ed6a112165da63d328f3f8ac99c523216c", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -18,11 +18,11 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n     for workspaces.iter().advance |p| {\n         let binfiles = os::list_dir(&p.push(\"bin\"));\n         for binfiles.iter().advance() |exec| {\n-            f(&PkgId::new(*exec));\n+            f(&PkgId::new(*exec, p));\n         }\n         let libfiles = os::list_dir(&p.push(\"lib\"));\n         for libfiles.iter().advance() |lib| {\n-            f(&PkgId::new(*lib));\n+            f(&PkgId::new(*lib, p));\n         }\n     }\n     true"}, {"sha": "d1000f7f845bb2d40f40ac809129e68b6035756d", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n pub use package_path::{RemotePath, LocalPath, normalize, hash};\n-use version::{try_getting_version, Version, NoVersion, split_version};\n+use version::{try_getting_version, try_getting_local_version,\n+              Version, NoVersion, split_version};\n \n /// Path-fragment identifier of a package such as\n /// 'github.com/graydon/test'; path must be a relative\n@@ -40,7 +41,10 @@ impl Eq for PkgId {\n }\n \n impl PkgId {\n-    pub fn new(s: &str) -> PkgId {\n+    // The PkgId constructor takes a Path argument so as\n+    // to be able to infer the version if the path refers\n+    // to a local git repository\n+    pub fn new(s: &str, work_dir: &Path) -> PkgId {\n         use conditions::bad_pkg_id::cond;\n \n         let mut given_version = None;\n@@ -71,9 +75,12 @@ impl PkgId {\n \n         let version = match given_version {\n             Some(v) => v,\n-            None => match try_getting_version(&remote_path) {\n+            None => match try_getting_local_version(&work_dir.push_rel(&*local_path)) {\n                 Some(v) => v,\n-                None => NoVersion\n+                None => match try_getting_version(&remote_path) {\n+                    Some(v) => v,\n+                    None => NoVersion\n+                }\n             }\n         };\n "}, {"sha": "668157bebb9152203a00ee4922d96dffe506329f", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -15,6 +15,7 @@ use std::{os, run, str};\n use context::*;\n use crate::Crate;\n use messages::*;\n+use source_control::git_clone;\n use path_util::pkgid_src_in_workspace;\n use util::compile_crate;\n use version::{ExactRevision, SemanticVersion, NoVersion};\n@@ -76,9 +77,10 @@ impl PkgSrc {\n         dir\n     }\n \n-    /// Try interpreting self's package id as a remote package, and try\n+    /// Try interpreting self's package id as a git repository, and try\n     /// fetching it and caching it in a local directory. Return the cached directory\n-    /// if this was successful, None otherwise\n+    /// if this was successful, None otherwise. Similarly, if the package id\n+    /// refers to a git repo on the local version, also check it out.\n     /// (right now we only support git)\n     pub fn fetch_git(&self) -> Option<Path> {\n \n@@ -87,6 +89,18 @@ impl PkgSrc {\n         // Git can't clone into a non-empty directory\n         os::remove_dir_recursive(&local);\n \n+        debug!(\"Checking whether %s exists locally. Cwd = %s, does it? %?\",\n+               self.id.local_path.to_str(),\n+               os::getcwd().to_str(),\n+               os::path_exists(&*self.id.local_path));\n+\n+        if os::path_exists(&*self.id.local_path) {\n+            debug!(\"%s exists locally! Cloning it into %s\",\n+                   self.id.local_path.to_str(), local.to_str());\n+            git_clone(&*self.id.local_path, &local, &self.id.version);\n+            return Some(local);\n+        }\n+\n         let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n         let branch_args = match self.id.version {\n                       NoVersion => ~[],"}, {"sha": "e4a345733eaac47af70f36816a45640cb65371d9", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -54,13 +54,30 @@ pub fn rust_path() -> ~[Path] {\n     };\n     let cwd = os::getcwd();\n     // now add in default entries\n+    env_rust_path.push(cwd.push(\".rust\"));\n     env_rust_path.push(copy cwd);\n     do cwd.each_parent() |p| { push_if_exists(&mut env_rust_path, p) };\n     let h = os::homedir();\n     for h.iter().advance |h| { push_if_exists(&mut env_rust_path, h); }\n     env_rust_path\n }\n \n+pub fn default_workspace() -> Path {\n+    let p = rust_path();\n+    if p.is_empty() {\n+        fail!(\"Empty RUST_PATH\");\n+    }\n+    let result = p[0];\n+    if !os::path_is_dir(&result) {\n+        os::mkdir_recursive(&result, U_RWX);\n+    }\n+    result\n+}\n+\n+pub fn in_rust_path(p: &Path) -> bool {\n+    rust_path().contains(p)\n+}\n+\n pub static U_RWX: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n \n /// Creates a directory that is readable, writeable,"}, {"sha": "46f2d5eb37e8d09d6dbb55f5ea44d9ce0bcef779", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -38,9 +38,10 @@ use syntax::{ast, diagnostic};\n use util::*;\n use messages::*;\n use path_util::{build_pkg_id_in_workspace, first_pkgid_src_in_workspace};\n-use path_util::{U_RWX, rust_path};\n-use path_util::{built_executable_in_workspace, built_library_in_workspace};\n+use path_util::{U_RWX, rust_path, in_rust_path};\n+use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n+use source_control::is_git_dir;\n use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces};\n use context::Ctx;\n use package_id::PkgId;\n@@ -57,6 +58,7 @@ mod package_path;\n mod package_source;\n mod path_util;\n mod search;\n+mod source_control;\n mod target;\n #[cfg(test)]\n mod tests;\n@@ -201,8 +203,10 @@ impl CtxMethods for Ctx {\n                 }\n                 // The package id is presumed to be the first command-line\n                 // argument\n-                let pkgid = PkgId::new(copy args[0]);\n+                let pkgid = PkgId::new(copy args[0], &os::getcwd());\n                 for each_pkg_parent_workspace(&pkgid) |workspace| {\n+                    debug!(\"found pkg %s in workspace %s, trying to build\",\n+                           pkgid.to_str(), workspace.to_str());\n                     self.build(workspace, &pkgid);\n                 }\n             }\n@@ -212,7 +216,7 @@ impl CtxMethods for Ctx {\n                 }\n                 // The package id is presumed to be the first command-line\n                 // argument\n-                let pkgid = PkgId::new(copy args[0]);\n+                let pkgid = PkgId::new(copy args[0], &os::getcwd());\n                 let cwd = os::getcwd();\n                 self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n             }\n@@ -233,9 +237,10 @@ impl CtxMethods for Ctx {\n \n                 // The package id is presumed to be the first command-line\n                 // argument\n-                let pkgid = PkgId::new(args[0]);\n+                let pkgid = PkgId::new(args[0], &os::getcwd());\n                 let workspaces = pkg_parent_workspaces(&pkgid);\n                 if workspaces.is_empty() {\n+                    debug!(\"install! workspaces was empty\");\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n                     let src = PkgSrc::new(&rp[0], &build_pkg_id_in_workspace(&pkgid, &rp[0]),\n@@ -245,6 +250,9 @@ impl CtxMethods for Ctx {\n                 }\n                 else {\n                     for each_pkg_parent_workspace(&pkgid) |workspace| {\n+                        debug!(\"install: found pkg %s in workspace %s, trying to build\",\n+                               pkgid.to_str(), workspace.to_str());\n+\n                         self.install(workspace, &pkgid);\n                     }\n                 }\n@@ -272,7 +280,7 @@ impl CtxMethods for Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let pkgid = PkgId::new(args[0]);\n+                let pkgid = PkgId::new(args[0], &os::getcwd()); // ??\n                 if !installed_packages::package_is_installed(&pkgid) {\n                     warn(fmt!(\"Package %s doesn't seem to be installed! Doing nothing.\", args[0]));\n                     return;\n@@ -304,12 +312,29 @@ impl CtxMethods for Ctx {\n     }\n \n     fn build(&self, workspace: &Path, pkgid: &PkgId) {\n-        debug!(\"build: workspace = %s pkgid = %s\", workspace.to_str(),\n+        debug!(\"build: workspace = %s (in Rust path? %? is git dir? %? \\\n+                pkgid = %s\", workspace.to_str(),\n+               in_rust_path(workspace), is_git_dir(&workspace.push_rel(&*pkgid.local_path)),\n                pkgid.to_str());\n         let src_dir   = first_pkgid_src_in_workspace(pkgid, workspace);\n         let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n         debug!(\"Destination dir = %s\", build_dir.to_str());\n \n+        // If workspace isn't in the RUST_PATH, and it's a git repo,\n+        // then clone it into the first entry in RUST_PATH, and repeat\n+        debug!(\"%? %? %s\", in_rust_path(workspace),\n+               is_git_dir(&workspace.push_rel(&*pkgid.local_path)),\n+               workspace.to_str());\n+        if !in_rust_path(workspace) && is_git_dir(&workspace.push_rel(&*pkgid.local_path)) {\n+            let out_dir = default_workspace().push(\"src\").push_rel(&*pkgid.local_path);\n+            source_control::git_clone(&workspace.push_rel(&*pkgid.local_path),\n+                                      &out_dir, &pkgid.version);\n+            let default_ws = default_workspace();\n+            debug!(\"Calling build recursively with %? and %?\", default_ws.to_str(),\n+                   pkgid.to_str());\n+            return self.build(&default_ws, pkgid);\n+        }\n+\n         // Create the package source\n         let mut src = PkgSrc::new(workspace, &build_dir, pkgid);\n         debug!(\"Package src = %?\", src);"}, {"sha": "8d125300a3344e0db66d1cefe45be418faa684c0", "filename": "src/librustpkg/source_control.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Utils for working with version control repositories. Just git right now.\n+\n+use std::{io, os, run, str};\n+use version::*;\n+\n+/// For a local git repo\n+pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n+    assert!(os::path_is_dir(source));\n+    assert!(is_git_dir(source));\n+    if !os::path_exists(target) {\n+        let version_args = match v {\n+            &ExactRevision(ref s) => ~[~\"--branch\", s.to_owned()],\n+            _ => ~[]\n+        };\n+        debug!(\"Running: git clone %s %s %s\", version_args.to_str(), source.to_str(),\n+               target.to_str());\n+        let outp = run::process_output(\"git\", ~[~\"clone\"] + version_args +\n+                                       ~[source.to_str(), target.to_str()]);\n+        if outp.status != 0 {\n+            io::println(str::from_bytes_owned(outp.output.clone()));\n+            io::println(str::from_bytes_owned(outp.error));\n+            fail!(\"Couldn't `git clone` %s\", source.to_str());\n+        }\n+    }\n+    else {\n+        // Pull changes\n+        debug!(\"Running: git --work-tree=%s --git-dir=%s pull --no-edit %s\",\n+               target.to_str(), target.push(\".git\").to_str(), source.to_str());\n+        let outp = run::process_output(\"git\", [fmt!(\"--work-tree=%s\", target.to_str()),\n+                                               fmt!(\"--git-dir=%s\", target.push(\".git\").to_str()),\n+                                               ~\"pull\", ~\"--no-edit\", source.to_str()]);\n+        assert!(outp.status == 0);\n+    }\n+}\n+\n+pub fn is_git_dir(p: &Path) -> bool {\n+    os::path_is_dir(&p.push(\".git\"))\n+}"}, {"sha": "722f01a2564456dd002d8954ac74823fca30be65", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 222, "deletions": 81, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -18,7 +18,6 @@ use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n use package_path::*;\n use package_id::{PkgId};\n-use package_source::*;\n use version::{ExactRevision, NoVersion, Version};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n@@ -52,8 +51,8 @@ fn fake_pkg() -> PkgId {\n     }\n }\n \n-fn remote_pkg() -> PkgId {\n-    let remote = RemotePath(Path(\"github.com/catamorphism/test-pkg\"));\n+fn git_repo_pkg() -> PkgId {\n+    let remote = RemotePath(Path(\"mockgithub.com/catamorphism/test-pkg\"));\n     PkgId {\n         local_path: normalize(copy remote),\n         remote_path: remote,\n@@ -109,6 +108,86 @@ fn mk_temp_workspace(short_name: &LocalPath, version: &Version) -> Path {\n     package_dir\n }\n \n+/// Should create an empty git repo in p, relative to the tmp dir, and return the new\n+/// absolute path\n+fn init_git_repo(p: &Path) -> Path {\n+    assert!(!p.is_absolute());\n+    let tmp = mkdtemp(&os::tmpdir(), \"git_local\").expect(\"couldn't create temp dir\");\n+    let work_dir = tmp.push_rel(p);\n+    let work_dir_for_opts = work_dir.clone();\n+    assert!(os::mkdir_recursive(&work_dir, U_RWX));\n+    debug!(\"Running: git init in %s\", work_dir.to_str());\n+    let opts = run::ProcessOptions {\n+        env: None,\n+        dir: Some(&work_dir_for_opts),\n+        in_fd: None,\n+        out_fd: None,\n+        err_fd: None\n+    };\n+    let mut prog = run::Process::new(\"git\", [~\"init\"], opts);\n+    let mut output = prog.finish_with_output();\n+    if output.status == 0 {\n+        // Add stuff to the dir so that git tag succeeds\n+        writeFile(&work_dir.push(\"README\"), \"\");\n+        prog = run::Process::new(\"git\", [~\"add\", ~\"README\"], opts);\n+        output = prog.finish_with_output();\n+        if output.status == 0 {\n+            prog = run::Process::new(\"git\", [~\"commit\", ~\"-m\", ~\"whatever\"], opts);\n+            output = prog.finish_with_output();\n+            if output.status == 0 {\n+                tmp\n+            }\n+            else {\n+                fail!(\"Couldn't commit in %s\", work_dir.to_str());\n+            }\n+        }\n+        else {\n+            fail!(\"Couldn't add in %s\", work_dir.to_str());\n+        }\n+    }\n+    else {\n+        fail!(\"Couldn't initialize git repository in %s\", work_dir.to_str())\n+    }\n+}\n+\n+fn add_git_tag(repo: &Path, tag: ~str) {\n+    assert!(repo.is_absolute());\n+    let mut prog = run::Process::new(\"git\", [~\"add\", ~\"-A\"],\n+                                     run::ProcessOptions { env: None,\n+                                                          dir: Some(repo),\n+                                                          in_fd: None,\n+                                                          out_fd: None,\n+                                                          err_fd: None\n+                                                         });\n+    let output = prog.finish_with_output();\n+    if output.status != 0 {\n+        fail!(\"Couldn't add all files in %s\", repo.to_str())\n+    }\n+    prog = run::Process::new(\"git\", [~\"commit\", ~\"-m\", ~\"whatever\"],\n+                                     run::ProcessOptions { env: None,\n+                                                          dir: Some(repo),\n+                                                          in_fd: None,\n+                                                          out_fd: None,\n+                                                          err_fd: None\n+                                                         });\n+    let output = prog.finish_with_output();\n+    if output.status != 0 {\n+        fail!(\"Couldn't commit in %s\", repo.to_str())\n+    }\n+\n+    prog = run::Process::new(\"git\", [~\"tag\", tag.clone()],\n+                                     run::ProcessOptions { env: None,\n+                                                          dir: Some(repo),\n+                                                          in_fd: None,\n+                                                          out_fd: None,\n+                                                          err_fd: None\n+                                                         });\n+    let output = prog.finish_with_output();\n+    if output.status != 0 {\n+        fail!(\"Couldn't add git tag %s in %s\", tag, repo.to_str())\n+    }\n+}\n+\n fn is_rwx(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n@@ -168,16 +247,6 @@ to make sure the command succeeded\n     output\n }\n \n-fn make_git_repo(short_name: &str) -> Path {\n-    let temp_d = mk_temp_workspace(&normalize(RemotePath(Path(short_name))), &NoVersion);\n-    debug!(\"Dry run: would initialize %s as a git repository\", temp_d.pop().pop().to_str());\n-    temp_d.pop().pop()\n-}\n-\n-fn add_git_tag(repo: &Path, tag: &str) {\n-    debug!(\"Dry run: would add tag %s to repo %s\", tag, repo.to_str());\n-}\n-\n fn create_local_package(pkgid: &PkgId) -> Path {\n     let parent_dir = mk_temp_workspace(&pkgid.local_path, &pkgid.version);\n     debug!(\"Created empty package dir for %s, returning %s\", pkgid.to_str(), parent_dir.to_str());\n@@ -236,16 +305,19 @@ fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n \n }\n \n-fn assert_lib_exists(repo: &Path, short_name: &str) {\n+fn assert_lib_exists(repo: &Path, short_name: &str, v: Version) {\n     debug!(\"assert_lib_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n-    let lib = target_library_in_workspace(&PkgId::new(short_name), repo);\n+    let lib = target_library_in_workspace(&(PkgId {\n+        version: v, ..PkgId::new(short_name, repo)}\n+                                           ), repo);\n+    debug!(\"assert_lib_exists: checking whether %s exists\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n }\n \n fn assert_executable_exists(repo: &Path, short_name: &str) {\n     debug!(\"assert_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n-    let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n+    let exec = target_executable_in_workspace(&PkgId::new(short_name, repo), repo);\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n }\n@@ -394,38 +466,54 @@ fn test_install_invalid() {\n     assert!(error_occurred && error1_occurred);\n }\n \n+// Tests above should (maybe) be converted to shell out to rustpkg, too\n+\n #[test] #[ignore(cfg(target_arch = \"x86\"))]\n-fn test_install_url() {\n-    let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n+fn test_install_git() {\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n-    let ctxt = fake_ctxt(Some(@sysroot));\n-    let temp_pkg_id = remote_pkg();\n+    let temp_pkg_id = git_repo_pkg();\n+    let repo = init_git_repo(&Path(temp_pkg_id.local_path.to_str()));\n+    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test_pkg\");\n+    writeFile(&repo_subdir.push(\"main.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    writeFile(&repo_subdir.push(\"lib.rs\"),\n+              \"pub fn f() { let _x = (); }\");\n+    writeFile(&repo_subdir.push(\"test.rs\"),\n+              \"#[test] pub fn f() { (); }\");\n+    writeFile(&repo_subdir.push(\"bench.rs\"),\n+              \"#[bench] pub fn f() { (); }\");\n+    add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n+\n+    debug!(\"test_install_git: calling rustpkg install %s in %s\",\n+           temp_pkg_id.local_path.to_str(), repo.to_str());\n     // should have test, bench, lib, and main\n-    ctxt.install(&workspace, &temp_pkg_id);\n+    command_line_test([~\"install\", temp_pkg_id.local_path.to_str()], &repo);\n     // Check that all files exist\n-    let exec = target_executable_in_workspace(&temp_pkg_id, &workspace);\n+    let ws = repo.push(\".rust\");\n+    debug!(\"Checking for files in %s\", ws.to_str());\n+    let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let _built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n-                                   &workspace).expect(\"test_install_url: built lib should exist\");\n-    let lib = target_library_in_workspace(&temp_pkg_id, &workspace);\n+                                   &ws).expect(\"test_install_git: built lib should exist\");\n+    let lib = target_library_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n     let built_test = built_test_in_workspace(&temp_pkg_id,\n-                         &workspace).expect(\"test_install_url: built test should exist\");\n+                         &ws).expect(\"test_install_git: built test should exist\");\n     assert!(os::path_exists(&built_test));\n     let built_bench = built_bench_in_workspace(&temp_pkg_id,\n-                          &workspace).expect(\"test_install_url: built bench should exist\");\n+                          &ws).expect(\"test_install_git: built bench should exist\");\n     assert!(os::path_exists(&built_bench));\n     // And that the test and bench executables aren't installed\n-    let test = target_test_in_workspace(&temp_pkg_id, &workspace);\n+    let test = target_test_in_workspace(&temp_pkg_id, &ws);\n     assert!(!os::path_exists(&test));\n     debug!(\"test = %s\", test.to_str());\n-    let bench = target_bench_in_workspace(&temp_pkg_id, &workspace);\n+    let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"bench = %s\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n@@ -445,18 +533,18 @@ fn test_package_ids_must_be_relative_path_like() {\n \n     */\n \n-    let whatever = PkgId::new(\"foo\");\n+    let whatever = PkgId::new(\"foo\", &os::getcwd());\n \n     assert_eq!(~\"foo-0.1\", whatever.to_str());\n     assert!(\"github.com/catamorphism/test_pkg-0.1\" ==\n-            PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n+            PkgId::new(\"github.com/catamorphism/test-pkg\", &os::getcwd()).to_str());\n \n     do cond.trap(|(p, e)| {\n         assert!(\"\" == p.to_str());\n         assert!(\"0-length pkgid\" == e);\n         copy whatever\n     }).in {\n-        let x = PkgId::new(\"\");\n+        let x = PkgId::new(\"\", &os::getcwd());\n         assert_eq!(~\"foo-0.1\", x.to_str());\n     }\n \n@@ -465,47 +553,80 @@ fn test_package_ids_must_be_relative_path_like() {\n         assert!(\"absolute pkgid\" == e);\n         copy whatever\n     }).in {\n-        let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n+        let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str(),\n+                           &os::getcwd());\n         assert_eq!(~\"foo-0.1\", z.to_str());\n     }\n \n }\n \n #[test] #[ignore(cfg(target_arch = \"x86\"))]\n fn test_package_version() {\n-    let temp_pkg_id = PkgId::new(\"github.com/catamorphism/test_pkg_version\");\n+    let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n+    let repo = init_git_repo(&Path(local_path));\n+    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test_pkg_version\");\n+    debug!(\"Writing files in: %s\", repo_subdir.to_str());\n+    writeFile(&repo_subdir.push(\"main.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    writeFile(&repo_subdir.push(\"lib.rs\"),\n+              \"pub fn f() { let _x = (); }\");\n+    writeFile(&repo_subdir.push(\"test.rs\"),\n+              \"#[test] pub fn f() { (); }\");\n+    writeFile(&repo_subdir.push(\"bench.rs\"),\n+              \"#[bench] pub fn f() { (); }\");\n+    add_git_tag(&repo_subdir, ~\"0.4\");\n+\n+    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version\", &repo);\n     match temp_pkg_id.version {\n         ExactRevision(~\"0.4\") => (),\n         _ => fail!(fmt!(\"test_package_version: package version was %?, expected Some(0.4)\",\n                         temp_pkg_id.version))\n     }\n-    let temp = mk_empty_workspace(&LocalPath(Path(\"test_pkg_version\")), &temp_pkg_id.version);\n-    let ctx = fake_ctxt(Some(@test_sysroot()));\n-    ctx.build(&temp, &temp_pkg_id);\n-    assert!(match built_library_in_workspace(&temp_pkg_id, &temp) {\n+    // This should look at the prefix, clone into a workspace, then build.\n+    command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg_version\"],\n+                      &repo);\n+    assert!(match built_library_in_workspace(&temp_pkg_id,\n+                                             &repo.push(\".rust\")) {\n         Some(p) => p.to_str().ends_with(fmt!(\"0.4%s\", os::consts::DLL_SUFFIX)),\n         None    => false\n     });\n-    assert!(built_executable_in_workspace(&temp_pkg_id, &temp)\n-            == Some(temp.push(\"build\").\n-                    push(\"github.com\").\n+    assert!(built_executable_in_workspace(&temp_pkg_id, &repo.push(\".rust\"))\n+            == Some(repo.push(\".rust\").push(\"build\").\n+                    push(\"mockgithub.com\").\n                     push(\"catamorphism\").\n                     push(\"test_pkg_version\").\n                     push(\"test_pkg_version\")));\n }\n \n-// FIXME #7006: Fails on linux for some reason\n-#[test]\n-#[ignore]\n fn test_package_request_version() {\n-    let temp_pkg_id = PkgId::new(\"github.com/catamorphism/test_pkg_version#0.3\");\n-    let temp = mk_empty_workspace(&LocalPath(Path(\"test_pkg_version\")), &ExactRevision(~\"0.3\"));\n-    let pkg_src = PkgSrc::new(&temp, &temp, &temp_pkg_id);\n+    let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n+    let repo = init_git_repo(&Path(local_path));\n+    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test_pkg_version\");\n+    debug!(\"Writing files in: %s\", repo_subdir.to_str());\n+    writeFile(&repo_subdir.push(\"main.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    writeFile(&repo_subdir.push(\"lib.rs\"),\n+              \"pub fn f() { let _x = (); }\");\n+    writeFile(&repo_subdir.push(\"test.rs\"),\n+              \"#[test] pub fn f() { (); }\");\n+    writeFile(&repo_subdir.push(\"bench.rs\"),\n+              \"#[bench] pub fn f() { (); }\");\n+    writeFile(&repo_subdir.push(\"version-0.3-file.txt\"), \"hi\");\n+    add_git_tag(&repo_subdir, ~\"0.3\");\n+    writeFile(&repo_subdir.push(\"version-0.4-file.txt\"), \"hello\");\n+    add_git_tag(&repo_subdir, ~\"0.4\");\n+\n+/*\n+\n+    let pkg_src = PkgSrc::new(&repo, &repo, &temp_pkg_id);\n     match temp_pkg_id.version {\n         ExactRevision(~\"0.3\") => {\n+            debug!(\"Version matches, calling fetch_git\");\n             match pkg_src.fetch_git() {\n                 Some(p) => {\n+                    debug!(\"does version-0.3-file exist?\");\n                     assert!(os::path_exists(&p.push(\"version-0.3-file.txt\")));\n+                    debug!(\"does version-0.4-file exist?\");\n                     assert!(!os::path_exists(&p.push(\"version-0.4-file.txt\")));\n \n                 }\n@@ -518,24 +639,31 @@ fn test_package_request_version() {\n         _ => fail!(fmt!(\"test_package_version: package version was %?, expected ExactRevision(0.3)\",\n                         temp_pkg_id.version))\n     }\n-    let c = fake_ctxt(Some(@test_sysroot()));\n-    c.install(&temp, &temp_pkg_id);\n-    debug!(\"installed_library_in_workspace(%s, %s) = %?\", temp_pkg_id.short_name, temp.to_str(),\n-           installed_library_in_workspace(temp_pkg_id.short_name, &temp));\n-    assert!(match installed_library_in_workspace(temp_pkg_id.short_name, &temp) {\n+*/\n+\n+    command_line_test([~\"install\", fmt!(\"%s#0.3\", local_path)], &repo);\n+\n+    assert!(match installed_library_in_workspace(\"test_pkg_version\", &repo.push(\".rust\")) {\n         Some(p) => {\n             debug!(\"installed: %s\", p.to_str());\n             p.to_str().ends_with(fmt!(\"0.3%s\", os::consts::DLL_SUFFIX))\n         }\n         None    => false\n     });\n-    assert!(target_executable_in_workspace(&temp_pkg_id, &temp)\n-            == temp.push(\"bin\").push(\"test_pkg_version\"));\n+    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\", &repo);\n+    assert!(target_executable_in_workspace(&temp_pkg_id, &repo.push(\".rust\"))\n+            == repo.push(\".rust\").push(\"bin\").push(\"test_pkg_version\"));\n \n+    assert!(os::path_exists(&repo.push(\".rust\").push(\"src\")\n+                            .push(\"mockgithub.com\").push(\"catamorphism\")\n+                            .push(\"test_pkg_version-0.3\")\n+                            .push(\"version-0.3-file.txt\")));\n+    assert!(!os::path_exists(&repo.push(\".rust\").push(\"src\")\n+                            .push(\"mockgithub.com\").push(\"catamorphism\")\n+                             .push(\"test_pkg_version-0.3\")\n+                            .push(\"version-0.4-file.txt\")));\n }\n \n-// Tests above should (maybe) be converted to shell out to rustpkg, too\n-\n #[test]\n #[ignore (reason = \"http-client not ported to rustpkg yet\")]\n fn rustpkg_install_url_2() {\n@@ -546,23 +674,35 @@ fn rustpkg_install_url_2() {\n \n #[test]\n fn rustpkg_library_target() {\n-    let foo_repo = make_git_repo(\"foo\");\n-    add_git_tag(&foo_repo, \"1.0\");\n+    let foo_repo = init_git_repo(&Path(\"foo\"));\n+    let package_dir = foo_repo.push(\"foo\");\n+\n+    debug!(\"Writing files in: %s\", package_dir.to_str());\n+    writeFile(&package_dir.push(\"main.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    writeFile(&package_dir.push(\"lib.rs\"),\n+              \"pub fn f() { let _x = (); }\");\n+    writeFile(&package_dir.push(\"test.rs\"),\n+              \"#[test] pub fn f() { (); }\");\n+    writeFile(&package_dir.push(\"bench.rs\"),\n+              \"#[bench] pub fn f() { (); }\");\n+\n+    add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], &foo_repo);\n-    assert_lib_exists(&foo_repo, \"foo\");\n+    assert_lib_exists(&foo_repo.push(\".rust\"), \"foo\", ExactRevision(~\"1.0\"));\n }\n \n #[test]\n fn rustpkg_local_pkg() {\n-    let dir = create_local_package(&PkgId::new(\"foo\"));\n+    let dir = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n     command_line_test([~\"install\", ~\"foo\"], &dir);\n     assert_executable_exists(&dir, \"foo\");\n }\n \n #[test]\n #[ignore] // XXX Failing on dist-linux bot\n fn package_script_with_default_build() {\n-    let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n+    let dir = create_local_package(&PkgId::new(\"fancy-lib\", &os::getcwd()));\n     debug!(\"dir = %s\", dir.to_str());\n     let source = test_sysroot().pop().pop().pop().push(\"src\").push(\"librustpkg\").\n         push(\"testsuite\").push(\"pass\").push(\"src\").push(\"fancy-lib\").push(\"pkg.rs\");\n@@ -572,7 +712,7 @@ fn package_script_with_default_build() {\n         fail!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], &dir);\n-    assert_lib_exists(&dir, \"fancy-lib\");\n+    assert_lib_exists(&dir, \"fancy-lib\", NoVersion);\n     assert!(os::path_exists(&dir.push(\"build\").push(\"fancy_lib\").push(\"generated.rs\")));\n }\n \n@@ -633,12 +773,12 @@ fn rust_path_parse() {\n \n #[test]\n fn test_list() {\n-    let foo = PkgId::new(\"foo\");\n     let dir = mkdtemp(&os::tmpdir(), \"test_list\").expect(\"test_list failed\");\n+    let foo = PkgId::new(\"foo\", &dir);\n     create_local_package_in(&foo, &dir);\n-    let bar = PkgId::new(\"bar\");\n+    let bar = PkgId::new(\"bar\", &dir);\n     create_local_package_in(&bar, &dir);\n-    let quux = PkgId::new(\"quux\");\n+    let quux = PkgId::new(\"quux\", &dir);\n     create_local_package_in(&quux, &dir);\n \n     command_line_test([~\"install\", ~\"foo\"], &dir);\n@@ -660,10 +800,10 @@ fn test_list() {\n \n #[test]\n fn install_remove() {\n-    let foo = PkgId::new(\"foo\");\n-    let bar = PkgId::new(\"bar\");\n-    let quux = PkgId::new(\"quux\");\n     let dir = mkdtemp(&os::tmpdir(), \"install_remove\").expect(\"install_remove\");\n+    let foo = PkgId::new(\"foo\", &dir);\n+    let bar = PkgId::new(\"bar\", &dir);\n+    let quux = PkgId::new(\"quux\", &dir);\n     create_local_package_in(&foo, &dir);\n     create_local_package_in(&bar, &dir);\n     create_local_package_in(&quux, &dir);\n@@ -688,7 +828,7 @@ fn install_check_duplicates() {\n     // (\"Is already installed -- doing nothing\")\n     // check invariant that there are no dups in the pkg database\n     let dir = mkdtemp(&os::tmpdir(), \"install_remove\").expect(\"install_remove\");\n-    let foo = PkgId::new(\"foo\");\n+    let foo = PkgId::new(\"foo\", &dir);\n     create_local_package_in(&foo, &dir);\n \n     command_line_test([~\"install\", ~\"foo\"], &dir);\n@@ -709,7 +849,7 @@ fn install_check_duplicates() {\n #[test]\n #[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn no_rebuilding() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = PkgId::new(\"foo\", &os::getcwd());\n     let workspace = create_local_package(&p_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let date = datestamp(&built_library_in_workspace(&p_id,\n@@ -723,8 +863,8 @@ fn no_rebuilding() {\n #[test]\n #[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn no_rebuilding_dep() {\n-    let p_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"bar\");\n+    let p_id = PkgId::new(\"foo\", &os::getcwd());\n+    let dep_id = PkgId::new(\"bar\", &os::getcwd());\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace,\n@@ -736,8 +876,8 @@ fn no_rebuilding_dep() {\n \n #[test]\n fn do_rebuild_dep_dates_change() {\n-    let p_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"bar\");\n+    let p_id = PkgId::new(\"foo\", &os::getcwd());\n+    let dep_id = PkgId::new(\"bar\", &os::getcwd());\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n@@ -749,8 +889,8 @@ fn do_rebuild_dep_dates_change() {\n \n #[test]\n fn do_rebuild_dep_only_contents_change() {\n-    let p_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"bar\");\n+    let p_id = PkgId::new(\"foo\", &os::getcwd());\n+    let dep_id = PkgId::new(\"bar\", &os::getcwd());\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n@@ -764,8 +904,8 @@ fn do_rebuild_dep_only_contents_change() {\n #[test]\n #[ignore(reason = \"list not yet implemented\")]\n fn test_versions() {\n-    let workspace = create_local_package(&PkgId::new(\"foo#0.1\"));\n-    create_local_package(&PkgId::new(\"foo#0.2\"));\n+    let workspace = create_local_package(&PkgId::new(\"foo#0.1\", &os::getcwd()));\n+    create_local_package(&PkgId::new(\"foo#0.2\", &os::getcwd()));\n     command_line_test([~\"install\", ~\"foo#0.1\"], &workspace);\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n@@ -775,7 +915,8 @@ fn test_versions() {\n #[test]\n #[ignore(reason = \"do not yet implemented\")]\n fn test_build_hooks() {\n-    let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\"), \"frob\");\n+    let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\", &os::getcwd()),\n+                                                                \"frob\");\n     command_line_test([~\"do\", ~\"foo\", ~\"frob\"], &workspace);\n }\n \n@@ -784,7 +925,7 @@ fn test_build_hooks() {\n #[ignore(reason = \"info not yet implemented\")]\n fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n-    let workspace = create_local_package(&PkgId::new(\"foo\"));\n+    let workspace = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n     let output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n     assert_eq!(str::from_bytes(output.output), expected_info);\n }\n@@ -793,15 +934,15 @@ fn test_info() {\n #[ignore(reason = \"test not yet implemented\")]\n fn test_rustpkg_test() {\n     let expected_results = ~\"1 out of 1 tests passed\"; // fill in\n-    let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n+    let workspace = create_local_package_with_test(&PkgId::new(\"foo\", &os::getcwd()));\n     let output = command_line_test([~\"test\", ~\"foo\"], &workspace);\n     assert_eq!(str::from_bytes(output.output), expected_results);\n }\n \n #[test]\n #[ignore(reason = \"uninstall not yet implemented\")]\n fn test_uninstall() {\n-    let workspace = create_local_package(&PkgId::new(\"foo\"));\n+    let workspace = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n     let _output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n     command_line_test([~\"uninstall\", ~\"foo\"], &workspace);\n     let output = command_line_test([~\"list\"], &workspace);"}, {"sha": "c9b9415f87270c56c753bb88f777be777f2392a6", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -344,7 +344,7 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n                     }\n                     None => {\n                         // Try to install it\n-                        let pkg_id = PkgId::new(lib_name);\n+                        let pkg_id = PkgId::new(lib_name, &os::getcwd());\n                         my_ctxt.install(&my_workspace, &pkg_id);\n                         // Also, add an additional search path\n                         debug!(\"let installed_path...\")"}, {"sha": "5b291164287acfbedc38413b8ba1f1ac10651501", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa9ad86739e84805cabc2131d6607b4160bc556/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=0fa9ad86739e84805cabc2131d6607b4160bc556", "patch": "@@ -89,6 +89,29 @@ pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n     }\n }\n \n+/// If `local_path` is a git repo, and the most recent tag in that repo denotes a version,\n+/// return it; otherwise, `None`\n+pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n+    debug!(\"in try_getting_local_version\");\n+    let outp = run::process_output(\"git\",\n+                                   [fmt!(\"--git-dir=%s\", local_path.push(\".git\").to_str()),\n+                                    ~\"tag\", ~\"-l\"]);\n+\n+    debug!(\"git --git-dir=%s tag -l ~~~> %?\", local_path.push(\".git\").to_str(), outp.status);\n+\n+    if outp.status != 0 {\n+        return None;\n+    }\n+\n+    let mut output = None;\n+    let output_text = str::from_bytes(outp.output);\n+    for output_text.line_iter().advance |l| {\n+        if !l.is_whitespace() {\n+            output = Some(l);\n+        }\n+    }\n+    output.chain(try_parsing_version)\n+}\n \n /// If `remote_path` refers to a git repo that can be downloaded,\n /// and the most recent tag in that repo denotes a version, return it;"}]}