{"sha": "43f868b1c3efa4fcf2526e9600c0f047c19a3eb7", "node_id": "C_kwDOAAsO6NoAKDQzZjg2OGIxYzNlZmE0ZmNmMjUyNmU5NjAwYzBmMDQ3YzE5YTNlYjc", "commit": {"author": {"name": "Peter Collingbourne", "email": "pcc@google.com", "date": "2022-11-24T02:13:30Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-03-01T02:51:36Z"}, "message": "Move linkage type check to HIR analysis and fix semantics issues.\n\nThis ensures that the error is printed even for unused variables,\nas well as unifying the handling between the LLVM and GCC backends.\n\nThis also fixes unusual behavior around exported Rust-defined variables\nwith linkage attributes. With the previous behavior, it appears to be\nimpossible to define such a variable such that it can actually be imported\nand used by another crate. This is because on the importing side, the\nvariable is required to be a pointer, but on the exporting side, the\ntype checker rejects static variables of pointer type because they do\nnot implement `Sync`. Even if it were possible to import such a type, it\nappears that code generation on the importing side would add an unexpected\nadditional level of pointer indirection, which would break type safety.\n\nThis highlighted that the semantics of linkage on Rust-defined variables\nis different to linkage on foreign items. As such, we now model the\ndifference with two different codegen attributes: linkage for Rust-defined\nvariables, and import_linkage for foreign items.\n\nThis change gives semantics to the test\nsrc/test/ui/linkage-attr/auxiliary/def_illtyped_external.rs which was\npreviously expected to fail to compile. Therefore, convert it into a\ntest that is expected to successfully compile.\n\nThe update to the GCC backend is speculative and untested.", "tree": {"sha": "bc8cce7439daf77cd328a00c576cfbf48f8384f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc8cce7439daf77cd328a00c576cfbf48f8384f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43f868b1c3efa4fcf2526e9600c0f047c19a3eb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43f868b1c3efa4fcf2526e9600c0f047c19a3eb7", "html_url": "https://github.com/rust-lang/rust/commit/43f868b1c3efa4fcf2526e9600c0f047c19a3eb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43f868b1c3efa4fcf2526e9600c0f047c19a3eb7/comments", "author": {"login": "pcc", "id": 425024, "node_id": "MDQ6VXNlcjQyNTAyNA==", "avatar_url": "https://avatars.githubusercontent.com/u/425024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcc", "html_url": "https://github.com/pcc", "followers_url": "https://api.github.com/users/pcc/followers", "following_url": "https://api.github.com/users/pcc/following{/other_user}", "gists_url": "https://api.github.com/users/pcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcc/subscriptions", "organizations_url": "https://api.github.com/users/pcc/orgs", "repos_url": "https://api.github.com/users/pcc/repos", "events_url": "https://api.github.com/users/pcc/events{/privacy}", "received_events_url": "https://api.github.com/users/pcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01", "html_url": "https://github.com/rust-lang/rust/commit/d1eb38f5b5a3ed04f55189641b1d30ecd86b4a01"}], "stats": {"total": 32, "additions": 6, "deletions": 26}, "files": [{"sha": "eeb2b8f0d2968cb318f4e6671cd252903cde9aed", "filename": "src/consts.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/43f868b1c3efa4fcf2526e9600c0f047c19a3eb7/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43f868b1c3efa4fcf2526e9600c0f047c19a3eb7/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=43f868b1c3efa4fcf2526e9600c0f047c19a3eb7", "patch": "@@ -8,13 +8,11 @@ use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::mir::interpret::{self, ConstAllocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n-use rustc_span::Span;\n use rustc_span::def_id::DefId;\n use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRange};\n \n use crate::base;\n use crate::context::CodegenCx;\n-use crate::errors::LinkageConstOrMutType;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -216,7 +214,8 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n         let sym = self.tcx.symbol_name(instance).name;\n \n-        let global = if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n+        let global =\n+            if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n             let llty = self.layout_of(ty).gcc_type(self);\n             if let Some(global) = self.get_declared_value(sym) {\n                 if self.val_ty(global) != self.type_ptr_to(llty) {\n@@ -239,7 +238,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n             global\n         } else {\n-            check_and_apply_linkage(&self, &fn_attrs, ty, sym, self.tcx.def_span(def_id))\n+            check_and_apply_linkage(&self, &fn_attrs, ty, sym)\n         };\n \n         if !def_id.is_local() {\n@@ -337,24 +336,12 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n     Ok((const_alloc_to_gcc(cx, alloc), alloc))\n }\n \n-fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> LValue<'gcc> {\n+fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n     let llty = cx.layout_of(ty).gcc_type(cx);\n-    if let Some(linkage) = attrs.linkage {\n-        // If this is a static with a linkage specified, then we need to handle\n-        // it a little specially. The typesystem prevents things like &T and\n-        // extern \"C\" fn() from being non-null, so we can't just declare a\n-        // static and call it a day. Some linkages (like weak) will make it such\n-        // that the static actually has a null value.\n-        let llty2 =\n-            if let ty::RawPtr(ref mt) = ty.kind() {\n-                cx.layout_of(mt.ty).gcc_type(cx)\n-            }\n-            else {\n-                cx.sess().emit_fatal(LinkageConstOrMutType { span: span })\n-            };\n+    if let Some(linkage) = attrs.import_linkage {\n         // Declare a symbol `foo` with the desired linkage.\n-        let global1 = cx.declare_global_with_linkage(&sym, llty2, base::global_linkage_to_gcc(linkage));\n+        let global1 = cx.declare_global_with_linkage(&sym, cx.type_i8(), base::global_linkage_to_gcc(linkage));\n \n         // Declare an internal global `extern_with_linkage_foo` which\n         // is initialized with the address of `foo`.  If `foo` is"}, {"sha": "d0ba7e2479111fed3ee8661f86984a3fbfd18cf2", "filename": "src/errors.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43f868b1c3efa4fcf2526e9600c0f047c19a3eb7/src%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43f868b1c3efa4fcf2526e9600c0f047c19a3eb7/src%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferrors.rs?ref=43f868b1c3efa4fcf2526e9600c0f047c19a3eb7", "patch": "@@ -211,13 +211,6 @@ pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n     pub in_elem: Ty<'a>,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_gcc_linkage_const_or_mut_type)]\n-pub(crate) struct LinkageConstOrMutType {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_gcc_lto_not_supported)]\n pub(crate) struct LTONotSupported;"}]}