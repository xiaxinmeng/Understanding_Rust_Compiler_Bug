{"sha": "5e51b2d9688ccdfb082a1b855c9aa8398b86b870", "node_id": "C_kwDOAAsO6NoAKDVlNTFiMmQ5Njg4Y2NkZmIwODJhMWI4NTVjOWFhODM5OGI4NmI4NzA", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-04-13T09:33:44Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-04-13T11:19:56Z"}, "message": "Correctly handle built-in compiler proc-macros as proc-macro and not macro", "tree": {"sha": "e3aa0d9a68cf251610db3bd2ef6a91af9c857625", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3aa0d9a68cf251610db3bd2ef6a91af9c857625"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e51b2d9688ccdfb082a1b855c9aa8398b86b870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e51b2d9688ccdfb082a1b855c9aa8398b86b870", "html_url": "https://github.com/rust-lang/rust/commit/5e51b2d9688ccdfb082a1b855c9aa8398b86b870", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e51b2d9688ccdfb082a1b855c9aa8398b86b870/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b76821b4de51fa79c4f593079679f63b7476f737", "url": "https://api.github.com/repos/rust-lang/rust/commits/b76821b4de51fa79c4f593079679f63b7476f737", "html_url": "https://github.com/rust-lang/rust/commit/b76821b4de51fa79c4f593079679f63b7476f737"}], "stats": {"total": 95, "additions": 55, "deletions": 40}, "files": [{"sha": "8a089b250769ac30b0172f898563dd66fd6ff35e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e51b2d9688ccdfb082a1b855c9aa8398b86b870/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e51b2d9688ccdfb082a1b855c9aa8398b86b870/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5e51b2d9688ccdfb082a1b855c9aa8398b86b870", "patch": "@@ -111,7 +111,7 @@ pub(crate) fn try_inline(\n             clean::ConstantItem(build_const(cx, did))\n         }\n         Res::Def(DefKind::Macro(kind), did) => {\n-            let mac = build_macro(cx, did, name, import_def_id);\n+            let mac = build_macro(cx, did, name, import_def_id, kind);\n \n             let type_kind = match kind {\n                 MacroKind::Bang => ItemType::Macro,\n@@ -651,18 +651,24 @@ fn build_macro(\n     def_id: DefId,\n     name: Symbol,\n     import_def_id: Option<DefId>,\n+    macro_kind: MacroKind,\n ) -> clean::ItemKind {\n     match CStore::from_tcx(cx.tcx).load_macro_untracked(def_id, cx.sess()) {\n-        LoadedMacro::MacroDef(item_def, _) => {\n-            if let ast::ItemKind::MacroDef(ref def) = item_def.kind {\n-                let vis = cx.tcx.visibility(import_def_id.unwrap_or(def_id));\n-                clean::MacroItem(clean::Macro {\n-                    source: utils::display_macro_source(cx, name, def, def_id, vis),\n-                })\n-            } else {\n-                unreachable!()\n+        LoadedMacro::MacroDef(item_def, _) => match macro_kind {\n+            MacroKind::Bang => {\n+                if let ast::ItemKind::MacroDef(ref def) = item_def.kind {\n+                    let vis = cx.tcx.visibility(import_def_id.unwrap_or(def_id));\n+                    clean::MacroItem(clean::Macro {\n+                        source: utils::display_macro_source(cx, name, def, def_id, vis),\n+                    })\n+                } else {\n+                    unreachable!()\n+                }\n             }\n-        }\n+            MacroKind::Derive | MacroKind::Attr => {\n+                clean::ProcMacroItem(clean::ProcMacro { kind: macro_kind, helpers: Vec::new() })\n+            }\n+        },\n         LoadedMacro::ProcMacro(ext) => clean::ProcMacroItem(clean::ProcMacro {\n             kind: ext.macro_kind(),\n             helpers: ext.helper_attrs,"}, {"sha": "f8dd8a234df9f733846e3d6f5e56b6dbcbe74180", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5e51b2d9688ccdfb082a1b855c9aa8398b86b870/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e51b2d9688ccdfb082a1b855c9aa8398b86b870/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5e51b2d9688ccdfb082a1b855c9aa8398b86b870", "patch": "@@ -909,6 +909,38 @@ fn clean_ty_generics<'tcx>(\n     }\n }\n \n+fn clean_proc_macro<'tcx>(\n+    item: &hir::Item<'tcx>,\n+    name: &mut Symbol,\n+    kind: MacroKind,\n+    cx: &mut DocContext<'tcx>,\n+) -> ItemKind {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    if kind == MacroKind::Derive &&\n+        let Some(derive_name) = attrs\n+            .lists(sym::proc_macro_derive)\n+            .find_map(|mi| mi.ident())\n+    {\n+        *name = derive_name.name;\n+    }\n+\n+    let mut helpers = Vec::new();\n+    for mi in attrs.lists(sym::proc_macro_derive) {\n+        if !mi.has_name(sym::attributes) {\n+            continue;\n+        }\n+\n+        if let Some(list) = mi.meta_item_list() {\n+            for inner_mi in list {\n+                if let Some(ident) = inner_mi.ident() {\n+                    helpers.push(ident.name);\n+                }\n+            }\n+        }\n+    }\n+    ProcMacroItem(ProcMacro { kind, helpers })\n+}\n+\n fn clean_fn_or_proc_macro<'tcx>(\n     item: &hir::Item<'tcx>,\n     sig: &hir::FnSig<'tcx>,\n@@ -930,31 +962,7 @@ fn clean_fn_or_proc_macro<'tcx>(\n         }\n     });\n     match macro_kind {\n-        Some(kind) => {\n-            if kind == MacroKind::Derive {\n-                *name = attrs\n-                    .lists(sym::proc_macro_derive)\n-                    .find_map(|mi| mi.ident())\n-                    .expect(\"proc-macro derives require a name\")\n-                    .name;\n-            }\n-\n-            let mut helpers = Vec::new();\n-            for mi in attrs.lists(sym::proc_macro_derive) {\n-                if !mi.has_name(sym::attributes) {\n-                    continue;\n-                }\n-\n-                if let Some(list) = mi.meta_item_list() {\n-                    for inner_mi in list {\n-                        if let Some(ident) = inner_mi.ident() {\n-                            helpers.push(ident.name);\n-                        }\n-                    }\n-                }\n-            }\n-            ProcMacroItem(ProcMacro { kind, helpers })\n-        }\n+        Some(kind) => clean_proc_macro(item, name, kind, cx),\n         None => {\n             let mut func = clean_function(cx, sig, generics, FunctionArgs::Body(body_id));\n             clean_fn_decl_legacy_const_generics(&mut func, attrs);\n@@ -2247,16 +2255,17 @@ fn clean_maybe_renamed_item<'tcx>(\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Impl(impl_) => return clean_impl(impl_, item.owner_id.def_id, cx),\n-            // proc macros can have a name set by attributes\n-            ItemKind::Fn(ref sig, generics, body_id) => {\n-                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n-            }\n-            ItemKind::Macro(ref macro_def, _) => {\n+            ItemKind::Macro(ref macro_def, MacroKind::Bang) => {\n                 let ty_vis = cx.tcx.visibility(def_id);\n                 MacroItem(Macro {\n                     source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n                 })\n             }\n+            ItemKind::Macro(_, macro_kind) => clean_proc_macro(item, &mut name, macro_kind, cx),\n+            // proc macros can have a name set by attributes\n+            ItemKind::Fn(ref sig, generics, body_id) => {\n+                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n+            }\n             ItemKind::Trait(_, _, generics, bounds, item_ids) => {\n                 let items = item_ids\n                     .iter()"}]}