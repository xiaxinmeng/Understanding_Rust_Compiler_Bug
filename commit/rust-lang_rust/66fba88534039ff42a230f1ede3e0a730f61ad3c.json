{"sha": "66fba88534039ff42a230f1ede3e0a730f61ad3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZmJhODg1MzQwMzlmZjQyYTIzMGYxZWRlM2UwYTczMGY2MWFkM2M=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-10T19:21:14Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-10T21:51:34Z"}, "message": "split module", "tree": {"sha": "053fe621cf9c7c868f6f6ab6cee1cd0f331b66dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/053fe621cf9c7c868f6f6ab6cee1cd0f331b66dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66fba88534039ff42a230f1ede3e0a730f61ad3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66fba88534039ff42a230f1ede3e0a730f61ad3c", "html_url": "https://github.com/rust-lang/rust/commit/66fba88534039ff42a230f1ede3e0a730f61ad3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66fba88534039ff42a230f1ede3e0a730f61ad3c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8923713c51bc3484bd98085ad620713959bbc0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8923713c51bc3484bd98085ad620713959bbc0d", "html_url": "https://github.com/rust-lang/rust/commit/e8923713c51bc3484bd98085ad620713959bbc0d"}], "stats": {"total": 502, "additions": 261, "deletions": 241}, "files": [{"sha": "3d02c65496d6aef5496b5f98ffdb9a28d054dd2b", "filename": "crates/ra_lsp_server/src/project_model.rs", "status": "modified", "additions": 10, "deletions": 241, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/66fba88534039ff42a230f1ede3e0a730f61ad3c/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66fba88534039ff42a230f1ede3e0a730f61ad3c/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs?ref=66fba88534039ff42a230f1ede3e0a730f61ad3c", "patch": "@@ -1,17 +1,20 @@\n+mod cargo_workspace;\n+mod sysroot;\n+\n use std::{\n     path::{Path, PathBuf},\n-    process::Command,\n };\n \n-use cargo_metadata::{metadata_run, CargoOpt};\n-use ra_syntax::SmolStr;\n-use ra_arena::{Arena, RawId, impl_arena_id};\n-use rustc_hash::FxHashMap;\n-use failure::{format_err, bail};\n+use failure::bail;\n use thread_worker::{WorkerHandle, Worker};\n \n use crate::Result;\n \n+pub use crate::project_model::{\n+    cargo_workspace::{CargoWorkspace, Package, Target, TargetKind},\n+    sysroot::Sysroot,\n+};\n+\n #[derive(Debug, Clone)]\n pub struct ProjectWorkspace {\n     pub(crate) cargo: CargoWorkspace,\n@@ -22,7 +25,7 @@ impl ProjectWorkspace {\n     pub fn discover(path: &Path) -> Result<ProjectWorkspace> {\n         let cargo_toml = find_cargo_toml(path)?;\n         let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml)?;\n-        let sysroot = sysroot_info(&cargo_toml)?;\n+        let sysroot = Sysroot::discover(&cargo_toml)?;\n         let res = ProjectWorkspace { cargo, sysroot };\n         Ok(res)\n     }\n@@ -42,224 +45,6 @@ pub fn workspace_loader() -> (Worker<PathBuf, Result<ProjectWorkspace>>, WorkerH\n     )\n }\n \n-/// `CargoWorksapce` represents the logical structure of, well, a Cargo\n-/// workspace. It pretty closely mirrors `cargo metadata` output.\n-///\n-/// Note that internally, rust analyzer uses a differnet structure:\n-/// `CrateGraph`. `CrateGraph` is lower-level: it knows only about the crates,\n-/// while this knows about `Pacakges` & `Targets`: purely cargo-related\n-/// concepts.\n-#[derive(Debug, Clone)]\n-pub struct CargoWorkspace {\n-    packages: Arena<Package, PackageData>,\n-    targets: Arena<Target, TargetData>,\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct Package(RawId);\n-impl_arena_id!(Package);\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct Target(RawId);\n-impl_arena_id!(Target);\n-\n-#[derive(Debug, Clone)]\n-struct PackageData {\n-    name: SmolStr,\n-    manifest: PathBuf,\n-    targets: Vec<Target>,\n-    is_member: bool,\n-    dependencies: Vec<PackageDependency>,\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct PackageDependency {\n-    pub pkg: Package,\n-    pub name: SmolStr,\n-}\n-\n-#[derive(Debug, Clone)]\n-struct TargetData {\n-    pkg: Package,\n-    name: SmolStr,\n-    root: PathBuf,\n-    kind: TargetKind,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum TargetKind {\n-    Bin,\n-    Lib,\n-    Example,\n-    Test,\n-    Bench,\n-    Other,\n-}\n-\n-#[derive(Debug, Clone)]\n-pub(crate) struct Sysroot {\n-    crates: FxHashMap<SmolStr, PathBuf>,\n-}\n-\n-impl Package {\n-    pub fn name(self, ws: &CargoWorkspace) -> &str {\n-        ws.packages[self].name.as_str()\n-    }\n-    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n-        ws.packages[self].manifest.parent().unwrap()\n-    }\n-    pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n-        ws.packages[self].targets.iter().cloned()\n-    }\n-    #[allow(unused)]\n-    pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n-        ws.packages[self].is_member\n-    }\n-    pub fn dependencies<'a>(\n-        self,\n-        ws: &'a CargoWorkspace,\n-    ) -> impl Iterator<Item = &'a PackageDependency> + 'a {\n-        ws.packages[self].dependencies.iter()\n-    }\n-}\n-\n-impl Target {\n-    pub fn package(self, ws: &CargoWorkspace) -> Package {\n-        ws.targets[self].pkg\n-    }\n-    pub fn name(self, ws: &CargoWorkspace) -> &str {\n-        ws.targets[self].name.as_str()\n-    }\n-    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n-        ws.targets[self].root.as_path()\n-    }\n-    pub fn kind(self, ws: &CargoWorkspace) -> TargetKind {\n-        ws.targets[self].kind\n-    }\n-}\n-\n-impl CargoWorkspace {\n-    pub fn from_cargo_metadata(path: &Path) -> Result<CargoWorkspace> {\n-        let cargo_toml = find_cargo_toml(path)?;\n-        let meta = metadata_run(\n-            Some(cargo_toml.as_path()),\n-            true,\n-            Some(CargoOpt::AllFeatures),\n-        )\n-        .map_err(|e| format_err!(\"cargo metadata failed: {}\", e))?;\n-        let mut pkg_by_id = FxHashMap::default();\n-        let mut packages = Arena::default();\n-        let mut targets = Arena::default();\n-\n-        let ws_members = &meta.workspace_members;\n-\n-        for meta_pkg in meta.packages {\n-            let is_member = ws_members.contains(&meta_pkg.id);\n-            let pkg = packages.alloc(PackageData {\n-                name: meta_pkg.name.into(),\n-                manifest: meta_pkg.manifest_path.clone(),\n-                targets: Vec::new(),\n-                is_member,\n-                dependencies: Vec::new(),\n-            });\n-            let pkg_data = &mut packages[pkg];\n-            pkg_by_id.insert(meta_pkg.id.clone(), pkg);\n-            for meta_tgt in meta_pkg.targets {\n-                let tgt = targets.alloc(TargetData {\n-                    pkg,\n-                    name: meta_tgt.name.into(),\n-                    root: meta_tgt.src_path.clone(),\n-                    kind: TargetKind::new(meta_tgt.kind.as_slice()),\n-                });\n-                pkg_data.targets.push(tgt);\n-            }\n-        }\n-        let resolve = meta.resolve.expect(\"metadata executed with deps\");\n-        for node in resolve.nodes {\n-            let source = pkg_by_id[&node.id];\n-            for dep_node in node.deps {\n-                let dep = PackageDependency {\n-                    name: dep_node.name.into(),\n-                    pkg: pkg_by_id[&dep_node.pkg],\n-                };\n-                packages[source].dependencies.push(dep);\n-            }\n-        }\n-\n-        Ok(CargoWorkspace { packages, targets })\n-    }\n-    pub fn packages<'a>(&'a self) -> impl Iterator<Item = Package> + 'a {\n-        self.packages.iter().map(|(id, _pkg)| id)\n-    }\n-    pub fn target_by_root(&self, root: &Path) -> Option<Target> {\n-        self.packages()\n-            .filter_map(|pkg| pkg.targets(self).find(|it| it.root(self) == root))\n-            .next()\n-    }\n-}\n-\n-fn sysroot_info(cargo_toml: &Path) -> Result<Sysroot> {\n-    let rustc_output = Command::new(\"rustc\")\n-        .current_dir(cargo_toml.parent().unwrap())\n-        .args(&[\"--print\", \"sysroot\"])\n-        .output()?;\n-    if !rustc_output.status.success() {\n-        failure::bail!(\"failed to locate sysroot\")\n-    }\n-    let stdout = String::from_utf8(rustc_output.stdout)?;\n-    let sysroot_path = Path::new(stdout.trim());\n-    let src = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n-\n-    let crates: &[(&str, &[&str])] = &[\n-        (\n-            \"std\",\n-            &[\n-                \"alloc_jemalloc\",\n-                \"alloc_system\",\n-                \"panic_abort\",\n-                \"rand\",\n-                \"compiler_builtins\",\n-                \"unwind\",\n-                \"rustc_asan\",\n-                \"rustc_lsan\",\n-                \"rustc_msan\",\n-                \"rustc_tsan\",\n-                \"build_helper\",\n-            ],\n-        ),\n-        (\"core\", &[]),\n-        (\"alloc\", &[]),\n-        (\"collections\", &[]),\n-        (\"libc\", &[]),\n-        (\"panic_unwind\", &[]),\n-        (\"proc_macro\", &[]),\n-        (\"rustc_unicode\", &[]),\n-        (\"std_unicode\", &[]),\n-        (\"test\", &[]),\n-        // Feature gated\n-        (\"alloc_jemalloc\", &[]),\n-        (\"alloc_system\", &[]),\n-        (\"compiler_builtins\", &[]),\n-        (\"getopts\", &[]),\n-        (\"panic_unwind\", &[]),\n-        (\"panic_abort\", &[]),\n-        (\"rand\", &[]),\n-        (\"term\", &[]),\n-        (\"unwind\", &[]),\n-        // Dependencies\n-        (\"build_helper\", &[]),\n-        (\"rustc_asan\", &[]),\n-        (\"rustc_lsan\", &[]),\n-        (\"rustc_msan\", &[]),\n-        (\"rustc_tsan\", &[]),\n-        (\"syntax\", &[]),\n-    ];\n-\n-    Ok(Sysroot {\n-        crates: FxHashMap::default(),\n-    })\n-}\n-\n fn find_cargo_toml(path: &Path) -> Result<PathBuf> {\n     if path.ends_with(\"Cargo.toml\") {\n         return Ok(path.to_path_buf());\n@@ -274,19 +59,3 @@ fn find_cargo_toml(path: &Path) -> Result<PathBuf> {\n     }\n     bail!(\"can't find Cargo.toml at {}\", path.display())\n }\n-\n-impl TargetKind {\n-    fn new(kinds: &[String]) -> TargetKind {\n-        for kind in kinds {\n-            return match kind.as_str() {\n-                \"bin\" => TargetKind::Bin,\n-                \"test\" => TargetKind::Test,\n-                \"bench\" => TargetKind::Bench,\n-                \"example\" => TargetKind::Example,\n-                _ if kind.contains(\"lib\") => TargetKind::Lib,\n-                _ => continue,\n-            };\n-        }\n-        TargetKind::Other\n-    }\n-}"}, {"sha": "138fdee2263c6d9ad4b4e9560860a8fec7fae443", "filename": "crates/ra_lsp_server/src/project_model/cargo_workspace.rs", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/66fba88534039ff42a230f1ede3e0a730f61ad3c/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66fba88534039ff42a230f1ede3e0a730f61ad3c/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fcargo_workspace.rs?ref=66fba88534039ff42a230f1ede3e0a730f61ad3c", "patch": "@@ -0,0 +1,173 @@\n+use std::{\n+    path::{Path, PathBuf},\n+};\n+\n+use cargo_metadata::{metadata_run, CargoOpt};\n+use ra_syntax::SmolStr;\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use rustc_hash::FxHashMap;\n+use failure::format_err;\n+\n+use crate::Result;\n+\n+/// `CargoWorksapce` represents the logical structure of, well, a Cargo\n+/// workspace. It pretty closely mirrors `cargo metadata` output.\n+///\n+/// Note that internally, rust analyzer uses a differnet structure:\n+/// `CrateGraph`. `CrateGraph` is lower-level: it knows only about the crates,\n+/// while this knows about `Pacakges` & `Targets`: purely cargo-related\n+/// concepts.\n+#[derive(Debug, Clone)]\n+pub struct CargoWorkspace {\n+    packages: Arena<Package, PackageData>,\n+    targets: Arena<Target, TargetData>,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct Package(RawId);\n+impl_arena_id!(Package);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct Target(RawId);\n+impl_arena_id!(Target);\n+\n+#[derive(Debug, Clone)]\n+struct PackageData {\n+    name: SmolStr,\n+    manifest: PathBuf,\n+    targets: Vec<Target>,\n+    is_member: bool,\n+    dependencies: Vec<PackageDependency>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct PackageDependency {\n+    pub pkg: Package,\n+    pub name: SmolStr,\n+}\n+\n+#[derive(Debug, Clone)]\n+struct TargetData {\n+    pkg: Package,\n+    name: SmolStr,\n+    root: PathBuf,\n+    kind: TargetKind,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum TargetKind {\n+    Bin,\n+    Lib,\n+    Example,\n+    Test,\n+    Bench,\n+    Other,\n+}\n+\n+impl TargetKind {\n+    fn new(kinds: &[String]) -> TargetKind {\n+        for kind in kinds {\n+            return match kind.as_str() {\n+                \"bin\" => TargetKind::Bin,\n+                \"test\" => TargetKind::Test,\n+                \"bench\" => TargetKind::Bench,\n+                \"example\" => TargetKind::Example,\n+                _ if kind.contains(\"lib\") => TargetKind::Lib,\n+                _ => continue,\n+            };\n+        }\n+        TargetKind::Other\n+    }\n+}\n+\n+impl Package {\n+    pub fn name(self, ws: &CargoWorkspace) -> &str {\n+        ws.packages[self].name.as_str()\n+    }\n+    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n+        ws.packages[self].manifest.parent().unwrap()\n+    }\n+    pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n+        ws.packages[self].targets.iter().cloned()\n+    }\n+    #[allow(unused)]\n+    pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n+        ws.packages[self].is_member\n+    }\n+    pub fn dependencies<'a>(\n+        self,\n+        ws: &'a CargoWorkspace,\n+    ) -> impl Iterator<Item = &'a PackageDependency> + 'a {\n+        ws.packages[self].dependencies.iter()\n+    }\n+}\n+\n+impl Target {\n+    pub fn package(self, ws: &CargoWorkspace) -> Package {\n+        ws.targets[self].pkg\n+    }\n+    pub fn name(self, ws: &CargoWorkspace) -> &str {\n+        ws.targets[self].name.as_str()\n+    }\n+    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n+        ws.targets[self].root.as_path()\n+    }\n+    pub fn kind(self, ws: &CargoWorkspace) -> TargetKind {\n+        ws.targets[self].kind\n+    }\n+}\n+\n+impl CargoWorkspace {\n+    pub fn from_cargo_metadata(cargo_toml: &Path) -> Result<CargoWorkspace> {\n+        let meta = metadata_run(Some(cargo_toml), true, Some(CargoOpt::AllFeatures))\n+            .map_err(|e| format_err!(\"cargo metadata failed: {}\", e))?;\n+        let mut pkg_by_id = FxHashMap::default();\n+        let mut packages = Arena::default();\n+        let mut targets = Arena::default();\n+\n+        let ws_members = &meta.workspace_members;\n+\n+        for meta_pkg in meta.packages {\n+            let is_member = ws_members.contains(&meta_pkg.id);\n+            let pkg = packages.alloc(PackageData {\n+                name: meta_pkg.name.into(),\n+                manifest: meta_pkg.manifest_path.clone(),\n+                targets: Vec::new(),\n+                is_member,\n+                dependencies: Vec::new(),\n+            });\n+            let pkg_data = &mut packages[pkg];\n+            pkg_by_id.insert(meta_pkg.id.clone(), pkg);\n+            for meta_tgt in meta_pkg.targets {\n+                let tgt = targets.alloc(TargetData {\n+                    pkg,\n+                    name: meta_tgt.name.into(),\n+                    root: meta_tgt.src_path.clone(),\n+                    kind: TargetKind::new(meta_tgt.kind.as_slice()),\n+                });\n+                pkg_data.targets.push(tgt);\n+            }\n+        }\n+        let resolve = meta.resolve.expect(\"metadata executed with deps\");\n+        for node in resolve.nodes {\n+            let source = pkg_by_id[&node.id];\n+            for dep_node in node.deps {\n+                let dep = PackageDependency {\n+                    name: dep_node.name.into(),\n+                    pkg: pkg_by_id[&dep_node.pkg],\n+                };\n+                packages[source].dependencies.push(dep);\n+            }\n+        }\n+\n+        Ok(CargoWorkspace { packages, targets })\n+    }\n+    pub fn packages<'a>(&'a self) -> impl Iterator<Item = Package> + 'a {\n+        self.packages.iter().map(|(id, _pkg)| id)\n+    }\n+    pub fn target_by_root(&self, root: &Path) -> Option<Target> {\n+        self.packages()\n+            .filter_map(|pkg| pkg.targets(self).find(|it| it.root(self) == root))\n+            .next()\n+    }\n+}"}, {"sha": "ae72c9c17a94ffeb8c40afcc882be068040a8ed0", "filename": "crates/ra_lsp_server/src/project_model/sysroot.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/66fba88534039ff42a230f1ede3e0a730f61ad3c/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66fba88534039ff42a230f1ede3e0a730f61ad3c/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model%2Fsysroot.rs?ref=66fba88534039ff42a230f1ede3e0a730f61ad3c", "patch": "@@ -0,0 +1,78 @@\n+use std::{\n+    path::{Path, PathBuf},\n+    process::Command,\n+};\n+\n+use ra_syntax::SmolStr;\n+use rustc_hash::FxHashMap;\n+\n+use crate::Result;\n+\n+#[derive(Debug, Clone)]\n+pub struct Sysroot {\n+    crates: FxHashMap<SmolStr, PathBuf>,\n+}\n+\n+impl Sysroot {\n+    pub(crate) fn discover(cargo_toml: &Path) -> Result<Sysroot> {\n+        let rustc_output = Command::new(\"rustc\")\n+            .current_dir(cargo_toml.parent().unwrap())\n+            .args(&[\"--print\", \"sysroot\"])\n+            .output()?;\n+        if !rustc_output.status.success() {\n+            failure::bail!(\"failed to locate sysroot\")\n+        }\n+        let stdout = String::from_utf8(rustc_output.stdout)?;\n+        let sysroot_path = Path::new(stdout.trim());\n+        let src = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n+\n+        let crates: &[(&str, &[&str])] = &[\n+            (\n+                \"std\",\n+                &[\n+                    \"alloc_jemalloc\",\n+                    \"alloc_system\",\n+                    \"panic_abort\",\n+                    \"rand\",\n+                    \"compiler_builtins\",\n+                    \"unwind\",\n+                    \"rustc_asan\",\n+                    \"rustc_lsan\",\n+                    \"rustc_msan\",\n+                    \"rustc_tsan\",\n+                    \"build_helper\",\n+                ],\n+            ),\n+            (\"core\", &[]),\n+            (\"alloc\", &[]),\n+            (\"collections\", &[]),\n+            (\"libc\", &[]),\n+            (\"panic_unwind\", &[]),\n+            (\"proc_macro\", &[]),\n+            (\"rustc_unicode\", &[]),\n+            (\"std_unicode\", &[]),\n+            (\"test\", &[]),\n+            // Feature gated\n+            (\"alloc_jemalloc\", &[]),\n+            (\"alloc_system\", &[]),\n+            (\"compiler_builtins\", &[]),\n+            (\"getopts\", &[]),\n+            (\"panic_unwind\", &[]),\n+            (\"panic_abort\", &[]),\n+            (\"rand\", &[]),\n+            (\"term\", &[]),\n+            (\"unwind\", &[]),\n+            // Dependencies\n+            (\"build_helper\", &[]),\n+            (\"rustc_asan\", &[]),\n+            (\"rustc_lsan\", &[]),\n+            (\"rustc_msan\", &[]),\n+            (\"rustc_tsan\", &[]),\n+            (\"syntax\", &[]),\n+        ];\n+\n+        Ok(Sysroot {\n+            crates: FxHashMap::default(),\n+        })\n+    }\n+}"}]}