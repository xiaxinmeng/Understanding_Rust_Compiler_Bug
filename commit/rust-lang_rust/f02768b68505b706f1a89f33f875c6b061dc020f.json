{"sha": "f02768b68505b706f1a89f33f875c6b061dc020f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMjc2OGI2ODUwNWI3MDZmMWE4OWYzM2Y4NzVjNmIwNjFkYzAyMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-15T00:18:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-15T00:18:27Z"}, "message": "Auto merge of #55008 - ljedrz:cleanup_rustc_driver, r=estebank\n\nCleanup rustc/driver\n\n- improve/remove allocations\n- simplify `profile::trace::cons*`\n- don't sort `base` if it only has one element\n- use `Cow<str>` where applicable\n- use `unwrap_or_else` with function calls\n- remove an explicit `return`, add an explicit `None`\n- remove lifetimes from `const`s\n- improve common patterns\n- improve macro calls\n- whitespace & formatting fixes", "tree": {"sha": "5da803523c4c5ac85c4dd08825f5eea7ff76de71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5da803523c4c5ac85c4dd08825f5eea7ff76de71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f02768b68505b706f1a89f33f875c6b061dc020f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f02768b68505b706f1a89f33f875c6b061dc020f", "html_url": "https://github.com/rust-lang/rust/commit/f02768b68505b706f1a89f33f875c6b061dc020f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f02768b68505b706f1a89f33f875c6b061dc020f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c665e20db6c61de8f741bca3ca7660e679885c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c665e20db6c61de8f741bca3ca7660e679885c0", "html_url": "https://github.com/rust-lang/rust/commit/0c665e20db6c61de8f741bca3ca7660e679885c0"}, {"sha": "b03a82cfca27c11fabc19e4146d6583b3cd320ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/b03a82cfca27c11fabc19e4146d6583b3cd320ae", "html_url": "https://github.com/rust-lang/rust/commit/b03a82cfca27c11fabc19e4146d6583b3cd320ae"}], "stats": {"total": 454, "additions": 208, "deletions": 246}, "files": [{"sha": "b4f95b915eb8d26817de3f7aa17d861832889bd7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f02768b68505b706f1a89f33f875c6b061dc020f", "patch": "@@ -44,7 +44,7 @@ use serialize::json;\n \n use std::any::Any;\n use std::env;\n-use std::ffi::{OsStr, OsString};\n+use std::ffi::OsString;\n use std::fs;\n use std::io::{self, Write};\n use std::iter;\n@@ -1021,6 +1021,7 @@ where\n             .cloned()\n             .collect();\n         missing_fragment_specifiers.sort();\n+\n         for span in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n             let msg = \"missing fragment specifier\";\n@@ -1472,7 +1473,7 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[Pa\n             .collect();\n         let mut file = fs::File::create(&deps_filename)?;\n         for path in out_filenames {\n-            write!(file, \"{}: {}\\n\\n\", path.display(), files.join(\" \"))?;\n+            writeln!(file, \"{}: {}\\n\", path.display(), files.join(\" \"))?;\n         }\n \n         // Emit a fake target for each input file to the compilation. This\n@@ -1484,15 +1485,12 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[Pa\n         Ok(())\n     })();\n \n-    match result {\n-        Ok(()) => {}\n-        Err(e) => {\n-            sess.fatal(&format!(\n-                \"error writing dependencies to `{}`: {}\",\n-                deps_filename.display(),\n-                e\n-            ));\n-        }\n+    if let Err(e) = result {\n+        sess.fatal(&format!(\n+            \"error writing dependencies to `{}`: {}\",\n+            deps_filename.display(),\n+            e\n+        ));\n     }\n }\n \n@@ -1520,6 +1518,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                             Symbol::intern(\"proc-macro\"),\n                             Symbol::intern(\"bin\")\n                         ];\n+\n                         if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().node {\n                             let span = spanned.span;\n                             let lev_candidate = find_best_match_for_name(\n@@ -1551,7 +1550,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                         }\n                         None\n                     }\n-                    _ => {\n+                    None => {\n                         session\n                             .struct_span_err(a.span, \"`crate_type` requires a value\")\n                             .note(\"for example: `#![crate_type=\\\"lib\\\"]`\")\n@@ -1581,25 +1580,26 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n             base.push(::rustc_codegen_utils::link::default_output_for_target(\n                 session,\n             ));\n+        } else {\n+            base.sort();\n+            base.dedup();\n         }\n-        base.sort();\n-        base.dedup();\n     }\n \n-    base.into_iter()\n-        .filter(|crate_type| {\n-            let res = !::rustc_codegen_utils::link::invalid_output_for_target(session, *crate_type);\n+    base.retain(|crate_type| {\n+        let res = !::rustc_codegen_utils::link::invalid_output_for_target(session, *crate_type);\n \n-            if !res {\n-                session.warn(&format!(\n-                    \"dropping unsupported crate type `{}` for target `{}`\",\n-                    *crate_type, session.opts.target_triple\n-                ));\n-            }\n+        if !res {\n+            session.warn(&format!(\n+                \"dropping unsupported crate type `{}` for target `{}`\",\n+                *crate_type, session.opts.target_triple\n+            ));\n+        }\n \n-            res\n-        })\n-        .collect()\n+        res\n+    });\n+\n+    base\n }\n \n pub fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n@@ -1650,17 +1650,14 @@ pub fn build_output_filenames(\n             // \"-\" as input file will cause the parser to read from stdin so we\n             // have to make up a name\n             // We want to toss everything after the final '.'\n-            let dirpath = match *odir {\n-                Some(ref d) => d.clone(),\n-                None => PathBuf::new(),\n-            };\n+            let dirpath = (*odir).as_ref().cloned().unwrap_or_default();\n \n             // If a crate name is present, we use it as the link name\n             let stem = sess.opts\n                 .crate_name\n                 .clone()\n                 .or_else(|| attr::find_crate_name(attrs).map(|n| n.to_string()))\n-                .unwrap_or(input.filestem());\n+                .unwrap_or_else(|| input.filestem());\n \n             OutputFilenames {\n                 out_directory: dirpath,\n@@ -1693,13 +1690,11 @@ pub fn build_output_filenames(\n                 sess.warn(\"ignoring -C extra-filename flag due to -o flag\");\n             }\n \n-            let cur_dir = Path::new(\"\");\n-\n             OutputFilenames {\n-                out_directory: out_file.parent().unwrap_or(cur_dir).to_path_buf(),\n+                out_directory: out_file.parent().unwrap_or_else(|| Path::new(\"\")).to_path_buf(),\n                 out_filestem: out_file\n                     .file_stem()\n-                    .unwrap_or(OsStr::new(\"\"))\n+                    .unwrap_or_default()\n                     .to_str()\n                     .unwrap()\n                     .to_string(),"}, {"sha": "276b7290c2ef012de4ac7e0c83b48a1a77702232", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 73, "deletions": 101, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=f02768b68505b706f1a89f33f875c6b061dc020f", "patch": "@@ -89,6 +89,7 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use serialize::json::ToJson;\n \n use std::any::Any;\n+use std::borrow::Cow;\n use std::cmp::max;\n use std::default::Default;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n@@ -136,9 +137,7 @@ pub mod target_features {\n                              codegen_backend: &dyn CodegenBackend) {\n         let tf = Symbol::intern(\"target_feature\");\n \n-        for feat in codegen_backend.target_features(sess) {\n-            cfg.insert((tf, Some(feat)));\n-        }\n+        cfg.extend(codegen_backend.target_features(sess).into_iter().map(|feat| (tf, Some(feat))));\n \n         if sess.crt_static_feature() {\n             cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n@@ -152,21 +151,14 @@ pub const EXIT_SUCCESS: isize = 0;\n /// Exit status code used for compilation failures and  invalid flags.\n pub const EXIT_FAILURE: isize = 1;\n \n-const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n-                                      md#bug-reports\";\n-\n-const ICE_REPORT_COMPILER_FLAGS: &'static [&'static str] = &[\n-    \"Z\",\n-    \"C\",\n-    \"crate-type\",\n-];\n-const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &'static [&'static str] = &[\n-    \"metadata\",\n-    \"extra-filename\",\n-];\n-const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &'static [&'static str] = &[\n-    \"incremental\",\n-];\n+const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n+                              md#bug-reports\";\n+\n+const ICE_REPORT_COMPILER_FLAGS: &[&str] = &[\"Z\", \"C\", \"crate-type\"];\n+\n+const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &[&str] = &[\"metadata\", \"extra-filename\"];\n+\n+const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &[&str] = &[\"incremental\"];\n \n pub fn abort_on_err<T>(result: Result<T, CompileIncomplete>, sess: &Session) -> T {\n     match result {\n@@ -195,14 +187,16 @@ pub fn run<F>(run_compiler: F) -> isize\n                     }\n                     None => {\n                         let emitter =\n-                            errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n-                                                                None,\n-                                                                true,\n-                                                                false);\n+                            errors::emitter::EmitterWriter::stderr(\n+                                errors::ColorConfig::Auto,\n+                                None,\n+                                true,\n+                                false\n+                            );\n                         let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n                         handler.emit(&MultiSpan::new(),\n-                                    \"aborting due to previous error(s)\",\n-                                    errors::Level::Fatal);\n+                                     \"aborting due to previous error(s)\",\n+                                     errors::Level::Fatal);\n                         panic::resume_unwind(Box::new(errors::FatalErrorMarker));\n                     }\n                 }\n@@ -224,15 +218,10 @@ fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n     // available for future dynamic libraries opened. This is currently used by\n     // loading LLVM and then making its symbols available for other dynamic\n     // libraries.\n-    let lib = match DynamicLibrary::open_global_now(path) {\n-        Ok(lib) => lib,\n-        Err(err) => {\n-            let err = format!(\"couldn't load codegen backend {:?}: {:?}\",\n-                              path,\n-                              err);\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-    };\n+    let lib = DynamicLibrary::open_global_now(path).unwrap_or_else(|err| {\n+        let err = format!(\"couldn't load codegen backend {:?}: {:?}\", path, err);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n     unsafe {\n         match lib.symbol(\"__rustc_codegen_backend\") {\n             Ok(f) => {\n@@ -328,37 +317,30 @@ fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n     let sysroot = sysroot_candidates.iter()\n         .map(|sysroot| {\n             let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n-            sysroot.join(libdir)\n-                .with_file_name(option_env!(\"CFG_CODEGEN_BACKENDS_DIR\")\n-                                .unwrap_or(\"codegen-backends\"))\n+            sysroot.join(libdir).with_file_name(\n+                option_env!(\"CFG_CODEGEN_BACKENDS_DIR\").unwrap_or(\"codegen-backends\"))\n         })\n         .filter(|f| {\n             info!(\"codegen backend candidate: {}\", f.display());\n             f.exists()\n         })\n         .next();\n-    let sysroot = match sysroot {\n-        Some(path) => path,\n-        None => {\n-            let candidates = sysroot_candidates.iter()\n-                .map(|p| p.display().to_string())\n-                .collect::<Vec<_>>()\n-                .join(\"\\n* \");\n-            let err = format!(\"failed to find a `codegen-backends` folder \\\n-                               in the sysroot candidates:\\n* {}\", candidates);\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-    };\n+    let sysroot = sysroot.unwrap_or_else(|| {\n+        let candidates = sysroot_candidates.iter()\n+            .map(|p| p.display().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n* \");\n+        let err = format!(\"failed to find a `codegen-backends` folder \\\n+                           in the sysroot candidates:\\n* {}\", candidates);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n     info!(\"probing {} for a codegen backend\", sysroot.display());\n \n-    let d = match sysroot.read_dir() {\n-        Ok(d) => d,\n-        Err(e) => {\n-            let err = format!(\"failed to load default codegen backend, couldn't \\\n-                               read `{}`: {}\", sysroot.display(), e);\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-    };\n+    let d = sysroot.read_dir().unwrap_or_else(|e| {\n+        let err = format!(\"failed to load default codegen backend, couldn't \\\n+                           read `{}`: {}\", sysroot.display(), e);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n \n     let mut file: Option<PathBuf> = None;\n \n@@ -378,8 +360,8 @@ fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n         }\n         if let Some(ref prev) = file {\n             let err = format!(\"duplicate codegen backends found\\n\\\n-                first:  {}\\n\\\n-                second: {}\\n\\\n+                               first:  {}\\n\\\n+                               second: {}\\n\\\n             \", prev.display(), path.display());\n             early_error(ErrorOutputType::default(), &err);\n         }\n@@ -391,7 +373,7 @@ fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n         None => {\n             let err = format!(\"failed to load default codegen backend for `{}`, \\\n                                no appropriate codegen dylib found in `{}`\",\n-                               backend_name, sysroot.display());\n+                              backend_name, sysroot.display());\n             early_error(ErrorOutputType::default(), &err);\n         }\n     }\n@@ -578,7 +560,7 @@ pub fn set_sigpipe_handler() {\n     unsafe {\n         // Set the SIGPIPE signal handler, so that an EPIPE\n         // will cause rustc to terminate, as expected.\n-        assert!(libc::signal(libc::SIGPIPE, libc::SIG_DFL) != libc::SIG_ERR);\n+        assert_ne!(libc::signal(libc::SIGPIPE, libc::SIG_DFL), libc::SIG_ERR);\n     }\n }\n \n@@ -996,7 +978,7 @@ impl RustcDefaultCalls {\n                          input: &Input)\n                          -> Compilation {\n         let r = matches.opt_strs(\"Z\");\n-        if r.contains(&(\"ls\".to_string())) {\n+        if r.iter().any(|s| *s == \"ls\") {\n             match input {\n                 &Input::File(ref ifile) => {\n                     let path = &(*ifile);\n@@ -1015,7 +997,7 @@ impl RustcDefaultCalls {\n             return Compilation::Stop;\n         }\n \n-        return Compilation::Continue;\n+        Compilation::Continue\n     }\n \n \n@@ -1028,7 +1010,7 @@ impl RustcDefaultCalls {\n         use rustc::session::config::PrintRequest::*;\n         // PrintRequest::NativeStaticLibs is special - printed during linking\n         // (empty iterator returns true)\n-        if sess.opts.prints.iter().all(|&p| p==PrintRequest::NativeStaticLibs) {\n+        if sess.opts.prints.iter().all(|&p| p == PrintRequest::NativeStaticLibs) {\n             return Compilation::Continue;\n         }\n \n@@ -1055,10 +1037,8 @@ impl RustcDefaultCalls {\n                 Sysroot => println!(\"{}\", sess.sysroot().display()),\n                 TargetSpec => println!(\"{}\", sess.target.target.to_json().pretty()),\n                 FileNames | CrateName => {\n-                    let input = match input {\n-                        Some(input) => input,\n-                        None => early_error(ErrorOutputType::default(), \"no input file provided\"),\n-                    };\n+                    let input = input.unwrap_or_else(||\n+                        early_error(ErrorOutputType::default(), \"no input file provided\"));\n                     let attrs = attrs.as_ref().unwrap();\n                     let t_outputs = driver::build_output_filenames(input, odir, ofile, attrs, sess);\n                     let id = rustc_codegen_utils::link::find_crate_name(Some(sess), attrs, input);\n@@ -1074,18 +1054,14 @@ impl RustcDefaultCalls {\n                             &id,\n                             &t_outputs\n                         );\n-                        println!(\"{}\",\n-                                 fname.file_name()\n-                                      .unwrap()\n-                                      .to_string_lossy());\n+                        println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n                     }\n                 }\n                 Cfg => {\n                     let allow_unstable_cfg = UnstableFeatures::from_environment()\n                         .is_nightly_build();\n \n-                    let mut cfgs = Vec::new();\n-                    for &(name, ref value) in sess.parse_sess.config.iter() {\n+                    let mut cfgs = sess.parse_sess.config.iter().filter_map(|&(name, ref value)| {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n                             ident: ast::Path::from_ident(ast::Ident::with_empty_ctxt(name)),\n                             node: ast::MetaItemKind::Word,\n@@ -1104,16 +1080,16 @@ impl RustcDefaultCalls {\n                         let value = value.as_ref().map(|s| s.as_ref());\n                         if name != \"target_feature\" || value != Some(\"crt-static\") {\n                             if !allow_unstable_cfg && gated_cfg.is_some() {\n-                                continue;\n+                                return None\n                             }\n                         }\n \n-                        cfgs.push(if let Some(value) = value {\n-                            format!(\"{}=\\\"{}\\\"\", name, value)\n+                        if let Some(value) = value {\n+                            Some(format!(\"{}=\\\"{}\\\"\", name, value))\n                         } else {\n-                            name.to_string()\n-                        });\n-                    }\n+                            Some(name.to_string())\n+                        }\n+                    }).collect::<Vec<String>>();\n \n                     cfgs.sort();\n                     for cfg in cfgs {\n@@ -1150,9 +1126,8 @@ fn commit_date_str() -> Option<&'static str> {\n pub fn version(binary: &str, matches: &getopts::Matches) {\n     let verbose = matches.opt_present(\"verbose\");\n \n-    println!(\"{} {}\",\n-             binary,\n-             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"));\n+    println!(\"{} {}\", binary, option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"));\n+\n     if verbose {\n         fn unw(x: Option<&str>) -> &str {\n             x.unwrap_or(\"unknown\")\n@@ -1176,7 +1151,7 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     for option in groups.iter().filter(|x| include_unstable_options || x.is_stable()) {\n         (option.apply)(&mut options);\n     }\n-    let message = \"Usage: rustc [OPTIONS] INPUT\".to_string();\n+    let message = \"Usage: rustc [OPTIONS] INPUT\";\n     let nightly_help = if nightly_options::is_nightly_build() {\n         \"\\n    -Z help             Print internal options for debugging rustc\"\n     } else {\n@@ -1191,7 +1166,7 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     -C help             Print codegen options\n     -W help             \\\n               Print 'lint' options and default settings{}{}\\n\",\n-             options.usage(&message),\n+             options.usage(message),\n              nightly_help,\n              verbose_help);\n }\n@@ -1273,8 +1248,6 @@ Available lint options:\n \n     print_lints(builtin);\n \n-\n-\n     let max_name_len = max(\"warnings\".len(),\n                            plugin_groups.iter()\n                                         .chain(&builtin_groups)\n@@ -1407,10 +1380,8 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     for option in config::rustc_optgroups() {\n         (option.apply)(&mut options);\n     }\n-    let matches = match options.parse(args) {\n-        Ok(m) => m,\n-        Err(f) => early_error(ErrorOutputType::default(), &f.to_string()),\n-    };\n+    let matches = options.parse(args).unwrap_or_else(|f|\n+        early_error(ErrorOutputType::default(), &f.to_string()));\n \n     // For all options we just parsed, we check a few aspects:\n     //\n@@ -1452,6 +1423,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     let cg_flags = matches.opt_strs(\"C\");\n+\n     if cg_flags.iter().any(|x| *x == \"help\") {\n         describe_codegen_flags();\n         return None;\n@@ -1462,7 +1434,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n                    \"the --no-stack-check flag is deprecated and does nothing\");\n     }\n \n-    if cg_flags.contains(&\"passes=list\".to_string()) {\n+    if cg_flags.iter().any(|x| *x == \"passes=list\") {\n         get_codegen_sysroot(\"llvm\")().print_passes();\n         return None;\n     }\n@@ -1500,7 +1472,7 @@ pub fn in_named_rustc_thread<F, R>(name: String, f: F) -> Result<R, Box<dyn Any\n     // Temporarily have stack size set to 16MB to deal with nom-using crates failing\n     const STACK_SIZE: usize = 16 * 1024 * 1024; // 16MB\n \n-    #[cfg(all(unix,not(target_os = \"haiku\")))]\n+    #[cfg(all(unix, not(target_os = \"haiku\")))]\n     let spawn_thread = unsafe {\n         // Fetch the current resource limits\n         let mut rlim = libc::rlimit {\n@@ -1554,7 +1526,7 @@ pub fn in_named_rustc_thread<F, R>(name: String, f: F) -> Result<R, Box<dyn Any\n         }\n     };\n \n-    #[cfg(not(any(windows,unix)))]\n+    #[cfg(not(any(windows, unix)))]\n     let spawn_thread = true;\n \n     // The or condition is added from backward compatibility.\n@@ -1632,7 +1604,7 @@ fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n         }\n     }\n \n-    if result.len() > 0 {\n+    if !result.is_empty() {\n         Some((result, excluded_cargo_defaults))\n     } else {\n         None\n@@ -1680,25 +1652,25 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) -> Result<(), CompilationFail\n                              errors::Level::Bug);\n             }\n \n-            let mut xs = vec![\n-                \"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n-                format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL),\n+            let mut xs: Vec<Cow<'static, str>> = vec![\n+                \"the compiler unexpectedly panicked. this is a bug.\".into(),\n+                format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL).into(),\n                 format!(\"rustc {} running on {}\",\n                         option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n-                        config::host_triple()),\n+                        config::host_triple()).into(),\n             ];\n \n             if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n-                xs.push(format!(\"compiler flags: {}\", flags.join(\" \")));\n+                xs.push(format!(\"compiler flags: {}\", flags.join(\" \")).into());\n \n                 if excluded_cargo_defaults {\n-                    xs.push(\"some of the compiler flags provided by cargo are hidden\".to_string());\n+                    xs.push(\"some of the compiler flags provided by cargo are hidden\".into());\n                 }\n             }\n \n             for note in &xs {\n                 handler.emit(&MultiSpan::new(),\n-                             &note,\n+                             note,\n                              errors::Level::Note);\n             }\n "}, {"sha": "b4f6d10b1f829f91f96004b13b60429b7ff643a9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=f02768b68505b706f1a89f33f875c6b061dc020f", "patch": "@@ -167,10 +167,10 @@ pub fn parse_pretty(sess: &Session,\n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n     fn call_with_pp_support<'tcx, A, F>(&self,\n-                                           sess: &'tcx Session,\n-                                           hir_map: Option<&hir_map::Map<'tcx>>,\n-                                           f: F)\n-                                           -> A\n+                                        sess: &'tcx Session,\n+                                        hir_map: Option<&hir_map::Map<'tcx>>,\n+                                        f: F)\n+                                        -> A\n         where F: FnOnce(&dyn PrinterSupport) -> A\n     {\n         match *self {\n@@ -198,17 +198,18 @@ impl PpSourceMode {\n             _ => panic!(\"Should use call_with_pp_support_hir\"),\n         }\n     }\n-    fn call_with_pp_support_hir<'tcx, A, F>(&self,\n-                                               sess: &'tcx Session,\n-                                               cstore: &'tcx CStore,\n-                                               hir_map: &hir_map::Map<'tcx>,\n-                                               analysis: &ty::CrateAnalysis,\n-                                               resolutions: &Resolutions,\n-                                               arenas: &'tcx AllArenas<'tcx>,\n-                                               output_filenames: &OutputFilenames,\n-                                               id: &str,\n-                                               f: F)\n-                                               -> A\n+    fn call_with_pp_support_hir<'tcx, A, F>(\n+        &self,\n+        sess: &'tcx Session,\n+        cstore: &'tcx CStore,\n+        hir_map: &hir_map::Map<'tcx>,\n+        analysis: &ty::CrateAnalysis,\n+        resolutions: &Resolutions,\n+        arenas: &'tcx AllArenas<'tcx>,\n+        output_filenames: &OutputFilenames,\n+        id: &str,\n+        f: F\n+    ) -> A\n         where F: FnOnce(&dyn HirPrinterSupport, &hir::Crate) -> A\n     {\n         match *self {\n@@ -855,7 +856,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                     break n.body();\n                 }\n                 let parent = tcx.hir.get_parent_node(node_id);\n-                assert!(node_id != parent);\n+                assert_ne!(node_id, parent);\n                 node_id = parent;\n             }\n         }\n@@ -952,18 +953,17 @@ pub fn print_after_parsing(sess: &Session,\n         // Silently ignores an identified node.\n         let out: &mut dyn Write = &mut out;\n         s.call_with_pp_support(sess, None, move |annotation| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                pprust::print_crate(sess.source_map(),\n-                                    &sess.parse_sess,\n-                                    krate,\n-                                    src_name,\n-                                    &mut rdr,\n-                                    box out,\n-                                    annotation.pp_ann(),\n-                                    false)\n-            })\n-            .unwrap()\n+            debug!(\"pretty printing source code {:?}\", s);\n+            let sess = annotation.sess();\n+            pprust::print_crate(sess.source_map(),\n+                                &sess.parse_sess,\n+                                krate,\n+                                src_name,\n+                                &mut rdr,\n+                                box out,\n+                                annotation.pp_ann(),\n+                                false)\n+        }).unwrap()\n     } else {\n         unreachable!();\n     };"}, {"sha": "d334a9476ce249d0d2f271fc5706b68ce0bb688c", "filename": "src/librustc_driver/profile/mod.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Fmod.rs?ref=f02768b68505b706f1a89f33f875c6b061dc020f", "patch": "@@ -23,7 +23,7 @@ pub fn begin(sess: &Session) {\n     use std::sync::mpsc::{channel};\n     let (tx, rx) = channel();\n     if profq_set_chan(sess, tx) {\n-        thread::spawn(move||profile_queries_thread(rx));\n+        thread::spawn(move || profile_queries_thread(rx));\n     }\n }\n \n@@ -34,11 +34,12 @@ pub fn begin(sess: &Session) {\n pub fn dump(sess: &Session, path: String) {\n     use std::sync::mpsc::{channel};\n     let (tx, rx) = channel();\n-    let params = ProfQDumpParams{\n-        path, ack:tx,\n+    let params = ProfQDumpParams {\n+        path,\n+        ack: tx,\n         // FIXME: Add another compiler flag to toggle whether this log\n         // is written; false for now\n-        dump_profq_msg_log:true,\n+        dump_profq_msg_log: true,\n     };\n     profq_msg(sess, ProfileQueriesMsg::Dump(params));\n     let _ = rx.recv().unwrap();\n@@ -63,20 +64,20 @@ struct StackFrame {\n }\n \n fn total_duration(traces: &[trace::Rec]) -> Duration {\n-    let mut sum : Duration = Duration::new(0,0);\n+    let mut sum : Duration = Duration::new(0, 0);\n     for t in traces.iter() { sum += t.dur_total; }\n     return sum\n }\n \n // profiling thread; retains state (in local variables) and dump traces, upon request.\n-fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n+fn profile_queries_thread(r: Receiver<ProfileQueriesMsg>) {\n     use self::trace::*;\n     use std::fs::File;\n     use std::time::{Instant};\n \n-    let mut profq_msgs : Vec<ProfileQueriesMsg> = vec![];\n-    let mut frame : StackFrame = StackFrame{ parse_st:ParseState::Clear, traces:vec![] };\n-    let mut stack : Vec<StackFrame> = vec![];\n+    let mut profq_msgs: Vec<ProfileQueriesMsg> = vec![];\n+    let mut frame: StackFrame = StackFrame { parse_st: ParseState::Clear, traces: vec![] };\n+    let mut stack: Vec<StackFrame> = vec![];\n     loop {\n         let msg = r.recv();\n         if let Err(_recv_err) = msg {\n@@ -90,7 +91,7 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n         match msg {\n             ProfileQueriesMsg::Halt => return,\n             ProfileQueriesMsg::Dump(params) => {\n-                assert!(stack.len() == 0);\n+                assert!(stack.is_empty());\n                 assert!(frame.parse_st == ParseState::Clear);\n                 {\n                     // write log of all messages\n@@ -109,17 +110,14 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                     let counts_path = format!(\"{}.counts.txt\", params.path);\n                     let mut counts_file = File::create(&counts_path).unwrap();\n \n-                    write!(html_file, \"<html>\\n\").unwrap();\n-                    write!(html_file,\n-                           \"<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\",\n-                           \"profile_queries.css\").unwrap();\n-                    write!(html_file, \"<style>\\n\").unwrap();\n+                    writeln!(html_file,\n+                        \"<html>\\n<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\",\n+                        \"profile_queries.css\").unwrap();\n+                    writeln!(html_file, \"<style>\").unwrap();\n                     trace::write_style(&mut html_file);\n-                    write!(html_file, \"</style>\\n\").unwrap();\n-                    write!(html_file, \"</head>\\n\").unwrap();\n-                    write!(html_file, \"<body>\\n\").unwrap();\n+                    writeln!(html_file, \"</style>\\n</head>\\n<body>\").unwrap();\n                     trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n-                    write!(html_file, \"</body>\\n</html>\\n\").unwrap();\n+                    writeln!(html_file, \"</body>\\n</html>\").unwrap();\n \n                     let ack_path = format!(\"{}.ack\", params.path);\n                     let ack_file = File::create(&ack_path).unwrap();\n@@ -141,10 +139,10 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n \n                     // Parse State: Clear\n                     (ParseState::Clear,\n-                     ProfileQueriesMsg::QueryBegin(span,querymsg)) => {\n+                     ProfileQueriesMsg::QueryBegin(span, querymsg)) => {\n                         let start = Instant::now();\n                         frame.parse_st = ParseState::HaveQuery\n-                            (Query{span:span, msg:querymsg}, start)\n+                            (Query { span, msg: querymsg }, start)\n                     },\n                     (ParseState::Clear,\n                      ProfileQueriesMsg::CacheHit) => {\n@@ -287,8 +285,6 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                         frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n                     },\n \n-                    //\n-                    //\n                     // Parse errors:\n \n                     (ParseState::HaveQuery(q,_),\n@@ -310,7 +306,6 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                         unreachable!()\n                     },\n                 }\n-\n             }\n         }\n     }"}, {"sha": "9589ae2a8dbe0032848633a6b04342987109a3cf", "filename": "src/librustc_driver/profile/trace.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02768b68505b706f1a89f33f875c6b061dc020f/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=f02768b68505b706f1a89f33f875c6b061dc020f", "patch": "@@ -43,18 +43,18 @@ pub struct QueryMetric {\n     pub dur_total: Duration,\n }\n \n+fn cons(s: &str) -> String {\n+    let first = s.split(|d| d == '(' || d == '{').next();\n+    assert!(first.is_some() && first != Some(\"\"));\n+    first.unwrap().to_owned()\n+}\n+\n pub fn cons_of_query_msg(q: &trace::Query) -> String {\n-    let s = format!(\"{:?}\", q.msg);\n-    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n-    assert!(cons.len() > 0 && cons[0] != \"\");\n-    cons[0].to_string()\n+    cons(&format!(\"{:?}\", q.msg))\n }\n \n pub fn cons_of_key(k: &DepNode) -> String {\n-    let s = format!(\"{:?}\", k);\n-    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n-    assert!(cons.len() > 0 && cons[0] != \"\");\n-    cons[0].to_string()\n+    cons(&format!(\"{:?}\", k))\n }\n \n // First return value is text; second return value is a CSS class\n@@ -84,35 +84,33 @@ pub fn html_of_effect(eff: &Effect) -> (String, String) {\n // First return value is text; second return value is a CSS class\n fn html_of_duration(_start: &Instant, dur: &Duration) -> (String, String) {\n     use rustc::util::common::duration_to_secs_str;\n-    (duration_to_secs_str(dur.clone()),\n-     String::new()\n-    )\n+    (duration_to_secs_str(dur.clone()), String::new())\n }\n \n-fn html_of_fraction(frac: f64) -> (String, String) {\n+fn html_of_fraction(frac: f64) -> (String, &'static str) {\n     let css = {\n-        if       frac > 0.50  { \"frac-50\".to_string() }\n-        else if  frac > 0.40  { \"frac-40\".to_string() }\n-        else if  frac > 0.30  { \"frac-30\".to_string() }\n-        else if  frac > 0.20  { \"frac-20\".to_string() }\n-        else if  frac > 0.10  { \"frac-10\".to_string() }\n-        else if  frac > 0.05  { \"frac-05\".to_string() }\n-        else if  frac > 0.02  { \"frac-02\".to_string() }\n-        else if  frac > 0.01  { \"frac-01\".to_string() }\n-        else if  frac > 0.001 { \"frac-001\".to_string() }\n-        else                  { \"frac-0\".to_string() }\n+        if       frac > 0.50  { \"frac-50\" }\n+        else if  frac > 0.40  { \"frac-40\" }\n+        else if  frac > 0.30  { \"frac-30\" }\n+        else if  frac > 0.20  { \"frac-20\" }\n+        else if  frac > 0.10  { \"frac-10\" }\n+        else if  frac > 0.05  { \"frac-05\" }\n+        else if  frac > 0.02  { \"frac-02\" }\n+        else if  frac > 0.01  { \"frac-01\" }\n+        else if  frac > 0.001 { \"frac-001\" }\n+        else                  { \"frac-0\" }\n     };\n     let percent = frac * 100.0;\n-    if percent > 0.1 { (format!(\"{:.1}%\", percent), css) }\n-    else { (\"< 0.1%\".to_string(), css) }\n+\n+    if percent > 0.1 {\n+        (format!(\"{:.1}%\", percent), css)\n+    } else {\n+        (\"< 0.1%\".to_string(), css)\n+    }\n }\n \n fn total_duration(traces: &[Rec]) -> Duration {\n-    let mut sum : Duration = Duration::new(0,0);\n-    for t in traces.iter() {\n-        sum += t.dur_total;\n-    }\n-    return sum\n+    Duration::new(0, 0) + traces.iter().map(|t| t.dur_total).sum()\n }\n \n fn duration_div(nom: Duration, den: Duration) -> f64 {\n@@ -130,64 +128,65 @@ fn write_traces_rec(file: &mut File, traces: &[Rec], total: Duration, depth: usi\n         let fraction = duration_div(t.dur_total, total);\n         let percent = fraction * 100.0;\n         let (frc_text, frc_css_classes) = html_of_fraction(fraction);\n-        write!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\\n\",\n-               depth,\n-               t.extent.len(),\n-               /* Heuristic for 'important' CSS class: */\n-               if t.extent.len() > 5 || percent >= 1.0 {\n-                   \" important\" }\n-               else { \"\" },\n-               eff_css_classes,\n-               dur_css_classes,\n-               frc_css_classes,\n+        writeln!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\",\n+                 depth,\n+                 t.extent.len(),\n+                 /* Heuristic for 'important' CSS class: */\n+                 if t.extent.len() > 5 || percent >= 1.0 { \" important\" } else { \"\" },\n+                 eff_css_classes,\n+                 dur_css_classes,\n+                 frc_css_classes,\n         ).unwrap();\n-        write!(file, \"<div class=\\\"eff\\\">{}</div>\\n\", eff_text).unwrap();\n-        write!(file, \"<div class=\\\"dur\\\">{}</div>\\n\", dur_text).unwrap();\n-        write!(file, \"<div class=\\\"frc\\\">{}</div>\\n\", frc_text).unwrap();\n+        writeln!(file, \"<div class=\\\"eff\\\">{}</div>\", eff_text).unwrap();\n+        writeln!(file, \"<div class=\\\"dur\\\">{}</div>\", dur_text).unwrap();\n+        writeln!(file, \"<div class=\\\"frc\\\">{}</div>\", frc_text).unwrap();\n         write_traces_rec(file, &t.extent, total, depth + 1);\n-        write!(file, \"</div>\\n\").unwrap();\n+        writeln!(file, \"</div>\").unwrap();\n     }\n }\n \n fn compute_counts_rec(counts: &mut FxHashMap<String,QueryMetric>, traces: &[Rec]) {\n+    counts.reserve(traces.len());\n     for t in traces.iter() {\n         match t.effect {\n             Effect::TimeBegin(ref msg) => {\n                 let qm = match counts.get(msg) {\n-                    Some(_qm) => { panic!(\"TimeBegin with non-unique, repeat message\") }\n-                    None => QueryMetric{\n+                    Some(_qm) => panic!(\"TimeBegin with non-unique, repeat message\"),\n+                    None => QueryMetric {\n                         count: 1,\n                         dur_self: t.dur_self,\n                         dur_total: t.dur_total,\n-                    }};\n+                    }\n+                };\n                 counts.insert(msg.clone(), qm);\n             },\n             Effect::TaskBegin(ref key) => {\n                 let cons = cons_of_key(key);\n                 let qm = match counts.get(&cons) {\n                     Some(qm) =>\n-                        QueryMetric{\n+                        QueryMetric {\n                             count: qm.count + 1,\n                             dur_self: qm.dur_self + t.dur_self,\n                             dur_total: qm.dur_total + t.dur_total,\n                         },\n-                    None => QueryMetric{\n+                    None => QueryMetric {\n                         count: 1,\n                         dur_self: t.dur_self,\n                         dur_total: t.dur_total,\n-                    }};\n+                    }\n+                };\n                 counts.insert(cons, qm);\n             },\n             Effect::QueryBegin(ref qmsg, ref _cc) => {\n                 let qcons = cons_of_query_msg(qmsg);\n                 let qm = match counts.get(&qcons) {\n                     Some(qm) =>\n-                        QueryMetric{\n+                        QueryMetric {\n                             count: qm.count + 1,\n                             dur_total: qm.dur_total + t.dur_total,\n                             dur_self: qm.dur_self + t.dur_self\n                         },\n-                    None => QueryMetric{\n+                    None => QueryMetric {\n                         count: 1,\n                         dur_total: t.dur_total,\n                         dur_self: t.dur_self,\n@@ -200,19 +199,20 @@ fn compute_counts_rec(counts: &mut FxHashMap<String,QueryMetric>, traces: &[Rec]\n     }\n }\n \n-pub fn write_counts(count_file: &mut File, counts: &mut FxHashMap<String,QueryMetric>) {\n+pub fn write_counts(count_file: &mut File, counts: &mut FxHashMap<String, QueryMetric>) {\n     use rustc::util::common::duration_to_secs_str;\n     use std::cmp::Reverse;\n \n     let mut data = counts.iter().map(|(ref cons, ref qm)|\n         (cons.clone(), qm.count.clone(), qm.dur_total.clone(), qm.dur_self.clone())\n     ).collect::<Vec<_>>();\n+\n     data.sort_by_key(|k| Reverse(k.3));\n     for (cons, count, dur_total, dur_self) in data {\n-        write!(count_file, \"{}, {}, {}, {}\\n\",\n-               cons, count,\n-               duration_to_secs_str(dur_total),\n-               duration_to_secs_str(dur_self)\n+        writeln!(count_file, \"{}, {}, {}, {}\",\n+                 cons, count,\n+                 duration_to_secs_str(dur_total),\n+                 duration_to_secs_str(dur_self)\n         ).unwrap();\n     }\n }\n@@ -223,12 +223,12 @@ pub fn write_traces(html_file: &mut File, counts_file: &mut File, traces: &[Rec]\n     compute_counts_rec(&mut counts, traces);\n     write_counts(counts_file, &mut counts);\n \n-    let total : Duration = total_duration(traces);\n+    let total: Duration = total_duration(traces);\n     write_traces_rec(html_file, traces, total, 0)\n }\n \n pub fn write_style(html_file: &mut File) {\n-    write!(html_file,\"{}\", \"\n+    write!(html_file, \"{}\", \"\n body {\n     font-family: sans-serif;\n     background: black;"}]}