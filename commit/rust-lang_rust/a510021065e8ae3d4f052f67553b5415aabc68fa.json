{"sha": "a510021065e8ae3d4f052f67553b5415aabc68fa", "node_id": "C_kwDOAAsO6NoAKGE1MTAwMjEwNjVlOGFlM2Q0ZjA1MmY2NzU1M2I1NDE1YWFiYzY4ZmE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-11T17:20:54Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-11T17:20:54Z"}, "message": "Replace some more ide usages of ModuleDef with Definition", "tree": {"sha": "f5f65fbb32f5855ea1d5cb79f1ade95ddb43b0de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5f65fbb32f5855ea1d5cb79f1ade95ddb43b0de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a510021065e8ae3d4f052f67553b5415aabc68fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a510021065e8ae3d4f052f67553b5415aabc68fa", "html_url": "https://github.com/rust-lang/rust/commit/a510021065e8ae3d4f052f67553b5415aabc68fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a510021065e8ae3d4f052f67553b5415aabc68fa/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42ff91f006604498911d5057381e297c3dcc124", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42ff91f006604498911d5057381e297c3dcc124", "html_url": "https://github.com/rust-lang/rust/commit/e42ff91f006604498911d5057381e297c3dcc124"}], "stats": {"total": 262, "additions": 132, "deletions": 130}, "files": [{"sha": "a7c12c163619b08317244549098fe5891430539d", "filename": "crates/ide/src/annotations.rs", "status": "modified", "additions": 71, "deletions": 79, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a510021065e8ae3d4f052f67553b5415aabc68fa/crates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a510021065e8ae3d4f052f67553b5415aabc68fa/crates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations.rs?ref=a510021065e8ae3d4f052f67553b5415aabc68fa", "patch": "@@ -1,7 +1,7 @@\n-use either::Either;\n use hir::{HasSource, InFile, Semantics};\n use ide_db::{\n     base_db::{FileId, FilePosition, FileRange},\n+    defs::Definition,\n     helpers::visit_file_defs,\n     RootDatabase,\n };\n@@ -62,91 +62,83 @@ pub(crate) fn annotations(\n         }\n     }\n \n-    visit_file_defs(&Semantics::new(db), file_id, &mut |def| match def {\n-        Either::Left(def) => {\n-            let range = match def {\n-                hir::ModuleDef::Const(konst) if config.annotate_references => {\n-                    konst.source(db).and_then(|node| name_range(&node, file_id))\n-                }\n-                hir::ModuleDef::Trait(trait_)\n-                    if config.annotate_references || config.annotate_impls =>\n-                {\n-                    trait_.source(db).and_then(|node| name_range(&node, file_id))\n-                }\n-                hir::ModuleDef::Adt(adt) => match adt {\n-                    hir::Adt::Enum(enum_) => {\n-                        if config.annotate_enum_variant_references {\n-                            enum_\n-                                .variants(db)\n-                                .into_iter()\n-                                .map(|variant| {\n-                                    variant.source(db).and_then(|node| name_range(&node, file_id))\n-                                })\n-                                .filter_map(std::convert::identity)\n-                                .for_each(|range| {\n-                                    annotations.push(Annotation {\n-                                        range,\n-                                        kind: AnnotationKind::HasReferences {\n-                                            position: FilePosition {\n-                                                file_id,\n-                                                offset: range.start(),\n-                                            },\n-                                            data: None,\n-                                        },\n-                                    })\n+    visit_file_defs(&Semantics::new(db), file_id, &mut |def| {\n+        let range = match def {\n+            Definition::Const(konst) if config.annotate_references => {\n+                konst.source(db).and_then(|node| name_range(&node, file_id))\n+            }\n+            Definition::Trait(trait_) if config.annotate_references || config.annotate_impls => {\n+                trait_.source(db).and_then(|node| name_range(&node, file_id))\n+            }\n+            Definition::Adt(adt) => match adt {\n+                hir::Adt::Enum(enum_) => {\n+                    if config.annotate_enum_variant_references {\n+                        enum_\n+                            .variants(db)\n+                            .into_iter()\n+                            .map(|variant| {\n+                                variant.source(db).and_then(|node| name_range(&node, file_id))\n+                            })\n+                            .filter_map(std::convert::identity)\n+                            .for_each(|range| {\n+                                annotations.push(Annotation {\n+                                    range,\n+                                    kind: AnnotationKind::HasReferences {\n+                                        position: FilePosition { file_id, offset: range.start() },\n+                                        data: None,\n+                                    },\n                                 })\n-                        }\n-                        if config.annotate_references || config.annotate_impls {\n-                            enum_.source(db).and_then(|node| name_range(&node, file_id))\n-                        } else {\n-                            None\n-                        }\n+                            })\n+                    }\n+                    if config.annotate_references || config.annotate_impls {\n+                        enum_.source(db).and_then(|node| name_range(&node, file_id))\n+                    } else {\n+                        None\n                     }\n-                    _ => {\n-                        if config.annotate_references || config.annotate_impls {\n-                            adt.source(db).and_then(|node| name_range(&node, file_id))\n-                        } else {\n-                            None\n-                        }\n+                }\n+                _ => {\n+                    if config.annotate_references || config.annotate_impls {\n+                        adt.source(db).and_then(|node| name_range(&node, file_id))\n+                    } else {\n+                        None\n                     }\n+                }\n+            },\n+            _ => None,\n+        };\n+\n+        let (range, offset) = match range {\n+            Some(range) => (range, range.start()),\n+            None => return,\n+        };\n+\n+        if config.annotate_impls && !matches!(def, Definition::Const(_)) {\n+            annotations.push(Annotation {\n+                range,\n+                kind: AnnotationKind::HasImpls {\n+                    position: FilePosition { file_id, offset },\n+                    data: None,\n                 },\n-                _ => None,\n-            };\n-\n-            let (range, offset) = match range {\n-                Some(range) => (range, range.start()),\n-                None => return,\n-            };\n-\n-            if config.annotate_impls && !matches!(def, hir::ModuleDef::Const(_)) {\n-                annotations.push(Annotation {\n-                    range,\n-                    kind: AnnotationKind::HasImpls {\n-                        position: FilePosition { file_id, offset },\n-                        data: None,\n-                    },\n-                });\n-            }\n-            if config.annotate_references {\n-                annotations.push(Annotation {\n-                    range,\n-                    kind: AnnotationKind::HasReferences {\n-                        position: FilePosition { file_id, offset },\n-                        data: None,\n-                    },\n-                });\n-            }\n+            });\n+        }\n+        if config.annotate_references {\n+            annotations.push(Annotation {\n+                range,\n+                kind: AnnotationKind::HasReferences {\n+                    position: FilePosition { file_id, offset },\n+                    data: None,\n+                },\n+            });\n+        }\n \n-            fn name_range<T: HasName>(node: &InFile<T>, file_id: FileId) -> Option<TextRange> {\n-                if node.file_id == file_id.into() {\n-                    node.value.name().map(|it| it.syntax().text_range())\n-                } else {\n-                    // Node is outside the file we are adding annotations to (e.g. macros).\n-                    None\n-                }\n+        fn name_range<T: HasName>(node: &InFile<T>, file_id: FileId) -> Option<TextRange> {\n+            if node.file_id == file_id.into() {\n+                node.value.name().map(|it| it.syntax().text_range())\n+            } else {\n+                // Node is outside the file we are adding annotations to (e.g. macros).\n+                None\n             }\n         }\n-        Either::Right(_) => (),\n     });\n \n     if config.annotate_method_references {"}, {"sha": "093449176336e97e99b03ef5d55692cd0603398f", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a510021065e8ae3d4f052f67553b5415aabc68fa/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a510021065e8ae3d4f052f67553b5415aabc68fa/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=a510021065e8ae3d4f052f67553b5415aabc68fa", "patch": "@@ -2,11 +2,11 @@ use std::fmt;\n \n use ast::HasName;\n use cfg::CfgExpr;\n-use either::Either;\n use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, InFile, Semantics};\n use ide_assists::utils::test_related_attribute;\n use ide_db::{\n     base_db::{FilePosition, FileRange},\n+    defs::Definition,\n     helpers::visit_file_defs,\n     search::SearchScope,\n     RootDatabase, SymbolKind,\n@@ -138,8 +138,8 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n         }) {\n             if let Some(def) = def {\n                 let file_id = match def {\n-                    hir::ModuleDef::Module(it) => it.declaration_source(db).map(|src| src.file_id),\n-                    hir::ModuleDef::Function(it) => it.source(db).map(|src| src.file_id),\n+                    Definition::Module(it) => it.declaration_source(db).map(|src| src.file_id),\n+                    Definition::Function(it) => it.source(db).map(|src| src.file_id),\n                     _ => None,\n                 };\n                 if let Some(file_id) = file_id.filter(|file| file.call_node(db).is_some()) {\n@@ -150,32 +150,25 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n             res.push(runnable);\n         }\n     };\n-    visit_file_defs(&sema, file_id, &mut |def| match def {\n-        Either::Left(def) => {\n-            let runnable = match def {\n-                hir::ModuleDef::Module(it) => runnable_mod(&sema, it),\n-                hir::ModuleDef::Function(it) => runnable_fn(&sema, it),\n-                _ => None,\n-            };\n-            add_opt(runnable.or_else(|| module_def_doctest(sema.db, def)), Some(def));\n-        }\n-        Either::Right(impl_) => {\n-            add_opt(runnable_impl(&sema, &impl_), None);\n-            impl_\n-                .items(db)\n-                .into_iter()\n-                .map(|assoc| {\n-                    (\n-                        match assoc {\n-                            hir::AssocItem::Function(it) => runnable_fn(&sema, it)\n-                                .or_else(|| module_def_doctest(sema.db, it.into())),\n-                            hir::AssocItem::Const(it) => module_def_doctest(sema.db, it.into()),\n-                            hir::AssocItem::TypeAlias(it) => module_def_doctest(sema.db, it.into()),\n-                        },\n-                        assoc,\n-                    )\n-                })\n-                .for_each(|(r, assoc)| add_opt(r, Some(assoc.into())));\n+    visit_file_defs(&sema, file_id, &mut |def| {\n+        let runnable = match def {\n+            Definition::Module(it) => runnable_mod(&sema, it),\n+            Definition::Function(it) => runnable_fn(&sema, it),\n+            Definition::SelfType(impl_) => runnable_impl(&sema, &impl_),\n+            _ => None,\n+        };\n+        add_opt(runnable.or_else(|| module_def_doctest(sema.db, def)), Some(def));\n+        if let Definition::SelfType(impl_) = def {\n+            impl_.items(db).into_iter().for_each(|assoc| {\n+                let runnable = match assoc {\n+                    hir::AssocItem::Function(it) => {\n+                        runnable_fn(&sema, it).or_else(|| module_def_doctest(sema.db, it.into()))\n+                    }\n+                    hir::AssocItem::Const(it) => module_def_doctest(sema.db, it.into()),\n+                    hir::AssocItem::TypeAlias(it) => module_def_doctest(sema.db, it.into()),\n+                };\n+                add_opt(runnable, Some(assoc.into()))\n+            });\n         }\n     });\n \n@@ -392,17 +385,19 @@ fn runnable_mod_outline_definition(\n     }\n }\n \n-fn module_def_doctest(db: &RootDatabase, def: hir::ModuleDef) -> Option<Runnable> {\n+fn module_def_doctest(db: &RootDatabase, def: Definition) -> Option<Runnable> {\n     let attrs = match def {\n-        hir::ModuleDef::Module(it) => it.attrs(db),\n-        hir::ModuleDef::Function(it) => it.attrs(db),\n-        hir::ModuleDef::Adt(it) => it.attrs(db),\n-        hir::ModuleDef::Variant(it) => it.attrs(db),\n-        hir::ModuleDef::Const(it) => it.attrs(db),\n-        hir::ModuleDef::Static(it) => it.attrs(db),\n-        hir::ModuleDef::Trait(it) => it.attrs(db),\n-        hir::ModuleDef::TypeAlias(it) => it.attrs(db),\n-        hir::ModuleDef::BuiltinType(_) => return None,\n+        Definition::Module(it) => it.attrs(db),\n+        Definition::Function(it) => it.attrs(db),\n+        Definition::Adt(it) => it.attrs(db),\n+        Definition::Variant(it) => it.attrs(db),\n+        Definition::Const(it) => it.attrs(db),\n+        Definition::Static(it) => it.attrs(db),\n+        Definition::Trait(it) => it.attrs(db),\n+        Definition::TypeAlias(it) => it.attrs(db),\n+        Definition::Macro(it) => it.attrs(db),\n+        Definition::SelfType(it) => it.attrs(db),\n+        _ => return None,\n     };\n     if !has_runnable_doc_test(&attrs) {\n         return None;\n@@ -440,7 +435,7 @@ fn module_def_doctest(db: &RootDatabase, def: hir::ModuleDef) -> Option<Runnable\n     let test_id = path.map_or_else(|| TestId::Name(def_name.to_string()), TestId::Path);\n \n     let mut nav = match def {\n-        hir::ModuleDef::Module(def) => NavigationTarget::from_module_to_decl(db, def),\n+        Definition::Module(def) => NavigationTarget::from_module_to_decl(db, def),\n         def => def.try_to_nav(db)?,\n     };\n     nav.focus_range = None;"}, {"sha": "1d7f4392dd0fa16a63efd8da7d1511b28e54c552", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a510021065e8ae3d4f052f67553b5415aabc68fa/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a510021065e8ae3d4f052f67553b5415aabc68fa/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=a510021065e8ae3d4f052f67553b5415aabc68fa", "patch": "@@ -516,6 +516,18 @@ impl NameRefClass {\n     }\n }\n \n+impl_from!(\n+    Field, Module, Function, Adt, Variant, Const, Static, Trait, TypeAlias, BuiltinType, Local,\n+    GenericParam, Label\n+    for Definition\n+);\n+\n+impl From<Impl> for Definition {\n+    fn from(impl_: Impl) -> Self {\n+        Definition::SelfType(impl_)\n+    }\n+}\n+\n impl AsAssocItem for Definition {\n     fn as_assoc_item(self, db: &dyn hir::db::HirDatabase) -> Option<AssocItem> {\n         match self {\n@@ -527,11 +539,15 @@ impl AsAssocItem for Definition {\n     }\n }\n \n-impl_from!(\n-    Field, Module, Function, Adt, Variant, Const, Static, Trait, TypeAlias, BuiltinType, Local,\n-    GenericParam, Label\n-    for Definition\n-);\n+impl From<AssocItem> for Definition {\n+    fn from(assoc_item: AssocItem) -> Self {\n+        match assoc_item {\n+            AssocItem::Function(it) => Definition::Function(it),\n+            AssocItem::Const(it) => Definition::Const(it),\n+            AssocItem::TypeAlias(it) => Definition::TypeAlias(it),\n+        }\n+    }\n+}\n \n impl From<PathResolution> for Definition {\n     fn from(path_resolution: PathResolution) -> Self {"}, {"sha": "aae1fba6e934de8a2b65513f1c6a9030f6d30628", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a510021065e8ae3d4f052f67553b5415aabc68fa/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a510021065e8ae3d4f052f67553b5415aabc68fa/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=a510021065e8ae3d4f052f67553b5415aabc68fa", "patch": "@@ -10,7 +10,6 @@ pub mod rust_doc;\n use std::{collections::VecDeque, iter};\n \n use base_db::FileId;\n-use either::Either;\n use hir::{ItemInNs, MacroDef, ModuleDef, Name, PathResolution, Semantics};\n use itertools::Itertools;\n use syntax::{\n@@ -19,7 +18,7 @@ use syntax::{\n     T,\n };\n \n-use crate::RootDatabase;\n+use crate::{defs::Definition, RootDatabase};\n \n pub use self::famous_defs::FamousDefs;\n \n@@ -122,7 +121,7 @@ pub fn mod_path_to_ast(path: &hir::ModPath) -> ast::Path {\n pub fn visit_file_defs(\n     sema: &Semantics<RootDatabase>,\n     file_id: FileId,\n-    cb: &mut dyn FnMut(Either<hir::ModuleDef, hir::Impl>),\n+    cb: &mut dyn FnMut(Definition),\n ) {\n     let db = sema.db;\n     let module = match sema.to_module_def(file_id) {\n@@ -134,12 +133,12 @@ pub fn visit_file_defs(\n         if let ModuleDef::Module(submodule) = def {\n             if let hir::ModuleSource::Module(_) = submodule.definition_source(db).value {\n                 defs.extend(submodule.declarations(db));\n-                submodule.impl_defs(db).into_iter().for_each(|impl_| cb(Either::Right(impl_)));\n+                submodule.impl_defs(db).into_iter().for_each(|impl_| cb(impl_.into()));\n             }\n         }\n-        cb(Either::Left(def));\n+        cb(def.into());\n     }\n-    module.impl_defs(db).into_iter().for_each(|impl_| cb(Either::Right(impl_)));\n+    module.impl_defs(db).into_iter().for_each(|impl_| cb(impl_.into()));\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]"}]}