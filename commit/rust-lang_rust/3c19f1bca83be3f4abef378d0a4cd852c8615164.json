{"sha": "3c19f1bca83be3f4abef378d0a4cd852c8615164", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMTlmMWJjYTgzYmUzZjRhYmVmMzc4ZDBhNGNkODUyYzg2MTUxNjQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-06-27T12:20:42Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-07-10T07:35:35Z"}, "message": "Refactored int/uint range code in preparation for change to range_rev semantics.\n\nAlso added unit tests of range code to test refactoring.  The\nnum-range-rev.rs test will need to be updated when the range_rev\nsemantics change.", "tree": {"sha": "02e3a0567d5295474bb41f278ddb7509138d91f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02e3a0567d5295474bb41f278ddb7509138d91f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c19f1bca83be3f4abef378d0a4cd852c8615164", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c19f1bca83be3f4abef378d0a4cd852c8615164", "html_url": "https://github.com/rust-lang/rust/commit/3c19f1bca83be3f4abef378d0a4cd852c8615164", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c19f1bca83be3f4abef378d0a4cd852c8615164/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41dcec2fe16e272016ae77d10a6a5ff3a737f192", "url": "https://api.github.com/repos/rust-lang/rust/commits/41dcec2fe16e272016ae77d10a6a5ff3a737f192", "html_url": "https://github.com/rust-lang/rust/commit/41dcec2fe16e272016ae77d10a6a5ff3a737f192"}], "stats": {"total": 414, "additions": 381, "deletions": 33}, "files": [{"sha": "4fd30be80e66e3ca9545e8892bb810487d813211", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 72, "deletions": 16, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3c19f1bca83be3f4abef378d0a4cd852c8615164/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c19f1bca83be3f4abef378d0a4cd852c8615164/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=3c19f1bca83be3f4abef378d0a4cd852c8615164", "patch": "@@ -29,28 +29,38 @@ pub static bytes : uint = ($bits / 8);\n pub static min_value: $T = (-1 as $T) << (bits - 1);\n pub static max_value: $T = min_value - 1 as $T;\n \n+enum Range { Closed, HalfOpen }\n+\n+#[inline]\n ///\n-/// Iterate over the range [`lo`..`hi`)\n+/// Iterate through a range with a given step value.\n ///\n-/// # Arguments\n+/// Let `term` denote the closed interval `[stop-step,stop]` if `r` is Closed;\n+/// otherwise `term` denotes the half-open interval `[stop-step,stop)`.\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// `x_j == start + step*j`, and `x_n` lies in the interval `term`.\n ///\n-/// * `lo` - lower bound, inclusive\n-/// * `hi` - higher bound, exclusive\n-///\n-/// # Examples\n-/// ~~~\n-/// let mut sum = 0;\n-/// for int::range(1, 5) |i| {\n-///     sum += i;\n-/// }\n-/// assert!(sum == 10);\n-/// ~~~\n+/// If no such nonnegative integer `n` exists, then the iteration range\n+/// is empty.\n ///\n-#[inline]\n-pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n+fn range_step_core(start: $T, stop: $T, step: $T, r: Range, it: &fn($T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n+    } else if step == (1 as $T) { // elide bounds check to tighten loop\n+        while i < stop {\n+            if !it(i) { return false; }\n+            // no need for overflow check;\n+            // cannot have i + 1 > max_value because i < stop <= max_value\n+            i += (1 as $T);\n+        }\n+    } else if step == (-1 as $T) { // elide bounds check to tighten loop\n+        while i > stop {\n+            if !it(i) { return false; }\n+            // no need for underflow check;\n+            // cannot have i - 1 < min_value because i > stop >= min_value\n+            i -= (1 as $T);\n+        }\n     } else if step > 0 { // ascending\n         while i < stop {\n             if !it(i) { return false; }\n@@ -66,9 +76,55 @@ pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n             i += step;\n         }\n     }\n-    return true;\n+    match r {\n+        HalfOpen => return true,\n+        Closed => return (i != stop || it(i))\n+    }\n+}\n+\n+#[inline]\n+///\n+/// Iterate through the range [`start`..`stop`) with a given step value.\n+///\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// * `x_i == start + step*i`, and\n+/// * `n` is the greatest nonnegative integer such that `x_n < stop`\n+///\n+/// (If no such `n` exists, then the iteration range is empty.)\n+///\n+/// # Arguments\n+///\n+/// * `start` - lower bound, inclusive\n+/// * `stop` - higher bound, exclusive\n+///\n+/// # Examples\n+/// ~~~\n+/// let mut sum = 0;\n+/// for int::range(1, 5) |i| {\n+///     sum += i;\n+/// }\n+/// assert!(sum == 10);\n+/// ~~~\n+///\n+pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n+    range_step_core(start, stop, step, HalfOpen, it)\n+}\n+\n+#[inline]\n+///\n+/// Iterate through a range with a given step value.\n+///\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// `x_i == start + step*i` and `x_n <= last < step + x_n`.\n+///\n+/// (If no such nonnegative integer `n` exists, then the iteration\n+///  range is empty.)\n+///\n+pub fn range_step_inclusive(start: $T, last: $T, step: $T, it: &fn($T) -> bool) -> bool {\n+    range_step_core(start, last, step, Closed, it)\n }\n \n+\n #[inline]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: $T, hi: $T, it: &fn($T) -> bool) -> bool {"}, {"sha": "09397ecfd77688514e3bd76b837c7051546b1ea9", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 76, "deletions": 17, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3c19f1bca83be3f4abef378d0a4cd852c8615164/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c19f1bca83be3f4abef378d0a4cd852c8615164/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=3c19f1bca83be3f4abef378d0a4cd852c8615164", "patch": "@@ -30,40 +30,99 @@ pub static bytes : uint = ($bits / 8);\n pub static min_value: $T = 0 as $T;\n pub static max_value: $T = 0 as $T - 1 as $T;\n \n+enum Range { Closed, HalfOpen }\n+\n #[inline]\n-/**\n- * Iterate through a range with a given step value.\n- *\n- * # Examples\n- * ~~~ {.rust}\n- * let nums = [1,2,3,4,5,6,7];\n- *\n- * for uint::range_step(0, nums.len() - 1, 2) |i| {\n- *     println(fmt!(\"%d & %d\", nums[i], nums[i+1]));\n- * }\n- * ~~~\n- */\n-pub fn range_step(start: $T, stop: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n+///\n+/// Iterate through a range with a given step value.\n+///\n+/// Let `term` denote the closed interval `[stop-step,stop]` if `r` is Closed;\n+/// otherwise `term` denotes the half-open interval `[stop-step,stop)`.\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// `x_j == start + step*j`, and `x_n` lies in the interval `term`.\n+///\n+/// If no such nonnegative integer `n` exists, then the iteration range\n+/// is empty.\n+///\n+fn range_step_core(start: $T, stop: $T, step: $T_SIGNED, r: Range, it: &fn($T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n         fail!(\"range_step called with step == 0\");\n-    }\n-    if step >= 0 {\n+    } else if step == (1 as $T_SIGNED) { // elide bounds check to tighten loop\n+        while i < stop {\n+            if !it(i) { return false; }\n+            // no need for overflow check;\n+            // cannot have i + 1 > max_value because i < stop <= max_value\n+            i += (1 as $T);\n+        }\n+    } else if step == (-1 as $T_SIGNED) { // elide bounds check to tighten loop\n+        while i > stop {\n+            if !it(i) { return false; }\n+            // no need for underflow check;\n+            // cannot have i - 1 < min_value because i > stop >= min_value\n+            i -= (1 as $T);\n+        }\n+    } else if step > 0 { // ascending\n         while i < stop {\n             if !it(i) { return false; }\n             // avoiding overflow. break if i + step > max_value\n             if i > max_value - (step as $T) { return true; }\n             i += step as $T;\n         }\n-    } else {\n+    } else { // descending\n         while i > stop {\n             if !it(i) { return false; }\n             // avoiding underflow. break if i + step < min_value\n             if i < min_value + ((-step) as $T) { return true; }\n             i -= -step as $T;\n         }\n     }\n-    return true;\n+    match r {\n+        HalfOpen => return true,\n+        Closed => return (i != stop || it(i))\n+    }\n+}\n+\n+#[inline]\n+///\n+/// Iterate through the range [`start`..`stop`) with a given step value.\n+///\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// - `x_i == start + step*i`, and\n+/// - `n` is the greatest nonnegative integer such that `x_n < stop`\n+///\n+/// (If no such `n` exists, then the iteration range is empty.)\n+///\n+/// # Arguments\n+///\n+/// * `start` - lower bound, inclusive\n+/// * `stop` - higher bound, exclusive\n+///\n+/// # Examples\n+/// ~~~ {.rust}\n+/// let nums = [1,2,3,4,5,6,7];\n+///\n+/// for uint::range_step(0, nums.len() - 1, 2) |i| {\n+///     println(fmt!(\"%d & %d\", nums[i], nums[i+1]));\n+/// }\n+/// ~~~\n+///\n+pub fn range_step(start: $T, stop: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n+    range_step_core(start, stop, step, HalfOpen, it)\n+}\n+\n+#[inline]\n+///\n+/// Iterate through a range with a given step value.\n+///\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// `x_i == start + step*i` and `x_n <= last < step + x_n`.\n+///\n+/// (If no such nonnegative integer `n` exists, then the iteration\n+///  range is empty.)\n+///\n+pub fn range_step_inclusive(start: $T, last: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n+    range_step_core(start, last, step, Closed, it)\n }\n \n #[inline]"}, {"sha": "e65c793a7b4524a173e4fc75ae8cb59aa8dbc5be", "filename": "src/test/run-pass/num-range-rev.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3c19f1bca83be3f4abef378d0a4cd852c8615164/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c19f1bca83be3f4abef378d0a4cd852c8615164/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs?ref=3c19f1bca83be3f4abef378d0a4cd852c8615164", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::int;\n+use std::uint;\n+\n+fn uint_range(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n+    uint::range(lo, hi, it)\n+}\n+\n+fn int_range(lo: int,  hi: int, it: &fn(int) -> bool) -> bool {\n+    int::range(lo, hi, it)\n+}\n+\n+fn uint_range_rev(hi: uint, lo: uint, it: &fn(uint) -> bool) -> bool {\n+    uint::range_rev(hi, lo, it)\n+}\n+\n+fn int_range_rev(hi: int,  lo: int, it: &fn(int) -> bool) -> bool {\n+    int::range_rev(hi, lo, it)\n+}\n+\n+fn int_range_step(a: int, b: int, step: int, it: &fn(int) -> bool) -> bool {\n+    int::range_step(a, b, step, it)\n+}\n+\n+fn uint_range_step(a: uint, b: uint, step: int, it: &fn(uint) -> bool) -> bool {\n+    uint::range_step(a, b, step, it)\n+}\n+\n+\n+pub fn main() {\n+    // int and uint have same result for\n+    //   Sum{100 > i >= 2} == (Sum{1 <= i <= 99} - 1) == n*(n+1)/2 - 1 for n=99\n+    let mut sum = 0u;\n+    for uint_range_rev(99, 1) |i| {\n+        sum += i;\n+    }\n+    assert_eq!(sum, 4949);\n+\n+    let mut sum = 0i;\n+    for int_range_rev(99, 1) |i| {\n+        sum += i;\n+    }\n+    assert_eq!(sum, 4949);\n+\n+\n+    // elements are visited in correct order\n+    let primes = [2,3,5,7,11];\n+    let mut prod = 1i;\n+    for uint_range_rev(4, 0) |i| {\n+        println(fmt!(\"uint 4 downto 0: %u\", i));\n+        prod *= int::pow(primes[i], i);\n+    }\n+    assert_eq!(prod, 11*11*11*11*7*7*7*5*5*3);\n+    let mut prod = 1i;\n+    for int_range_rev(4, 0) |i| {\n+        println(fmt!(\"int 4 downto 0: %d\", i));\n+        prod *= int::pow(primes[i], i as uint);\n+    }\n+    assert_eq!(prod, 11*11*11*11*7*7*7*5*5*3);\n+\n+\n+    // range and range_rev are symmetric.\n+    let mut sum_up = 0u;\n+    for uint_range(10, 30) |i| {\n+        sum_up += i;\n+    }\n+    let mut sum_down = 0u;\n+    for uint_range_rev(29, 9) |i| {\n+        sum_down += i;\n+    }\n+    assert_eq!(sum_up, sum_down);\n+\n+    let mut sum_up = 0;\n+    for int_range(-20, 10) |i| {\n+        sum_up += i;\n+    }\n+    let mut sum_down = 0;\n+    for int_range_rev(9, -21) |i| {\n+        sum_down += i;\n+    }\n+    assert_eq!(sum_up, sum_down);\n+\n+\n+    // empty ranges\n+    for int_range_rev(10, 10) |_| {\n+        fail!(\"range should be empty when start == stop\");\n+    }\n+\n+    for uint_range_rev(0, 1) |_| {\n+        // fail!(\"range should be empty when start-1 underflows\");\n+    }\n+\n+    // range iterations do not wrap/underflow\n+    let mut uflo_loop_visited = ~[];\n+    for int_range_step(int::min_value+15, int::min_value, -4) |x| {\n+        uflo_loop_visited.push(x - int::min_value);\n+    }\n+    assert_eq!(uflo_loop_visited, ~[15, 11, 7, 3]);\n+\n+    let mut uflo_loop_visited = ~[];\n+    for uint_range_step(uint::min_value+15, uint::min_value, -4) |x| {\n+        uflo_loop_visited.push(x - uint::min_value);\n+    }\n+    assert_eq!(uflo_loop_visited, ~[15, 11, 7, 3]);\n+}"}, {"sha": "7c1f905a049b6f4db40964ad810ecdc7a40f940e", "filename": "src/test/run-pass/num-range.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3c19f1bca83be3f4abef378d0a4cd852c8615164/src%2Ftest%2Frun-pass%2Fnum-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c19f1bca83be3f4abef378d0a4cd852c8615164/src%2Ftest%2Frun-pass%2Fnum-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range.rs?ref=3c19f1bca83be3f4abef378d0a4cd852c8615164", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::int;\n+use std::uint;\n+\n+fn uint_range(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n+    uint::range(lo, hi, it)\n+}\n+\n+fn int_range(lo: int, hi: int, it: &fn(int) -> bool) -> bool {\n+    int::range(lo, hi, it)\n+}\n+\n+fn int_range_step(a: int, b: int, step: int, it: &fn(int) -> bool) -> bool {\n+    int::range_step(a, b, step, it)\n+}\n+\n+fn uint_range_step(a: uint, b: uint, s: int, it: &fn(uint) -> bool) -> bool {\n+    uint::range_step(a, b, s, it)\n+}\n+\n+pub fn main() {\n+    println(fmt!(\"num-range start\"));\n+    // int and uint have same result for\n+    //   Sum{2 <= i < 100} == (Sum{1 <= i <= 99} - 1) == n*(n+1)/2 - 1 for n=99\n+    let mut sum = 0u;\n+    for uint_range(2, 100) |i| {\n+        sum += i;\n+    }\n+    assert_eq!(sum, 4949);\n+\n+    let mut sum = 0i;\n+    for int_range(2, 100) |i| {\n+        sum += i;\n+    }\n+    assert_eq!(sum, 4949);\n+\n+\n+    // elements are visited in correct order\n+    let primes = [2,3,5,7];\n+    let mut prod = 1i;\n+    for uint_range(0, 4) |i| {\n+        prod *= int::pow(primes[i], i);\n+    }\n+    assert_eq!(prod, 1*3*5*5*7*7*7);\n+    let mut prod = 1i;\n+    for int_range(0, 4) |i| {\n+        prod *= int::pow(primes[i], i as uint);\n+    }\n+    assert_eq!(prod, 1*3*5*5*7*7*7);\n+\n+\n+    // empty ranges\n+    for int_range(10, 10) |_| {\n+        fail!(\"range should be empty when start == stop\");\n+    }\n+\n+    for uint_range(10, 10) |_| {\n+        fail!(\"range should be empty when start == stop\");\n+    }\n+\n+\n+    // range iterations do not wrap/overflow\n+    let mut oflo_loop_visited = ~[];\n+    for uint_range_step(uint::max_value-15, uint::max_value, 4) |x| {\n+        oflo_loop_visited.push(uint::max_value - x);\n+    }\n+    assert_eq!(oflo_loop_visited, ~[15, 11, 7, 3]);\n+\n+    let mut oflo_loop_visited = ~[];\n+    for int_range_step(int::max_value-15, int::max_value, 4) |x| {\n+        oflo_loop_visited.push(int::max_value - x);\n+    }\n+    assert_eq!(oflo_loop_visited, ~[15, 11, 7, 3]);\n+\n+\n+    // range_step never passes nor visits the stop element\n+    for int_range_step(0, 21, 3) |x| {\n+        assert!(x < 21);\n+    }\n+\n+    // range_step_inclusive will never pass stop element, and may skip it.\n+    let mut saw21 = false;\n+    for uint::range_step_inclusive(0, 21, 4) |x| {\n+        assert!(x <= 21);\n+        if x == 21 { saw21 = true; }\n+    }\n+    assert!(!saw21);\n+    let mut saw21 = false;\n+    for int::range_step_inclusive(0, 21, 4) |x| {\n+        assert!(x <= 21);\n+        if x == 21 { saw21 = true; }\n+    }\n+    assert!(!saw21);\n+\n+    // range_step_inclusive will never pass stop element, but may visit it.\n+    let mut saw21 = false;\n+    for uint::range_step_inclusive(0, 21, 3) |x| {\n+        assert!(x <= 21);\n+        println(fmt!(\"saw: %u\", x));\n+        if x == 21 { saw21 = true; }\n+    }\n+    assert!(saw21);\n+    let mut saw21 = false;\n+    for int::range_step_inclusive(0, 21, 3) |x| {\n+        assert!(x <= 21);\n+        if x == 21 { saw21 = true; }\n+    }\n+    assert!(saw21);\n+\n+}"}]}