{"sha": "6da62a40f25c7baa26c7d6ca79b5ecc804c0c307", "node_id": "C_kwDOAAsO6NoAKDZkYTYyYTQwZjI1YzdiYWEyNmM3ZDZjYTc5YjVlY2M4MDRjMGMzMDc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-04-29T05:57:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-29T05:57:54Z"}, "message": "Rollup merge of #110614 - compiler-errors:new-solver-overflow-response, r=lcnr\n\nClear response values for overflow in new solver\n\nWhen we have an overflow, return a trivial query response. This fixes an ICE with the code described in #110544:\n\n```rust\ntrait Trait {}\n\nstruct W<T>(T);\n\nimpl<T, U> Trait for W<(W<T>, W<U>)>\nwhere\n    W<T>: Trait,\n    W<U>: Trait,\n{}\n\nfn impls<T: Trait>() {}\n\nfn main() {\n    impls::<W<_>>()\n}\n```\n\nWhere, while proving `W<?0>: Trait`, we overflow but still apply the query response of `?0 = (W<?1>, W<?2>)`. Then while re-processing the query to validate that our evaluation result was stable, we get a different query response that looks like `?1 = (W<?3>, W<?4>), ?2 = (W<?5>, W<?6>)`, and so we trigger the ICE.\n\nAlso, by returning a trivial query response we also avoid the infinite-loop/OOM behavior of the old solver.\n\nr? ``@lcnr``", "tree": {"sha": "ad69be89f23dee0b48f501761651993b920e96ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad69be89f23dee0b48f501761651993b920e96ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkTLHiCRBK7hj4Ov3rIwAAijIIABj/hRYer6q/VFz1Djjb40Cz\nyTAg52alEKSPenKj+ThWVoU1XkYoQMeLVUQloDl/fLdXX7LSydHvI4zVooiWfq1S\nMNDjj9XSn61XuUgWbvnRN214iT7IAonaZnoGFtAVuOhPimYK0HY2/CipurCGBpXf\nhr/4vUMcBA+BMBFDw7Qe9Ae15CJUB2lq3CKWo/XnOCRAhA/E3+VLRV9c7vQoez0v\nUMxBiHrZznCa2V3sj7TQm1hf0byGtF4ENyFkWU3K9vZgZwbJ7qC7lsXMl4wioAR1\nn8rX3LPx0uhvQ+9PqD4EKPrXXwGeckC8XhdOGcJj4zoqhnmvK1b1GDliBAzz/nQ=\n=MStZ\n-----END PGP SIGNATURE-----\n", "payload": "tree ad69be89f23dee0b48f501761651993b920e96ab\nparent 572c0d553f2bd1b934b08fe240310112369a5c76\nparent ee8942138a9ff0dedbe8575f0aacaea2ec78a51f\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1682747874 +0530\ncommitter GitHub <noreply@github.com> 1682747874 +0530\n\nRollup merge of #110614 - compiler-errors:new-solver-overflow-response, r=lcnr\n\nClear response values for overflow in new solver\n\nWhen we have an overflow, return a trivial query response. This fixes an ICE with the code described in #110544:\n\n```rust\ntrait Trait {}\n\nstruct W<T>(T);\n\nimpl<T, U> Trait for W<(W<T>, W<U>)>\nwhere\n    W<T>: Trait,\n    W<U>: Trait,\n{}\n\nfn impls<T: Trait>() {}\n\nfn main() {\n    impls::<W<_>>()\n}\n```\n\nWhere, while proving `W<?0>: Trait`, we overflow but still apply the query response of `?0 = (W<?1>, W<?2>)`. Then while re-processing the query to validate that our evaluation result was stable, we get a different query response that looks like `?1 = (W<?3>, W<?4>), ?2 = (W<?5>, W<?6>)`, and so we trigger the ICE.\n\nAlso, by returning a trivial query response we also avoid the infinite-loop/OOM behavior of the old solver.\n\nr? ``@lcnr``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307", "html_url": "https://github.com/rust-lang/rust/commit/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "572c0d553f2bd1b934b08fe240310112369a5c76", "url": "https://api.github.com/repos/rust-lang/rust/commits/572c0d553f2bd1b934b08fe240310112369a5c76", "html_url": "https://github.com/rust-lang/rust/commit/572c0d553f2bd1b934b08fe240310112369a5c76"}, {"sha": "ee8942138a9ff0dedbe8575f0aacaea2ec78a51f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8942138a9ff0dedbe8575f0aacaea2ec78a51f", "html_url": "https://github.com/rust-lang/rust/commit/ee8942138a9ff0dedbe8575f0aacaea2ec78a51f"}], "stats": {"total": 142, "additions": 122, "deletions": 20}, "files": [{"sha": "63a73f8d50d93b62f1b51e7027609b2ac7b552e9", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=6da62a40f25c7baa26c7d6ca79b5ecc804c0c307", "patch": "@@ -3,7 +3,8 @@ use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n-    DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime, TyCtxtInferExt,\n+    DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime, RegionVariableOrigin,\n+    TyCtxtInferExt,\n };\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n@@ -223,18 +224,20 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         {\n             debug!(\"rerunning goal to check result is stable\");\n             let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n-            let canonical_response =\n+            let new_canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-            if !canonical_response.value.var_values.is_identity() {\n+            if !new_canonical_response.value.var_values.is_identity() {\n                 bug!(\n                     \"unstable result: re-canonicalized goal={canonical_goal:#?} \\\n-                     response={canonical_response:#?}\"\n+                    first_response={canonical_response:#?} \\\n+                    second_response={new_canonical_response:#?}\"\n                 );\n             }\n-            if certainty != canonical_response.value.certainty {\n+            if certainty != new_canonical_response.value.certainty {\n                 bug!(\n                     \"unstable certainty: {certainty:#?} re-canonicalized goal={canonical_goal:#?} \\\n-                     response={canonical_response:#?}\"\n+                     first_response={canonical_response:#?} \\\n+                     second_response={new_canonical_response:#?}\"\n                 );\n             }\n         }\n@@ -434,6 +437,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         })\n     }\n \n+    pub(super) fn next_region_infer(&self) -> ty::Region<'tcx> {\n+        self.infcx.next_region_var(RegionVariableOrigin::MiscVariable(DUMMY_SP))\n+    }\n+\n     pub(super) fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n         self.infcx.next_const_var(\n             ty,"}, {"sha": "67ad7fb4bd21debff85d1035cd160da03a26fd8b", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=6da62a40f25c7baa26c7d6ca79b5ecc804c0c307", "patch": "@@ -16,7 +16,7 @@ use rustc_infer::infer::canonical::query_response::make_query_region_constraints\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData, MaybeCause};\n use rustc_middle::ty::{self, BoundVar, GenericArgKind};\n use rustc_span::DUMMY_SP;\n use std::iter;\n@@ -60,9 +60,27 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         let certainty = certainty.unify_with(goals_certainty);\n \n-        let external_constraints = self.compute_external_query_constraints()?;\n+        let response = match certainty {\n+            Certainty::Yes | Certainty::Maybe(MaybeCause::Ambiguity) => {\n+                let external_constraints = self.compute_external_query_constraints()?;\n+                Response { var_values: self.var_values, external_constraints, certainty }\n+            }\n+            Certainty::Maybe(MaybeCause::Overflow) => {\n+                // If we have overflow, it's probable that we're substituting a type\n+                // into itself infinitely and any partial substitutions in the query\n+                // response are probably not useful anyways, so just return an empty\n+                // query response.\n+                //\n+                // This may prevent us from potentially useful inference, e.g.\n+                // 2 candidates, one ambiguous and one overflow, which both\n+                // have the same inference constraints.\n+                //\n+                // Changing this to retain some constraints in the future\n+                // won't be a breaking change, so this is good enough for now.\n+                return Ok(self.make_ambiguous_response_no_constraints(MaybeCause::Overflow));\n+            }\n+        };\n \n-        let response = Response { var_values: self.var_values, external_constraints, certainty };\n         let canonical = Canonicalizer::canonicalize(\n             self.infcx,\n             CanonicalizeMode::Response { max_input_universe: self.max_input_universe },\n@@ -72,6 +90,40 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         Ok(canonical)\n     }\n \n+    /// Constructs a totally unconstrained, ambiguous response to a goal.\n+    ///\n+    /// Take care when using this, since often it's useful to respond with\n+    /// ambiguity but return constrained variables to guide inference.\n+    pub(in crate::solve) fn make_ambiguous_response_no_constraints(\n+        &self,\n+        maybe_cause: MaybeCause,\n+    ) -> CanonicalResponse<'tcx> {\n+        let unconstrained_response = Response {\n+            var_values: CanonicalVarValues {\n+                var_values: self.tcx().mk_substs_from_iter(self.var_values.var_values.iter().map(\n+                    |arg| -> ty::GenericArg<'tcx> {\n+                        match arg.unpack() {\n+                            GenericArgKind::Lifetime(_) => self.next_region_infer().into(),\n+                            GenericArgKind::Type(_) => self.next_ty_infer().into(),\n+                            GenericArgKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n+                        }\n+                    },\n+                )),\n+            },\n+            external_constraints: self\n+                .tcx()\n+                .mk_external_constraints(ExternalConstraintsData::default()),\n+            certainty: Certainty::Maybe(maybe_cause),\n+        };\n+\n+        Canonicalizer::canonicalize(\n+            self.infcx,\n+            CanonicalizeMode::Response { max_input_universe: self.max_input_universe },\n+            &mut Default::default(),\n+            unconstrained_response,\n+        )\n+    }\n+\n     #[instrument(level = \"debug\", skip(self), ret)]\n     fn compute_external_query_constraints(&self) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n         // Cannot use `take_registered_region_obligations` as we may compute the response"}, {"sha": "d94679fef283399422c27223ca77d34afef77262", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=6da62a40f25c7baa26c7d6ca79b5ecc804c0c307", "patch": "@@ -340,17 +340,17 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         if responses.is_empty() {\n             return Err(NoSolution);\n         }\n-        let certainty = responses.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n-            certainty.unify_with(response.value.certainty)\n-        });\n-\n-        let response = self.evaluate_added_goals_and_make_canonical_response(certainty);\n-        if let Ok(response) = response {\n-            assert!(response.has_no_inference_or_external_constraints());\n-            Ok(response)\n-        } else {\n-            bug!(\"failed to make floundered response: {responses:?}\");\n-        }\n+\n+        let Certainty::Maybe(maybe_cause) = responses.iter().fold(\n+            Certainty::AMBIGUOUS,\n+            |certainty, response| {\n+                certainty.unify_with(response.value.certainty)\n+            },\n+        ) else {\n+            bug!(\"expected flounder response to be ambiguous\")\n+        };\n+\n+        Ok(self.make_ambiguous_response_no_constraints(maybe_cause))\n     }\n }\n "}, {"sha": "b37f09ee185e9a29da8ff54f9df30dc687a95ba8", "filename": "tests/ui/traits/new-solver/exponential-trait-goals.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/tests%2Fui%2Ftraits%2Fnew-solver%2Fexponential-trait-goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/tests%2Fui%2Ftraits%2Fnew-solver%2Fexponential-trait-goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fexponential-trait-goals.rs?ref=6da62a40f25c7baa26c7d6ca79b5ecc804c0c307", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Trait {}\n+\n+struct W<T>(T);\n+\n+impl<T, U> Trait for W<(W<T>, W<U>)>\n+where\n+    W<T>: Trait,\n+    W<U>: Trait,\n+{\n+}\n+\n+fn impls<T: Trait>() {}\n+\n+fn main() {\n+    impls::<W<_>>();\n+    //~^ ERROR type annotations needed\n+    //~| ERROR overflow evaluating the requirement `W<_>: Trait`\n+}"}, {"sha": "28a99cbbca6a18a7eaad521d1d4449d7f86910ee", "filename": "tests/ui/traits/new-solver/exponential-trait-goals.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/tests%2Fui%2Ftraits%2Fnew-solver%2Fexponential-trait-goals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6da62a40f25c7baa26c7d6ca79b5ecc804c0c307/tests%2Fui%2Ftraits%2Fnew-solver%2Fexponential-trait-goals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fexponential-trait-goals.stderr?ref=6da62a40f25c7baa26c7d6ca79b5ecc804c0c307", "patch": "@@ -0,0 +1,23 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/exponential-trait-goals.rs:17:5\n+   |\n+LL |     impls::<W<_>>();\n+   |     ^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `impls`\n+\n+error[E0275]: overflow evaluating the requirement `W<_>: Trait`\n+  --> $DIR/exponential-trait-goals.rs:17:5\n+   |\n+LL |     impls::<W<_>>();\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`exponential_trait_goals`)\n+note: required by a bound in `impls`\n+  --> $DIR/exponential-trait-goals.rs:14:13\n+   |\n+LL | fn impls<T: Trait>() {}\n+   |             ^^^^^ required by this bound in `impls`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0275, E0282.\n+For more information about an error, try `rustc --explain E0275`."}]}