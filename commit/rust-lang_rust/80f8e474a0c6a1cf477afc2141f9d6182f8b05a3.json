{"sha": "80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZjhlNDc0YTBjNmExY2Y0NzdhZmMyMTQxZjlkNjE4MmY4YjA1YTM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-26T12:28:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-26T12:28:18Z"}, "message": "Merge pull request #3318 from matklad/cleanup\n\nReduce visibility", "tree": {"sha": "e6eae489689f0d9ffca3a02f910af900585488fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6eae489689f0d9ffca3a02f910af900585488fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeVmRiCRBK7hj4Ov3rIwAAdHIIALAyLasR7Dk48ls+sqEvRKSv\nkalkfZlZLHSgRskyDQ5iB1RxPq1WrtX8LFjD7+GZRCHBtqE5dCQWFt1YGryiUnkB\nlbo3pWWYXYmzpazN4enkMTlqfqEJuowGfSy3ngVJWjFZgZk9HkkNCGPfm9nJUW52\nsogJ7TL/uHZ0Nqc11N1iBYs/anVNhxucrgBFtYlKs9KVkGxUTnX1xP3WfXpacEI7\nCK0lKpb+J3danrYWG2Jr5wNgxjuAKSs/jhY4qWI6AFuBRYgs0vE+Ir/ummFTPr5O\nTs2KaBlE43YJgwAnsB2TSwQ0n9KkNyvI3h5+3sB9UJfq4M+5sF07lYGPMVW6zoM=\n=snMb\n-----END PGP SIGNATURE-----\n", "payload": "tree e6eae489689f0d9ffca3a02f910af900585488fb\nparent 5c64ad27e041bcdb281c0a751720ceb3a6369d04\nparent ade0176c20f7e4159a0cb81ae8034acacc915310\nauthor Aleksey Kladov <aleksey.kladov@gmail.com> 1582720098 +0100\ncommitter GitHub <noreply@github.com> 1582720098 +0100\n\nMerge pull request #3318 from matklad/cleanup\n\nReduce visibility"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "html_url": "https://github.com/rust-lang/rust/commit/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c64ad27e041bcdb281c0a751720ceb3a6369d04", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c64ad27e041bcdb281c0a751720ceb3a6369d04", "html_url": "https://github.com/rust-lang/rust/commit/5c64ad27e041bcdb281c0a751720ceb3a6369d04"}, {"sha": "ade0176c20f7e4159a0cb81ae8034acacc915310", "url": "https://api.github.com/repos/rust-lang/rust/commits/ade0176c20f7e4159a0cb81ae8034acacc915310", "html_url": "https://github.com/rust-lang/rust/commit/ade0176c20f7e4159a0cb81ae8034acacc915310"}], "stats": {"total": 191, "additions": 90, "deletions": 101}, "files": [{"sha": "3aa7c487041b44c798ec8b0b15bc7c8d4345073d", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "patch": "@@ -40,6 +40,7 @@ from_id![\n     (hir_def::ConstId, crate::Const),\n     (hir_def::FunctionId, crate::Function),\n     (hir_def::ImplId, crate::ImplBlock),\n+    (hir_def::TypeParamId, crate::TypeParam),\n     (hir_expand::MacroDefId, crate::MacroDef)\n ];\n "}, {"sha": "4a85e7e36d6f76a8ac747490547318edf9e733cf", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "patch": "@@ -47,7 +47,7 @@ pub use crate::{\n     },\n     has_source::HasSource,\n     semantics::{original_range, Semantics, SemanticsScope},\n-    source_analyzer::{PathResolution, ScopeEntryWithSyntax},\n+    source_analyzer::PathResolution,\n };\n \n pub use hir_def::{"}, {"sha": "9fedb7657937666c119274bfde8f0f053780bfc2", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "patch": "@@ -4,16 +4,16 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n-    TraitId,\n+    DefWithBodyId, TraitId,\n };\n use ra_db::{FileId, FileRange};\n-use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextUnit};\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextUnit};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     db::HirDatabase,\n     source_analyzer::{resolve_hir_path, ReferenceDescriptor, SourceAnalyzer},\n-    source_binder::{ChildContainer, SourceBinder, ToDef},\n+    source_binder::{ChildContainer, SourceBinder},\n     Function, HirFileId, InFile, Local, MacroDef, Module, Name, Origin, Path, PathResolution,\n     ScopeDef, StructField, Trait, Type, TypeParam, VariantDef,\n };\n@@ -129,9 +129,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n \n     pub fn to_def<T: ToDef + Clone>(&self, src: &T) -> Option<T::Def> {\n-        let src = self.find_file(src.syntax().clone()).with_value(src.clone());\n-        let mut sb = self.sb.borrow_mut();\n-        T::to_def(self.db, &mut sb, src)\n+        T::to_def(self, src)\n     }\n \n     pub fn to_module_def(&self, file: FileId) -> Option<Module> {\n@@ -227,6 +225,68 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n }\n \n+pub trait ToDef: Sized + AstNode + 'static {\n+    type Def;\n+    fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: &Self) -> Option<Self::Def>;\n+}\n+\n+macro_rules! to_def_impls {\n+    ($(($def:path, $ast:path)),* ,) => {$(\n+        impl ToDef for $ast {\n+            type Def = $def;\n+            fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: &Self)\n+                -> Option<Self::Def>\n+            {\n+                let src = sema.find_file(src.syntax().clone()).with_value(src);\n+                sema.sb.borrow_mut().to_id(sema.db, src.cloned()).map(Into::into)\n+            }\n+        }\n+    )*}\n+}\n+\n+to_def_impls![\n+    (crate::Module, ast::Module),\n+    (crate::Struct, ast::StructDef),\n+    (crate::Enum, ast::EnumDef),\n+    (crate::Union, ast::UnionDef),\n+    (crate::Trait, ast::TraitDef),\n+    (crate::ImplBlock, ast::ImplBlock),\n+    (crate::TypeAlias, ast::TypeAliasDef),\n+    (crate::Const, ast::ConstDef),\n+    (crate::Static, ast::StaticDef),\n+    (crate::Function, ast::FnDef),\n+    (crate::StructField, ast::RecordFieldDef),\n+    (crate::EnumVariant, ast::EnumVariant),\n+    (crate::TypeParam, ast::TypeParam),\n+    (crate::MacroDef, ast::MacroCall), // this one is dubious, not all calls are macros\n+];\n+\n+impl ToDef for ast::BindPat {\n+    type Def = Local;\n+\n+    fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: &Self) -> Option<Local> {\n+        let src = sema.find_file(src.syntax().clone()).with_value(src);\n+        let file_id = src.file_id;\n+        let mut sb = sema.sb.borrow_mut();\n+        let db = sema.db;\n+        let parent: DefWithBodyId = src.value.syntax().ancestors().find_map(|it| {\n+            let res = match_ast! {\n+                match it {\n+                    ast::ConstDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n+                    ast::StaticDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n+                    ast::FnDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        })?;\n+        let (_body, source_map) = db.body_with_source_map(parent);\n+        let src = src.cloned().map(ast::Pat::from);\n+        let pat_id = source_map.node_pat(src.as_ref())?;\n+        Some(Local { parent: parent.into(), pat_id })\n+    }\n+}\n+\n fn find_root(node: &SyntaxNode) -> SyntaxNode {\n     node.ancestors().last().unwrap()\n }"}, {"sha": "b655e2c3204b0691f2e29735150d3fa6279921e0", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "patch": "@@ -25,8 +25,8 @@ use ra_syntax::{\n };\n \n use crate::{\n-    db::HirDatabase, Adt, Const, EnumVariant, Function, Local, MacroDef, Name, Path, Static,\n-    Struct, Trait, Type, TypeAlias, TypeParam,\n+    db::HirDatabase, Adt, Const, EnumVariant, Function, Local, MacroDef, Path, Static, Struct,\n+    Trait, Type, TypeAlias, TypeParam,\n };\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n@@ -53,22 +53,6 @@ pub enum PathResolution {\n     AssocItem(crate::AssocItem),\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ScopeEntryWithSyntax {\n-    pub(crate) name: Name,\n-    pub(crate) ptr: Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>,\n-}\n-\n-impl ScopeEntryWithSyntax {\n-    pub fn name(&self) -> &Name {\n-        &self.name\n-    }\n-\n-    pub fn ptr(&self) -> Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>> {\n-        self.ptr\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct ReferenceDescriptor {\n     pub range: TextRange,\n@@ -235,16 +219,16 @@ impl SourceAnalyzer {\n         resolve_hir_path(db, &self.resolver, &hir_path)\n     }\n \n-    fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n+    fn resolve_local_name(\n+        &self,\n+        name_ref: &ast::NameRef,\n+    ) -> Option<Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>> {\n         let name = name_ref.as_name();\n         let source_map = self.body_source_map.as_ref()?;\n         let scopes = self.scopes.as_ref()?;\n         let scope = scope_for(scopes, source_map, InFile::new(self.file_id, name_ref.syntax()))?;\n         let entry = scopes.resolve_name_in_scope(scope, &name)?;\n-        Some(ScopeEntryWithSyntax {\n-            name: entry.name().clone(),\n-            ptr: source_map.pat_syntax(entry.pat())?.value,\n-        })\n+        Some(source_map.pat_syntax(entry.pat())?.value)\n     }\n \n     // FIXME: we only use this in `inline_local_variable` assist, ideally, we\n@@ -258,7 +242,7 @@ impl SourceAnalyzer {\n             .filter_map(ast::NameRef::cast)\n             .filter(|name_ref| match self.resolve_local_name(&name_ref) {\n                 None => false,\n-                Some(entry) => entry.ptr() == ptr,\n+                Some(d_ptr) => d_ptr == ptr,\n             })\n             .map(|name_ref| ReferenceDescriptor {\n                 name: name_ref.text().to_string(),"}, {"sha": "4353e25ac847057ad0c132b86ef671d9bf1e2d8d", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 14, "deletions": 70, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "patch": "@@ -6,7 +6,7 @@ use hir_def::{\n     dyn_map::DynMap,\n     keys::{self, Key},\n     ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId, ImplId, ModuleId,\n-    StaticId, StructFieldId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n+    StaticId, StructFieldId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::AsName, AstId, InFile, MacroDefId, MacroDefKind};\n use ra_db::FileId;\n@@ -17,9 +17,9 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashMap;\n \n-use crate::{db::HirDatabase, Local, Module, TypeParam};\n+use crate::{db::HirDatabase, Module};\n \n-pub struct SourceBinder {\n+pub(crate) struct SourceBinder {\n     child_by_source_cache: FxHashMap<ChildContainer, DynMap>,\n }\n \n@@ -38,7 +38,11 @@ impl SourceBinder {\n         Some(Module { id: ModuleId { krate, local_id } })\n     }\n \n-    fn to_id<T: ToId>(&mut self, db: &impl HirDatabase, src: InFile<T>) -> Option<T::ID> {\n+    pub(crate) fn to_id<T: ToId>(\n+        &mut self,\n+        db: &impl HirDatabase,\n+        src: InFile<T>,\n+    ) -> Option<T::ID> {\n         T::to_id(db, self, src)\n     }\n \n@@ -118,42 +122,6 @@ pub(crate) trait ToId: Sized {\n     ) -> Option<Self::ID>;\n }\n \n-pub trait ToDef: Sized + AstNode + 'static {\n-    type Def;\n-    fn to_def<DB: HirDatabase>(\n-        db: &DB,\n-        sb: &mut SourceBinder,\n-        src: InFile<Self>,\n-    ) -> Option<Self::Def>;\n-}\n-\n-macro_rules! to_def_impls {\n-    ($(($def:path, $ast:path)),* ,) => {$(\n-        impl ToDef for $ast {\n-            type Def = $def;\n-            fn to_def<DB: HirDatabase>(db: &DB, sb: &mut SourceBinder, src: InFile<Self>)\n-                -> Option<Self::Def>\n-            { sb.to_id(db, src).map(Into::into) }\n-        }\n-    )*}\n-}\n-\n-to_def_impls![\n-    (crate::Module, ast::Module),\n-    (crate::Struct, ast::StructDef),\n-    (crate::Enum, ast::EnumDef),\n-    (crate::Union, ast::UnionDef),\n-    (crate::Trait, ast::TraitDef),\n-    (crate::ImplBlock, ast::ImplBlock),\n-    (crate::TypeAlias, ast::TypeAliasDef),\n-    (crate::Const, ast::ConstDef),\n-    (crate::Static, ast::StaticDef),\n-    (crate::Function, ast::FnDef),\n-    (crate::StructField, ast::RecordFieldDef),\n-    (crate::EnumVariant, ast::EnumVariant),\n-    (crate::MacroDef, ast::MacroCall), // this one is dubious, not all calls are macros\n-];\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub(crate) enum ChildContainer {\n     DefWithBodyId(DefWithBodyId),\n@@ -245,37 +213,14 @@ impl ToId for ast::MacroCall {\n     }\n }\n \n-impl ToDef for ast::BindPat {\n-    type Def = Local;\n+impl ToId for ast::TypeParam {\n+    type ID = TypeParamId;\n \n-    fn to_def<DB: HirDatabase>(db: &DB, sb: &mut SourceBinder, src: InFile<Self>) -> Option<Local> {\n-        let file_id = src.file_id;\n-        let parent: DefWithBodyId = src.value.syntax().ancestors().find_map(|it| {\n-            let res = match_ast! {\n-                match it {\n-                    ast::ConstDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::StaticDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::FnDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    _ => return None,\n-                }\n-            };\n-            Some(res)\n-        })?;\n-        let (_body, source_map) = db.body_with_source_map(parent);\n-        let src = src.map(ast::Pat::from);\n-        let pat_id = source_map.node_pat(src.as_ref())?;\n-        Some(Local { parent: parent.into(), pat_id })\n-    }\n-}\n-\n-impl ToDef for ast::TypeParam {\n-    type Def = TypeParam;\n-\n-    fn to_def<DB: HirDatabase>(\n+    fn to_id<DB: HirDatabase>(\n         db: &DB,\n         sb: &mut SourceBinder,\n-        src: InFile<ast::TypeParam>,\n-    ) -> Option<TypeParam> {\n+        src: InFile<Self>,\n+    ) -> Option<Self::ID> {\n         let file_id = src.file_id;\n         let parent: GenericDefId = src.value.syntax().ancestors().find_map(|it| {\n             let res = match_ast! {\n@@ -291,8 +236,7 @@ impl ToDef for ast::TypeParam {\n             };\n             Some(res)\n         })?;\n-        let &id = sb.child_by_source(db, parent.into())[keys::TYPE_PARAM].get(&src)?;\n-        Some(TypeParam { id })\n+        sb.child_by_source(db, parent.into())[keys::TYPE_PARAM].get(&src).copied()\n     }\n }\n "}]}