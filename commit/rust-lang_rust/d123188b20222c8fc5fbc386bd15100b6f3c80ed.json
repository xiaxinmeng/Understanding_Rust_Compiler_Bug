{"sha": "d123188b20222c8fc5fbc386bd15100b6f3c80ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMjMxODhiMjAyMjJjOGZjNWZiYzM4NmJkMTUxMDBiNmYzYzgwZWQ=", "commit": {"author": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-06T18:59:32Z"}, "committer": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-06T18:59:32Z"}, "message": "Clean up check_loans.\n\nRefactor a number of functions in check_loans to take node IDs and spans\nrather than taking expressions directly. Also rename some variables to\nmake them less ambiguous.\n\nThis is the first step towards using ExprUseVisitor in check_loans, as\nnow some of the interfaces more closely match those used in\nExprUseVisitor.", "tree": {"sha": "2a64740d863f3669d2864296885de41afbbbf667", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a64740d863f3669d2864296885de41afbbbf667"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d123188b20222c8fc5fbc386bd15100b6f3c80ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d123188b20222c8fc5fbc386bd15100b6f3c80ed", "html_url": "https://github.com/rust-lang/rust/commit/d123188b20222c8fc5fbc386bd15100b6f3c80ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d123188b20222c8fc5fbc386bd15100b6f3c80ed/comments", "author": null, "committer": null, "parents": [{"sha": "071e22ed890377840d8b38a3809860e284538b74", "url": "https://api.github.com/repos/rust-lang/rust/commits/071e22ed890377840d8b38a3809860e284538b74", "html_url": "https://github.com/rust-lang/rust/commit/071e22ed890377840d8b38a3809860e284538b74"}], "stats": {"total": 85, "additions": 48, "deletions": 37}, "files": [{"sha": "6b8efe55f2430da8bb3d2abb9199f8f04444332e", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d123188b20222c8fc5fbc386bd15100b6f3c80ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d123188b20222c8fc5fbc386bd15100b6f3c80ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=d123188b20222c8fc5fbc386bd15100b6f3c80ed", "patch": "@@ -385,37 +385,47 @@ impl<'a> CheckLoanCtxt<'a> {\n         });\n     }\n \n-    pub fn check_assignment(&self, expr: &ast::Expr) {\n+    pub fn check_assignment_expr(&self, expr: &ast::Expr) {\n+        let assignment_id = expr.id;\n+        let assignment_span = expr.span;\n+\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n-        let cmt = match self.bccx.tcx.adjustments.borrow().find(&expr.id) {\n+        let assignee_cmt = match self.bccx.tcx.adjustments.borrow().find(&assignment_id) {\n             None => self.bccx.cat_expr_unadjusted(expr),\n             Some(adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n         };\n \n-        debug!(\"check_assignment(cmt={})\", cmt.repr(self.tcx()));\n+        self.check_assignment(assignment_id, assignment_span, assignee_cmt);\n+    }\n+\n+    fn check_assignment(&self,\n+                        assignment_id: ast::NodeId,\n+                        assignment_span: Span,\n+                        assignee_cmt: mc::cmt) {\n+        debug!(\"check_assignment(assignee_cmt={})\", assignee_cmt.repr(self.tcx()));\n \n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n-        if cmt.mutbl.is_mutable() {\n-            if check_for_aliasable_mutable_writes(self, expr, cmt.clone()) {\n+        if assignee_cmt.mutbl.is_mutable() {\n+            if check_for_aliasable_mutable_writes(self, assignment_span, assignee_cmt.clone()) {\n                 if check_for_assignment_to_restricted_or_frozen_location(\n-                    self, expr, cmt.clone()) {\n+                    self, assignment_id, assignment_span, assignee_cmt.clone()) {\n                     // Safe, but record for lint pass later:\n-                    mark_variable_as_used_mut(self, cmt);\n+                    mark_variable_as_used_mut(self, assignee_cmt);\n                 }\n             }\n             return;\n         }\n \n         // For immutable local variables, assignments are legal\n         // if they cannot already have been assigned\n-        if self.is_local_variable(cmt.clone()) {\n-            assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n-            let lp = opt_loan_path(&cmt).unwrap();\n-            self.move_data.each_assignment_of(expr.id, &lp, |assign| {\n+        if self.is_local_variable(assignee_cmt.clone()) {\n+            assert!(assignee_cmt.mutbl.is_immutable()); // no \"const\" locals\n+            let lp = opt_loan_path(&assignee_cmt).unwrap();\n+            self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n-                    expr.span,\n+                    assignment_span,\n                     &*lp,\n                     assign);\n                 false\n@@ -424,21 +434,21 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         // Otherwise, just a plain error.\n-        match opt_loan_path(&cmt) {\n+        match opt_loan_path(&assignee_cmt) {\n             Some(lp) => {\n                 self.bccx.span_err(\n-                    expr.span,\n+                    assignment_span,\n                     format!(\"cannot assign to {} {} `{}`\",\n-                            cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(&*cmt),\n+                            assignee_cmt.mutbl.to_user_str(),\n+                            self.bccx.cmt_to_str(&*assignee_cmt),\n                             self.bccx.loan_path_to_str(&*lp)).as_slice());\n             }\n             None => {\n                 self.bccx.span_err(\n-                    expr.span,\n+                    assignment_span,\n                     format!(\"cannot assign to {} {}\",\n-                            cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(&*cmt)).as_slice());\n+                            assignee_cmt.mutbl.to_user_str(),\n+                            self.bccx.cmt_to_str(&*assignee_cmt)).as_slice());\n             }\n         }\n         return;\n@@ -495,7 +505,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         fn check_for_aliasable_mutable_writes(this: &CheckLoanCtxt,\n-                                              expr: &ast::Expr,\n+                                              span: Span,\n                                               cmt: mc::cmt) -> bool {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n@@ -506,7 +516,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n-                    check_for_aliasability_violation(this, expr, b.clone());\n+                    check_for_aliasability_violation(this, span, b.clone());\n                 }\n \n                 _ => {}\n@@ -516,7 +526,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n-                                            expr: &ast::Expr,\n+                                            span: Span,\n                                             cmt: mc::cmt)\n                                             -> bool {\n             match cmt.freely_aliasable(this.tcx()) {\n@@ -528,7 +538,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 }\n                 Some(cause) => {\n                     this.bccx.report_aliasability_violation(\n-                        expr.span,\n+                        span,\n                         MutabilityViolation,\n                         cause);\n                     return false;\n@@ -538,13 +548,14 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         fn check_for_assignment_to_restricted_or_frozen_location(\n             this: &CheckLoanCtxt,\n-            expr: &ast::Expr,\n-            cmt: mc::cmt) -> bool\n+            assignment_id: ast::NodeId,\n+            assignment_span: Span,\n+            assignee_cmt: mc::cmt) -> bool\n         {\n             //! Check for assignments that violate the terms of an\n             //! outstanding loan.\n \n-            let loan_path = match opt_loan_path(&cmt) {\n+            let loan_path = match opt_loan_path(&assignee_cmt) {\n                 Some(lp) => lp,\n                 None => { return true; /* no loan path, can't be any loans */ }\n             };\n@@ -579,11 +590,11 @@ impl<'a> CheckLoanCtxt<'a> {\n             // `RESTR_MUTATE` restriction whenever the contents of an\n             // owned pointer are borrowed, and hence while `v[*]` is not\n             // restricted from being written, `v` is.\n-            let cont = this.each_in_scope_restriction(expr.id,\n+            let cont = this.each_in_scope_restriction(assignment_id,\n                                                       &*loan_path,\n                                                       |loan, restr| {\n                 if restr.set.intersects(RESTR_MUTATE) {\n-                    this.report_illegal_mutation(expr, &*loan_path, loan);\n+                    this.report_illegal_mutation(assignment_span, &*loan_path, loan);\n                     false\n                 } else {\n                     true\n@@ -656,9 +667,9 @@ impl<'a> CheckLoanCtxt<'a> {\n                 };\n \n                 // Check for a non-const loan of `loan_path`\n-                let cont = this.each_in_scope_loan(expr.id, |loan| {\n+                let cont = this.each_in_scope_loan(assignment_id, |loan| {\n                     if loan.loan_path == loan_path {\n-                        this.report_illegal_mutation(expr, &*full_loan_path, loan);\n+                        this.report_illegal_mutation(assignment_span, &*full_loan_path, loan);\n                         false\n                     } else {\n                         true\n@@ -671,11 +682,11 @@ impl<'a> CheckLoanCtxt<'a> {\n     }\n \n     pub fn report_illegal_mutation(&self,\n-                                   expr: &ast::Expr,\n+                                   span: Span,\n                                    loan_path: &LoanPath,\n                                    loan: &Loan) {\n         self.bccx.span_err(\n-            expr.span,\n+            span,\n             format!(\"cannot assign to `{}` because it is borrowed\",\n                     self.bccx.loan_path_to_str(loan_path)).as_slice());\n         self.bccx.span_note(\n@@ -733,7 +744,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 match freevar_mode {\n                     freevars::CaptureByRef => { }\n                     freevars::CaptureByValue => {\n-                        check_by_move_capture(self, closure_id, freevar, &*var_path);\n+                        check_by_move_capture(self, closure_id, freevar.span, &*var_path);\n                     }\n                 }\n             }\n@@ -742,14 +753,14 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         fn check_by_move_capture(this: &CheckLoanCtxt,\n                                  closure_id: ast::NodeId,\n-                                 freevar: &freevars::freevar_entry,\n+                                 freevar_span: Span,\n                                  move_path: &LoanPath) {\n             let move_err = this.analyze_move_out_from(closure_id, move_path);\n             match move_err {\n                 MoveOk => {}\n                 MoveWhileBorrowed(loan_path, loan_span) => {\n                     this.bccx.span_err(\n-                        freevar.span,\n+                        freevar_span,\n                         format!(\"cannot move `{}` into closure \\\n                                 because it is borrowed\",\n                                 this.bccx.loan_path_to_str(\n@@ -841,7 +852,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n       }\n       ast::ExprAssign(dest, _) |\n       ast::ExprAssignOp(_, dest, _) => {\n-        this.check_assignment(dest);\n+        this.check_assignment_expr(dest);\n       }\n       ast::ExprCall(f, ref args) => {\n         this.check_call(expr, Some(f), f.span, args.as_slice());\n@@ -859,7 +870,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n       }\n       ast::ExprInlineAsm(ref ia) => {\n           for &(_, out) in ia.outputs.iter() {\n-              this.check_assignment(out);\n+              this.check_assignment_expr(out);\n           }\n       }\n       _ => {}"}]}