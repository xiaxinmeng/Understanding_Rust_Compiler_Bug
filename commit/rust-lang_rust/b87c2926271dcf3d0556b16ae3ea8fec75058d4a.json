{"sha": "b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4N2MyOTI2MjcxZGNmM2QwNTU2YjE2YWUzZWE4ZmVjNzUwNThkNGE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-14T13:14:09Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-14T14:03:11Z"}, "message": "be more robust to bogus items in struct patterns/constructors\n\nFixes #27815", "tree": {"sha": "ff010f486989d8df16d6dd5872e4529cb58d85f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff010f486989d8df16d6dd5872e4529cb58d85f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "html_url": "https://github.com/rust-lang/rust/commit/b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b7fc67dd453c470a48dbdcf64693a93293c9ab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7fc67dd453c470a48dbdcf64693a93293c9ab0", "html_url": "https://github.com/rust-lang/rust/commit/7b7fc67dd453c470a48dbdcf64693a93293c9ab0"}], "stats": {"total": 214, "additions": 99, "deletions": 115}, "files": [{"sha": "9eb372a6c590b6789337f00fd8fddbeb27dab09c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "patch": "@@ -526,41 +526,41 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n                                   etc: bool, expected: Ty<'tcx>) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n+    let report_nonstruct = || {\n+        let name = pprust::path_to_string(path);\n+        span_err!(tcx.sess, pat.span, E0163,\n+                  \"`{}` does not name a struct or a struct variant\", name);\n+        fcx.write_error(pat.id);\n+\n+        for field in fields {\n+            check_pat(pcx, &field.node.pat, tcx.types.err);\n+        }\n+    };\n \n     let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n     let (adt_def, variant) = match def {\n-        def::DefTrait(_) => {\n-            let name = pprust::path_to_string(path);\n-            span_err!(tcx.sess, pat.span, E0168,\n-                \"use of trait `{}` in a struct pattern\", name);\n-            fcx.write_error(pat.id);\n-\n-            for field in fields {\n-                check_pat(pcx, &*field.node.pat, tcx.types.err);\n-            }\n-            return;\n-        },\n-        _ => {\n-            let def_type = tcx.lookup_item_type(def.def_id());\n-            match def_type.ty.sty {\n+        def::DefTy(did, _) | def::DefStruct(did) => {\n+            match tcx.lookup_item_type(did).ty.sty {\n                 ty::TyStruct(struct_def, _) =>\n                     (struct_def, struct_def.struct_variant()),\n-                ty::TyEnum(enum_def, _)\n-                    if def == def::DefVariant(enum_def.did, def.def_id(), true) =>\n-                    (enum_def, enum_def.variant_of_def(def)),\n                 _ => {\n-                    let name = pprust::path_to_string(path);\n-                    span_err!(tcx.sess, pat.span, E0163,\n-                        \"`{}` does not name a struct or a struct variant\", name);\n-                    fcx.write_error(pat.id);\n-\n-                    for field in fields {\n-                        check_pat(pcx, &*field.node.pat, tcx.types.err);\n-                    }\n+                    report_nonstruct();\n                     return;\n                 }\n             }\n         }\n+        def::DefVariant(eid, vid, true) => {\n+            match tcx.lookup_item_type(vid).ty.sty {\n+                ty::TyEnum(enum_def, _) if enum_def.did == eid => {\n+                    (enum_def, enum_def.variant_with_id(vid))\n+                }\n+                _ => tcx.sess.span_bug(pat.span, \"variant's type is not its enum\")\n+            }\n+        }\n+        _ => {\n+            report_nonstruct();\n+            return;\n+        }\n     };\n \n     instantiate_path(pcx.fcx,"}, {"sha": "92f39d972ee194926ba5e2332a48ad8db42cad48", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 45, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "patch": "@@ -1421,14 +1421,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// This is used when checking the constructor in struct literals.\n     fn instantiate_struct_literal_ty(&self,\n-                                     did: ast::DefId,\n+                                     struct_ty: ty::TypeScheme<'tcx>,\n                                      path: &ast::Path)\n                                      -> TypeAndSubsts<'tcx>\n     {\n-        let tcx = self.tcx();\n-\n-        let ty::TypeScheme { generics, ty: decl_ty } =\n-            tcx.lookup_item_type(did);\n+        let ty::TypeScheme { generics, ty: decl_ty } = struct_ty;\n \n         let substs = astconv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n@@ -3168,6 +3165,18 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n+    fn report_exprstruct_on_nondict<'a, 'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                              id: ast::NodeId,\n+                                              fields: &'tcx [ast::Field],\n+                                              base_expr: &'tcx Option<P<ast::Expr>>,\n+                                              path: &ast::Path)\n+    {\n+        span_err!(fcx.tcx().sess, path.span, E0071,\n+                  \"`{}` does not name a structure\",\n+                  pprust::path_to_string(path));\n+        check_struct_fields_on_error(fcx, id, fields, base_expr)\n+    }\n+\n     type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, Ty);\n \n     let tcx = fcx.ccx.tcx;\n@@ -3618,7 +3627,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n         // Resolve the path.\n         let def = lookup_full_def(tcx, path.span, id);\n-        let struct_id = match def {\n+\n+        let struct_ty = match def {\n             def::DefVariant(enum_id, variant_id, true) => {\n                 if let &Some(ref base_expr) = base_expr {\n                     span_err!(tcx.sess, base_expr.span, E0436,\n@@ -3627,54 +3637,38 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, &fields[..]);\n-                enum_id\n+                Some(tcx.lookup_item_type(enum_id))\n             }\n-            def::DefTrait(def_id) => {\n-                span_err!(tcx.sess, path.span, E0159,\n-                    \"use of trait `{}` as a struct constructor\",\n-                    pprust::path_to_string(path));\n-                check_struct_fields_on_error(fcx,\n-                                             id,\n-                                             &fields[..],\n-                                             base_expr);\n-                def_id\n-            },\n-            def => {\n+            def::DefTy(did, _) | def::DefStruct(did) => {\n                 // Verify that this was actually a struct.\n-                let typ = fcx.ccx.tcx.lookup_item_type(def.def_id());\n-                match typ.ty.sty {\n-                    ty::TyStruct(struct_def, _) => {\n-                        check_struct_constructor(fcx,\n-                                                 id,\n-                                                 expr.span,\n-                                                 struct_def,\n-                                                 &fields[..],\n-                                                 base_expr.as_ref().map(|e| &**e));\n-                    }\n-                    _ => {\n-                        span_err!(tcx.sess, path.span, E0071,\n-                            \"`{}` does not name a structure\",\n-                            pprust::path_to_string(path));\n-                        check_struct_fields_on_error(fcx,\n-                                                     id,\n-                                                     &fields[..],\n-                                                     base_expr);\n-                    }\n+                let typ = tcx.lookup_item_type(did);\n+                if let ty::TyStruct(struct_def, _) = typ.ty.sty {\n+                    check_struct_constructor(fcx,\n+                                             id,\n+                                             expr.span,\n+                                             struct_def,\n+                                             &fields,\n+                                             base_expr.as_ref().map(|e| &**e));\n+                } else {\n+                    report_exprstruct_on_nondict(fcx, id, &fields, base_expr, path);\n                 }\n-\n-                def.def_id()\n+                Some(typ)\n+            }\n+            _ => {\n+                report_exprstruct_on_nondict(fcx, id, &fields, base_expr, path);\n+                None\n             }\n         };\n \n         // Turn the path into a type and verify that that type unifies with\n         // the resulting structure type. This is needed to handle type\n         // parameters correctly.\n-        let actual_structure_type = fcx.expr_ty(&*expr);\n-        if !actual_structure_type.references_error() {\n-            let type_and_substs = fcx.instantiate_struct_literal_ty(struct_id, path);\n+        if let Some(struct_ty) = struct_ty {\n+            let expr_ty = fcx.expr_ty(&expr);\n+            let type_and_substs = fcx.instantiate_struct_literal_ty(struct_ty, path);\n             match fcx.mk_subty(false,\n                                infer::Misc(path.span),\n-                               actual_structure_type,\n+                               expr_ty,\n                                type_and_substs.ty) {\n                 Ok(()) => {}\n                 Err(type_error) => {\n@@ -3685,8 +3679,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                          fcx.infcx()\n                                             .ty_to_string(type_and_substs.ty),\n                                          fcx.infcx()\n-                                            .ty_to_string(\n-                                                actual_structure_type),\n+                                            .ty_to_string(expr_ty),\n                                          type_error);\n                     tcx.note_and_explain_type_err(&type_error, path.span);\n                 }"}, {"sha": "c49f05fa7a2e1b951846eed0509d8b17ad0bdfe5", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "patch": "@@ -735,39 +735,33 @@ fn some_func(x: &mut i32) {\n \"##,\n \n E0071: r##\"\n-You tried to use a structure initialization with a non-structure type.\n+You tried to use structure-literal syntax to create an item that is\n+not a struct-style structure or enum variant.\n+\n Example of erroneous code:\n \n ```\n-enum Foo { FirstValue };\n+enum Foo { FirstValue(i32) };\n \n let u = Foo::FirstValue { value: 0i32 }; // error: Foo::FirstValue\n                                          // isn't a structure!\n-// or even simpler, if the structure wasn't defined at all:\n-let u = RandomName { random_field: 0i32 }; // error: RandomName\n-                                           // isn't a structure!\n-```\n+// or even simpler, if the name doesn't refer to a structure at all.\n+let t = u32 { value: 4 }; // error: `u32` does not name a structure.```\n \n-To fix this, please check:\n- * Did you spell it right?\n- * Did you accidentaly used an enum as a struct?\n- * Did you accidentaly make an enum when you intended to use a struct?\n+To fix this, ensure that the name was correctly spelled, and that\n+the correct form of initializer was used.\n \n-Here is the previous code with all missing information:\n+For example, the code above can be fixed to:\n \n ```\n-struct Inner {\n-    value: i32\n-}\n-\n enum Foo {\n-    FirstValue(Inner)\n+    FirstValue(i32)\n }\n \n fn main() {\n-    let u = Foo::FirstValue(Inner { value: 0i32 });\n+    let u = Foo::FirstValue(0i32);\n \n-    let t = Inner { value: 0i32 };\n+    let t = 4;\n }\n ```\n \"##,\n@@ -1636,30 +1630,6 @@ fn(isize, *const *const u8) -> isize\n ```\n \"##,\n \n-E0159: r##\"\n-You tried to use a trait as a struct constructor. Erroneous code example:\n-\n-```\n-trait TraitNotAStruct {}\n-\n-TraitNotAStruct{ value: 0 }; // error: use of trait `TraitNotAStruct` as a\n-                             //        struct constructor\n-```\n-\n-Please verify you used the correct type name or please implement the trait\n-on a struct and use this struct constructor. Example:\n-\n-```\n-trait TraitNotAStruct {}\n-\n-struct Foo {\n-    value: i32\n-}\n-\n-Foo{ value: 0 }; // ok!\n-```\n-\"##,\n-\n E0166: r##\"\n This error means that the compiler found a return expression in a function\n marked as diverging. A function diverges if it has `!` in the place of the\n@@ -2673,10 +2643,11 @@ register_diagnostics! {\n     E0127,\n     E0129,\n     E0141,\n+//  E0159, // use of trait `{}` as struct constructor\n     E0163,\n     E0164,\n     E0167,\n-    E0168,\n+//  E0168,\n     E0173, // manual implementations of unboxed closure traits are experimental\n     E0174, // explicit use of unboxed closure methods are experimental\n     E0182,"}, {"sha": "5f7752bb203c2574da6986722d4ce348665c272e", "filename": "src/test/compile-fail-fulldeps/issue-18986.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs?ref=b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "patch": "@@ -15,6 +15,6 @@ pub use use_from_trait_xc::Trait;\n \n fn main() {\n     match () {\n-        Trait { x: 42 } => () //~ ERROR use of trait `Trait` in a struct pattern\n+        Trait { x: 42 } => () //~ ERROR `Trait` does not name a struct\n     }\n }"}, {"sha": "b1ac2dfd1c414b14b564f7f3b9f24ea4d5c2884a", "filename": "src/test/compile-fail/issue-27815.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod A {}\n+\n+fn main() {\n+    let u = A { x: 1 }; //~ ERROR `A` does not name a structure\n+    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a structure\n+    match () {\n+        A { x: 1 } => {} //~ ERROR `A` does not name a struct\n+        u32 { x: 1 } => {} //~ ERROR `u32` does not name a struct\n+    }\n+}"}, {"sha": "67ccd6b7cd058dd787c75c09230f58a45b72359c", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87c2926271dcf3d0556b16ae3ea8fec75058d4a/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "patch": "@@ -12,5 +12,5 @@ trait TraitNotAStruct {}\n \n fn main() {\n     TraitNotAStruct{ value: 0 };\n-    //~^ ERROR: use of trait `TraitNotAStruct` as a struct constructor [E0159]\n+    //~^ ERROR: `TraitNotAStruct` does not name a structure [E0071]\n }"}]}