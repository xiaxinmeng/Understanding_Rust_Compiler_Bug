{"sha": "512069f8e51c975aac6bab662d9fccbf019d2a27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMjA2OWY4ZTUxYzk3NWFhYzZiYWI2NjJkOWZjY2JmMDE5ZDJhMjc=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-03-26T19:30:41Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-04-01T00:09:29Z"}, "message": "Fix stack overflow when generating debuginfo for 'recursive' type\n\nBy using 'impl trait', it's possible to create a self-referential\ntype as follows:\n\nfn foo() -> impl Copy { foo }\n\nThis is a function which returns itself.\nNormally, the signature of this function would be impossible\nto write - it would look like 'fn foo() -> fn() -> fn() ...'\ne.g. a function which returns a function, which returns a function...\n\nUsing 'impl trait' allows us to avoid writing this infinitely long\ntype. While it's useless for practical purposes, it does compile and run\n\nHowever, issues arise when we try to generate llvm debuginfo for such a\ntype. All 'impl trait' types (e.g. ty::Opaque) are resolved when we\ngenerate debuginfo, which can lead to us recursing back to the original\n'fn' type when we try to process its return type.\n\nTo resolve this, I've modified debuginfo generation to account for these\nkinds of weird types. Unfortunately, there's no 'correct' debuginfo that\nwe can generate - 'impl trait' does not exist in debuginfo, and this\nkind of recursive type is impossible to directly represent.\n\nTo ensure that we emit *something*, this commit emits dummy\ndebuginfo/type names whenever it encounters a self-reference. In\npractice, this should never happen - it's just to ensure that we can\nemit some kind of debuginfo, even if it's not particularly meaningful\n\nFixes #58463", "tree": {"sha": "b4c8e57f7bd38dde579246ef0d50e6633cd6ac62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4c8e57f7bd38dde579246ef0d50e6633cd6ac62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/512069f8e51c975aac6bab662d9fccbf019d2a27", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAlyhVrkACgkQtAh+UQ6Y\nsWSplhAAggDBMzDd0kBSwQgJIJtpsP/k2kuJDG9X+X+TZ8/jV/iJUvlcn3o7miLT\n9hFL910HoqTa42RFlfUHg2SSemfgJCoC0Q3634dfBQP7YjRMEbzpReCrBFmOHzzx\ncXGEu57VbAE9YI+imtBYMSNz99TZWaFY2QbP084M1fIyQrqbGUxOJxwRk1IFg7gy\nVWrIvP3kAt6HeygNSoMjyNoBv3TEjaBp9+E1SMLZLIGsTHvQsn3hz8GopyqwIYWC\nLODB67521fd99uGi1V9l4DvbGXzpXk4y/aw4yoFlaqu296J2BFKr/CEtPdIZs5F3\nkpM+MWxjyojs1Pi3qa2mJo1lNlH2gLSH9N0HRssfosUDhxJxepith5oH7KMWkp9/\nJ/MCRV4Dm/XLS7S3vsqzitWUkHYUgxG73nNDbTrqmDijhQwd73TzedmjO50a2kQo\nfk++GqWUwGrYaOxWwTiJMNINnJAwkJjW9EQi5vn7zYu8jlGFsG94m8WN92TscZm8\nTDtz/w36TXB9ecNbwY76QFBgw+n8oBjFH771AJCoptZnoCng5mSxNpSMKBE++Vx5\nQ+cNDddPi9Ns8FUYYnDFvwwhYwnnTWeepFDd6KBcdvmqG4aeONGDK3jmtm/dO4mO\nu8l3VIsoS1FxYfWXtBC00lHIvox0b2nQZef9xyFtI0CH/Jvv9r0=\n=Iwzo\n-----END PGP SIGNATURE-----", "payload": "tree b4c8e57f7bd38dde579246ef0d50e6633cd6ac62\nparent 4fac5c98b22faa7fce2d5d64bf34c61340883302\nauthor Aaron Hill <aa1ronham@gmail.com> 1553628641 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1554077369 -0400\n\nFix stack overflow when generating debuginfo for 'recursive' type\n\nBy using 'impl trait', it's possible to create a self-referential\ntype as follows:\n\nfn foo() -> impl Copy { foo }\n\nThis is a function which returns itself.\nNormally, the signature of this function would be impossible\nto write - it would look like 'fn foo() -> fn() -> fn() ...'\ne.g. a function which returns a function, which returns a function...\n\nUsing 'impl trait' allows us to avoid writing this infinitely long\ntype. While it's useless for practical purposes, it does compile and run\n\nHowever, issues arise when we try to generate llvm debuginfo for such a\ntype. All 'impl trait' types (e.g. ty::Opaque) are resolved when we\ngenerate debuginfo, which can lead to us recursing back to the original\n'fn' type when we try to process its return type.\n\nTo resolve this, I've modified debuginfo generation to account for these\nkinds of weird types. Unfortunately, there's no 'correct' debuginfo that\nwe can generate - 'impl trait' does not exist in debuginfo, and this\nkind of recursive type is impossible to directly represent.\n\nTo ensure that we emit *something*, this commit emits dummy\ndebuginfo/type names whenever it encounters a self-reference. In\npractice, this should never happen - it's just to ensure that we can\nemit some kind of debuginfo, even if it's not particularly meaningful\n\nFixes #58463\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/512069f8e51c975aac6bab662d9fccbf019d2a27", "html_url": "https://github.com/rust-lang/rust/commit/512069f8e51c975aac6bab662d9fccbf019d2a27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/512069f8e51c975aac6bab662d9fccbf019d2a27/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fac5c98b22faa7fce2d5d64bf34c61340883302", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fac5c98b22faa7fce2d5d64bf34c61340883302", "html_url": "https://github.com/rust-lang/rust/commit/4fac5c98b22faa7fce2d5d64bf34c61340883302"}], "stats": {"total": 125, "additions": 108, "deletions": 17}, "files": [{"sha": "3d742811ff049b62c3a6a0860266f8413970f125", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/512069f8e51c975aac6bab662d9fccbf019d2a27/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512069f8e51c975aac6bab662d9fccbf019d2a27/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=512069f8e51c975aac6bab662d9fccbf019d2a27", "patch": "@@ -117,6 +117,32 @@ impl TypeMap<'ll, 'tcx> {\n         }\n     }\n \n+    // Removes a Ty to metadata mapping\n+    // This is useful when computing the metadata for a potentially\n+    // recursive type (e.g. a function ptr of the form:\n+    //\n+    // fn foo() -> impl Copy { foo }\n+    //\n+    // This kind of type cannot be properly represented\n+    // via LLVM debuginfo. As a workaround,\n+    // we register a temporary Ty to metadata mapping\n+    // for the function before we compute its actual metadat.a\n+    // If the metadata computation ends up recursing back to the\n+    // original function, it will use the temporary mapping\n+    // for the inner self-reference, preventing us from\n+    // recursing forever.\n+    //\n+    // This function is used to remove the temporary metadata\n+    // mapping after we've computed the actual metadat\n+    fn remove_type(\n+        &mut self,\n+        type_: Ty<'tcx>,\n+    ) {\n+        if self.type_to_metadata.remove(type_).is_none() {\n+            bug!(\"Type metadata Ty '{}' is not in the TypeMap!\", type_);\n+        }\n+    }\n+\n     // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n     // fail if the mapping already exists.\n     fn register_unique_id_with_metadata(\n@@ -608,17 +634,51 @@ pub fn type_metadata(\n             }\n         }\n         ty::FnDef(..) | ty::FnPtr(_) => {\n-            let fn_metadata = subroutine_type_metadata(cx,\n-                                                       unique_type_id,\n-                                                       t.fn_sig(cx.tcx),\n-                                                       usage_site_span).metadata;\n+\n             if let Some(metadata) = debug_context(cx).type_map\n                .borrow()\n                .find_metadata_for_unique_id(unique_type_id)\n             {\n                 return metadata;\n             }\n \n+            // It's possible to create a self-referential\n+            // type in Rust by using 'impl trait':\n+            //\n+            // fn foo() -> impl Copy { foo }\n+            //\n+            // See TypeMap::remove_type for more detals\n+            // about the workaround\n+\n+            let temp_type = {\n+                unsafe {\n+                    // The choice of type here is pretty arbitrary -\n+                    // anything reading the debuginfo for a recursive\n+                    // type is going to see *somthing* weird - the only\n+                    // question is what exactly it will see\n+                    let (size, align) = cx.size_and_align_of(t);\n+                    llvm::LLVMRustDIBuilderCreateBasicType(\n+                        DIB(cx),\n+                        SmallCStr::new(\"<recur_type>\").as_ptr(),\n+                        size.bits(),\n+                        align.bits() as u32,\n+                        DW_ATE_unsigned)\n+\n+\n+                }\n+            };\n+\n+            let type_map = &debug_context(cx).type_map;\n+            type_map.borrow_mut().register_type_with_metadata(t, temp_type);\n+\n+            let fn_metadata = subroutine_type_metadata(cx,\n+                                                       unique_type_id,\n+                                                       t.fn_sig(cx.tcx),\n+                                                       usage_site_span).metadata;\n+\n+            type_map.borrow_mut().remove_type(t);\n+\n+\n             // This is actually a function pointer, so wrap it in pointer DI\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n "}, {"sha": "024840a3fa8ad943bbc9f878e5b7e50de5c2f1e0", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/512069f8e51c975aac6bab662d9fccbf019d2a27/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512069f8e51c975aac6bab662d9fccbf019d2a27/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=512069f8e51c975aac6bab662d9fccbf019d2a27", "patch": "@@ -5,6 +5,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty};\n use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::fx::FxHashSet;\n \n use rustc::hir;\n \n@@ -17,7 +18,8 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                              qualified: bool)\n                                              -> String {\n     let mut result = String::with_capacity(64);\n-    push_debuginfo_type_name(cx, t, qualified, &mut result);\n+    let mut visited = FxHashSet::default();\n+    push_debuginfo_type_name(cx, t, qualified, &mut result, &mut visited);\n     result\n }\n \n@@ -26,7 +28,27 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                           t: Ty<'tcx>,\n                                           qualified: bool,\n-                                          output: &mut String) {\n+                                          output: &mut String,\n+                                          visited: &mut FxHashSet<Ty<'tcx>>) {\n+\n+    // We've encountered a weird 'recursive type'\n+    // Currently, the only way to generate such a type\n+    // is by using 'impl trait':\n+    //\n+    // fn foo() -> impl Copy { foo }\n+    //\n+    // There's not really a sensible name we can generate,\n+    // since we don't include 'impl trait' types (e.g. ty::Opaque)\n+    // in the output\n+    //\n+    // Since we need to generate *something*, we just\n+    // use a dummy string that should make it clear\n+    // that something unusual is going on\n+    if visited.insert(t) {\n+        output.push_str(\"<recursive_type>\");\n+        return;\n+    }\n+\n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n     let cpp_like_names = cx.sess().target.target.options.is_like_msvc;\n@@ -42,12 +64,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::Foreign(def_id) => push_item_name(cx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n             push_item_name(cx, def.did, qualified, output);\n-            push_type_params(cx, substs, output);\n+            push_type_params(cx, substs, output, visited);\n         },\n         ty::Tuple(component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n-                push_debuginfo_type_name(cx, component_type, true, output);\n+                push_debuginfo_type_name(cx, component_type, true, output, visited);\n                 output.push_str(\", \");\n             }\n             if !component_types.is_empty() {\n@@ -65,7 +87,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 hir::MutMutable => output.push_str(\"mut \"),\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('*');\n@@ -79,15 +101,15 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push_str(\"mut \");\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('*');\n             }\n         },\n         ty::Array(inner_type, len) => {\n             output.push('[');\n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n             output.push_str(&format!(\"; {}\", len.unwrap_usize(cx.tcx)));\n             output.push(']');\n         },\n@@ -98,7 +120,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('[');\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('>');\n@@ -113,7 +135,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     &principal,\n                 );\n                 push_item_name(cx, principal.def_id, false, output);\n-                push_type_params(cx, principal.substs, output);\n+                push_type_params(cx, principal.substs, output, visited);\n             } else {\n                 output.push_str(\"dyn '_\");\n             }\n@@ -136,7 +158,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n-                    push_debuginfo_type_name(cx, parameter_type, true, output);\n+                    push_debuginfo_type_name(cx, parameter_type, true, output, visited);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n@@ -155,7 +177,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n             if !sig.output().is_unit() {\n                 output.push_str(\" -> \");\n-                push_debuginfo_type_name(cx, sig.output(), true, output);\n+                push_debuginfo_type_name(cx, sig.output(), true, output, visited);\n             }\n         },\n         ty::Closure(..) => {\n@@ -200,15 +222,16 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     // common denominator - otherwise we would run into conflicts.\n     fn push_type_params<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   substs: SubstsRef<'tcx>,\n-                                  output: &mut String) {\n+                                  output: &mut String,\n+                                  visited: &mut FxHashSet<Ty<'tcx>>) {\n         if substs.types().next().is_none() {\n             return;\n         }\n \n         output.push('<');\n \n         for type_parameter in substs.types() {\n-            push_debuginfo_type_name(cx, type_parameter, true, output);\n+            push_debuginfo_type_name(cx, type_parameter, true, output, visited);\n             output.push_str(\", \");\n         }\n "}, {"sha": "8ab845366b7b4b873687dbc9e7aa6c4b82cd4237", "filename": "src/test/run-pass/issues/issue-58463.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/512069f8e51c975aac6bab662d9fccbf019d2a27/src%2Ftest%2Frun-pass%2Fissues%2Fissue-58463.rs", "raw_url": "https://github.com/rust-lang/rust/raw/512069f8e51c975aac6bab662d9fccbf019d2a27/src%2Ftest%2Frun-pass%2Fissues%2Fissue-58463.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-58463.rs?ref=512069f8e51c975aac6bab662d9fccbf019d2a27", "patch": "@@ -0,0 +1,8 @@\n+// run-pass\n+// compile-flags:-C debuginfo=2\n+fn foo() -> impl Copy {\n+    foo\n+}\n+fn main() {\n+    foo();\n+}"}]}