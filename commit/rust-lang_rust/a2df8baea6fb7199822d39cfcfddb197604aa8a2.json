{"sha": "a2df8baea6fb7199822d39cfcfddb197604aa8a2", "node_id": "C_kwDOAAsO6NoAKGEyZGY4YmFlYTZmYjcxOTk4MjJkMzljZmNmZGRiMTk3NjA0YWE4YTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-20T01:34:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-20T01:34:43Z"}, "message": "Auto merge of #96224 - Dylan-DPC:rollup-h2h3j93, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #95740 (asm: Add a kreg0 register class on x86 which includes k0)\n - #95813 (Remove extra space before a where clause)\n - #96029 (Refactor loop into iterator; simplify negation logic.)\n - #96162 (interpret: Fix writing uninit to an allocation)\n - #96165 (Miri provenance cleanup)\n - #96205 (Use futex locks on emscripten.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7af4ae85c6eb05003d29f6771f36854747334307", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7af4ae85c6eb05003d29f6771f36854747334307"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2df8baea6fb7199822d39cfcfddb197604aa8a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2df8baea6fb7199822d39cfcfddb197604aa8a2", "html_url": "https://github.com/rust-lang/rust/commit/a2df8baea6fb7199822d39cfcfddb197604aa8a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2df8baea6fb7199822d39cfcfddb197604aa8a2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ca19e09d302a4cbde14f9cb1bc109179dc824cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ca19e09d302a4cbde14f9cb1bc109179dc824cd", "html_url": "https://github.com/rust-lang/rust/commit/4ca19e09d302a4cbde14f9cb1bc109179dc824cd"}, {"sha": "da1ddf371c13aed51ae6f81b4dc13ed0d6d58e20", "url": "https://api.github.com/repos/rust-lang/rust/commits/da1ddf371c13aed51ae6f81b4dc13ed0d6d58e20", "html_url": "https://github.com/rust-lang/rust/commit/da1ddf371c13aed51ae6f81b4dc13ed0d6d58e20"}], "stats": {"total": 316, "additions": 201, "deletions": 115}, "files": [{"sha": "2e8cd934eb2986fb22f6633618722ec912ab8f44", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -589,6 +589,7 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => unimplemented!(),\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => unimplemented!(),\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n             InlineAsmRegClass::X86(\n                 X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg,\n@@ -654,6 +655,7 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg) => unimplemented!(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => cx.type_i16(),\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => cx.type_i32(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n@@ -784,6 +786,7 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n             _ => unreachable!(),\n         },\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => None,\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg) => {\n             unreachable!(\"clobber-only\")\n         }"}, {"sha": "e994001f96fd9b47cd6fa2e3c550c9ee1351b04d", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -602,7 +602,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"^Yk\",\n             InlineAsmRegClass::X86(\n-                X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg,\n+                X86InlineAsmRegClass::x87_reg\n+                | X86InlineAsmRegClass::mmx_reg\n+                | X86InlineAsmRegClass::kreg0,\n             ) => unreachable!(\"clobber-only\"),\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => \"r\",\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n@@ -687,7 +689,11 @@ fn modifier_to_llvm(\n             _ => unreachable!(),\n         },\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg) => {\n+        InlineAsmRegClass::X86(\n+            X86InlineAsmRegClass::x87_reg\n+            | X86InlineAsmRegClass::mmx_reg\n+            | X86InlineAsmRegClass::kreg0,\n+        ) => {\n             unreachable!(\"clobber-only\")\n         }\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => None,\n@@ -757,7 +763,11 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg) => {\n+        InlineAsmRegClass::X86(\n+            X86InlineAsmRegClass::x87_reg\n+            | X86InlineAsmRegClass::mmx_reg\n+            | X86InlineAsmRegClass::kreg0,\n+        ) => {\n             unreachable!(\"clobber-only\")\n         }\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => cx.type_i32(),"}, {"sha": "68f9bee593f65ea0f8b04da55f60ef657b0670f8", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -38,7 +38,7 @@ pub(crate) fn const_caller_location(\n     if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &loc_place).is_err() {\n         bug!(\"intern_const_alloc_recursive should not error in this case\")\n     }\n-    ConstValue::Scalar(Scalar::from_pointer(loc_place.ptr.into_pointer_or_addr().unwrap(), &tcx))\n+    ConstValue::Scalar(Scalar::from_maybe_pointer(loc_place.ptr, &tcx))\n }\n \n /// Convert an evaluated constant to a type level constant"}, {"sha": "7721485771b3b0a121ea08e321b326889869d982", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -88,6 +88,10 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Pointers are \"tagged\" with provenance information; typically the `AllocId` they belong to.\n     type PointerTag: Provenance + Eq + Hash + 'static;\n \n+    /// When getting the AllocId of a pointer, some extra data is also obtained from the tag\n+    /// that is passed to memory access hooks so they can do things with it.\n+    type TagExtra: Copy + 'static;\n+\n     /// Machines can define extra (non-instance) things that represent values of function pointers.\n     /// For example, Miri uses this to return a function pointer from `dlsym`\n     /// that can later be called to execute the right thing.\n@@ -122,6 +126,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n \n     /// Whether, when checking alignment, we should `force_int` and thus support\n     /// custom alignment logic based on whatever the integer address happens to be.\n+    ///\n+    /// Requires PointerTag::OFFSET_IS_ADDR to be true.\n     fn force_int_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Whether to enforce the validity invariant\n@@ -285,11 +291,14 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         addr: u64,\n     ) -> Pointer<Option<Self::PointerTag>>;\n \n-    /// Convert a pointer with provenance into an allocation-offset pair.\n+    /// Convert a pointer with provenance into an allocation-offset pair\n+    /// and extra provenance info.\n+    ///\n+    /// The returned `AllocId` must be the same as `ptr.provenance.get_alloc_id()`.\n     fn ptr_get_alloc(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer<Self::PointerTag>,\n-    ) -> (AllocId, Size);\n+    ) -> (AllocId, Size, Self::TagExtra);\n \n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n@@ -321,7 +330,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _tcx: TyCtxt<'tcx>,\n         _machine: &Self,\n         _alloc_extra: &Self::AllocExtra,\n-        _tag: Self::PointerTag,\n+        _tag: (AllocId, Self::TagExtra),\n         _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -333,7 +342,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _tcx: TyCtxt<'tcx>,\n         _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _tag: Self::PointerTag,\n+        _tag: (AllocId, Self::TagExtra),\n         _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -345,7 +354,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _tcx: TyCtxt<'tcx>,\n         _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _tag: Self::PointerTag,\n+        _tag: (AllocId, Self::TagExtra),\n         _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -397,6 +406,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n // (CTFE and ConstProp) use the same instance.  Here, we share that code.\n pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type PointerTag = AllocId;\n+    type TagExtra = ();\n+\n     type ExtraFnVal = !;\n \n     type MemoryMap =\n@@ -474,9 +485,12 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     }\n \n     #[inline(always)]\n-    fn ptr_get_alloc(_ecx: &InterpCx<$mir, $tcx, Self>, ptr: Pointer<AllocId>) -> (AllocId, Size) {\n+    fn ptr_get_alloc(\n+        _ecx: &InterpCx<$mir, $tcx, Self>,\n+        ptr: Pointer<AllocId>,\n+    ) -> (AllocId, Size, Self::TagExtra) {\n         // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n-        (alloc_id, offset)\n+        (alloc_id, offset, ())\n     }\n }"}, {"sha": "e8ee0fe6ea6ee16a79af4fa6252e9f5f9ab2b448", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 45, "deletions": 41, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -158,8 +158,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<AllocId>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-        let (alloc_id, offset) = ptr.into_parts();\n+        let alloc_id = ptr.provenance;\n         // We need to handle `extern static`.\n         match self.tcx.get_global_alloc(alloc_id) {\n             Some(GlobalAlloc::Static(def_id)) if self.tcx.is_thread_local_static(def_id) => {\n@@ -171,7 +170,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => {}\n         }\n         // And we need to get the tag.\n-        Ok(M::tag_alloc_base_pointer(self, Pointer::new(alloc_id, offset)))\n+        Ok(M::tag_alloc_base_pointer(self, ptr))\n     }\n \n     pub fn create_fn_alloc_ptr(\n@@ -238,7 +237,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"reallocating {:?} which does not point to the beginning of an object\",\n@@ -255,14 +254,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         // This will also call the access hooks.\n         self.mem_copy(\n-            ptr.into(),\n+            ptr,\n             Align::ONE,\n             new_ptr.into(),\n             Align::ONE,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n         )?;\n-        self.deallocate_ptr(ptr.into(), old_size_and_align, kind)?;\n+        self.deallocate_ptr(ptr, old_size_and_align, kind)?;\n \n         Ok(new_ptr)\n     }\n@@ -274,7 +273,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, tag) = self.ptr_get_alloc_id(ptr)?;\n         trace!(\"deallocating: {}\", alloc_id);\n \n         if offset.bytes() != 0 {\n@@ -330,7 +329,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             *self.tcx,\n             &mut self.machine,\n             &mut alloc.extra,\n-            ptr.provenance,\n+            (alloc_id, tag),\n             alloc_range(Size::ZERO, size),\n         )?;\n \n@@ -350,17 +349,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<(AllocId, Size, Pointer<M::PointerTag>)>> {\n+    ) -> InterpResult<'tcx, Option<(AllocId, Size, M::TagExtra)>> {\n         let align = M::enforce_alignment(&self).then_some(align);\n         self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n-            |alloc_id, offset, ptr| {\n+            |alloc_id, offset, tag| {\n                 let (size, align) =\n                     self.get_alloc_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n-                Ok((size, align, (alloc_id, offset, ptr)))\n+                Ok((size, align, (alloc_id, offset, tag)))\n             },\n         )\n     }\n@@ -401,11 +400,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         size: Size,\n         align: Option<Align>,\n         msg: CheckInAllocMsg,\n-        alloc_size: impl FnOnce(\n-            AllocId,\n-            Size,\n-            Pointer<M::PointerTag>,\n-        ) -> InterpResult<'tcx, (Size, Align, T)>,\n+        alloc_size: impl FnOnce(AllocId, Size, M::TagExtra) -> InterpResult<'tcx, (Size, Align, T)>,\n     ) -> InterpResult<'tcx, Option<T>> {\n         fn check_offset_align(offset: u64, align: Align) -> InterpResult<'static> {\n             if offset % align.bytes() == 0 {\n@@ -433,8 +428,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 None\n             }\n-            Ok((alloc_id, offset, ptr)) => {\n-                let (alloc_size, alloc_align, ret_val) = alloc_size(alloc_id, offset, ptr)?;\n+            Ok((alloc_id, offset, tag)) => {\n+                let (alloc_size, alloc_align, ret_val) = alloc_size(alloc_id, offset, tag)?;\n                 // Test bounds. This also ensures non-null.\n                 // It is sufficient to check this for the end pointer. Also check for overflow!\n                 if offset.checked_add(size, &self.tcx).map_or(true, |end| end > alloc_size) {\n@@ -450,10 +445,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n                     if M::force_int_for_alignment_check(self) {\n-                        let addr = Scalar::from_pointer(ptr, &self.tcx)\n-                            .to_machine_usize(&self.tcx)\n-                            .expect(\"ptr-to-int cast for align check should never fail\");\n-                        check_offset_align(addr, align)?;\n+                        // `force_int_for_alignment_check` can only be true if `OFFSET_IS_ADDR` is true.\n+                        check_offset_align(ptr.addr().bytes(), align)?;\n                     } else {\n                         // Check allocation alignment and offset alignment.\n                         if alloc_align.bytes() < align.bytes() {\n@@ -569,14 +562,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n-            |alloc_id, offset, ptr| {\n+            |alloc_id, offset, tag| {\n                 let alloc = self.get_alloc_raw(alloc_id)?;\n-                Ok((alloc.size(), alloc.align, (alloc_id, offset, ptr, alloc)))\n+                Ok((alloc.size(), alloc.align, (alloc_id, offset, tag, alloc)))\n             },\n         )?;\n-        if let Some((alloc_id, offset, ptr, alloc)) = ptr_and_alloc {\n+        if let Some((alloc_id, offset, tag, alloc)) = ptr_and_alloc {\n             let range = alloc_range(offset, size);\n-            M::memory_read(*self.tcx, &self.machine, &alloc.extra, ptr.provenance, range)?;\n+            M::memory_read(*self.tcx, &self.machine, &alloc.extra, (alloc_id, tag), range)?;\n             Ok(Some(AllocRef { alloc, range, tcx: *self.tcx, alloc_id }))\n         } else {\n             // Even in this branch we have to be sure that we actually access the allocation, in\n@@ -631,13 +624,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n-        if let Some((alloc_id, offset, ptr)) = parts {\n+        if let Some((alloc_id, offset, tag)) = parts {\n             let tcx = *self.tcx;\n             // FIXME: can we somehow avoid looking up the allocation twice here?\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n             let (alloc, machine) = self.get_alloc_raw_mut(alloc_id)?;\n             let range = alloc_range(offset, size);\n-            M::memory_written(tcx, machine, &mut alloc.extra, ptr.provenance, range)?;\n+            M::memory_written(tcx, machine, &mut alloc.extra, (alloc_id, tag), range)?;\n             Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id }))\n         } else {\n             Ok(None)\n@@ -732,7 +725,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"get_fn({:?})\", ptr);\n-        let (alloc_id, offset, _ptr) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n         }\n@@ -892,8 +885,11 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n     }\n \n     /// Mark the entire referenced range as uninitalized\n-    pub fn write_uninit(&mut self) {\n-        self.alloc.mark_init(self.range, false);\n+    pub fn write_uninit(&mut self) -> InterpResult<'tcx> {\n+        Ok(self\n+            .alloc\n+            .write_uninit(&self.tcx, self.range)\n+            .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n }\n \n@@ -1009,16 +1005,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // and once below to get the underlying `&[mut] Allocation`.\n \n         // Source alloc preparations and access hooks.\n-        let Some((src_alloc_id, src_offset, src)) = src_parts else {\n+        let Some((src_alloc_id, src_offset, src_tag)) = src_parts else {\n             // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n             return Ok(());\n         };\n         let src_alloc = self.get_alloc_raw(src_alloc_id)?;\n         let src_range = alloc_range(src_offset, size);\n-        M::memory_read(*tcx, &self.machine, &src_alloc.extra, src.provenance, src_range)?;\n+        M::memory_read(*tcx, &self.machine, &src_alloc.extra, (src_alloc_id, src_tag), src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n-        let Some((dest_alloc_id, dest_offset, dest)) = dest_parts else {\n+        let Some((dest_alloc_id, dest_offset, dest_tag)) = dest_parts else {\n             // Zero-sized *destination*.\n             return Ok(());\n         };\n@@ -1040,7 +1036,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Destination alloc preparations and access hooks.\n         let (dest_alloc, extra) = self.get_alloc_raw_mut(dest_alloc_id)?;\n         let dest_range = alloc_range(dest_offset, size * num_copies);\n-        M::memory_written(*tcx, extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n+        M::memory_written(\n+            *tcx,\n+            extra,\n+            &mut dest_alloc.extra,\n+            (dest_alloc_id, dest_tag),\n+            dest_range,\n+        )?;\n         let dest_bytes = dest_alloc\n             .get_bytes_mut_ptr(&tcx, dest_range)\n             .map_err(|e| e.to_interp_error(dest_alloc_id))?\n@@ -1053,8 +1055,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // This also avoids writing to the target bytes so that the backing allocation is never\n             // touched if the bytes stay uninitialized for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n-            dest_alloc.mark_init(dest_range, false); // `Size` multiplication\n-            dest_alloc.mark_relocation_range(relocations);\n+            dest_alloc\n+                .write_uninit(&tcx, dest_range)\n+                .map_err(|e| e.to_interp_error(dest_alloc_id))?;\n+            // We can forget about the relocations, this is all not initialized anyway.\n             return Ok(());\n         }\n \n@@ -1159,11 +1163,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn ptr_try_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n-    ) -> Result<(AllocId, Size, Pointer<M::PointerTag>), u64> {\n+    ) -> Result<(AllocId, Size, M::TagExtra), u64> {\n         match ptr.into_pointer_or_addr() {\n             Ok(ptr) => {\n-                let (alloc_id, offset) = M::ptr_get_alloc(self, ptr);\n-                Ok((alloc_id, offset, ptr))\n+                let (alloc_id, offset, extra) = M::ptr_get_alloc(self, ptr);\n+                Ok((alloc_id, offset, extra))\n             }\n             Err(addr) => Err(addr.bytes()),\n         }\n@@ -1174,7 +1178,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn ptr_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n-    ) -> InterpResult<'tcx, (AllocId, Size, Pointer<M::PointerTag>)> {\n+    ) -> InterpResult<'tcx, (AllocId, Size, M::TagExtra)> {\n         self.ptr_try_get_alloc_id(ptr).map_err(|offset| {\n             err_ub!(DanglingIntPointer(offset, CheckInAllocMsg::InboundsTest)).into()\n         })"}, {"sha": "e4660fe090ce5fb4900d9c350908103866906a1d", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -823,7 +823,7 @@ where\n             // Zero-sized access\n             return Ok(());\n         };\n-        alloc.write_uninit();\n+        alloc.write_uninit()?;\n         Ok(())\n     }\n "}, {"sha": "71d29be97d5ec38e99b544bee0532d2c58ad4400", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -432,7 +432,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if let Some(ref mut ref_tracking) = self.ref_tracking {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n-            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n+            if let Ok((alloc_id, _offset, _tag)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n                 // Special handling for pointers to statics (irrespective of their type).\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {"}, {"sha": "e1e0ed7222d55fb39265197de0f449e32bf5d32d", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -338,18 +338,12 @@ impl MultiSpan {\n \n     /// Returns `true` if any of the primary spans are displayable.\n     pub fn has_primary_spans(&self) -> bool {\n-        self.primary_spans.iter().any(|sp| !sp.is_dummy())\n+        !self.is_dummy()\n     }\n \n     /// Returns `true` if this contains only a dummy primary span with any hygienic context.\n     pub fn is_dummy(&self) -> bool {\n-        let mut is_dummy = true;\n-        for span in &self.primary_spans {\n-            if !span.is_dummy() {\n-                is_dummy = false;\n-            }\n-        }\n-        is_dummy\n+        self.primary_spans.iter().all(|sp| sp.is_dummy())\n     }\n \n     /// Replaces all occurrences of one Span with another. Used to move `Span`s in areas that don't"}, {"sha": "7723f7a64f7691e0bcb53ad367560e9309a9d6cd", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -269,7 +269,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n     /// `get_bytes_with_uninit_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n-    /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n+    /// even when new allocations are pushed to the `HashMap`. `mem_copy_repeatedly` relies\n     /// on that.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n@@ -429,8 +429,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n         let val = match val {\n             ScalarMaybeUninit::Scalar(scalar) => scalar,\n             ScalarMaybeUninit::Uninit => {\n-                self.mark_init(range, false);\n-                return Ok(());\n+                return self.write_uninit(cx, range);\n             }\n         };\n \n@@ -455,6 +454,13 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n \n         Ok(())\n     }\n+\n+    /// Write \"uninit\" to the given memory range.\n+    pub fn write_uninit(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n+        self.mark_init(range, false);\n+        self.clear_relocations(cx, range)?;\n+        return Ok(());\n+    }\n }\n \n /// Relocations.\n@@ -561,8 +567,10 @@ impl<Tag> Deref for Relocations<Tag> {\n }\n \n /// A partial, owned list of relocations to transfer into another allocation.\n+///\n+/// Offsets are already adjusted to the destination allocation.\n pub struct AllocationRelocations<Tag> {\n-    relative_relocations: Vec<(Size, Tag)>,\n+    dest_relocations: Vec<(Size, Tag)>,\n }\n \n impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n@@ -575,12 +583,17 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     ) -> AllocationRelocations<Tag> {\n         let relocations = self.get_relocations(cx, src);\n         if relocations.is_empty() {\n-            return AllocationRelocations { relative_relocations: Vec::new() };\n+            return AllocationRelocations { dest_relocations: Vec::new() };\n         }\n \n         let size = src.size;\n         let mut new_relocations = Vec::with_capacity(relocations.len() * (count as usize));\n \n+        // If `count` is large, this is rather wasteful -- we are allocating a big array here, which\n+        // is mostly filled with redundant information since it's just N copies of the same `Tag`s\n+        // at slightly adjusted offsets. The reason we do this is so that in `mark_relocation_range`\n+        // we can use `insert_presorted`. That wouldn't work with an `Iterator` that just produces\n+        // the right sequence of relocations for all N copies.\n         for i in 0..count {\n             new_relocations.extend(relocations.iter().map(|&(offset, reloc)| {\n                 // compute offset for current repetition\n@@ -593,14 +606,17 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n             }));\n         }\n \n-        AllocationRelocations { relative_relocations: new_relocations }\n+        AllocationRelocations { dest_relocations: new_relocations }\n     }\n \n     /// Applies a relocation copy.\n     /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n     /// to be clear of relocations.\n+    ///\n+    /// This is dangerous to use as it can violate internal `Allocation` invariants!\n+    /// It only exists to support an efficient implementation of `mem_copy_repeatedly`.\n     pub fn mark_relocation_range(&mut self, relocations: AllocationRelocations<Tag>) {\n-        self.relocations.0.insert_presorted(relocations.relative_relocations);\n+        self.relocations.0.insert_presorted(relocations.dest_relocations);\n     }\n }\n \n@@ -1056,7 +1072,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         })\n     }\n \n-    pub fn mark_init(&mut self, range: AllocRange, is_init: bool) {\n+    fn mark_init(&mut self, range: AllocRange, is_init: bool) {\n         if range.size.bytes() == 0 {\n             return;\n         }\n@@ -1118,6 +1134,9 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     }\n \n     /// Applies multiple instances of the run-length encoding to the initialization mask.\n+    ///\n+    /// This is dangerous to use as it can violate internal `Allocation` invariants!\n+    /// It only exists to support an efficient implementation of `mem_copy_repeatedly`.\n     pub fn mark_compressed_init_range(\n         &mut self,\n         defined: &InitMaskCompressed,"}, {"sha": "c71aea417eca0143279c565a813ed0da9203dabc", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -163,6 +163,9 @@ pub struct Pointer<Tag = AllocId> {\n }\n \n static_assert_size!(Pointer, 16);\n+// `Option<Tag>` pointers are also passed around quite a bit\n+// (but not stored in permanent machine state).\n+static_assert_size!(Pointer<Option<AllocId>>, 16);\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n@@ -198,12 +201,26 @@ impl<Tag> From<Pointer<Tag>> for Pointer<Option<Tag>> {\n }\n \n impl<Tag> Pointer<Option<Tag>> {\n+    /// Convert this pointer that *might* have a tag into a pointer that *definitely* has a tag, or\n+    /// an absolute address.\n+    ///\n+    /// This is rarely what you want; call `ptr_try_get_alloc_id` instead.\n     pub fn into_pointer_or_addr(self) -> Result<Pointer<Tag>, Size> {\n         match self.provenance {\n             Some(tag) => Ok(Pointer::new(tag, self.offset)),\n             None => Err(self.offset),\n         }\n     }\n+\n+    /// Returns the absolute address the pointer points to.\n+    /// Only works if Tag::OFFSET_IS_ADDR is true!\n+    pub fn addr(self) -> Size\n+    where\n+        Tag: Provenance,\n+    {\n+        assert!(Tag::OFFSET_IS_ADDR);\n+        self.offset\n+    }\n }\n \n impl<Tag> Pointer<Option<Tag>> {"}, {"sha": "b7f695da544f1db26a260a1c26d2e3a63cf42b64", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -851,6 +851,7 @@ fn write_allocation_bytes<'tcx, Tag: Provenance, Extra>(\n         }\n         if let Some(&tag) = alloc.relocations().get(&i) {\n             // Memory with a relocation must be defined\n+            assert!(alloc.init_mask().is_range_initialized(i, i + ptr_size).is_ok());\n             let j = i.bytes_usize();\n             let offset = alloc\n                 .inspect_with_uninit_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());"}, {"sha": "e3ce8105a8b47a825ccb5499944993015f4bea92", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -803,6 +803,7 @@ symbols! {\n         keyword,\n         kind,\n         kreg,\n+        kreg0,\n         label,\n         label_break_value,\n         lang,"}, {"sha": "6bc807c7c4421649f89e81867da730d26a88b733", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -893,7 +893,7 @@ impl InlineAsmClobberAbi {\n \n                     xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n \n-                    k1, k2, k3, k4, k5, k6, k7,\n+                    k0, k1, k2, k3, k4, k5, k6, k7,\n \n                     mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7,\n                     st0, st1, st2, st3, st4, st5, st6, st7,\n@@ -908,7 +908,7 @@ impl InlineAsmClobberAbi {\n                     zmm16, zmm17, zmm18, zmm19, zmm20, zmm21, zmm22, zmm23,\n                     zmm24, zmm25, zmm26, zmm27, zmm28, zmm29, zmm30, zmm31,\n \n-                    k1, k2, k3, k4, k5, k6, k7,\n+                    k0, k1, k2, k3, k4, k5, k6, k7,\n \n                     mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7,\n                     st0, st1, st2, st3, st4, st5, st6, st7,\n@@ -927,7 +927,7 @@ impl InlineAsmClobberAbi {\n                     zmm16, zmm17, zmm18, zmm19, zmm20, zmm21, zmm22, zmm23,\n                     zmm24, zmm25, zmm26, zmm27, zmm28, zmm29, zmm30, zmm31,\n \n-                    k1, k2, k3, k4, k5, k6, k7,\n+                    k0, k1, k2, k3, k4, k5, k6, k7,\n \n                     mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7,\n                     st0, st1, st2, st3, st4, st5, st6, st7,"}, {"sha": "854674c7f2fa7c98804c4ce6cc28bc9d5c483a9b", "filename": "compiler/rustc_target/src/asm/x86.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -14,6 +14,7 @@ def_reg_class! {\n         ymm_reg,\n         zmm_reg,\n         kreg,\n+        kreg0,\n         mmx_reg,\n         x87_reg,\n     }\n@@ -38,7 +39,7 @@ impl X86InlineAsmRegClass {\n             }\n             Self::reg_byte => &[],\n             Self::xmm_reg | Self::ymm_reg | Self::zmm_reg => &['x', 'y', 'z'],\n-            Self::kreg => &[],\n+            Self::kreg | Self::kreg0 => &[],\n             Self::mmx_reg | Self::x87_reg => &[],\n         }\n     }\n@@ -77,7 +78,7 @@ impl X86InlineAsmRegClass {\n                 256 => Some(('y', \"ymm0\")),\n                 _ => Some(('x', \"xmm0\")),\n             },\n-            Self::kreg => None,\n+            Self::kreg | Self::kreg0 => None,\n             Self::mmx_reg | Self::x87_reg => None,\n         }\n     }\n@@ -95,7 +96,7 @@ impl X86InlineAsmRegClass {\n             Self::xmm_reg => Some(('x', \"xmm0\")),\n             Self::ymm_reg => Some(('y', \"ymm0\")),\n             Self::zmm_reg => Some(('z', \"zmm0\")),\n-            Self::kreg => None,\n+            Self::kreg | Self::kreg0 => None,\n             Self::mmx_reg | Self::x87_reg => None,\n         }\n     }\n@@ -132,6 +133,7 @@ impl X86InlineAsmRegClass {\n                 avx512f: I8, I16;\n                 avx512bw: I32, I64;\n             },\n+            Self::kreg0 => &[],\n             Self::mmx_reg | Self::x87_reg => &[],\n         }\n     }\n@@ -294,6 +296,7 @@ def_regs! {\n         zmm29: zmm_reg = [\"zmm29\", \"xmm29\", \"ymm29\"] % x86_64_only,\n         zmm30: zmm_reg = [\"zmm30\", \"xmm30\", \"ymm30\"] % x86_64_only,\n         zmm31: zmm_reg = [\"zmm31\", \"xmm31\", \"ymm31\"] % x86_64_only,\n+        k0: kreg0 = [\"k0\"],\n         k1: kreg = [\"k1\"],\n         k2: kreg = [\"k2\"],\n         k3: kreg = [\"k3\"],\n@@ -323,8 +326,6 @@ def_regs! {\n             \"the stack pointer cannot be used as an operand for inline asm\",\n         #error = [\"ip\", \"eip\", \"rip\"] =>\n             \"the instruction pointer cannot be used as an operand for inline asm\",\n-        #error = [\"k0\"] =>\n-            \"the k0 AVX mask register cannot be used as an operand for inline asm\",\n     }\n }\n "}, {"sha": "c12ee169e797aa78c904d3e5d125e16ceed4145d", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -52,25 +52,6 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n     }\n }\n \n-#[cfg(target_os = \"emscripten\")]\n-pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) {\n-    extern \"C\" {\n-        fn emscripten_futex_wait(\n-            addr: *const AtomicU32,\n-            val: libc::c_uint,\n-            max_wait_ms: libc::c_double,\n-        ) -> libc::c_int;\n-    }\n-\n-    unsafe {\n-        emscripten_futex_wait(\n-            futex,\n-            expected,\n-            timeout.map_or(crate::f64::INFINITY, |d| d.as_secs_f64() * 1000.0),\n-        );\n-    }\n-}\n-\n /// Wake up one thread that's blocked on futex_wait on this futex.\n ///\n /// Returns true if this actually woke up such a thread,\n@@ -101,10 +82,32 @@ pub fn futex_wake_all(futex: &AtomicU32) {\n }\n \n #[cfg(target_os = \"emscripten\")]\n-pub fn futex_wake(futex: &AtomicU32) -> bool {\n-    extern \"C\" {\n-        fn emscripten_futex_wake(addr: *const AtomicU32, count: libc::c_int) -> libc::c_int;\n+extern \"C\" {\n+    fn emscripten_futex_wake(addr: *const AtomicU32, count: libc::c_int) -> libc::c_int;\n+    fn emscripten_futex_wait(\n+        addr: *const AtomicU32,\n+        val: libc::c_uint,\n+        max_wait_ms: libc::c_double,\n+    ) -> libc::c_int;\n+}\n+\n+#[cfg(target_os = \"emscripten\")]\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {\n+    unsafe {\n+        emscripten_futex_wait(\n+            futex,\n+            expected,\n+            timeout.map_or(f64::INFINITY, |d| d.as_secs_f64() * 1000.0),\n+        ) != -libc::ETIMEDOUT\n     }\n+}\n \n+#[cfg(target_os = \"emscripten\")]\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n     unsafe { emscripten_futex_wake(futex, 1) > 0 }\n }\n+\n+#[cfg(target_os = \"emscripten\")]\n+pub fn futex_wake_all(futex: &AtomicU32) {\n+    unsafe { emscripten_futex_wake(futex, i32::MAX) };\n+}"}, {"sha": "3e39c8b9b23e7a00ab22c9c317d49d97e73d45a2", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -2,6 +2,7 @@ cfg_if::cfg_if! {\n     if #[cfg(any(\n         target_os = \"linux\",\n         target_os = \"android\",\n+        all(target_os = \"emscripten\", target_feature = \"atomics\"),\n     ))] {\n         mod futex;\n         mod futex_rwlock;"}, {"sha": "fd6d675dc8b8c5247ee16a9a55a49daea15e3323", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -370,7 +370,8 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n             clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n             clause.insert_str(0, &\"&nbsp;\".repeat(indent.saturating_sub(1)));\n             if !end_newline {\n-                clause.insert_str(0, \"<br>\");\n+                // we insert the <br> after a single space but before multiple spaces at the start\n+                clause.insert_str(if indent == 0 { 1 } else { 0 }, \"<br>\");\n             }\n         }\n         write!(f, \"{}\", clause)"}, {"sha": "a87152e0321b9b4a658f53e1772894c8e471b904", "filename": "src/test/codegen/asm-clobber_abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Fcodegen%2Fasm-clobber_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Fcodegen%2Fasm-clobber_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasm-clobber_abi.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -6,29 +6,29 @@\n use std::arch::asm;\n \n // CHECK-LABEL: @clobber_sysv64\n-// CHECK: ={ax},={cx},={dx},={si},={di},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n+// CHECK: ={ax},={cx},={dx},={si},={di},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k0},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n #[no_mangle]\n pub unsafe fn clobber_sysv64() {\n     asm!(\"\", clobber_abi(\"sysv64\"));\n }\n \n // CHECK-LABEL: @clobber_win64\n-// CHECK: ={ax},={cx},={dx},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n+// CHECK: ={ax},={cx},={dx},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k0},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n #[no_mangle]\n pub unsafe fn clobber_win64() {\n     asm!(\"\", clobber_abi(\"win64\"));\n }\n \n // CHECK-LABEL: @clobber_sysv64\n-// CHECK: =&{dx},={ax},={cx},={si},={di},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n+// CHECK: =&{dx},={ax},={cx},={si},={di},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k0},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n #[no_mangle]\n pub unsafe fn clobber_sysv64_edx() {\n     let foo: i32;\n     asm!(\"\", out(\"edx\") foo, clobber_abi(\"sysv64\"));\n }\n \n // CHECK-LABEL: @clobber_win64\n-// CHECK: =&{dx},={ax},={cx},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n+// CHECK: =&{dx},={ax},={cx},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k0},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n #[no_mangle]\n pub unsafe fn clobber_win64_edx() {\n     let foo: i32;"}, {"sha": "0133bcaeb66734f700c59da6b6ec9d0749d812a8", "filename": "src/test/rustdoc/where.SWhere_Simd_item-decl.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Frustdoc%2Fwhere.SWhere_Simd_item-decl.html", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Frustdoc%2Fwhere.SWhere_Simd_item-decl.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhere.SWhere_Simd_item-decl.html?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -0,0 +1 @@\n+<div class=\"docblock item-decl\"><pre class=\"rust struct\"><code>pub struct Simd&lt;T&gt;(_) <br /><span class=\"where\">where<br />&#160;&#160;&#160;&#160;T: <a class=\"trait\" href=\"trait.MyTrait.html\" title=\"trait foo::MyTrait\">MyTrait</a></span>;</code></pre></div>\n\\ No newline at end of file"}, {"sha": "54026ff034e001b93f3b6fd8f4b5141ff5528f76", "filename": "src/test/rustdoc/where.SWhere_TraitWhere_item-decl.html", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Frustdoc%2Fwhere.SWhere_TraitWhere_item-decl.html", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Frustdoc%2Fwhere.SWhere_TraitWhere_item-decl.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhere.SWhere_TraitWhere_item-decl.html?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -0,0 +1,3 @@\n+<div class=\"docblock item-decl\"><pre class=\"rust trait\"><code>pub trait TraitWhere {\n+    type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a>&lt;'a&gt;<br />&#160;&#160;&#160; <span class=\"where\">where<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Self: 'a</span>;\n+}</code></pre></div>\n\\ No newline at end of file"}, {"sha": "50a5722fbaff6926e5feec51c6ffd18d531bac5a", "filename": "src/test/rustdoc/where.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Frustdoc%2Fwhere.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Frustdoc%2Fwhere.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhere.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -1,3 +1,4 @@\n+#![feature(generic_associated_types)]\n #![crate_name = \"foo\"]\n \n pub trait MyTrait { fn dummy(&self) { } }\n@@ -19,6 +20,18 @@ impl<D> Delta<D> where D: MyTrait {\n \n pub struct Echo<E>(E);\n \n+// @has 'foo/struct.Simd.html'\n+// @snapshot SWhere_Simd_item-decl - '//div[@class=\"docblock item-decl\"]'\n+pub struct Simd<T>([T; 1])\n+where\n+    T: MyTrait;\n+\n+// @has 'foo/trait.TraitWhere.html'\n+// @snapshot SWhere_TraitWhere_item-decl - '//div[@class=\"docblock item-decl\"]'\n+pub trait TraitWhere {\n+    type Item<'a> where Self: 'a;\n+}\n+\n // @has foo/struct.Echo.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n //          \"impl<E> MyTrait for Echo<E> where E: MyTrait\"\n // @has foo/trait.MyTrait.html '//*[@id=\"implementors-list\"]//h3[@class=\"code-header in-band\"]' \\"}, {"sha": "272372ebedc1d01c5f716badcc5c7a6b2c08dffd", "filename": "src/test/ui/asm/x86_64/bad-reg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -29,13 +29,13 @@ fn main() {\n         //~^ ERROR invalid register `rsp`: the stack pointer cannot be used as an operand\n         asm!(\"\", in(\"ip\") foo);\n         //~^ ERROR invalid register `ip`: the instruction pointer cannot be used as an operand\n-        asm!(\"\", in(\"k0\") foo);\n-        //~^ ERROR invalid register `k0`: the k0 AVX mask register cannot be used as an operand\n \n         asm!(\"\", in(\"st(2)\") foo);\n         //~^ ERROR register class `x87_reg` can only be used as a clobber, not as an input or output\n         asm!(\"\", in(\"mm0\") foo);\n         //~^ ERROR register class `mmx_reg` can only be used as a clobber, not as an input or output\n+        asm!(\"\", in(\"k0\") foo);\n+        //~^ ERROR register class `kreg0` can only be used as a clobber, not as an input or output\n         asm!(\"\", out(\"st(2)\") _);\n         asm!(\"\", out(\"mm0\") _);\n         asm!(\"{}\", in(x87_reg) foo);"}, {"sha": "84b8b5ec2850b77d81505c0b3754e3a20d4f2777", "filename": "src/test/ui/asm/x86_64/bad-reg.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2df8baea6fb7199822d39cfcfddb197604aa8a2/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr?ref=a2df8baea6fb7199822d39cfcfddb197604aa8a2", "patch": "@@ -64,24 +64,24 @@ error: invalid register `ip`: the instruction pointer cannot be used as an opera\n LL |         asm!(\"\", in(\"ip\") foo);\n    |                  ^^^^^^^^^^^^\n \n-error: invalid register `k0`: the k0 AVX mask register cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:32:18\n-   |\n-LL |         asm!(\"\", in(\"k0\") foo);\n-   |                  ^^^^^^^^^^^^\n-\n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:35:18\n+  --> $DIR/bad-reg.rs:33:18\n    |\n LL |         asm!(\"\", in(\"st(2)\") foo);\n    |                  ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:37:18\n+  --> $DIR/bad-reg.rs:35:18\n    |\n LL |         asm!(\"\", in(\"mm0\") foo);\n    |                  ^^^^^^^^^^^^^\n \n+error: register class `kreg0` can only be used as a clobber, not as an input or output\n+  --> $DIR/bad-reg.rs:37:18\n+   |\n+LL |         asm!(\"\", in(\"k0\") foo);\n+   |                  ^^^^^^^^^^^^\n+\n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n   --> $DIR/bad-reg.rs:41:20\n    |"}]}