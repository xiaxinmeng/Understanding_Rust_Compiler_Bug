{"sha": "25f953437d2bc3983b03c0d17cf56de40acec45b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1Zjk1MzQzN2QyYmMzOTgzYjAzYzBkMTdjZjU2ZGU0MGFjZWM0NWI=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-06-02T20:03:35Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-10-29T16:09:20Z"}, "message": "Lint non-FFI-safe enums.", "tree": {"sha": "c3b78ef0075e8ca72343fa3e7b90baa47d683ff0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3b78ef0075e8ca72343fa3e7b90baa47d683ff0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25f953437d2bc3983b03c0d17cf56de40acec45b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25f953437d2bc3983b03c0d17cf56de40acec45b", "html_url": "https://github.com/rust-lang/rust/commit/25f953437d2bc3983b03c0d17cf56de40acec45b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25f953437d2bc3983b03c0d17cf56de40acec45b/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0", "html_url": "https://github.com/rust-lang/rust/commit/01740acd5ab243e7b8c0e1e076ed56edcb9bf4d0"}], "stats": {"total": 97, "additions": 80, "deletions": 17}, "files": [{"sha": "e8f9dad65851beab32e35424518e4cedc13c323d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25f953437d2bc3983b03c0d17cf56de40acec45b/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f953437d2bc3983b03c0d17cf56de40acec45b/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=25f953437d2bc3983b03c0d17cf56de40acec45b", "patch": "@@ -34,6 +34,7 @@\n //! Context itself, span_lint should be used instead of add_lint.\n \n use driver::session;\n+use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::ty;\n use middle::pat_util;\n use metadata::csearch;\n@@ -627,6 +628,14 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n                                 \"found rust type `uint` in foreign module, while \\\n                                 libc::c_uint or libc::c_ulong should be used\");\n                     }\n+                    ast::DefTy(def_id) => {\n+                        if !adt::is_ffi_safe(cx.tcx, def_id) {\n+                            cx.span_lint(ctypes, ty.span,\n+                                         \"found enum type without foreign-function-safe \\\n+                                          representation annotation in foreign module\");\n+                            // NOTE this message could be more helpful\n+                        }\n+                    }\n                     _ => ()\n                 }\n             }"}, {"sha": "10b7655ae456645ef0b8d70e8dc60b3fdbac2ca7", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/25f953437d2bc3983b03c0d17cf56de40acec45b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f953437d2bc3983b03c0d17cf56de40acec45b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=25f953437d2bc3983b03c0d17cf56de40acec45b", "patch": "@@ -145,22 +145,8 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n-            struct Case { discr: Disr, tys: ~[ty::t] };\n-            impl Case {\n-                fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n-                    mk_struct(cx, self.tys, false).size == 0\n-                }\n-                fn find_ptr(&self) -> Option<uint> {\n-                    self.tys.iter().position(|&ty| mono_data_classify(ty) == MonoNonNull)\n-                }\n-            }\n-\n-            let cases = do ty::enum_variants(cx.tcx, def_id).map |vi| {\n-                let arg_tys = do vi.args.map |&raw_ty| {\n-                    ty::subst(cx.tcx, substs, raw_ty)\n-                };\n-                Case { discr: vi.disr_val, tys: arg_tys }\n-            };\n+            let cases = get_cases(cx.tcx, def_id, substs);\n+            let hint = ty::lookup_repr_hint(cx.tcx, def_id);\n \n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n@@ -170,7 +156,6 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             if cases.iter().all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n-                let hint = ty::lookup_repr_hint(cx.tcx, def_id);\n                 let bounds = IntBounds {\n                     ulo: *discrs.iter().min().unwrap(),\n                     uhi: *discrs.iter().max().unwrap(),\n@@ -232,6 +217,56 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n     }\n }\n \n+/// Determine, without doing translation, whether an ADT must be FFI-safe.\n+/// For use in lint or similar, where being sound but slightly incomplete is acceptable.\n+pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n+    match ty::get(ty::lookup_item_type(tcx, def_id).ty).sty {\n+        ty::ty_enum(def_id, ref substs) => {\n+            let cases = get_cases(tcx, def_id, substs);\n+            // Univariant => like struct/tuple.\n+            if cases.len() <= 2 {\n+                return true;\n+            }\n+            let hint = ty::lookup_repr_hint(tcx, def_id);\n+            // Appropriate representation explicitly selected?\n+            if hint.is_ffi_safe() {\n+                return true;\n+            }\n+            // Conservative approximation of nullable pointers, for Option<~T> etc.\n+            if cases.len() == 2 && hint == attr::ReprAny &&\n+                (cases[0].tys.is_empty() && cases[1].find_ptr().is_some() ||\n+                 cases[1].tys.is_empty() && cases[0].find_ptr().is_some()) {\n+                return true;\n+            }\n+            false\n+        }\n+        // struct, tuple, etc.\n+        // (is this right in the present of typedefs?)\n+        _ => true\n+    }\n+}\n+\n+// NOTE this should probably all be in ty\n+struct Case { discr: Disr, tys: ~[ty::t] }\n+impl Case {\n+    fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n+        mk_struct(cx, self.tys, false).size == 0\n+    }\n+    fn find_ptr(&self) -> Option<uint> {\n+        self.tys.iter().position(|&ty| mono_data_classify(ty) == MonoNonNull)\n+    }\n+}\n+\n+fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> ~[Case] {\n+    do ty::enum_variants(tcx, def_id).map |vi| {\n+        let arg_tys = do vi.args.map |&raw_ty| {\n+            ty::subst(tcx, substs, raw_ty)\n+        };\n+        Case { discr: vi.disr_val, tys: arg_tys }\n+    }\n+}\n+\n+\n fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n     let llty_rec = Type::struct_(lltys, packed);"}, {"sha": "222ca61a7910b362490c4943947c57397a845fa5", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/25f953437d2bc3983b03c0d17cf56de40acec45b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f953437d2bc3983b03c0d17cf56de40acec45b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=25f953437d2bc3983b03c0d17cf56de40acec45b", "patch": "@@ -442,6 +442,16 @@ pub enum ReprAttr {\n     ReprExtern\n }\n \n+impl ReprAttr {\n+    pub fn is_ffi_safe(&self) -> bool {\n+        match *self {\n+            ReprAny => false,\n+            ReprInt(_sp, ity) => ity.is_ffi_safe(),\n+            ReprExtern => true\n+        }\n+    }\n+}\n+\n #[deriving(Eq)]\n pub enum IntType {\n     SignedInt(ast::int_ty),\n@@ -456,4 +466,13 @@ impl IntType {\n             UnsignedInt(*) => false\n         }\n     }\n+    fn is_ffi_safe(self) -> bool {\n+        match self {\n+            SignedInt(ast::ty_i8) | UnsignedInt(ast::ty_u8) |\n+            SignedInt(ast::ty_i16) | UnsignedInt(ast::ty_u16) |\n+            SignedInt(ast::ty_i32) | UnsignedInt(ast::ty_u32) |\n+            SignedInt(ast::ty_i64) | UnsignedInt(ast::ty_u64) => true,\n+            _ => false\n+        }\n+    }\n }"}]}