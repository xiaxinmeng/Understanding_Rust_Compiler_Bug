{"sha": "22cd041ba0747e680e3faea7b6db2bbd40b41198", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyY2QwNDFiYTA3NDdlNjgwZTNmYWVhN2I2ZGIyYmJkNDBiNDExOTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-03T09:31:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-15T21:49:21Z"}, "message": "move the `region_obligations` processing code into `InferCtxt`", "tree": {"sha": "bdb13d85d5e4728bba8f807470f7a182d0223401", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdb13d85d5e4728bba8f807470f7a182d0223401"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22cd041ba0747e680e3faea7b6db2bbd40b41198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22cd041ba0747e680e3faea7b6db2bbd40b41198", "html_url": "https://github.com/rust-lang/rust/commit/22cd041ba0747e680e3faea7b6db2bbd40b41198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22cd041ba0747e680e3faea7b6db2bbd40b41198/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d73be851fbcaa2887d390192c6774b3792411c9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d73be851fbcaa2887d390192c6774b3792411c9f", "html_url": "https://github.com/rust-lang/rust/commit/d73be851fbcaa2887d390192c6774b3792411c9f"}], "stats": {"total": 326, "additions": 236, "deletions": 90}, "files": [{"sha": "41e1bf303b38457fb08b3c5a14ff6d4b1d2bcf7d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=22cd041ba0747e680e3faea7b6db2bbd40b41198", "patch": "@@ -55,6 +55,7 @@ mod higher_ranked;\n pub mod lattice;\n mod lub;\n pub mod region_inference;\n+mod region_obligations;\n pub mod resolve;\n mod freshen;\n mod sub;\n@@ -160,6 +161,13 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // regionck to be sure that it has found *all* the region\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n+    //\n+    // Before running `resolve_regions_and_report_errors`, the creator\n+    // of the inference context is expected to invoke\n+    // `process_region_obligations` (defined in `self::region_obligations`)\n+    // for each body-id in this map, which will process the\n+    // obligations within. This is expected to be done 'late enough'\n+    // that all type inference variables have been bound and so forth.\n     region_obligations: RefCell<NodeMap<Vec<RegionObligation<'tcx>>>>,\n }\n \n@@ -984,33 +992,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    /// Registers that the given region obligation must be resolved\n-    /// from within the scope of `body_id`. These regions are enqueued\n-    /// and later processed by regionck, when full type information is\n-    /// available (see `region_obligations` field for more\n-    /// information).\n-    pub fn register_region_obligation(&self,\n-                                      body_id: ast::NodeId,\n-                                      obligation: RegionObligation<'tcx>)\n-    {\n-        self.region_obligations.borrow_mut().entry(body_id)\n-                                            .or_insert(vec![])\n-                                            .push(obligation);\n-    }\n-\n-    /// Get the region obligations that must be proven (during\n-    /// `regionck`) for the given `body_id` (removing them from the\n-    /// map as a side-effect).\n-    pub fn take_region_obligations(&self,\n-                                   body_id: ast::NodeId)\n-                                   -> Vec<RegionObligation<'tcx>>\n-    {\n-        match self.region_obligations.borrow_mut().remove(&body_id) {\n-            None => vec![],\n-            Some(vec) => vec,\n-        }\n-    }\n-\n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()"}, {"sha": "edcabd531814291126bb9257cd4773c8abe4deec", "filename": "src/librustc/infer/region_obligations.rs", "status": "renamed", "additions": 203, "deletions": 29, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc%2Finfer%2Fregion_obligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc%2Finfer%2Fregion_obligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_obligations.rs?ref=22cd041ba0747e680e3faea7b6db2bbd40b41198", "patch": "@@ -1,27 +1,210 @@\n-//! Temporary holding spot for some code I want to factor out.\n-\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode, PredicateObligations};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::infer::{self, GenericKind, InferCtxt, InferOk, VerifyBound};\n-use rustc::ty::subst::Subst;\n-use rustc::ty::outlives::Component;\n+//! Code that handles \"type-outlives\" constraints like `T: 'a`. This\n+//! is based on the `outlives_components` function defined on the tcx,\n+//! but it adds a bit of heuristics on top, in particular to deal with\n+//! associated types and projections.\n+//!\n+//! When we process a given `T: 'a` obligation, we may produce two\n+//! kinds of constraints for the region inferencer:\n+//!\n+//! - Relationships between inference variables and other regions.\n+//!   For example, if we have `&'?0 u32: 'a`, then we would produce\n+//!   a constraint that `'a <= '?0`.\n+//! - \"Verifys\" that must be checked after inferencing is done.\n+//!   For example, if we know that, for some type parameter `T`,\n+//!   `T: 'a + 'b`, and we have a requirement that `T: '?1`,\n+//!   then we add a \"verify\" that checks that `'?1 <= 'a || '?1 <= 'b`.\n+//!   - Note the difference with the previous case: here, the region\n+//!     variable must be less than something else, so this doesn't\n+//!     affect how inference works (it finds the smallest region that\n+//!     will do); it's just a post-condition that we have to check.\n+//!\n+//! **The key point is that once this function is done, we have\n+//! reduced all of our \"type-region outlives\" obligations into relationships\n+//! between individual regions.**\n+//!\n+//! One key input to this function is the set of \"region-bound pairs\".\n+//! These are basically the relationships between type parameters and\n+//! regions that are in scope at the point where the outlives\n+//! obligation was incurred. **When type-checking a function,\n+//! particularly in the face of closures, this is not known until\n+//! regionck runs!** This is because some of those bounds come\n+//! from things we have yet to infer.\n+//!\n+//! Consider:\n+//!\n+//! ```\n+//! fn bar<T>(a: T, b: impl for<'a> Fn(&'a T));\n+//! fn foo<T>(x: T) {\n+//!     bar(x, |y| { ... })\n+//!          // ^ closure arg\n+//! }\n+//! ```\n+//!\n+//! Here, the type of `y` may involve inference variables and the\n+//! like, and it may also contain implied bounds that are needed to\n+//! type-check the closure body (e.g., here it informs us that `T`\n+//! outlives the late-bound region `'a`).\n+//!\n+//! > That said, in writing this, I have come to wonder: this\n+//!   inference dependency, I think, is only interesting for\n+//!   late-bound regions in the closure -- if the region appears free\n+//!   in the closure signature, then the relationship must be known to\n+//!   the caller (here, `foo`), and hence could be verified earlier\n+//!   up. Moreover, we infer late-bound regions quite early on right\n+//!   now, i.e., only when the expected signature is known.  So we\n+//!   *may* be able to sidestep this. Regardless, once the NLL\n+//!   transition is complete, this concern will be gone. -nmatsakis\n+\n+use infer::{self, GenericKind, InferCtxt, InferOk, RegionObligation, SubregionOrigin, VerifyBound};\n+use traits::{self, ObligationCause, ObligationCauseCode, PredicateObligations};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::subst::Subst;\n+use ty::outlives::Component;\n use syntax::ast;\n use syntax_pos::Span;\n \n-pub struct RegionckOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    // Context provided by the caller:\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Registers that the given region obligation must be resolved\n+    /// from within the scope of `body_id`. These regions are enqueued\n+    /// and later processed by regionck, when full type information is\n+    /// available (see `region_obligations` field for more\n+    /// information).\n+    pub fn register_region_obligation(\n+        &self,\n+        body_id: ast::NodeId,\n+        obligation: RegionObligation<'tcx>,\n+    ) {\n+        self.region_obligations\n+            .borrow_mut()\n+            .entry(body_id)\n+            .or_insert(vec![])\n+            .push(obligation);\n+    }\n+\n+    /// Process the region obligations that must be proven (during\n+    /// `regionck`) for the given `body_id`, given information about\n+    /// the region bounds in scope and so forth. This function must be\n+    /// invoked for all relevant body-ids before region inference is\n+    /// done (or else an assert will fire).\n+    ///\n+    /// See the `region_obligations` field of `InferCtxt` for some\n+    /// comments about how this funtion fits into the overall expected\n+    /// flow of the the inferencer. The key point is that it is\n+    /// invoked after all type-inference variables have been bound --\n+    /// towards the end of regionck. This also ensures that the\n+    /// region-bound-pairs are available (see comments above regarding\n+    /// closures).\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `region_bound_pairs`: the set of region bounds implied by\n+    ///   the parameters and where-clauses. In particular, each pair\n+    ///   `('a, K)` in this list tells us that the bounds in scope\n+    ///   indicate that `K: 'a`, where `K` is either a generic\n+    ///   parameter like `T` or a projection like `T::Item`.\n+    /// - `implicit_region_bound`: if some, this is a region bound\n+    ///   that is considered to hold for all type parameters (the\n+    ///   function body).\n+    /// - `param_env` is the parameter environment for the enclosing function.\n+    /// - `body_id` is the body-id whose region obligations are being\n+    ///   processed.\n+    ///\n+    /// # Returns\n+    ///\n+    /// This function may have to perform normalizations, and hence it\n+    /// returns an `InferOk` with subobligations that must be\n+    /// processed.\n+    pub fn process_registered_region_obligations(\n+        &self,\n+        region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: ast::NodeId,\n+    ) -> InferOk<'tcx, ()> {\n+        let region_obligations = match self.region_obligations.borrow_mut().remove(&body_id) {\n+            None => vec![],\n+            Some(vec) => vec,\n+        };\n+\n+        let mut outlives = TypeOutlives::new(\n+            self,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+            body_id,\n+        );\n+\n+        for RegionObligation {\n+            sup_type,\n+            sub_region,\n+            cause,\n+        } in region_obligations\n+        {\n+            let origin = SubregionOrigin::from_obligation_cause(\n+                &cause,\n+                || infer::RelateParamBound(cause.span, sup_type),\n+            );\n+\n+            outlives.type_must_outlive(origin, sup_type, sub_region);\n+        }\n+\n+        InferOk {\n+            value: (),\n+            obligations: outlives.into_accrued_obligations(),\n+        }\n+    }\n+\n+    /// Processes a single ad-hoc region obligation that was not\n+    /// registered in advance.\n+    pub fn type_must_outlive(\n+        &self,\n+        region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: ast::NodeId,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) -> InferOk<'tcx, ()> {\n+        let mut outlives = TypeOutlives::new(\n+            self,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+            body_id,\n+        );\n+        outlives.type_must_outlive(origin, ty, region);\n+        InferOk {\n+            value: (),\n+            obligations: outlives.into_accrued_obligations(),\n+        }\n+    }\n+\n+    /// Ignore the region obligations for a given `body_id`, not bothering to\n+    /// prove them. This function should not really exist; it is used to accommodate some older\n+    /// code for the time being.\n+    pub fn ignore_region_obligations(&self, body_id: ast::NodeId) {\n+        self.region_obligations.borrow_mut().remove(&body_id);\n+    }\n+}\n+\n+#[must_use] // you ought to invoke `into_accrued_obligations` when you are done =)\n+struct TypeOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    // See the comments on `process_registered_region_obligations` for the meaning\n+    // of these fields.\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: ast::NodeId,\n \n-    // Obligations that we accrue as we go:\n+    /// These are sub-obligations that we accrue as we go; they result\n+    /// from any normalizations we had to do.\n     obligations: PredicateObligations<'tcx>,\n }\n \n-impl<'cx, 'gcx, 'tcx> RegionckOutlives<'cx, 'gcx, 'tcx> {\n-    pub fn new(\n+impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n+    fn new(\n         infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n         region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -38,6 +221,12 @@ impl<'cx, 'gcx, 'tcx> RegionckOutlives<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Returns the obligations that accrued as a result of the\n+    /// `type_must_outlive` calls.\n+    fn into_accrued_obligations(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+\n     /// Adds constraints to inference such that `T: 'a` holds (or\n     /// reports an error if it cannot).\n     ///\n@@ -46,22 +235,7 @@ impl<'cx, 'gcx, 'tcx> RegionckOutlives<'cx, 'gcx, 'tcx> {\n     /// - `origin`, the reason we need this constraint\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n-    pub fn type_must_outlive(\n-        mut self,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        ty: Ty<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) -> InferOk<'tcx, ()> {\n-        self.type_must_outlive_pushing_obligations(origin, ty, region);\n-        InferOk {\n-            value: (),\n-            obligations: self.obligations,\n-        }\n-    }\n-\n-    /// Internal helper: ensure that `ty_must_outlive` and push obligations onto\n-    /// our internal vector.\n-    fn type_must_outlive_pushing_obligations(\n+    fn type_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n@@ -199,7 +373,7 @@ impl<'cx, 'gcx, 'tcx> RegionckOutlives<'cx, 'gcx, 'tcx> {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n             for component_ty in projection_ty.substs.types() {\n-                self.type_must_outlive_pushing_obligations(origin.clone(), component_ty, region);\n+                self.type_must_outlive(origin.clone(), component_ty, region);\n             }\n \n             for r in projection_ty.substs.regions() {", "previous_filename": "src/librustc_typeck/check/regionck_outlives.rs"}, {"sha": "0489a316cb3e8c27f7e4e6f55f5abb198345b9b1", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=22cd041ba0747e680e3faea7b6db2bbd40b41198", "patch": "@@ -543,7 +543,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // it, and it would take some refactoring to stop doing so.\n         // (In particular, the needed methods currently live in\n         // regionck.) -nmatsakis\n-        let _ = infcx.take_region_obligations(body_id);\n+        let _ = infcx.ignore_region_obligations(body_id);\n \n         infcx.resolve_regions_and_report_errors(region_context, &region_scope_tree, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {"}, {"sha": "c8b2032a49871510fc973b0ff9ca546d31dc395c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=22cd041ba0747e680e3faea7b6db2bbd40b41198", "patch": "@@ -137,7 +137,6 @@ pub mod dropck;\n pub mod _match;\n pub mod writeback;\n mod regionck;\n-mod regionck_outlives;\n pub mod coercion;\n pub mod demand;\n pub mod method;"}, {"sha": "20487dda20190d9d17df6b74fb88df1f08050ba4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22cd041ba0747e680e3faea7b6db2bbd40b41198/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=22cd041ba0747e680e3faea7b6db2bbd40b41198", "patch": "@@ -90,9 +90,8 @@ use middle::mem_categorization::Categorization;\n use middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n-use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::infer::{self, GenericKind, SubregionOrigin};\n+use rustc::infer::{self, InferOk, GenericKind};\n use rustc::ty::adjustment;\n use rustc::ty::outlives::Component;\n use rustc::ty::wf;\n@@ -105,8 +104,6 @@ use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, PatKind};\n \n-use super::regionck_outlives::RegionckOutlives;\n-\n // a variation on try that just returns unit\n macro_rules! ignore_err {\n     ($e:expr) => (match $e { Ok(e) => e, Err(_) => return () })\n@@ -360,28 +357,21 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // obligations. So make sure we process those.\n         self.select_all_obligations_or_error();\n \n-        // Make a copy of the region obligations vec because we'll need\n-        // to be able to borrow the fulfillment-cx below when projecting.\n-        let region_obligations = self.infcx.take_region_obligations(node_id);\n-\n-        for r_o in &region_obligations {\n-            debug!(\"visit_region_obligations: r_o={:?} cause={:?}\",\n-                   r_o, r_o.cause);\n-            let sup_type = self.resolve_type(r_o.sup_type);\n-            let origin = self.code_to_origin(&r_o.cause, sup_type);\n-            self.type_must_outlive(origin, sup_type, r_o.sub_region);\n-        }\n-\n-        // Processing the region obligations should not cause the list to grow further:\n-        assert!(self.infcx.take_region_obligations(node_id).is_empty());\n-    }\n-\n-    fn code_to_origin(&self,\n-                      cause: &traits::ObligationCause<'tcx>,\n-                      sup_type: Ty<'tcx>)\n-                      -> SubregionOrigin<'tcx> {\n-        SubregionOrigin::from_obligation_cause(cause,\n-                                               || infer::RelateParamBound(cause.span, sup_type))\n+        let InferOk { value: (), obligations }  =\n+            self.infcx.process_registered_region_obligations(\n+                &self.region_bound_pairs,\n+                self.implicit_region_bound,\n+                self.param_env,\n+                self.body_id);\n+\n+        // TODO -- It feels like we ought to loop here; these new\n+        // obligations, when selected, could cause the list of region\n+        // obligations to grow further. Fortunately, I believe that if\n+        // that happens it will at least lead to an ICE today, because\n+        // `resolve_regions_and_report_errors` (which runs after *all*\n+        // obligations have been selected) will assert that there are\n+        // no unsolved region obligations.\n+        self.register_predicates(obligations);\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n@@ -1147,12 +1137,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                              ty: Ty<'tcx>,\n                              region: ty::Region<'tcx>)\n     {\n-        let outlives = RegionckOutlives::new(&self.infcx,\n-                                             &self.region_bound_pairs,\n-                                             self.implicit_region_bound,\n-                                             self.param_env,\n-                                             self.body_id);\n-        self.register_infer_ok_obligations(outlives.type_must_outlive(origin, ty, region));\n+        let infer_ok = self.infcx.type_must_outlive(&self.region_bound_pairs,\n+                                                    self.implicit_region_bound,\n+                                                    self.param_env,\n+                                                    self.body_id,\n+                                                    origin,\n+                                                    ty,\n+                                                    region);\n+        self.register_infer_ok_obligations(infer_ok)\n     }\n \n     /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the"}]}