{"sha": "8b38b6859a5395520e4f466133db4ec4bfd0317d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMzhiNjg1OWE1Mzk1NTIwZTRmNDY2MTMzZGI0ZWM0YmZkMDMxN2Q=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-20T14:22:53Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Inline the constructor-specific `split` functions", "tree": {"sha": "cb99b95a8f2b53772ae7a3ca86665d414a8eded6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb99b95a8f2b53772ae7a3ca86665d414a8eded6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b38b6859a5395520e4f466133db4ec4bfd0317d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b38b6859a5395520e4f466133db4ec4bfd0317d", "html_url": "https://github.com/rust-lang/rust/commit/8b38b6859a5395520e4f466133db4ec4bfd0317d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b38b6859a5395520e4f466133db4ec4bfd0317d/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3141f2d78c446b35930d4a73273578e6c6b488f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3141f2d78c446b35930d4a73273578e6c6b488f5", "html_url": "https://github.com/rust-lang/rust/commit/3141f2d78c446b35930d4a73273578e6c6b488f5"}], "stats": {"total": 53, "additions": 19, "deletions": 34}, "files": [{"sha": "060e4fdf6f817f5c5818549b36114aca24b75ff6", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8b38b6859a5395520e4f466133db4ec4bfd0317d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b38b6859a5395520e4f466133db4ec4bfd0317d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=8b38b6859a5395520e4f466133db4ec4bfd0317d", "patch": "@@ -183,14 +183,6 @@ impl IntRange {\n         Pat { ty, span: DUMMY_SP, kind: Box::new(kind) }\n     }\n \n-    /// Split this range, as described at the top of the file.\n-    fn split<'p, 'tcx>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n-        let mut split_range = SplitIntRange::new(self.clone());\n-        let intranges = pcx.matrix.head_ctors(pcx.cx).filter_map(|ctor| ctor.as_int_range());\n-        split_range.split(intranges.cloned());\n-        split_range.iter().map(IntRange).collect()\n-    }\n-\n     /// Lint on likely incorrect range patterns (#63987)\n     pub(super) fn lint_overlapping_range_endpoints(&self, pcx: PatCtxt<'_, '_, '_>, hir_id: HirId) {\n         if self.is_singleton() {\n@@ -403,19 +395,6 @@ impl Slice {\n         self.kind.arity()\n     }\n \n-    /// Split this slice, as described at the top of the file.\n-    fn split<'p, 'tcx>(self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n-        let (self_prefix, self_suffix) = match self.kind {\n-            VarLen(self_prefix, self_suffix) => (self_prefix, self_suffix),\n-            _ => return smallvec![Slice(self)],\n-        };\n-\n-        let mut split_self = SplitVarLenSlice::new(self_prefix, self_suffix, self.array_len);\n-        let slices = pcx.matrix.head_ctors(pcx.cx).filter_map(|c| c.as_slice()).map(|s| s.kind);\n-        split_self.split(slices);\n-        split_self.iter().map(Slice).collect()\n-    }\n-\n     /// See `Constructor::is_covered_by`\n     fn is_covered_by(self, other: Self) -> bool {\n         other.kind.covers_length(self.arity())\n@@ -680,26 +659,32 @@ impl<'tcx> Constructor<'tcx> {\n         debug!(\"Constructor::split({:#?}, {:#?})\", self, pcx.matrix);\n \n         match self {\n-            Wildcard => Constructor::split_wildcard(pcx),\n+            Wildcard => {\n+                let mut split_wildcard = SplitWildcard::new(pcx);\n+                split_wildcard.split(pcx);\n+                split_wildcard.into_ctors(pcx)\n+            }\n             // Fast-track if the range is trivial. In particular, we don't do the overlapping\n             // ranges check.\n-            IntRange(ctor_range) if !ctor_range.is_singleton() => ctor_range.split(pcx),\n-            Slice(slice @ Slice { kind: VarLen(..), .. }) => slice.split(pcx),\n+            IntRange(ctor_range) if !ctor_range.is_singleton() => {\n+                let mut split_range = SplitIntRange::new(ctor_range.clone());\n+                let intranges =\n+                    pcx.matrix.head_ctors(pcx.cx).filter_map(|ctor| ctor.as_int_range());\n+                split_range.split(intranges.cloned());\n+                split_range.iter().map(IntRange).collect()\n+            }\n+            &Slice(Slice { kind: VarLen(self_prefix, self_suffix), array_len }) => {\n+                let mut split_self = SplitVarLenSlice::new(self_prefix, self_suffix, array_len);\n+                let slices =\n+                    pcx.matrix.head_ctors(pcx.cx).filter_map(|c| c.as_slice()).map(|s| s.kind);\n+                split_self.split(slices);\n+                split_self.iter().map(Slice).collect()\n+            }\n             // Any other constructor can be used unchanged.\n             _ => smallvec![self.clone()],\n         }\n     }\n \n-    /// For wildcards, there are two groups of constructors: there are the constructors actually\n-    /// present in the matrix (`head_ctors`), and the constructors not present (`missing_ctors`).\n-    /// Two constructors that are not in the matrix will either both be caught (by a wildcard), or\n-    /// both not be caught. Therefore we can keep the missing constructors grouped together.\n-    fn split_wildcard<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Self; 1]> {\n-        let mut split_wildcard = SplitWildcard::new(pcx);\n-        split_wildcard.split(pcx);\n-        split_wildcard.into_ctors(pcx)\n-    }\n-\n     /// Returns whether `self` is covered by `other`, i.e. whether `self` is a subset of `other`.\n     /// For the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n     /// this checks for inclusion."}]}