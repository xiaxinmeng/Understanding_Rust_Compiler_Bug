{"sha": "b2ddd937b20d8fc26132cb7ec665784422d92926", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZGRkOTM3YjIwZDhmYzI2MTMyY2I3ZWM2NjU3ODQ0MjJkOTI5MjY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-30T10:30:50Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-30T10:30:50Z"}, "message": "Merge branch 'master' into mulit-decor", "tree": {"sha": "cf257df60ded1b45616d797b8feb71178cab0142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf257df60ded1b45616d797b8feb71178cab0142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2ddd937b20d8fc26132cb7ec665784422d92926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ddd937b20d8fc26132cb7ec665784422d92926", "html_url": "https://github.com/rust-lang/rust/commit/b2ddd937b20d8fc26132cb7ec665784422d92926", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2ddd937b20d8fc26132cb7ec665784422d92926/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0a42aecbc85298fb6351253c4cd1824567b7a42", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a42aecbc85298fb6351253c4cd1824567b7a42", "html_url": "https://github.com/rust-lang/rust/commit/c0a42aecbc85298fb6351253c4cd1824567b7a42"}, {"sha": "f0bd14f7b15b978f8bf32bb368f63faa0f26c02e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0bd14f7b15b978f8bf32bb368f63faa0f26c02e", "html_url": "https://github.com/rust-lang/rust/commit/f0bd14f7b15b978f8bf32bb368f63faa0f26c02e"}], "stats": {"total": 20985, "additions": 13105, "deletions": 7880}, "files": [{"sha": "dbca73415fec62d11ef151ff41d2592d19d981a8", "filename": "configure", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/configure", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -551,6 +551,7 @@ opt valgrind-rpass 1 \"run rpass-valgrind tests with valgrind\"\n opt docs     1 \"build standard library documentation\"\n opt compiler-docs     0 \"build compiler documentation\"\n opt optimize-tests 1 \"build tests with optimizations\"\n+opt debuginfo-tests 0 \"build tests with debugger metadata\"\n opt libcpp 1 \"build with llvm with libc++ instead of libstdc++ when using clang\"\n opt llvm-assertions 0 \"build LLVM with assertions\"\n opt debug-assertions 0 \"build with debugging assertions\"\n@@ -583,6 +584,7 @@ valopt jemalloc-root \"\" \"set directory where libjemalloc_pic.a is located\"\n valopt build \"${DEFAULT_BUILD}\" \"GNUs ./configure syntax LLVM build triple\"\n valopt android-cross-path \"/opt/ndk_standalone\" \"Android NDK standalone path\"\n valopt release-channel \"dev\" \"the name of the release channel to build\"\n+valopt musl-root \"/usr/local\" \"MUSL root installation directory\"\n \n # Many of these are saved below during the \"writing configuration\" step\n # (others are conditionally saved).\n@@ -659,9 +661,10 @@ if [ -n \"$CFG_ENABLE_DEBUG\" ]; then\n         CFG_DISABLE_OPTIMIZE=1\n         CFG_DISABLE_OPTIMIZE_CXX=1\n     fi\n-    CFG_ENABLE_LLVM_ASSERTIONS=1\n     CFG_ENABLE_DEBUG_ASSERTIONS=1\n     CFG_ENABLE_DEBUG_JEMALLOC=1\n+    CFG_ENABLE_DEBUGINFO=1\n+    CFG_ENABLE_LLVM_ASSERTIONS=1\n fi\n \n # OK, now write the debugging options\n@@ -1057,6 +1060,13 @@ do\n             fi\n             ;;\n \n+\n+        *-musl)\n+            if [ ! -f $CFG_MUSL_ROOT/lib/libc.a ]\n+            then\n+                err \"musl libc $CFG_MUSL_ROOT/lib/libc.a not found\"\n+            fi\n+            ;;\n         *)\n             ;;\n     esac\n@@ -1143,6 +1153,7 @@ do\n     make_dir $h/test/run-pass-valgrind\n     make_dir $h/test/run-pass-fulldeps\n     make_dir $h/test/run-fail\n+    make_dir $h/test/run-fail-fulldeps\n     make_dir $h/test/compile-fail\n     make_dir $h/test/parse-fail\n     make_dir $h/test/compile-fail-fulldeps"}, {"sha": "7767129a5e21821e60e477205e0ec446b15b3237", "filename": "mk/cfg/aarch64-apple-ios.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Faarch64-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Faarch64-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-apple-ios.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -20,16 +20,12 @@ CFG_GCCISH_CFLAGS_aarch64-apple-ios := -Wall -Werror -fPIC $(CFG_IOS_SDK_FLAGS_a\n CFG_GCCISH_CXXFLAGS_aarch64-apple-ios := -fno-rtti $(CFG_IOS_SDK_FLAGS_aarch64-apple-ios) -I$(CFG_IOS_SDK_aarch64-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_aarch64-apple-ios := -lpthread -syslibroot $(CFG_IOS_SDK_aarch64-apple-ios) -Wl,-no_compact_unwind\n CFG_GCCISH_DEF_FLAG_aarch64-apple-ios := -Wl,-exported_symbols_list,\n-CFG_GCCISH_PRE_LIB_FLAGS_aarch64-apple-ios :=\n-CFG_GCCISH_POST_LIB_FLAGS_aarch64-apple-ios :=\n-CFG_DEF_SUFFIX_aarch64-apple-ios := .darwin.def\n CFG_LLC_FLAGS_aarch64-apple-ios := -mattr=+neon,+cyclone,+fp-armv8\n CFG_INSTALL_NAME_aarch64-apple-ios = -Wl,-install_name,@rpath/$(1)\n CFG_LIBUV_LINK_FLAGS_aarch64-apple-ios =\n CFG_EXE_SUFFIX_aarch64-apple-ios :=\n CFG_WINDOWSY_aarch64-apple-ios :=\n CFG_UNIXY_aarch64-apple-ios := 1\n-CFG_PATH_MUNGE_aarch64-apple-ios := true\n CFG_LDPATH_aarch64-apple-ios :=\n CFG_RUN_aarch64-apple-ios = $(2)\n CFG_RUN_TARG_aarch64-apple-ios = $(call CFG_RUN_aarch64-apple-ios,,$(2))"}, {"sha": "d7a1405c3d0a87036bf199887ee3fea99f6c4497", "filename": "mk/cfg/aarch64-linux-android.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Faarch64-linux-android.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Faarch64-linux-android.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-linux-android.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,15 +13,11 @@ CFG_GCCISH_CFLAGS_aarch64-linux-android := -Wall -g -fPIC -D__aarch64__ -DANDROI\n CFG_GCCISH_CXXFLAGS_aarch64-linux-android := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_aarch64-linux-android := -shared -fPIC -ldl -g -lm -lsupc++\n CFG_GCCISH_DEF_FLAG_aarch64-linux-android := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_aarch64-linux-android := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_aarch64-linux-android := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_aarch64-linux-android := .android.def\n CFG_LLC_FLAGS_aarch64-linux-android :=\n CFG_INSTALL_NAME_aarch64-linux-android =\n CFG_EXE_SUFFIX_aarch64-linux-android :=\n CFG_WINDOWSY_aarch64-linux-android :=\n CFG_UNIXY_aarch64-linux-android := 1\n-CFG_PATH_MUNGE_aarch64-linux-android := true\n CFG_LDPATH_aarch64-linux-android :=\n CFG_RUN_aarch64-linux-android=\n CFG_RUN_TARG_aarch64-linux-android="}, {"sha": "6637423e4951a9826c7b3004d1c939a4713cad47", "filename": "mk/cfg/aarch64-unknown-linux-gnu.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Faarch64-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Faarch64-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-unknown-linux-gnu.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,15 +13,11 @@ CFG_GCCISH_CFLAGS_aarch64-unknown-linux-gnu := -Wall -g -fPIC -D__aarch64__ $(CF\n CFG_GCCISH_CXXFLAGS_aarch64-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_aarch64-unknown-linux-gnu := -shared -fPIC -g\n CFG_GCCISH_DEF_FLAG_aarch64-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_aarch64-unknown-linux-gnu := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_aarch64-unknown-linux-gnu := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_aarch64-unknown-linux-gnu := .linux.def\n CFG_LLC_FLAGS_aarch64-unknown-linux-gnu :=\n CFG_INSTALL_NAME_aarch64-unknown-linux-gnu =\n CFG_EXE_SUFFIX_aarch64-unknown-linux-gnu :=\n CFG_WINDOWSY_aarch64-unknown-linux-gnu :=\n CFG_UNIXY_aarch64-unknown-linux-gnu := 1\n-CFG_PATH_MUNGE_aarch64-unknown-linux-gnu := true\n CFG_LDPATH_aarch64-unknown-linux-gnu :=\n CFG_RUN_aarch64-unknown-linux-gnu=$(2)\n CFG_RUN_TARG_aarch64-unknown-linux-gnu=$(call CFG_RUN_aarch64-unknown-linux-gnu,,$(2))"}, {"sha": "fdd38ba75fe585e02d9491b2a154dcee786eec8b", "filename": "mk/cfg/arm-linux-androideabi.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farm-linux-androideabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farm-linux-androideabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-linux-androideabi.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,15 +12,11 @@ CFG_GCCISH_CFLAGS_arm-linux-androideabi := -Wall -g -fPIC -D__arm__ -DANDROID -D\n CFG_GCCISH_CXXFLAGS_arm-linux-androideabi := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_arm-linux-androideabi := -shared -fPIC -ldl -g -lm -lsupc++\n CFG_GCCISH_DEF_FLAG_arm-linux-androideabi := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_arm-linux-androideabi := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_arm-linux-androideabi := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_arm-linux-androideabi := .android.def\n CFG_LLC_FLAGS_arm-linux-androideabi :=\n CFG_INSTALL_NAME_arm-linux-androideabi =\n CFG_EXE_SUFFIX_arm-linux-androideabi :=\n CFG_WINDOWSY_arm-linux-androideabi :=\n CFG_UNIXY_arm-linux-androideabi := 1\n-CFG_PATH_MUNGE_arm-linux-androideabi := true\n CFG_LDPATH_arm-linux-androideabi :=\n CFG_RUN_arm-linux-androideabi=\n CFG_RUN_TARG_arm-linux-androideabi="}, {"sha": "9a91097458e90fdd101dbafc0d51e777935b78ad", "filename": "mk/cfg/arm-unknown-linux-gnueabi.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farm-unknown-linux-gnueabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farm-unknown-linux-gnueabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabi.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,15 +13,11 @@ CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabi := -Wall -g -fPIC -D__arm__ -mfpu=vf\n CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabi := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabi := -shared -fPIC -g\n CFG_GCCISH_DEF_FLAG_arm-unknown-linux-gnueabi := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_arm-unknown-linux-gnueabi := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_arm-unknown-linux-gnueabi := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_arm-unknown-linux-gnueabi := .linux.def\n CFG_LLC_FLAGS_arm-unknown-linux-gnueabi :=\n CFG_INSTALL_NAME_arm-unknown-linux-gnueabi =\n CFG_EXE_SUFFIX_arm-unknown-linux-gnueabi :=\n CFG_WINDOWSY_arm-unknown-linux-gnueabi :=\n CFG_UNIXY_arm-unknown-linux-gnueabi := 1\n-CFG_PATH_MUNGE_arm-unknown-linux-gnueabi := true\n CFG_LDPATH_arm-unknown-linux-gnueabi :=\n CFG_RUN_arm-unknown-linux-gnueabi=$(2)\n CFG_RUN_TARG_arm-unknown-linux-gnueabi=$(call CFG_RUN_arm-unknown-linux-gnueabi,,$(2))"}, {"sha": "0bd661ea00db22a8b2484b8f98da1bc97e993438", "filename": "mk/cfg/arm-unknown-linux-gnueabihf.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farm-unknown-linux-gnueabihf.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farm-unknown-linux-gnueabihf.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabihf.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,15 +13,11 @@ CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabihf := -Wall -g -fPIC -D__arm__ $(CFLA\n CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabihf := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabihf := -shared -fPIC -g\n CFG_GCCISH_DEF_FLAG_arm-unknown-linux-gnueabihf := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_arm-unknown-linux-gnueabihf := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_arm-unknown-linux-gnueabihf := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_arm-unknown-linux-gnueabihf := .linux.def\n CFG_LLC_FLAGS_arm-unknown-linux-gnueabihf :=\n CFG_INSTALL_NAME_ar,-unknown-linux-gnueabihf =\n CFG_EXE_SUFFIX_arm-unknown-linux-gnueabihf :=\n CFG_WINDOWSY_arm-unknown-linux-gnueabihf :=\n CFG_UNIXY_arm-unknown-linux-gnueabihf := 1\n-CFG_PATH_MUNGE_arm-unknown-linux-gnueabihf := true\n CFG_LDPATH_arm-unknown-linux-gnueabihf :=\n CFG_RUN_arm-unknown-linux-gnueabihf=$(2)\n CFG_RUN_TARG_arm-unknown-linux-gnueabihf=$(call CFG_RUN_arm-unknown-linux-gnueabihf,,$(2))"}, {"sha": "d4696976574e94c52252701a8559f7ac0fbd6b62", "filename": "mk/cfg/armv7-apple-ios.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farmv7-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farmv7-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farmv7-apple-ios.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -19,15 +19,11 @@ CFG_GCCISH_CFLAGS_armv7-apple-ios := -Wall -Werror -g -fPIC $(CFG_IOS_SDK_FLAGS_\n CFG_GCCISH_CXXFLAGS_armv7-apple-ios := -fno-rtti $(CFG_IOS_SDK_FLAGS_armv7-apple-ios) -I$(CFG_IOS_SDK_armv7-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_armv7-apple-ios := -lpthread -syslibroot $(CFG_IOS_SDK_armv7-apple-ios) -Wl,-no_compact_unwind\n CFG_GCCISH_DEF_FLAG_armv7-apple-ios := -Wl,-exported_symbols_list,\n-CFG_GCCISH_PRE_LIB_FLAGS_armv7-apple-ios :=\n-CFG_GCCISH_POST_LIB_FLAGS_armv7-apple-ios :=\n-CFG_DEF_SUFFIX_armv7-apple-ios := .darwin.def\n CFG_LLC_FLAGS_armv7-apple-ios := -mattr=+vfp3,+v7,+neon -march=arm\n CFG_INSTALL_NAME_armv7-apple-ios = -Wl,-install_name,@rpath/$(1)\n CFG_EXE_SUFFIX_armv7-apple-ios :=\n CFG_WINDOWSY_armv7-apple-ios :=\n CFG_UNIXY_armv7-apple-ios := 1\n-CFG_PATH_MUNGE_armv7-apple-ios := true\n CFG_LDPATH_armv7-apple-ios :=\n CFG_RUN_armv7-apple-ios = $(2)\n CFG_RUN_TARG_armv7-apple-ios = $(call CFG_RUN_armv7-apple-ios,,$(2))"}, {"sha": "96ca07648949ff500c50b8bfac253527a1564658", "filename": "mk/cfg/armv7s-apple-ios.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farmv7s-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Farmv7s-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farmv7s-apple-ios.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -19,15 +19,11 @@ CFG_GCCISH_CFLAGS_armv7s-apple-ios := -Wall -Werror -g -fPIC $(CFG_IOS_SDK_FLAGS\n CFG_GCCISH_CXXFLAGS_armv7s-apple-ios := -fno-rtti $(CFG_IOS_SDK_FLAGS_armv7s-apple-ios) -I$(CFG_IOS_SDK_armv7s-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_armv7s-apple-ios := -lpthread -syslibroot $(CFG_IOS_SDK_armv7s-apple-ios) -Wl,-no_compact_unwind\n CFG_GCCISH_DEF_FLAG_armv7s-apple-ios := -Wl,-exported_symbols_list,\n-CFG_GCCISH_PRE_LIB_FLAGS_armv7s-apple-ios :=\n-CFG_GCCISH_POST_LIB_FLAGS_armv7s-apple-ios :=\n-CFG_DEF_SUFFIX_armv7s-apple-ios := .darwin.def\n CFG_LLC_FLAGS_armv7s-apple-ios := -mattr=+vfp4,+v7,+neon\n CFG_INSTALL_NAME_armv7s-apple-ios = -Wl,-install_name,@rpath/$(1)\n CFG_EXE_SUFFIX_armv7s-apple-ios :=\n CFG_WINDOWSY_armv7s-apple-ios :=\n CFG_UNIXY_armv7s-apple-ios := 1\n-CFG_PATH_MUNGE_armv7s-apple-ios := true\n CFG_LDPATH_armv7s-apple-ios :=\n CFG_RUN_armv7s-apple-ios = $(2)\n CFG_RUN_TARG_armv7s-apple-ios = $(call CFG_RUN_armv7s-apple-ios,,$(2))"}, {"sha": "373e2e3b65d15e6d7e39e724ede7498f2a532bf0", "filename": "mk/cfg/i386-apple-ios.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fi386-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fi386-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi386-apple-ios.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -18,15 +18,11 @@ CFG_GCCISH_CFLAGS_i386-apple-ios := -Wall -Werror -g -fPIC -m32 $(CFG_IOSSIM_FLA\n CFG_GCCISH_CXXFLAGS_i386-apple-ios := -fno-rtti $(CFG_IOSSIM_FLAGS_i386-apple-ios) -I$(CFG_IOSSIM_SDK_i386-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_i386-apple-ios := -lpthread -m32 -Wl,-no_compact_unwind -m32 -Wl,-syslibroot $(CFG_IOSSIM_SDK_i386-apple-ios)\n CFG_GCCISH_DEF_FLAG_i386-apple-ios := -Wl,-exported_symbols_list,\n-CFG_GCCISH_PRE_LIB_FLAGS_i386-apple-ios :=\n-CFG_GCCISH_POST_LIB_FLAGS_i386-apple-ios :=\n-CFG_DEF_SUFFIX_i386-apple-ios := .darwin.def\n CFG_LLC_FLAGS_i386-apple-ios =\n CFG_INSTALL_NAME_i386-apple-ios = -Wl,-install_name,@rpath/$(1)\n CFG_EXE_SUFFIX_i386-apple-ios :=\n CFG_WINDOWSY_i386-apple-ios :=\n CFG_UNIXY_i386-apple-ios := 1\n-CFG_PATH_MUNGE_i386-apple-ios = :true\n CFG_LDPATH_i386-apple-ios =\n CFG_RUN_i386-apple-ios = $(2)\n CFG_RUN_TARG_i386-apple-ios = $(call CFG_RUN_i386-apple-ios,,$(2))"}, {"sha": "7ebb492bb21fe1c9d8a50dd4ac697529d85223dc", "filename": "mk/cfg/i686-apple-darwin.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fi686-apple-darwin.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fi686-apple-darwin.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-apple-darwin.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,15 +12,11 @@ CFG_GCCISH_CFLAGS_i686-apple-darwin := -Wall -Werror -g -fPIC -m32 -arch i386 $(\n CFG_GCCISH_CXXFLAGS_i686-apple-darwin := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-apple-darwin := -dynamiclib -pthread  -framework CoreServices -m32\n CFG_GCCISH_DEF_FLAG_i686-apple-darwin := -Wl,-exported_symbols_list,\n-CFG_GCCISH_PRE_LIB_FLAGS_i686-apple-darwin :=\n-CFG_GCCISH_POST_LIB_FLAGS_i686-apple-darwin :=\n-CFG_DEF_SUFFIX_i686-apple-darwin := .darwin.def\n CFG_LLC_FLAGS_i686-apple-darwin :=\n CFG_INSTALL_NAME_i686-apple-darwin = -Wl,-install_name,@rpath/$(1)\n CFG_EXE_SUFFIX_i686-apple-darwin :=\n CFG_WINDOWSY_i686-apple-darwin :=\n CFG_UNIXY_i686-apple-darwin := 1\n-CFG_PATH_MUNGE_i686-apple-darwin := true\n CFG_LDPATH_i686-apple-darwin :=\n CFG_RUN_i686-apple-darwin=$(2)\n CFG_RUN_TARG_i686-apple-darwin=$(call CFG_RUN_i686-apple-darwin,,$(2))"}, {"sha": "174671a9a8812a3370888a2b7730cab3d6f952d6", "filename": "mk/cfg/i686-pc-windows-gnu.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fi686-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fi686-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-pc-windows-gnu.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,15 +13,11 @@ CFG_GCCISH_CFLAGS_i686-pc-windows-gnu := -Wall -Werror -g -m32 -D_WIN32_WINNT=0x\n CFG_GCCISH_CXXFLAGS_i686-pc-windows-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-pc-windows-gnu := -shared -g -m32\n CFG_GCCISH_DEF_FLAG_i686-pc-windows-gnu :=\n-CFG_GCCISH_PRE_LIB_FLAGS_i686-pc-windows-gnu :=\n-CFG_GCCISH_POST_LIB_FLAGS_i686-pc-windows-gnu :=\n-CFG_DEF_SUFFIX_i686-pc-windows-gnu := .windows.def\n CFG_LLC_FLAGS_i686-pc-windows-gnu :=\n CFG_INSTALL_NAME_i686-pc-windows-gnu =\n CFG_EXE_SUFFIX_i686-pc-windows-gnu := .exe\n CFG_WINDOWSY_i686-pc-windows-gnu := 1\n CFG_UNIXY_i686-pc-windows-gnu :=\n-CFG_PATH_MUNGE_i686-pc-windows-gnu :=\n CFG_LDPATH_i686-pc-windows-gnu :=\n CFG_RUN_i686-pc-windows-gnu=$(2)\n CFG_RUN_TARG_i686-pc-windows-gnu=$(call CFG_RUN_i686-pc-windows-gnu,,$(2))"}, {"sha": "88c0907f63b2ac8f8be2e4d30078d31fe75db184", "filename": "mk/cfg/i686-unknown-linux-gnu.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fi686-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fi686-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-linux-gnu.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,15 +12,11 @@ CFG_GCCISH_CFLAGS_i686-unknown-linux-gnu := -Wall -Werror -g -fPIC -m32 $(CFLAGS\n CFG_GCCISH_CXXFLAGS_i686-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m32\n CFG_GCCISH_DEF_FLAG_i686-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_i686-unknown-linux-gnu := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_i686-unknown-linux-gnu := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_i686-unknown-linux-gnu := .linux.def\n CFG_LLC_FLAGS_i686-unknown-linux-gnu :=\n CFG_INSTALL_NAME_i686-unknown-linux-gnu =\n CFG_EXE_SUFFIX_i686-unknown-linux-gnu =\n CFG_WINDOWSY_i686-unknown-linux-gnu :=\n CFG_UNIXY_i686-unknown-linux-gnu := 1\n-CFG_PATH_MUNGE_i686-unknown-linux-gnu := true\n CFG_LDPATH_i686-unknown-linux-gnu :=\n CFG_RUN_i686-unknown-linux-gnu=$(2)\n CFG_RUN_TARG_i686-unknown-linux-gnu=$(call CFG_RUN_i686-unknown-linux-gnu,,$(2))"}, {"sha": "ba5f6d0e756343af7fb01c1b2e398d9644f56018", "filename": "mk/cfg/mips-unknown-linux-gnu.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,15 +12,11 @@ CFG_GCCISH_CFLAGS_mips-unknown-linux-gnu := -Wall -g -fPIC -mips32r2 -msoft-floa\n CFG_GCCISH_CXXFLAGS_mips-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_mips-unknown-linux-gnu := -shared -fPIC -g -mips32r2 -msoft-float -mabi=32\n CFG_GCCISH_DEF_FLAG_mips-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_mips-unknown-linux-gnu := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_mips-unknown-linux-gnu := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_mips-unknown-linux-gnu := .linux.def\n CFG_LLC_FLAGS_mips-unknown-linux-gnu :=\n CFG_INSTALL_NAME_mips-unknown-linux-gnu =\n CFG_EXE_SUFFIX_mips-unknown-linux-gnu :=\n CFG_WINDOWSY_mips-unknown-linux-gnu :=\n CFG_UNIXY_mips-unknown-linux-gnu := 1\n-CFG_PATH_MUNGE_mips-unknown-linux-gnu := true\n CFG_LDPATH_mips-unknown-linux-gnu :=\n CFG_RUN_mips-unknown-linux-gnu=\n CFG_RUN_TARG_mips-unknown-linux-gnu="}, {"sha": "539038c7434606dfc4825052af1a35a431445096", "filename": "mk/cfg/mipsel-unknown-linux-gnu.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fmipsel-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fmipsel-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmipsel-unknown-linux-gnu.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,15 +12,11 @@ CFG_GCCISH_CFLAGS_mipsel-unknown-linux-gnu := -Wall -g -fPIC -mips32 -mabi=32 $(\n CFG_GCCISH_CXXFLAGS_mipsel-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_mipsel-unknown-linux-gnu := -shared -fPIC -g -mips32\n CFG_GCCISH_DEF_FLAG_mipsel-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_mipsel-unknown-linux-gnu := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_mipsel-unknown-linux-gnu := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_mipsel-unknown-linux-gnu := .linux.def\n CFG_LLC_FLAGS_mipsel-unknown-linux-gnu :=\n CFG_INSTALL_NAME_mipsel-unknown-linux-gnu =\n CFG_EXE_SUFFIX_mipsel-unknown-linux-gnu :=\n CFG_WINDOWSY_mipsel-unknown-linux-gnu :=\n CFG_UNIXY_mipsel-unknown-linux-gnu := 1\n-CFG_PATH_MUNGE_mipsel-unknown-linux-gnu := true\n CFG_LDPATH_mipsel-unknown-linux-gnu :=\n CFG_RUN_mipsel-unknown-linux-gnu=\n CFG_RUN_TARG_mipsel-unknown-linux-gnu="}, {"sha": "dda957673eba665d15ab266a29e89a76336d370c", "filename": "mk/cfg/powerpc-unknown-linux-gnu.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fpowerpc-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fpowerpc-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fpowerpc-unknown-linux-gnu.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,15 +13,11 @@ CFG_GCCISH_CFLAGS_powerpc-unknown-linux-gnu := -Wall -Werror -g -fPIC -m32 $(CFL\n CFG_GCCISH_CXXFLAGS_powerpc-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_powerpc-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m32\n CFG_GCCISH_DEF_FLAG_powerpc-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_powerpc-unknown-linux-gnu := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_powerpc-unknown-linux-gnu := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_powerpc-unknown-linux-gnu := .linux.def\n CFG_LLC_FLAGS_powerpc-unknown-linux-gnu :=\n CFG_INSTALL_NAME_powerpc-unknown-linux-gnu =\n CFG_EXE_SUFFIX_powerpc-unknown-linux-gnu =\n CFG_WINDOWSY_powerpc-unknown-linux-gnu :=\n CFG_UNIXY_powerpc-unknown-linux-gnu := 1\n-CFG_PATH_MUNGE_powerpc-unknown-linux-gnu := true\n CFG_LDPATH_powerpc-unknown-linux-gnu :=\n CFG_RUN_powerpc-unknown-linux-gnu=$(2)\n CFG_RUN_TARG_powerpc-unknown-linux-gnu=$(call CFG_RUN_powerpc-unknown-linux-gnu,,$(2))"}, {"sha": "4c68d3dcf37b4424b10e06ae845bfb30e2950d57", "filename": "mk/cfg/x86_64-apple-darwin.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-apple-darwin.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-apple-darwin.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-apple-darwin.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,15 +12,11 @@ CFG_GCCISH_CFLAGS_x86_64-apple-darwin := -Wall -Werror -g -fPIC -m64 -arch x86_6\n CFG_GCCISH_CXXFLAGS_x86_64-apple-darwin := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-apple-darwin := -dynamiclib -pthread  -framework CoreServices -m64\n CFG_GCCISH_DEF_FLAG_x86_64-apple-darwin := -Wl,-exported_symbols_list,\n-CFG_GCCISH_PRE_LIB_FLAGS_x86_64-apple-darwin :=\n-CFG_GCCISH_POST_LIB_FLAGS_x86_64-apple-darwin :=\n-CFG_DEF_SUFFIX_x86_64-apple-darwin := .darwin.def\n CFG_LLC_FLAGS_x86_64-apple-darwin :=\n CFG_INSTALL_NAME_x86_64-apple-darwin = -Wl,-install_name,@rpath/$(1)\n CFG_EXE_SUFFIX_x86_64-apple-darwin :=\n CFG_WINDOWSY_x86_64-apple-darwin :=\n CFG_UNIXY_x86_64-apple-darwin := 1\n-CFG_PATH_MUNGE_x86_64-apple-darwin := true\n CFG_LDPATH_x86_64-apple-darwin :=\n CFG_RUN_x86_64-apple-darwin=$(2)\n CFG_RUN_TARG_x86_64-apple-darwin=$(call CFG_RUN_x86_64-apple-darwin,,$(2))"}, {"sha": "dd6080fdb0bab1ecc872a8fd9e0f1160bf37a477", "filename": "mk/cfg/x86_64-apple-ios.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-apple-ios.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -20,16 +20,12 @@ CFG_GCCISH_CFLAGS_x86_64-apple-ios := -Wall -Werror -fPIC $(CFG_IOSSIM_FLAGS_x86\n CFG_GCCISH_CXXFLAGS_x86_64-apple-ios := -fno-rtti $(CFG_IOSSIM_FLAGS_x86_64-apple-ios) -I$(CFG_IOSSIM_SDK_x86_64-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_x86_64-apple-ios := -lpthread -Wl,-no_compact_unwind -m64 -Wl,-syslibroot $(CFG_IOSSIM_SDK_x86_64-apple-ios)\n CFG_GCCISH_DEF_FLAG_x86_64-apple-ios := -Wl,-exported_symbols_list,\n-CFG_GCCISH_PRE_LIB_FLAGS_x86_64-apple-ios :=\n-CFG_GCCISH_POST_LIB_FLAGS_x86_64-apple-ios :=\n-CFG_DEF_SUFFIX_x86_64-apple-ios := .darwin.def\n CFG_LLC_FLAGS_x86_64-apple-ios :=\n CFG_INSTALL_NAME_x86_64-apple-ios = -Wl,-install_name,@rpath/$(1)\n CFG_LIBUV_LINK_FLAGS_x86_64-apple-ios :=\n CFG_EXE_SUFFIX_x86_64-apple-ios :=\n CFG_WINDOWSY_x86_64-apple-ios :=\n CFG_UNIXY_x86_64-apple-ios := 1\n-CFG_PATH_MUNGE_x86_64-apple-ios := true\n CFG_LDPATH_x86_64-apple-ios :=\n CFG_RUN_x86_64-apple-ios = $(2)\n CFG_RUN_TARG_x86_64-apple-ios = $(call CFG_RUN_x86_64-apple-ios,,$(2))"}, {"sha": "4118ea26c072b0e13587bcc293d38a5c55b56329", "filename": "mk/cfg/x86_64-pc-windows-gnu.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,15 +13,11 @@ CFG_GCCISH_CFLAGS_x86_64-pc-windows-gnu := -Wall -Werror -g -m64 -D_WIN32_WINNT=\n CFG_GCCISH_CXXFLAGS_x86_64-pc-windows-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-pc-windows-gnu := -shared -g -m64\n CFG_GCCISH_DEF_FLAG_x86_64-pc-windows-gnu :=\n-CFG_GCCISH_PRE_LIB_FLAGS_x86_64-pc-windows-gnu :=\n-CFG_GCCISH_POST_LIB_FLAGS_x86_64-pc-windows-gnu :=\n-CFG_DEF_SUFFIX_x86_64-pc-windows-gnu := .windows.def\n CFG_LLC_FLAGS_x86_64-pc-windows-gnu :=\n CFG_INSTALL_NAME_x86_64-pc-windows-gnu =\n CFG_EXE_SUFFIX_x86_64-pc-windows-gnu := .exe\n CFG_WINDOWSY_x86_64-pc-windows-gnu := 1\n CFG_UNIXY_x86_64-pc-windows-gnu :=\n-CFG_PATH_MUNGE_x86_64-pc-windows-gnu :=\n CFG_LDPATH_x86_64-pc-windows-gnu :=\n CFG_RUN_x86_64-pc-windows-gnu=$(2)\n CFG_RUN_TARG_x86_64-pc-windows-gnu=$(call CFG_RUN_x86_64-pc-windows-gnu,,$(2))"}, {"sha": "dd6d19f7491bb688d8f7c588392afd18c9a6a4c5", "filename": "mk/cfg/x86_64-unknown-bitrig.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-bitrig.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-bitrig.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-bitrig.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,15 +11,11 @@ CFG_JEMALLOC_CFLAGS_x86_64-unknown-bitrig := -m64 -I/usr/include $(CFLAGS)\n CFG_GCCISH_CFLAGS_x86_64-unknown-bitrig := -Wall -Werror -fPIC -m64 -I/usr/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-bitrig := -shared -pic -pthread -m64 $(LDFLAGS)\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-bitrig := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-bitrig := -Wl,-pic -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-bitrig := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_x86_64-unknown-bitrig := .bsd.def\n CFG_LLC_FLAGS_x86_64-unknown-bitrig :=\n CFG_INSTALL_NAME_x86_64-unknown-bitrig =\n CFG_EXE_SUFFIX_x86_64-unknown-bitrig :=\n CFG_WINDOWSY_x86_64-unknown-bitrig :=\n CFG_UNIXY_x86_64-unknown-bitrig := 1\n-CFG_PATH_MUNGE_x86_64-unknown-bitrig :=\n CFG_LDPATH_x86_64-unknown-bitrig :=\n CFG_RUN_x86_64-unknown-bitrig=$(2)\n CFG_RUN_TARG_x86_64-unknown-bitrig=$(call CFG_RUN_x86_64-unknown-bitrig,,$(2))"}, {"sha": "4015293826e1a884e2a2c9975908ec09e17ef6eb", "filename": "mk/cfg/x86_64-unknown-dragonfly.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-dragonfly.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-dragonfly.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-dragonfly.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,15 +11,11 @@ CFG_JEMALLOC_CFLAGS_x86_64-unknown-dragonfly := -m64 -I/usr/include -I/usr/local\n CFG_GCCISH_CFLAGS_x86_64-unknown-dragonfly := -Wall -Werror -g -fPIC -m64 -I/usr/include -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-dragonfly := -shared -fPIC -g -pthread  -lrt -m64\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-dragonfly := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-dragonfly := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-dragonfly := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_x86_64-unknown-dragonfly := .bsd.def\n CFG_LLC_FLAGS_x86_64-unknown-dragonfly :=\n CFG_INSTALL_NAME_x86_64-unknown-dragonfly =\n CFG_EXE_SUFFIX_x86_64-unknown-dragonfly :=\n CFG_WINDOWSY_x86_64-unknown-dragonfly :=\n CFG_UNIXY_x86_64-unknown-dragonfly := 1\n-CFG_PATH_MUNGE_x86_64-unknown-dragonfly :=\n CFG_LDPATH_x86_64-unknown-dragonfly :=\n CFG_RUN_x86_64-unknown-dragonfly=$(2)\n CFG_RUN_TARG_x86_64-unknown-dragonfly=$(call CFG_RUN_x86_64-unknown-dragonfly,,$(2))"}, {"sha": "1bd43168b4f692cf7283560803446569a275ac95", "filename": "mk/cfg/x86_64-unknown-freebsd.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-freebsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-freebsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-freebsd.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,15 +11,11 @@ CFG_JEMALLOC_CFLAGS_x86_64-unknown-freebsd := -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_CFLAGS_x86_64-unknown-freebsd := -Wall -Werror -g -fPIC -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-freebsd := -shared -fPIC -g -pthread  -lrt\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-freebsd := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-freebsd := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-freebsd := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_x86_64-unknown-freebsd := .bsd.def\n CFG_LLC_FLAGS_x86_64-unknown-freebsd :=\n CFG_INSTALL_NAME_x86_64-unknown-freebsd =\n CFG_EXE_SUFFIX_x86_64-unknown-freebsd :=\n CFG_WINDOWSY_x86_64-unknown-freebsd :=\n CFG_UNIXY_x86_64-unknown-freebsd := 1\n-CFG_PATH_MUNGE_x86_64-unknown-freebsd :=\n CFG_LDPATH_x86_64-unknown-freebsd :=\n CFG_RUN_x86_64-unknown-freebsd=$(2)\n CFG_RUN_TARG_x86_64-unknown-freebsd=$(call CFG_RUN_x86_64-unknown-freebsd,,$(2))"}, {"sha": "044c687c9fc4c871cb3510dfbf8f7b3e3121caf4", "filename": "mk/cfg/x86_64-unknown-linux-gnu.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,15 +12,11 @@ CFG_GCCISH_CFLAGS_x86_64-unknown-linux-gnu := -Wall -Werror -g -fPIC -m64\n CFG_GCCISH_CXXFLAGS_x86_64-unknown-linux-gnu := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m64\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-linux-gnu := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-linux-gnu := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_x86_64-unknown-linux-gnu := .linux.def\n CFG_LLC_FLAGS_x86_64-unknown-linux-gnu :=\n CFG_INSTALL_NAME_x86_64-unknown-linux-gnu =\n CFG_EXE_SUFFIX_x86_64-unknown-linux-gnu =\n CFG_WINDOWSY_x86_64-unknown-linux-gnu :=\n CFG_UNIXY_x86_64-unknown-linux-gnu := 1\n-CFG_PATH_MUNGE_x86_64-unknown-linux-gnu := true\n CFG_LDPATH_x86_64-unknown-linux-gnu :=\n CFG_RUN_x86_64-unknown-linux-gnu=$(2)\n CFG_RUN_TARG_x86_64-unknown-linux-gnu=$(call CFG_RUN_x86_64-unknown-linux-gnu,,$(2))"}, {"sha": "b3dea6f97cbc11a05ea751c9fb809e66c792c6ff", "filename": "mk/cfg/x86_64-unknown-linux-musl.mk", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-linux-musl.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-linux-musl.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-linux-musl.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,27 @@\n+# x86_64-unknown-linux-musl configuration\n+CC_x86_64-unknown-linux-musl=$(CFG_MUSL_ROOT)/bin/musl-gcc\n+CXX_x86_64-unknown-linux-musl=notaprogram\n+CPP_x86_64-unknown-linux-musl=$(CFG_MUSL_ROOT)/bin/musl-gcc -E\n+AR_x86_64-unknown-linux-musl=$(AR)\n+CFG_LIB_NAME_x86_64-unknown-linux-musl=lib$(1).so\n+CFG_STATIC_LIB_NAME_x86_64-unknown-linux-musl=lib$(1).a\n+CFG_LIB_GLOB_x86_64-unknown-linux-musl=lib$(1)-*.so\n+CFG_JEMALLOC_CFLAGS_x86_64-unknown-linux-musl := -m64\n+CFG_GCCISH_CFLAGS_x86_64-unknown-linux-musl := -Wall -Werror -g -fPIC -m64\n+CFG_GCCISH_CXXFLAGS_x86_64-unknown-linux-musl :=\n+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-linux-musl :=\n+CFG_GCCISH_DEF_FLAG_x86_64-unknown-linux-musl :=\n+CFG_LLC_FLAGS_x86_64-unknown-linux-musl :=\n+CFG_INSTALL_NAME_x86_64-unknown-linux-musl =\n+CFG_EXE_SUFFIX_x86_64-unknown-linux-musl =\n+CFG_WINDOWSY_x86_64-unknown-linux-musl :=\n+CFG_UNIXY_x86_64-unknown-linux-musl := 1\n+CFG_LDPATH_x86_64-unknown-linux-musl :=\n+CFG_RUN_x86_64-unknown-linux-musl=$(2)\n+CFG_RUN_TARG_x86_64-unknown-linux-musl=$(call CFG_RUN_x86_64-unknown-linux-musl,,$(2))\n+CFG_GNU_TRIPLE_x86_64-unknown-linux-musl := x86_64-unknown-linux-musl\n+\n+NATIVE_DEPS_libc_T_x86_64-unknown-linux-musl += libc.a\n+NATIVE_DEPS_std_T_x86_64-unknown-linux-musl += libunwind.a \\\n+\tcrt1.o crti.o crtn.o\n+INSTALLED_OBJECTS_x86_64-unknown-linux-musl += crt1.o crti.o crtn.o"}, {"sha": "261616ecf1fdaea8c14cff20c9bf49c7c44d1c30", "filename": "mk/cfg/x86_64-unknown-openbsd.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-openbsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcfg%2Fx86_64-unknown-openbsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-openbsd.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,15 +11,11 @@ CFG_JEMALLOC_CFLAGS_x86_64-unknown-openbsd := -m64 -I/usr/include $(CFLAGS)\n CFG_GCCISH_CFLAGS_x86_64-unknown-openbsd := -Wall -Werror -g -fPIC -m64 -I/usr/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-openbsd := -shared -fPIC -g -pthread -m64\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-openbsd := -Wl,--export-dynamic,--dynamic-list=\n-CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-openbsd := -Wl,-whole-archive\n-CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-openbsd := -Wl,-no-whole-archive\n-CFG_DEF_SUFFIX_x86_64-unknown-openbsd := .bsd.def\n CFG_LLC_FLAGS_x86_64-unknown-openbsd :=\n CFG_INSTALL_NAME_x86_64-unknown-openbsd =\n CFG_EXE_SUFFIX_x86_64-unknown-openbsd :=\n CFG_WINDOWSY_x86_64-unknown-openbsd :=\n CFG_UNIXY_x86_64-unknown-openbsd := 1\n-CFG_PATH_MUNGE_x86_64-unknown-openbsd :=\n CFG_LDPATH_x86_64-unknown-openbsd :=\n CFG_RUN_x86_64-unknown-openbsd=$(2)\n CFG_RUN_TARG_x86_64-unknown-openbsd=$(call CFG_RUN_x86_64-unknown-openbsd,,$(2))"}, {"sha": "367c25a8a6d495f5281ae94980101e70b699f0b2", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -123,6 +123,9 @@ ONLY_RLIB_rustc_bitflags := 1\n # Documented-by-default crates\n DOC_CRATES := std alloc collections core libc rustc_unicode\n \n+# Installed objects/libraries by default\n+INSTALLED_OBJECTS := libmorestack.a libcompiler-rt.a\n+\n ################################################################################\n # You should not need to edit below this line\n ################################################################################"}, {"sha": "9ac96aa90f6b9b9a1035b40994bbbfeb6f7784cd", "filename": "mk/main.mk", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -399,8 +399,10 @@ endif\n # Prerequisites for using the stageN compiler to build target artifacts\n TSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(HSREQ$(1)_H_$(3)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a\n+\t$$(foreach obj,$$(INSTALLED_OBJECTS),\\\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(obj)) \\\n+\t$$(foreach obj,$$(INSTALLED_OBJECTS_$(2)),\\\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(obj))\n \n # Prerequisites for a working stageN compiler and libraries, for a specific\n # target"}, {"sha": "1382d160e13999063b3ac7674ab95c0de600854b", "filename": "mk/prepare.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fprepare.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Fprepare.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fprepare.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -140,8 +140,8 @@ prepare-target-$(2)-host-$(3)-$(1)-$(4): prepare-maybe-clean-$(4) \\\n           $$(if $$(findstring $(2),$$(CFG_HOST)), \\\n             $$(foreach crate,$$(HOST_CRATES), \\\n               $$(call PREPARE_LIB,$$(call CFG_LIB_GLOB_$(2),$$(crate)))),) \\\n-          $$(call PREPARE_LIB,libmorestack.a) \\\n-          $$(call PREPARE_LIB,libcompiler-rt.a),),),)\n+\t  $$(foreach object,$$(INSTALLED_OBJECTS) $$(INSTALLED_OBJECTS_$(2)),\\\n+\t    $$(call PREPARE_LIB,$$(object))),),),)\n endef\n \n define INSTALL_GDB_DEBUGGER_SCRIPTS_COMMANDS"}, {"sha": "bd6578d3b724b9baeffaab93ac7d40fa81215747", "filename": "mk/rt.mk", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -74,7 +74,8 @@ $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.ll $$(MKFILE_DEPS) \\\n \t@mkdir -p $$(@D)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(LLC_$$(CFG_BUILD)) $$(CFG_LLC_FLAGS_$(1)) \\\n-\t    -filetype=obj -mtriple=$$(CFG_LLVM_TARGET_$(1)) -relocation-model=pic -o $$@ $$<\n+\t    -filetype=obj -mtriple=$$(CFG_LLVM_TARGET_$(1)) \\\n+\t    -relocation-model=pic -o $$@ $$<\n \n $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.c $$(MKFILE_DEPS)\n \t@mkdir -p $$(@D)\n@@ -110,6 +111,11 @@ $$(RT_OUTPUT_DIR_$(1))/$$(NATIVE_$(2)_$(1)): $$(OBJS_$(2)_$(1))\n \t@$$(call E, link: $$@)\n \t$$(Q)$$(AR_$(1)) rcs $$@ $$^\n \n+ifeq ($$(findstring windows,$(1)),windows)\n+$$(RT_OUTPUT_DIR_$(1))/lib$(2).a: $$(RT_OUTPUT_DIR_$(1))/$$(NATIVE_$(2)_$(1))\n+\t$$(Q)cp $$^ $$@\n+endif\n+\n endef\n \n $(foreach target,$(CFG_TARGET), \\\n@@ -221,7 +227,7 @@ COMPRT_DEPS := $(wildcard \\\n               $(S)src/compiler-rt/*/*/*/*)\n endif\n \n-COMPRT_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n+COMPRT_NAME_$(1) := libcompiler-rt.a\n COMPRT_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(COMPRT_NAME_$(1))\n COMPRT_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/compiler-rt\n \n@@ -312,6 +318,19 @@ endif # endif for windowsy\n endif # endif for ios\n endif # endif for darwin\n \n+################################################################################\n+# libc/libunwind for musl\n+#\n+# When we're building a musl-like target we're going to link libc/libunwind\n+# statically into the standard library and liblibc, so we need to make sure\n+# they're in a location that we can find\n+################################################################################\n+\n+ifeq ($$(findstring musl,$(1)),musl)\n+$$(RT_OUTPUT_DIR_$(1))/%: $$(CFG_MUSL_ROOT)/lib/%\n+\tcp $$^ $$@\n+endif\n+\n endef\n \n # Instantiate template for all stages/targets"}, {"sha": "363022e8781d08bfd28ef2ca213374409a8e4010", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -25,8 +25,6 @@ endif\n RUSTLLVM_OBJS_CS_$(1) := $$(addprefix rustllvm/, \\\n \tExecutionEngineWrapper.cpp RustWrapper.cpp PassWrapper.cpp)\n \n-RUSTLLVM_DEF_$(1) := $(1)/rustllvm/rustllvm$(CFG_DEF_SUFFIX_$(1))\n-\n RUSTLLVM_INCS_$(1) = $$(LLVM_EXTRA_INCDIRS_$(1)) \\\n                      -iquote $$(LLVM_INCDIR_$(1)) \\\n                      -iquote $$(S)src/rustllvm/include"}, {"sha": "319f44fd35b77c1058c4627b77640cf913ffc09f", "filename": "mk/target.mk", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -35,7 +35,9 @@ CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4) := \\\n \t\t$$(foreach dep,$$(RUST_DEPS_$(4)), \\\n \t\t  $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n \t\t$$(foreach dep,$$(NATIVE_DEPS_$(4)), \\\n-\t\t  $$(RT_OUTPUT_DIR_$(2))/$$(call CFG_STATIC_LIB_NAME_$(2),$$(dep)))\n+\t\t  $$(RT_OUTPUT_DIR_$(2))/$$(call CFG_STATIC_LIB_NAME_$(2),$$(dep))) \\\n+\t\t$$(foreach dep,$$(NATIVE_DEPS_$(4)_T_$(2)), \\\n+\t\t  $$(RT_OUTPUT_DIR_$(2))/$$(dep))\n endef\n \n $(foreach host,$(CFG_HOST), \\\n@@ -143,14 +145,7 @@ $$(TBIN$(1)_T_$(2)_H_$(3))/:\n $$(TLIB$(1)_T_$(2)_H_$(3))/:\n \tmkdir -p $$@\n \n-$$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a: \\\n-\t    $$(RT_OUTPUT_DIR_$(2))/$$(call CFG_STATIC_LIB_NAME_$(2),compiler-rt) \\\n-\t    | $$(TLIB$(1)_T_$(2)_H_$(3))/ $$(SNAPSHOT_RUSTC_POST_CLEANUP)\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n-$$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a: \\\n-\t    $$(RT_OUTPUT_DIR_$(2))/$$(call CFG_STATIC_LIB_NAME_$(2),morestack) \\\n+$$(TLIB$(1)_T_$(2)_H_$(3))/%: $$(RT_OUTPUT_DIR_$(2))/% \\\n \t    | $$(TLIB$(1)_T_$(2)_H_$(3))/ $$(SNAPSHOT_RUSTC_POST_CLEANUP)\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@"}, {"sha": "f391d8555fc2bff578a2a6c329b79cf71aa84542", "filename": "mk/tests.mk", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -304,6 +304,7 @@ check-stage$(1)-T-$(2)-H-$(3)-exec: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pfail-exec \\\n     check-stage$(1)-T-$(2)-H-$(3)-rpass-valgrind-exec \\\n     check-stage$(1)-T-$(2)-H-$(3)-rpass-full-exec \\\n+    check-stage$(1)-T-$(2)-H-$(3)-rfail-full-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-cfail-full-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rmake-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rustdocck-exec \\\n@@ -345,6 +346,7 @@ check-stage$(1)-T-$(2)-H-$(3)-pretty-exec: \\\n     check-stage$(1)-T-$(2)-H-$(3)-pretty-rpass-valgrind-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-rpass-full-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-rfail-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-rfail-full-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-bench-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-pretty-exec\n \n@@ -464,6 +466,7 @@ $(foreach host,$(CFG_HOST), \\\n RPASS_RS := $(wildcard $(S)src/test/run-pass/*.rs)\n RPASS_VALGRIND_RS := $(wildcard $(S)src/test/run-pass-valgrind/*.rs)\n RPASS_FULL_RS := $(wildcard $(S)src/test/run-pass-fulldeps/*.rs)\n+RFAIL_FULL_RS := $(wildcard $(S)src/test/run-fail-fulldeps/*.rs)\n CFAIL_FULL_RS := $(wildcard $(S)src/test/compile-fail-fulldeps/*.rs)\n RFAIL_RS := $(wildcard $(S)src/test/run-fail/*.rs)\n CFAIL_RS := $(wildcard $(S)src/test/compile-fail/*.rs)\n@@ -483,6 +486,7 @@ PERF_RS := $(wildcard $(S)src/test/bench/*.rs)\n RPASS_TESTS := $(RPASS_RS)\n RPASS_VALGRIND_TESTS := $(RPASS_VALGRIND_RS)\n RPASS_FULL_TESTS := $(RPASS_FULL_RS)\n+RFAIL_FULL_TESTS := $(RFAIL_FULL_RS)\n CFAIL_FULL_TESTS := $(CFAIL_FULL_RS)\n RFAIL_TESTS := $(RFAIL_RS)\n CFAIL_TESTS := $(CFAIL_RS)\n@@ -510,6 +514,11 @@ CTEST_BUILD_BASE_rpass-full = run-pass-fulldeps\n CTEST_MODE_rpass-full = run-pass\n CTEST_RUNTOOL_rpass-full = $(CTEST_RUNTOOL)\n \n+CTEST_SRC_BASE_rfail-full = run-fail-fulldeps\n+CTEST_BUILD_BASE_rfail-full = run-fail-fulldeps\n+CTEST_MODE_rfail-full = run-fail\n+CTEST_RUNTOOL_rfail-full = $(CTEST_RUNTOOL)\n+\n CTEST_SRC_BASE_cfail-full = compile-fail-fulldeps\n CTEST_BUILD_BASE_cfail-full = compile-fail-fulldeps\n CTEST_MODE_cfail-full = compile-fail\n@@ -623,6 +632,13 @@ ifndef CFG_DISABLE_OPTIMIZE_TESTS\n CTEST_RUSTC_FLAGS += -O\n endif\n \n+# Analogously to the above, whether to pass `-g` when compiling tests\n+# is a separate choice from whether to pass `-g` when building the\n+# compiler and standard library themselves.\n+CTEST_RUSTC_FLAGS := $$(subst -g,,$$(CTEST_RUSTC_FLAGS))\n+ifdef CFG_ENABLE_DEBUGINFO_TESTS\n+CTEST_RUSTC_FLAGS += -g\n+endif\n \n CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3) := \\\n \t\t--compile-lib-path $$(HLIB$(1)_H_$(3)) \\\n@@ -661,6 +677,7 @@ endif\n CTEST_DEPS_rpass_$(1)-T-$(2)-H-$(3) = $$(RPASS_TESTS)\n CTEST_DEPS_rpass-valgrind_$(1)-T-$(2)-H-$(3) = $$(RPASS_VALGRIND_TESTS)\n CTEST_DEPS_rpass-full_$(1)-T-$(2)-H-$(3) = $$(RPASS_FULL_TESTS) $$(CSREQ$(1)_T_$(3)_H_$(3)) $$(SREQ$(1)_T_$(2)_H_$(3))\n+CTEST_DEPS_rfail-full_$(1)-T-$(2)-H-$(3) = $$(RFAIL_FULL_TESTS) $$(CSREQ$(1)_T_$(3)_H_$(3)) $$(SREQ$(1)_T_$(2)_H_$(3))\n CTEST_DEPS_cfail-full_$(1)-T-$(2)-H-$(3) = $$(CFAIL_FULL_TESTS) $$(CSREQ$(1)_T_$(3)_H_$(3)) $$(SREQ$(1)_T_$(2)_H_$(3))\n CTEST_DEPS_rfail_$(1)-T-$(2)-H-$(3) = $$(RFAIL_TESTS)\n CTEST_DEPS_cfail_$(1)-T-$(2)-H-$(3) = $$(CFAIL_TESTS)\n@@ -737,7 +754,7 @@ endif\n \n endef\n \n-CTEST_NAMES = rpass rpass-valgrind rpass-full cfail-full rfail cfail pfail \\\n+CTEST_NAMES = rpass rpass-valgrind rpass-full rfail-full cfail-full rfail cfail pfail \\\n \tbench perf debuginfo-gdb debuginfo-lldb codegen rustdocck\n \n $(foreach host,$(CFG_HOST), \\\n@@ -746,22 +763,26 @@ $(foreach host,$(CFG_HOST), \\\n    $(eval $(foreach name,$(CTEST_NAMES), \\\n    $(eval $(call DEF_RUN_COMPILETEST,$(stage),$(target),$(host),$(name))))))))))\n \n-PRETTY_NAMES = pretty-rpass pretty-rpass-valgrind pretty-rpass-full pretty-rfail pretty-bench pretty-pretty\n+PRETTY_NAMES = pretty-rpass pretty-rpass-valgrind pretty-rpass-full pretty-rfail-full pretty-rfail \\\n+    pretty-bench pretty-pretty\n PRETTY_DEPS_pretty-rpass = $(RPASS_TESTS)\n PRETTY_DEPS_pretty-rpass-valgrind = $(RPASS_VALGRIND_TESTS)\n PRETTY_DEPS_pretty-rpass-full = $(RPASS_FULL_TESTS)\n+PRETTY_DEPS_pretty-rfail-full = $(RFAIL_FULL_TESTS)\n PRETTY_DEPS_pretty-rfail = $(RFAIL_TESTS)\n PRETTY_DEPS_pretty-bench = $(BENCH_TESTS)\n PRETTY_DEPS_pretty-pretty = $(PRETTY_TESTS)\n PRETTY_DIRNAME_pretty-rpass = run-pass\n PRETTY_DIRNAME_pretty-rpass-valgrind = run-pass-valgrind\n PRETTY_DIRNAME_pretty-rpass-full = run-pass-fulldeps\n+PRETTY_DIRNAME_pretty-rfail-full = run-fail-fulldeps\n PRETTY_DIRNAME_pretty-rfail = run-fail\n PRETTY_DIRNAME_pretty-bench = bench\n PRETTY_DIRNAME_pretty-pretty = pretty\n \n define DEF_PRETTY_FULLDEPS\n PRETTY_DEPS$(1)_T_$(2)_H_$(3)_pretty-rpass-full = $$(CSREQ$(1)_T_$(3)_H_$(3))\n+PRETTY_DEPS$(1)_T_$(2)_H_$(3)_pretty-rfail-full = $$(CSREQ$(1)_T_$(3)_H_$(3))\n endef\n \n $(foreach host,$(CFG_HOST), \\\n@@ -901,6 +922,7 @@ TEST_GROUPS = \\\n \trpass \\\n     rpass-valgrind \\\n \trpass-full \\\n+\trfail-full \\\n \tcfail-full \\\n \trfail \\\n \tcfail \\\n@@ -918,6 +940,7 @@ TEST_GROUPS = \\\n \tpretty-rpass \\\n     pretty-rpass-valgrind \\\n \tpretty-rpass-full \\\n+\tpretty-rfail-full \\\n \tpretty-rfail \\\n \tpretty-bench \\\n \tpretty-pretty \\"}, {"sha": "a648e51497e79dbcc726065863d61807733a50fd", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -170,6 +170,9 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n         format!(\"ignore-{}\",\n                 config.stage_id.split('-').next().unwrap())\n     }\n+    fn ignore_env(config: &Config) -> String {\n+        format!(\"ignore-{}\", util::get_env(&config.target).unwrap_or(\"<unknown>\"))\n+    }\n     fn ignore_gdb(config: &Config, line: &str) -> bool {\n         if config.mode != common::DebugInfoGdb {\n             return false;\n@@ -231,6 +234,7 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n         !parse_name_directive(ln, &ignore_target(config)) &&\n         !parse_name_directive(ln, &ignore_architecture(config)) &&\n         !parse_name_directive(ln, &ignore_stage(config)) &&\n+        !parse_name_directive(ln, &ignore_env(config)) &&\n         !(config.mode == common::Pretty && parse_name_directive(ln, \"ignore-pretty\")) &&\n         !(config.target != config.host && parse_name_directive(ln, \"ignore-cross-compile\")) &&\n         !ignore_gdb(config, ln) &&"}, {"sha": "33d4f761eea841ee7730abd6f3b98bd02f9a523a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1233,7 +1233,20 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n         let mut crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n         } else {\n-            vec!(\"--crate-type=dylib\".to_string())\n+            // We primarily compile all auxiliary libraries as dynamic libraries\n+            // to avoid code size bloat and large binaries as much as possible\n+            // for the test suite (otherwise including libstd statically in all\n+            // executables takes up quite a bit of space).\n+            //\n+            // For targets like MUSL, however, there is no support for dynamic\n+            // libraries so we just go back to building a normal library. Note,\n+            // however, that if the library is built with `force_host` then it's\n+            // ok to be a dylib as the host should always support dylibs.\n+            if config.target.contains(\"musl\") && !aux_props.force_host {\n+                vec!(\"--crate-type=lib\".to_string())\n+            } else {\n+                vec!(\"--crate-type=dylib\".to_string())\n+            }\n         };\n         crate_type.extend(extra_link_args.clone().into_iter());\n         let aux_args ="}, {"sha": "184d62db45114682d21ffe8303424c89e7f5405e", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -60,6 +60,10 @@ pub fn get_arch(triple: &str) -> &'static str {\n     panic!(\"Cannot determine Architecture from triple\");\n }\n \n+pub fn get_env(triple: &str) -> Option<&str> {\n+    triple.split('-').nth(3)\n+}\n+\n pub fn make_new_path(path: &str) -> String {\n     assert!(cfg!(windows));\n     // Windows just uses PATH as the library search path, so we have to"}, {"sha": "cceab31c61db1da60b0887face14d1492b33e557", "filename": "src/doc/grammar.md", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -96,12 +96,16 @@ explicit codepoint lists. [^inputformat]\n ## Special Unicode Productions\n \n The following productions in the Rust grammar are defined in terms of Unicode\n-properties: `ident`, `non_null`, `non_star`, `non_eol`, `non_slash_or_star`,\n-`non_single_quote` and `non_double_quote`.\n+properties: `ident`, `non_null`, `non_eol`, `non_single_quote` and\n+`non_double_quote`.\n \n ### Identifiers\n \n-The `ident` production is any nonempty Unicode string of the following form:\n+The `ident` production is any nonempty Unicode[^non_ascii_idents] string of\n+the following form:\n+\n+[^non_ascii_idents]: Non-ASCII characters in identifiers are currently feature\n+  gated. This is expected to improve soon.\n \n - The first character has property `XID_start`\n - The remaining characters have property `XID_continue`\n@@ -118,8 +122,6 @@ Some productions are defined by exclusion of particular Unicode characters:\n \n - `non_null` is any single Unicode character aside from `U+0000` (null)\n - `non_eol` is `non_null` restricted to exclude `U+000A` (`'\\n'`)\n-- `non_star` is `non_null` restricted to exclude `U+002A` (`*`)\n-- `non_slash_or_star` is `non_null` restricted to exclude `U+002F` (`/`) and `U+002A` (`*`)\n - `non_single_quote` is `non_null` restricted to exclude `U+0027`  (`'`)\n - `non_double_quote` is `non_null` restricted to exclude `U+0022` (`\"`)\n \n@@ -152,19 +154,19 @@ token : simple_token | ident | literal | symbol | whitespace token ;\n \n <p id=\"keyword-table-marker\"></p>\n \n-|          |          |          |          |        |\n-|----------|----------|----------|----------|--------|\n-| abstract | alignof  | as       | become   | box    |\n-| break    | const    | continue | crate    | do     |\n-| else     | enum     | extern   | false    | final  |\n-| fn       | for      | if       | impl     | in     |\n-| let      | loop     | match    | mod      | move   |\n-| mut      | offsetof | once     | override | priv   |\n-| proc     | pub      | pure     | ref      | return |\n-| sizeof   | static   | self     | struct   | super  |\n-| true     | trait    | type     | typeof   | unsafe |\n-| unsized  | use      | virtual  | where    | while  |\n-| yield    |          |          |          |        |\n+|          |          |          |          |         |\n+|----------|----------|----------|----------|---------|\n+| abstract | alignof  | as       | become   | box     |\n+| break    | const    | continue | crate    | do      |\n+| else     | enum     | extern   | false    | final   |\n+| fn       | for      | if       | impl     | in      |\n+| let      | loop     | macro    | match    | mod     |\n+| move     | mut      | offsetof | override | priv    |\n+| proc     | pub      | pure     | ref      | return  |\n+| Self     | self     | sizeof   | static   | struct  |\n+| super    | trait    | true     | type     | typeof  |\n+| unsafe   | unsized  | use      | virtual  | where   |\n+| while    | yield    |          |          |         |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -524,6 +526,15 @@ array_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n idx_expr : expr '[' expr ']' ;\n ```\n \n+### Range expressions\n+\n+```antlr\n+range_expr : expr \"..\" expr |\n+             expr \"..\" |\n+             \"..\" expr |\n+             \"..\" ;\n+```\n+\n ### Unary operator expressions\n \n **FIXME:** grammar?\n@@ -610,7 +621,7 @@ lambda_expr : '|' ident_list '|' expr ;\n ### While loops\n \n ```antlr\n-while_expr : \"while\" no_struct_literal_expr '{' block '}' ;\n+while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n ```\n \n ### Infinite loops\n@@ -634,7 +645,7 @@ continue_expr : \"continue\" [ lifetime ];\n ### For expressions\n \n ```antlr\n-for_expr : \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n+for_expr : [ lifetime ':' ] \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n ```\n \n ### If expressions"}, {"sha": "e740bf3c223aef1a34278be7c5811df77d63ff78", "filename": "src/doc/not_found.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Fnot_found.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Fnot_found.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnot_found.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -57,8 +57,12 @@ function populate_rust_search() {\n \n     // #18540, use a single token\n \n+    var a = document.createElement(\"a\");\n+    a.href = \"http://doc.rust-lang.org/core/?search=\" + encodeURIComponent(lt);\n+    a.textContent = lt;\n     var search = document.getElementById('core-search');\n-    search.innerHTML = \"<a href=\\\"http://doc.rust-lang.org/core/?search=\" + lt + \"\\\">\" + lt + \"</a>\";\n+    search.innerHTML = \"\";\n+    search.appendChild(a);\n }\n populate_site_search();\n populate_rust_search();"}, {"sha": "19cbd6f90a58146402abf38283d285cac38cae85", "filename": "src/doc/reference.md", "status": "modified", "additions": 59, "deletions": 383, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -29,41 +29,6 @@ You may also be interested in the [grammar].\n \n # Notation\n \n-Rust's grammar is defined over Unicode code points, each conventionally denoted\n-`U+XXXX`, for 4 or more hexadecimal digits `X`. _Most_ of Rust's grammar is\n-confined to the ASCII range of Unicode, and is described in this document by a\n-dialect of Extended Backus-Naur Form (EBNF), specifically a dialect of EBNF\n-supported by common automated LL(k) parsing tools such as `llgen`, rather than\n-the dialect given in ISO 14977. The dialect can be defined self-referentially\n-as follows:\n-\n-```{.ebnf .notation}\n-grammar : rule + ;\n-rule    : nonterminal ':' productionrule ';' ;\n-productionrule : production [ '|' production ] * ;\n-production : term * ;\n-term : element repeats ;\n-element : LITERAL | IDENTIFIER | '[' productionrule ']' ;\n-repeats : [ '*' | '+' ] NUMBER ? | NUMBER ? | '?' ;\n-```\n-\n-Where:\n-\n-- Whitespace in the grammar is ignored.\n-- Square brackets are used to group rules.\n-- `LITERAL` is a single printable ASCII character, or an escaped hexadecimal\n-  ASCII code of the form `\\xQQ`, in single quotes, denoting the corresponding\n-  Unicode code point `U+00QQ`.\n-- `IDENTIFIER` is a nonempty string of ASCII letters and underscores.\n-- The `repeat` forms apply to the adjacent `element`, and are as follows:\n-  - `?` means zero or one repetition\n-  - `*` means zero or more repetitions\n-  - `+` means one or more repetitions\n-  - NUMBER trailing a repeat symbol gives a maximum repetition count\n-  - NUMBER on its own gives an exact repetition count\n-\n-This EBNF dialect should hopefully be familiar to many readers.\n-\n ## Unicode productions\n \n A few productions in Rust's grammar permit Unicode code points outside the ASCII\n@@ -100,15 +65,12 @@ explicit code point lists. [^inputformat]\n   provided to the grammar verifier, restricted to ASCII range, when verifying the\n   grammar in this document.\n \n-## Special Unicode Productions\n-\n-The following productions in the Rust grammar are defined in terms of Unicode\n-properties: `ident`, `non_null`, `non_star`, `non_eol`, `non_slash_or_star`,\n-`non_single_quote` and `non_double_quote`.\n+## Identifiers\n \n-### Identifiers\n+An identifier is any nonempty Unicode[^non_ascii_idents] string of the following form:\n \n-The `ident` production is any nonempty Unicode string of the following form:\n+[^non_ascii_idents]: Non-ASCII characters in identifiers are currently feature\n+  gated. This is expected to improve soon.\n \n - The first character has property `XID_start`\n - The remaining characters have property `XID_continue`\n@@ -119,54 +81,34 @@ that does _not_ occur in the set of [keywords](#keywords).\n > character ranges used to form the more familiar C and Java language-family\n > identifiers.\n \n-### Delimiter-restricted productions\n-\n-Some productions are defined by exclusion of particular Unicode characters:\n-\n-- `non_null` is any single Unicode character aside from `U+0000` (null)\n-- `non_eol` is `non_null` restricted to exclude `U+000A` (`'\\n'`)\n-- `non_star` is `non_null` restricted to exclude `U+002A` (`*`)\n-- `non_slash_or_star` is `non_null` restricted to exclude `U+002F` (`/`) and `U+002A` (`*`)\n-- `non_single_quote` is `non_null` restricted to exclude `U+0027`  (`'`)\n-- `non_double_quote` is `non_null` restricted to exclude `U+0022` (`\"`)\n-\n ## Comments\n \n-```{.ebnf .gram}\n-comment : block_comment | line_comment ;\n-block_comment : \"/*\" block_comment_body * \"*/\" ;\n-block_comment_body : [block_comment | character] * ;\n-line_comment : \"//\" non_eol * ;\n-```\n-\n-Comments in Rust code follow the general C++ style of line and block-comment\n-forms. Nested block comments are supported.\n+Comments in Rust code follow the general C++ style of line (`//`) and\n+block (`/* ... */`) comment forms. Nested block comments are supported.\n \n Line comments beginning with exactly _three_ slashes (`///`), and block\n comments beginning with exactly one repeated asterisk in the block-open\n sequence (`/**`), are interpreted as a special syntax for `doc`\n [attributes](#attributes). That is, they are equivalent to writing\n-`#[doc=\"...\"]` around the body of the comment (this includes the comment\n-characters themselves, i.e. `/// Foo` turns into `#[doc=\"/// Foo\"]`).\n+`#[doc=\"...\"]` around the body of the comment, i.e., `/// Foo` turns into\n+`#[doc=\"Foo\"]`.\n \n Line comments beginning with `//!` and block comments beginning with `/*!` are\n doc comments that apply to the parent of the comment, rather than the item\n that follows.  That is, they are equivalent to writing `#![doc=\"...\"]` around\n-the body of the comment. `//!` comments are usually used to display\n-information on the crate index page.\n+the body of the comment. `//!` comments are usually used to document\n+modules that occupy a source file.\n \n Non-doc comments are interpreted as a form of whitespace.\n \n ## Whitespace\n \n-```{.ebnf .gram}\n-whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n-whitespace : [ whitespace_char | comment ] + ;\n-```\n+Whitespace is any non-empty string containing only the following characters:\n \n-The `whitespace_char` production is any nonempty Unicode string consisting of\n-any of the following Unicode characters: `U+0020` (space, `' '`), `U+0009`\n-(tab, `'\\t'`), `U+000A` (LF, `'\\n'`), `U+000D` (CR, `'\\r'`).\n+- `U+0020` (space, `' '`)\n+- `U+0009` (tab, `'\\t'`)\n+- `U+000A` (LF, `'\\n'`)\n+- `U+000D` (CR, `'\\r'`)\n \n Rust is a \"free-form\" language, meaning that all forms of whitespace serve only\n to separate _tokens_ in the grammar, and have no semantic significance.\n@@ -176,53 +118,18 @@ with any other legal whitespace element, such as a single space character.\n \n ## Tokens\n \n-```{.ebnf .gram}\n-simple_token : keyword | unop | binop ;\n-token : simple_token | ident | literal | symbol | whitespace token ;\n-```\n-\n Tokens are primitive productions in the grammar defined by regular\n (non-recursive) languages. \"Simple\" tokens are given in [string table\n production](#string-table-productions) form, and occur in the rest of the\n grammar as double-quoted strings. Other tokens have exact rules given.\n \n-### Keywords\n-\n-<p id=\"keyword-table-marker\"></p>\n-\n-|          |          |          |          |         |\n-|----------|----------|----------|----------|---------|\n-| abstract | alignof  | as       | become   | box     |\n-| break    | const    | continue | crate    | do      |\n-| else     | enum     | extern   | false    | final   |\n-| fn       | for      | if       | impl     | in      |\n-| let      | loop     | macro    | match    | mod     |\n-| move     | mut      | offsetof | override | priv    |\n-| proc     | pub      | pure     | ref      | return  |\n-| Self     | self     | sizeof   | static   | struct  |\n-| super    | trait    | true     | type     | typeof  |\n-| unsafe   | unsized  | use      | virtual  | where   |\n-| while    | yield    |          |          |         |\n-\n-\n-Each of these keywords has special meaning in its grammar, and all of them are\n-excluded from the `ident` rule.\n-\n-Note that some of these keywords are reserved, and do not currently do\n-anything.\n-\n ### Literals\n \n A literal is an expression consisting of a single token, rather than a sequence\n of tokens, that immediately and directly denotes the value it evaluates to,\n rather than referring to it by name or some other evaluation rule. A literal is\n a form of constant expression, so is evaluated (primarily) at compile time.\n \n-```{.ebnf .gram}\n-lit_suffix : ident;\n-literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit ] lit_suffix ?;\n-```\n-\n The optional suffix is only used for certain numeric literals, but is\n reserved for future extension, that is, the above gives the lexical\n grammar, but a Rust parser will reject everything but the 12 special\n@@ -275,32 +182,6 @@ cases mentioned in [Number literals](#number-literals) below.\n \n #### Character and string literals\n \n-```{.ebnf .gram}\n-char_lit : '\\x27' char_body '\\x27' ;\n-string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n-\n-char_body : non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape | unicode_escape ] ;\n-\n-string_body : non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape | unicode_escape ] ;\n-raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n-\n-common_escape : '\\x5c'\n-              | 'n' | 'r' | 't' | '0'\n-              | 'x' hex_digit 2\n-\n-unicode_escape : 'u' '{' hex_digit+ 6 '}';\n-\n-hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n-          | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n-          | dec_digit ;\n-oct_digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;\n-dec_digit : '0' | nonzero_dec ;\n-nonzero_dec: '1' | '2' | '3' | '4'\n-           | '5' | '6' | '7' | '8' | '9' ;\n-```\n-\n ##### Character literals\n \n A _character literal_ is a single Unicode character enclosed within two\n@@ -311,13 +192,13 @@ which must be _escaped_ by a preceding `U+005C` character (`\\`).\n \n A _string literal_ is a sequence of any Unicode characters enclosed within two\n `U+0022` (double-quote) characters, with the exception of `U+0022` itself,\n-which must be _escaped_ by a preceding `U+005C` character (`\\`), or a _raw\n-string literal_.\n+which must be _escaped_ by a preceding `U+005C` character (`\\`).\n \n-A multi-line string literal may be defined by terminating each line with a\n-`U+005C` character (`\\`) immediately before the newline. This causes the\n-`U+005C` character, the newline, and all whitespace at the beginning of the\n-next line to be ignored.\n+Line-break characters are allowed in string literals. Normally they represent\n+themselves (i.e. no translation), but as a special exception, when a `U+005C`\n+character (`\\`) occurs immediately before the newline, the `U+005C` character,\n+the newline, and all whitespace at the beginning of the next line are ignored.\n+Thus `a` and `b` are equal:\n \n ```rust\n let a = \"foobar\";\n@@ -349,11 +230,10 @@ following forms:\n \n Raw string literals do not process any escapes. They start with the character\n `U+0072` (`r`), followed by zero or more of the character `U+0023` (`#`) and a\n-`U+0022` (double-quote) character. The _raw string body_ is not defined in the\n-EBNF grammar above: it can contain any sequence of Unicode characters and is\n-terminated only by another `U+0022` (double-quote) character, followed by the\n-same number of `U+0023` (`#`) characters that preceded the opening `U+0022`\n-(double-quote) character.\n+`U+0022` (double-quote) character. The _raw string body_ can contain any sequence\n+of Unicode characters and is terminated only by another `U+0022` (double-quote)\n+character, followed by the same number of `U+0023` (`#`) characters that preceded\n+the opening `U+0022` (double-quote) character.\n \n All Unicode characters contained in the raw string body represent themselves,\n the characters `U+0022` (double-quote) (except when followed by at least as\n@@ -375,26 +255,14 @@ r##\"foo #\"# bar\"##;                // foo #\"# bar\n \n #### Byte and byte string literals\n \n-```{.ebnf .gram}\n-byte_lit : \"b\\x27\" byte_body '\\x27' ;\n-byte_string_lit : \"b\\x22\" string_body * '\\x22' | \"br\" raw_byte_string ;\n-\n-byte_body : ascii_non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape ] ;\n-\n-byte_string_body : ascii_non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape ] ;\n-raw_byte_string : '\"' raw_byte_string_body '\"' | '#' raw_byte_string '#' ;\n-\n-```\n-\n ##### Byte literals\n \n A _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F`\n-range) enclosed within two `U+0027` (single-quote) characters, with the\n-exception of `U+0027` itself, which must be _escaped_ by a preceding U+005C\n-character (`\\`), or a single _escape_. It is equivalent to a `u8` unsigned\n-8-bit integer _number literal_.\n+range) or a single _escape_ preceded by the characters `U+0062` (`b`) and\n+`U+0027` (single-quote), and followed by the character `U+0027`. If the character\n+`U+0027` is present within the literal, it must be _escaped_ by a preceding\n+`U+005C` (`\\`) character. It is equivalent to a `u8` unsigned 8-bit integer\n+_number literal_.\n \n ##### Byte string literals\n \n@@ -403,7 +271,7 @@ preceded by the characters `U+0062` (`b`) and `U+0022` (double-quote), and\n followed by the character `U+0022`. If the character `U+0022` is present within\n the literal, it must be _escaped_ by a preceding `U+005C` (`\\`) character.\n Alternatively, a byte string literal can be a _raw byte string literal_, defined\n-below. A byte string literal is equivalent to a `&'static [u8]` borrowed array\n+below. A byte string literal of length `n` is equivalent to a `&'static [u8; n]` borrowed fixed-sized array\n of unsigned 8-bit integers.\n \n Some additional _escapes_ are available in either byte or non-raw byte string\n@@ -424,11 +292,10 @@ following forms:\n Raw byte string literals do not process any escapes. They start with the\n character `U+0062` (`b`), followed by `U+0072` (`r`), followed by zero or more\n of the character `U+0023` (`#`), and a `U+0022` (double-quote) character. The\n-_raw string body_ is not defined in the EBNF grammar above: it can contain any\n-sequence of ASCII characters and is terminated only by another `U+0022`\n-(double-quote) character, followed by the same number of `U+0023` (`#`)\n-characters that preceded the opening `U+0022` (double-quote) character. A raw\n-byte string literal can not contain any non-ASCII byte.\n+_raw string body_ can contain any sequence of ASCII characters and is terminated\n+only by another `U+0022` (double-quote) character, followed by the same number of\n+`U+0023` (`#`) characters that preceded the opening `U+0022` (double-quote)\n+character. A raw byte string literal can not contain any non-ASCII byte.\n \n All characters contained in the raw string body represent their ASCII encoding,\n the characters `U+0022` (double-quote) (except when followed by at least as\n@@ -450,19 +317,6 @@ b\"\\\\x52\"; br\"\\x52\";                  // \\x52\n \n #### Number literals\n \n-```{.ebnf .gram}\n-num_lit : nonzero_dec [ dec_digit | '_' ] * float_suffix ?\n-        | '0' [       [ dec_digit | '_' ] * float_suffix ?\n-              | 'b'   [ '1' | '0' | '_' ] +\n-              | 'o'   [ oct_digit | '_' ] +\n-              | 'x'   [ hex_digit | '_' ] +  ] ;\n-\n-float_suffix : [ exponent | '.' dec_lit exponent ? ] ? ;\n-\n-exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n-dec_lit : [ dec_digit | '_' ] + ;\n-```\n-\n A _number literal_ is either an _integer literal_ or a _floating-point\n literal_. The grammar for recognizing the two kinds of literals is mixed.\n \n@@ -512,11 +366,19 @@ A _floating-point literal_ has one of two forms:\n   optionally followed by another decimal literal, with an optional _exponent_.\n * A single _decimal literal_ followed by an _exponent_.\n \n-By default, a floating-point literal has a generic type, and, like integer\n-literals, the type must be uniquely determined from the context. There are two valid\n+Like integer literals, a floating-point literal may be followed by a\n+suffix, so long as the pre-suffix part does not end with `U+002E` (`.`).\n+The suffix forcibly sets the type of the literal. There are two valid\n _floating-point suffixes_, `f32` and `f64` (the 32-bit and 64-bit floating point\n types), which explicitly determine the type of the literal.\n \n+The type of an _unsuffixed_ floating-point literal is determined by type\n+inference. If a floating-point type can be _uniquely_ determined from the\n+surrounding program context, the unsuffixed floating-point literal has that type.\n+If the program context underconstrains the type, it defaults to double-precision `f64`;\n+if the program context overconstrains the type, it is considered a static type\n+error.\n+\n Examples of floating-point literals of various forms:\n \n ```\n@@ -540,12 +402,6 @@ The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n-```{.ebnf .gram}\n-symbol : \"::\" | \"->\"\n-       | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n-       | ',' | ';' ;\n-```\n-\n Symbols are a general class of printable [token](#tokens) that play structural\n roles in a variety of grammar productions. They are catalogued here for\n completeness as the set of remaining miscellaneous printable tokens that do not\n@@ -555,16 +411,6 @@ operators](#binary-operator-expressions), or [keywords](#keywords).\n \n ## Paths\n \n-```{.ebnf .gram}\n-expr_path : [ \"::\" ] ident [ \"::\" expr_path_tail ] + ;\n-expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | expr_path ;\n-\n-type_path : ident [ type_path_tail ] + ;\n-type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | \"::\" type_path ;\n-```\n-\n A _path_ is a sequence of one or more path components _logically_ separated by\n a namespace qualifier (`::`). If a path consists of only one component, it may\n refer to either an [item](#items) or a [variable](#variables) in a local control\n@@ -660,19 +506,6 @@ Users of `rustc` can define new syntax extensions in two ways:\n \n ## Macros\n \n-```{.ebnf .gram}\n-expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ;\n-macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';' ;\n-matcher : '(' matcher * ')' | '[' matcher * ']'\n-        | '{' matcher * '}' | '$' ident ':' ident\n-        | '$' '(' matcher * ')' sep_token? [ '*' | '+' ]\n-        | non_special_token ;\n-transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n-            | '{' transcriber * '}' | '$' ident\n-            | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]\n-            | non_special_token ;\n-```\n-\n `macro_rules` allows users to define syntax extension in a declarative way.  We\n call such extensions \"macros by example\" or simply \"macros\" \u2014 to be distinguished\n from the \"procedural macros\" defined in [compiler plugins][plugin].\n@@ -811,12 +644,6 @@ Crates contain [items](#items), each of which may have some number of\n \n ## Items\n \n-```{.ebnf .gram}\n-item : extern_crate_decl | use_decl | mod_item | fn_item | type_item\n-     | struct_item | enum_item | static_item | trait_item | impl_item\n-     | extern_block ;\n-```\n-\n An _item_ is a component of a crate. Items are organized within a crate by a\n nested set of [modules](#modules). Every crate has a single \"outermost\"\n anonymous module; all further items within the crate have [paths](#paths)\n@@ -863,11 +690,6 @@ no notion of type abstraction: there are no first-class \"forall\" types.\n \n ### Modules\n \n-```{.ebnf .gram}\n-mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n-mod : item * ;\n-```\n-\n A module is a container for zero or more [items](#items).\n \n A _module item_ is a module, surrounded in braces, named, and prefixed with the\n@@ -928,11 +750,6 @@ mod thread {\n \n ##### Extern crate declarations\n \n-```{.ebnf .gram}\n-extern_crate_decl : \"extern\" \"crate\" crate_name\n-crate_name: ident | ( string_lit \"as\" ident )\n-```\n-\n An _`extern crate` declaration_ specifies a dependency on an external crate.\n The external crate is then bound into the declaring scope as the `ident`\n provided in the `extern_crate_decl`.\n@@ -958,17 +775,6 @@ extern crate std as ruststd; // linking to 'std' under another name\n \n ##### Use declarations\n \n-```{.ebnf .gram}\n-use_decl : \"pub\" ? \"use\" [ path \"as\" ident\n-                          | path_glob ] ;\n-\n-path_glob : ident [ \"::\" [ path_glob\n-                          | '*' ] ] ?\n-          | '{' path_item [ ',' path_item ] * '}' ;\n-\n-path_item : ident | \"self\" ;\n-```\n-\n A _use declaration_ creates one or more local name bindings synonymous with\n some other [path](#paths). Usually a `use` declaration is used to shorten the\n path required to refer to a module item. These declarations may appear at the\n@@ -1413,10 +1219,6 @@ it were `Bar(i32)`, this is disallowed.\n \n ### Constant items\n \n-```{.ebnf .gram}\n-const_item : \"const\" ident ':' type '=' expr ';' ;\n-```\n-\n A *constant item* is a named _constant value_ which is not associated with a\n specific memory location in the program. Constants are essentially inlined\n wherever they are used, meaning that they are copied directly into the relevant\n@@ -1453,10 +1255,6 @@ const BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n \n ### Static items\n \n-```{.ebnf .gram}\n-static_item : \"static\" ident ':' type '=' expr ';' ;\n-```\n-\n A *static item* is similar to a *constant*, except that it represents a precise\n memory location in the program. A static is never \"inlined\" at the usage site,\n and all references to it refer to the same memory location. Static items have\n@@ -1711,11 +1509,6 @@ impl Seq<bool> for u32 {\n \n ### External blocks\n \n-```{.ebnf .gram}\n-extern_block_item : \"extern\" '{' extern_block '}' ;\n-extern_block : [ foreign_fn ] * ;\n-```\n-\n External blocks form the basis for Rust's foreign function interface.\n Declarations in an external block describe symbols in external, non-Rust\n libraries.\n@@ -1915,13 +1708,6 @@ the namespace hierarchy as it normally would.\n \n ## Attributes\n \n-```{.ebnf .gram}\n-attribute : '#' '!' ? '[' meta_item ']' ;\n-meta_item : ident [ '=' literal\n-                  | '(' meta_seq ')' ] ? ;\n-meta_seq : meta_item [ ',' meta_seq ] ? ;\n-```\n-\n Any item declaration may have an _attribute_ applied to it. Attributes in Rust\n are modeled on Attributes in ECMA-335, with the syntax coming from ECMA-334\n (C#). An attribute is a general, free-form metadatum that is interpreted\n@@ -2111,8 +1897,8 @@ release builds.\n \n There are two kinds of configuration options, one that is either defined or not\n (`#[cfg(foo)]`), and the other that contains a string that can be checked\n-against (`#[cfg(bar = \"baz\")]` (currently only compiler-defined configuration\n-options can have the latter form).\n+against (`#[cfg(bar = \"baz\")]`). Currently, only compiler-defined configuration\n+options can have the latter form.\n \n ```\n // The function is only included in the build when compiling for OSX\n@@ -2188,7 +1974,7 @@ For any lint check `C`:\n \n The lint checks supported by the compiler can be found via `rustc -W help`,\n along with their default settings.  [Compiler\n-plugins](book/plugins.html#lint-plugins) can provide additional lint checks.\n+plugins](book/compiler-plugins.html#lint-plugins) can provide additional lint checks.\n \n ```{.ignore}\n mod m1 {\n@@ -2349,7 +2135,10 @@ The currently implemented features of the reference compiler are:\n           semantics are likely to change, so this macro usage must be opted\n           into.\n \n-* `associated_types` - Allows type aliases in traits. Experimental.\n+* `associated_consts` - Allows constants to be defined in `impl` and `trait`\n+                        blocks, so that they can be associated with a type or\n+                        trait in a similar manner to methods and associated\n+                        types.\n \n * `box_patterns` - Allows `box` patterns, the exact semantics of which\n                    is subject to change.\n@@ -2503,7 +2292,7 @@ The currently implemented features of the reference compiler are:\n                               terms of encapsulation).\n \n If a feature is promoted to a language feature, then all existing programs will\n-start to receive compilation warnings about #[feature] directives which enabled\n+start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a\n feature is decided to be removed from the language, errors will be issued (if\n there isn't a parser error first). The directive in this case is no longer\n@@ -2554,11 +2343,6 @@ in meaning to declaring the item outside the statement block.\n \n #### Variable declarations\n \n-```{.ebnf .gram}\n-let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n-init : [ '=' ] expr ;\n-```\n-\n A _variable declaration_ introduces a new set of variable, given by a pattern. The\n pattern may be followed by a type annotation, and/or an initializer expression.\n When no type annotation is given, the compiler will infer the type, or signal\n@@ -2649,7 +2433,7 @@ parentheses. They are used to create [tuple-typed](#tuple-types) values.\n ```{.tuple}\n (0,);\n (0.0, 4.5);\n-(\"a\", 4us, true);\n+(\"a\", 4usize, true);\n ```\n \n ### Unit expressions\n@@ -2659,15 +2443,6 @@ the same name.\n \n ### Structure expressions\n \n-```{.ebnf .gram}\n-struct_expr : expr_path '{' ident ':' expr\n-                      [ ',' ident ':' expr ] *\n-                      [ \"..\" expr ] '}' |\n-              expr_path '(' expr\n-                      [ ',' expr ] * ')' |\n-              expr_path ;\n-```\n-\n There are several forms of structure expressions. A _structure expression_\n consists of the [path](#paths) of a [structure item](#structures), followed by\n a brace-enclosed list of one or more comma-separated name-value pairs,\n@@ -2718,11 +2493,6 @@ Point3d {y: 0, z: 10, .. base};\n \n ### Block expressions\n \n-```{.ebnf .gram}\n-block_expr : '{' [ stmt ';' | item ] *\n-                 [ expr ] '}' ;\n-```\n-\n A _block expression_ is similar to a module in terms of the declarations that\n are possible. Each block conceptually introduces a new namespace scope. Use\n items can bring new names into scopes and declared items are in scope for only\n@@ -2745,10 +2515,6 @@ assert_eq!(5, x);\n \n ### Method-call expressions\n \n-```{.ebnf .gram}\n-method_call_expr : expr '.' ident paren_expr_list ;\n-```\n-\n A _method call_ consists of an expression followed by a single dot, an\n identifier, and a parenthesized expression-list. Method calls are resolved to\n methods on specific traits, either statically dispatching to a method if the\n@@ -2757,10 +2523,6 @@ the left-hand-side expression is an indirect [trait object](#trait-objects).\n \n ### Field expressions\n \n-```{.ebnf .gram}\n-field_expr : expr '.' ident ;\n-```\n-\n A _field expression_ consists of an expression followed by a single dot and an\n identifier, when not immediately followed by a parenthesized expression-list\n (the latter is a [method call expression](#method-call-expressions)). A field\n@@ -2781,12 +2543,6 @@ automatically dereferenced to make the field access possible.\n \n ### Array expressions\n \n-```{.ebnf .gram}\n-array_expr : '[' \"mut\" ? array_elems? ']' ;\n-\n-array_elems : [expr [',' expr]*] | [expr ';' expr] ;\n-```\n-\n An [array](#array,-and-slice-types) _expression_ is written by enclosing zero\n or more comma-separated expressions of uniform type in square brackets.\n \n@@ -2803,10 +2559,6 @@ constant expression that can be evaluated at compile time, such as a\n \n ### Index expressions\n \n-```{.ebnf .gram}\n-idx_expr : expr '[' expr ']' ;\n-```\n-\n [Array](#array,-and-slice-types)-typed expressions can be indexed by\n writing a square-bracket-enclosed expression (the index) after them. When the\n array is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can\n@@ -2823,13 +2575,6 @@ _panicked state_.\n \n ### Range expressions\n \n-```{.ebnf .gram}\n-range_expr : expr \"..\" expr |\n-             expr \"..\" |\n-             \"..\" expr |\n-             \"..\" ;\n-```\n-\n The `..` operator will construct an object of one of the `std::ops::Range` variants.\n \n ```\n@@ -2872,10 +2617,6 @@ before the expression they apply to.\n \n ### Binary operator expressions\n \n-```{.ebnf .gram}\n-binop_expr : expr binop expr ;\n-```\n-\n Binary operators expressions are given in terms of [operator\n precedence](#operator-precedence).\n \n@@ -3036,10 +2777,6 @@ An expression enclosed in parentheses evaluates to the result of the enclosed\n expression. Parentheses can be used to explicitly specify evaluation order\n within an expression.\n \n-```{.ebnf .gram}\n-paren_expr : '(' expr ')' ;\n-```\n-\n An example of a parenthesized expression:\n \n ```\n@@ -3049,12 +2786,6 @@ let x: i32 = (2 + 3) * 4;\n \n ### Call expressions\n \n-```{.ebnf .gram}\n-expr_list : [ expr [ ',' expr ]* ] ? ;\n-paren_expr_list : '(' expr_list ')' ;\n-call_expr : expr paren_expr_list ;\n-```\n-\n A _call expression_ invokes a function, providing zero or more input variables\n and an optional location to move the function's output into. If the function\n eventually returns, then the expression completes.\n@@ -3070,11 +2801,6 @@ let pi: Result<f32, _> = \"3.14\".parse();\n \n ### Lambda expressions\n \n-```{.ebnf .gram}\n-ident_list : [ ident [ ',' ident ]* ] ? ;\n-lambda_expr : '|' ident_list '|' expr ;\n-```\n-\n A _lambda expression_ (sometimes called an \"anonymous function expression\")\n defines a function and denotes it as a value, in a single expression. A lambda\n expression is a pipe-symbol-delimited (`|`) list of identifiers followed by an\n@@ -3118,10 +2844,6 @@ ten_times(|j| println!(\"hello, {}\", j));\n \n A `loop` expression denotes an infinite loop.\n \n-```{.ebnf .gram}\n-loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n-```\n-\n A `loop` expression may optionally have a _label_. The label is written as\n a lifetime preceding the loop expression, as in `'foo: loop{ }`. If a\n label is present, then labeled `break` and `continue` expressions nested\n@@ -3131,10 +2853,6 @@ expressions](#continue-expressions).\n \n ### Break expressions\n \n-```{.ebnf .gram}\n-break_expr : \"break\" [ lifetime ];\n-```\n-\n A `break` expression has an optional _label_. If the label is absent, then\n executing a `break` expression immediately terminates the innermost loop\n enclosing it. It is only permitted in the body of a loop. If the label is\n@@ -3143,10 +2861,6 @@ be the innermost label enclosing the `break` expression, but must enclose it.\n \n ### Continue expressions\n \n-```{.ebnf .gram}\n-continue_expr : \"continue\" [ lifetime ];\n-```\n-\n A `continue` expression has an optional _label_. If the label is absent, then\n executing a `continue` expression immediately terminates the current iteration\n of the innermost loop enclosing it, returning control to the loop *head*. In\n@@ -3160,10 +2874,6 @@ A `continue` expression is only permitted in the body of a loop.\n \n ### While loops\n \n-```{.ebnf .gram}\n-while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n A `while` loop begins by evaluating the boolean loop conditional expression.\n If the loop conditional expression evaluates to `true`, the loop body block\n executes and control returns to the loop conditional expression. If the loop\n@@ -3187,26 +2897,22 @@ loops](#infinite-loops), [break expressions](#break-expressions), and\n \n ### For expressions\n \n-```{.ebnf .gram}\n-for_expr : [ lifetime ':' ] \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n A `for` expression is a syntactic construct for looping over elements provided\n-by an implementation of `std::iter::Iterator`.\n+by an implementation of `std::iter::IntoIterator`.\n \n An example of a for loop over the contents of an array:\n \n ```\n # type Foo = i32;\n-# fn bar(f: Foo) { }\n+# fn bar(f: &Foo) { }\n # let a = 0;\n # let b = 0;\n # let c = 0;\n \n let v: &[Foo] = &[a, b, c];\n \n-for e in v.iter() {\n-    bar(*e);\n+for e in v {\n+    bar(e);\n }\n ```\n \n@@ -3226,14 +2932,6 @@ loops](#infinite-loops), [break expressions](#break-expressions), and\n \n ### If expressions\n \n-```{.ebnf .gram}\n-if_expr : \"if\" no_struct_literal_expr '{' block '}'\n-          else_tail ? ;\n-\n-else_tail : \"else\" [ if_expr | if_let_expr\n-                   | '{' block '}' ] ;\n-```\n-\n An `if` expression is a conditional branch in program control. The form of an\n `if` expression is a condition expression, followed by a consequent block, any\n number of `else if` conditions and blocks, and an optional trailing `else`\n@@ -3246,14 +2944,6 @@ if` condition is evaluated. If all `if` and `else if` conditions evaluate to\n \n ### Match expressions\n \n-```{.ebnf .gram}\n-match_expr : \"match\" no_struct_literal_expr '{' match_arm * '}' ;\n-\n-match_arm : attribute * match_pat \"=>\" [ expr \",\" | '{' block '}' ] ;\n-\n-match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n-```\n-\n A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n literals, destructured arrays or enum constructors, structures and tuples,\n@@ -3370,23 +3060,13 @@ let message = match maybe_digit {\n \n ### If let expressions\n \n-```{.ebnf .gram}\n-if_let_expr : \"if\" \"let\" pat '=' expr '{' block '}'\n-               else_tail ? ;\n-else_tail : \"else\" [ if_expr | if_let_expr | '{' block '}' ] ;\n-```\n-\n An `if let` expression is semantically identical to an `if` expression but in place\n of a condition expression it expects a refutable let statement. If the value of the\n expression on the right hand side of the let statement matches the pattern, the corresponding\n block will execute, otherwise flow proceeds to the first `else` block that follows.\n \n ### While let loops\n \n-```{.ebnf .gram}\n-while_let_expr : \"while\" \"let\" pat '=' expr '{' block '}' ;\n-```\n-\n A `while let` loop is semantically identical to a `while` loop but in place of a\n condition expression it expects a refutable let statement. If the value of the\n expression on the right hand side of the let statement matches the pattern, the\n@@ -3395,10 +3075,6 @@ Otherwise, the while expression completes.\n \n ### Return expressions\n \n-```{.ebnf .gram}\n-return_expr : \"return\" expr ? ;\n-```\n-\n Return expressions are denoted with the keyword `return`. Evaluating a `return`\n expression moves its argument into the designated output location for the\n current function call, destroys the current function activation frame, and\n@@ -3971,4 +3647,4 @@ that have since been removed):\n   pattern syntax\n \n [ffi]: book/ffi.html\n-[plugin]: book/plugins.html\n+[plugin]: book/compiler-plugins.html"}, {"sha": "dbbe9fc3ac6da92602304f64de31b07afa01e80a", "filename": "src/doc/style/testing/unit.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1,10 +1,10 @@\n % Unit testing\n \n-Unit tests should live in a `test` submodule at the bottom of the module they\n-test. Mark the `test` submodule with `#[cfg(test)]` so it is only compiled when\n+Unit tests should live in a `tests` submodule at the bottom of the module they\n+test. Mark the `tests` submodule with `#[cfg(test)]` so it is only compiled when\n testing.\n \n-The `test` module should contain:\n+The `tests` module should contain:\n \n * Imports needed only for testing.\n * Functions marked with `#[test]` striving for full coverage of the parent module's\n@@ -17,7 +17,7 @@ For example:\n // Excerpt from std::str\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     #[test]\n     fn test_eq() {\n         assert!((eq(&\"\".to_owned(), &\"\".to_owned())));"}, {"sha": "280665af787423b67abbce2ffddc9e4962e63742", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -8,7 +8,7 @@ good at: embedding in other languages, programs with specific space and time\n requirements, and writing low-level code, like device drivers and operating\n systems. It improves on current languages targeting this space by having a\n number of compile-time safety checks that produce no runtime overhead, while\n-eliminating all data races. Rust also aims to achieve \u2018zero-cost abstrations\u2019\n+eliminating all data races. Rust also aims to achieve \u2018zero-cost abstractions\u2019\n even though some of these abstractions feel like those of a high-level\n language. Even then, Rust still allows precise control like a low-level\n language would.\n@@ -127,7 +127,7 @@ vector. When we try to compile this program, we get an error:\n \n ```text\n error: cannot borrow `x` as mutable because it is also borrowed as immutable\n-    x.push(4);\n+    x.push(\"foo\");\n     ^\n note: previous borrow of `x` occurs here; the immutable borrow prevents\n subsequent moves or mutable borrows of `x` until the borrow ends"}, {"sha": "695dc42cb6418a7d9694fe07f48235009bcf8c5d", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -36,7 +36,6 @@\n     * [Strings](strings.md)\n     * [Generics](generics.md)\n     * [Traits](traits.md)\n-    * [Operators and Overloading](operators-and-overloading.md)\n     * [Drop](drop.md)\n     * [if let](if-let.md)\n     * [Trait Objects](trait-objects.md)\n@@ -50,6 +49,7 @@\n     * [Casting between types](casting-between-types.md)\n     * [Associated Types](associated-types.md)\n     * [Unsized Types](unsized-types.md)\n+    * [Operators and Overloading](operators-and-overloading.md)\n     * [Deref coercions](deref-coercions.md)\n     * [Macros](macros.md)\n     * [Raw Pointers](raw-pointers.md)"}, {"sha": "887965375932b3fe4953179a96d4dd54ec23c32e", "filename": "src/doc/trpl/benchmark-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,7 +13,7 @@ pub fn add_two(a: i32) -> i32 {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use super::*;\n     use test::Bencher;\n "}, {"sha": "d7fa84761e5271e770d29d671b46c23f555e0ac5", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -294,7 +294,7 @@ is `Fn(i32) -> i32`.\n \n There\u2019s one other key point here: because we\u2019re bounding a generic with a\n trait, this will get monomorphized, and therefore, we\u2019ll be doing static\n-dispatch into the closure. That\u2019s pretty neat. In many langauges, closures are\n+dispatch into the closure. That\u2019s pretty neat. In many languages, closures are\n inherently heap allocated, and will always involve dynamic dispatch. In Rust,\n we can stack allocate our closure environment, and statically dispatch the\n call. This happens quite often with iterators and their adapters, which often"}, {"sha": "57cbb6213963a9dff2fe4688912122767926c59b", "filename": "src/doc/trpl/const-and-static.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fconst-and-static.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fconst-and-static.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconst-and-static.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -66,6 +66,8 @@ unsafe {\n }\n ```\n \n+[unsafe]: unsafe.html\n+\n Furthermore, any type stored in a `static` must be `Sync`.\n \n # Initializing"}, {"sha": "b7011100971a88a8a4b96bad37bf7934a9714080", "filename": "src/doc/trpl/deref-coercions.md", "status": "modified", "additions": 117, "deletions": 1, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fderef-coercions.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1,3 +1,119 @@\n % `Deref` coercions\n \n-Coming soon!\n+The standard library provides a special trait, [`Deref`][deref]. It\u2019s normally\n+used to overload `*`, the dereference operator:\n+\n+```rust\n+use std::ops::Deref;\n+\n+struct DerefExample<T> {\n+    value: T,\n+}\n+\n+impl<T> Deref for DerefExample<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.value\n+    }\n+}\n+\n+fn main() {\n+    let x = DerefExample { value: 'a' };\n+    assert_eq!('a', *x);\n+}\n+```\n+\n+[deref]: ../std/ops/trait.Deref.html\n+\n+This is useful for writing custom pointer types. However, there\u2019s a language\n+feature related to `Deref`: \u2018deref coercions\u2019. Here\u2019s the rule: If you have a\n+type `U`, and it implements `Deref<Target=T>`, values of `&U` will\n+automatically coerce to a `&T`. Here\u2019s an example:\n+\n+```rust\n+fn foo(s: &str) {\n+    // borrow a string for a second\n+}\n+\n+// String implements Deref<Target=str>\n+let owned = \"Hello\".to_string();\n+\n+// therefore, this works:\n+foo(&owned);\n+```\n+\n+Using an ampersand in front of a value takes a reference to it. So `owned` is a\n+`String`, `&owned` is an `&String`, and since `impl Deref<Target=str> for\n+String`, `&String` will deref to `&str`, which `foo()` takes.\n+\n+That\u2019s it. This rule is one of the only places in which Rust does an automatic\n+conversion for you, but it adds a lot of flexibility. For example, the `Rc<T>`\n+type implements `Deref<Target=T>`, so this works:\n+\n+```rust\n+use std::rc::Rc;\n+\n+fn foo(s: &str) {\n+    // borrow a string for a second\n+}\n+\n+// String implements Deref<Target=str>\n+let owned = \"Hello\".to_string();\n+let counted = Rc::new(owned);\n+\n+// therefore, this works:\n+foo(&counted);\n+```\n+\n+All we\u2019ve done is wrap our `String` in an `Rc<T>`. But we can now pass the\n+`Rc<String>` around anywhere we\u2019d have a `String`. The signature of `foo`\n+didn\u2019t change, but works just as well with either type. This example has two\n+conversions: `Rc<String>` to `String` and then `String` to `&str`. Rust will do\n+this as many times as possible until the types match.\n+\n+Another very common implementation provided by the standard library is:\n+\n+```rust\n+fn foo(s: &[i32]) {\n+    // borrow a slice for a second\n+}\n+\n+// Vec<T> implements Deref<Target=[T]>\n+let owned = vec![1, 2, 3];\n+\n+foo(&owned);\n+```\n+\n+Vectors can `Deref` to a slice.\n+\n+## Deref and method calls\n+\n+`Deref` will also kick in when calling a method. In other words, these are\n+the same two things in Rust:\n+\n+```rust\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self) { println!(\"Foo\"); }\n+}\n+\n+let f = Foo;\n+\n+f.foo();\n+```\n+\n+Even though `f` isn\u2019t a reference, and `foo` takes `&self`, this works.\n+That\u2019s because these things are the same:\n+\n+```rust,ignore\n+f.foo();\n+(&f).foo();\n+(&&f).foo();\n+(&&&&&&&&f).foo();\n+```\n+\n+A value of type `&&&&&&&&&&&&&&&&Foo` can still have methods defined on `Foo`\n+called, because the compiler will insert as many * operations as necessary to\n+get it right. And since it\u2019s inserting `*`s, that uses `Deref`."}, {"sha": "b28343e7fb94c75f7acd8d654bad07c4098720b1", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -556,7 +556,7 @@ This sets a few different options, with a logo, favicon, and a root URL.\n \n ## Generation options\n \n-`rustdoc` also contains a few other options on the command line, for further customiziation:\n+`rustdoc` also contains a few other options on the command line, for further customization:\n \n - `--html-in-header FILE`: includes the contents of FILE at the end of the\n   `<head>...</head>` section."}, {"sha": "d0825e543f2c288c678515ad8115d17b28ed1b0d", "filename": "src/doc/trpl/getting-started.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgetting-started.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1,5 +1,5 @@\n % Getting Started\n \n This first section of the book will get you going with Rust and its tooling.\n-First, we\u2019ll install Rust. Then: the classic \u2018Hello World\u2019 program. Finally,\n+First, we\u2019ll install Rust. Then, the classic \u2018Hello World\u2019 program. Finally,\n we\u2019ll talk about Cargo, Rust\u2019s build system and package manager."}, {"sha": "9845fcbdcd173ec3d6b3543bb2fba9689cf5727e", "filename": "src/doc/trpl/glossary.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fglossary.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fglossary.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fglossary.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -19,7 +19,7 @@ In the example above `x` and `y` have arity 2. `z` has arity 3.\n \n When a compiler is compiling your program, it does a number of different\n things. One of the things that it does is turn the text of your program into an\n-'abstract syntax tree,' or 'AST.' This tree is a representation of the\n+\u2018abstract syntax tree\u2019, or\u2018AST\u2019. This tree is a representation of the\n structure of your program. For example, `2 + 3` can be turned into a tree:\n \n ```text"}, {"sha": "d547451fccec2e551193a062e906c5da3de7971d", "filename": "src/doc/trpl/hello-cargo.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -32,6 +32,13 @@ $ mkdir src\n $ mv main.rs src/main.rs\n ```\n \n+Note that since we're creating an executable, we used `main.rs`. If we\n+want to make a library instead, we should use `lib.rs`.\n+Custom file locations for the entry point can be specified\n+with a [`[[lib]]` or `[[bin]]`][crates-custom] key in the TOML file described below.\n+\n+[crates-custom]: http://doc.crates.io/manifest.html#configuring-a-target\n+\n Cargo expects your source files to live inside a `src` directory. That leaves\n the top level for other things, like READMEs, license information, and anything\n not related to your code. Cargo helps us keep our projects nice and tidy. A"}, {"sha": "d504fab206ddfd185d65c4b6362e5395eb8b7e9b", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -765,7 +765,7 @@ as `unimplemented!` until you\u2019re ready to write them.\n # Procedural macros\n \n If Rust\u2019s macro system can\u2019t do what you need, you may want to write a\n-[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n+[compiler plugin](compiler-plugins.html) instead. Compared to `macro_rules!`\n macros, this is significantly more work, the interfaces are much less stable,\n and bugs can be much harder to track down. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax"}, {"sha": "1445d39fe873876f48632571c306282c8f1eb155", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -18,7 +18,7 @@ foo.bar().baz();\n Luckily, as you may have guessed with the leading question, you can! Rust provides\n the ability to use this \u2018method call syntax\u2019 via the `impl` keyword.\n \n-## Method calls\n+# Method calls\n \n Here\u2019s how it works:\n \n@@ -83,7 +83,7 @@ impl Circle {\n }\n ```\n \n-## Chaining method calls\n+# Chaining method calls\n \n So, now we know how to call a method, such as `foo.bar()`. But what about our\n original example, `foo.bar().baz()`? This is called \u2018method chaining\u2019, and we\n@@ -127,7 +127,7 @@ fn grow(&self) -> Circle {\n We just say we\u2019re returning a `Circle`. With this method, we can grow a new\n circle to any arbitrary size.\n \n-## Static methods\n+# Static methods\n \n You can also define methods that do not take a `self` parameter. Here\u2019s a\n pattern that\u2019s very common in Rust code:\n@@ -158,7 +158,7 @@ This \u2018static method\u2019 builds a new `Circle` for us. Note that static methods\n are called with the `Struct::method()` syntax, rather than the `ref.method()`\n syntax.\n \n-## Builder Pattern\n+# Builder Pattern\n \n Let\u2019s say that we want our users to be able to create Circles, but we will\n allow them to only set the properties they care about. Otherwise, the `x`"}, {"sha": "816bfb17970619374a2147deddecc16fad7cb920", "filename": "src/doc/trpl/mutability.md", "status": "modified", "additions": 177, "deletions": 1, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmutability.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1,3 +1,179 @@\n % Mutability\n \n-Coming Soon\n+Mutability, the ability to change something, works a bit differently in Rust\n+than in other languages. The first aspect of mutability is its non-default\n+status:\n+\n+```rust,ignore\n+let x = 5;\n+x = 6; // error!\n+```\n+\n+We can introduce mutability with the `mut` keyword:\n+\n+```rust\n+let mut x = 5;\n+\n+x = 6; // no problem!\n+```\n+\n+This is a mutable [variable binding][vb]. When a binding is mutable, it means\n+you\u2019re allowed to change what the binding points to. So in the above example,\n+it\u2019s not so much that the value at `x` is changing, but that the binding\n+changed from one `i32` to another.\n+\n+[vb]: variable-bindings.html\n+\n+If you want to change what the binding points to, you\u2019ll need a [mutable reference][mr]:\n+\n+```rust\n+let mut x = 5;\n+let y = &mut x;\n+```\n+\n+[mr]: references-and-borrowing.html\n+\n+`y` is an immutable binding to a mutable reference, which means that you can\u2019t\n+bind `y` to something else (`y = &mut z`), but you can mutate the thing that\u2019s\n+bound to `y`. (`*y = 5`) A subtle distinction.\n+\n+Of course, if you need both:\n+\n+```rust\n+let mut x = 5;\n+let mut y = &mut x;\n+```\n+\n+Now `y` can be bound to another value, and the value it\u2019s referencing can be\n+changed.\n+\n+It\u2019s important to note that `mut` is part of a [pattern][pattern], so you\n+can do things like this:\n+\n+```rust\n+let (mut x, y) = (5, 6);\n+\n+fn foo(mut x: i32) {\n+# }\n+```\n+\n+[pattern]: patterns.html\n+\n+# Interior vs. Exterior Mutability\n+\n+However, when we say something is \u2018immutable\u2019 in Rust, that doesn\u2019t mean that\n+it\u2019s not able to be changed: We mean something has \u2018exterior mutability\u2019. Consider,\n+for example, [`Arc<T>`][arc]:\n+\n+```rust\n+use std::sync::Arc;\n+\n+let x = Arc::new(5);\n+let y = x.clone();\n+```\n+\n+[arc]: ../std/sync/struct.Arc.html\n+\n+When we call `clone()`, the `Arc<T>` needs to update the reference count. Yet\n+we\u2019ve not used any `mut`s here, `x` is an immutable binding, and we didn\u2019t take\n+`&mut 5` or anything. So what gives?\n+\n+To this, we have to go back to the core of Rust\u2019s guiding philosophy, memory\n+safety, and the mechanism by which Rust guarantees it, the\n+[ownership][ownership] system, and more specifically, [borrowing][borrowing]:\n+\n+> You may have one or the other of these two kinds of borrows, but not both at\n+> the same time:\n+> \n+> * 0 to N references (`&T`) to a resource.\n+> * exactly one mutable reference (`&mut T`)\n+\n+[ownership]: ownership.html\n+[borrowing]: borrowing.html#The-Rules\n+\n+So, that\u2019s the real definition of \u2018immutability\u2019: is this safe to have two\n+pointers to? In `Arc<T>`\u2019s case, yes: the mutation is entirely contained inside\n+the structure itself. It\u2019s not user facing. For this reason, it hands out `&T`\n+with `clone()`. If it handed out `&mut T`s, though, that would be a problem.\n+\n+Other types, like the ones in the [`std::cell`][stdcell] module, have the\n+opposite: interior mutability. For example:\n+\n+```rust\n+use std::cell::RefCell;\n+\n+let x = RefCell::new(42);\n+\n+let y = x.borrow_mut();\n+```\n+\n+[stdcell]: ../std/cell/index.html\n+\n+RefCell hands out `&mut` references to what\u2019s inside of it with the\n+`borrow_mut()` method. Isn\u2019t that dangerous? What if we do:\n+\n+```rust,ignore\n+use std::cell::RefCell;\n+\n+let x = RefCell::new(42);\n+\n+let y = x.borrow_mut();\n+let z = x.borrow_mut();\n+# (y, z);\n+```\n+\n+This will in fact panic, at runtime. This is what `RefCell` does: it enforces\n+Rust\u2019s borrowing rules at runtime, and `panic!`s if they\u2019re violated. This\n+allows us to get around another aspect of Rust\u2019s mutability rules. Let\u2019s talk\n+about it first.\n+\n+## Field-level mutability\n+\n+Mutability is a property of either a borrow (`&mut`) or a binding (`let mut`).\n+This means that, for example, you cannot have a [`struct`][struct] with\n+some fields mutable and some immutable:\n+\n+```rust,ignore\n+struct Point {\n+    x: i32,\n+    mut y: i32, // nope\n+}\n+```\n+\n+The mutability of a struct is in its binding:\n+\n+```rust,ignore\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+let mut a = Point { x: 5, y: 6 };\n+\n+a.x = 10;\n+\n+let b = Point { x: 5, y: 6};\n+\n+b.x = 10; // error: cannot assign to immutable field `b.x`\n+```\n+\n+[struct]: structs.html\n+\n+However, by using `Cell<T>`, you can emulate field-level mutability:\n+\n+```\n+use std::cell::Cell;\n+\n+struct Point {\n+    x: i32,\n+    y: Cell<i32>,\n+}\n+\n+let mut point = Point { x: 5, y: Cell::new(6) };\n+\n+point.y.set(7);\n+\n+println!(\"y: {:?}\", point.y);\n+```\n+\n+This will print `y: Cell { value: 7 }`. We\u2019ve successfully updated `y`."}, {"sha": "6a594659c37d27617cc7899c542de54977c21f9a", "filename": "src/doc/trpl/operators-and-overloading.md", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1,3 +1,83 @@\n % Operators and Overloading\n \n-Coming soon!\n+Rust allows for a limited form of operator overloading. There are certain\n+operators that are able to be overloaded. To support a particular operator\n+between types, there\u2019s a specific trait that you can implement, which then\n+overloads the operator.\n+\n+For example, the `+` operator can be overloaded with the `Add` trait:\n+\n+```rust\n+use std::ops::Add;\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+impl Add for Point {\n+    type Output = Point;\n+\n+    fn add(self, other: Point) -> Point {\n+        Point { x: self.x + other.x, y: self.y + other.y }\n+    }\n+}\n+\n+fn main() {\n+    let p1 = Point { x: 1, y: 0 };\n+    let p2 = Point { x: 2, y: 3 };\n+\n+    let p3 = p1 + p2;\n+\n+    println!(\"{:?}\", p3);\n+}\n+```\n+\n+In `main`, we can use `+` on our two `Point`s, since we\u2019ve implemented\n+`Add<Output=Point>` for `Point`.\n+\n+There are a number of operators that can be overloaded this way, and all of\n+their associated traits live in the [`std::ops`][stdops] module. Check out its\n+documentation for the full list.\n+\n+[stdops]: ../std/ops/index.html\n+\n+Implementing these traits follows a pattern. Let\u2019s look at [`Add`][add] in more\n+detail:\n+\n+```rust\n+# mod foo {\n+pub trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+# }\n+```\n+\n+[add]: ../std/ops/trait.Add.html\n+\n+There\u2019s three types in total involved here: the type you `impl Add` for, `RHS`,\n+which defaults to `Self`, and `Output`. For an expression `let z = x + y`, `x`\n+is the `Self` type, `y` is the RHS, and `z` is the `Self::Output` type.\n+\n+```rust\n+# struct Point;\n+# use std::ops::Add;\n+impl Add<i32> for Point {\n+    type Output = f64;\n+\n+    fn add(self, rhs: i32) -> f64 {\n+        // add an i32 to a Point and get an f64\n+# 1.0\n+    }\n+}\n+```\n+\n+will let you do this:\n+\n+```rust,ignore\n+let p: Point = // ...\n+let x: f64 = p + 2i32;\n+```"}, {"sha": "aca6e327c3bce07f5d0626faaa162b9ba7623d40", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -62,14 +62,14 @@ let y = 1.0; // y has type f64\n Here\u2019s a list of the different numeric types, with links to their documentation\n in the standard library:\n \n+* [i8](../std/primitive.i8.html)\n * [i16](../std/primitive.i16.html)\n * [i32](../std/primitive.i32.html)\n * [i64](../std/primitive.i64.html)\n-* [i8](../std/primitive.i8.html)\n+* [u8](../std/primitive.u8.html)\n * [u16](../std/primitive.u16.html)\n * [u32](../std/primitive.u32.html)\n * [u64](../std/primitive.u64.html)\n-* [u8](../std/primitive.u8.html)\n * [isize](../std/primitive.isize.html)\n * [usize](../std/primitive.usize.html)\n * [f32](../std/primitive.f32.html)\n@@ -82,12 +82,12 @@ Let\u2019s go over them by category:\n Integer types come in two varieties: signed and unsigned. To understand the\n difference, let\u2019s consider a number with four bits of size. A signed, four-bit\n number would let you store numbers from `-8` to `+7`. Signed numbers use\n-\u2018two\u2019s compliment representation\u2019. An unsigned four bit number, since it does\n+\u201ctwo\u2019s compliment representation\u201d. An unsigned four bit number, since it does\n not need to store negatives, can store values from `0` to `+15`.\n \n Unsigned types use a `u` for their category, and signed types use `i`. The `i`\n is for \u2018integer\u2019. So `u8` is an eight-bit unsigned number, and `i8` is an\n-eight-bit signed number. \n+eight-bit signed number.\n \n ## Fixed size types\n \n@@ -103,7 +103,7 @@ and unsigned varieties. This makes for two types: `isize` and `usize`.\n \n ## Floating-point types\n \n-Rust also two floating point types: `f32` and `f64`. These correspond to \n+Rust also has two floating point types: `f32` and `f64`. These correspond to\n IEEE-754 single and double precision numbers.\n \n # Arrays\n@@ -241,8 +241,8 @@ println!(\"x is {}\", x);\n Remember [before][let] when I said the left-hand side of a `let` statement was more\n powerful than just assigning a binding? Here we are. We can put a pattern on\n the left-hand side of the `let`, and if it matches up to the right-hand side,\n-we can assign multiple bindings at once. In this case, `let` \"destructures,\"\n-or \"breaks up,\" the tuple, and assigns the bits to three bindings.\n+we can assign multiple bindings at once. In this case, `let` \u201cdestructures\u201d\n+or \u201cbreaks up\u201d the tuple, and assigns the bits to three bindings.\n \n [let]: variable-bindings.html\n "}, {"sha": "45f87a6740597c6ac892c8732b3df881b16d7b42", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -219,10 +219,10 @@ fn it_works() {\n This is a very common use of `assert_eq!`: call some function with\n some known arguments and compare it to the expected output.\n \n-# The `test` module\n+# The `tests` module\n \n There is one way in which our existing example is not idiomatic: it's\n-missing the test module. The idiomatic way of writing our example\n+missing the `tests` module. The idiomatic way of writing our example\n looks like this:\n \n ```{rust,ignore}\n@@ -231,7 +231,7 @@ pub fn add_two(a: i32) -> i32 {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use super::add_two;\n \n     #[test]\n@@ -241,7 +241,7 @@ mod test {\n }\n ```\n \n-There's a few changes here. The first is the introduction of a `mod test` with\n+There's a few changes here. The first is the introduction of a `mod tests` with\n a `cfg` attribute. The module allows us to group all of our tests together, and\n to also define helper functions if needed, that don't become a part of the rest\n of our crate. The `cfg` attribute only compiles our test code if we're\n@@ -260,7 +260,7 @@ pub fn add_two(a: i32) -> i32 {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use super::*;\n \n     #[test]\n@@ -279,7 +279,7 @@ $ cargo test\n      Running target/adder-91b3e234d4ed382a\n \n running 1 test\n-test test::it_works ... ok\n+test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -292,7 +292,7 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n \n It works!\n \n-The current convention is to use the `test` module to hold your \"unit-style\"\n+The current convention is to use the `tests` module to hold your \"unit-style\"\n tests. Anything that just tests one small bit of functionality makes sense to\n go here. But what about \"integration-style\" tests instead? For that, we have\n the `tests` directory\n@@ -325,7 +325,7 @@ $ cargo test\n      Running target/adder-91b3e234d4ed382a\n \n running 1 test\n-test test::it_works ... ok\n+test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -346,7 +346,7 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n Now we have three sections: our previous test is also run, as well as our new\n one.\n \n-That's all there is to the `tests` directory. The `test` module isn't needed\n+That's all there is to the `tests` directory. The `tests` module isn't needed\n here, since the whole thing is focused on tests.\n \n Let's finally check out that third section: documentation tests.\n@@ -382,7 +382,7 @@ pub fn add_two(a: i32) -> i32 {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use super::*;\n \n     #[test]\n@@ -405,7 +405,7 @@ $ cargo test\n      Running target/adder-91b3e234d4ed382a\n \n running 1 test\n-test test::it_works ... ok\n+test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n "}, {"sha": "c01129057418cf1af9db4d73fb37ed52d4133f19", "filename": "src/doc/trpl/trait-objects.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftrait-objects.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -155,7 +155,7 @@ A function that takes a trait object is not specialized to each of the types\n that implements `Foo`: only one copy is generated, often (but not always)\n resulting in less code bloat. However, this comes at the cost of requiring\n slower virtual function calls, and effectively inhibiting any chance of\n-inlining and related optimisations from occurring.\n+inlining and related optimizations from occurring.\n \n ### Why pointers?\n "}, {"sha": "ea5d2ed711fed0f0aac66be1db7c909014ff5339", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -184,7 +184,7 @@ won\u2019t have its methods:\n ```rust,ignore\n let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n let result = f.write(\"whatever\".as_bytes());\n-# result.unwrap(); // ignore the erorr\n+# result.unwrap(); // ignore the error\n ```\n \n Here\u2019s the error:\n@@ -203,7 +203,7 @@ use std::io::Write;\n \n let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n let result = f.write(\"whatever\".as_bytes());\n-# result.unwrap(); // ignore the erorr\n+# result.unwrap(); // ignore the error\n ```\n \n This will compile without error."}, {"sha": "2353c63a606af070be774e1e9bb2ccb5de1142f5", "filename": "src/doc/trpl/ufcs.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fufcs.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fufcs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fufcs.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -89,7 +89,7 @@ not, and so we need to pass an explicit `&b`.\n The form of UFCS we just talked about:\n \n ```rust,ignore\n-Type::method(args);\n+Trait::method(args);\n ```\n \n Is a short-hand. There\u2019s an expanded form of this that\u2019s needed in some"}, {"sha": "2166c046897f0a56da8c299dbd95a737a3dda291", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1,6 +1,6 @@\n % Variable Bindings\n \n-Vitually every non-\u2019Hello World\u2019 Rust program uses *variable bindings*. They\n+Virtually every non-'Hello World\u2019 Rust program uses *variable bindings*. They\n look like this:\n \n ```rust"}, {"sha": "6170bdb86eaa3a7843dc89af9a47260395cdb778", "filename": "src/doc/trpl/vectors.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fdoc%2Ftrpl%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvectors.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1,8 +1,9 @@\n % Vectors\n \n A \u2018vector\u2019 is a dynamic or \u2018growable\u2019 array, implemented as the standard\n-library type [`Vec<T>`][vec]. That `<T>` is a [generic][generic], meaning we\n-can have vectors of any type. Vectors always allocate their data on the heap.\n+library type [`Vec<T>`][vec]. The `T` means that we can have vectors\n+of any type (see the chapter on [generics][generic] for more).\n+Vectors always allocate their data on the heap.\n You can create them with the `vec!` macro:\n \n ```rust\n@@ -56,3 +57,4 @@ Vectors have many more useful methods, which you can read about in [their\n API documentation][vec].\n \n [vec]: ../std/vec/index.html\n+[generic]: generics.html"}, {"sha": "27e15bc2f0eeaa044a8e7a8dd301e232c28e3b3e", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -505,10 +505,20 @@ trait_items\n ;\n \n trait_item\n-: trait_type\n+: trait_const\n+| trait_type\n | trait_method\n ;\n \n+trait_const\n+: maybe_outer_attrs CONST ident maybe_const_default ';' { $$ = mk_node(\"ConstTraitItem\", 3, $1, $3, $4); }\n+;\n+\n+maybe_const_default\n+: '=' expr { $$ = mk_node(\"ConstDefault\", 1, $2); }\n+| %empty   { $$ = mk_none(); }\n+;\n+\n trait_type\n : maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n ;\n@@ -611,7 +621,16 @@ impl_items\n impl_item\n : impl_method\n | item_macro\n-| trait_type\n+| impl_const\n+| impl_type\n+;\n+\n+impl_const\n+: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n+;\n+\n+impl_type\n+: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n ;\n \n item_fn"}, {"sha": "ab7030bee1554a52bccddfc7c2213d222fbeef23", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -355,7 +355,6 @@ impl<T: Clone> Arc<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n@@ -489,7 +488,6 @@ impl<T> Clone for Weak<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`."}, {"sha": "86a04a0687a5bb11b92aa8748c5556f24b520709", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -211,7 +211,9 @@ mod imp {\n     }\n \n     // -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n-    #[cfg(all(not(windows), not(target_os = \"android\")))]\n+    #[cfg(all(not(windows),\n+              not(target_os = \"android\"),\n+              not(target_env = \"musl\")))]\n     #[link(name = \"pthread\")]\n     extern {}\n \n@@ -384,7 +386,7 @@ mod imp {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use boxed::Box;"}, {"sha": "c0974dcb2a0f06180518f1baaf4113aa8f8fb83d", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -73,7 +73,7 @@\n #![feature(allocator)]\n #![feature(custom_attribute)]\n #![feature(fundamental)]\n-#![feature(lang_items, unsafe_destructor)]\n+#![feature(lang_items)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n #![feature(unboxed_closures)]"}, {"sha": "015d0330ed72d79f58257604fb6339295525e15f", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -375,7 +375,6 @@ impl<T> Deref for Rc<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n@@ -693,7 +692,6 @@ impl<T> Weak<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`."}, {"sha": "adfcca14d8d5a138284b9ab09ee940c8293d3d17", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -35,7 +35,6 @@\n #![feature(core)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n-#![feature(unsafe_destructor)]\n #![cfg_attr(test, feature(test))]\n \n extern crate alloc;\n@@ -124,7 +123,6 @@ fn chunk(size: usize, is_copy: bool) -> Chunk {\n     }\n }\n \n-#[unsafe_destructor]\n impl<'longer_than_self> Drop for Arena<'longer_than_self> {\n     fn drop(&mut self) {\n         unsafe {\n@@ -510,7 +508,6 @@ impl<T> TypedArena<T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "af7112a5cb4e30147c7a3228eb3832c3d89c4e80", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -546,7 +546,7 @@ impl<T: Ord> BinaryHeap<T> {\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n-        Drain { iter: self.data.drain() }\n+        Drain { iter: self.data.drain(..) }\n     }\n \n     /// Drops all items from the binary heap."}, {"sha": "bca0e1427e4426ae687d4e7d2f34a499daf0dea6", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -270,14 +270,12 @@ impl<T> DoubleEndedIterator for RawItems<T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<T> Drop for RawItems<T> {\n     fn drop(&mut self) {\n         for _ in self.by_ref() {}\n     }\n }\n \n-#[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n         if self.keys.is_null() ||\n@@ -1394,7 +1392,6 @@ impl<K, V> TraversalImpl for MoveTraversalImpl<K, V> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<K, V> Drop for MoveTraversalImpl<K, V> {\n     fn drop(&mut self) {\n         // We need to cleanup the stored values manually, as the RawItems destructor would run"}, {"sha": "4480a7d7e0a09fbe2be418082d6a9b9ee8b32f6f", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -394,14 +394,71 @@\n //!\n //! ## Precision\n //!\n-//! For non-numeric types, this can be considered a \"maximum width\". If the\n-//! resulting string is longer than this width, then it is truncated down to\n-//! this many characters and only those are emitted.\n+//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n+//! longer than this width, then it is truncated down to this many characters and only those are\n+//! emitted.\n //!\n //! For integral types, this has no meaning currently.\n //!\n-//! For floating-point types, this indicates how many digits after the decimal\n-//! point should be printed.\n+//! For floating-point types, this indicates how many digits after the decimal point should be\n+//! printed.\n+//!\n+//! There are three possible ways to specify the desired `precision`:\n+//!\n+//! There are three possible ways to specify the desired `precision`:\n+//! 1. An integer `.N`,\n+//! 2. an integer followed by dollar sign `.N$`, or\n+//! 3. an asterisk `.*`.\n+//!\n+//! The first specification, `.N`, means the integer `N` itself is the precision.\n+//!\n+//! The second, `.N$`, means use format *argument* `N` (which must be a `usize`) as the precision.\n+//!\n+//! Finally,  `.*` means that this `{...}` is associated with *two* format inputs rather than one:\n+//! the first input holds the `usize` precision, and the second holds the value to print.  Note\n+//! that in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part\n+//! refers to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n+//!\n+//! For example, these:\n+//!\n+//! ```\n+//! // Hello {arg 0 (x)} is {arg 1 (0.01} with precision specified inline (5)}\n+//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n+//!\n+//! // Hello {arg 1 (x)} is {arg 2 (0.01} with precision specified in arg 0 (5)}\n+//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n+//!\n+//! // Hello {arg 0 (x)} is {arg 2 (0.01} with precision specified in arg 1 (5)}\n+//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (x)} is {second of next two args (0.01} with precision\n+//! //                          specified in first of next two args (5)}\n+//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (x)} is {arg 2 (0.01} with precision\n+//! //                          specified in its predecessor (5)}\n+//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+//! ```\n+//!\n+//! All print the same thing:\n+//!\n+//! ```text\n+//! Hello x is 0.01000\n+//! ```\n+//!\n+//! While these:\n+//!\n+//! ```\n+//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n+//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+//! ```\n+//!\n+//! print two significantly different things:\n+//!\n+//! ```text\n+//! Hello, `1234.560` has 3 fractional digits\n+//! Hello, `123` has 3 characters\n+//! ```\n //!\n //! # Escaping\n //!"}, {"sha": "ecbe9369e781f68ccdfd5c9b592a355f80c356aa", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -33,7 +33,6 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(unsafe_destructor)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(step_by)]\n@@ -42,7 +41,8 @@\n #![feature(slice_patterns)]\n #![feature(debug_builders)]\n #![feature(utf8_error)]\n-#![cfg_attr(test, feature(rand, rustc_private, test, hash, collections))]\n+#![cfg_attr(test, feature(rand, rustc_private, test, hash, collections,\n+                          collections_drain, collections_range))]\n #![cfg_attr(test, allow(deprecated))] // rand\n \n #![feature(no_std)]\n@@ -82,6 +82,7 @@ pub mod borrow;\n pub mod enum_set;\n pub mod fmt;\n pub mod linked_list;\n+pub mod range;\n pub mod slice;\n pub mod str;\n pub mod string;"}, {"sha": "f6dc5cf7d90a0045146754af6fa4d52594463768", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -624,7 +624,6 @@ impl<T> LinkedList<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for LinkedList<T> {\n     fn drop(&mut self) {\n@@ -933,7 +932,7 @@ impl<A: Hash> Hash for LinkedList<A> {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use std::clone::Clone;\n     use std::iter::{Iterator, IntoIterator};\n     use std::option::Option::{Some, None, self};"}, {"sha": "6ab143998d299f5222057e8372b58a083ad916be", "filename": "src/libcollections/range.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![unstable(feature = \"collections_range\", reason = \"was just added\")]\n+\n+//! Range syntax.\n+\n+use core::option::Option::{self, None, Some};\n+use core::ops::{RangeFull, Range, RangeTo, RangeFrom};\n+\n+/// **RangeArgument** is implemented by Rust's built-in range types, produced\n+/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n+pub trait RangeArgument<T> {\n+    /// Start index (inclusive)\n+    ///\n+    /// Return start value if present, else `None`.\n+    fn start(&self) -> Option<&T> { None }\n+\n+    /// End index (exclusive)\n+    ///\n+    /// Return end value if present, else `None`.\n+    fn end(&self) -> Option<&T> { None }\n+}\n+\n+\n+impl<T> RangeArgument<T> for RangeFull {}\n+\n+impl<T> RangeArgument<T> for RangeFrom<T> {\n+    fn start(&self) -> Option<&T> { Some(&self.start) }\n+}\n+\n+impl<T> RangeArgument<T> for RangeTo<T> {\n+    fn end(&self) -> Option<&T> { Some(&self.end) }\n+}\n+\n+impl<T> RangeArgument<T> for Range<T> {\n+    fn start(&self) -> Option<&T> { Some(&self.start) }\n+    fn end(&self) -> Option<&T> { Some(&self.end) }\n+}"}, {"sha": "be6405dc85a1498fcbffba5194c8397c1754ebd9", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -951,12 +951,13 @@ impl<'a> Deref for DerefString<'a> {\n /// # #![feature(collections)]\n /// use std::string::as_string;\n ///\n-/// fn string_consumer(s: String) {\n-///     assert_eq!(s, \"foo\".to_string());\n+/// // Let's pretend we have a function that requires `&String`\n+/// fn string_consumer(s: &String) {\n+///     assert_eq!(s, \"foo\");\n /// }\n ///\n-/// let string = as_string(\"foo\").clone();\n-/// string_consumer(string);\n+/// // Provide a `&String` from a `&str` without allocating\n+/// string_consumer(&as_string(\"foo\"));\n /// ```\n #[unstable(feature = \"collections\")]\n pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {"}, {"sha": "4f0b17a563b796198d19b0d913dd7b893ed482fb", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 105, "deletions": 90, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -69,6 +69,8 @@ use core::usize;\n \n use borrow::{Cow, IntoCow};\n \n+use super::range::RangeArgument;\n+\n // FIXME- fix places which assume the max vector allowed has memory usize::MAX.\n static MAX_MEMORY_SIZE: usize = isize::MAX as usize;\n \n@@ -116,11 +118,7 @@ static MAX_MEMORY_SIZE: usize = isize::MAX as usize;\n /// stack.push(2);\n /// stack.push(3);\n ///\n-/// loop {\n-///     let top = match stack.pop() {\n-///         None => break, // empty\n-///         Some(x) => x,\n-///     };\n+/// while let Some(top) = stack.pop() {\n ///     // Prints 3, 2, 1\n ///     println!(\"{}\", top);\n /// }\n@@ -540,7 +538,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `i` is out of bounds.\n+    /// Panics if `index` is out of bounds.\n     ///\n     /// # Examples\n     ///\n@@ -718,36 +716,61 @@ impl<T> Vec<T> {\n         unsafe { other.set_len(0); }\n     }\n \n-    /// Creates a draining iterator that clears the `Vec` and iterates over\n-    /// the removed items from start to end.\n+    /// Create a draining iterator that removes the specified range in the vector\n+    /// and yields the removed items from start to end. The element range is\n+    /// removed even if the iterator is not consumed until the end.\n+    ///\n+    /// Note: It is unspecified how many elements are removed from the vector,\n+    /// if the `Drain` value is leaked.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n-    /// let mut v = vec![\"a\".to_string(), \"b\".to_string()];\n-    /// for s in v.drain() {\n-    ///     // s has type String, not &String\n-    ///     println!(\"{}\", s);\n-    /// }\n-    /// assert!(v.is_empty());\n+    /// # #![feature(collections_drain, collections_range)]\n+    ///\n+    /// // Draining using `..` clears the whole vector.\n+    /// let mut v = vec![1, 2, 3];\n+    /// let u: Vec<_> = v.drain(..).collect();\n+    /// assert_eq!(v, &[]);\n+    /// assert_eq!(u, &[1, 2, 3]);\n     /// ```\n-    #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn drain(&mut self) -> Drain<T> {\n+    #[unstable(feature = \"collections_drain\",\n+               reason = \"recently added, matches RFC\")]\n+    pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n+        // Memory safety\n+        //\n+        // When the Drain is first created, it shortens the length of\n+        // the source vector to make sure no uninitalized or moved-from elements\n+        // are accessible at all if the Drain's destructor never gets to run.\n+        //\n+        // Drain will ptr::read out the values to remove.\n+        // When finished, remaining tail of the vec is copied back to cover\n+        // the hole, and the vector length is restored to the new length.\n+        //\n+        let len = self.len();\n+        let start = *range.start().unwrap_or(&0);\n+        let end = *range.end().unwrap_or(&len);\n+        assert!(start <= end);\n+        assert!(end <= len);\n+\n         unsafe {\n-            let begin = *self.ptr as *const T;\n-            let end = if mem::size_of::<T>() == 0 {\n-                (*self.ptr as usize + self.len()) as *const T\n-            } else {\n-                (*self.ptr).offset(self.len() as isize) as *const T\n-            };\n-            self.set_len(0);\n+            // set self.vec length's to start, to be safe in case Drain is leaked\n+            self.set_len(start);\n+            // Use the borrow in the IterMut to indicate borrowing behavior of the\n+            // whole Drain iterator (like &mut T).\n+            let range_slice = slice::from_raw_parts_mut(\n+                                        self.as_mut_ptr().offset(start as isize),\n+                                        end - start);\n             Drain {\n-                ptr: begin,\n-                end: end,\n-                marker: PhantomData,\n+                tail_start: end,\n+                tail_len: len - end,\n+                iter: range_slice.iter_mut(),\n+                vec: self as *mut _,\n             }\n         }\n     }\n@@ -1603,7 +1626,6 @@ impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n@@ -1785,7 +1807,6 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n@@ -1799,14 +1820,16 @@ impl<T> Drop for IntoIter<T> {\n     }\n }\n \n-/// An iterator that drains a vector.\n-#[unsafe_no_drop_flag]\n-#[unstable(feature = \"collections\",\n-           reason = \"recently added as part of collections reform 2\")]\n-pub struct Drain<'a, T:'a> {\n-    ptr: *const T,\n-    end: *const T,\n-    marker: PhantomData<&'a T>,\n+/// A draining iterator for `Vec<T>`.\n+#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+pub struct Drain<'a, T: 'a> {\n+    /// Index of tail to preserve\n+    tail_start: usize,\n+    /// Length of tail\n+    tail_len: usize,\n+    /// Current remaining range to remove\n+    iter: slice::IterMut<'a, T>,\n+    vec: *mut Vec<T>,\n }\n \n unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n@@ -1818,76 +1841,55 @@ impl<'a, T> Iterator for Drain<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            if self.ptr == self.end {\n-                None\n-            } else {\n-                if mem::size_of::<T>() == 0 {\n-                    // purposefully don't use 'ptr.offset' because for\n-                    // vectors with 0-size elements this would return the\n-                    // same pointer.\n-                    self.ptr = mem::transmute(self.ptr as usize + 1);\n-\n-                    // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n-                } else {\n-                    let old = self.ptr;\n-                    self.ptr = self.ptr.offset(1);\n-\n-                    Some(ptr::read(old))\n-                }\n+        self.iter.next().map(|elt|\n+            unsafe {\n+                ptr::read(elt as *const _)\n             }\n-        }\n+        )\n     }\n \n-    #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let diff = (self.end as usize) - (self.ptr as usize);\n-        let size = mem::size_of::<T>();\n-        let exact = diff / (if size == 0 {1} else {size});\n-        (exact, Some(exact))\n+        self.iter.size_hint()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        unsafe {\n-            if self.end == self.ptr {\n-                None\n-            } else {\n-                if mem::size_of::<T>() == 0 {\n-                    // See above for why 'ptr.offset' isn't used\n-                    self.end = mem::transmute(self.end as usize - 1);\n-\n-                    // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n-                } else {\n-                    self.end = self.end.offset(-1);\n-\n-                    Some(ptr::read(self.end))\n-                }\n+        self.iter.next_back().map(|elt|\n+            unsafe {\n+                ptr::read(elt as *const _)\n             }\n-        }\n+        )\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n-\n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n-        // self.ptr == self.end == mem::POST_DROP_USIZE if drop has already been called,\n-        // so we can use #[unsafe_no_drop_flag].\n+        // exhaust self first\n+        while let Some(_) = self.next() { }\n \n-        // destroy the remaining elements\n-        for _x in self.by_ref() {}\n+        if self.tail_len > 0 {\n+            unsafe {\n+                let source_vec = &mut *self.vec;\n+                // memmove back untouched tail, update to new length\n+                let start = source_vec.len();\n+                let tail = self.tail_start;\n+                let src = source_vec.as_ptr().offset(tail as isize);\n+                let dst = source_vec.as_mut_ptr().offset(start as isize);\n+                ptr::copy(src, dst, self.tail_len);\n+                source_vec.set_len(start + self.tail_len);\n+            }\n+        }\n     }\n }\n \n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Conversion from &[T] to &Vec<T>\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1909,7 +1911,6 @@ impl<'a, T> Deref for DerefVec<'a, T> {\n }\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n@@ -1919,6 +1920,22 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n }\n \n /// Converts a slice to a wrapper type providing a `&Vec<T>` reference.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![feature(collections)]\n+/// use std::vec::as_vec;\n+///\n+/// // Let's pretend we have a function that requires `&Vec<i32>`\n+/// fn vec_consumer(s: &Vec<i32>) {\n+///     assert_eq!(s, &[1, 2, 3]);\n+/// }\n+///\n+/// // Provide a `&Vec<i32>` from a `&[i32]` without allocating\n+/// let values = [1, 2, 3];\n+/// vec_consumer(&as_vec(&values));\n+/// ```\n #[unstable(feature = \"collections\")]\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n@@ -1962,7 +1979,6 @@ struct PartialVecZeroSized<T,U> {\n     marker: PhantomData<::core::cell::Cell<(T,U)>>,\n }\n \n-#[unsafe_destructor]\n impl<T,U> Drop for PartialVecNonZeroSized<T,U> {\n     fn drop(&mut self) {\n         unsafe {\n@@ -1988,7 +2004,6 @@ impl<T,U> Drop for PartialVecNonZeroSized<T,U> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<T,U> Drop for PartialVecZeroSized<T,U> {\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "3032b13855ba3b1b510fc6e7afa853d1f339dd6f", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -59,7 +59,6 @@ impl<T: Clone> Clone for VecDeque<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for VecDeque<T> {\n     fn drop(&mut self) {\n@@ -1612,7 +1611,6 @@ pub struct Drain<'a, T: 'a> {\n     inner: &'a mut VecDeque<T>,\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n@@ -1772,7 +1770,7 @@ impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use core::iter::{Iterator, self};\n     use core::option::Option::Some;\n "}, {"sha": "6ff819fc87cdbd0c3d702a608f786b4e63c1e43c", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -418,7 +418,7 @@ impl<V> VecMap<V> {\n         }\n         let filter: fn((usize, Option<V>)) -> Option<(usize, V)> = filter; // coerce to fn ptr\n \n-        Drain { iter: self.v.drain().enumerate().filter_map(filter) }\n+        Drain { iter: self.v.drain(..).enumerate().filter_map(filter) }\n     }\n \n     /// Returns the number of elements in the map."}, {"sha": "57a95633b678f3ac0c9536450996f0dec1911a37", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -10,14 +10,14 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n+#![feature(collections_drain)]\n #![feature(core)]\n #![feature(hash)]\n #![feature(rand)]\n #![feature(rustc_private)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(unsafe_destructor)]\n #![feature(into_cow)]\n #![feature(step_by)]\n #![cfg_attr(test, feature(str_char))]"}, {"sha": "8a8da0d9faaeac1fb7332f4e63897167dfd6da29", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -18,7 +18,6 @@ struct DropCounter<'a> {\n     count: &'a mut u32\n }\n \n-#[unsafe_destructor]\n impl<'a> Drop for DropCounter<'a> {\n     fn drop(&mut self) {\n         *self.count += 1;\n@@ -460,7 +459,7 @@ fn test_move_items_zero_sized() {\n fn test_drain_items() {\n     let mut vec = vec![1, 2, 3];\n     let mut vec2 = vec![];\n-    for i in vec.drain() {\n+    for i in vec.drain(..) {\n         vec2.push(i);\n     }\n     assert_eq!(vec, []);\n@@ -471,7 +470,7 @@ fn test_drain_items() {\n fn test_drain_items_reverse() {\n     let mut vec = vec![1, 2, 3];\n     let mut vec2 = vec![];\n-    for i in vec.drain().rev() {\n+    for i in vec.drain(..).rev() {\n         vec2.push(i);\n     }\n     assert_eq!(vec, []);\n@@ -482,13 +481,43 @@ fn test_drain_items_reverse() {\n fn test_drain_items_zero_sized() {\n     let mut vec = vec![(), (), ()];\n     let mut vec2 = vec![];\n-    for i in vec.drain() {\n+    for i in vec.drain(..) {\n         vec2.push(i);\n     }\n     assert_eq!(vec, []);\n     assert_eq!(vec2, [(), (), ()]);\n }\n \n+#[test]\n+#[should_panic]\n+fn test_drain_out_of_bounds() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    v.drain(5..6);\n+}\n+\n+#[test]\n+fn test_drain_range() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    for _ in v.drain(4..) {\n+    }\n+    assert_eq!(v, &[1, 2, 3, 4]);\n+\n+    let mut v: Vec<_> = (1..6).map(|x| x.to_string()).collect();\n+    for _ in v.drain(1..4) {\n+    }\n+    assert_eq!(v, &[1.to_string(), 5.to_string()]);\n+\n+    let mut v: Vec<_> = (1..6).map(|x| x.to_string()).collect();\n+    for _ in v.drain(1..4).rev() {\n+    }\n+    assert_eq!(v, &[1.to_string(), 5.to_string()]);\n+\n+    let mut v: Vec<_> = vec![(); 5];\n+    for _ in v.drain(1..4).rev() {\n+    }\n+    assert_eq!(v, &[(), ()]);\n+}\n+\n #[test]\n fn test_into_boxed_slice() {\n     let xs = vec![1, 2, 3];"}, {"sha": "bcbf31617eeb6aedda8e38e804168a42a33c0cfc", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -129,6 +129,12 @@ pub struct AtomicPtr<T> {\n     _marker: PhantomData<*mut T>,\n }\n \n+impl<T> Default for AtomicPtr<T> {\n+    fn default() -> AtomicPtr<T> {\n+        AtomicPtr::new(::ptr::null_mut())\n+    }\n+}\n+\n unsafe impl<T> Sync for AtomicPtr<T> {}\n \n /// Atomic memory orderings"}, {"sha": "9ff447a87f1fea6730580fa1b17b7afb4727bf2e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -417,7 +417,7 @@ impl<T> RefCell<T> {\n     ///\n     /// let result = thread::spawn(move || {\n     ///    let c = RefCell::new(5);\n-    ///    let m = c.borrow_mut();\n+    ///    let m = c.borrow();\n     ///\n     ///    let b = c.borrow_mut(); // this causes a panic\n     /// }).join();\n@@ -493,7 +493,6 @@ impl<'b> BorrowRef<'b> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<'b> Drop for BorrowRef<'b> {\n     #[inline]\n     fn drop(&mut self) {\n@@ -557,7 +556,6 @@ struct BorrowRefMut<'b> {\n     _borrow: &'b Cell<BorrowFlag>,\n }\n \n-#[unsafe_destructor]\n impl<'b> Drop for BorrowRefMut<'b> {\n     #[inline]\n     fn drop(&mut self) {"}, {"sha": "d3de77a9241e3f7dbab05cbe77f2b89ccba5c647", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,7 +11,7 @@\n //! Traits for conversions between types.\n //!\n //! The traits in this module provide a general way to talk about conversions from one type to\n-//! another. They follow the standard Rust conventions of `as`/`to`/`into`/`from`.\n+//! another. They follow the standard Rust conventions of `as`/`into`/`from`.\n //!\n //! Like many traits, these are often used as bounds for generic functions, to support arguments of\n //! multiple types.\n@@ -83,10 +83,8 @@ pub trait Into<T>: Sized {\n /// `String` implements `From<&str>`:\n ///\n /// ```\n-/// let s = \"hello\";\n /// let string = \"hello\".to_string();\n-///\n-/// let other_string: String = From::from(s);\n+/// let other_string = String::from(\"hello\");\n ///\n /// assert_eq!(string, other_string);\n /// ```"}, {"sha": "73778bfd0380991efbc3e56e0eba93b56f1ce240", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -34,8 +34,7 @@ mod num;\n mod float;\n mod builders;\n \n-#[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n-#[cfg_attr(not(stage0), unstable(feature = \"core\", reason = \"internal to format_args!\"))]\n+#[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n #[doc(hidden)]\n pub mod rt {\n     pub mod v1;\n@@ -148,8 +147,7 @@ enum Void {}\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[derive(Copy)]\n-#[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n-#[cfg_attr(not(stage0), unstable(feature = \"core\", reason = \"internal to format_args!\"))]\n+#[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n #[doc(hidden)]\n pub struct ArgumentV1<'a> {\n     value: &'a Void,\n@@ -169,8 +167,7 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     #[doc(hidden)]\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n-    #[cfg_attr(not(stage0), unstable(feature = \"core\", reason = \"internal to format_args!\"))]\n+    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n     pub fn new<'b, T>(x: &'b T,\n                       f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {\n         unsafe {\n@@ -182,8 +179,7 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     #[doc(hidden)]\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n-    #[cfg_attr(not(stage0), unstable(feature = \"core\", reason = \"internal to format_args!\"))]\n+    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n     pub fn from_usize(x: &usize) -> ArgumentV1 {\n         ArgumentV1::new(x, ArgumentV1::show_usize)\n     }\n@@ -206,8 +202,7 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n-    #[cfg_attr(not(stage0), unstable(feature = \"core\", reason = \"internal to format_args!\"))]\n+    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n     pub fn new_v1(pieces: &'a [&'a str],\n                   args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n         Arguments {\n@@ -224,8 +219,7 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n-    #[cfg_attr(not(stage0), unstable(feature = \"core\", reason = \"internal to format_args!\"))]\n+    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n     pub fn new_v1_formatted(pieces: &'a [&'a str],\n                             args: &'a [ArgumentV1<'a>],\n                             fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {"}, {"sha": "2afd8abeb31aa5810f414924a06e080ac2e357c6", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -14,69 +14,46 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#![cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n-#![cfg_attr(not(stage0), unstable(feature = \"core\", reason = \"internal to format_args!\"))]\n+#![unstable(feature = \"core\", reason = \"internal to format_args!\")]\n \n #[derive(Copy, Clone)]\n-#[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n pub struct Argument {\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     pub position: Position,\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     pub format: FormatSpec,\n }\n \n #[derive(Copy, Clone)]\n-#[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n pub struct FormatSpec {\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     pub fill: char,\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     pub align: Alignment,\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     pub flags: u32,\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     pub precision: Count,\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     pub width: Count,\n }\n \n /// Possible alignments that can be requested as part of a formatting directive.\n #[derive(Copy, Clone, PartialEq)]\n-#[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n pub enum Alignment {\n     /// Indication that contents should be left-aligned.\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     Left,\n     /// Indication that contents should be right-aligned.\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     Right,\n     /// Indication that contents should be center-aligned.\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     Center,\n     /// No alignment was requested.\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     Unknown,\n }\n \n #[derive(Copy, Clone)]\n-#[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n pub enum Count {\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     Is(usize),\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     Param(usize),\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     NextParam,\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     Implied,\n }\n \n #[derive(Copy, Clone)]\n-#[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n pub enum Position {\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     Next,\n-    #[cfg_attr(stage0, stable(feature = \"rust1\", since = \"1.0.0\"))]\n     At(usize)\n }"}, {"sha": "ac43055a7c4a5ff65e3110ad4b5765fb19a0756c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -139,6 +139,21 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_fence_rel();\n     pub fn atomic_fence_acqrel();\n \n+    /// A compiler-only memory barrier.\n+    ///\n+    /// Memory accesses will never be reordered across this barrier by the compiler,\n+    /// but no instructions will be emitted for it. This is appropriate for operations\n+    /// on the same thread that may be preempted, such as when interacting with signal\n+    /// handlers.\n+    #[cfg(not(stage0))]     // SNAP 857ef6e\n+    pub fn atomic_singlethreadfence();\n+    #[cfg(not(stage0))]     // SNAP 857ef6e\n+    pub fn atomic_singlethreadfence_acq();\n+    #[cfg(not(stage0))]     // SNAP 857ef6e\n+    pub fn atomic_singlethreadfence_rel();\n+    #[cfg(not(stage0))]     // SNAP 857ef6e\n+    pub fn atomic_singlethreadfence_acqrel();\n+\n     /// Aborts the execution of the process.\n     pub fn abort() -> !;\n \n@@ -255,12 +270,17 @@ extern \"rust-intrinsic\" {\n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n     pub fn owns_managed<T>() -> bool;\n \n-    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n-    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n-    /// undefined behaviour.\n+    /// Calculates the offset from a pointer.\n     ///\n     /// This is implemented as an intrinsic to avoid converting to and from an\n     /// integer, since the conversion would throw away aliasing information.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Both the starting and resulting pointer must be either in bounds or one\n+    /// byte past the end of an allocated object. If either pointer is out of\n+    /// bounds or arithmetic overflow occurs then any further use of the\n+    /// returned value will result in undefined behavior.\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -303,14 +323,8 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(not(stage0))]\n     pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// dox\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(stage0)]\n-    pub fn copy_nonoverlapping<T>(dst: *mut T, src: *const T, count: usize);\n-\n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n@@ -340,14 +354,8 @@ extern \"rust-intrinsic\" {\n     /// ```\n     ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(not(stage0))]\n     pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// dox\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(stage0)]\n-    pub fn copy<T>(dst: *mut T, src: *const T, count: usize);\n-\n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -572,7 +580,22 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the value of the discriminant for the variant in 'v',\n     /// cast to a `u64`; if `T` has no discriminant, returns 0.\n-    // SNAP 5520801\n-    #[cfg(not(stage0))]\n     pub fn discriminant_value<T>(v: &T) -> u64;\n }\n+\n+#[cfg(not(stage0))]\n+extern \"rust-intrinsic\" {\n+    /// Performs an unchecked signed division, which results in undefined behavior,\n+    /// in cases where y == 0, or x == int::MIN and y == -1\n+    pub fn unchecked_sdiv<T>(x: T, y: T) -> T;\n+    /// Performs an unchecked unsigned division, which results in undefined behavior,\n+    /// in cases where y == 0\n+    pub fn unchecked_udiv<T>(x: T, y: T) -> T;\n+\n+    /// Returns the remainder of an unchecked signed division, which results in\n+    /// undefined behavior, in cases where y == 0, or x == int::MIN and y == -1\n+    pub fn unchecked_urem<T>(x: T, y: T) -> T;\n+    /// Returns the remainder of an unchecked signed division, which results in\n+    /// undefined behavior, in cases where y == 0\n+    pub fn unchecked_srem<T>(x: T, y: T) -> T;\n+}"}, {"sha": "0fa27a4312d5760948c12ce5dcc6df8bf3918241", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -179,8 +179,8 @@ pub trait Iterator {\n \n     /// Creates an iterator that iterates over both this and the specified\n     /// iterators simultaneously, yielding the two elements as pairs. When\n-    /// either iterator returns `None`, all further invocations of next() will\n-    /// return `None`.\n+    /// either iterator returns `None`, all further invocations of `next()`\n+    /// will return `None`.\n     ///\n     /// # Examples\n     ///\n@@ -2407,12 +2407,14 @@ pub trait Step: PartialOrd {\n     /// `start` should always be less than `end`, so the result should never\n     /// be negative.\n     ///\n+    /// `by` must be > 0.\n+    ///\n     /// Returns `None` if it is not possible to calculate steps_between\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n }\n \n-macro_rules! step_impl {\n+macro_rules! step_impl_unsigned {\n     ($($t:ty)*) => ($(\n         impl Step for $t {\n             #[inline]\n@@ -2423,7 +2425,33 @@ macro_rules! step_impl {\n             #[allow(trivial_numeric_casts)]\n             fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n                 if *start <= *end {\n-                    Some(((*end - *start) / *by) as usize)\n+                    // Note: We assume $t <= usize here\n+                    Some((*end - *start) as usize / (*by as usize))\n+                } else {\n+                    Some(0)\n+                }\n+            }\n+        }\n+    )*)\n+}\n+macro_rules! step_impl_signed {\n+    ($($t:ty)*) => ($(\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&self, by: &$t) -> Option<$t> {\n+                (*self).checked_add(*by)\n+            }\n+            #[inline]\n+            #[allow(trivial_numeric_casts)]\n+            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n+                if *start <= *end {\n+                    // Note: We assume $t <= isize here\n+                    // Use .wrapping_sub and cast to usize to compute the\n+                    // difference that may not fit inside the range of isize.\n+                    Some(\n+                        ((*end as isize).wrapping_sub(*start as isize) as usize\n+                        / (*by as usize))\n+                    )\n                 } else {\n                     Some(0)\n                 }\n@@ -2447,9 +2475,12 @@ macro_rules! step_impl_no_between {\n     )*)\n }\n \n-step_impl!(usize u8 u16 u32 isize i8 i16 i32);\n+step_impl_unsigned!(usize u8 u16 u32);\n+step_impl_signed!(isize i8 i16 i32);\n+#[cfg(target_pointer_width = \"64\")]\n+step_impl_unsigned!(u64);\n #[cfg(target_pointer_width = \"64\")]\n-step_impl!(u64 i64);\n+step_impl_signed!(i64);\n #[cfg(target_pointer_width = \"32\")]\n step_impl_no_between!(u64 i64);\n "}, {"sha": "dd06c3d0987d98b7e0da0444eaaebf21f932093e", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -65,7 +65,7 @@\n \n #![feature(intrinsics, lang_items)]\n #![feature(on_unimplemented)]\n-#![feature(simd, unsafe_destructor)]\n+#![feature(simd)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(rustc_attrs)]"}, {"sha": "44e5390098bee7b194b3724e9099d9100337de48", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -35,20 +35,10 @@ use hash::Hasher;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n-#[cfg(not(stage0))]\n pub unsafe trait Send {\n     // empty.\n }\n \n-/// Types able to be transferred across thread boundaries.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"send\"]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n-#[cfg(stage0)]\n-pub unsafe trait Send : MarkerTrait {\n-    // empty.\n-}\n-\n unsafe impl Send for .. { }\n \n impl<T> !Send for *const T { }\n@@ -60,21 +50,10 @@ impl !Send for Managed { }\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n-#[cfg(not(stage0))]\n pub trait Sized {\n     // Empty.\n }\n \n-/// Types with a constant size known at compile-time.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"sized\"]\n-#[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n-#[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n-#[cfg(stage0)]\n-pub trait Sized : MarkerTrait {\n-    // Empty.\n-}\n-\n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n ///\n /// By default, variable bindings have 'move semantics.' In other\n@@ -222,23 +201,13 @@ pub trait Copy : Clone {\n /// wrapper around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n pub unsafe trait Sync {\n     // Empty\n }\n \n-/// dox\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"sync\"]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n-pub unsafe trait Sync : MarkerTrait {\n-    // Empty\n-}\n-\n unsafe impl Sync for .. { }\n \n impl<T> !Sync for *const T { }\n@@ -301,20 +270,6 @@ macro_rules! impls{\n         )\n }\n \n-/// dox\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-pub trait MarkerTrait : PhantomFn<Self,Self> { }\n-\n-#[cfg(stage0)]\n-impl<T: ?Sized> MarkerTrait for T {}\n-\n-/// dox\n-#[lang=\"phantom_fn\"]\n-#[cfg(stage0)]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n-}\n-\n /// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n /// even though it does not. This allows you to inform the compiler about certain safety properties\n /// of your code.\n@@ -461,14 +416,6 @@ mod impls {\n #[rustc_reflect_like]\n #[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n #[allow(deprecated)]\n-#[cfg(not(stage0))]\n pub trait Reflect {}\n \n-/// dox\n-#[rustc_reflect_like]\n-#[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n-#[cfg(stage0)]\n-pub trait Reflect: MarkerTrait {}\n-\n impl Reflect for .. { }\n-"}, {"sha": "640703ca2f9c2d293f9b3351e95539e4a32df473", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,16 +12,10 @@\n \n use marker::Sized;\n use ops::Deref;\n-#[cfg(stage0)] use marker::MarkerTrait;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n-#[cfg(not(stage0))]\n pub unsafe trait Zeroable {}\n \n-/// Unsafe trait to indicate what types are usable with the NonZero struct\n-#[cfg(stage0)]\n-pub unsafe trait Zeroable: MarkerTrait {}\n-\n unsafe impl<T:?Sized> Zeroable for *const T {}\n unsafe impl<T:?Sized> Zeroable for *mut T {}\n unsafe impl Zeroable for isize {}"}, {"sha": "b8638c5b09be257ea87e9c7db993ea0c930328d5", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -745,7 +745,20 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn trailing_zeros(self) -> u32 {\n-            unsafe { $cttz(self as $ActualT) as u32 }\n+            // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n+            // emits two conditional moves on x86_64. By promoting the value to\n+            // u16 and setting bit 8, we get better code without any conditional\n+            // operations.\n+            // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n+            // pending, remove this workaround once LLVM generates better code\n+            // for cttz8.\n+            unsafe {\n+                if $BITS == 8 {\n+                    intrinsics::cttz16(self as u16 | 0x100) as u32\n+                } else {\n+                    $cttz(self as $ActualT) as u32\n+                }\n+            }\n         }\n \n         /// Shifts the bits to the left by a specified amount, `n`,"}, {"sha": "8a4f603ec472036be4366cadda7a0613f8a82534", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -508,8 +508,6 @@ macro_rules! neg_impl_numeric {\n macro_rules! neg_impl_unsigned {\n     ($($t:ty)*) => {\n         neg_impl_core!{ x => {\n-            #[cfg(stage0)]\n-            use ::num::wrapping::WrappingOps;\n             !x.wrapping_add(1)\n         }, $($t)*} }\n }\n@@ -1162,7 +1160,6 @@ pub trait FnOnce<Args> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n-#[cfg(not(stage0))]\n mod impls {\n     use marker::Sized;\n     use super::{Fn, FnMut, FnOnce};"}, {"sha": "47c029f11b38fad65971f9822d532aae935a161b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -106,28 +106,11 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n pub use intrinsics::copy_nonoverlapping;\n \n-/// dox\n-#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n-    intrinsics::copy_nonoverlapping(dst, src, count)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n pub use intrinsics::copy;\n \n-/// dox\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n-    intrinsics::copy(dst, src, count)\n-}\n-\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::write_bytes;\n \n@@ -301,9 +284,10 @@ impl<T: ?Sized> *const T {\n     ///\n     /// # Safety\n     ///\n-    /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n-    /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n-    /// the pointer is used.\n+    /// Both the starting and resulting pointer must be either in bounds or one\n+    /// byte past the end of an allocated object. If either pointer is out of\n+    /// bounds or arithmetic overflow occurs then\n+    /// any further use of the returned value will result in undefined behavior.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn offset(self, count: isize) -> *const T where T: Sized {"}, {"sha": "38e66c5a3d6a2460e4e474a41f7e0c78a0ffb287", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 79, "deletions": 25, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -625,6 +625,36 @@ impl<'a, T> IntoIterator for &'a mut [T] {\n     }\n }\n \n+#[inline(always)]\n+fn size_from_ptr<T>(_: *const T) -> usize {\n+    mem::size_of::<T>()\n+}\n+\n+\n+// Use macro to be generic over const/mut\n+macro_rules! slice_offset {\n+    ($ptr:expr, $by:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            transmute(ptr as usize + $by)\n+        } else {\n+            ptr.offset($by)\n+        }\n+    }};\n+}\n+\n+macro_rules! slice_ref {\n+    ($ptr:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            // Use a non-null pointer value\n+            &mut *(1 as *mut _)\n+        } else {\n+            transmute(ptr)\n+        }\n+    }};\n+}\n+\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n@@ -641,20 +671,9 @@ macro_rules! iterator {\n                     if self.ptr == self.end {\n                         None\n                     } else {\n-                        if mem::size_of::<T>() == 0 {\n-                            // purposefully don't use 'ptr.offset' because for\n-                            // vectors with 0-size elements this would return the\n-                            // same pointer.\n-                            self.ptr = transmute(self.ptr as usize + 1);\n-\n-                            // Use a non-null pointer value\n-                            Some(&mut *(1 as *mut _))\n-                        } else {\n-                            let old = self.ptr;\n-                            self.ptr = self.ptr.offset(1);\n-\n-                            Some(transmute(old))\n-                        }\n+                        let old = self.ptr;\n+                        self.ptr = slice_offset!(self.ptr, 1);\n+                        Some(slice_ref!(old))\n                     }\n                 }\n             }\n@@ -666,6 +685,22 @@ macro_rules! iterator {\n                 let exact = diff / (if size == 0 {1} else {size});\n                 (exact, Some(exact))\n             }\n+\n+            #[inline]\n+            fn count(self) -> usize {\n+                self.size_hint().0\n+            }\n+\n+            #[inline]\n+            fn nth(&mut self, n: usize) -> Option<$elem> {\n+                // Call helper method. Can't put the definition here because mut versus const.\n+                self.iter_nth(n)\n+            }\n+\n+            #[inline]\n+            fn last(mut self) -> Option<$elem> {\n+                self.next_back()\n+            }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -679,17 +714,8 @@ macro_rules! iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        if mem::size_of::<T>() == 0 {\n-                            // See above for why 'ptr.offset' isn't used\n-                            self.end = transmute(self.end as usize - 1);\n-\n-                            // Use a non-null pointer value\n-                            Some(&mut *(1 as *mut _))\n-                        } else {\n-                            self.end = self.end.offset(-1);\n-\n-                            Some(transmute(self.end))\n-                        }\n+                        self.end = slice_offset!(self.end, -1);\n+                        Some(slice_ref!(self.end))\n                     }\n                 }\n             }\n@@ -785,6 +811,20 @@ impl<'a, T> Iter<'a, T> {\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(T => &'a [T]: self.ptr, self.end)\n     }\n+\n+    // Helper function for Iter::nth\n+    fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n+        match self.as_slice().get(n) {\n+            Some(elem_ref) => unsafe {\n+                self.ptr = slice_offset!(elem_ref as *const _, 1);\n+                Some(slice_ref!(elem_ref))\n+            },\n+            None => {\n+                self.ptr = self.end;\n+                None\n+            }\n+        }\n+    }\n }\n \n iterator!{struct Iter -> *const T, &'a T}\n@@ -914,6 +954,20 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_mut_slice!(T => &'a mut [T]: self.ptr, self.end)\n     }\n+\n+    // Helper function for IterMut::nth\n+    fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n+        match make_mut_slice!(T => &'a mut [T]: self.ptr, self.end).get_mut(n) {\n+            Some(elem_ref) => unsafe {\n+                self.ptr = slice_offset!(elem_ref as *mut _, 1);\n+                Some(slice_ref!(elem_ref))\n+            },\n+            None => {\n+                self.ptr = self.end;\n+                None\n+            }\n+        }\n+    }\n }\n \n iterator!{struct IterMut -> *mut T, &'a mut T}"}, {"sha": "bb36630f1682f5ea1c1f869c7a907426509b6231", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,6 +11,7 @@\n use core::iter::*;\n use core::iter::order::*;\n use core::iter::MinMaxResult::*;\n+use core::isize;\n use core::usize;\n use core::cmp;\n \n@@ -758,6 +759,11 @@ fn test_range() {\n     assert_eq!((usize::MAX - 1..usize::MAX).size_hint(), (1, Some(1)));\n     assert_eq!((-10..-1).size_hint(), (9, Some(9)));\n     assert_eq!((-1..-10).size_hint(), (0, Some(0)));\n+\n+    assert_eq!((-70..58i8).size_hint(), (128, Some(128)));\n+    assert_eq!((-128..127i8).size_hint(), (255, Some(255)));\n+    assert_eq!((-2..isize::MAX).size_hint(),\n+               (isize::MAX as usize + 2, Some(isize::MAX as usize + 2)));\n }\n \n #[test]"}, {"sha": "1566972275284f3bf829f4cc5fee6041b68e8031", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,7 +13,6 @@\n \n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n-#![feature(unsafe_destructor)]\n #![feature(core)]\n #![feature(test)]\n #![feature(rand)]"}, {"sha": "0ea9f8afb4e532c140a89d882beaf68b59da42d3", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -45,7 +45,7 @@ pub fn test_num<T>(ten: T, two: T) where\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::num::Float;"}, {"sha": "66945ad251f1ed3dc9a68912aa699a0e2e44dcbe", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -44,8 +44,7 @@ fn test_get_resource() {\n        i: Rc<RefCell<isize>>,\n     }\n \n-    #[unsafe_destructor]\n-    impl Drop for R {\n+        impl Drop for R {\n        fn drop(&mut self) {\n             let ii = &*self.i;\n             let i = *ii.borrow();\n@@ -220,7 +219,6 @@ fn test_ord() {\n     assert!(big > None);\n }\n \n-/* FIXME(#20575)\n #[test]\n fn test_collect() {\n     let v: Option<Vec<isize>> = (0..0).map(|_| Some(0)).collect();\n@@ -242,28 +240,26 @@ fn test_collect() {\n \n     assert!(v == None);\n }\n-*/\n+\n \n #[test]\n fn test_cloned() {\n-    let val1 = 1u32;\n-    let mut val2 = 2u32;\n-    let val1_ref = &val1;\n+    let val = 1u32;\n+    let val_ref = &val;\n     let opt_none: Option<&'static u32> = None;\n-    let opt_ref = Some(&val1);\n-    let opt_ref_ref = Some(&val1_ref);\n-    let opt_mut_ref = Some(&mut val2);\n+    let opt_ref = Some(&val);\n+    let opt_ref_ref = Some(&val_ref);\n \n     // None works\n     assert_eq!(opt_none.clone(), None);\n     assert_eq!(opt_none.cloned(), None);\n \n     // Immutable ref works\n-    assert_eq!(opt_ref.clone(), Some(&val1));\n+    assert_eq!(opt_ref.clone(), Some(&val));\n     assert_eq!(opt_ref.cloned(), Some(1u32));\n \n     // Double Immutable ref works\n-    assert_eq!(opt_ref_ref.clone(), Some(&val1_ref));\n-    assert_eq!(opt_ref_ref.clone().cloned(), Some(&val1));\n+    assert_eq!(opt_ref_ref.clone(), Some(&val_ref));\n+    assert_eq!(opt_ref_ref.clone().cloned(), Some(&val));\n     assert_eq!(opt_ref_ref.cloned().cloned(), Some(1u32));\n }"}, {"sha": "3fdb102875332f7aa4b26db6993abfb9ab5c6151", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn op1() -> Result<isize, &'static str> { Ok(666) }\n-pub fn op2() -> Result<isize, &'static str> { Err(\"sadface\") }\n+fn op1() -> Result<isize, &'static str> { Ok(666) }\n+fn op2() -> Result<isize, &'static str> { Err(\"sadface\") }\n \n #[test]\n-pub fn test_and() {\n+fn test_and() {\n     assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n     assert_eq!(op1().and(Err::<i32, &'static str>(\"bad\")).unwrap_err(),\n                \"bad\");\n@@ -23,7 +23,7 @@ pub fn test_and() {\n }\n \n #[test]\n-pub fn test_and_then() {\n+fn test_and_then() {\n     assert_eq!(op1().and_then(|i| Ok::<isize, &'static str>(i + 1)).unwrap(), 667);\n     assert_eq!(op1().and_then(|_| Err::<isize, &'static str>(\"bad\")).unwrap_err(),\n                \"bad\");\n@@ -35,7 +35,7 @@ pub fn test_and_then() {\n }\n \n #[test]\n-pub fn test_or() {\n+fn test_or() {\n     assert_eq!(op1().or(Ok::<_, &'static str>(667)).unwrap(), 666);\n     assert_eq!(op1().or(Err(\"bad\")).unwrap(), 666);\n \n@@ -44,7 +44,7 @@ pub fn test_or() {\n }\n \n #[test]\n-pub fn test_or_else() {\n+fn test_or_else() {\n     assert_eq!(op1().or_else(|_| Ok::<isize, &'static str>(667)).unwrap(), 666);\n     assert_eq!(op1().or_else(|e| Err::<isize, &'static str>(e)).unwrap(), 666);\n \n@@ -54,18 +54,17 @@ pub fn test_or_else() {\n }\n \n #[test]\n-pub fn test_impl_map() {\n+fn test_impl_map() {\n     assert!(Ok::<isize, isize>(1).map(|x| x + 1) == Ok(2));\n     assert!(Err::<isize, isize>(1).map(|x| x + 1) == Err(1));\n }\n \n #[test]\n-pub fn test_impl_map_err() {\n+fn test_impl_map_err() {\n     assert!(Ok::<isize, isize>(1).map_err(|x| x + 1) == Ok(1));\n     assert!(Err::<isize, isize>(1).map_err(|x| x + 1) == Err(2));\n }\n \n-/* FIXME(#20575)\n #[test]\n fn test_collect() {\n     let v: Result<Vec<isize>, ()> = (0..0).map(|_| Ok::<isize, ()>(0)).collect();\n@@ -86,10 +85,9 @@ fn test_collect() {\n     let v: Result<Vec<()>, isize> = functions.iter_mut().map(|f| (*f)()).collect();\n     assert!(v == Err(1));\n }\n-*/\n \n #[test]\n-pub fn test_fmt_default() {\n+fn test_fmt_default() {\n     let ok: Result<isize, &'static str> = Ok(100);\n     let err: Result<isize, &'static str> = Err(\"Err\");\n \n@@ -100,7 +98,7 @@ pub fn test_fmt_default() {\n }\n \n #[test]\n-pub fn test_unwrap_or() {\n+fn test_unwrap_or() {\n     let ok: Result<isize, &'static str> = Ok(100);\n     let ok_err: Result<isize, &'static str> = Err(\"Err\");\n \n@@ -109,7 +107,7 @@ pub fn test_unwrap_or() {\n }\n \n #[test]\n-pub fn test_unwrap_or_else() {\n+fn test_unwrap_or_else() {\n     fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n             50"}, {"sha": "7c884a73ce05bd4a83e86cc29cb3baef47ad6ba1", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -82,3 +82,34 @@ fn iterator_to_slice() {\n     test!([1u8,2,3]);\n     test!([(),(),()]);\n }\n+\n+#[test]\n+fn test_iterator_nth() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n+    }\n+    assert_eq!(v.iter().nth(v.len()), None);\n+\n+    let mut iter = v.iter();\n+    assert_eq!(iter.nth(2).unwrap(), &v[2]);\n+    assert_eq!(iter.nth(1).unwrap(), &v[4]);\n+}\n+\n+#[test]\n+fn test_iterator_last() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    assert_eq!(v.iter().last().unwrap(), &4);\n+    assert_eq!(v[..1].iter().last().unwrap(), &0);\n+}\n+\n+#[test]\n+fn test_iterator_count() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    assert_eq!(v.iter().count(), 5);\n+\n+    let mut iter2 = v.iter();\n+    iter2.next();\n+    iter2.next();\n+    assert_eq!(iter2.count(), 3);\n+}"}, {"sha": "999e7c643e576b0b4aa0a3d9f977fc133d75af88", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -140,11 +140,15 @@ pub use funcs::bsd43::*;\n \n // On NaCl, these libraries are static. Thus it would be a Bad Idea to link them\n // in when creating a test crate.\n-#[cfg(not(any(windows, all(target_os = \"nacl\", test))))]\n+#[cfg(not(any(windows, target_env = \"musl\", all(target_os = \"nacl\", test))))]\n #[link(name = \"c\")]\n #[link(name = \"m\")]\n extern {}\n \n+#[cfg(all(target_env = \"musl\", not(test)))]\n+#[link(name = \"c\", kind = \"static\")]\n+extern {}\n+\n // libnacl provides functions that require a trip through the IRT to work.\n // ie: _exit, mmap, nanosleep, etc. Anything that would otherwise require a trip\n // to the kernel."}, {"sha": "bcb827cb471cacac023c650ae81a78d147ec83d7", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -202,7 +202,7 @@ impl Rand for ChaChaRng {\n \n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use std::prelude::v1::*;\n \n     use core::iter::order;"}, {"sha": "f46d35a33db1a034b2b6190faedf084180b26fa0", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -82,7 +82,7 @@ impl IndependentSample<f64> for Exp {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use std::prelude::v1::*;\n \n     use distributions::{Sample, IndependentSample};"}, {"sha": "2951563934b3c412d273bf4ef91394806fbb41ee", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -276,7 +276,7 @@ impl IndependentSample<f64> for StudentT {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use std::prelude::v1::*;\n \n     use distributions::{Sample, IndependentSample};"}, {"sha": "22fe46a8bd83a20e9f78a1a81ec2f47fcfc28c37", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -510,7 +510,7 @@ impl Rand for Isaac64Rng {\n \n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use std::prelude::v1::*;\n \n     use core::iter::order;"}, {"sha": "bb0b13c43756b474cd1603a2d07b329dbdfadd7d", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -120,7 +120,7 @@ impl Default for ReseedWithDefault {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use std::prelude::v1::*;\n \n     use core::iter::{order, repeat};"}, {"sha": "2ef9dfd4da8dae56fff54612e90165a321bb0c27", "filename": "src/librustc/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -71,7 +71,7 @@ The rustc crate itself consists of the following submodules\n - util: ubiquitous types and helper functions\n - lib: bindings to LLVM\n \n-The entry-point for the compiler is main() in the librustc_trans\n+The entry-point for the compiler is main() in the librustc_driver\n crate.\n \n The 3 central data structures:"}, {"sha": "7fbe89648d547a410c8ab99ac7d72e1572077f5c", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -168,6 +168,25 @@ match x {\n ```\n \"##,\n \n+E0013: r##\"\n+Static and const variables can refer to other const variables. But a const\n+variable cannot refer to a static variable. For example, `Y` cannot refer to `X`\n+here:\n+\n+```\n+static X: i32 = 42;\n+const Y: i32 = X;\n+```\n+\n+To fix this, the value can be extracted as a const and then used:\n+\n+```\n+const A: i32 = 42;\n+static X: i32 = A;\n+const Y: i32 = A;\n+```\n+\"##,\n+\n E0015: r##\"\n The only function calls allowed in static or constant expressions are enum\n variant constructors or struct constructors (for unit or tuple structs). This\n@@ -336,6 +355,22 @@ enum Method { GET, POST }\n ```\n \"##,\n \n+E0265: r##\"\n+This error indicates that a static or constant references itself.\n+All statics and constants need to resolve to a value in an acyclic manner.\n+\n+For example, neither of the following can be sensibly compiled:\n+\n+```\n+const X: u32 = X;\n+```\n+\n+```\n+const X: u32 = Y;\n+const Y: u32 = X;\n+```\n+\"##,\n+\n E0267: r##\"\n This error indicates the use of loop keyword (break or continue) inside a\n closure but outside of any loop. Break and continue can be used as normal\n@@ -462,7 +497,6 @@ register_diagnostics! {\n     E0010,\n     E0011,\n     E0012,\n-    E0013,\n     E0014,\n     E0016,\n     E0017,\n@@ -482,7 +516,6 @@ register_diagnostics! {\n     E0262, // illegal lifetime parameter name\n     E0263, // lifetime name declared twice in same scope\n     E0264, // unknown external lang item\n-    E0265, // recursive constant\n     E0266, // expected item\n     E0269, // not all control paths return a value\n     E0270, // computation may converge in a function marked as diverging\n@@ -517,5 +550,3 @@ register_diagnostics! {\n     E0316, // nested quantification of lifetimes\n     E0370  // discriminant overflow\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "5bd3759a6e04e5386fadf522afb4aa21a5c74077", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -25,22 +25,23 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(associated_consts)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(fs_canonicalize)]\n #![feature(hash)]\n+#![feature(into_cow)]\n #![feature(libc)]\n+#![feature(path_ext)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(unsafe_destructor)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(path_ext)]\n #![feature(str_char)]\n-#![feature(into_cow)]\n-#![feature(slice_patterns)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]\n@@ -139,7 +140,6 @@ pub mod plugin;\n pub mod lint;\n \n pub mod util {\n-    pub use rustc_back::fs;\n     pub use rustc_back::sha2;\n \n     pub mod common;\n@@ -161,3 +161,9 @@ pub mod lib {\n mod rustc {\n     pub use lint;\n }\n+\n+// Build the diagnostics array at the end so that the metadata includes error use sites.\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "12112fd45ebe9b2d0911992f79cc1e7bd4c0b38e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -21,8 +21,10 @@ use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n \n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::rc::Rc;\n+use std::fs;\n+\n use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n@@ -32,7 +34,6 @@ use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit;\n-use util::fs;\n use log;\n \n pub struct CrateReader<'a> {\n@@ -322,7 +323,7 @@ impl<'a> CrateReader<'a> {\n             let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n             if let Some(locs) = self.sess.opts.externs.get(name) {\n                 let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(&l[..])).ok();\n+                    let l = fs::canonicalize(l).ok();\n                     source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n                     source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n                 });\n@@ -664,7 +665,7 @@ fn import_codemap(local_codemap: &codemap::CodeMap,\n                     .into_inner()\n                     .map_in_place(|mbc|\n                         codemap::MultiByteChar {\n-                            pos: mbc.pos + start_pos,\n+                            pos: mbc.pos - start_pos,\n                             bytes: mbc.bytes\n                         });\n "}, {"sha": "93056d949dbb07bfde8188d0823058ae0899c788", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -175,6 +175,13 @@ pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n+pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                                   -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.node, tcx)\n+}\n+\n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);"}, {"sha": "f03a2d342d7be0d567562ab380070d4f4d3ffc48", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -305,7 +305,25 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n-        Constant  => DlDef(def::DefConst(did)),\n+        Constant  => {\n+            // Check whether we have an associated const item.\n+            if item_sort(item) == Some('C') {\n+                // Check whether the associated const is from a trait or impl.\n+                // See the comment for methods below.\n+                let provenance = if reader::maybe_get_doc(\n+                      item, tag_item_trait_parent_sort).is_some() {\n+                    def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n+                                                                        item))\n+                } else {\n+                    def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n+                                                                       item))\n+                };\n+                DlDef(def::DefAssociatedConst(did, provenance))\n+            } else {\n+                // Regular const item.\n+                DlDef(def::DefConst(did))\n+            }\n+        }\n         ImmStatic => DlDef(def::DefStatic(did, false)),\n         MutStatic => DlDef(def::DefStatic(did, true)),\n         Struct    => DlDef(def::DefStruct(did)),\n@@ -826,6 +844,7 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n                         tag_item_impl_item, |doc| {\n         let def_id = item_def_id(doc, cdata);\n         match item_sort(doc) {\n+            Some('C') => impl_items.push(ty::ConstTraitItemId(def_id)),\n             Some('r') | Some('p') => {\n                 impl_items.push(ty::MethodTraitItemId(def_id))\n             }\n@@ -877,6 +896,18 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     let vis = item_visibility(method_doc);\n \n     match item_sort(method_doc) {\n+        Some('C') => {\n+            let ty = doc_type(method_doc, tcx, cdata);\n+            let default = get_provided_source(method_doc, cdata);\n+            ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n+                name: name,\n+                ty: ty,\n+                vis: vis,\n+                def_id: def_id,\n+                container: container,\n+                default: default,\n+            }))\n+        }\n         Some('r') | Some('p') => {\n             let generics = doc_generics(method_doc, tcx, cdata, tag_method_ty_generics);\n             let predicates = doc_predicates(method_doc, tcx, cdata, tag_method_ty_generics);\n@@ -914,6 +945,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n     reader::tagged_docs(item, tag_item_trait_item, |mth| {\n         let def_id = item_def_id(mth, cdata);\n         match item_sort(mth) {\n+            Some('C') => result.push(ty::ConstTraitItemId(def_id)),\n             Some('r') | Some('p') => {\n                 result.push(ty::MethodTraitItemId(def_id));\n             }\n@@ -951,11 +983,8 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                                     cdata,\n                                                     did.node,\n                                                     tcx);\n-            match trait_item {\n-                ty::MethodTraitItem(ref method) => {\n-                    result.push((*method).clone())\n-                }\n-                ty::TypeTraitItem(_) => {}\n+            if let ty::MethodTraitItem(ref method) = trait_item {\n+                result.push((*method).clone())\n             }\n         }\n         true\n@@ -964,6 +993,36 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n     return result;\n }\n \n+pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n+                                   cdata: Cmd,\n+                                   id: ast::NodeId,\n+                                   tcx: &ty::ctxt<'tcx>)\n+                                   -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+    let data = cdata.data();\n+    let item = lookup_item(id, data);\n+    let mut result = Vec::new();\n+\n+    for &tag in &[tag_item_trait_item, tag_item_impl_item] {\n+        reader::tagged_docs(item, tag, |ac_id| {\n+            let did = item_def_id(ac_id, cdata);\n+            let ac_doc = lookup_item(did.node, data);\n+\n+            if item_sort(ac_doc) == Some('C') {\n+                let trait_item = get_impl_or_trait_item(intr.clone(),\n+                                                        cdata,\n+                                                        did.node,\n+                                                        tcx);\n+                if let ty::ConstTraitItem(ref ac) = trait_item {\n+                    result.push((*ac).clone())\n+                }\n+            }\n+            true\n+        });\n+    }\n+\n+    return result;\n+}\n+\n pub fn get_type_name_if_impl(cdata: Cmd,\n                              node_id: ast::NodeId) -> Option<ast::Name> {\n     let item = lookup_item(node_id, cdata.data());"}, {"sha": "bcbb350fc34ee7b12489c9d0ee23dd771865d7a1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 82, "deletions": 11, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -378,14 +378,11 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n-                    match impl_item {\n-                        ty::MethodTraitItem(ref m) => {\n-                            encode_reexported_static_method(rbml_w,\n-                                                            exp,\n-                                                            m.def_id,\n-                                                            m.name);\n-                        }\n-                        ty::TypeTraitItem(_) => {}\n+                    if let ty::MethodTraitItem(ref m) = impl_item {\n+                        encode_reexported_static_method(rbml_w,\n+                                                        exp,\n+                                                        m.def_id,\n+                                                        m.name);\n                     }\n                 }\n             }\n@@ -802,6 +799,43 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_provided_source(rbml_w, method_ty.provided_source);\n }\n \n+fn encode_info_for_associated_const(ecx: &EncodeContext,\n+                                    rbml_w: &mut Encoder,\n+                                    associated_const: &ty::AssociatedConst,\n+                                    impl_path: PathElems,\n+                                    parent_id: NodeId,\n+                                    impl_item_opt: Option<&ast::ImplItem>) {\n+    debug!(\"encode_info_for_associated_const({:?},{:?})\",\n+           associated_const.def_id,\n+           token::get_name(associated_const.name));\n+\n+    rbml_w.start_tag(tag_items_data_item);\n+\n+    encode_def_id(rbml_w, associated_const.def_id);\n+    encode_name(rbml_w, associated_const.name);\n+    encode_visibility(rbml_w, associated_const.vis);\n+    encode_family(rbml_w, 'C');\n+    encode_provided_source(rbml_w, associated_const.default);\n+\n+    encode_parent_item(rbml_w, local_def(parent_id));\n+    encode_item_sort(rbml_w, 'C');\n+\n+    encode_bounds_and_type_for_item(rbml_w, ecx, associated_const.def_id.local_id());\n+\n+    let stab = stability::lookup(ecx.tcx, associated_const.def_id);\n+    encode_stability(rbml_w, stab);\n+\n+    let elem = ast_map::PathName(associated_const.name);\n+    encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n+\n+    if let Some(ii) = impl_item_opt {\n+        encode_attributes(rbml_w, &ii.attrs);\n+        encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id), ii));\n+    }\n+\n+    rbml_w.end_tag();\n+}\n+\n fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w: &mut Encoder,\n                                     m: &ty::Method<'tcx>,\n@@ -1195,6 +1229,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for &item_def_id in items {\n             rbml_w.start_tag(tag_item_impl_item);\n             match item_def_id {\n+                ty::ConstTraitItemId(item_def_id) => {\n+                    encode_def_id(rbml_w, item_def_id);\n+                    encode_item_sort(rbml_w, 'C');\n+                }\n                 ty::MethodTraitItemId(item_def_id) => {\n                     encode_def_id(rbml_w, item_def_id);\n                     encode_item_sort(rbml_w, 'r');\n@@ -1232,6 +1270,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             });\n \n             match ty::impl_or_trait_item(tcx, trait_item_def_id.def_id()) {\n+                ty::ConstTraitItem(ref associated_const) => {\n+                    encode_info_for_associated_const(ecx,\n+                                                     rbml_w,\n+                                                     &*associated_const,\n+                                                     path.clone(),\n+                                                     item.id,\n+                                                     ast_item)\n+                }\n                 ty::MethodTraitItem(ref method_type) => {\n                     encode_info_for_method(ecx,\n                                            rbml_w,\n@@ -1276,6 +1322,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for &method_def_id in &*ty::trait_item_def_ids(tcx, def_id) {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n+                ty::ConstTraitItemId(const_def_id) => {\n+                    encode_def_id(rbml_w, const_def_id);\n+                    encode_item_sort(rbml_w, 'C');\n+                }\n                 ty::MethodTraitItemId(method_def_id) => {\n                     encode_def_id(rbml_w, method_def_id);\n                     encode_item_sort(rbml_w, 'r');\n@@ -1321,6 +1371,25 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 ty::impl_or_trait_item(tcx, item_def_id.def_id());\n             let is_nonstatic_method;\n             match trait_item_type {\n+                ty::ConstTraitItem(associated_const) => {\n+                    encode_name(rbml_w, associated_const.name);\n+                    encode_def_id(rbml_w, associated_const.def_id);\n+                    encode_visibility(rbml_w, associated_const.vis);\n+\n+                    encode_provided_source(rbml_w, associated_const.default);\n+\n+                    let elem = ast_map::PathName(associated_const.name);\n+                    encode_path(rbml_w,\n+                                path.clone().chain(Some(elem).into_iter()));\n+\n+                    encode_item_sort(rbml_w, 'C');\n+                    encode_family(rbml_w, 'C');\n+\n+                    encode_bounds_and_type_for_item(rbml_w, ecx,\n+                                                    associated_const.def_id.local_id());\n+\n+                    is_nonstatic_method = false;\n+                }\n                 ty::MethodTraitItem(method_ty) => {\n                     let method_def_id = item_def_id.def_id();\n \n@@ -1365,6 +1434,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_item = &*ms[i];\n             encode_attributes(rbml_w, &trait_item.attrs);\n             match trait_item.node {\n+                ast::ConstTraitItem(_, _) => {\n+                    encode_inlined_item(ecx, rbml_w,\n+                                        IITraitItemRef(def_id, trait_item));\n+                }\n                 ast::MethodTraitItem(ref sig, ref body) => {\n                     // If this is a static method, we've already\n                     // encoded this.\n@@ -1384,9 +1457,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_method_argument_names(rbml_w, &sig.decl);\n                 }\n \n-                ast::TypeTraitItem(..) => {\n-                    encode_item_sort(rbml_w, 't');\n-                }\n+                ast::TypeTraitItem(..) => {}\n             }\n \n             rbml_w.end_tag();"}, {"sha": "7d8cf5b22a9016c6b9dec3ff8a61b147a6ee6ca5", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -18,7 +18,6 @@ use std::fs;\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n \n-use util::fs as myfs;\n use session::search_paths::{SearchPaths, PathKind};\n \n #[derive(Copy, Clone)]\n@@ -191,7 +190,7 @@ pub fn get_or_default_sysroot() -> PathBuf {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n     fn canonicalize(path: Option<PathBuf>) -> Option<PathBuf> {\n         path.and_then(|path| {\n-            match myfs::realpath(&path) {\n+            match fs::canonicalize(&path) {\n                 Ok(canon) => Some(canon),\n                 Err(e) => panic!(\"failed to get realpath: {}\", e),\n             }"}, {"sha": "062a156637a358d1af5b286c08aad6791f02281f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -225,12 +225,12 @@ use metadata::encoder;\n use metadata::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n-use util::fs;\n use util::common;\n use rustc_back::target::Target;\n \n use std::cmp;\n use std::collections::HashMap;\n+use std::fs;\n use std::io::prelude::*;\n use std::io;\n use std::path::{Path, PathBuf};\n@@ -430,9 +430,9 @@ impl<'a> Context<'a> {\n                                  .or_insert_with(|| (HashMap::new(), HashMap::new()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             if rlib {\n-                rlibs.insert(fs::realpath(path).unwrap(), kind);\n+                rlibs.insert(fs::canonicalize(path).unwrap(), kind);\n             } else {\n-                dylibs.insert(fs::realpath(path).unwrap(), kind);\n+                dylibs.insert(fs::canonicalize(path).unwrap(), kind);\n             }\n \n             FileMatches\n@@ -660,10 +660,10 @@ impl<'a> Context<'a> {\n             // there's at most one rlib and at most one dylib.\n             for loc in locs {\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(fs::realpath(&loc).unwrap(),\n+                    rlibs.insert(fs::canonicalize(&loc).unwrap(),\n                                  PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(fs::realpath(&loc).unwrap(),\n+                    dylibs.insert(fs::canonicalize(&loc).unwrap(),\n                                   PathKind::ExternFlag);\n                 }\n             }"}, {"sha": "3ef22ba8158b0ce69f93e622627cfcc7591cd59e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -465,6 +465,9 @@ impl tr for def::Def {\n           def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n           def::DefConst(did) => { def::DefConst(did.tr(dcx)) }\n+          def::DefAssociatedConst(did, p) => {\n+              def::DefAssociatedConst(did.tr(dcx), p.map(|did2| did2.tr(dcx)))\n+          }\n           def::DefLocal(nid) => { def::DefLocal(dcx.tr_id(nid)) }\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n@@ -1835,29 +1838,31 @@ fn decode_item_ast(par_doc: rbml::Doc) -> ast::Item {\n }\n \n #[cfg(test)]\n-trait fake_ext_ctxt {\n+trait FakeExtCtxt {\n+    fn call_site(&self) -> codemap::Span;\n     fn cfg(&self) -> ast::CrateConfig;\n-    fn parse_sess<'a>(&'a self) -> &'a parse::ParseSess;\n-    fn call_site(&self) -> Span;\n     fn ident_of(&self, st: &str) -> ast::Ident;\n+    fn name_of(&self, st: &str) -> ast::Name;\n+    fn parse_sess(&self) -> &parse::ParseSess;\n }\n \n #[cfg(test)]\n-impl fake_ext_ctxt for parse::ParseSess {\n-    fn cfg(&self) -> ast::CrateConfig {\n-        Vec::new()\n-    }\n-    fn parse_sess<'a>(&'a self) -> &'a parse::ParseSess { self }\n-    fn call_site(&self) -> Span {\n+impl FakeExtCtxt for parse::ParseSess {\n+    fn call_site(&self) -> codemap::Span {\n         codemap::Span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n-            expn_id: codemap::NO_EXPANSION\n+            expn_id: codemap::NO_EXPANSION,\n         }\n     }\n+    fn cfg(&self) -> ast::CrateConfig { Vec::new() }\n     fn ident_of(&self, st: &str) -> ast::Ident {\n-        token::str_to_ident(st)\n+        parse::token::str_to_ident(st)\n     }\n+    fn name_of(&self, st: &str) -> ast::Name {\n+        parse::token::intern(st)\n+    }\n+    fn parse_sess(&self) -> &parse::ParseSess { self }\n }\n \n #[cfg(test)]\n@@ -1883,15 +1888,14 @@ fn test_basic() {\n         fn foo() {}\n     ));\n }\n-/* NOTE: When there's a snapshot, update this (yay quasiquoter!)\n+\n #[test]\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n     roundtrip(quote_item!(&cx,\n         fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n     ));\n }\n-*/\n \n #[test]\n fn test_more() {"}, {"sha": "a7950a701f8c4fce0c96045d6ca81dcfa2c24db2", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -105,6 +105,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match pat.node {\n             ast::PatIdent(_, _, None) |\n             ast::PatEnum(_, None) |\n+            ast::PatQPath(..) |\n             ast::PatLit(..) |\n             ast::PatRange(..) |\n             ast::PatWild(_) => {"}, {"sha": "5b0eea6bcc51678466a24364db67707f4ef8b08b", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 77, "deletions": 50, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -46,33 +46,35 @@ bitflags! {\n     #[derive(RustcEncodable, RustcDecodable)]\n     flags ConstQualif: u8 {\n         // Const rvalue which can be placed behind a reference.\n-        const PURE_CONST          = 0b000000,\n+        const PURE_CONST         = 0,\n         // Inner mutability (can not be placed behind a reference) or behind\n         // &mut in a non-global expression. Can be copied from static memory.\n-        const MUTABLE_MEM         = 0b000001,\n+        const MUTABLE_MEM        = 1 << 0,\n         // Constant value with a type that implements Drop. Can be copied\n         // from static memory, similar to MUTABLE_MEM.\n-        const NEEDS_DROP          = 0b000010,\n+        const NEEDS_DROP         = 1 << 1,\n         // Even if the value can be placed in static memory, copying it from\n         // there is more expensive than in-place instantiation, and/or it may\n         // be too large. This applies to [T; N] and everything containing it.\n         // N.B.: references need to clear this flag to not end up on the stack.\n-        const PREFER_IN_PLACE     = 0b000100,\n+        const PREFER_IN_PLACE    = 1 << 2,\n         // May use more than 0 bytes of memory, doesn't impact the constness\n         // directly, but is not allowed to be borrowed mutably in a constant.\n-        const NON_ZERO_SIZED      = 0b001000,\n+        const NON_ZERO_SIZED     = 1 << 3,\n         // Actually borrowed, has to always be in static memory. Does not\n         // propagate, and requires the expression to behave like a 'static\n         // lvalue. The set of expressions with this flag is the minimum\n         // that have to be promoted.\n-        const HAS_STATIC_BORROWS  = 0b010000,\n+        const HAS_STATIC_BORROWS = 1 << 4,\n         // Invalid const for miscellaneous reasons (e.g. not implemented).\n-        const NOT_CONST           = 0b100000,\n+        const NOT_CONST          = 1 << 5,\n \n         // Borrowing the expression won't produce &'static T if any of these\n         // bits are set, though the value could be copied from static memory\n         // if `NOT_CONST` isn't set.\n-        const NON_STATIC_BORROWS = MUTABLE_MEM.bits | NEEDS_DROP.bits | NOT_CONST.bits\n+        const NON_STATIC_BORROWS = ConstQualif::MUTABLE_MEM.bits |\n+                                   ConstQualif::NEEDS_DROP.bits |\n+                                   ConstQualif::NOT_CONST.bits\n     }\n }\n \n@@ -102,7 +104,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     {\n         let (old_mode, old_qualif) = (self.mode, self.qualif);\n         self.mode = mode;\n-        self.qualif = PURE_CONST;\n+        self.qualif = ConstQualif::PURE_CONST;\n         let r = f(self);\n         self.mode = old_mode;\n         self.qualif = old_qualif;\n@@ -126,7 +128,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             Entry::Occupied(entry) => return *entry.get(),\n             Entry::Vacant(entry) => {\n                 // Prevent infinite recursion on re-entry.\n-                entry.insert(PURE_CONST);\n+                entry.insert(ConstQualif::PURE_CONST);\n             }\n         }\n         self.with_mode(mode, |this| {\n@@ -223,6 +225,28 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, t: &'v ast::TraitItem) {\n+        match t.node {\n+            ast::ConstTraitItem(_, ref default) => {\n+                if let Some(ref expr) = *default {\n+                    self.global_expr(Mode::Const, &*expr);\n+                } else {\n+                    visit::walk_trait_item(self, t);\n+                }\n+            }\n+            _ => self.with_mode(Mode::Var, |v| visit::walk_trait_item(v, t)),\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, i: &'v ast::ImplItem) {\n+        match i.node {\n+            ast::ConstImplItem(_, ref expr) => {\n+                self.global_expr(Mode::Const, &*expr);\n+            }\n+            _ => self.with_mode(Mode::Var, |v| visit::walk_impl_item(v, i)),\n+        }\n+    }\n+\n     fn visit_fn(&mut self,\n                 fk: visit::FnKind<'v>,\n                 fd: &'v ast::FnDecl,\n@@ -249,7 +273,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, ex: &ast::Expr) {\n         let mut outer = self.qualif;\n-        self.qualif = PURE_CONST;\n+        self.qualif = ConstQualif::PURE_CONST;\n \n         let node_ty = ty::node_id_to_type(self.tcx, ex.id);\n         check_expr(self, ex, node_ty);\n@@ -265,7 +289,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 self.visit_expr(&**callee);\n                 // The callee's size doesn't count in the call.\n                 let added = self.qualif - inner;\n-                self.qualif = inner | (added - NON_ZERO_SIZED);\n+                self.qualif = inner | (added - ConstQualif::NON_ZERO_SIZED);\n             }\n             ast::ExprRepeat(ref element, _) => {\n                 self.visit_expr(&**element);\n@@ -276,7 +300,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 };\n                 // [element; 0] is always zero-sized.\n                 if count == 0 {\n-                    self.qualif = self.qualif - (NON_ZERO_SIZED | PREFER_IN_PLACE);\n+                    self.qualif.remove(ConstQualif::NON_ZERO_SIZED | ConstQualif::PREFER_IN_PLACE);\n                 }\n             }\n             ast::ExprMatch(ref discr, ref arms, _) => {\n@@ -303,7 +327,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 let div_or_rem = op.node == ast::BiDiv || op.node == ast::BiRem;\n                 match node_ty.sty {\n                     ty::ty_uint(_) | ty::ty_int(_) if div_or_rem => {\n-                        if !self.qualif.intersects(NOT_CONST) {\n+                        if !self.qualif.intersects(ConstQualif::NOT_CONST) {\n                             match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n                                 Ok(_) => {}\n                                 Err(msg) => {\n@@ -326,11 +350,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // Constants cannot be borrowed if they contain interior mutability as\n                 // it means that our \"silent insertion of statics\" could change\n                 // initializer values (very bad).\n-                // If the type doesn't have interior mutability, then `MUTABLE_MEM` has\n+                // If the type doesn't have interior mutability, then `ConstQualif::MUTABLE_MEM` has\n                 // propagated from another error, so erroring again would be just noise.\n                 let tc = ty::type_contents(self.tcx, node_ty);\n-                if self.qualif.intersects(MUTABLE_MEM) && tc.interior_unsafe() {\n-                    outer = outer | NOT_CONST;\n+                if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n+                    outer = outer | ConstQualif::NOT_CONST;\n                     if self.mode != Mode::Var {\n                         self.tcx.sess.span_err(ex.span,\n                             \"cannot borrow a constant which contains \\\n@@ -339,32 +363,32 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 }\n                 // If the reference has to be 'static, avoid in-place initialization\n                 // as that will end up pointing to the stack instead.\n-                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n-                    self.qualif = self.qualif - PREFER_IN_PLACE;\n-                    self.add_qualif(HAS_STATIC_BORROWS);\n+                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n+                    self.qualif = self.qualif - ConstQualif::PREFER_IN_PLACE;\n+                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n                 }\n             }\n             Some(ast::MutMutable) => {\n                 // `&mut expr` means expr could be mutated, unless it's zero-sized.\n-                if self.qualif.intersects(NON_ZERO_SIZED) {\n+                if self.qualif.intersects(ConstQualif::NON_ZERO_SIZED) {\n                     if self.mode == Mode::Var {\n-                        outer = outer | NOT_CONST;\n-                        self.add_qualif(MUTABLE_MEM);\n+                        outer = outer | ConstQualif::NOT_CONST;\n+                        self.add_qualif(ConstQualif::MUTABLE_MEM);\n                     } else {\n                         span_err!(self.tcx.sess, ex.span, E0017,\n                             \"references in {}s may only refer \\\n                              to immutable values\", self.msg())\n                     }\n                 }\n-                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n-                    self.add_qualif(HAS_STATIC_BORROWS);\n+                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n+                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n                 }\n             }\n             None => {}\n         }\n         self.tcx.const_qualif_map.borrow_mut().insert(ex.id, self.qualif);\n         // Don't propagate certain flags.\n-        self.qualif = outer | (self.qualif - HAS_STATIC_BORROWS);\n+        self.qualif = outer | (self.qualif - ConstQualif::HAS_STATIC_BORROWS);\n     }\n }\n \n@@ -379,7 +403,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n     match node_ty.sty {\n         ty::ty_struct(did, _) |\n         ty::ty_enum(did, _) if ty::has_dtor(v.tcx, did) => {\n-            v.add_qualif(NEEDS_DROP);\n+            v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,\n                                     &format!(\"{}s are not allowed to have destructors\",\n@@ -394,15 +418,15 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprUnary(..) |\n         ast::ExprBinary(..) |\n         ast::ExprIndex(..) if v.tcx.method_map.borrow().contains_key(&method_call) => {\n-            v.add_qualif(NOT_CONST);\n+            v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0011,\n                             \"user-defined operators are not allowed in {}s\", v.msg());\n             }\n         }\n         ast::ExprBox(..) |\n         ast::ExprUnary(ast::UnUniq, _) => {\n-            v.add_qualif(NOT_CONST);\n+            v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0010,\n                           \"allocations are not allowed in {}s\", v.msg());\n@@ -412,7 +436,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             match ty::node_id_to_type(v.tcx, ptr.id).sty {\n                 ty::ty_ptr(_) => {\n                     // This shouldn't be allowed in constants at all.\n-                    v.add_qualif(NOT_CONST);\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n                 }\n                 _ => {}\n             }\n@@ -425,15 +449,15 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 ty::type_is_unsafe_ptr(toty) ||\n                 (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n             if !is_legal_cast {\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, e.span, E0012,\n                               \"can not cast to `{}` in {}s\",\n                               ppaux::ty_to_string(v.tcx, toty), v.msg());\n                 }\n             }\n             if ty::type_is_unsafe_ptr(fromty) && ty::type_is_numeric(toty) {\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, e.span, E0018,\n                               \"can not cast a pointer to an integer in {}s\", v.msg());\n@@ -445,17 +469,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             match def {\n                 Some(def::DefVariant(_, _, _)) => {\n                     // Count the discriminator or function pointer.\n-                    v.add_qualif(NON_ZERO_SIZED);\n+                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 Some(def::DefStruct(_)) => {\n                     if let ty::ty_bare_fn(..) = node_ty.sty {\n                         // Count the function pointer.\n-                        v.add_qualif(NON_ZERO_SIZED);\n+                        v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     }\n                 }\n                 Some(def::DefFn(..)) | Some(def::DefMethod(..)) => {\n                     // Count the function pointer.\n-                    v.add_qualif(NON_ZERO_SIZED);\n+                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 Some(def::DefStatic(..)) => {\n                     match v.mode {\n@@ -465,20 +489,23 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                                 \"constants cannot refer to other statics, \\\n                                  insert an intermediate constant instead\");\n                         }\n-                        Mode::Var => v.add_qualif(NOT_CONST)\n+                        Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n                 }\n-                Some(def::DefConst(did)) => {\n-                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did) {\n+                Some(def::DefConst(did)) |\n+                Some(def::DefAssociatedConst(did, _)) => {\n+                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did,\n+                                                                       Some(e.id)) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n                     } else {\n-                        v.tcx.sess.span_bug(e.span, \"DefConst doesn't point \\\n-                                                     to an ItemConst\");\n+                        v.tcx.sess.span_bug(e.span,\n+                                            \"DefConst or DefAssociatedConst \\\n+                                             doesn't point to a constant\");\n                     }\n                 }\n                 def => {\n-                    v.add_qualif(NOT_CONST);\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n                         debug!(\"(checking const) found bad def: {:?}\", def);\n                         span_err!(v.tcx.sess, e.span, E0014,\n@@ -505,10 +532,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 Some(def::DefStruct(..)) => {}\n                 Some(def::DefVariant(..)) => {\n                     // Count the discriminator.\n-                    v.add_qualif(NON_ZERO_SIZED);\n+                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 _ => {\n-                    v.add_qualif(NOT_CONST);\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n                         span_err!(v.tcx.sess, e.span, E0015,\n                                   \"function calls in {}s are limited to \\\n@@ -520,7 +547,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n             let mut block_span_err = |span| {\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, span, E0016,\n                               \"blocks in {}s are limited to items and \\\n@@ -549,17 +576,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprStruct(..) => {\n             let did = v.tcx.def_map.borrow().get(&e.id).map(|def| def.def_id());\n             if did == v.tcx.lang_items.unsafe_cell_type() {\n-                v.add_qualif(MUTABLE_MEM);\n+                v.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n         }\n \n         ast::ExprLit(_) |\n         ast::ExprAddrOf(..) => {\n-            v.add_qualif(NON_ZERO_SIZED);\n+            v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n         }\n \n         ast::ExprRepeat(..) => {\n-            v.add_qualif(PREFER_IN_PLACE);\n+            v.add_qualif(ConstQualif::PREFER_IN_PLACE);\n         }\n \n         ast::ExprClosure(..) => {\n@@ -568,7 +595,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n                 assert!(v.mode == Mode::Var,\n                         \"global closures can't capture anything\");\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n             }\n         }\n \n@@ -606,7 +633,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprAssignOp(..) |\n         ast::ExprInlineAsm(_) |\n         ast::ExprMac(_) => {\n-            v.add_qualif(NOT_CONST);\n+            v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0019,\n                           \"{} contains unimplemented expression type\", v.msg());\n@@ -619,7 +646,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut CheckCrateVisitor {\n         tcx: tcx,\n         mode: Mode::Var,\n-        qualif: NOT_CONST,\n+        qualif: ConstQualif::NOT_CONST,\n         rvalue_borrows: NodeMap()\n     }, tcx.map.krate());\n "}, {"sha": "a5ea3629abc84ad8fcce386d44764463b80bbd74", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -439,10 +439,11 @@ impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            ast::PatIdent(..) | ast::PatEnum(..) => {\n+            ast::PatIdent(..) | ast::PatEnum(..) | ast::PatQPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n-                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n+                    Some(DefAssociatedConst(did, _)) |\n+                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did, Some(pat.id)) {\n                         Some(const_expr) => {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n \n@@ -746,7 +747,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         ast::PatIdent(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefStruct(_)) => vec!(Single),\n@@ -755,15 +756,18 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n             },\n         ast::PatEnum(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n+        ast::PatQPath(..) =>\n+            cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n+                                            been rewritten\"),\n         ast::PatStruct(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n@@ -861,7 +865,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         ast::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n             match opt_def {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => if *constructor == Variant(id) {\n@@ -876,7 +880,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         ast::PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n-                DefConst(..) =>\n+                DefConst(..) | DefAssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 DefVariant(_, id, _) if *constructor != Variant(id) => None,\n@@ -890,11 +894,16 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n+        ast::PatQPath(_, _) => {\n+            cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n+                                            been rewritten\")\n+        }\n+\n         ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let class_id = match def {\n-                DefConst(..) =>\n+                DefConst(..) | DefAssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {"}, {"sha": "a521c4531c9a7e50e932eb81596c520754e0618d", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 75, "deletions": 37, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,10 +12,11 @@\n // recursively.\n \n use session::Session;\n-use middle::def::{DefStatic, DefConst, DefMap};\n+use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefMap};\n \n use syntax::ast;\n use syntax::{ast_util, ast_map};\n+use syntax::codemap::Span;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n@@ -26,8 +27,43 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n }\n \n impl<'v, 'a, 'ast> Visitor<'v> for CheckCrateVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n-        check_item(self, i);\n+    fn visit_item(&mut self, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemStatic(_, _, ref expr) |\n+            ast::ItemConst(_, ref expr) => {\n+                let mut recursion_visitor =\n+                    CheckItemRecursionVisitor::new(self, &it.span);\n+                recursion_visitor.visit_item(it);\n+                visit::walk_expr(self, &*expr)\n+            },\n+            _ => visit::walk_item(self, it)\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        match ti.node {\n+            ast::ConstTraitItem(_, ref default) => {\n+                if let Some(ref expr) = *default {\n+                    let mut recursion_visitor =\n+                        CheckItemRecursionVisitor::new(self, &ti.span);\n+                    recursion_visitor.visit_trait_item(ti);\n+                    visit::walk_expr(self, &*expr)\n+                }\n+            }\n+            _ => visit::walk_trait_item(self, ti)\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        match ii.node {\n+            ast::ConstImplItem(_, ref expr) => {\n+                let mut recursion_visitor =\n+                    CheckItemRecursionVisitor::new(self, &ii.span);\n+                recursion_visitor.visit_impl_item(ii);\n+                visit::walk_expr(self, &*expr)\n+            }\n+            _ => visit::walk_impl_item(self, ii)\n+        }\n     }\n }\n \n@@ -44,63 +80,65 @@ pub fn check_crate<'ast>(sess: &Session,\n     sess.abort_if_errors();\n }\n \n-fn check_item(v: &mut CheckCrateVisitor, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemStatic(_, _, ref ex) |\n-        ast::ItemConst(_, ref ex) => {\n-            check_item_recursion(v.sess, v.ast_map, v.def_map, it);\n-            visit::walk_expr(v, &**ex)\n-        },\n-        _ => visit::walk_item(v, it)\n-    }\n-}\n-\n struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n-    root_it: &'a ast::Item,\n+    root_span: &'a Span,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a DefMap,\n     idstack: Vec<ast::NodeId>\n }\n \n-// Make sure a const item doesn't recursively refer to itself\n-// FIXME: Should use the dependency graph when it's available (#1356)\n-pub fn check_item_recursion<'a>(sess: &'a Session,\n-                                ast_map: &'a ast_map::Map,\n-                                def_map: &'a DefMap,\n-                                it: &'a ast::Item) {\n-\n-    let mut visitor = CheckItemRecursionVisitor {\n-        root_it: it,\n-        sess: sess,\n-        ast_map: ast_map,\n-        def_map: def_map,\n-        idstack: Vec::new()\n-    };\n-    visitor.visit_item(it);\n+impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n+    fn new(v: &CheckCrateVisitor<'a, 'ast>, span: &'a Span)\n+           -> CheckItemRecursionVisitor<'a, 'ast> {\n+        CheckItemRecursionVisitor {\n+            root_span: span,\n+            sess: v.sess,\n+            ast_map: v.ast_map,\n+            def_map: v.def_map,\n+            idstack: Vec::new()\n+        }\n+    }\n+    fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F)\n+          where F: Fn(&mut Self) {\n+        if self.idstack.iter().any(|x| x == &(id)) {\n+            span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n+            return;\n+        }\n+        self.idstack.push(id);\n+        f(self);\n+        self.idstack.pop();\n+    }\n }\n \n impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        if self.idstack.iter().any(|x| x == &(it.id)) {\n-            span_err!(self.sess, self.root_it.span, E0265, \"recursive constant\");\n-            return;\n-        }\n-        self.idstack.push(it.id);\n-        visit::walk_item(self, it);\n-        self.idstack.pop();\n+        self.with_item_id_pushed(it.id, |v| visit::walk_item(v, it));\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        self.with_item_id_pushed(ti.id, |v| visit::walk_trait_item(v, ti));\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        self.with_item_id_pushed(ii.id, |v| visit::walk_impl_item(v, ii));\n     }\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprPath(..) => {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n+                    Some(DefAssociatedConst(def_id, _)) |\n                     Some(DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {\n                         match self.ast_map.get(def_id.node) {\n                           ast_map::NodeItem(item) =>\n                             self.visit_item(item),\n+                          ast_map::NodeTraitItem(item) =>\n+                            self.visit_trait_item(item),\n+                          ast_map::NodeImplItem(item) =>\n+                            self.visit_impl_item(item),\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n                             span_err!(self.sess, e.span, E0266,"}, {"sha": "916874f1c51a8ec2eeb24e79ed30e60c89f1b367", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 164, "deletions": 9, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -16,11 +16,12 @@ pub use self::const_val::*;\n use self::ErrKind::*;\n \n use metadata::csearch;\n-use middle::{astencode, def};\n+use middle::{astencode, def, infer, subst, traits};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::num::ToPrimitive;\n+use util::ppaux::Repr;\n \n use syntax::ast::{self, Expr};\n use syntax::codemap::Span;\n@@ -39,8 +40,9 @@ use std::rc::Rc;\n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n     match opt_def {\n-        Some(def::DefConst(def_id)) => {\n-            lookup_const_by_id(tcx, def_id)\n+        Some(def::DefConst(def_id)) |\n+        Some(def::DefAssociatedConst(def_id, _)) => {\n+            lookup_const_by_id(tcx, def_id, Some(e.id))\n         }\n         Some(def::DefVariant(enum_def, variant_def, _)) => {\n             lookup_variant_by_id(tcx, enum_def, variant_def)\n@@ -101,14 +103,46 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n     }\n }\n \n-pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n-                          -> Option<&'a Expr> {\n+pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n+                                        def_id: ast::DefId,\n+                                        maybe_ref_id: Option<ast::NodeId>)\n+                                        -> Option<&'tcx Expr> {\n     if ast_util::is_local(def_id) {\n         match tcx.map.find(def_id.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemConst(_, ref const_expr) => {\n-                    Some(&**const_expr)\n+                    Some(&*const_expr)\n+                }\n+                _ => None\n+            },\n+            Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n+                ast::ConstTraitItem(_, _) => {\n+                    match maybe_ref_id {\n+                        // If we have a trait item, and we know the expression\n+                        // that's the source of the obligation to resolve it,\n+                        // `resolve_trait_associated_const` will select an impl\n+                        // or the default.\n+                        Some(ref_id) => {\n+                            let trait_id = ty::trait_of_item(tcx, def_id)\n+                                              .unwrap();\n+                            resolve_trait_associated_const(tcx, ti, trait_id,\n+                                                           ref_id)\n+                        }\n+                        // Technically, without knowing anything about the\n+                        // expression that generates the obligation, we could\n+                        // still return the default if there is one. However,\n+                        // it's safer to return `None` than to return some value\n+                        // that may differ from what you would get from\n+                        // correctly selecting an impl.\n+                        None => None\n+                    }\n+                }\n+                _ => None\n+            },\n+            Some(ast_map::NodeImplItem(ii)) => match ii.node {\n+                ast::ConstImplItem(_, ref expr) => {\n+                    Some(&*expr)\n                 }\n                 _ => None\n             },\n@@ -122,16 +156,44 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n             }\n             None => {}\n         }\n+        let mut used_ref_id = false;\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n             csearch::FoundAst::Found(&ast::IIItem(ref item)) => match item.node {\n                 ast::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n+            csearch::FoundAst::Found(&ast::IITraitItem(trait_id, ref ti)) => match ti.node {\n+                ast::ConstTraitItem(_, _) => {\n+                    used_ref_id = true;\n+                    match maybe_ref_id {\n+                        // As mentioned in the comments above for in-crate\n+                        // constants, we only try to find the expression for\n+                        // a trait-associated const if the caller gives us\n+                        // the expression that refers to it.\n+                        Some(ref_id) => {\n+                            resolve_trait_associated_const(tcx, ti, trait_id,\n+                                                           ref_id).map(|e| e.id)\n+                        }\n+                        None => None\n+                    }\n+                }\n+                _ => None\n+            },\n+            csearch::FoundAst::Found(&ast::IIImplItem(_, ref ii)) => match ii.node {\n+                ast::ConstImplItem(_, ref expr) => Some(expr.id),\n+                _ => None\n+            },\n             _ => None\n         };\n-        tcx.extern_const_statics.borrow_mut().insert(def_id,\n-                                                     expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        // If we used the reference expression, particularly to choose an impl\n+        // of a trait-associated const, don't cache that, because the next\n+        // lookup with the same def_id may yield a different result.\n+        if !used_ref_id {\n+            tcx.extern_const_statics\n+               .borrow_mut().insert(def_id,\n+                                    expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        }\n         expr_id.map(|id| tcx.map.expect_expr(id))\n     }\n }\n@@ -755,7 +817,35 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           _ => (None, None)\n                       }\n                   } else {\n-                      (lookup_const_by_id(tcx, def_id), None)\n+                      (lookup_const_by_id(tcx, def_id, Some(e.id)), None)\n+                  }\n+              }\n+              Some(def::DefAssociatedConst(def_id, provenance)) => {\n+                  if ast_util::is_local(def_id) {\n+                      match provenance {\n+                          def::FromTrait(trait_id) => match tcx.map.find(def_id.node) {\n+                              Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n+                                  ast::ConstTraitItem(ref ty, _) => {\n+                                      (resolve_trait_associated_const(tcx, ti,\n+                                                                      trait_id, e.id),\n+                                       Some(&**ty))\n+                                  }\n+                                  _ => (None, None)\n+                              },\n+                              _ => (None, None)\n+                          },\n+                          def::FromImpl(_) => match tcx.map.find(def_id.node) {\n+                              Some(ast_map::NodeImplItem(ii)) => match ii.node {\n+                                  ast::ConstImplItem(ref ty, ref expr) => {\n+                                      (Some(&**expr), Some(&**ty))\n+                                  }\n+                                  _ => (None, None)\n+                              },\n+                              _ => (None, None)\n+                          },\n+                      }\n+                  } else {\n+                      (lookup_const_by_id(tcx, def_id, Some(e.id)), None)\n                   }\n               }\n               Some(def::DefVariant(enum_def, variant_def, _)) => {\n@@ -833,6 +923,71 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n     Ok(result)\n }\n \n+fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n+                                                ti: &'tcx ast::TraitItem,\n+                                                trait_id: ast::DefId,\n+                                                ref_id: ast::NodeId)\n+                                                -> Option<&'tcx Expr>\n+{\n+    let rcvr_substs = ty::node_id_item_substs(tcx, ref_id).substs;\n+    let subst::SeparateVecsPerParamSpace {\n+        types: rcvr_type,\n+        selfs: rcvr_self,\n+        fns: _,\n+    } = rcvr_substs.types.split();\n+    let trait_substs =\n+        subst::Substs::erased(subst::VecPerParamSpace::new(rcvr_type,\n+                                                           rcvr_self,\n+                                                           Vec::new()));\n+    let trait_substs = tcx.mk_substs(trait_substs);\n+    debug!(\"resolve_trait_associated_const: trait_substs={}\",\n+           trait_substs.repr(tcx));\n+    let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n+                                                      substs: trait_substs }));\n+\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    let param_env = ty::empty_parameter_environment(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &param_env);\n+    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                             trait_ref.to_poly_trait_predicate());\n+    let selection = match selcx.select(&obligation) {\n+        Ok(Some(vtable)) => vtable,\n+        // Still ambiguous, so give up and let the caller decide whether this\n+        // expression is really needed yet. Some associated constant values\n+        // can't be evaluated until monomorphization is done in trans.\n+        Ok(None) => {\n+            return None\n+        }\n+        Err(e) => {\n+            tcx.sess.span_bug(ti.span,\n+                              &format!(\"Encountered error `{}` when trying \\\n+                                        to select an implementation for \\\n+                                        constant trait item reference.\",\n+                                       e.repr(tcx)))\n+        }\n+    };\n+\n+    match selection {\n+        traits::VtableImpl(ref impl_data) => {\n+            match ty::associated_consts(tcx, impl_data.impl_def_id)\n+                     .iter().find(|ic| ic.name == ti.ident.name) {\n+                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n+                None => match ti.node {\n+                    ast::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),\n+                    _ => None,\n+                },\n+            }\n+        }\n+        _ => {\n+            tcx.sess.span_bug(\n+                ti.span,\n+                &format!(\"resolve_trait_associated_const: unexpected vtable type\"))\n+        }\n+    }\n+}\n+\n fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult {\n     macro_rules! convert_val {\n         ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {"}, {"sha": "1aa2ca9115d2f61429d3d62b36921c1254138db2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n         self.tcx.def_map.borrow().get(id).map(|def| {\n             match def.full_def() {\n-                def::DefConst(_) => {\n+                def::DefConst(_) | def::DefAssociatedConst(..) => {\n                     self.check_def_id(def.def_id())\n                 }\n                 _ if self.ignore_non_const_paths => (),\n@@ -114,14 +114,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         let trait_item = ty::trait_item(self.tcx,\n                                                         trait_ref.def_id,\n                                                         index);\n-                        match trait_item {\n-                            ty::MethodTraitItem(method) => {\n-                                self.check_def_id(method.def_id);\n-                            }\n-                            ty::TypeTraitItem(typedef) => {\n-                                self.check_def_id(typedef.def_id);\n-                            }\n-                        }\n+                        self.check_def_id(trait_item.def_id());\n                     }\n                 }\n             }\n@@ -353,6 +346,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n                 for trait_item in trait_items {\n                     match trait_item.node {\n+                        ast::ConstTraitItem(_, Some(_)) |\n                         ast::MethodTraitItem(_, Some(_)) => {\n                             if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n                                 self.worklist.push(trait_item.id);\n@@ -365,6 +359,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 for impl_item in impl_items {\n                     match impl_item.node {\n+                        ast::ConstImplItem(..) |\n                         ast::MethodImplItem(..) => {\n                             if opt_trait.is_some() ||\n                                     has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n@@ -406,7 +401,7 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n         None => ()\n     }\n \n-    // Seed implemented trait methods\n+    // Seed implemented trait items\n     let mut life_seeder = LifeSeeder {\n         worklist: worklist\n     };\n@@ -487,7 +482,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n                              |ctor| self.live_symbols.contains(&ctor)) {\n             return true;\n         }\n-        // If it's a type whose methods are live, then it's live, too.\n+        // If it's a type whose items are live, then it's live, too.\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n@@ -557,21 +552,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         visit::walk_foreign_item(self, fi);\n     }\n \n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>,\n-                _: &'v ast::FnDecl, block: &'v ast::Block,\n-                span: codemap::Span, id: ast::NodeId) {\n-        // Have to warn method here because methods are not ast::Item\n-        match fk {\n-            visit::FkMethod(name, _, _) => {\n-                if !self.symbol_is_live(id, None) {\n-                    self.warn_dead_code(id, span, name.name, \"method\");\n-                }\n-            }\n-            _ => ()\n-        }\n-        visit::walk_block(self, block);\n-    }\n-\n     fn visit_struct_field(&mut self, field: &ast::StructField) {\n         if self.should_warn_about_field(&field.node) {\n             self.warn_dead_code(field.node.id, field.span,\n@@ -581,12 +561,37 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         visit::walk_struct_field(self, field);\n     }\n \n-    // Overwrite so that we don't warn the trait method itself.\n-    fn visit_trait_item(&mut self, trait_method: &ast::TraitItem) {\n-        match trait_method.node {\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        match impl_item.node {\n+            ast::ConstImplItem(_, ref expr) => {\n+                if !self.symbol_is_live(impl_item.id, None) {\n+                    self.warn_dead_code(impl_item.id, impl_item.span,\n+                                        impl_item.ident.name, \"associated const\");\n+                }\n+                visit::walk_expr(self, expr)\n+            }\n+            ast::MethodImplItem(_, ref body) => {\n+                if !self.symbol_is_live(impl_item.id, None) {\n+                    self.warn_dead_code(impl_item.id, impl_item.span,\n+                                        impl_item.ident.name, \"method\");\n+                }\n+                visit::walk_block(self, body)\n+            }\n+            ast::TypeImplItem(..) |\n+            ast::MacImplItem(..) => {}\n+        }\n+    }\n+\n+    // Overwrite so that we don't warn the trait item itself.\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        match trait_item.node {\n+            ast::ConstTraitItem(_, Some(ref expr)) => {\n+                visit::walk_expr(self, expr)\n+            }\n             ast::MethodTraitItem(_, Some(ref body)) => {\n                 visit::walk_block(self, body)\n             }\n+            ast::ConstTraitItem(_, None) |\n             ast::MethodTraitItem(_, None) |\n             ast::TypeTraitItem(..) => {}\n         }"}, {"sha": "bce246fa4af866dbd2ec1f974dbdd4158ee5f0f0", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -28,6 +28,7 @@ pub enum Def {\n     DefForeignMod(ast::DefId),\n     DefStatic(ast::DefId, bool /* is_mutbl */),\n     DefConst(ast::DefId),\n+    DefAssociatedConst(ast::DefId /* const */, MethodProvenance),\n     DefLocal(ast::NodeId),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n@@ -140,7 +141,8 @@ impl Def {\n             DefFn(id, _) | DefMod(id) | DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n             DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n-            DefMethod(id, _) | DefConst(id) | DefSelfTy(Some(id), None)=> {\n+            DefMethod(id, _) | DefConst(id) | DefAssociatedConst(id, _) |\n+            DefSelfTy(Some(id), None)=> {\n                 id\n             }\n             DefLocal(id) |"}, {"sha": "d740d24e23672d9016e8c76a9a9f8f60884733e1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -234,7 +234,7 @@ impl OverloadedCallType {\n             ty::MethodTraitItem(ref method_descriptor) => {\n                 (*method_descriptor).clone()\n             }\n-            ty::TypeTraitItem(_) => {\n+            _ => {\n                 tcx.sess.bug(\"overloaded call method wasn't in method map\")\n             }\n         };\n@@ -1147,7 +1147,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             let tcx = typer.tcx();\n \n             match pat.node {\n-                ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n+                ast::PatEnum(_, _) | ast::PatQPath(..) |\n+                ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n                     match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {\n                             // no definition found: pat is not a\n@@ -1183,6 +1184,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         }\n \n                         Some(def::DefConst(..)) |\n+                        Some(def::DefAssociatedConst(..)) |\n                         Some(def::DefLocal(..)) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no"}, {"sha": "22e3376e09ea8f4a46ba4cd8bcabd84c597b8412", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -843,8 +843,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n-                        ast::TypeImplItem(_) => None,\n-                        ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n+                        ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\"),\n+                        _ => None,\n                     }\n                 },\n                 ast_map::NodeTraitItem(item) => {\n@@ -1723,8 +1723,8 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                         taken.push_all(&sig.generics.lifetimes);\n                         Some(ii.id)\n                     }\n-                    ast::TypeImplItem(_) => None,\n-                    ast::MacImplItem(_) => tcx.sess.bug(\"unexpanded macro\")\n+                    ast::MacImplItem(_) => tcx.sess.bug(\"unexpanded macro\"),\n+                    _ => None,\n                 }\n             }\n             _ => None"}, {"sha": "c4ab89e3b4da07ef0de3663309127aeda946a7b9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -589,7 +589,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefConst(..) |\n-          def::DefFn(..) | def::DefMethod(..) => {\n+          def::DefAssociatedConst(..) | def::DefFn(..) | def::DefMethod(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n@@ -838,20 +838,20 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n         let qualif = self.tcx().const_qualif_map.borrow().get(&id).cloned()\n-                               .unwrap_or(check_const::NOT_CONST);\n+                               .unwrap_or(check_const::ConstQualif::NOT_CONST);\n \n         // Only promote `[T; 0]` before an RFC for rvalue promotions\n         // is accepted.\n         let qualif = match expr_ty.sty {\n             ty::ty_vec(_, Some(0)) => qualif,\n-            _ => check_const::NOT_CONST\n+            _ => check_const::ConstQualif::NOT_CONST\n         };\n \n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n-        let re = match qualif & check_const::NON_STATIC_BORROWS {\n-            check_const::PURE_CONST => ty::ReStatic,\n+        let re = match qualif & check_const::ConstQualif::NON_STATIC_BORROWS {\n+            check_const::ConstQualif::PURE_CONST => ty::ReStatic,\n             _ => self.temporary_scope(id),\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n@@ -1286,7 +1286,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         try!(self.cat_pattern_(cmt_field, &**subpat, op));\n                     }\n                 }\n-                Some(def::DefConst(..)) => {\n+                Some(def::DefConst(..)) | Some(def::DefAssociatedConst(..)) => {\n                     for subpat in subpats {\n                         try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }\n@@ -1299,6 +1299,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n           }\n \n+          ast::PatQPath(..) => {\n+              // Lone constant: ignore\n+          }\n+\n           ast::PatIdent(_, _, Some(ref subpat)) => {\n               try!(self.cat_pattern_(cmt, &**subpat, op));\n           }"}, {"sha": "27a30f5cf253cf97da67691b72b29ec2863119cc", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -30,7 +30,7 @@ pub fn pat_id_map(dm: &DefMap, pat: &ast::Pat) -> PatIdMap {\n \n pub fn pat_is_refutable(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        ast::PatLit(_) | ast::PatRange(_, _) => true,\n+        ast::PatLit(_) | ast::PatRange(_, _) | ast::PatQPath(..) => true,\n         ast::PatEnum(_, _) |\n         ast::PatIdent(_, _, None) |\n         ast::PatStruct(..) => {\n@@ -60,9 +60,25 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n \n pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        ast::PatIdent(_, _, None) | ast::PatEnum(..) => {\n+        ast::PatIdent(_, _, None) | ast::PatEnum(..) | ast::PatQPath(..) => {\n             match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) => true,\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n+                _ => false\n+            }\n+        }\n+        _ => false\n+    }\n+}\n+\n+// Same as above, except that partially-resolved defs cause `false` to be\n+// returned instead of a panic.\n+pub fn pat_is_resolved_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n+    match pat.node {\n+        ast::PatIdent(_, _, None) | ast::PatEnum(..) | ast::PatQPath(..) => {\n+            match dm.borrow().get(&pat.id)\n+                    .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n+                                  else { None } ) {\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "b532dc88df4cb5c939c6935ddd20bd1edbd2fba8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n-                            def::DefConst(..) => {\n+                            def::DefConst(..) | def::DefAssociatedConst(..) => {\n                                 self.worklist.push(def_id.node);\n                             }\n \n@@ -183,12 +183,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n                 match trait_method.node {\n+                    ast::ConstTraitItem(_, ref default) => default.is_some(),\n                     ast::MethodTraitItem(_, ref body) => body.is_some(),\n                     ast::TypeTraitItem(..) => false,\n                 }\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n                 match impl_item.node {\n+                    ast::ConstImplItem(..) => true,\n                     ast::MethodImplItem(ref sig, _) => {\n                         if generics_require_inlining(&sig.generics) ||\n                                 attr::requests_inline(&impl_item.attrs) {\n@@ -303,9 +305,13 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n                 match trait_method.node {\n+                    ast::ConstTraitItem(_, None) |\n                     ast::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n+                    ast::ConstTraitItem(_, Some(ref expr)) => {\n+                        self.visit_expr(&*expr);\n+                    }\n                     ast::MethodTraitItem(_, Some(ref body)) => {\n                         visit::walk_block(self, body);\n                     }\n@@ -314,6 +320,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n+                    ast::ConstImplItem(_, ref expr) => {\n+                        self.visit_expr(&*expr);\n+                    }\n                     ast::MethodImplItem(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {"}, {"sha": "3d6ed3c34406118fdea3f0bedfc381d78e7e7c6e", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -100,9 +100,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                         .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n                         .into_iter()\n                 }\n-                ty::TypeTraitItem(_) => {\n-                    None.into_iter()\n-                }\n+                _ => None.into_iter(),\n             }\n         })\n         .collect();"}, {"sha": "9cdae21868ed3393ec4493ca2c7cb06fce921c80", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -863,7 +863,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     for impl_item in impl_items {\n         let assoc_type = match *impl_or_trait_items_map.get(&impl_item.def_id()).unwrap() {\n             ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n-            ty::MethodTraitItem(..) => { continue; }\n+            ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => { continue; }\n         };\n \n         if assoc_type.name != obligation.predicate.item_name {"}, {"sha": "6ecff3b7faabe9178064a6676be5deaf85124cf5", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -434,7 +434,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         for trait_item in &**trait_items {\n             match *trait_item {\n                 ty::MethodTraitItem(_) => method_count += 1,\n-                ty::TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n     }\n@@ -445,14 +445,14 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     for trait_item in trait_items.iter().take(method_offset_in_trait) {\n         match *trait_item {\n             ty::MethodTraitItem(_) => method_count += 1,\n-            ty::TypeTraitItem(_) => {}\n+            _ => {}\n         }\n     }\n \n     // the item at the offset we were given really ought to be a method\n     assert!(match trait_items[method_offset_in_trait] {\n         ty::MethodTraitItem(_) => true,\n-        ty::TypeTraitItem(_) => false\n+        _ => false\n     });\n \n     method_count"}, {"sha": "33ba21bc7b15445c16a860328e2ca10e8f2f8b01", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 149, "deletions": 45, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -80,7 +80,7 @@ use std::vec::IntoIter;\n use collections::enum_set::{EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n use syntax::abi;\n-use syntax::ast::{CrateNum, DefId, ItemTrait, LOCAL_CRATE};\n+use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n@@ -133,13 +133,17 @@ impl ImplOrTraitItemContainer {\n \n #[derive(Clone, Debug)]\n pub enum ImplOrTraitItem<'tcx> {\n+    ConstTraitItem(Rc<AssociatedConst<'tcx>>),\n     MethodTraitItem(Rc<Method<'tcx>>),\n     TypeTraitItem(Rc<AssociatedType>),\n }\n \n impl<'tcx> ImplOrTraitItem<'tcx> {\n     fn id(&self) -> ImplOrTraitItemId {\n         match *self {\n+            ConstTraitItem(ref associated_const) => {\n+                ConstTraitItemId(associated_const.def_id)\n+            }\n             MethodTraitItem(ref method) => MethodTraitItemId(method.def_id),\n             TypeTraitItem(ref associated_type) => {\n                 TypeTraitItemId(associated_type.def_id)\n@@ -149,20 +153,31 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n \n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.def_id,\n             MethodTraitItem(ref method) => method.def_id,\n             TypeTraitItem(ref associated_type) => associated_type.def_id,\n         }\n     }\n \n     pub fn name(&self) -> ast::Name {\n         match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.name,\n             MethodTraitItem(ref method) => method.name,\n             TypeTraitItem(ref associated_type) => associated_type.name,\n         }\n     }\n \n+    pub fn vis(&self) -> ast::Visibility {\n+        match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.vis,\n+            MethodTraitItem(ref method) => method.vis,\n+            TypeTraitItem(ref associated_type) => associated_type.vis,\n+        }\n+    }\n+\n     pub fn container(&self) -> ImplOrTraitItemContainer {\n         match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.container,\n             MethodTraitItem(ref method) => method.container,\n             TypeTraitItem(ref associated_type) => associated_type.container,\n         }\n@@ -171,20 +186,22 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     pub fn as_opt_method(&self) -> Option<Rc<Method<'tcx>>> {\n         match *self {\n             MethodTraitItem(ref m) => Some((*m).clone()),\n-            TypeTraitItem(_) => None\n+            _ => None,\n         }\n     }\n }\n \n #[derive(Clone, Copy, Debug)]\n pub enum ImplOrTraitItemId {\n+    ConstTraitItemId(ast::DefId),\n     MethodTraitItemId(ast::DefId),\n     TypeTraitItemId(ast::DefId),\n }\n \n impl ImplOrTraitItemId {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n+            ConstTraitItemId(def_id) => def_id,\n             MethodTraitItemId(def_id) => def_id,\n             TypeTraitItemId(def_id) => def_id,\n         }\n@@ -238,6 +255,16 @@ impl<'tcx> Method<'tcx> {\n     }\n }\n \n+#[derive(Clone, Copy, Debug)]\n+pub struct AssociatedConst<'tcx> {\n+    pub name: ast::Name,\n+    pub ty: Ty<'tcx>,\n+    pub vis: ast::Visibility,\n+    pub def_id: ast::DefId,\n+    pub container: ImplOrTraitItemContainer,\n+    pub default: Option<ast::DefId>,\n+}\n+\n #[derive(Clone, Copy, Debug)]\n pub struct AssociatedType {\n     pub name: ast::Name,\n@@ -821,16 +848,18 @@ impl<'tcx> ctxt<'tcx> {\n // recursing over the type itself.\n bitflags! {\n     flags TypeFlags: u32 {\n-        const NO_TYPE_FLAGS       = 0b0,\n-        const HAS_PARAMS          = 0b1,\n-        const HAS_SELF            = 0b10,\n-        const HAS_TY_INFER        = 0b100,\n-        const HAS_RE_INFER        = 0b1000,\n-        const HAS_RE_LATE_BOUND   = 0b10000,\n-        const HAS_REGIONS         = 0b100000,\n-        const HAS_TY_ERR          = 0b1000000,\n-        const HAS_PROJECTION      = 0b10000000,\n-        const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n+        const NO_TYPE_FLAGS     = 0,\n+        const HAS_PARAMS        = 1 << 0,\n+        const HAS_SELF          = 1 << 1,\n+        const HAS_TY_INFER      = 1 << 2,\n+        const HAS_RE_INFER      = 1 << 3,\n+        const HAS_RE_LATE_BOUND = 1 << 4,\n+        const HAS_REGIONS       = 1 << 5,\n+        const HAS_TY_ERR        = 1 << 6,\n+        const HAS_PROJECTION    = 1 << 7,\n+        const NEEDS_SUBST       = TypeFlags::HAS_PARAMS.bits |\n+                                  TypeFlags::HAS_SELF.bits |\n+                                  TypeFlags::HAS_REGIONS.bits,\n     }\n }\n \n@@ -863,8 +892,8 @@ macro_rules! sty_debug_print {\n                         ty::ty_err => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let region = t.flags.intersects(ty::HAS_RE_INFER);\n-                    let ty = t.flags.intersects(ty::HAS_TY_INFER);\n+                    let region = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;\n@@ -966,23 +995,23 @@ impl<'tcx> Borrow<sty<'tcx>> for InternedTy<'tcx> {\n }\n \n pub fn type_has_params(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_PARAMS)\n+    ty.flags.intersects(TypeFlags::HAS_PARAMS)\n }\n pub fn type_has_self(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_SELF)\n+    ty.flags.intersects(TypeFlags::HAS_SELF)\n }\n pub fn type_has_ty_infer(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_TY_INFER)\n+    ty.flags.intersects(TypeFlags::HAS_TY_INFER)\n }\n pub fn type_needs_infer(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_TY_INFER | HAS_RE_INFER)\n+    ty.flags.intersects(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n }\n pub fn type_has_projection(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_PROJECTION)\n+    ty.flags.intersects(TypeFlags::HAS_PROJECTION)\n }\n \n pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_RE_LATE_BOUND)\n+    ty.flags.intersects(TypeFlags::HAS_RE_LATE_BOUND)\n }\n \n /// An \"escaping region\" is a bound region whose binder is not part of `t`.\n@@ -2291,6 +2320,16 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n+                    ast::ConstImplItem(_, _) => {\n+                        let def_id = ast_util::local_def(id);\n+                        let scheme = lookup_item_type(cx, def_id);\n+                        let predicates = lookup_predicates(cx, def_id);\n+                        construct_parameter_environment(cx,\n+                                                        impl_item.span,\n+                                                        &scheme.generics,\n+                                                        &predicates,\n+                                                        id)\n+                    }\n                     ast::MethodImplItem(_, ref body) => {\n                         let method_def_id = ast_util::local_def(id);\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n@@ -2304,11 +2343,10 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     method_bounds,\n                                     body.id)\n                             }\n-                            TypeTraitItem(_) => {\n+                            _ => {\n                                 cx.sess\n                                   .bug(\"ParameterEnvironment::for_item(): \\\n-                                        can't create a parameter environment \\\n-                                        for type trait items\")\n+                                        got non-method item from impl method?!\")\n                             }\n                         }\n                     }\n@@ -2322,6 +2360,25 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             }\n             Some(ast_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n+                    ast::ConstTraitItem(_, ref default) => {\n+                        match *default {\n+                            Some(_) => {\n+                                let def_id = ast_util::local_def(id);\n+                                let scheme = lookup_item_type(cx, def_id);\n+                                let predicates = lookup_predicates(cx, def_id);\n+                                construct_parameter_environment(cx,\n+                                                                trait_item.span,\n+                                                                &scheme.generics,\n+                                                                &predicates,\n+                                                                id)\n+                            }\n+                            None => {\n+                                cx.sess.bug(\"ParameterEnvironment::from_item(): \\\n+                                             can't create a parameter environment \\\n+                                             for const trait items without defaults\")\n+                            }\n+                        }\n+                    }\n                     ast::MethodTraitItem(_, None) => {\n                         cx.sess.span_bug(trait_item.span,\n                                          \"ParameterEnvironment::for_item():\n@@ -2342,11 +2399,11 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     method_bounds,\n                                     body.id)\n                             }\n-                            TypeTraitItem(_) => {\n+                            _ => {\n                                 cx.sess\n                                   .bug(\"ParameterEnvironment::for_item(): \\\n-                                        can't create a parameter environment \\\n-                                        for type trait items\")\n+                                        got non-method item from provided \\\n+                                        method?!\")\n                             }\n                         }\n                     }\n@@ -2755,7 +2812,7 @@ struct FlagComputation {\n \n impl FlagComputation {\n     fn new() -> FlagComputation {\n-        FlagComputation { flags: NO_TYPE_FLAGS, depth: 0 }\n+        FlagComputation { flags: TypeFlags::NO_TYPE_FLAGS, depth: 0 }\n     }\n \n     fn for_sty(st: &sty) -> FlagComputation {\n@@ -2800,20 +2857,20 @@ impl FlagComputation {\n \n             // You might think that we could just return ty_err for\n             // any type containing ty_err as a component, and get\n-            // rid of the HAS_TY_ERR flag -- likewise for ty_bot (with\n+            // rid of the TypeFlags::HAS_TY_ERR flag -- likewise for ty_bot (with\n             // the exception of function types that return bot).\n             // But doing so caused sporadic memory corruption, and\n             // neither I (tjc) nor nmatsakis could figure out why,\n             // so we're doing it this way.\n             &ty_err => {\n-                self.add_flags(HAS_TY_ERR)\n+                self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n             &ty_param(ref p) => {\n                 if p.space == subst::SelfSpace {\n-                    self.add_flags(HAS_SELF);\n+                    self.add_flags(TypeFlags::HAS_SELF);\n                 } else {\n-                    self.add_flags(HAS_PARAMS);\n+                    self.add_flags(TypeFlags::HAS_PARAMS);\n                 }\n             }\n \n@@ -2822,15 +2879,15 @@ impl FlagComputation {\n             }\n \n             &ty_infer(_) => {\n-                self.add_flags(HAS_TY_INFER)\n+                self.add_flags(TypeFlags::HAS_TY_INFER)\n             }\n \n             &ty_enum(_, substs) | &ty_struct(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n             &ty_projection(ref data) => {\n-                self.add_flags(HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n \n@@ -2894,11 +2951,11 @@ impl FlagComputation {\n     }\n \n     fn add_region(&mut self, r: Region) {\n-        self.add_flags(HAS_REGIONS);\n+        self.add_flags(TypeFlags::HAS_REGIONS);\n         match r {\n-            ty::ReInfer(_) => { self.add_flags(HAS_RE_INFER); }\n+            ty::ReInfer(_) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n             ty::ReLateBound(debruijn, _) => {\n-                self.add_flags(HAS_RE_LATE_BOUND);\n+                self.add_flags(TypeFlags::HAS_RE_LATE_BOUND);\n                 self.add_depth(debruijn.depth);\n             }\n             _ => { }\n@@ -3252,11 +3309,11 @@ pub fn type_is_nil(ty: Ty) -> bool {\n }\n \n pub fn type_is_error(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_TY_ERR)\n+    ty.flags.intersects(TypeFlags::HAS_TY_ERR)\n }\n \n pub fn type_needs_subst(ty: Ty) -> bool {\n-    ty.flags.intersects(NEEDS_SUBST)\n+    ty.flags.intersects(TypeFlags::NEEDS_SUBST)\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n@@ -4719,7 +4776,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def::DefUpvar(..) |\n                 def::DefLocal(..) => LvalueExpr,\n \n-                def::DefConst(..) => RvalueDatumExpr,\n+                def::DefConst(..) |\n+                def::DefAssociatedConst(..) => RvalueDatumExpr,\n \n                 def => {\n                     tcx.sess.span_bug(\n@@ -5070,10 +5128,10 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 if let ast::MethodTraitItem(_, Some(_)) = ti.node {\n                     match impl_or_trait_item(cx, ast_util::local_def(ti.id)) {\n                         MethodTraitItem(m) => Some(m),\n-                        TypeTraitItem(_) => {\n+                        _ => {\n                             cx.sess.bug(\"provided_trait_methods(): \\\n-                                         associated type found from \\\n-                                         looking up ProvidedMethod?!\")\n+                                         non-method item found from \\\n+                                         looking up provided method?!\")\n                         }\n                     }\n                 } else {\n@@ -5088,6 +5146,52 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n     }\n }\n \n+pub fn associated_consts<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n+                               -> Vec<Rc<AssociatedConst<'tcx>>> {\n+    if is_local(id) {\n+        match cx.map.expect_item(id.node).node {\n+            ItemTrait(_, _, _, ref tis) => {\n+                tis.iter().filter_map(|ti| {\n+                    if let ast::ConstTraitItem(_, _) = ti.node {\n+                        match impl_or_trait_item(cx, ast_util::local_def(ti.id)) {\n+                            ConstTraitItem(ac) => Some(ac),\n+                            _ => {\n+                                cx.sess.bug(\"associated_consts(): \\\n+                                             non-const item found from \\\n+                                             looking up a constant?!\")\n+                            }\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                }).collect()\n+            }\n+            ItemImpl(_, _, _, _, _, ref iis) => {\n+                iis.iter().filter_map(|ii| {\n+                    if let ast::ConstImplItem(_, _) = ii.node {\n+                        match impl_or_trait_item(cx, ast_util::local_def(ii.id)) {\n+                            ConstTraitItem(ac) => Some(ac),\n+                            _ => {\n+                                cx.sess.bug(\"associated_consts(): \\\n+                                             non-const item found from \\\n+                                             looking up a constant?!\")\n+                            }\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                }).collect()\n+            }\n+            _ => {\n+                cx.sess.bug(&format!(\"associated_consts: `{:?}` is not a trait \\\n+                                      or impl\", id))\n+            }\n+        }\n+    } else {\n+        csearch::get_associated_consts(cx, id)\n+    }\n+}\n+\n /// Helper for looking things up in the various maps that are populated during\n /// typeck::collect (e.g., `cx.impl_or_trait_items`, `cx.tcache`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n@@ -5174,7 +5278,7 @@ pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n                 Some(ref item) => {\n                     match **item {\n                         TypeTraitItem(_) => true,\n-                        MethodTraitItem(_) => false,\n+                        _ => false,\n                     }\n                 }\n                 None => false,\n@@ -6188,7 +6292,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n                            .insert(method_def_id, source);\n                     }\n                 }\n-                TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n \n@@ -6240,7 +6344,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n                             .insert(method_def_id, source);\n                     }\n                 }\n-                TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n "}, {"sha": "b999929c4af9e4a5a24d75e4c15042865f9aa1ae", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -621,6 +621,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let arch = &sess.target.target.arch;\n     let wordsz = &sess.target.target.target_pointer_width;\n     let os = &sess.target.target.target_os;\n+    let env = &sess.target.target.target_env;\n \n     let fam = match sess.target.target.options.is_like_windows {\n         true  => InternedString::new(\"windows\"),\n@@ -634,8 +635,8 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n          mk(InternedString::new(\"target_family\"), fam),\n          mk(InternedString::new(\"target_arch\"), intern(arch)),\n          mk(InternedString::new(\"target_endian\"), intern(end)),\n-         mk(InternedString::new(\"target_pointer_width\"),\n-            intern(wordsz))\n+         mk(InternedString::new(\"target_pointer_width\"), intern(wordsz)),\n+         mk(InternedString::new(\"target_env\"), intern(env)),\n     ];\n     if sess.opts.debug_assertions {\n         ret.push(attr::mk_word_item(InternedString::new(\"debug_assertions\")));\n@@ -754,11 +755,14 @@ mod opt {\n     pub fn   multi(a: S, b: S, c: S, d: S) -> R { stable(getopts::optmulti(a, b, c, d)) }\n     pub fn    flag(a: S, b: S, c: S)       -> R { stable(getopts::optflag(a, b, c)) }\n     pub fn flagopt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optflagopt(a, b, c, d)) }\n+    pub fn flagmulti(a: S, b: S, c: S)     -> R { stable(getopts::optflagmulti(a, b, c)) }\n+\n \n     pub fn     opt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optopt(a, b, c, d)) }\n     pub fn   multi_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optmulti(a, b, c, d)) }\n     pub fn    flag_u(a: S, b: S, c: S)       -> R { unstable(getopts::optflag(a, b, c)) }\n     pub fn flagopt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optflagopt(a, b, c, d)) }\n+    pub fn flagmulti_u(a: S, b: S, c: S)     -> R { unstable(getopts::optflagmulti(a, b, c)) }\n }\n \n /// Returns the \"short\" subset of the rustc command line options,\n@@ -785,8 +789,8 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n         opt::multi(\"\", \"print\", \"Comma separated list of compiler information to \\\n                                print on stdout\",\n                  \"[crate-name|file-names|sysroot]\"),\n-        opt::flag(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n-        opt::flag(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n+        opt::flagmulti(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n+        opt::flagmulti(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n         opt::opt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n         opt::opt(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n                                 in <dir>\", \"DIR\"),\n@@ -1111,7 +1115,7 @@ impl fmt::Display for CrateType {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n \n     use session::config::{build_configuration, optgroups, build_session_options};\n     use session::build_session;"}, {"sha": "14bc19dffd5d0b6f307856c23ccdf8814b74fdf9", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -57,6 +57,8 @@ pub struct Session {\n     pub crate_metadata: RefCell<Vec<String>>,\n     pub features: RefCell<feature_gate::Features>,\n \n+    pub delayed_span_bug: RefCell<Option<(codemap::Span, String)>>,\n+\n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n     pub recursion_limit: Cell<usize>,\n@@ -114,7 +116,15 @@ impl Session {\n         self.diagnostic().handler().has_errors()\n     }\n     pub fn abort_if_errors(&self) {\n-        self.diagnostic().handler().abort_if_errors()\n+        self.diagnostic().handler().abort_if_errors();\n+\n+        let delayed_bug = self.delayed_span_bug.borrow();\n+        match *delayed_bug {\n+            Some((span, ref errmsg)) => {\n+                self.diagnostic().span_bug(span, errmsg);\n+            },\n+            _ => {}\n+        }\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n         if self.can_print_warnings {\n@@ -171,6 +181,11 @@ impl Session {\n             None => self.bug(msg),\n         }\n     }\n+    /// Delay a span_bug() call until abort_if_errors()\n+    pub fn delay_span_bug(&self, sp: Span, msg: &str) {\n+        let mut delayed = self.delayed_span_bug.borrow_mut();\n+        *delayed = Some((sp, msg.to_string()));\n+    }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_bug(sp, msg)\n     }\n@@ -402,6 +417,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         crate_metadata: RefCell::new(Vec::new()),\n+        delayed_span_bug: RefCell::new(None),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n         can_print_warnings: can_print_warnings"}, {"sha": "3d56371dd52cafc56ae365b786a0b623e1504548", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -830,6 +830,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n impl<'tcx> Repr<'tcx> for ast::TraitItem {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         let kind = match self.node {\n+            ast::ConstTraitItem(..) => \"ConstTraitItem\",\n             ast::MethodTraitItem(..) => \"MethodTraitItem\",\n             ast::TypeTraitItem(..) => \"TypeTraitItem\",\n         };\n@@ -1054,9 +1055,39 @@ impl<'tcx> Repr<'tcx> for ty::Variance {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::ImplOrTraitItem<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"ImplOrTraitItem({})\",\n+                match *self {\n+                    ty::ImplOrTraitItem::MethodTraitItem(ref i) => i.repr(tcx),\n+                    ty::ImplOrTraitItem::ConstTraitItem(ref i) => i.repr(tcx),\n+                    ty::ImplOrTraitItem::TypeTraitItem(ref i) => i.repr(tcx),\n+                })\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::AssociatedConst<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"AssociatedConst(name: {}, ty: {}, vis: {}, def_id: {})\",\n+                self.name.repr(tcx),\n+                self.ty.repr(tcx),\n+                self.vis.repr(tcx),\n+                self.def_id.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::AssociatedType {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"AssociatedType(name: {}, vis: {}, def_id: {})\",\n+                self.name.repr(tcx),\n+                self.vis.repr(tcx),\n+                self.def_id.repr(tcx))\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n+        format!(\"Method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n                  explicit_self: {}, vis: {}, def_id: {})\",\n                 self.name.repr(tcx),\n                 self.generics.repr(tcx),"}, {"sha": "2ab4d7ff78a1d256edc6fad38d6e96b17e308412", "filename": "src/librustc_back/fs.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a42aecbc85298fb6351253c4cd1824567b7a42/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=c0a42aecbc85298fb6351253c4cd1824567b7a42", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::io;\n-use std::path::{Path, PathBuf};\n-\n-#[cfg(windows)]\n-pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n-    Ok(original.to_path_buf())\n-}\n-\n-#[cfg(unix)]\n-pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n-    use libc;\n-    use std::ffi::{OsString, CString};\n-    use std::os::unix::prelude::*;\n-\n-    extern {\n-        fn realpath(pathname: *const libc::c_char, resolved: *mut libc::c_char)\n-                    -> *mut libc::c_char;\n-    }\n-\n-    let path = try!(CString::new(original.as_os_str().as_bytes()));\n-    let mut buf = vec![0u8; 16 * 1024];\n-    unsafe {\n-        let r = realpath(path.as_ptr(), buf.as_mut_ptr() as *mut _);\n-        if r.is_null() {\n-            return Err(io::Error::last_os_error())\n-        }\n-    }\n-    let p = buf.iter().position(|i| *i == 0).unwrap();\n-    buf.truncate(p);\n-    Ok(PathBuf::from(OsString::from_vec(buf)))\n-}\n-\n-#[cfg(all(not(windows), test))]\n-mod test {\n-    use tempdir::TempDir;\n-    use std::fs::{self, File};\n-    use super::realpath;\n-\n-    #[test]\n-    fn realpath_works() {\n-        let tmpdir = TempDir::new(\"rustc-fs\").unwrap();\n-        let tmpdir = realpath(tmpdir.path()).unwrap();\n-        let file = tmpdir.join(\"test\");\n-        let dir = tmpdir.join(\"test2\");\n-        let link = dir.join(\"link\");\n-        let linkdir = tmpdir.join(\"test3\");\n-\n-        File::create(&file).unwrap();\n-        fs::create_dir(&dir).unwrap();\n-        fs::soft_link(&file, &link).unwrap();\n-        fs::soft_link(&dir, &linkdir).unwrap();\n-\n-        assert_eq!(realpath(&tmpdir).unwrap(), tmpdir);\n-        assert_eq!(realpath(&file).unwrap(), file);\n-        assert_eq!(realpath(&link).unwrap(), file);\n-        assert_eq!(realpath(&linkdir).unwrap(), dir);\n-        assert_eq!(realpath(&linkdir.join(\"link\")).unwrap(), file);\n-    }\n-\n-    #[test]\n-    fn realpath_works_tricky() {\n-        let tmpdir = TempDir::new(\"rustc-fs\").unwrap();\n-        let tmpdir = realpath(tmpdir.path()).unwrap();\n-\n-        let a = tmpdir.join(\"a\");\n-        let b = a.join(\"b\");\n-        let c = b.join(\"c\");\n-        let d = a.join(\"d\");\n-        let e = d.join(\"e\");\n-        let f = a.join(\"f\");\n-\n-        fs::create_dir_all(&b).unwrap();\n-        fs::create_dir_all(&d).unwrap();\n-        File::create(&f).unwrap();\n-        fs::soft_link(\"../d/e\", &c).unwrap();\n-        fs::soft_link(\"../f\", &e).unwrap();\n-\n-        assert_eq!(realpath(&c).unwrap(), f);\n-        assert_eq!(realpath(&e).unwrap(), f);\n-    }\n-}"}, {"sha": "3e55f7f8045b59b60ee38723f34655e43f987924", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -41,6 +41,7 @@\n #![feature(path_ext)]\n #![feature(step_by)]\n #![feature(libc)]\n+#![feature(fs_canonicalize)]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;\n@@ -53,7 +54,6 @@ pub mod abi;\n pub mod archive;\n pub mod tempdir;\n pub mod arm;\n-pub mod fs;\n pub mod mips;\n pub mod mipsel;\n pub mod rpath;"}, {"sha": "6674d3135a0bdb671dbd621a1979dd97df196fca", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -10,8 +10,8 @@\n \n use std::collections::HashSet;\n use std::env;\n-use std::io;\n use std::path::{Path, PathBuf};\n+use std::fs;\n use syntax::ast;\n \n pub struct RPathConfig<'a> {\n@@ -20,7 +20,6 @@ pub struct RPathConfig<'a> {\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n     pub get_install_prefix_lib_path: &'a mut FnMut() -> PathBuf,\n-    pub realpath: &'a mut FnMut(&Path) -> io::Result<PathBuf>,\n }\n \n pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n@@ -95,11 +94,11 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String\n     };\n \n     let cwd = env::current_dir().unwrap();\n-    let mut lib = (config.realpath)(&cwd.join(lib)).unwrap();\n+    let mut lib = fs::canonicalize(&cwd.join(lib)).unwrap_or(cwd.join(lib));\n     lib.pop();\n     let mut output = cwd.join(&config.out_filename);\n     output.pop();\n-    let output = (config.realpath)(&output).unwrap();\n+    let output = fs::canonicalize(&output).unwrap_or(output);\n     let relative = path_relative_from(&lib, &output)\n         .expect(&format!(\"couldn't create relative path from {:?} to {:?}\", output, lib));\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -171,7 +170,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n }\n \n #[cfg(all(unix, test))]\n-mod test {\n+mod tests {\n     use super::{RPathConfig};\n     use super::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n     use std::path::{Path, PathBuf};\n@@ -231,7 +230,6 @@ mod test {\n                 is_like_osx: true,\n                 out_filename: PathBuf::from(\"bin/rustc\"),\n                 get_install_prefix_lib_path: &mut || panic!(),\n-                realpath: &mut |p| Ok(p.to_path_buf()),\n             };\n             let res = get_rpath_relative_to_output(config,\n                                                    Path::new(\"lib/libstd.so\"));\n@@ -243,7 +241,6 @@ mod test {\n                 get_install_prefix_lib_path: &mut || panic!(),\n                 has_rpath: true,\n                 is_like_osx: false,\n-                realpath: &mut |p| Ok(p.to_path_buf()),\n             };\n             let res = get_rpath_relative_to_output(config,\n                                                    Path::new(\"lib/libstd.so\"));"}, {"sha": "dd6bc672a03d996ab8d1cf390eac171cef3696e5", "filename": "src/librustc_back/target/aarch64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"ios\".to_string(),\n+        target_env: \"\".to_string(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+cyclone\".to_string(),\n             eliminate_frame_pointer: false,"}, {"sha": "67194e7ac5c7c8c43832803f755df8aae57081a5", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,10 +11,6 @@\n use target::Target;\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n-    base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n-    base.is_like_android = true;\n-    base.position_independent_executables = true;\n     Target {\n         data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n                       f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n@@ -24,6 +20,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"android\".to_string(),\n-        options: base,\n+        target_env: \"\".to_string(),\n+        options: super::android_base::opts(),\n     }\n }"}, {"sha": "18e67d066d03632f8c148a54c03326411364fc44", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        target_env: \"gnu\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"linux\".to_string(),\n         options: base,"}, {"sha": "2883ffd6e9f2244ccd24b24dea153eeac6422792", "filename": "src/librustc_back/target/android_base.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fandroid_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fandroid_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fandroid_base.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut base = super::linux_base::opts();\n+    // Many of the symbols defined in compiler-rt are also defined in libgcc.\n+    // Android's linker doesn't like that by default.\n+    base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n+    base.is_like_android = true;\n+    base.position_independent_executables = true;\n+    base\n+}"}, {"sha": "cbaa2b205b05512c36f660e5d10ec2a989653b86", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,26 +11,19 @@\n use target::Target;\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::android_base::opts();\n     base.features = \"+v7\".to_string();\n-    // Many of the symbols defined in compiler-rt are also defined in libgcc.  Android\n-    // linker doesn't like that by default.\n-    base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n-    base.is_like_android = true;\n-    // FIXME #17437 (and #17448): Android doesn't support position dependent executables anymore.\n-    base.position_independent_executables = false;\n \n     Target {\n-        data_layout: \"e-p:32:32:32\\\n-                      -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n-                      -f32:32:32-f64:64:64\\\n-                      -v64:64:64-v128:64:128\\\n-                      -a:0:64-n32\".to_string(),\n+        data_layout: \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:64:128-a:0:64-\\\n+                      n32\".to_string(),\n         llvm_target: \"arm-linux-androideabi\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"android\".to_string(),\n+        target_env: \"gnu\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "30015c4a7e6ff0ef1a34a6b04fd36ea956162ffd", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"linux\".to_string(),\n+        target_env: \"gnueabi\".to_string(),\n \n         options: TargetOptions {\n             features: \"+v6\".to_string(),"}, {"sha": "8f8c7114e6effa537c55bdeec16fa3b0ccb3a304", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"linux\".to_string(),\n+        target_env: \"gnueabihf\".to_string(),\n \n         options: TargetOptions {\n             features: \"+v6,+vfp2\".to_string(),"}, {"sha": "3b55993659de24c132dbbb585b7fb7832b44c9c3", "filename": "src/librustc_back/target/armv7_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"ios\".to_string(),\n+        target_env: \"\".to_string(),\n         options: TargetOptions {\n             features: \"+v7,+vfp3,+neon\".to_string(),\n             .. opts(Arch::Armv7)"}, {"sha": "5a67e3fe127d6f375bb7018a9ccf7b45da1ddce4", "filename": "src/librustc_back/target/armv7s_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"ios\".to_string(),\n+        target_env: \"\".to_string(),\n         options: TargetOptions {\n             features: \"+v7,+vfp4,+neon\".to_string(),\n             .. opts(Arch::Armv7s)"}, {"sha": "a9a073e2a8c64ae3db1c0394edc549f430b38329", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"ios\".to_string(),\n+        target_env: \"\".to_string(),\n         options: opts(Arch::I386)\n     }\n }"}, {"sha": "47b329982d43e29383a77083d92c556c7e835a85", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -26,6 +26,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"macos\".to_string(),\n+        target_env: \"\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "9e2aa20085c3634f1dde00f97e1eb0def39a5ecf", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -30,6 +30,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"windows\".to_string(),\n+        target_env: \"gnu\".to_string(),\n         options: options,\n     }\n }"}, {"sha": "ecabe71ad4c6c635ef279472ac60868a6cdd38c2", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"dragonfly\".to_string(),\n+        target_env: \"\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "21094ad905e90f5c281c8d451fa44fb676b97399", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "823a4a81fa4c19f98f1cf04834c7640ad9695530", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -19,12 +19,16 @@ pub fn opts() -> TargetOptions {\n         morestack: true,\n         linker_is_gnu: true,\n         has_rpath: true,\n-        pre_link_args: vec!(\n-            // GNU-style linkers will use this to omit linking to libraries which\n-            // don't actually fulfill any relocations, but only for libraries which\n-            // follow this flag. Thus, use it before specifying libraries to link to.\n+        pre_link_args: vec![\n+            // We want to be able to strip as much executable code as possible\n+            // from the linker command line, and this flag indicates to the\n+            // linker that it can avoid linking in dynamic libraries that don't\n+            // actually satisfy any symbols up to that point (as with many other\n+            // resolutions the linker does). This option only applies to all\n+            // following libraries so we're sure to pass it as one of the first\n+            // arguments.\n             \"-Wl,--as-needed\".to_string(),\n-        ),\n+        ],\n         position_independent_executables: true,\n         .. Default::default()\n     }"}, {"sha": "4662ff1958ba87de61a7d1922324e047f7185f90", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"mips\".to_string(),\n         target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n         options: super::linux_base::opts()\n     }\n }"}, {"sha": "80e38c5ddea98e61cdc65bcdb8d94371b11f4373", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"mips\".to_string(),\n         target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n \n         options: super::linux_base::opts()\n     }"}, {"sha": "c5f1882fa1dd7d33409db8a850b246e2bbc20efb", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -46,44 +46,19 @@\n //! specified by the target, rather than replace.\n \n use serialize::json::Json;\n-use syntax::{diagnostic, abi};\n use std::default::Default;\n use std::io::prelude::*;\n+use syntax::{diagnostic, abi};\n \n-mod windows_base;\n-mod linux_base;\n+mod android_base;\n mod apple_base;\n mod apple_ios_base;\n-mod freebsd_base;\n-mod dragonfly_base;\n mod bitrig_base;\n+mod dragonfly_base;\n+mod freebsd_base;\n+mod linux_base;\n mod openbsd_base;\n-\n-mod armv7_apple_ios;\n-mod armv7s_apple_ios;\n-mod i386_apple_ios;\n-\n-mod arm_linux_androideabi;\n-mod arm_unknown_linux_gnueabi;\n-mod arm_unknown_linux_gnueabihf;\n-mod aarch64_apple_ios;\n-mod aarch64_linux_android;\n-mod aarch64_unknown_linux_gnu;\n-mod i686_apple_darwin;\n-mod i686_pc_windows_gnu;\n-mod i686_unknown_dragonfly;\n-mod i686_unknown_linux_gnu;\n-mod mips_unknown_linux_gnu;\n-mod mipsel_unknown_linux_gnu;\n-mod powerpc_unknown_linux_gnu;\n-mod x86_64_apple_darwin;\n-mod x86_64_apple_ios;\n-mod x86_64_pc_windows_gnu;\n-mod x86_64_unknown_freebsd;\n-mod x86_64_unknown_dragonfly;\n-mod x86_64_unknown_bitrig;\n-mod x86_64_unknown_linux_gnu;\n-mod x86_64_unknown_openbsd;\n+mod windows_base;\n \n /// Everything `rustc` knows about how to compile for a specific target.\n ///\n@@ -100,6 +75,8 @@ pub struct Target {\n     pub target_pointer_width: String,\n     /// OS name to use for conditional compilation.\n     pub target_os: String,\n+    /// Environment name to use for conditional compilation.\n+    pub target_env: String,\n     /// Architecture to use for ABI considerations. Valid options: \"x86\", \"x86_64\", \"arm\",\n     /// \"aarch64\", \"mips\", and \"powerpc\". \"mips\" includes \"mipsel\".\n     pub arch: String,\n@@ -115,14 +92,22 @@ pub struct Target {\n pub struct TargetOptions {\n     /// Linker to invoke. Defaults to \"cc\".\n     pub linker: String,\n-    /// Linker arguments that are unconditionally passed *before* any user-defined libraries.\n+    /// Linker arguments that are unconditionally passed *before* any\n+    /// user-defined libraries.\n     pub pre_link_args: Vec<String>,\n-    /// Linker arguments that are unconditionally passed *after* any user-defined libraries.\n+    /// Linker arguments that are unconditionally passed *after* any\n+    /// user-defined libraries.\n     pub post_link_args: Vec<String>,\n-    /// Default CPU to pass to LLVM. Corresponds to `llc -mcpu=$cpu`. Defaults to \"default\".\n+    /// Objects to link before and after all others, always found within the\n+    /// sysroot folder.\n+    pub pre_link_objects: Vec<String>,\n+    pub post_link_objects: Vec<String>,\n+    /// Default CPU to pass to LLVM. Corresponds to `llc -mcpu=$cpu`. Defaults\n+    /// to \"default\".\n     pub cpu: String,\n-    /// Default target features to pass to LLVM. These features will *always* be passed, and cannot\n-    /// be disabled even via `-C`. Corresponds to `llc -mattr=$features`.\n+    /// Default target features to pass to LLVM. These features will *always* be\n+    /// passed, and cannot be disabled even via `-C`. Corresponds to `llc\n+    /// -mattr=$features`.\n     pub features: String,\n     /// Whether dynamic linking is available on this target. Defaults to false.\n     pub dynamic_linking: bool,\n@@ -207,6 +192,8 @@ impl Default for TargetOptions {\n             has_rpath: false,\n             no_compiler_rt: false,\n             position_independent_executables: false,\n+            pre_link_objects: Vec::new(),\n+            post_link_objects: Vec::new(),\n         }\n     }\n }\n@@ -250,6 +237,8 @@ impl Target {\n             target_pointer_width: get_req_field(\"target-pointer-width\"),\n             arch: get_req_field(\"arch\"),\n             target_os: get_req_field(\"os\"),\n+            target_env: obj.find(\"env\").and_then(|s| s.as_string())\n+                           .map(|s| s.to_string()).unwrap_or(String::new()),\n             options: Default::default(),\n         };\n \n@@ -329,6 +318,7 @@ impl Target {\n         macro_rules! load_specific {\n             ( $($name:ident),+ ) => (\n                 {\n+                    $(mod $name;)*\n                     let target = target.replace(\"-\", \"_\");\n                     if false { }\n                     $(\n@@ -358,6 +348,7 @@ impl Target {\n             arm_unknown_linux_gnueabi,\n             arm_unknown_linux_gnueabihf,\n             aarch64_unknown_linux_gnu,\n+            x86_64_unknown_linux_musl,\n \n             arm_linux_androideabi,\n             aarch64_linux_android,"}, {"sha": "3a2b4bd16065ef38e892a78415b4d0f4cc75b39a", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -21,6 +21,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"powerpc\".to_string(),\n         target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "89a67da2d8bbcf9b677553c31287036004fd85b2", "filename": "src/librustc_back/target/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -25,6 +25,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"macos\".to_string(),\n+        target_env: \"\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "74491629ed8592faf1e53115f5dbfc7890756f17", "filename": "src/librustc_back/target/x86_64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -21,6 +21,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"ios\".to_string(),\n+        target_env: \"\".to_string(),\n         options: opts(Arch::X86_64)\n     }\n }"}, {"sha": "bea7d16e9dfadd83897082db1e9218f3ea2e4305", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -27,6 +27,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"windows\".to_string(),\n+        target_env: \"gnu\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "201c56b2e15c682b991738e9306332b331f467e4", "filename": "src/librustc_back/target/x86_64_unknown_bitrig.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"bitrig\".to_string(),\n+        target_env: \"\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "c590f0297b948a03648ac04b4c482d8ebb8c3935", "filename": "src/librustc_back/target/x86_64_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -24,6 +24,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"dragonfly\".to_string(),\n+        target_env: \"\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "0d8ea90a2ab04921d0371cbe94f6244c273b1d15", "filename": "src/librustc_back/target/x86_64_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -24,6 +24,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"freebsd\".to_string(),\n+        target_env: \"\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "ba945afc5649b38f70750eea70bda88479f72aff", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -24,6 +24,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "3debad2e8f2013daef0b27cd330caf71e1808356", "filename": "src/librustc_back/target/x86_64_unknown_linux_musl.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::linux_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.pre_link_args.push(\"-m64\".to_string());\n+\n+    // Make sure that the linker/gcc really don't pull in anything, including\n+    // default objects, libs, etc.\n+    base.pre_link_args.push(\"-nostdlib\".to_string());\n+    base.pre_link_args.push(\"-static\".to_string());\n+\n+    // At least when this was tested, the linker would not add the\n+    // `GNU_EH_FRAME` program header to executables generated, which is required\n+    // when unwinding to locate the unwinding information. I'm not sure why this\n+    // argument is *not* necessary for normal builds, but it can't hurt!\n+    base.pre_link_args.push(\"-Wl,--eh-frame-hdr\".to_string());\n+\n+    // There's a whole bunch of circular dependencies when dealing with MUSL\n+    // unfortunately. To put this in perspective libc is statically linked to\n+    // liblibc and libunwind is statically linked to libstd:\n+    //\n+    // * libcore depends on `fmod` which is in libc (transitively in liblibc).\n+    //   liblibc, however, depends on libcore.\n+    // * compiler-rt has personality symbols that depend on libunwind, but\n+    //   libunwind is in libstd which depends on compiler-rt.\n+    //\n+    // Recall that linkers discard libraries and object files as much as\n+    // possible, and with all the static linking and archives flying around with\n+    // MUSL the linker is super aggressively stripping out objects. For example\n+    // the first case has fmod stripped from liblibc (it's in its own object\n+    // file) so it's not there when libcore needs it. In the second example all\n+    // the unused symbols from libunwind are stripped (each is in its own object\n+    // file in libstd) before we end up linking compiler-rt which depends on\n+    // those symbols.\n+    //\n+    // To deal with these circular dependencies we just force the compiler to\n+    // link everything as a group, not stripping anything out until everything\n+    // is processed. The linker will still perform a pass to strip out object\n+    // files but it won't do so until all objects/archives have been processed.\n+    base.pre_link_args.push(\"-Wl,-(\".to_string());\n+    base.post_link_args.push(\"-Wl,-)\".to_string());\n+\n+    // When generating a statically linked executable there's generally some\n+    // small setup needed which is listed in these files. These are provided by\n+    // a musl toolchain and are linked by default by the `musl-gcc` script. Note\n+    // that `gcc` also does this by default, it just uses some different files.\n+    //\n+    // Each target directory for musl has these object files included in it so\n+    // they'll be included from there.\n+    base.pre_link_objects.push(\"crt1.o\".to_string());\n+    base.pre_link_objects.push(\"crti.o\".to_string());\n+    base.post_link_objects.push(\"crtn.o\".to_string());\n+\n+    // MUSL support doesn't currently include dynamic linking, so there's no\n+    // need for dylibs or rpath business. Additionally `-pie` is incompatible\n+    // with `-static`, so we can't pass `-pie`.\n+    base.dynamic_linking = false;\n+    base.has_rpath = false;\n+    base.position_independent_executables = false;\n+\n+    Target {\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n+                      s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n+        llvm_target: \"x86_64-unknown-linux-musl\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "7f64259adf9f8cf0c581a0e50d7a00a014b353a0", "filename": "src/librustc_back/target/x86_64_unknown_openbsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n         target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"openbsd\".to_string(),\n+        target_env: \"\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "6d23cad26cb37e76d07362fbe3f31b5e1893b1af", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,6 +12,7 @@\n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"rustc_bitflags\"]\n+#![feature(associated_consts)]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -34,26 +35,27 @@\n ///\n /// ```{.rust}\n /// # #![feature(rustc_private)]\n+/// # #![feature(associated_consts)]\n /// #[macro_use] extern crate rustc_bitflags;\n ///\n /// bitflags! {\n ///     flags Flags: u32 {\n ///         const FLAG_A       = 0b00000001,\n ///         const FLAG_B       = 0b00000010,\n ///         const FLAG_C       = 0b00000100,\n-///         const FLAG_ABC     = FLAG_A.bits\n-///                            | FLAG_B.bits\n-///                            | FLAG_C.bits,\n+///         const FLAG_ABC     = Flags::FLAG_A.bits\n+///                            | Flags::FLAG_B.bits\n+///                            | Flags::FLAG_C.bits,\n ///     }\n /// }\n ///\n /// fn main() {\n-///     let e1 = FLAG_A | FLAG_C;\n-///     let e2 = FLAG_B | FLAG_C;\n-///     assert!((e1 | e2) == FLAG_ABC);   // union\n-///     assert!((e1 & e2) == FLAG_C);     // intersection\n-///     assert!((e1 - e2) == FLAG_A);     // set difference\n-///     assert!(!e2 == FLAG_A);           // set complement\n+///     let e1 = Flags::FLAG_A | Flags::FLAG_C;\n+///     let e2 = Flags::FLAG_B | Flags::FLAG_C;\n+///     assert!((e1 | e2) == Flags::FLAG_ABC); // union\n+///     assert!((e1 & e2) == Flags::FLAG_C);   // intersection\n+///     assert!((e1 - e2) == Flags::FLAG_A);   // set difference\n+///     assert!(!e2 == Flags::FLAG_A);         // set complement\n /// }\n /// ```\n ///\n@@ -86,7 +88,7 @@\n /// }\n ///\n /// fn main() {\n-///     let mut flags = FLAG_A | FLAG_B;\n+///     let mut flags = Flags::FLAG_A | Flags::FLAG_B;\n ///     flags.clear();\n ///     assert!(flags.is_empty());\n ///     assert_eq!(format!(\"{:?}\", flags), \"hi!\");\n@@ -144,9 +146,9 @@ macro_rules! bitflags {\n             bits: $T,\n         }\n \n-        $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n-\n         impl $BitFlags {\n+            $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+\n             /// Returns an empty set of flags.\n             #[inline]\n             pub fn empty() -> $BitFlags {\n@@ -314,9 +316,9 @@ mod tests {\n             #[doc = \"* cmr bed\"]\n             #[doc = \"* strcat table\"]\n             #[doc = \"<strcat> wait what?\"]\n-            const FlagABC     = FlagA.bits\n-                               | FlagB.bits\n-                               | FlagC.bits,\n+            const FlagABC     = Flags::FlagA.bits\n+                               | Flags::FlagB.bits\n+                               | Flags::FlagC.bits,\n         }\n     }\n \n@@ -329,52 +331,52 @@ mod tests {\n     #[test]\n     fn test_bits(){\n         assert_eq!(Flags::empty().bits(), 0b00000000);\n-        assert_eq!(FlagA.bits(), 0b00000001);\n-        assert_eq!(FlagABC.bits(), 0b00000111);\n+        assert_eq!(Flags::FlagA.bits(), 0b00000001);\n+        assert_eq!(Flags::FlagABC.bits(), 0b00000111);\n \n         assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n-        assert_eq!(AnotherFlag.bits(), !0);\n+        assert_eq!(AnotherSetOfFlags::AnotherFlag.bits(), !0);\n     }\n \n     #[test]\n     fn test_from_bits() {\n         assert!(Flags::from_bits(0) == Some(Flags::empty()));\n-        assert!(Flags::from_bits(0b1) == Some(FlagA));\n-        assert!(Flags::from_bits(0b10) == Some(FlagB));\n-        assert!(Flags::from_bits(0b11) == Some(FlagA | FlagB));\n+        assert!(Flags::from_bits(0b1) == Some(Flags::FlagA));\n+        assert!(Flags::from_bits(0b10) == Some(Flags::FlagB));\n+        assert!(Flags::from_bits(0b11) == Some(Flags::FlagA | Flags::FlagB));\n         assert!(Flags::from_bits(0b1000) == None);\n \n-        assert!(AnotherSetOfFlags::from_bits(!0) == Some(AnotherFlag));\n+        assert!(AnotherSetOfFlags::from_bits(!0) == Some(AnotherSetOfFlags::AnotherFlag));\n     }\n \n     #[test]\n     fn test_from_bits_truncate() {\n         assert!(Flags::from_bits_truncate(0) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0b1) == FlagA);\n-        assert!(Flags::from_bits_truncate(0b10) == FlagB);\n-        assert!(Flags::from_bits_truncate(0b11) == (FlagA | FlagB));\n+        assert!(Flags::from_bits_truncate(0b1) == Flags::FlagA);\n+        assert!(Flags::from_bits_truncate(0b10) == Flags::FlagB);\n+        assert!(Flags::from_bits_truncate(0b11) == (Flags::FlagA | Flags::FlagB));\n         assert!(Flags::from_bits_truncate(0b1000) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0b1001) == FlagA);\n+        assert!(Flags::from_bits_truncate(0b1001) == Flags::FlagA);\n \n         assert!(AnotherSetOfFlags::from_bits_truncate(0) == AnotherSetOfFlags::empty());\n     }\n \n     #[test]\n     fn test_is_empty(){\n         assert!(Flags::empty().is_empty());\n-        assert!(!FlagA.is_empty());\n-        assert!(!FlagABC.is_empty());\n+        assert!(!Flags::FlagA.is_empty());\n+        assert!(!Flags::FlagABC.is_empty());\n \n-        assert!(!AnotherFlag.is_empty());\n+        assert!(!AnotherSetOfFlags::AnotherFlag.is_empty());\n     }\n \n     #[test]\n     fn test_is_all() {\n         assert!(Flags::all().is_all());\n-        assert!(!FlagA.is_all());\n-        assert!(FlagABC.is_all());\n+        assert!(!Flags::FlagA.is_all());\n+        assert!(Flags::FlagABC.is_all());\n \n-        assert!(AnotherFlag.is_all());\n+        assert!(AnotherSetOfFlags::AnotherFlag.is_all());\n     }\n \n     #[test]\n@@ -383,77 +385,77 @@ mod tests {\n         let e2 = Flags::empty();\n         assert!(!e1.intersects(e2));\n \n-        assert!(AnotherFlag.intersects(AnotherFlag));\n+        assert!(AnotherSetOfFlags::AnotherFlag.intersects(AnotherSetOfFlags::AnotherFlag));\n     }\n \n     #[test]\n     fn test_empty_does_not_intersect_with_full() {\n         let e1 = Flags::empty();\n-        let e2 = FlagABC;\n+        let e2 = Flags::FlagABC;\n         assert!(!e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_disjoint_intersects() {\n-        let e1 = FlagA;\n-        let e2 = FlagB;\n+        let e1 = Flags::FlagA;\n+        let e2 = Flags::FlagB;\n         assert!(!e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_overlapping_intersects() {\n-        let e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let e1 = Flags::FlagA;\n+        let e2 = Flags::FlagA | Flags::FlagB;\n         assert!(e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_contains() {\n-        let e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let e1 = Flags::FlagA;\n+        let e2 = Flags::FlagA | Flags::FlagB;\n         assert!(!e1.contains(e2));\n         assert!(e2.contains(e1));\n-        assert!(FlagABC.contains(e2));\n+        assert!(Flags::FlagABC.contains(e2));\n \n-        assert!(AnotherFlag.contains(AnotherFlag));\n+        assert!(AnotherSetOfFlags::AnotherFlag.contains(AnotherSetOfFlags::AnotherFlag));\n     }\n \n     #[test]\n     fn test_insert(){\n-        let mut e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let mut e1 = Flags::FlagA;\n+        let e2 = Flags::FlagA | Flags::FlagB;\n         e1.insert(e2);\n         assert!(e1 == e2);\n \n         let mut e3 = AnotherSetOfFlags::empty();\n-        e3.insert(AnotherFlag);\n-        assert!(e3 == AnotherFlag);\n+        e3.insert(AnotherSetOfFlags::AnotherFlag);\n+        assert!(e3 == AnotherSetOfFlags::AnotherFlag);\n     }\n \n     #[test]\n     fn test_remove(){\n-        let mut e1 = FlagA | FlagB;\n-        let e2 = FlagA | FlagC;\n+        let mut e1 = Flags::FlagA | Flags::FlagB;\n+        let e2 = Flags::FlagA | Flags::FlagC;\n         e1.remove(e2);\n-        assert!(e1 == FlagB);\n+        assert!(e1 == Flags::FlagB);\n \n-        let mut e3 = AnotherFlag;\n-        e3.remove(AnotherFlag);\n+        let mut e3 = AnotherSetOfFlags::AnotherFlag;\n+        e3.remove(AnotherSetOfFlags::AnotherFlag);\n         assert!(e3 == AnotherSetOfFlags::empty());\n     }\n \n     #[test]\n     fn test_operators() {\n-        let e1 = FlagA | FlagC;\n-        let e2 = FlagB | FlagC;\n-        assert!((e1 | e2) == FlagABC);     // union\n-        assert!((e1 & e2) == FlagC);       // intersection\n-        assert!((e1 - e2) == FlagA);       // set difference\n-        assert!(!e2 == FlagA);             // set complement\n-        assert!(e1 ^ e2 == FlagA | FlagB); // toggle\n+        let e1 = Flags::FlagA | Flags::FlagC;\n+        let e2 = Flags::FlagB | Flags::FlagC;\n+        assert!((e1 | e2) == Flags::FlagABC);     // union\n+        assert!((e1 & e2) == Flags::FlagC);       // intersection\n+        assert!((e1 - e2) == Flags::FlagA);       // set difference\n+        assert!(!e2 == Flags::FlagA);             // set complement\n+        assert!(e1 ^ e2 == Flags::FlagA | Flags::FlagB); // toggle\n         let mut e3 = e1;\n         e3.toggle(e2);\n-        assert!(e3 == FlagA | FlagB);\n+        assert!(e3 == Flags::FlagA | Flags::FlagB);\n \n         let mut m4 = AnotherSetOfFlags::empty();\n         m4.toggle(AnotherSetOfFlags::empty());\n@@ -466,11 +468,11 @@ mod tests {\n         let mut b = Flags::empty();\n \n         assert!(!(a < b) && !(b < a));\n-        b = FlagB;\n+        b = Flags::FlagB;\n         assert!(a < b);\n-        a = FlagC;\n+        a = Flags::FlagC;\n         assert!(!(a < b) && b < a);\n-        b = FlagC | FlagB;\n+        b = Flags::FlagC | Flags::FlagB;\n         assert!(a < b);\n     }\n \n@@ -480,10 +482,10 @@ mod tests {\n         let mut b = Flags::empty();\n \n         assert!(a <= b && a >= b);\n-        a = FlagA;\n+        a = Flags::FlagA;\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        b = FlagB;\n+        b = Flags::FlagB;\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n@@ -494,7 +496,7 @@ mod tests {\n       let mut y = Flags::empty();\n       assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n       x = Flags::all();\n-      y = FlagABC;\n+      y = Flags::FlagABC;\n       assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n     }\n }"}, {"sha": "27adf5bf21b63297a5491ba94efd3bea8f50867d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -77,6 +77,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         borrowck_item(self, item);\n     }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        if let ast::ConstTraitItem(_, Some(ref expr)) = ti.node {\n+            gather_loans::gather_loans_in_static_initializer(self, &*expr);\n+        }\n+        visit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        if let ast::ConstImplItem(_, ref expr) = ii.node {\n+            gather_loans::gather_loans_in_static_initializer(self, &*expr);\n+        }\n+        visit::walk_impl_item(self, ii);\n+    }\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {"}, {"sha": "a43268ff1a8827c1cad97eef5a5f66c481467bb8", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,5 +13,3 @@\n register_diagnostics! {\n     E0373 // closure may outlive current fn, but it borrows {}, which is owned by current fn\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "50dc08e299a822701eaf28c5fc87b0d223b0861a", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -25,7 +25,6 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(unsafe_destructor)]\n #![feature(into_cow)]\n \n #[macro_use] extern crate log;\n@@ -47,3 +46,8 @@ pub mod diagnostics;\n mod borrowck;\n \n pub mod graphviz;\n+\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc_borrowck, DIAGNOSTICS }"}, {"sha": "17fd0b81536258d5c229c229c34533bc1789558e", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -36,7 +36,7 @@ use std::usize;\n use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub struct Graph<N,E> {\n     nodes: SnapshotVec<Node<N>> ,"}, {"sha": "33b2edd2e106d22ec0dd98f4b17a7067dc38f43f", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "previous_filename": "src/librustc_data_structures/graph/test.rs"}, {"sha": "a899bbacc03016f8c624d68c8d18758f90b57c12", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -14,7 +14,7 @@ use std::marker::PhantomData;\n use snapshot_vec as sv;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n /// This trait is implemented by any type that can serve as a type\n /// variable. We call such variables *unification keys*. For example,"}, {"sha": "dbe3cfc7a48a9b2e7c7f749a1f7c5f0f7d77adcb", "filename": "src/librustc_data_structures/unify/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Ftests.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "previous_filename": "src/librustc_data_structures/unify/test.rs"}, {"sha": "8dff0f1d3f41a61e78589c3027070ebd54a00ffb", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -31,7 +31,6 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(exit_status)]\n #![feature(set_stdio)]\n@@ -854,9 +853,10 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     use syntax::diagnostics::registry::Registry;\n \n     let all_errors = Vec::new() +\n-        &rustc::diagnostics::DIAGNOSTICS[..] +\n-        &rustc_typeck::diagnostics::DIAGNOSTICS[..] +\n-        &rustc_resolve::diagnostics::DIAGNOSTICS[..];\n+        &rustc::DIAGNOSTICS[..] +\n+        &rustc_typeck::DIAGNOSTICS[..] +\n+        &rustc_borrowck::DIAGNOSTICS[..] +\n+        &rustc_resolve::DIAGNOSTICS[..];\n \n     Registry::new(&*all_errors)\n }"}, {"sha": "b8032bda8d070ede99791322e5f2ba00c49abc14", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -35,6 +35,7 @@ use syntax::codemap;\n use syntax::fold::{self, Folder};\n use syntax::print::{pp, pprust};\n use syntax::ptr::P;\n+use syntax::util::small_vector::SmallVector;\n \n use graphviz as dot;\n \n@@ -475,6 +476,29 @@ impl fold::Folder for ReplaceBodyWithLoop {\n         }\n     }\n \n+    fn fold_trait_item(&mut self, i: P<ast::TraitItem>) -> SmallVector<P<ast::TraitItem>> {\n+        match i.node {\n+            ast::ConstTraitItem(..) => {\n+                self.within_static_or_const = true;\n+                let ret = fold::noop_fold_trait_item(i, self);\n+                self.within_static_or_const = false;\n+                return ret;\n+            }\n+            _ => fold::noop_fold_trait_item(i, self),\n+        }\n+    }\n+\n+    fn fold_impl_item(&mut self, i: P<ast::ImplItem>) -> SmallVector<P<ast::ImplItem>> {\n+        match i.node {\n+            ast::ConstImplItem(..) => {\n+                self.within_static_or_const = true;\n+                let ret = fold::noop_fold_impl_item(i, self);\n+                self.within_static_or_const = false;\n+                return ret;\n+            }\n+            _ => fold::noop_fold_impl_item(i, self),\n+        }\n+    }\n \n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n         fn expr_to_block(rules: ast::BlockCheckMode,"}, {"sha": "cc2c9b735ea44b881aa9d763af3ea37919eb13b7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1068,6 +1068,26 @@ impl LintPass for NonUpperCaseGlobals {\n         }\n     }\n \n+    fn check_trait_item(&mut self, cx: &Context, ti: &ast::TraitItem) {\n+        match ti.node {\n+            ast::ConstTraitItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ti.ident, ti.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &Context, ii: &ast::ImplItem) {\n+        match ii.node {\n+            ast::ConstImplItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ii.ident, ii.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n@@ -1584,8 +1604,9 @@ impl LintPass for MissingDoc {\n         if self.private_traits.contains(&trait_item.id) { return }\n \n         let desc = match trait_item.node {\n+            ast::ConstTraitItem(..) => \"an associated constant\",\n             ast::MethodTraitItem(..) => \"a trait method\",\n-            ast::TypeTraitItem(..) => \"an associated type\"\n+            ast::TypeTraitItem(..) => \"an associated type\",\n         };\n \n         self.check_missing_docs_attrs(cx, Some(trait_item.id),\n@@ -1600,9 +1621,10 @@ impl LintPass for MissingDoc {\n         }\n \n         let desc = match impl_item.node {\n+            ast::ConstImplItem(..) => \"an associated constant\",\n             ast::MethodImplItem(..) => \"a method\",\n             ast::TypeImplItem(_) => \"an associated type\",\n-            ast::MacImplItem(_) => \"an impl item macro\"\n+            ast::MacImplItem(_) => \"an impl item macro\",\n         };\n         self.check_missing_docs_attrs(cx, Some(impl_item.id),\n                                       &impl_item.attrs,\n@@ -2120,3 +2142,57 @@ impl LintPass for UnstableFeatures {\n         }\n     }\n }\n+\n+/// Lints for attempts to impl Drop on types that have `#[repr(C)]`\n+/// attribute (see issue #24585).\n+#[derive(Copy, Clone)]\n+pub struct DropWithReprExtern;\n+\n+declare_lint! {\n+    DROP_WITH_REPR_EXTERN,\n+    Warn,\n+    \"use of #[repr(C)] on a type that implements Drop\"\n+}\n+\n+impl LintPass for DropWithReprExtern {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DROP_WITH_REPR_EXTERN)\n+    }\n+    fn check_crate(&mut self, ctx: &Context, _: &ast::Crate) {\n+        for dtor_did in ctx.tcx.destructors.borrow().iter() {\n+            let (drop_impl_did, dtor_self_type) =\n+                if dtor_did.krate == ast::LOCAL_CRATE {\n+                    let impl_did = ctx.tcx.map.get_parent_did(dtor_did.node);\n+                    let ty = ty::lookup_item_type(ctx.tcx, impl_did).ty;\n+                    (impl_did, ty)\n+                } else {\n+                    continue;\n+                };\n+\n+            match dtor_self_type.sty {\n+                ty::ty_enum(self_type_did, _) |\n+                ty::ty_struct(self_type_did, _) |\n+                ty::ty_closure(self_type_did, _) => {\n+                    let hints = ty::lookup_repr_hints(ctx.tcx, self_type_did);\n+                    if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n+                        ty::ty_dtor(ctx.tcx, self_type_did).has_drop_flag() {\n+                        let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n+                                                                     codemap::DUMMY_SP);\n+                        let self_defn_span = ctx.tcx.map.def_id_span(self_type_did,\n+                                                                     codemap::DUMMY_SP);\n+                        ctx.span_lint(DROP_WITH_REPR_EXTERN,\n+                                      drop_impl_span,\n+                                      \"implementing Drop adds hidden state to types, \\\n+                                       possibly conflicting with `#[repr(C)]`\");\n+                        // FIXME #19668: could be span_lint_note instead of manual guard.\n+                        if ctx.current_level(DROP_WITH_REPR_EXTERN) != Level::Allow {\n+                            ctx.sess().span_note(self_defn_span,\n+                                               \"the `#[repr(C)]` attribute is attached here\");\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}"}, {"sha": "970f9c634a2caad2c4cbe4abb402786486e03c5f", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -37,7 +37,6 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(str_char)]\n #![cfg_attr(test, feature(test))]\n@@ -109,6 +108,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  UnconditionalRecursion,\n                  InvalidNoMangleItems,\n                  PluginAsLibrary,\n+                 DropWithReprExtern,\n                  );\n \n     add_builtin_with_new!(sess,"}, {"sha": "b591e37f893e254d919441924b5176aefd6f935e", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -105,7 +105,6 @@ impl<'a> Iterator for Iter<'a> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<'a> Drop for Iter<'a> {\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "db88072150a603f2ef49f5847f51065e7abbd4dc", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -25,12 +25,12 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(associated_consts)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n-#![feature(unsafe_destructor)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n@@ -43,6 +43,7 @@ pub use self::RealPredicate::*;\n pub use self::TypeKind::*;\n pub use self::AtomicBinOp::*;\n pub use self::AtomicOrdering::*;\n+pub use self::SynchronizationScope::*;\n pub use self::FileType::*;\n pub use self::MetadataType::*;\n pub use self::AsmDialect::*;\n@@ -124,32 +125,32 @@ pub enum DiagnosticSeverity {\n \n bitflags! {\n     flags Attribute : u32 {\n-        const ZExtAttribute = 1 << 0,\n-        const SExtAttribute = 1 << 1,\n-        const NoReturnAttribute = 1 << 2,\n-        const InRegAttribute = 1 << 3,\n-        const StructRetAttribute = 1 << 4,\n-        const NoUnwindAttribute = 1 << 5,\n-        const NoAliasAttribute = 1 << 6,\n-        const ByValAttribute = 1 << 7,\n-        const NestAttribute = 1 << 8,\n-        const ReadNoneAttribute = 1 << 9,\n-        const ReadOnlyAttribute = 1 << 10,\n-        const NoInlineAttribute = 1 << 11,\n-        const AlwaysInlineAttribute = 1 << 12,\n+        const ZExtAttribute            = 1 << 0,\n+        const SExtAttribute            = 1 << 1,\n+        const NoReturnAttribute        = 1 << 2,\n+        const InRegAttribute           = 1 << 3,\n+        const StructRetAttribute       = 1 << 4,\n+        const NoUnwindAttribute        = 1 << 5,\n+        const NoAliasAttribute         = 1 << 6,\n+        const ByValAttribute           = 1 << 7,\n+        const NestAttribute            = 1 << 8,\n+        const ReadNoneAttribute        = 1 << 9,\n+        const ReadOnlyAttribute        = 1 << 10,\n+        const NoInlineAttribute        = 1 << 11,\n+        const AlwaysInlineAttribute    = 1 << 12,\n         const OptimizeForSizeAttribute = 1 << 13,\n-        const StackProtectAttribute = 1 << 14,\n+        const StackProtectAttribute    = 1 << 14,\n         const StackProtectReqAttribute = 1 << 15,\n-        const AlignmentAttribute = 31 << 16,\n-        const NoCaptureAttribute = 1 << 21,\n-        const NoRedZoneAttribute = 1 << 22,\n+        const AlignmentAttribute       = 1 << 16,\n+        const NoCaptureAttribute       = 1 << 21,\n+        const NoRedZoneAttribute       = 1 << 22,\n         const NoImplicitFloatAttribute = 1 << 23,\n-        const NakedAttribute = 1 << 24,\n-        const InlineHintAttribute = 1 << 25,\n-        const StackAttribute = 7 << 26,\n-        const ReturnsTwiceAttribute = 1 << 29,\n-        const UWTableAttribute = 1 << 30,\n-        const NonLazyBindAttribute = 1 << 31,\n+        const NakedAttribute           = 1 << 24,\n+        const InlineHintAttribute      = 1 << 25,\n+        const StackAttribute           = 7 << 26,\n+        const ReturnsTwiceAttribute    = 1 << 29,\n+        const UWTableAttribute         = 1 << 30,\n+        const NonLazyBindAttribute     = 1 << 31,\n     }\n }\n \n@@ -361,6 +362,13 @@ pub enum AtomicOrdering {\n     SequentiallyConsistent = 7\n }\n \n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum SynchronizationScope {\n+    SingleThread = 0,\n+    CrossThread = 1\n+}\n+\n // Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n #[repr(C)]\n #[derive(Copy, Clone)]\n@@ -1534,7 +1542,9 @@ extern {\n                               SingleThreaded: Bool)\n                               -> ValueRef;\n \n-    pub fn LLVMBuildAtomicFence(B: BuilderRef, Order: AtomicOrdering);\n+    pub fn LLVMBuildAtomicFence(B: BuilderRef,\n+                                Order: AtomicOrdering,\n+                                Scope: SynchronizationScope);\n \n \n     /* Selected entries from the downcasts. */"}, {"sha": "128e29ee76e7d6ec17acc19c8b9216cacef514b2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -119,6 +119,15 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         visit::walk_fn(self, a, b, c, d);\n     }\n \n+    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+        // visit_fn handles methods, but associated consts have to be handled\n+        // here.\n+        if !self.parents.contains_key(&ii.id) {\n+            self.parents.insert(ii.id, self.curparent);\n+        }\n+        visit::walk_impl_item(self, ii);\n+    }\n+\n     fn visit_struct_def(&mut self, s: &ast::StructDef, _: ast::Ident,\n                         _: &'v ast::Generics, n: ast::NodeId) {\n         // Struct constructors are parented to their struct definitions because\n@@ -272,6 +281,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 if public_ty || public_trait {\n                     for impl_item in impl_items {\n                         match impl_item.node {\n+                            ast::ConstImplItem(..) => {\n+                                if (public_ty && impl_item.vis == ast::Public)\n+                                    || tr.is_some() {\n+                                    self.exported_items.insert(impl_item.id);\n+                                }\n+                            }\n                             ast::MethodImplItem(ref sig, _) => {\n                                 let meth_public = match sig.explicit_self.node {\n                                     ast::SelfStatic => public_ty,\n@@ -399,6 +414,33 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             debug!(\"privacy - is {:?} a public method\", did);\n \n             return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n+                Some(&ty::ConstTraitItem(ref ac)) => {\n+                    debug!(\"privacy - it's a const: {:?}\", *ac);\n+                    match ac.container {\n+                        ty::TraitContainer(id) => {\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            self.def_privacy(id)\n+                        }\n+                        ty::ImplContainer(id) => {\n+                            match ty::impl_trait_ref(self.tcx, id) {\n+                                Some(t) => {\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    self.def_privacy(t.def_id)\n+                                }\n+                                None => {\n+                                    debug!(\"privacy - found inherent \\\n+                                            associated constant {:?}\",\n+                                            ac.vis);\n+                                    if ac.vis == ast::Public {\n+                                        Allowable\n+                                    } else {\n+                                        ExternallyDenied\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n                     debug!(\"privacy - well at least it's a method: {:?}\",\n                            *meth);\n@@ -490,6 +532,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 //               where the method was defined?\n                 Some(ast_map::NodeImplItem(ii)) => {\n                     match ii.node {\n+                        ast::ConstImplItem(..) |\n                         ast::MethodImplItem(..) => {\n                             let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n@@ -693,7 +736,11 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             ty::MethodTraitItem(method_type) => {\n                 method_type.provided_source.unwrap_or(method_id)\n             }\n-            ty::TypeTraitItem(_) => method_id,\n+            _ => {\n+                self.tcx.sess\n+                    .span_bug(span,\n+                              \"got non-method item in check_static_method\")\n+            }\n         };\n \n         let string = token::get_name(name);\n@@ -787,6 +834,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n             def::DefConst(..) => ck(\"const\"),\n+            def::DefAssociatedConst(..) => ck(\"associated const\"),\n             def::DefVariant(..) => ck(\"variant\"),\n             def::DefTy(_, false) => ck(\"type\"),\n             def::DefTy(_, true) => ck(\"enum\"),\n@@ -1128,8 +1176,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                         ast::MethodImplItem(..) => {\n                             check_inherited(tcx, impl_item.span, impl_item.vis);\n                         }\n-                        ast::TypeImplItem(_) |\n-                        ast::MacImplItem(_) => {}\n+                        _ => {}\n                     }\n                 }\n             }\n@@ -1307,6 +1354,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     impl_items.iter()\n                               .any(|impl_item| {\n                                   match impl_item.node {\n+                                      ast::ConstImplItem(..) |\n                                       ast::MethodImplItem(..) => {\n                                           self.exported_items.contains(&impl_item.id)\n                                       }\n@@ -1330,6 +1378,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n                                 match impl_item.node {\n+                                    ast::ConstImplItem(..) |\n                                     ast::MethodImplItem(..)\n                                         if self.item_is_public(&impl_item.id, impl_item.vis) =>\n                                     {\n@@ -1360,12 +1409,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n-                                match impl_item.node {\n-                                    ast::TypeImplItem(ref ty) => {\n-                                        self.visit_ty(ty);\n-                                    }\n-                                    ast::MethodImplItem(..) |\n-                                    ast::MacImplItem(_) => {},\n+                                if let ast::TypeImplItem(ref ty) = impl_item.node {\n+                                    self.visit_ty(ty);\n                                 }\n                             }\n                         }\n@@ -1376,15 +1421,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items {\n                         match impl_item.node {\n+                            ast::ConstImplItem(..) => {\n+                                if self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                    found_pub_static = true;\n+                                    visit::walk_impl_item(self, impl_item);\n+                                }\n+                            }\n                             ast::MethodImplItem(ref sig, _) => {\n                                 if sig.explicit_self.node == ast::SelfStatic &&\n-                                        self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                      self.item_is_public(&impl_item.id, impl_item.vis) {\n                                     found_pub_static = true;\n                                     visit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n-                            ast::TypeImplItem(_) |\n-                            ast::MacImplItem(_) => {}\n+                            _ => {}\n                         }\n                     }\n                     if found_pub_static {"}, {"sha": "4ea18968d43ac218df9fbc3dda33aee3c716ad1e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,7 +13,7 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use {DefModifiers, PUBLIC, IMPORTABLE};\n+use DefModifiers;\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n use resolve_imports::ImportResolution;\n@@ -262,7 +262,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let name = item.ident.name;\n         let sp = item.span;\n         let is_public = item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n \n         match item.node {\n             ItemUse(ref view_path) => {\n@@ -530,17 +534,23 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                         trait_item.span);\n \n                     match trait_item.node {\n+                        ast::ConstTraitItem(..) => {\n+                            let def = DefAssociatedConst(local_def(trait_item.id),\n+                                                         FromTrait(local_def(item.id)));\n+                            // NB: not DefModifiers::IMPORTABLE\n+                            name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n+                        }\n                         ast::MethodTraitItem(..) => {\n                             let def = DefMethod(local_def(trait_item.id),\n                                                 FromTrait(local_def(item.id)));\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_value(def, trait_item.span, PUBLIC);\n+                            // NB: not DefModifiers::IMPORTABLE\n+                            name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         ast::TypeTraitItem(..) => {\n                             let def = DefAssociatedTy(local_def(item.id),\n                                                       local_def(trait_item.id));\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_type(def, trait_item.span, PUBLIC);\n+                            // NB: not DefModifiers::IMPORTABLE\n+                            name_bindings.define_type(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                     }\n \n@@ -578,10 +588,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         // used\n         child.define_value(DefVariant(item_id,\n                                       local_def(variant.node.id), is_exported),\n-                           variant.span, PUBLIC | IMPORTABLE);\n+                           variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n         child.define_type(DefVariant(item_id,\n                                      local_def(variant.node.id), is_exported),\n-                          variant.span, PUBLIC | IMPORTABLE);\n+                          variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n@@ -590,7 +600,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             parent: &Rc<Module>) {\n         let name = foreign_item.ident.name;\n         let is_public = foreign_item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let name_bindings =\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n@@ -638,7 +652,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 external crate) building external def {}, priv {:?}\",\n                final_ident, vis);\n         let is_public = vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let is_exported = is_public && match new_parent.def_id.get() {\n             None => true,\n             Some(did) => self.external_exports.contains(&did)\n@@ -689,7 +707,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                       final_ident);\n               // variants are always treated as importable to allow them to be\n               // glob used\n-              let modifiers = PUBLIC | IMPORTABLE;\n+              let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n               if is_struct {\n                   child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n                   // Not adding fields for variants as they are not accessed with a self receiver\n@@ -703,16 +721,18 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n                     .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n           }\n-          DefFn(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n+          DefFn(..) | DefStatic(..) | DefConst(..) | DefAssociatedConst(..) |\n+          DefMethod(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n             // impl methods have already been defined with the correct importability modifier\n             let mut modifiers = match *child_name_bindings.value_def.borrow() {\n-                Some(ref def) => (modifiers & !IMPORTABLE) | (def.modifiers & IMPORTABLE),\n+                Some(ref def) => (modifiers & !DefModifiers::IMPORTABLE) |\n+                             (def.modifiers &  DefModifiers::IMPORTABLE),\n                 None => modifiers\n             };\n             if new_parent.kind.get() != NormalModuleKind {\n-                modifiers = modifiers & !IMPORTABLE;\n+                modifiers = modifiers & !DefModifiers::IMPORTABLE;\n             }\n             child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n           }"}, {"sha": "a896bd311698c3cf55fd8d9a4e146d5bab99e8c3", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -28,5 +28,3 @@ register_diagnostics! {\n     E0364, // item is private\n     E0365  // item is private\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "7abe5a84c5fff80fde3206c6e0987aa91316cb5a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 214, "deletions": 83, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -20,6 +20,7 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(alloc)]\n+#![feature(associated_consts)]\n #![feature(collections)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -41,6 +42,7 @@ use self::TypeParameters::*;\n use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n+use self::AssocItemResolveResult::*;\n use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n@@ -60,7 +62,8 @@ use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n-use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n+use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block};\n+use syntax::ast::{ConstImplItem, Crate, CrateNum};\n use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n@@ -69,7 +72,7 @@ use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use syntax::ast::{Local, MethodImplItem, Name, NodeId};\n-use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n+use syntax::ast::{Pat, PatEnum, PatIdent, PatLit, PatQPath};\n use syntax::ast::{PatRange, PatStruct, Path, PrimTy};\n use syntax::ast::{TraitRef, Ty, TyBool, TyChar, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt};\n@@ -330,6 +333,15 @@ enum ModulePrefixResult {\n     PrefixFound(Rc<Module>, usize)\n }\n \n+#[derive(Copy, Clone)]\n+enum AssocItemResolveResult {\n+    /// Syntax such as `<T>::item`, which can't be resolved until type\n+    /// checking.\n+    TypecheckRequired,\n+    /// We should have been able to resolve the associated item.\n+    ResolveAttempt(Option<PathResolution>),\n+}\n+\n #[derive(Copy, Clone, PartialEq)]\n enum NameSearchType {\n     /// We're doing a name search in order to resolve a `use` directive.\n@@ -466,8 +478,8 @@ impl fmt::Debug for Module {\n bitflags! {\n     #[derive(Debug)]\n     flags DefModifiers: u8 {\n-        const PUBLIC            = 0b0000_0001,\n-        const IMPORTABLE        = 0b0000_0010,\n+        const PUBLIC     = 1 << 0,\n+        const IMPORTABLE = 1 << 1,\n     }\n }\n \n@@ -513,7 +525,11 @@ impl NameBindings {\n                      is_public: bool,\n                      sp: Span) {\n         // Merges the module with the existing type def or creates a new one.\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let module_ = Rc::new(Module::new(parent_link,\n                                           def_id,\n                                           kind,\n@@ -548,7 +564,11 @@ impl NameBindings {\n                        external: bool,\n                        is_public: bool,\n                        _sp: Span) {\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n             None => {\n@@ -648,7 +668,7 @@ impl NameBindings {\n     }\n \n     fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n-        self.defined_in_namespace_with(namespace, PUBLIC)\n+        self.defined_in_namespace_with(namespace, DefModifiers::PUBLIC)\n     }\n \n     fn defined_in_namespace_with(&self, namespace: Namespace, modifiers: DefModifiers) -> bool {\n@@ -719,11 +739,11 @@ impl NameBindings {\n         match namespace {\n             TypeNS  => {\n                 let type_def = self.type_def.borrow();\n-                type_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+                type_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n             }\n             ValueNS => {\n                 let value_def = self.value_def.borrow();\n-                value_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+                value_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n             }\n         }\n     }\n@@ -910,7 +930,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn create_name_bindings_from_module(module: Rc<Module>) -> NameBindings {\n         NameBindings {\n             type_def: RefCell::new(Some(TypeNsDef {\n-                modifiers: IMPORTABLE,\n+                modifiers: DefModifiers::IMPORTABLE,\n                 module_def: Some(module),\n                 type_def: None,\n                 type_span: None\n@@ -1830,21 +1850,36 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             //\n                             // FIXME #4951: Do we need a node ID here?\n \n-                            let type_parameters = match trait_item.node {\n+                            match trait_item.node {\n+                                ast::ConstTraitItem(_, ref default) => {\n+                                    // Only impose the restrictions of\n+                                    // ConstRibKind if there's an actual constant\n+                                    // expression in a provided default.\n+                                    if default.is_some() {\n+                                        this.with_constant_rib(|this| {\n+                                            visit::walk_trait_item(this, trait_item)\n+                                        });\n+                                    } else {\n+                                        visit::walk_trait_item(this, trait_item)\n+                                    }\n+                                }\n                                 ast::MethodTraitItem(ref sig, _) => {\n-                                    HasTypeParameters(&sig.generics,\n-                                                      FnSpace,\n-                                                      MethodRibKind)\n+                                    let type_parameters =\n+                                        HasTypeParameters(&sig.generics,\n+                                                          FnSpace,\n+                                                          MethodRibKind);\n+                                    this.with_type_parameter_rib(type_parameters, |this| {\n+                                        visit::walk_trait_item(this, trait_item)\n+                                    });\n                                 }\n                                 ast::TypeTraitItem(..) => {\n                                     this.check_if_primitive_type_name(trait_item.ident.name,\n                                                                       trait_item.span);\n-                                    NoTypeParameters\n+                                    this.with_type_parameter_rib(NoTypeParameters, |this| {\n+                                        visit::walk_trait_item(this, trait_item)\n+                                    });\n                                 }\n                             };\n-                            this.with_type_parameter_rib(type_parameters, |this| {\n-                                visit::walk_trait_item(this, trait_item)\n-                            });\n                         }\n                     });\n                 });\n@@ -2094,6 +2129,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n                             match impl_item.node {\n+                                ConstImplItem(..) => {\n+                                    // If this is a trait impl, ensure the method\n+                                    // exists in trait\n+                                    this.check_trait_item(impl_item.ident.name,\n+                                                          impl_item.span);\n+                                    this.with_constant_rib(|this| {\n+                                        visit::walk_impl_item(this, impl_item);\n+                                    });\n+                                }\n                                 MethodImplItem(ref sig, _) => {\n                                     // If this is a trait impl, ensure the method\n                                     // exists in trait\n@@ -2280,31 +2324,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n-            // `<T>::a::b::c` is resolved by typeck alone.\n-            TyPath(Some(ast::QSelf { position: 0, .. }), _) => {}\n-\n             TyPath(ref maybe_qself, ref path) => {\n-                let max_assoc_types = if let Some(ref qself) = *maybe_qself {\n-                    // Make sure the trait is valid.\n-                    let _ = self.resolve_trait_reference(ty.id, path, 1);\n-                    path.segments.len() - qself.position\n-                } else {\n-                    path.segments.len()\n-                };\n-\n-                let mut resolution = None;\n-                for depth in 0..max_assoc_types {\n-                    self.with_no_errors(|this| {\n-                        resolution = this.resolve_path(ty.id, path, depth, TypeNS, true);\n-                    });\n-                    if resolution.is_some() {\n-                        break;\n-                    }\n-                }\n-                if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n-                    // A module is not a valid type.\n-                    resolution = None;\n-                }\n+                let resolution =\n+                    match self.resolve_possibly_assoc_item(ty.id,\n+                                                           maybe_qself.as_ref(),\n+                                                           path,\n+                                                           TypeNS,\n+                                                           true) {\n+                        // `<T>::a::b::c` is resolved by typeck alone.\n+                        TypecheckRequired => {\n+                            // Resolve embedded types.\n+                            visit::walk_ty(self, ty);\n+                            return;\n+                        }\n+                        ResolveAttempt(resolution) => resolution,\n+                    };\n \n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n@@ -2464,7 +2498,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 PatEnum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n-                    if let Some(path_res) = self.resolve_path(pat_id, path, 0, ValueNS, false) {\n+                    let resolution =\n+                        match self.resolve_possibly_assoc_item(pat_id, None,\n+                                                               path, ValueNS,\n+                                                               false) {\n+                            // The below shouldn't happen because all\n+                            // qualified paths should be in PatQPath.\n+                            TypecheckRequired =>\n+                                self.session.span_bug(\n+                                    path.span,\n+                                    \"resolve_possibly_assoc_item claimed\n+                                     that a path in PatEnum requires typecheck\n+                                     to resolve, but qualified paths should be\n+                                     PatQPath\"),\n+                            ResolveAttempt(resolution) => resolution,\n+                        };\n+                    if let Some(path_res) = resolution {\n                         match path_res.base_def {\n                             DefVariant(..) | DefStruct(..) | DefConst(..) => {\n                                 self.record_def(pattern.id, path_res);\n@@ -2475,19 +2524,70 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                     referenced in a pattern, \\\n                                                     use a `const` instead\");\n                             }\n+                            _ => {\n+                                // If anything ends up here entirely resolved,\n+                                // it's an error. If anything ends up here\n+                                // partially resolved, that's OK, because it may\n+                                // be a `T::CONST` that typeck will resolve to\n+                                // an inherent impl.\n+                                if path_res.depth == 0 {\n+                                    self.resolve_error(\n+                                        path.span,\n+                                        &format!(\"`{}` is not an enum variant, struct or const\",\n+                                                 token::get_ident(\n+                                                     path.segments.last().unwrap().identifier)));\n+                                } else {\n+                                    self.record_def(pattern.id, path_res);\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        self.resolve_error(path.span,\n+                            &format!(\"unresolved enum variant, struct or const `{}`\",\n+                                token::get_ident(path.segments.last().unwrap().identifier)));\n+                    }\n+                    visit::walk_path(self, path);\n+                }\n+\n+                PatQPath(ref qself, ref path) => {\n+                    // Associated constants only.\n+                    let resolution =\n+                        match self.resolve_possibly_assoc_item(pat_id, Some(qself),\n+                                                               path, ValueNS,\n+                                                               false) {\n+                            TypecheckRequired => {\n+                                // All `<T>::CONST` should end up here, and will\n+                                // require use of the trait map to resolve\n+                                // during typechecking.\n+                                let const_name = path.segments.last().unwrap()\n+                                                     .identifier.name;\n+                                let traits = self.get_traits_containing_item(const_name);\n+                                self.trait_map.insert(pattern.id, traits);\n+                                visit::walk_pat(self, pattern);\n+                                return true;\n+                            }\n+                            ResolveAttempt(resolution) => resolution,\n+                        };\n+                    if let Some(path_res) = resolution {\n+                        match path_res.base_def {\n+                            // All `<T as Trait>::CONST` should end up here, and\n+                            // have the trait already selected.\n+                            DefAssociatedConst(..) => {\n+                                self.record_def(pattern.id, path_res);\n+                            }\n                             _ => {\n                                 self.resolve_error(path.span,\n-                                    &format!(\"`{}` is not an enum variant, struct or const\",\n+                                    &format!(\"`{}` is not an associated const\",\n                                         token::get_ident(\n                                             path.segments.last().unwrap().identifier)));\n                             }\n                         }\n                     } else {\n                         self.resolve_error(path.span,\n-                            &format!(\"unresolved enum variant, struct or const `{}`\",\n+                            &format!(\"unresolved associated const `{}`\",\n                                 token::get_ident(path.segments.last().unwrap().identifier)));\n                     }\n-                    visit::walk_path(self, path);\n+                    visit::walk_pat(self, pattern);\n                 }\n \n                 PatStruct(ref path, _, _) => {\n@@ -2542,7 +2642,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             def @ DefVariant(..) | def @ DefStruct(..) => {\n                                 return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n                             }\n-                            def @ DefConst(..) => {\n+                            def @ DefConst(..) | def @ DefAssociatedConst(..) => {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n                             DefStatic(..) => {\n@@ -2579,6 +2679,47 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n+    /// Handles paths that may refer to associated items\n+    fn resolve_possibly_assoc_item(&mut self,\n+                                   id: NodeId,\n+                                   maybe_qself: Option<&ast::QSelf>,\n+                                   path: &Path,\n+                                   namespace: Namespace,\n+                                   check_ribs: bool)\n+                                   -> AssocItemResolveResult\n+    {\n+        match maybe_qself {\n+            Some(&ast::QSelf { position: 0, .. }) =>\n+                return TypecheckRequired,\n+            _ => {}\n+        }\n+        let max_assoc_types = if let Some(qself) = maybe_qself {\n+            // Make sure the trait is valid.\n+            let _ = self.resolve_trait_reference(id, path, 1);\n+            path.segments.len() - qself.position\n+        } else {\n+            path.segments.len()\n+        };\n+\n+        let mut resolution = self.with_no_errors(|this| {\n+            this.resolve_path(id, path, 0, namespace, check_ribs)\n+        });\n+        for depth in 1..max_assoc_types {\n+            if resolution.is_some() {\n+                break;\n+            }\n+            self.with_no_errors(|this| {\n+                resolution = this.resolve_path(id, path, depth,\n+                                               TypeNS, true);\n+            });\n+        }\n+        if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n+            // A module is not a valid type or value.\n+            resolution = None;\n+        }\n+        ResolveAttempt(resolution)\n+    }\n+\n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n     /// Skips `path_depth` trailing segments, which is also reflected in the\n@@ -3093,38 +3234,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Next, resolve the node.\n         match expr.node {\n-            // `<T>::a::b::c` is resolved by typeck alone.\n-            ExprPath(Some(ast::QSelf { position: 0, .. }), ref path) => {\n-                let method_name = path.segments.last().unwrap().identifier.name;\n-                let traits = self.search_for_traits_containing_method(method_name);\n-                self.trait_map.insert(expr.id, traits);\n-                visit::walk_expr(self, expr);\n-            }\n-\n             ExprPath(ref maybe_qself, ref path) => {\n-                let max_assoc_types = if let Some(ref qself) = *maybe_qself {\n-                    // Make sure the trait is valid.\n-                    let _ = self.resolve_trait_reference(expr.id, path, 1);\n-                    path.segments.len() - qself.position\n-                } else {\n-                    path.segments.len()\n-                };\n-\n-                let mut resolution = self.with_no_errors(|this| {\n-                    this.resolve_path(expr.id, path, 0, ValueNS, true)\n-                });\n-                for depth in 1..max_assoc_types {\n-                    if resolution.is_some() {\n-                        break;\n-                    }\n-                    self.with_no_errors(|this| {\n-                        resolution = this.resolve_path(expr.id, path, depth, TypeNS, true);\n-                    });\n-                }\n-                if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n-                    // A module is not a valid type or value.\n-                    resolution = None;\n-                }\n+                let resolution =\n+                    match self.resolve_possibly_assoc_item(expr.id,\n+                                                           maybe_qself.as_ref(),\n+                                                           path,\n+                                                           ValueNS,\n+                                                           true) {\n+                        // `<T>::a::b::c` is resolved by typeck alone.\n+                        TypecheckRequired => {\n+                            let method_name = path.segments.last().unwrap().identifier.name;\n+                            let traits = self.get_traits_containing_item(method_name);\n+                            self.trait_map.insert(expr.id, traits);\n+                            visit::walk_expr(self, expr);\n+                            return;\n+                        }\n+                        ResolveAttempt(resolution) => resolution,\n+                    };\n \n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n@@ -3155,7 +3281,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // so they can be completed during typeck.\n                         if path_res.depth != 0 {\n                             let method_name = path.segments.last().unwrap().identifier.name;\n-                            let traits = self.search_for_traits_containing_method(method_name);\n+                            let traits = self.get_traits_containing_item(method_name);\n                             self.trait_map.insert(expr.id, traits);\n                         }\n \n@@ -3313,14 +3439,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.search_for_traits_containing_method(ident.node.name);\n+                let traits = self.get_traits_containing_item(ident.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprMethodCall(ident, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);\n-                let traits = self.search_for_traits_containing_method(ident.node.name);\n+                let traits = self.get_traits_containing_item(ident.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -3329,8 +3455,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn search_for_traits_containing_method(&mut self, name: Name) -> Vec<DefId> {\n-        debug!(\"(searching for traits containing method) looking for '{}'\",\n+    fn get_traits_containing_item(&mut self, name: Name) -> Vec<DefId> {\n+        debug!(\"(getting traits containing item) looking for '{}'\",\n                token::get_name(name));\n \n         fn add_trait_info(found_traits: &mut Vec<DefId>,\n@@ -3580,3 +3706,8 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                     },\n     }\n }\n+\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "350f69d30c4e452d8c0779e6798162aa7e257ae9", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -10,7 +10,7 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use {PUBLIC, IMPORTABLE};\n+use DefModifiers;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use NameBindings;\n@@ -848,7 +848,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // Merge the child item into the import resolution.\n         {\n             let mut merge_child_item = |namespace| {\n-                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n+                let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n+\n+                if name_bindings.defined_in_namespace_with(namespace, modifier) {\n                     let namespace_name = match namespace {\n                         TypeNS => \"type\",\n                         ValueNS => \"value\",\n@@ -914,7 +916,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                        import_span: Span,\n                                        name: Name,\n                                        namespace: Namespace) {\n-        if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n+        if !name_bindings.defined_in_namespace_with(namespace, DefModifiers::IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n             span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);"}, {"sha": "92c9549b37727adbd9263cc95d52120776ef3efd", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -32,7 +32,7 @@ use std::ffi::OsString;\n use std::fs::{self, PathExt};\n use std::io::{self, Read, Write};\n use std::mem;\n-use std::path::{Path, PathBuf};\n+use std::path::{self, Path, PathBuf};\n use std::process::Command;\n use std::str;\n use flate;\n@@ -794,13 +794,21 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     let pname = get_cc_prog(sess);\n     let mut cmd = Command::new(&pname[..]);\n \n+    let root = sess.target_filesearch(PathKind::Native).get_lib_path();\n     cmd.args(&sess.target.target.options.pre_link_args);\n+    for obj in &sess.target.target.options.pre_link_objects {\n+        cmd.arg(root.join(obj));\n+    }\n+\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n-    cmd.args(&sess.target.target.options.post_link_args);\n     if !sess.target.target.options.no_compiler_rt {\n         cmd.arg(\"-lcompiler-rt\");\n     }\n+    for obj in &sess.target.target.options.post_link_objects {\n+        cmd.arg(root.join(obj));\n+    }\n+    cmd.args(&sess.target.target.options.post_link_args);\n \n     if sess.opts.debugging_opts.print_link_args {\n         println!(\"{:?}\", &cmd);\n@@ -864,7 +872,7 @@ fn link_args(cmd: &mut Command,\n     // target descriptor\n     let t = &sess.target.target;\n \n-    cmd.arg(\"-L\").arg(&lib_path);\n+    cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(&lib_path));\n \n     cmd.arg(\"-o\").arg(out_filename).arg(obj_filename);\n \n@@ -916,8 +924,9 @@ fn link_args(cmd: &mut Command,\n         // stripped away as much as it could. This has not been seen to impact\n         // link times negatively.\n         //\n-        // -dead_strip can't be part of the pre_link_args because it's also used for partial\n-        // linking when using multiple codegen units (-r). So we insert it here.\n+        // -dead_strip can't be part of the pre_link_args because it's also used\n+        // for partial linking when using multiple codegen units (-r). So we\n+        // insert it here.\n         cmd.arg(\"-Wl,-dead_strip\");\n     }\n \n@@ -1043,7 +1052,6 @@ fn link_args(cmd: &mut Command,\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n             get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n-            realpath: &mut ::util::fs::realpath\n         };\n         cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n     }\n@@ -1258,7 +1266,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 }\n             });\n         } else {\n-            cmd.arg(cratepath);\n+            cmd.arg(&fix_windows_verbatim_for_gcc(cratepath));\n         }\n     }\n \n@@ -1271,7 +1279,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // Just need to tell the linker about where the library lives and\n         // what its name is\n         if let Some(dir) = cratepath.parent() {\n-            cmd.arg(\"-L\").arg(dir);\n+            cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(dir));\n         }\n         let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n         cmd.arg(&format!(\"-l{}\", unlib(&sess.target, filestem)));\n@@ -1325,3 +1333,29 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n         }\n     }\n }\n+\n+// Unfortunately, on windows, gcc cannot accept paths of the form `\\\\?\\C:\\...`\n+// (a verbatim path). This form of path is generally pretty rare, but the\n+// implementation of `fs::canonicalize` currently generates paths of this form,\n+// meaning that we're going to be passing quite a few of these down to gcc.\n+//\n+// For now we just strip the \"verbatim prefix\" of `\\\\?\\` from the path. This\n+// will probably lose information in some cases, but there's not a whole lot\n+// more we can do with a buggy gcc...\n+fn fix_windows_verbatim_for_gcc(p: &Path) -> PathBuf {\n+    if !cfg!(windows) {\n+        return p.to_path_buf()\n+    }\n+    let mut components = p.components();\n+    let prefix = match components.next() {\n+        Some(path::Component::Prefix(p)) => p,\n+        _ => return p.to_path_buf(),\n+    };\n+    let disk = match prefix.kind() {\n+        path::Prefix::VerbatimDisk(disk) => disk,\n+        _ => return p.to_path_buf(),\n+    };\n+    let mut base = OsString::from(format!(\"{}:\", disk as char));\n+    base.push(components.as_path());\n+    PathBuf::from(base)\n+}"}, {"sha": "3e2db80a9c556dbe55076575c8e75dd7c916540e", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -34,7 +34,6 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(unicode)]\n #![feature(path_ext)]"}, {"sha": "d80086da20315af17357c4ee927f8a7d469875d6", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -242,6 +242,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n             def::DefConst(_) |\n+            def::DefAssociatedConst(..) |\n             def::DefLocal(_) |\n             def::DefVariant(_, _, _) |\n             def::DefUpvar(..) => Some(recorder::VarRef),\n@@ -294,6 +295,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return;\n         }\n \n+        debug!(\"process_method: {}:{}\", id, token::get_name(name));\n+\n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n@@ -359,14 +362,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n                                              ast_util::local_def(id))\n-            .and_then(|def_id| {\n-                if match def_id {\n-                    ty::MethodTraitItemId(def_id) => {\n-                        def_id.node != 0 && def_id != ast_util::local_def(id)\n-                    }\n-                    ty::TypeTraitItemId(_) => false,\n-                } {\n-                    Some(def_id.def_id())\n+            .and_then(|new_id| {\n+                let def_id = new_id.def_id();\n+                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n+                    Some(def_id)\n                 } else {\n                     None\n                 }\n@@ -542,25 +541,27 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     fn process_const(&mut self,\n-                      item: &ast::Item,\n-                      typ: &ast::Ty,\n-                      expr: &ast::Expr)\n+                     id: ast::NodeId,\n+                     ident: &ast::Ident,\n+                     span: Span,\n+                     typ: &ast::Ty,\n+                     expr: &ast::Expr)\n     {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(id));\n \n-        let sub_span = self.span.sub_span_after_keyword(item.span,\n+        let sub_span = self.span.sub_span_after_keyword(span,\n                                                         keywords::Const);\n-        self.fmt.static_str(item.span,\n+        self.fmt.static_str(span,\n                             sub_span,\n-                            item.id,\n-                            &get_ident(item.ident),\n+                            id,\n+                            &get_ident((*ident).clone()),\n                             &qualname[..],\n                             \"\",\n                             &ty_to_string(&*typ),\n                             self.cur_scope);\n \n         // walk type and init value\n-        self.visit_ty(&*typ);\n+        self.visit_ty(typ);\n         self.visit_expr(expr);\n     }\n \n@@ -705,7 +706,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n-            visit::walk_impl_item(self, impl_item);\n+            self.visit_impl_item(impl_item);\n         }\n     }\n \n@@ -800,6 +801,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n             def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n             def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n                                                     span,\n                                                     sub_span,\n@@ -883,6 +885,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefLocal(_) |\n             def::DefStatic(_,_) |\n             def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n             def::DefStruct(_) |\n             def::DefVariant(..) |\n             def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n@@ -966,7 +969,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     ty::MethodTraitItem(method) => {\n                         method.provided_source.unwrap_or(def_id)\n                     }\n-                    ty::TypeTraitItem(_) => def_id,\n+                    _ => self.sess\n+                             .span_bug(ex.span,\n+                                       \"save::process_method_call: non-method \\\n+                                        DefId in MethodStatic or MethodStaticClosure\"),\n                 };\n                 (Some(def_id), decl_id)\n             }\n@@ -1008,7 +1014,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n                 let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n                 let struct_def = match def {\n-                    def::DefConst(..) => None,\n+                    def::DefConst(..) | def::DefAssociatedConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n                     _ => {\n                         match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n@@ -1040,7 +1046,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::PatEnum(ref path, _) => {\n+            ast::PatEnum(ref path, _) |\n+            ast::PatQPath(_, ref path) => {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n                 visit::walk_pat(self, p);\n             }\n@@ -1186,7 +1193,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             ast::ItemStatic(ref typ, mt, ref expr) =>\n                 self.process_static(item, &**typ, mt, &**expr),\n             ast::ItemConst(ref typ, ref expr) =>\n-                self.process_const(item, &**typ, &**expr),\n+                self.process_const(item.id, &item.ident, item.span, &*typ, &*expr),\n             ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n             ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             ast::ItemImpl(_, _,\n@@ -1236,16 +1243,25 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         match trait_item.node {\n+            ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n+                self.process_const(trait_item.id, &trait_item.ident,\n+                                   trait_item.span, &*ty, &*expr);\n+            }\n             ast::MethodTraitItem(ref sig, ref body) => {\n                 self.process_method(sig, body.as_ref().map(|x| &**x),\n                                     trait_item.id, trait_item.ident.name, trait_item.span);\n             }\n+            ast::ConstTraitItem(_, None) |\n             ast::TypeTraitItem(..) => {}\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n         match impl_item.node {\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                self.process_const(impl_item.id, &impl_item.ident,\n+                                   impl_item.span, &ty, &expr);\n+            }\n             ast::MethodImplItem(ref sig, ref body) => {\n                 self.process_method(sig, Some(body), impl_item.id,\n                                     impl_item.ident.name, impl_item.span);\n@@ -1432,8 +1448,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 // FIXME(nrc) what are these doing here?\n-                def::DefStatic(_, _) => {}\n-                def::DefConst(..) => {}\n+                def::DefStatic(_, _) |\n+                def::DefConst(..) |\n+                def::DefAssociatedConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n                             def)\n             }"}, {"sha": "060dde02c2d12269b38fb724153f363f24ac3759", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -916,8 +916,8 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         let datum = Datum::new(llval, binding_info.ty, Lvalue);\n         if let Some(cs) = cs {\n-            bcx.fcx.schedule_drop_and_zero_mem(cs, llval, binding_info.ty);\n             bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n+            bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty);\n         }\n \n         debug!(\"binding {} to {}\", binding_info.id, bcx.val_to_string(llval));\n@@ -1809,7 +1809,8 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::PatMac(..) => {\n             bcx.sess().span_bug(pat.span, \"unexpanded macro\");\n         }\n-        ast::PatWild(_) | ast::PatLit(_) | ast::PatRange(_, _) => ()\n+        ast::PatQPath(..) | ast::PatWild(_) | ast::PatLit(_) |\n+        ast::PatRange(_, _) => ()\n     }\n     return bcx;\n }"}, {"sha": "001de615fb1eb3c5fea7ad8fb776cf12752d2adf", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -414,6 +414,10 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n             assert_eq!(nonzero_fields.len(), 1);\n             let nonzero_field = ty::lookup_field_type(tcx, did, nonzero_fields[0].id, substs);\n             match nonzero_field.sty {\n+                ty::ty_ptr(ty::mt { ty, .. }) if !type_is_sized(tcx, ty) => {\n+                    path.push_all(&[0, FAT_PTR_ADDR]);\n+                    Some(path)\n+                },\n                 ty::ty_ptr(..) | ty::ty_int(..) | ty::ty_uint(..) => {\n                     path.push(0);\n                     Some(path)\n@@ -436,6 +440,22 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n             None\n         },\n \n+        // Perhaps one of the upvars of this struct is non-zero\n+        // Let's recurse and find out!\n+        ty::ty_closure(def_id, substs) => {\n+            let typer = NormalizingClosureTyper::new(tcx);\n+            let upvars = typer.closure_upvars(def_id, substs).unwrap();\n+            let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n+\n+            for (j, &ty) in upvar_types.iter().enumerate() {\n+                if let Some(mut fpath) = find_discr_field_candidate(tcx, ty, path.clone()) {\n+                    fpath.push(j);\n+                    return Some(fpath);\n+                }\n+            }\n+            None\n+        },\n+\n         // Can we use one of the fields in this tuple?\n         ty::ty_tup(ref tys) => {\n             for (j, &ty) in tys.iter().enumerate() {\n@@ -767,6 +787,7 @@ pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             (_match::Switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n         }\n         Univariant(..) => {\n+            // N.B.: Univariant means <= 1 enum variants (*not* == 1 variants).\n             (_match::Single, None)\n         }\n     }\n@@ -1058,7 +1079,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n                 let ptr = struct_field_ptr(variant_cx, st, value, (st.fields.len() - 1), false);\n-                datum::Datum::new(ptr, ptr_ty, datum::Rvalue::new(datum::ByRef))\n+                datum::Datum::new(ptr, ptr_ty, datum::Lvalue)\n                     .store_to(variant_cx, scratch.val)\n             });\n             let expr_datum = scratch.to_expr_datum();"}, {"sha": "b44ccec0127bd7f864b387e6d24ae216667a933b", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -39,13 +39,13 @@ pub fn split_stack(val: ValueRef, set: bool) {\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n-        Hint   => llvm::SetFunctionAttribute(val, llvm::InlineHintAttribute),\n-        Always => llvm::SetFunctionAttribute(val, llvm::AlwaysInlineAttribute),\n-        Never  => llvm::SetFunctionAttribute(val, llvm::NoInlineAttribute),\n+        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHintAttribute),\n+        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInlineAttribute),\n+        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInlineAttribute),\n         None   => {\n-            let attr = llvm::InlineHintAttribute |\n-                       llvm::AlwaysInlineAttribute |\n-                       llvm::NoInlineAttribute;\n+            let attr = llvm::Attribute::InlineHintAttribute |\n+                       llvm::Attribute::AlwaysInlineAttribute |\n+                       llvm::Attribute::NoInlineAttribute;\n             unsafe {\n                 llvm::LLVMRemoveFunctionAttr(val, attr.bits() as c_ulonglong)\n             }\n@@ -57,10 +57,13 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {\n #[inline]\n pub fn emit_uwtable(val: ValueRef, emit: bool) {\n     if emit {\n-        llvm::SetFunctionAttribute(val, llvm::UWTableAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTableAttribute);\n     } else {\n         unsafe {\n-            llvm::LLVMRemoveFunctionAttr(val, llvm::UWTableAttribute.bits() as c_ulonglong);\n+            llvm::LLVMRemoveFunctionAttr(\n+                val,\n+                llvm::Attribute::UWTableAttribute.bits() as c_ulonglong,\n+            );\n         }\n     }\n }\n@@ -71,10 +74,13 @@ pub fn emit_uwtable(val: ValueRef, emit: bool) {\n pub fn unwind(val: ValueRef, can_unwind: bool) {\n     if can_unwind {\n         unsafe {\n-            llvm::LLVMRemoveFunctionAttr(val, llvm::NoUnwindAttribute.bits() as c_ulonglong);\n+            llvm::LLVMRemoveFunctionAttr(\n+                val,\n+                llvm::Attribute::NoUnwindAttribute.bits() as c_ulonglong,\n+            );\n         }\n     } else {\n-        llvm::SetFunctionAttribute(val, llvm::NoUnwindAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwindAttribute);\n     }\n }\n \n@@ -83,10 +89,13 @@ pub fn unwind(val: ValueRef, can_unwind: bool) {\n #[allow(dead_code)] // possibly useful function\n pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n     if optimize {\n-        llvm::SetFunctionAttribute(val, llvm::OptimizeForSizeAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSizeAttribute);\n     } else {\n         unsafe {\n-            llvm::LLVMRemoveFunctionAttr(val, llvm::OptimizeForSizeAttribute.bits() as c_ulonglong);\n+            llvm::LLVMRemoveFunctionAttr(\n+                val,\n+                llvm::Attribute::OptimizeForSizeAttribute.bits() as c_ulonglong,\n+            );\n         }\n     }\n }\n@@ -107,7 +116,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n                                                llvm::ColdAttribute as u64)\n             }\n         } else if attr.check_name(\"allocator\") {\n-            llvm::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n+            llvm::Attribute::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n         }\n     }\n }\n@@ -176,9 +185,9 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // The outptr can be noalias and nocapture because it's entirely\n             // invisible to the program. We also know it's nonnull as well\n             // as how many bytes we can dereference\n-            attrs.arg(1, llvm::StructRetAttribute)\n-                 .arg(1, llvm::NoAliasAttribute)\n-                 .arg(1, llvm::NoCaptureAttribute)\n+            attrs.arg(1, llvm::Attribute::StructRetAttribute)\n+                 .arg(1, llvm::Attribute::NoAliasAttribute)\n+                 .arg(1, llvm::Attribute::NoCaptureAttribute)\n                  .arg(1, llvm::DereferenceableAttribute(llret_sz));\n \n             // Add one more since there's an outptr\n@@ -190,7 +199,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // `~` pointer return values never alias because ownership\n                 // is transferred\n                 ty::ty_uniq(it) if common::type_is_sized(ccx.tcx(), it) => {\n-                    attrs.ret(llvm::NoAliasAttribute);\n+                    attrs.ret(llvm::Attribute::NoAliasAttribute);\n                 }\n                 _ => {}\n             }\n@@ -207,7 +216,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             }\n \n             if let ty::ty_bool = ret_ty.sty {\n-                attrs.ret(llvm::ZExtAttribute);\n+                attrs.ret(llvm::Attribute::ZExtAttribute);\n             }\n         }\n     }\n@@ -221,20 +230,20 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // For non-immediate arguments the callee gets its own copy of\n                 // the value on the stack, so there are no aliases. It's also\n                 // program-invisible so can't possibly capture\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n+                     .arg(idx, llvm::Attribute::NoCaptureAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n             }\n \n             ty::ty_bool => {\n-                attrs.arg(idx, llvm::ZExtAttribute);\n+                attrs.arg(idx, llvm::Attribute::ZExtAttribute);\n             }\n \n             // `~` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(inner) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n \n-                attrs.arg(idx, llvm::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n \n@@ -247,23 +256,23 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                                   !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n \n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n \n                 if mt.mutbl == ast::MutImmutable {\n-                    attrs.arg(idx, llvm::ReadOnlyAttribute);\n+                    attrs.arg(idx, llvm::Attribute::ReadOnlyAttribute);\n                 }\n \n                 if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx, llvm::NoCaptureAttribute);\n+                    attrs.arg(idx, llvm::Attribute::NoCaptureAttribute);\n                 }\n             }\n \n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n             ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoCaptureAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n "}, {"sha": "4879975dde695c265bd7505b3e1127a0bccebf5c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -125,7 +125,6 @@ pub struct _InsnCtxt {\n     _cannot_construct_outside_of_this_module: ()\n }\n \n-#[unsafe_destructor]\n impl Drop for _InsnCtxt {\n     fn drop(&mut self) {\n         TASK_LOCAL_INSN_KEY.with(|slot| {\n@@ -166,7 +165,6 @@ impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n         if self.ccx.sess().trans_stats() {\n@@ -471,8 +469,11 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n \n           match adt::trans_switch(cx, &*repr, av) {\n               (_match::Single, None) => {\n-                  cx = iter_variant(cx, &*repr, av, &*(*variants)[0],\n-                                    substs, &mut f);\n+                  if n_variants != 0 {\n+                      assert!(n_variants == 1);\n+                      cx = iter_variant(cx, &*repr, av, &*(*variants)[0],\n+                                        substs, &mut f);\n+                  }\n               }\n               (_match::Switch, Some(lldiscrim_a)) => {\n                   cx = f(cx, lldiscrim_a, cx.tcx().types.isize);\n@@ -1078,25 +1079,17 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         Some(ast_map::NodeTraitItem(trait_item)) => {\n             match trait_item.node {\n                 ast::MethodTraitItem(_, Some(ref body)) => body,\n-                ast::MethodTraitItem(_, None) => {\n-                    tcx.sess.bug(\"unexpected variant: required trait method \\\n-                                  in has_nested_returns\")\n-                }\n-                ast::TypeTraitItem(..) => {\n-                    tcx.sess.bug(\"unexpected variant: associated type trait item in \\\n-                                  has_nested_returns\")\n+                _ => {\n+                    tcx.sess.bug(\"unexpected variant: trait item other than a \\\n+                                  provided method in has_nested_returns\")\n                 }\n             }\n         }\n         Some(ast_map::NodeImplItem(impl_item)) => {\n             match impl_item.node {\n                 ast::MethodImplItem(_, ref body) => body,\n-                ast::TypeImplItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: associated type impl item in \\\n-                                  has_nested_returns\")\n-                }\n-                ast::MacImplItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: unexpanded macro impl item in \\\n+                _ => {\n+                    tcx.sess.bug(\"unexpected variant: non-method impl item in \\\n                                   has_nested_returns\")\n                 }\n             }\n@@ -2189,7 +2182,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n \n-            debuginfo::insert_reference_to_gdb_debug_scripts_section_global(ccx);\n+            debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx);\n \n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n@@ -2363,13 +2356,14 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         ast_map::NodeTraitItem(trait_item) => {\n             debug!(\"get_item_val(): processing a NodeTraitItem\");\n             match trait_item.node {\n-                ast::MethodTraitItem(_, None) | ast::TypeTraitItem(..) => {\n-                    ccx.sess().span_bug(trait_item.span,\n-                        \"unexpected variant: required trait method in get_item_val()\");\n-                }\n                 ast::MethodTraitItem(_, Some(_)) => {\n                     register_method(ccx, id, &trait_item.attrs, trait_item.span)\n                 }\n+                _ => {\n+                    ccx.sess().span_bug(trait_item.span,\n+                        \"unexpected variant: trait item other than a provided \\\n+                         method in get_item_val()\");\n+                }\n             }\n         }\n \n@@ -2378,13 +2372,10 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 ast::MethodImplItem(..) => {\n                     register_method(ccx, id, &impl_item.attrs, impl_item.span)\n                 }\n-                ast::TypeImplItem(_) => {\n-                    ccx.sess().span_bug(impl_item.span,\n-                        \"unexpected variant: associated type in get_item_val()\")\n-                }\n-                ast::MacImplItem(_) => {\n+                _ => {\n                     ccx.sess().span_bug(impl_item.span,\n-                        \"unexpected variant: unexpanded macro in get_item_val()\")\n+                        \"unexpected variant: non-method impl item in \\\n+                         get_item_val()\");\n                 }\n             }\n         }"}, {"sha": "d6ac412a4faead9678cc7711671e87e40a1e78df", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -12,7 +12,7 @@\n #![allow(non_snake_case)]\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect, AttrBuilder};\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect, AttrBuilder};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use trans::common::*;\n@@ -965,9 +965,9 @@ pub fn CallWithConv(cx: Block,\n     B(cx).call_with_conv(fn_, args, conv, attributes)\n }\n \n-pub fn AtomicFence(cx: Block, order: AtomicOrdering) {\n+pub fn AtomicFence(cx: Block, order: AtomicOrdering, scope: SynchronizationScope) {\n     if cx.unreachable.get() { return; }\n-    B(cx).atomic_fence(order)\n+    B(cx).atomic_fence(order, scope)\n }\n \n pub fn Select(cx: Block, if_: ValueRef, then: ValueRef, else_: ValueRef) -> ValueRef {"}, {"sha": "497e0ae422c1fa3659c17eadb3e0140b518f5956", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)] // FFI wrappers\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect, AttrBuilder};\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect, AttrBuilder};\n use llvm::{Opcode, IntPredicate, RealPredicate, False};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use trans::base;\n@@ -989,9 +989,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_fence(&self, order: AtomicOrdering) {\n+    pub fn atomic_fence(&self, order: AtomicOrdering, scope: SynchronizationScope) {\n         unsafe {\n-            llvm::LLVMBuildAtomicFence(self.llbuilder, order);\n+            llvm::LLVMBuildAtomicFence(self.llbuilder, order, scope);\n         }\n     }\n }"}, {"sha": "2eef678673987dc8ee28cbfdfa57fe469e776f9b", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -10,8 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -164,7 +163,7 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n@@ -186,12 +185,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {"}, {"sha": "689b3b3ad37eef5695cc2f02a75c04b40b1327ba", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -10,8 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -132,7 +131,7 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let size = ty_size(ty, align_fn);\n@@ -146,12 +145,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let align = align_fn(ty);"}, {"sha": "2e899f72979d7e491233dbff117ea88e163e624a", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -13,8 +13,7 @@\n use libc::c_uint;\n use std::cmp;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -89,10 +88,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n     }\n }\n \n@@ -106,7 +105,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "eae2378a2c518e0fd970a7495ea975bec4d1d4c2", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -10,8 +10,7 @@\n \n use libc::c_uint;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Attribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -85,10 +84,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n     }\n }\n \n@@ -102,7 +101,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "d9c265d94a793e8f92c534e6d334ee2035e8f4e9", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -52,11 +52,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 ret_ty = ArgType::direct(rty, Some(t), None, None);\n             }\n             RetPointer => {\n-                ret_ty = ArgType::indirect(rty, Some(StructRetAttribute));\n+                ret_ty = ArgType::indirect(rty, Some(Attribute::StructRetAttribute));\n             }\n         }\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -67,11 +67,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 if size == 0 {\n                     ArgType::ignore(t)\n                 } else {\n-                    ArgType::indirect(t, Some(ByValAttribute))\n+                    ArgType::indirect(t, Some(Attribute::ByValAttribute))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "d954a861a7267390256e87685d1abef932e22074", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -16,7 +16,6 @@ use self::RegClass::*;\n \n use llvm::{Integer, Pointer, Float, Double};\n use llvm::{Struct, Array, Attribute, Vector};\n-use llvm::{StructRetAttribute, ByValAttribute, ZExtAttribute};\n use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -407,19 +406,19 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                                 None)\n             }\n         } else {\n-            let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n             ArgType::direct(ty, None, None, attr)\n         }\n     }\n \n     let mut arg_tys = Vec::new();\n     for t in atys {\n-        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), ByValAttribute);\n+        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), Attribute::ByValAttribute);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), StructRetAttribute)\n+        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), Attribute::StructRetAttribute)\n     } else {\n         ArgType::direct(Type::void(ccx), None, None, None)\n     };"}, {"sha": "7808b9d27feead1a39005e8bc6e3a2b120719768", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -31,10 +31,10 @@ pub fn compute_abi_info(ccx: &CrateContext,\n             2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n             4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n             8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-            _ => ArgType::indirect(rty, Some(StructRetAttribute))\n+            _ => ArgType::indirect(rty, Some(Attribute::StructRetAttribute))\n         };\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -46,11 +46,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                     2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n                     4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n                     8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-                    _ => ArgType::indirect(t, Some(ByValAttribute))\n+                    _ => ArgType::indirect(t, Some(Attribute::ByValAttribute))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "0e4680723073f50881e8a0b0b0389ea221996d1a", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -202,6 +202,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             }\n             def::DefStatic(..) |\n             def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n             def::DefLocal(..) |\n             def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n@@ -465,9 +466,9 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n                     (true, source_id, new_substs)\n                 }\n-                ty::TypeTraitItem(_) => {\n+                _ => {\n                     tcx.sess.bug(\"trans_fn_ref_with_vtables() tried \\\n-                                  to translate an associated type?!\")\n+                                  to translate a non-method?!\")\n                 }\n             }\n         }"}, {"sha": "637325881436dd8e2e1b1c6ad2b076b017f2773c", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 67, "deletions": 17, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -393,37 +393,74 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n-            zero: false\n+            fill_on_drop: false,\n+            skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n+        debug!(\"schedule_drop_mem({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()));\n+               ty.repr(self.ccx.tcx()),\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n+\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n+    }\n+\n+    /// Schedules a (deep) drop and filling of `val`, which is a pointer to an instance of `ty`\n+    fn schedule_drop_and_fill_mem(&self,\n+                                  cleanup_scope: ScopeId,\n+                                  val: ValueRef,\n+                                  ty: Ty<'tcx>) {\n+        if !self.type_needs_drop(ty) { return; }\n+\n+        let drop = box DropValue {\n+            is_immediate: false,\n+            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n+            val: val,\n+            ty: ty,\n+            fill_on_drop: true,\n+            skip_dtor: false,\n+        };\n+\n+        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={}, fill_on_drop={}, skip_dtor={})\",\n+               cleanup_scope,\n+               self.ccx.tn().val_to_string(val),\n+               ty.repr(self.ccx.tcx()),\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n-    /// Schedules a (deep) drop and zero-ing of `val`, which is a pointer to an instance of `ty`\n-    fn schedule_drop_and_zero_mem(&self,\n+    /// Issue #23611: Schedules a (deep) drop of the contents of\n+    /// `val`, which is a pointer to an instance of struct/enum type\n+    /// `ty`. The scheduled code handles extracting the discriminant\n+    /// and dropping the contents associated with that variant\n+    /// *without* executing any associated drop implementation.\n+    fn schedule_drop_adt_contents(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>) {\n+        // `if` below could be \"!contents_needs_drop\"; skipping drop\n+        // is just an optimization, so sound to be conservative.\n         if !self.type_needs_drop(ty) { return; }\n \n         let drop = box DropValue {\n             is_immediate: false,\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n-            zero: true\n+            fill_on_drop: false,\n+            skip_dtor: true,\n         };\n \n-        debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n+        debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n-               true);\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -440,13 +477,16 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n-            zero: false\n+            fill_on_drop: false,\n+            skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?})\",\n+        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()));\n+               ty.repr(self.ccx.tcx()),\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -987,7 +1027,8 @@ pub struct DropValue<'tcx> {\n     must_unwind: bool,\n     val: ValueRef,\n     ty: Ty<'tcx>,\n-    zero: bool\n+    fill_on_drop: bool,\n+    skip_dtor: bool,\n }\n \n impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n@@ -1007,13 +1048,18 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        let _icx = base::push_ctxt(\"<DropValue as Cleanup>::trans\");\n+        let skip_dtor = self.skip_dtor;\n+        let _icx = if skip_dtor {\n+            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=true\")\n+        } else {\n+            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=false\")\n+        };\n         let bcx = if self.is_immediate {\n-            glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n+            glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         } else {\n-            glue::drop_ty(bcx, self.val, self.ty, debug_loc)\n+            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         };\n-        if self.zero {\n+        if self.fill_on_drop {\n             base::drop_done_fill_mem(bcx, self.val, self.ty);\n         }\n         bcx\n@@ -1190,7 +1236,11 @@ pub trait CleanupMethods<'blk, 'tcx> {\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n                          ty: Ty<'tcx>);\n-    fn schedule_drop_and_zero_mem(&self,\n+    fn schedule_drop_and_fill_mem(&self,\n+                                  cleanup_scope: ScopeId,\n+                                  val: ValueRef,\n+                                  ty: Ty<'tcx>);\n+    fn schedule_drop_adt_contents(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>);"}, {"sha": "3aaf4addd89626fc8d99540832099e0198fef317", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -173,13 +173,11 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             \"cross crate constant could not be inlined\");\n     }\n \n-    let item = ccx.tcx().map.expect_item(def_id.node);\n-    if let ast::ItemConst(_, ref expr) = item.node {\n-        &**expr\n-    } else {\n-        ccx.sess().span_bug(ref_expr.span,\n-                            &format!(\"get_const_expr given non-constant item {}\",\n-                                     item.repr(ccx.tcx())));\n+    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(ref_expr.id)) {\n+        Some(ref expr) => expr,\n+        None => {\n+            ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n+        }\n     }\n }\n \n@@ -188,7 +186,7 @@ fn get_const_val(ccx: &CrateContext,\n                  ref_expr: &ast::Expr) -> ValueRef {\n     let expr = get_const_expr(ccx, def_id, ref_expr);\n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-    get_const_expr_as_global(ccx, expr, check_const::PURE_CONST, empty_substs)\n+    get_const_expr_as_global(ccx, expr, check_const::ConstQualif::PURE_CONST, empty_substs)\n }\n \n pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -201,7 +199,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast::ExprPath(..) => {\n             let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             match def {\n-                def::DefConst(def_id) => {\n+                def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n                     if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n                         return get_const_val(ccx, def_id, expr);\n                     }\n@@ -217,7 +215,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         Some(&val) => return val,\n         None => {}\n     }\n-    let val = if qualif.intersects(check_const::NON_STATIC_BORROWS) {\n+    let val = if qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS) {\n         // Avoid autorefs as they would create global instead of stack\n         // references, even when only the latter are correct.\n         let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n@@ -774,7 +772,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n-                def::DefConst(def_id) => {\n+                def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n                     const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {"}, {"sha": "41ef566f2fd7f8e916c7af0039a62e28d91dc9c4", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -21,6 +21,7 @@ use trans::builder::Builder;\n use trans::common::{ExternMap,BuilderRef_res};\n use trans::debuginfo;\n use trans::declare;\n+use trans::glue::DropGlueKind;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n use middle::subst::Substs;\n@@ -73,7 +74,7 @@ pub struct SharedCrateContext<'tcx> {\n     check_drop_flag_for_sanity: bool,\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n-    available_drop_glues: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n+    available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -89,7 +90,7 @@ pub struct LocalCrateContext<'tcx> {\n     item_vals: RefCell<NodeMap<ValueRef>>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n+    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>>,\n     /// Track mapping of external ids to local items imported for inlining\n     external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n@@ -574,7 +575,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.fn_pointer_shims\n     }\n \n-    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n+    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>> {\n         &self.local.drop_glues\n     }\n \n@@ -660,7 +661,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.available_monomorphizations\n     }\n \n-    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n+    pub fn available_drop_glues(&self) -> &RefCell<FnvHashMap<DropGlueKind<'tcx>, String>> {\n         &self.shared.available_drop_glues\n     }\n \n@@ -734,6 +735,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n }\n \n+/// Declare any llvm intrinsics that you might need\n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => ("}, {"sha": "9af22b788b77beaf0160dfa8cabe2f5e82762937", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,514 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::metadata::file_metadata;\n+use super::utils::DIB;\n+\n+use llvm;\n+use llvm::debuginfo::{DIScope, DISubprogram};\n+use trans::common::CrateContext;\n+use middle::pat_util;\n+use util::nodemap::NodeMap;\n+\n+use libc::c_uint;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap, ast_util};\n+\n+// This procedure builds the *scope map* for a given function, which maps any\n+// given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n+//\n+// This builder procedure walks the AST in execution order and keeps track of\n+// what belongs to which scope, creating DIScope DIEs along the way, and\n+// introducing *artificial* lexical scope descriptors where necessary. These\n+// artificial scopes allow GDB to correctly handle name shadowing.\n+pub fn create_scope_map(cx: &CrateContext,\n+                        args: &[ast::Arg],\n+                        fn_entry_block: &ast::Block,\n+                        fn_metadata: DISubprogram,\n+                        fn_ast_id: ast::NodeId)\n+                        -> NodeMap<DIScope> {\n+    let mut scope_map = NodeMap();\n+\n+    let def_map = &cx.tcx().def_map;\n+\n+    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n+    scope_map.insert(fn_ast_id, fn_metadata);\n+\n+    // Push argument identifiers onto the stack so arguments integrate nicely\n+    // with variable shadowing.\n+    for arg in args {\n+        pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n+            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n+                                               name: Some(path1.node.name) });\n+            scope_map.insert(node_id, fn_metadata);\n+        })\n+    }\n+\n+    // Clang creates a separate scope for function bodies, so let's do this too.\n+    with_new_scope(cx,\n+                   fn_entry_block.span,\n+                   &mut scope_stack,\n+                   &mut scope_map,\n+                   |cx, scope_stack, scope_map| {\n+        walk_block(cx, fn_entry_block, scope_stack, scope_map);\n+    });\n+\n+    return scope_map;\n+}\n+\n+// local helper functions for walking the AST.\n+fn with_new_scope<F>(cx: &CrateContext,\n+                     scope_span: Span,\n+                     scope_stack: &mut Vec<ScopeStackEntry> ,\n+                     scope_map: &mut NodeMap<DIScope>,\n+                     inner_walk: F) where\n+    F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n+{\n+    // Create a new lexical scope and push it onto the stack\n+    let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+    let scope_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateLexicalBlock(\n+            DIB(cx),\n+            parent_scope,\n+            file_metadata,\n+            loc.line as c_uint,\n+            loc.col.to_usize() as c_uint)\n+    };\n+\n+    scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, name: None });\n+\n+    inner_walk(cx, scope_stack, scope_map);\n+\n+    // pop artificial scopes\n+    while scope_stack.last().unwrap().name.is_some() {\n+        scope_stack.pop();\n+    }\n+\n+    if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n+        cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+    }\n+\n+    scope_stack.pop();\n+}\n+\n+struct ScopeStackEntry {\n+    scope_metadata: DIScope,\n+    name: Option<ast::Name>\n+}\n+\n+fn walk_block(cx: &CrateContext,\n+              block: &ast::Block,\n+              scope_stack: &mut Vec<ScopeStackEntry> ,\n+              scope_map: &mut NodeMap<DIScope>) {\n+    scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n+\n+    // The interesting things here are statements and the concluding expression.\n+    for statement in &block.stmts {\n+        scope_map.insert(ast_util::stmt_id(&**statement),\n+                         scope_stack.last().unwrap().scope_metadata);\n+\n+        match statement.node {\n+            ast::StmtDecl(ref decl, _) =>\n+                walk_decl(cx, &**decl, scope_stack, scope_map),\n+            ast::StmtExpr(ref exp, _) |\n+            ast::StmtSemi(ref exp, _) =>\n+                walk_expr(cx, &**exp, scope_stack, scope_map),\n+            ast::StmtMac(..) => () // Ignore macros (which should be expanded anyway).\n+        }\n+    }\n+\n+    if let Some(ref exp) = block.expr {\n+        walk_expr(cx, &**exp, scope_stack, scope_map);\n+    }\n+}\n+\n+fn walk_decl(cx: &CrateContext,\n+             decl: &ast::Decl,\n+             scope_stack: &mut Vec<ScopeStackEntry> ,\n+             scope_map: &mut NodeMap<DIScope>) {\n+    match *decl {\n+        codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n+            scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n+\n+            if let Some(ref exp) = local.init {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n+fn walk_pattern(cx: &CrateContext,\n+                pat: &ast::Pat,\n+                scope_stack: &mut Vec<ScopeStackEntry> ,\n+                scope_map: &mut NodeMap<DIScope>) {\n+\n+    let def_map = &cx.tcx().def_map;\n+\n+    // Unfortunately, we cannot just use pat_util::pat_bindings() or\n+    // ast_util::walk_pat() here because we have to visit *all* nodes in\n+    // order to put them into the scope map. The above functions don't do that.\n+    match pat.node {\n+        ast::PatIdent(_, ref path1, ref sub_pat_opt) => {\n+\n+            // Check if this is a binding. If so we need to put it on the\n+            // scope stack and maybe introduce an artificial scope\n+            if pat_util::pat_is_binding(def_map, &*pat) {\n+\n+                let name = path1.node.name;\n+\n+                // LLVM does not properly generate 'DW_AT_start_scope' fields\n+                // for variable DIEs. For this reason we have to introduce\n+                // an artificial scope at bindings whenever a variable with\n+                // the same name is declared in *any* parent scope.\n+                //\n+                // Otherwise the following error occurs:\n+                //\n+                // let x = 10;\n+                //\n+                // do_something(); // 'gdb print x' correctly prints 10\n+                //\n+                // {\n+                //     do_something(); // 'gdb print x' prints 0, because it\n+                //                     // already reads the uninitialized 'x'\n+                //                     // from the next line...\n+                //     let x = 100;\n+                //     do_something(); // 'gdb print x' correctly prints 100\n+                // }\n+\n+                // Is there already a binding with that name?\n+                // N.B.: this comparison must be UNhygienic... because\n+                // gdb knows nothing about the context, so any two\n+                // variables with the same name will cause the problem.\n+                let need_new_scope = scope_stack\n+                    .iter()\n+                    .any(|entry| entry.name == Some(name));\n+\n+                if need_new_scope {\n+                    // Create a new lexical scope and push it onto the stack\n+                    let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n+                    let file_metadata = file_metadata(cx, &loc.file.name);\n+                    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+                    let scope_metadata = unsafe {\n+                        llvm::LLVMDIBuilderCreateLexicalBlock(\n+                            DIB(cx),\n+                            parent_scope,\n+                            file_metadata,\n+                            loc.line as c_uint,\n+                            loc.col.to_usize() as c_uint)\n+                    };\n+\n+                    scope_stack.push(ScopeStackEntry {\n+                        scope_metadata: scope_metadata,\n+                        name: Some(name)\n+                    });\n+\n+                } else {\n+                    // Push a new entry anyway so the name can be found\n+                    let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n+                    scope_stack.push(ScopeStackEntry {\n+                        scope_metadata: prev_metadata,\n+                        name: Some(name)\n+                    });\n+                }\n+            }\n+\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            if let Some(ref sub_pat) = *sub_pat_opt {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatWild(_) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+        }\n+\n+        ast::PatEnum(_, ref sub_pats_opt) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            if let Some(ref sub_pats) = *sub_pats_opt {\n+                for p in sub_pats {\n+                    walk_pattern(cx, &**p, scope_stack, scope_map);\n+                }\n+            }\n+        }\n+\n+        ast::PatQPath(..) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+        }\n+\n+        ast::PatStruct(_, ref field_pats, _) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for &codemap::Spanned {\n+                node: ast::FieldPat { pat: ref sub_pat, .. },\n+                ..\n+            } in field_pats.iter() {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatTup(ref sub_pats) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for sub_pat in sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat, _) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+        }\n+\n+        ast::PatLit(ref exp) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_expr(cx, &**exp, scope_stack, scope_map);\n+        }\n+\n+        ast::PatRange(ref exp1, ref exp2) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_expr(cx, &**exp1, scope_stack, scope_map);\n+            walk_expr(cx, &**exp2, scope_stack, scope_map);\n+        }\n+\n+        ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for sub_pat in front_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+\n+            if let Some(ref sub_pat) = *middle_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+\n+            for sub_pat in back_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatMac(_) => {\n+            cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded macro.\");\n+        }\n+    }\n+}\n+\n+fn walk_expr(cx: &CrateContext,\n+             exp: &ast::Expr,\n+             scope_stack: &mut Vec<ScopeStackEntry> ,\n+             scope_map: &mut NodeMap<DIScope>) {\n+\n+    scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n+\n+    match exp.node {\n+        ast::ExprLit(_)   |\n+        ast::ExprBreak(_) |\n+        ast::ExprAgain(_) |\n+        ast::ExprPath(..) => {}\n+\n+        ast::ExprCast(ref sub_exp, _)     |\n+        ast::ExprAddrOf(_, ref sub_exp)  |\n+        ast::ExprField(ref sub_exp, _) |\n+        ast::ExprTupField(ref sub_exp, _) |\n+        ast::ExprParen(ref sub_exp) =>\n+            walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+\n+        ast::ExprBox(ref place, ref sub_expr) => {\n+            place.as_ref().map(\n+                |e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprRet(ref exp_opt) => match *exp_opt {\n+            Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+            None => ()\n+        },\n+\n+        ast::ExprUnary(_, ref sub_exp) => {\n+            walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+        ast::ExprIndex(ref lhs, ref rhs) |\n+        ast::ExprBinary(_, ref lhs, ref rhs)    => {\n+            walk_expr(cx, &**lhs, scope_stack, scope_map);\n+            walk_expr(cx, &**rhs, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprRange(ref start, ref end) => {\n+            start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+        }\n+\n+        ast::ExprVec(ref init_expressions) |\n+        ast::ExprTup(ref init_expressions) => {\n+            for ie in init_expressions {\n+                walk_expr(cx, &**ie, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprAssign(ref sub_exp1, ref sub_exp2) |\n+        ast::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n+            walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n+            walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n+            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+            with_new_scope(cx,\n+                           then_block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**then_block, scope_stack, scope_map);\n+            });\n+\n+            match *opt_else_exp {\n+                Some(ref else_exp) =>\n+                    walk_expr(cx, &**else_exp, scope_stack, scope_map),\n+                _ => ()\n+            }\n+        }\n+\n+        ast::ExprIfLet(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded if-let.\");\n+        }\n+\n+        ast::ExprWhile(ref cond_exp, ref loop_body, _) => {\n+            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+            with_new_scope(cx,\n+                           loop_body.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**loop_body, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprWhileLet(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded while-let.\");\n+        }\n+\n+        ast::ExprForLoop(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded for loop.\");\n+        }\n+\n+        ast::ExprMac(_) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded macro.\");\n+        }\n+\n+        ast::ExprLoop(ref block, _) |\n+        ast::ExprBlock(ref block)   => {\n+            with_new_scope(cx,\n+                           block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**block, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprClosure(_, ref decl, ref block) => {\n+            with_new_scope(cx,\n+                           block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                for &ast::Arg { pat: ref pattern, .. } in &decl.inputs {\n+                    walk_pattern(cx, &**pattern, scope_stack, scope_map);\n+                }\n+\n+                walk_block(cx, &**block, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprCall(ref fn_exp, ref args) => {\n+            walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n+\n+            for arg_exp in args {\n+                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprMethodCall(_, _, ref args) => {\n+            for arg_exp in args {\n+                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprMatch(ref discriminant_exp, ref arms, _) => {\n+            walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n+\n+            // For each arm we have to first walk the pattern as these might\n+            // introduce new artificial scopes. It should be sufficient to\n+            // walk only one pattern per arm, as they all must contain the\n+            // same binding names.\n+\n+            for arm_ref in arms {\n+                let arm_span = arm_ref.pats[0].span;\n+\n+                with_new_scope(cx,\n+                               arm_span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n+                    for pat in &arm_ref.pats {\n+                        walk_pattern(cx, &**pat, scope_stack, scope_map);\n+                    }\n+\n+                    if let Some(ref guard_exp) = arm_ref.guard {\n+                        walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n+                    }\n+\n+                    walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n+                })\n+            }\n+        }\n+\n+        ast::ExprStruct(_, ref fields, ref base_exp) => {\n+            for &ast::Field { expr: ref exp, .. } in fields {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+\n+            match *base_exp {\n+                Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n+                None => ()\n+            }\n+        }\n+\n+        ast::ExprInlineAsm(ast::InlineAsm { ref inputs,\n+                                            ref outputs,\n+                                            .. }) => {\n+            // inputs, outputs: Vec<(String, P<Expr>)>\n+            for &(_, ref exp) in inputs {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+\n+            for &(_, ref exp, _) in outputs {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "a91619b2f845a437732a2d2e8dc3c4b5363d9d6f", "filename": "src/librustc_trans/trans/debuginfo/doc.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Debug Info Module\n+//!\n+//! This module serves the purpose of generating debug symbols. We use LLVM's\n+//! [source level debugging](http://!llvm.org/docs/SourceLevelDebugging.html)\n+//! features for generating the debug information. The general principle is\n+//! this:\n+//!\n+//! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n+//! create DWARF debug symbols for the given code. The\n+//! [metadata](http://!llvm.org/docs/LangRef.html#metadata-type) is structured\n+//! much like DWARF *debugging information entries* (DIE), representing type\n+//! information such as datatype layout, function signatures, block layout,\n+//! variable location and scope information, etc. It is the purpose of this\n+//! module to generate correct metadata and insert it into the LLVM IR.\n+//!\n+//! As the exact format of metadata trees may change between different LLVM\n+//! versions, we now use LLVM\n+//! [DIBuilder](http://!llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+//! to create metadata where possible. This will hopefully ease the adaption of\n+//! this module to future LLVM versions.\n+//!\n+//! The public API of the module is a set of functions that will insert the\n+//! correct metadata into the LLVM IR when called with the right parameters.\n+//! The module is thus driven from an outside client with functions like\n+//! `debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n+//!\n+//! Internally the module will try to reuse already created metadata by\n+//! utilizing a cache. The way to get a shared metadata node when needed is\n+//! thus to just call the corresponding function in this module:\n+//!\n+//!     let file_metadata = file_metadata(crate_context, path);\n+//!\n+//! The function will take care of probing the cache for an existing node for\n+//! that exact file path.\n+//!\n+//! All private state used by the module is stored within either the\n+//! CrateDebugContext struct (owned by the CrateContext) or the\n+//! FunctionDebugContext (owned by the FunctionContext).\n+//!\n+//! This file consists of three conceptual sections:\n+//! 1. The public interface of the module\n+//! 2. Module-internal metadata creation functions\n+//! 3. Minor utility functions\n+//!\n+//!\n+//! ## Recursive Types\n+//!\n+//! Some kinds of types, such as structs and enums can be recursive. That means\n+//! that the type definition of some type X refers to some other type which in\n+//! turn (transitively) refers to X. This introduces cycles into the type\n+//! referral graph. A naive algorithm doing an on-demand, depth-first traversal\n+//! of this graph when describing types, can get trapped in an endless loop\n+//! when it reaches such a cycle.\n+//!\n+//! For example, the following simple type for a singly-linked list...\n+//!\n+//! ```\n+//! struct List {\n+//!     value: int,\n+//!     tail: Option<Box<List>>,\n+//! }\n+//! ```\n+//!\n+//! will generate the following callstack with a naive DFS algorithm:\n+//!\n+//! ```\n+//! describe(t = List)\n+//!   describe(t = int)\n+//!   describe(t = Option<Box<List>>)\n+//!     describe(t = Box<List>)\n+//!       describe(t = List) // at the beginning again...\n+//!       ...\n+//! ```\n+//!\n+//! To break cycles like these, we use \"forward declarations\". That is, when\n+//! the algorithm encounters a possibly recursive type (any struct or enum), it\n+//! immediately creates a type description node and inserts it into the cache\n+//! *before* describing the members of the type. This type description is just\n+//! a stub (as type members are not described and added to it yet) but it\n+//! allows the algorithm to already refer to the type. After the stub is\n+//! inserted into the cache, the algorithm continues as before. If it now\n+//! encounters a recursive reference, it will hit the cache and does not try to\n+//! describe the type anew.\n+//!\n+//! This behaviour is encapsulated in the 'RecursiveTypeDescription' enum,\n+//! which represents a kind of continuation, storing all state needed to\n+//! continue traversal at the type members after the type has been registered\n+//! with the cache. (This implementation approach might be a tad over-\n+//! engineered and may change in the future)\n+//!\n+//!\n+//! ## Source Locations and Line Information\n+//!\n+//! In addition to data type descriptions the debugging information must also\n+//! allow to map machine code locations back to source code locations in order\n+//! to be useful. This functionality is also handled in this module. The\n+//! following functions allow to control source mappings:\n+//!\n+//! + set_source_location()\n+//! + clear_source_location()\n+//! + start_emitting_source_locations()\n+//!\n+//! `set_source_location()` allows to set the current source location. All IR\n+//! instructions created after a call to this function will be linked to the\n+//! given source location, until another location is specified with\n+//! `set_source_location()` or the source location is cleared with\n+//! `clear_source_location()`. In the later case, subsequent IR instruction\n+//! will not be linked to any source location. As you can see, this is a\n+//! stateful API (mimicking the one in LLVM), so be careful with source\n+//! locations set by previous calls. It's probably best to not rely on any\n+//! specific state being present at a given point in code.\n+//!\n+//! One topic that deserves some extra attention is *function prologues*. At\n+//! the beginning of a function's machine code there are typically a few\n+//! instructions for loading argument values into allocas and checking if\n+//! there's enough stack space for the function to execute. This *prologue* is\n+//! not visible in the source code and LLVM puts a special PROLOGUE END marker\n+//! into the line table at the first non-prologue instruction of the function.\n+//! In order to find out where the prologue ends, LLVM looks for the first\n+//! instruction in the function body that is linked to a source location. So,\n+//! when generating prologue instructions we have to make sure that we don't\n+//! emit source location information until the 'real' function body begins. For\n+//! this reason, source location emission is disabled by default for any new\n+//! function being translated and is only activated after a call to the third\n+//! function from the list above, `start_emitting_source_locations()`. This\n+//! function should be called right before regularly starting to translate the\n+//! top-level block of the given function.\n+//!\n+//! There is one exception to the above rule: `llvm.dbg.declare` instruction\n+//! must be linked to the source location of the variable being declared. For\n+//! function parameters these `llvm.dbg.declare` instructions typically occur\n+//! in the middle of the prologue, however, they are ignored by LLVM's prologue\n+//! detection. The `create_argument_metadata()` and related functions take care\n+//! of linking the `llvm.dbg.declare` instructions to the correct source\n+//! locations even while source location emission is still disabled, so there\n+//! is no need to do anything special with source location handling here.\n+//!\n+//! ## Unique Type Identification\n+//!\n+//! In order for link-time optimization to work properly, LLVM needs a unique\n+//! type identifier that tells it across compilation units which types are the\n+//! same as others. This type identifier is created by\n+//! TypeMap::get_unique_type_id_of_type() using the following algorithm:\n+//!\n+//! (1) Primitive types have their name as ID\n+//! (2) Structs, enums and traits have a multipart identifier\n+//!\n+//!     (1) The first part is the SVH (strict version hash) of the crate they\n+//!          wereoriginally defined in\n+//!\n+//!     (2) The second part is the ast::NodeId of the definition in their\n+//!          originalcrate\n+//!\n+//!     (3) The final part is a concatenation of the type IDs of their concrete\n+//!          typearguments if they are generic types.\n+//!\n+//! (3) Tuple-, pointer and function types are structurally identified, which\n+//!     means that they are equivalent if their component types are equivalent\n+//!     (i.e. (int, int) is the same regardless in which crate it is used).\n+//!\n+//! This algorithm also provides a stable ID for types that are defined in one\n+//! crate but instantiated from metadata within another crate. We just have to\n+//! take care to always map crate and node IDs back to the original crate\n+//! context.\n+//!\n+//! As a side-effect these unique type IDs also help to solve a problem arising\n+//! from lifetime parameters. Since lifetime parameters are completely omitted\n+//! in debuginfo, more than one `Ty` instance may map to the same debuginfo\n+//! type metadata, that is, some struct `Struct<'a>` may have N instantiations\n+//! with different concrete substitutions for `'a`, and thus there will be N\n+//! `Ty` instances for the type `Struct<'a>` even though it is not generic\n+//! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n+//! cheap identifier for type metadata---we have done this in the past, but it\n+//! led to unnecessary metadata duplication in the best case and LLVM\n+//! assertions in the worst. However, the unique type ID as described above\n+//! *can* be used as identifier. Since it is comparatively expensive to\n+//! construct, though, `ty::type_id()` is still used additionally as an\n+//! optimization for cases where the exact same type has been seen before\n+//! (which is most of the time)."}, {"sha": "a6f1199d0ffe7354997e18371da1e768a47626fc", "filename": "src/librustc_trans/trans/debuginfo/gdb.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// .debug_gdb_scripts binary section.\n+\n+use llvm;\n+use llvm::ValueRef;\n+\n+use trans::common::{C_bytes, CrateContext};\n+use trans::declare;\n+use trans::type_::Type;\n+use middle::ty::ClosureTyper;\n+use session::config::NoDebugInfo;\n+\n+use std::ffi::CString;\n+use std::ptr;\n+use syntax::attr;\n+\n+\n+/// Inserts a side-effect free instruction sequence that makes sure that the\n+/// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n+    if needs_gdb_debug_scripts_section(ccx) {\n+        let empty = CString::new(\"\").unwrap();\n+        let gdb_debug_scripts_section_global =\n+            get_or_insert_gdb_debug_scripts_section_global(ccx);\n+        unsafe {\n+            let volative_load_instruction =\n+                llvm::LLVMBuildLoad(ccx.raw_builder(),\n+                                    gdb_debug_scripts_section_global,\n+                                    empty.as_ptr());\n+            llvm::LLVMSetVolatile(volative_load_instruction, llvm::True);\n+        }\n+    }\n+}\n+\n+/// Allocates the global variable responsible for the .debug_gdb_scripts binary\n+/// section.\n+pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n+                                                  -> llvm::ValueRef {\n+    let section_var_name = \"__rustc_debug_gdb_scripts_section__\";\n+\n+    let section_var = unsafe {\n+        llvm::LLVMGetNamedGlobal(ccx.llmod(),\n+                                 section_var_name.as_ptr() as *const _)\n+    };\n+\n+    if section_var == ptr::null_mut() {\n+        let section_name = b\".debug_gdb_scripts\\0\";\n+        let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n+\n+        unsafe {\n+            let llvm_type = Type::array(&Type::i8(ccx),\n+                                        section_contents.len() as u64);\n+\n+            let section_var = declare::define_global(ccx, section_var_name,\n+                                                     llvm_type).unwrap_or_else(||{\n+                ccx.sess().bug(&format!(\"symbol `{}` is already defined\", section_var_name))\n+            });\n+            llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n+            llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n+            llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n+            llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n+            llvm::SetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n+            // This should make sure that the whole section is not larger than\n+            // the string it contains. Otherwise we get a warning from GDB.\n+            llvm::LLVMSetAlignment(section_var, 1);\n+            section_var\n+        }\n+    } else {\n+        section_var\n+    }\n+}\n+\n+pub fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n+    let omit_gdb_pretty_printer_section =\n+        attr::contains_name(&ccx.tcx()\n+                                .map\n+                                .krate()\n+                                .attrs,\n+                            \"omit_gdb_pretty_printer_section\");\n+\n+    !omit_gdb_pretty_printer_section &&\n+    !ccx.sess().target.target.options.is_like_osx &&\n+    !ccx.sess().target.target.options.is_like_windows &&\n+    ccx.sess().opts.debuginfo != NoDebugInfo\n+}"}, {"sha": "9ff69e7f9dd294c2f43ba57f0dd28130e4fee0c5", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "renamed", "additions": 1344, "deletions": 3306, "changes": 4650, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "previous_filename": "src/librustc_trans/trans/debuginfo.rs"}, {"sha": "e4312b669ad98d2cce97fbb5b57944cddb729033", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "added", "additions": 651, "deletions": 0, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,651 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See doc.rs for documentation.\n+mod doc;\n+\n+use self::VariableAccess::*;\n+use self::VariableKind::*;\n+\n+use self::utils::{DIB, span_start, assert_type_for_node_id, contains_nodebug_attribute,\n+                  create_DIArray, is_node_local_to_unit};\n+use self::namespace::{namespace_for_item, NamespaceTreeNode};\n+use self::type_names::compute_debuginfo_type_name;\n+use self::metadata::{type_metadata, file_metadata, scope_metadata, TypeMap, compile_unit_metadata};\n+use self::source_loc::InternalDebugLocation;\n+\n+use llvm;\n+use llvm::{ModuleRef, ContextRef, ValueRef};\n+use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n+                      DIDescriptor, FlagPrototyped};\n+use middle::subst::{self, Substs};\n+use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n+use trans;\n+use trans::monomorphize;\n+use middle::ty::{self, Ty, ClosureTyper};\n+use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n+use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n+\n+use libc::c_uint;\n+use std::cell::{Cell, RefCell};\n+use std::ffi::CString;\n+use std::ptr;\n+use std::rc::Rc;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap, ast_util, ast_map};\n+use syntax::parse::token::{self, special_idents};\n+\n+pub mod gdb;\n+mod utils;\n+mod namespace;\n+mod type_names;\n+mod metadata;\n+mod create_scope_map;\n+mod source_loc;\n+\n+pub use self::source_loc::set_source_location;\n+pub use self::source_loc::clear_source_location;\n+pub use self::source_loc::start_emitting_source_locations;\n+pub use self::source_loc::get_cleanup_debug_loc_for_ast_node;\n+pub use self::source_loc::with_source_location_override;\n+pub use self::metadata::create_match_binding_metadata;\n+pub use self::metadata::create_argument_metadata;\n+pub use self::metadata::create_captured_var_metadata;\n+pub use self::metadata::create_global_var_metadata;\n+pub use self::metadata::create_local_var_metadata;\n+\n+#[allow(non_upper_case_globals)]\n+const DW_TAG_auto_variable: c_uint = 0x100;\n+#[allow(non_upper_case_globals)]\n+const DW_TAG_arg_variable: c_uint = 0x101;\n+\n+/// A context object for maintaining all state needed by the debuginfo module.\n+pub struct CrateDebugContext<'tcx> {\n+    llcontext: ContextRef,\n+    builder: DIBuilderRef,\n+    current_debug_location: Cell<InternalDebugLocation>,\n+    created_files: RefCell<FnvHashMap<String, DIFile>>,\n+    created_enum_disr_types: RefCell<DefIdMap<DIType>>,\n+\n+    type_map: RefCell<TypeMap<'tcx>>,\n+    namespace_map: RefCell<FnvHashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n+\n+    // This collection is used to assert that composite types (structs, enums,\n+    // ...) have their members only set once:\n+    composite_types_completed: RefCell<FnvHashSet<DIType>>,\n+}\n+\n+impl<'tcx> CrateDebugContext<'tcx> {\n+    pub fn new(llmod: ModuleRef) -> CrateDebugContext<'tcx> {\n+        debug!(\"CrateDebugContext::new\");\n+        let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n+        // DIBuilder inherits context from the module, so we'd better use the same one\n+        let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n+        return CrateDebugContext {\n+            llcontext: llcontext,\n+            builder: builder,\n+            current_debug_location: Cell::new(InternalDebugLocation::UnknownLocation),\n+            created_files: RefCell::new(FnvHashMap()),\n+            created_enum_disr_types: RefCell::new(DefIdMap()),\n+            type_map: RefCell::new(TypeMap::new()),\n+            namespace_map: RefCell::new(FnvHashMap()),\n+            composite_types_completed: RefCell::new(FnvHashSet()),\n+        };\n+    }\n+}\n+\n+pub enum FunctionDebugContext {\n+    RegularContext(Box<FunctionDebugContextData>),\n+    DebugInfoDisabled,\n+    FunctionWithoutDebugInfo,\n+}\n+\n+impl FunctionDebugContext {\n+    fn get_ref<'a>(&'a self,\n+                   cx: &CrateContext,\n+                   span: Span)\n+                   -> &'a FunctionDebugContextData {\n+        match *self {\n+            FunctionDebugContext::RegularContext(box ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n+                cx.sess().span_bug(span,\n+                                   FunctionDebugContext::debuginfo_disabled_message());\n+            }\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+                cx.sess().span_bug(span,\n+                                   FunctionDebugContext::should_be_ignored_message());\n+            }\n+        }\n+    }\n+\n+    fn debuginfo_disabled_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext although debug info is disabled!\"\n+    }\n+\n+    fn should_be_ignored_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext for function that should be \\\n+         ignored by debug info!\"\n+    }\n+}\n+\n+struct FunctionDebugContextData {\n+    scope_map: RefCell<NodeMap<DIScope>>,\n+    fn_metadata: DISubprogram,\n+    argument_counter: Cell<usize>,\n+    source_locations_enabled: Cell<bool>,\n+    source_location_override: Cell<bool>,\n+}\n+\n+pub enum VariableAccess<'a> {\n+    // The llptr given is an alloca containing the variable's value\n+    DirectVariable { alloca: ValueRef },\n+    // The llptr given is an alloca containing the start of some pointer chain\n+    // leading to the variable's content.\n+    IndirectVariable { alloca: ValueRef, address_operations: &'a [i64] }\n+}\n+\n+pub enum VariableKind {\n+    ArgumentVariable(usize /*index*/),\n+    LocalVariable,\n+    CapturedVariable,\n+}\n+\n+/// Create any deferred debug metadata nodes\n+pub fn finalize(cx: &CrateContext) {\n+    if cx.dbg_cx().is_none() {\n+        return;\n+    }\n+\n+    debug!(\"finalize\");\n+    let _ = compile_unit_metadata(cx);\n+\n+    if gdb::needs_gdb_debug_scripts_section(cx) {\n+        // Add a .debug_gdb_scripts section to this compile-unit. This will\n+        // cause GDB to try and load the gdb_load_rust_pretty_printers.py file,\n+        // which activates the Rust pretty printers for binary this section is\n+        // contained in.\n+        gdb::get_or_insert_gdb_debug_scripts_section_global(cx);\n+    }\n+\n+    unsafe {\n+        llvm::LLVMDIBuilderFinalize(DIB(cx));\n+        llvm::LLVMDIBuilderDispose(DIB(cx));\n+        // Debuginfo generation in LLVM by default uses a higher\n+        // version of dwarf than OS X currently understands. We can\n+        // instruct LLVM to emit an older version of dwarf, however,\n+        // for OS X to understand. For more info see #11352\n+        // This can be overridden using --llvm-opts -dwarf-version,N.\n+        // Android has the same issue (#22398)\n+        if cx.sess().target.target.options.is_like_osx ||\n+           cx.sess().target.target.options.is_like_android {\n+            llvm::LLVMRustAddModuleFlag(cx.llmod(),\n+                                        \"Dwarf Version\\0\".as_ptr() as *const _,\n+                                        2)\n+        }\n+\n+        // Prevent bitcode readers from deleting the debug info.\n+        let ptr = \"Debug Info Version\\0\".as_ptr();\n+        llvm::LLVMRustAddModuleFlag(cx.llmod(), ptr as *const _,\n+                                    llvm::LLVMRustDebugMetadataVersion);\n+    };\n+}\n+\n+/// Creates the function-specific debug context.\n+///\n+/// Returns the FunctionDebugContext for the function which holds state needed\n+/// for debug info creation. The function may also return another variant of the\n+/// FunctionDebugContext enum which indicates why no debuginfo should be created\n+/// for the function.\n+pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                               fn_ast_id: ast::NodeId,\n+                                               param_substs: &Substs<'tcx>,\n+                                               llfn: ValueRef) -> FunctionDebugContext {\n+    if cx.sess().opts.debuginfo == NoDebugInfo {\n+        return FunctionDebugContext::DebugInfoDisabled;\n+    }\n+\n+    // Clear the debug location so we don't assign them in the function prelude.\n+    // Do this here already, in case we do an early exit from this function.\n+    source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+\n+    if fn_ast_id == ast::DUMMY_NODE_ID {\n+        // This is a function not linked to any source location, so don't\n+        // generate debuginfo for it.\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+    }\n+\n+    let empty_generics = ast_util::empty_generics();\n+\n+    let fnitem = cx.tcx().map.get(fn_ast_id);\n+\n+    let (name, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n+        ast_map::NodeItem(ref item) => {\n+            if contains_nodebug_attribute(&item.attrs) {\n+                return FunctionDebugContext::FunctionWithoutDebugInfo;\n+            }\n+\n+            match item.node {\n+                ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n+                    (item.ident.name, fn_decl, generics, top_level_block, item.span, true)\n+                }\n+                _ => {\n+                    cx.sess().span_bug(item.span,\n+                        \"create_function_debug_context: item bound to non-function\");\n+                }\n+            }\n+        }\n+        ast_map::NodeImplItem(impl_item) => {\n+            match impl_item.node {\n+                ast::MethodImplItem(ref sig, ref body) => {\n+                    if contains_nodebug_attribute(&impl_item.attrs) {\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                    }\n+\n+                    (impl_item.ident.name,\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n+                     impl_item.span,\n+                     true)\n+                }\n+                _ => {\n+                    cx.sess().span_bug(impl_item.span,\n+                                       \"create_function_debug_context() \\\n+                                        called on non-method impl item?!\")\n+                }\n+            }\n+        }\n+        ast_map::NodeExpr(ref expr) => {\n+            match expr.node {\n+                ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n+                    let name = format!(\"fn{}\", token::gensym(\"fn\"));\n+                    let name = token::intern(&name[..]);\n+                    (name, fn_decl,\n+                        // This is not quite right. It should actually inherit\n+                        // the generics of the enclosing function.\n+                        &empty_generics,\n+                        top_level_block,\n+                        expr.span,\n+                        // Don't try to lookup the item path:\n+                        false)\n+                }\n+                _ => cx.sess().span_bug(expr.span,\n+                        \"create_function_debug_context: expected an expr_fn_block here\")\n+            }\n+        }\n+        ast_map::NodeTraitItem(trait_item) => {\n+            match trait_item.node {\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    if contains_nodebug_attribute(&trait_item.attrs) {\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                    }\n+\n+                    (trait_item.ident.name,\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n+                     trait_item.span,\n+                     true)\n+                }\n+                _ => {\n+                    cx.sess()\n+                      .bug(&format!(\"create_function_debug_context: \\\n+                                    unexpected sort of node: {:?}\",\n+                                    fnitem))\n+                }\n+            }\n+        }\n+        ast_map::NodeForeignItem(..) |\n+        ast_map::NodeVariant(..) |\n+        ast_map::NodeStructCtor(..) => {\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        }\n+        _ => cx.sess().bug(&format!(\"create_function_debug_context: \\\n+                                    unexpected sort of node: {:?}\",\n+                                   fnitem))\n+    };\n+\n+    // This can be the case for functions inlined from another crate\n+    if span == codemap::DUMMY_SP {\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+    }\n+\n+    let loc = span_start(cx, span);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+\n+    let function_type_metadata = unsafe {\n+        let fn_signature = get_function_signature(cx,\n+                                                  fn_ast_id,\n+                                                  &*fn_decl,\n+                                                  param_substs,\n+                                                  span);\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n+    };\n+\n+    // Get_template_parameters() will append a `<...>` clause to the function\n+    // name if necessary.\n+    let mut function_name = String::from_str(&token::get_name(name));\n+    let template_parameters = get_template_parameters(cx,\n+                                                      generics,\n+                                                      param_substs,\n+                                                      file_metadata,\n+                                                      &mut function_name);\n+\n+    // There is no ast_map::Path for ast::ExprClosure-type functions. For now,\n+    // just don't put them into a namespace. In the future this could be improved\n+    // somehow (storing a path in the ast_map, or construct a path using the\n+    // enclosing function).\n+    let (linkage_name, containing_scope) = if has_path {\n+        let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n+        let linkage_name = namespace_node.mangled_name_of_contained_item(\n+            &function_name[..]);\n+        let containing_scope = namespace_node.scope;\n+        (linkage_name, containing_scope)\n+    } else {\n+        (function_name.clone(), file_metadata)\n+    };\n+\n+    // Clang sets this parameter to the opening brace of the function's block,\n+    // so let's do this too.\n+    let scope_line = span_start(cx, top_level_block.span).line;\n+\n+    let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n+\n+    let function_name = CString::new(function_name).unwrap();\n+    let linkage_name = CString::new(linkage_name).unwrap();\n+    let fn_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateFunction(\n+            DIB(cx),\n+            containing_scope,\n+            function_name.as_ptr(),\n+            linkage_name.as_ptr(),\n+            file_metadata,\n+            loc.line as c_uint,\n+            function_type_metadata,\n+            is_local_to_unit,\n+            true,\n+            scope_line as c_uint,\n+            FlagPrototyped as c_uint,\n+            cx.sess().opts.optimize != config::No,\n+            llfn,\n+            template_parameters,\n+            ptr::null_mut())\n+    };\n+\n+    let scope_map = create_scope_map::create_scope_map(cx,\n+                                                       &fn_decl.inputs,\n+                                                       &*top_level_block,\n+                                                       fn_metadata,\n+                                                       fn_ast_id);\n+\n+    // Initialize fn debug context (including scope map and namespace map)\n+    let fn_debug_context = box FunctionDebugContextData {\n+        scope_map: RefCell::new(scope_map),\n+        fn_metadata: fn_metadata,\n+        argument_counter: Cell::new(1),\n+        source_locations_enabled: Cell::new(false),\n+        source_location_override: Cell::new(false),\n+    };\n+\n+\n+\n+    return FunctionDebugContext::RegularContext(fn_debug_context);\n+\n+    fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                        fn_ast_id: ast::NodeId,\n+                                        fn_decl: &ast::FnDecl,\n+                                        param_substs: &Substs<'tcx>,\n+                                        error_reporting_span: Span) -> DIArray {\n+        if cx.sess().opts.debuginfo == LimitedDebugInfo {\n+            return create_DIArray(DIB(cx), &[]);\n+        }\n+\n+        let mut signature = Vec::with_capacity(fn_decl.inputs.len() + 1);\n+\n+        // Return type -- llvm::DIBuilder wants this at index 0\n+        assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n+        let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n+        let return_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                           param_substs,\n+                                                           &return_type);\n+        if ty::type_is_nil(return_type) {\n+            signature.push(ptr::null_mut())\n+        } else {\n+            signature.push(type_metadata(cx, return_type, codemap::DUMMY_SP));\n+        }\n+\n+        // Arguments types\n+        for arg in &fn_decl.inputs {\n+            assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n+            let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n+            let arg_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                            param_substs,\n+                                                            &arg_type);\n+            signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n+        }\n+\n+        return create_DIArray(DIB(cx), &signature[..]);\n+    }\n+\n+    fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                         generics: &ast::Generics,\n+                                         param_substs: &Substs<'tcx>,\n+                                         file_metadata: DIFile,\n+                                         name_to_append_suffix_to: &mut String)\n+                                         -> DIArray\n+    {\n+        let self_type = param_substs.self_ty();\n+        let self_type = monomorphize::normalize_associated_type(cx.tcx(), &self_type);\n+\n+        // Only true for static default methods:\n+        let has_self_type = self_type.is_some();\n+\n+        if !generics.is_type_parameterized() && !has_self_type {\n+            return create_DIArray(DIB(cx), &[]);\n+        }\n+\n+        name_to_append_suffix_to.push('<');\n+\n+        // The list to be filled with template parameters:\n+        let mut template_params: Vec<DIDescriptor> =\n+            Vec::with_capacity(generics.ty_params.len() + 1);\n+\n+        // Handle self type\n+        if has_self_type {\n+            let actual_self_type = self_type.unwrap();\n+            // Add self type name to <...> clause of function name\n+            let actual_self_type_name = compute_debuginfo_type_name(\n+                cx,\n+                actual_self_type,\n+                true);\n+\n+            name_to_append_suffix_to.push_str(&actual_self_type_name[..]);\n+\n+            if generics.is_type_parameterized() {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n+            // Only create type information if full debuginfo is enabled\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n+                let actual_self_type_metadata = type_metadata(cx,\n+                                                              actual_self_type,\n+                                                              codemap::DUMMY_SP);\n+\n+                let name = token::get_name(special_idents::type_self.name);\n+\n+                let name = CString::new(name.as_bytes()).unwrap();\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_self_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n+\n+                template_params.push(param_metadata);\n+            }\n+        }\n+\n+        // Handle other generic parameters\n+        let actual_types = param_substs.types.get_slice(subst::FnSpace);\n+        for (index, &ast::TyParam{ ident, .. }) in generics.ty_params.iter().enumerate() {\n+            let actual_type = actual_types[index];\n+            // Add actual type name to <...> clause of function name\n+            let actual_type_name = compute_debuginfo_type_name(cx,\n+                                                               actual_type,\n+                                                               true);\n+            name_to_append_suffix_to.push_str(&actual_type_name[..]);\n+\n+            if index != generics.ty_params.len() - 1 {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n+            // Again, only create type information if full debuginfo is enabled\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n+                let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n+                let ident = token::get_ident(ident);\n+                let name = CString::new(ident.as_bytes()).unwrap();\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n+                template_params.push(param_metadata);\n+            }\n+        }\n+\n+        name_to_append_suffix_to.push('>');\n+\n+        return create_DIArray(DIB(cx), &template_params[..]);\n+    }\n+}\n+\n+fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             variable_name: ast::Name,\n+                             variable_type: Ty<'tcx>,\n+                             scope_metadata: DIScope,\n+                             variable_access: VariableAccess,\n+                             variable_kind: VariableKind,\n+                             span: Span) {\n+    let cx: &CrateContext = bcx.ccx();\n+\n+    let filename = span_start(cx, span).file.name.clone();\n+    let file_metadata = file_metadata(cx, &filename[..]);\n+\n+    let name = token::get_name(variable_name);\n+    let loc = span_start(cx, span);\n+    let type_metadata = type_metadata(cx, variable_type, span);\n+\n+    let (argument_index, dwarf_tag) = match variable_kind {\n+        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n+        LocalVariable    |\n+        CapturedVariable => (0, DW_TAG_auto_variable)\n+    };\n+\n+    let name = CString::new(name.as_bytes()).unwrap();\n+    match (variable_access, &[][..]) {\n+        (DirectVariable { alloca }, address_operations) |\n+        (IndirectVariable {alloca, address_operations}, _) => {\n+            let metadata = unsafe {\n+                llvm::LLVMDIBuilderCreateVariable(\n+                    DIB(cx),\n+                    dwarf_tag,\n+                    scope_metadata,\n+                    name.as_ptr(),\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    cx.sess().opts.optimize != config::No,\n+                    0,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    argument_index)\n+            };\n+            source_loc::set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n+                                                                          loc.line,\n+                                                                          loc.col.to_usize()));\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                    DIB(cx),\n+                    alloca,\n+                    metadata,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    bcx.llbb);\n+\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+            }\n+        }\n+    }\n+\n+    match variable_kind {\n+        ArgumentVariable(_) | CapturedVariable => {\n+            assert!(!bcx.fcx\n+                        .debug_context\n+                        .get_ref(cx, span)\n+                        .source_locations_enabled\n+                        .get());\n+            source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+        }\n+        _ => { /* nothing to do */ }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum DebugLoc {\n+    At(ast::NodeId, Span),\n+    None\n+}\n+\n+impl DebugLoc {\n+    pub fn apply(&self, fcx: &FunctionContext) {\n+        match *self {\n+            DebugLoc::At(node_id, span) => {\n+                source_loc::set_source_location(fcx, node_id, span);\n+            }\n+            DebugLoc::None => {\n+                source_loc::clear_source_location(fcx);\n+            }\n+        }\n+    }\n+}\n+\n+pub trait ToDebugLoc {\n+    fn debug_loc(&self) -> DebugLoc;\n+}\n+\n+impl ToDebugLoc for ast::Expr {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for NodeIdAndSpan {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for Option<NodeIdAndSpan> {\n+    fn debug_loc(&self) -> DebugLoc {\n+        match *self {\n+            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n+            None => DebugLoc::None\n+        }\n+    }\n+}"}, {"sha": "0aa0408c0ef33c31a89fd1566901207dfa7b56cb", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Namespace Handling.\n+\n+use super::utils::{DIB, debug_context};\n+\n+use llvm;\n+use llvm::debuginfo::DIScope;\n+use trans::common::CrateContext;\n+use middle::ty::{self, ClosureTyper};\n+\n+use std::ffi::CString;\n+use std::ptr;\n+use std::rc::{Rc, Weak};\n+use syntax::{ast, ast_map};\n+use syntax::parse::token;\n+\n+pub struct NamespaceTreeNode {\n+    pub name: ast::Name,\n+    pub scope: DIScope,\n+    pub parent: Option<Weak<NamespaceTreeNode>>,\n+}\n+\n+impl NamespaceTreeNode {\n+    pub fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n+        fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n+            match node.parent {\n+                Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n+                None => {}\n+            }\n+            let string = token::get_name(node.name);\n+            output.push_str(&format!(\"{}\", string.len()));\n+            output.push_str(&string);\n+        }\n+\n+        let mut name = String::from_str(\"_ZN\");\n+        fill_nested(self, &mut name);\n+        name.push_str(&format!(\"{}\", item_name.len()));\n+        name.push_str(item_name);\n+        name.push('E');\n+        name\n+    }\n+}\n+\n+pub fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n+    &cx.link_meta().crate_name\n+}\n+\n+pub fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n+    ty::with_path(cx.tcx(), def_id, |path| {\n+        // prepend crate name if not already present\n+        let krate = if def_id.krate == ast::LOCAL_CRATE {\n+            let crate_namespace_name = token::intern(crate_root_namespace(cx));\n+            Some(ast_map::PathMod(crate_namespace_name))\n+        } else {\n+            None\n+        };\n+        let mut path = krate.into_iter().chain(path).peekable();\n+\n+        let mut current_key = Vec::new();\n+        let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n+\n+        // Create/Lookup namespace for each element of the path.\n+        loop {\n+            // Emulate a for loop so we can use peek below.\n+            let path_element = match path.next() {\n+                Some(e) => e,\n+                None => break\n+            };\n+            // Ignore the name of the item (the last path element).\n+            if path.peek().is_none() {\n+                break;\n+            }\n+\n+            let name = path_element.name();\n+            current_key.push(name);\n+\n+            let existing_node = debug_context(cx).namespace_map.borrow()\n+                                                 .get(&current_key).cloned();\n+            let current_node = match existing_node {\n+                Some(existing_node) => existing_node,\n+                None => {\n+                    // create and insert\n+                    let parent_scope = match parent_node {\n+                        Some(ref node) => node.scope,\n+                        None => ptr::null_mut()\n+                    };\n+                    let namespace_name = token::get_name(name);\n+                    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n+                    let scope = unsafe {\n+                        llvm::LLVMDIBuilderCreateNameSpace(\n+                            DIB(cx),\n+                            parent_scope,\n+                            namespace_name.as_ptr(),\n+                            // cannot reconstruct file ...\n+                            ptr::null_mut(),\n+                            // ... or line information, but that's not so important.\n+                            0)\n+                    };\n+\n+                    let node = Rc::new(NamespaceTreeNode {\n+                        name: name,\n+                        scope: scope,\n+                        parent: parent_node.map(|parent| parent.downgrade()),\n+                    });\n+\n+                    debug_context(cx).namespace_map.borrow_mut()\n+                                     .insert(current_key.clone(), node.clone());\n+\n+                    node\n+                }\n+            };\n+\n+            parent_node = Some(current_node);\n+        }\n+\n+        match parent_node {\n+            Some(node) => node,\n+            None => {\n+                cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n+                                       path too short for {:?}\",\n+                                      def_id));\n+            }\n+        }\n+    })\n+}"}, {"sha": "981a23fd664a91380c3376c9b3c55738d9d9caf0", "filename": "src/librustc_trans/trans/debuginfo/source_loc.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::InternalDebugLocation::*;\n+\n+use super::utils::{debug_context, span_start, fn_should_be_ignored};\n+use super::metadata::{scope_metadata,UNKNOWN_COLUMN_NUMBER};\n+use super::{FunctionDebugContext, DebugLoc};\n+\n+use llvm;\n+use llvm::debuginfo::DIScope;\n+use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext};\n+\n+use libc::c_uint;\n+use std::ptr;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap};\n+\n+pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                                    node_id: ast::NodeId,\n+                                                    node_span: Span,\n+                                                    is_block: bool)\n+                                                 -> NodeIdAndSpan {\n+    // A debug location needs two things:\n+    // (1) A span (of which only the beginning will actually be used)\n+    // (2) An AST node-id which will be used to look up the lexical scope\n+    //     for the location in the functions scope-map\n+    //\n+    // This function will calculate the debug location for compiler-generated\n+    // cleanup calls that are executed when control-flow leaves the\n+    // scope identified by `node_id`.\n+    //\n+    // For everything but block-like things we can simply take id and span of\n+    // the given expression, meaning that from a debugger's view cleanup code is\n+    // executed at the same source location as the statement/expr itself.\n+    //\n+    // Blocks are a special case. Here we want the cleanup to be linked to the\n+    // closing curly brace of the block. The *scope* the cleanup is executed in\n+    // is up to debate: It could either still be *within* the block being\n+    // cleaned up, meaning that locals from the block are still visible in the\n+    // debugger.\n+    // Or it could be in the scope that the block is contained in, so any locals\n+    // from within the block are already considered out-of-scope and thus not\n+    // accessible in the debugger anymore.\n+    //\n+    // The current implementation opts for the second option: cleanup of a block\n+    // already happens in the parent scope of the block. The main reason for\n+    // this decision is that scoping becomes controlflow dependent when variable\n+    // shadowing is involved and it's impossible to decide statically which\n+    // scope is actually left when the cleanup code is executed.\n+    // In practice it shouldn't make much of a difference.\n+\n+    let mut cleanup_span = node_span;\n+\n+    if is_block {\n+        // Not all blocks actually have curly braces (e.g. simple closure\n+        // bodies), in which case we also just want to return the span of the\n+        // whole expression.\n+        let code_snippet = cx.sess().codemap().span_to_snippet(node_span);\n+        if let Ok(code_snippet) = code_snippet {\n+            let bytes = code_snippet.as_bytes();\n+\n+            if !bytes.is_empty() && &bytes[bytes.len()-1..] == b\"}\" {\n+                cleanup_span = Span {\n+                    lo: node_span.hi - codemap::BytePos(1),\n+                    hi: node_span.hi,\n+                    expn_id: node_span.expn_id\n+                };\n+            }\n+        }\n+    }\n+\n+    NodeIdAndSpan {\n+        id: node_id,\n+        span: cleanup_span\n+    }\n+}\n+\n+\n+/// Sets the current debug location at the beginning of the span.\n+///\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n+/// parameter is used to reliably find the correct visibility scope for the code\n+/// position.\n+pub fn set_source_location(fcx: &FunctionContext,\n+                           node_id: ast::NodeId,\n+                           span: Span) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => return,\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            set_debug_location(fcx.ccx, UnknownLocation);\n+            return;\n+        }\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+            if function_debug_context.source_location_override.get() {\n+                // Just ignore any attempts to set a new debug location while\n+                // the override is active.\n+                return;\n+            }\n+\n+            let cx = fcx.ccx;\n+\n+            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n+\n+            if function_debug_context.source_locations_enabled.get() {\n+                let loc = span_start(cx, span);\n+                let scope = scope_metadata(fcx, node_id, span);\n+\n+                set_debug_location(cx, InternalDebugLocation::new(scope,\n+                                                                  loc.line,\n+                                                                  loc.col.to_usize()));\n+            } else {\n+                set_debug_location(cx, UnknownLocation);\n+            }\n+        }\n+    }\n+}\n+\n+/// This function makes sure that all debug locations emitted while executing\n+/// `wrapped_function` are set to the given `debug_loc`.\n+pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n+                                           debug_loc: DebugLoc,\n+                                           wrapped_function: F) -> R\n+    where F: FnOnce() -> R\n+{\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => {\n+            wrapped_function()\n+        }\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            set_debug_location(fcx.ccx, UnknownLocation);\n+            wrapped_function()\n+        }\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+            if function_debug_context.source_location_override.get() {\n+                wrapped_function()\n+            } else {\n+                debug_loc.apply(fcx);\n+                function_debug_context.source_location_override.set(true);\n+                let result = wrapped_function();\n+                function_debug_context.source_location_override.set(false);\n+                result\n+            }\n+        }\n+    }\n+}\n+\n+/// Clears the current debug location.\n+///\n+/// Instructions generated hereafter won't be assigned a source location.\n+pub fn clear_source_location(fcx: &FunctionContext) {\n+    if fn_should_be_ignored(fcx) {\n+        return;\n+    }\n+\n+    set_debug_location(fcx.ccx, UnknownLocation);\n+}\n+\n+/// Enables emitting source locations for the given functions.\n+///\n+/// Since we don't want source locations to be emitted for the function prelude,\n+/// they are disabled when beginning to translate a new function. This functions\n+/// switches source location emitting on and must therefore be called before the\n+/// first real statement/expression of the function is translated.\n+pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n+            data.source_locations_enabled.set(true)\n+        },\n+        _ => { /* safe to ignore */ }\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum InternalDebugLocation {\n+    KnownLocation { scope: DIScope, line: usize, col: usize },\n+    UnknownLocation\n+}\n+\n+impl InternalDebugLocation {\n+    pub fn new(scope: DIScope, line: usize, col: usize) -> InternalDebugLocation {\n+        KnownLocation {\n+            scope: scope,\n+            line: line,\n+            col: col,\n+        }\n+    }\n+}\n+\n+pub fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n+    if debug_location == debug_context(cx).current_debug_location.get() {\n+        return;\n+    }\n+\n+    let metadata_node;\n+\n+    match debug_location {\n+        KnownLocation { scope, line, .. } => {\n+            // Always set the column to zero like Clang and GCC\n+            let col = UNKNOWN_COLUMN_NUMBER;\n+            debug!(\"setting debug location to {} {}\", line, col);\n+\n+            unsafe {\n+                metadata_node = llvm::LLVMDIBuilderCreateDebugLocation(\n+                    debug_context(cx).llcontext,\n+                    line as c_uint,\n+                    col as c_uint,\n+                    scope,\n+                    ptr::null_mut());\n+            }\n+        }\n+        UnknownLocation => {\n+            debug!(\"clearing debug location \");\n+            metadata_node = ptr::null_mut();\n+        }\n+    };\n+\n+    unsafe {\n+        llvm::LLVMSetCurrentDebugLocation(cx.raw_builder(), metadata_node);\n+    }\n+\n+    debug_context(cx).current_debug_location.set(debug_location);\n+}"}, {"sha": "2d0003d93a5d25a8a63e332fc42418331e8973a8", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Type Names for Debug Info.\n+\n+use super::namespace::crate_root_namespace;\n+\n+use trans::common::CrateContext;\n+use middle::subst::{self, Substs};\n+use middle::ty::{self, Ty, ClosureTyper};\n+use syntax::ast;\n+use syntax::parse::token;\n+use util::ppaux;\n+\n+\n+// Compute the name of the type as it should be stored in debuginfo. Does not do\n+// any caching, i.e. calling the function twice with the same type will also do\n+// the work twice. The `qualified` parameter only affects the first level of the\n+// type name, further levels (i.e. type parameters) are always fully qualified.\n+pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                             t: Ty<'tcx>,\n+                                             qualified: bool)\n+                                             -> String {\n+    let mut result = String::with_capacity(64);\n+    push_debuginfo_type_name(cx, t, qualified, &mut result);\n+    result\n+}\n+\n+// Pushes the name of the type as it should be stored in debuginfo on the\n+// `output` String. See also compute_debuginfo_type_name().\n+pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                          t: Ty<'tcx>,\n+                                          qualified: bool,\n+                                          output: &mut String) {\n+    match t.sty {\n+        ty::ty_bool              => output.push_str(\"bool\"),\n+        ty::ty_char              => output.push_str(\"char\"),\n+        ty::ty_str               => output.push_str(\"str\"),\n+        ty::ty_int(ast::TyIs)     => output.push_str(\"isize\"),\n+        ty::ty_int(ast::TyI8)    => output.push_str(\"i8\"),\n+        ty::ty_int(ast::TyI16)   => output.push_str(\"i16\"),\n+        ty::ty_int(ast::TyI32)   => output.push_str(\"i32\"),\n+        ty::ty_int(ast::TyI64)   => output.push_str(\"i64\"),\n+        ty::ty_uint(ast::TyUs)    => output.push_str(\"usize\"),\n+        ty::ty_uint(ast::TyU8)   => output.push_str(\"u8\"),\n+        ty::ty_uint(ast::TyU16)  => output.push_str(\"u16\"),\n+        ty::ty_uint(ast::TyU32)  => output.push_str(\"u32\"),\n+        ty::ty_uint(ast::TyU64)  => output.push_str(\"u64\"),\n+        ty::ty_float(ast::TyF32) => output.push_str(\"f32\"),\n+        ty::ty_float(ast::TyF64) => output.push_str(\"f64\"),\n+        ty::ty_struct(def_id, substs) |\n+        ty::ty_enum(def_id, substs) => {\n+            push_item_name(cx, def_id, qualified, output);\n+            push_type_params(cx, substs, output);\n+        },\n+        ty::ty_tup(ref component_types) => {\n+            output.push('(');\n+            for &component_type in component_types {\n+                push_debuginfo_type_name(cx, component_type, true, output);\n+                output.push_str(\", \");\n+            }\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n+            output.push(')');\n+        },\n+        ty::ty_uniq(inner_type) => {\n+            output.push_str(\"Box<\");\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+            output.push('>');\n+        },\n+        ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n+            output.push('*');\n+            match mutbl {\n+                ast::MutImmutable => output.push_str(\"const \"),\n+                ast::MutMutable => output.push_str(\"mut \"),\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n+            output.push('&');\n+            if mutbl == ast::MutMutable {\n+                output.push_str(\"mut \");\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_vec(inner_type, optional_length) => {\n+            output.push('[');\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+\n+            match optional_length {\n+                Some(len) => {\n+                    output.push_str(&format!(\"; {}\", len));\n+                }\n+                None => { /* nothing to do */ }\n+            };\n+\n+            output.push(']');\n+        },\n+        ty::ty_trait(ref trait_data) => {\n+            let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n+            push_item_name(cx, principal.def_id, false, output);\n+            push_type_params(cx, principal.substs, output);\n+        },\n+        ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            if unsafety == ast::Unsafety::Unsafe {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if abi != ::syntax::abi::Rust {\n+                output.push_str(\"extern \\\"\");\n+                output.push_str(abi.name());\n+                output.push_str(\"\\\" \");\n+            }\n+\n+            output.push_str(\"fn(\");\n+\n+            let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+            if !sig.inputs.is_empty() {\n+                for &parameter_type in &sig.inputs {\n+                    push_debuginfo_type_name(cx, parameter_type, true, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop();\n+                output.pop();\n+            }\n+\n+            if sig.variadic {\n+                if !sig.inputs.is_empty() {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push(')');\n+\n+            match sig.output {\n+                ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_debuginfo_type_name(cx, result_type, true, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n+            }\n+        },\n+        ty::ty_closure(..) => {\n+            output.push_str(\"closure\");\n+        }\n+        ty::ty_err |\n+        ty::ty_infer(_) |\n+        ty::ty_projection(..) |\n+        ty::ty_param(_) => {\n+            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)));\n+        }\n+    }\n+\n+    fn push_item_name(cx: &CrateContext,\n+                      def_id: ast::DefId,\n+                      qualified: bool,\n+                      output: &mut String) {\n+        ty::with_path(cx.tcx(), def_id, |path| {\n+            if qualified {\n+                if def_id.krate == ast::LOCAL_CRATE {\n+                    output.push_str(crate_root_namespace(cx));\n+                    output.push_str(\"::\");\n+                }\n+\n+                let mut path_element_count = 0;\n+                for path_element in path {\n+                    let name = token::get_name(path_element.name());\n+                    output.push_str(&name);\n+                    output.push_str(\"::\");\n+                    path_element_count += 1;\n+                }\n+\n+                if path_element_count == 0 {\n+                    cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n+                }\n+\n+                output.pop();\n+                output.pop();\n+            } else {\n+                let name = token::get_name(path.last()\n+                                               .expect(\"debuginfo: Empty item path?\")\n+                                               .name());\n+                output.push_str(&name);\n+            }\n+        });\n+    }\n+\n+    // Pushes the type parameters in the given `Substs` to the output string.\n+    // This ignores region parameters, since they can't reliably be\n+    // reconstructed for items from non-local crates. For local crates, this\n+    // would be possible but with inlining and LTO we have to use the least\n+    // common denominator - otherwise we would run into conflicts.\n+    fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                  substs: &subst::Substs<'tcx>,\n+                                  output: &mut String) {\n+        if substs.types.is_empty() {\n+            return;\n+        }\n+\n+        output.push('<');\n+\n+        for &type_parameter in substs.types.iter() {\n+            push_debuginfo_type_name(cx, type_parameter, true, output);\n+            output.push_str(\", \");\n+        }\n+\n+        output.pop();\n+        output.pop();\n+\n+        output.push('>');\n+    }\n+}\n+"}, {"sha": "0c12f6ed095f1b9a36b648053a8dae0fa7e1363b", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Utility Functions.\n+\n+use super::{FunctionDebugContext, CrateDebugContext};\n+use super::namespace::namespace_for_item;\n+\n+use llvm;\n+use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n+use trans::machine;\n+use trans::common::{CrateContext, FunctionContext};\n+use trans::type_::Type;\n+\n+use syntax::codemap::Span;\n+use syntax::{ast, codemap};\n+\n+pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n+{\n+    // The is_local_to_unit flag indicates whether a function is local to the\n+    // current compilation unit (i.e. if it is *static* in the C-sense). The\n+    // *reachable* set should provide a good approximation of this, as it\n+    // contains everything that might leak out of the current crate (by being\n+    // externally visible or by being inlined into something externally\n+    // visible). It might better to use the `exported_items` set from\n+    // `driver::CrateAnalysis` in the future, but (atm) this set is not\n+    // available in the translation pass.\n+    !cx.reachable().contains(&node_id)\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n+    return unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n+    };\n+}\n+\n+pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n+    attributes.iter().any(|attr| {\n+        let meta_item: &ast::MetaItem = &*attr.node.value;\n+        match meta_item.node {\n+            ast::MetaWord(ref value) => &value[..] == \"no_debug\",\n+            _ => false\n+        }\n+    })\n+}\n+\n+/// Return codemap::Loc corresponding to the beginning of the span\n+pub fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n+    cx.sess().codemap().lookup_char_pos(span.lo)\n+}\n+\n+pub fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n+    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type) as u64)\n+}\n+\n+pub fn bytes_to_bits(bytes: u64) -> u64 {\n+    bytes * 8\n+}\n+\n+#[inline]\n+pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n+                           -> &'a CrateDebugContext<'tcx> {\n+    let debug_context: &'a CrateDebugContext<'tcx> = cx.dbg_cx().as_ref().unwrap();\n+    debug_context\n+}\n+\n+#[inline]\n+#[allow(non_snake_case)]\n+pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+    cx.dbg_cx().as_ref().unwrap().builder\n+}\n+\n+pub fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(_) => false,\n+        _ => true\n+    }\n+}\n+\n+pub fn assert_type_for_node_id(cx: &CrateContext,\n+                           node_id: ast::NodeId,\n+                           error_reporting_span: Span) {\n+    if !cx.tcx().node_types().contains_key(&node_id) {\n+        cx.sess().span_bug(error_reporting_span,\n+                           \"debuginfo: Could not find type for node id!\");\n+    }\n+}\n+\n+pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n+                                   -> (DIScope, Span) {\n+    let containing_scope = namespace_for_item(cx, def_id).scope;\n+    let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n+        cx.tcx().map.span(def_id.node)\n+    } else {\n+        // For external items there is no span information\n+        codemap::DUMMY_SP\n+    };\n+\n+    (containing_scope, definition_span)\n+}"}, {"sha": "35946491ba17693f99d66b4d1aca6d87b6c78c10", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -71,12 +71,12 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n     llvm::SetUnnamedAddr(llfn, true);\n \n     if output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute);\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturnAttribute);\n     }\n \n     if ccx.tcx().sess.opts.cg.no_redzone\n         .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoRedZoneAttribute)\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZoneAttribute)\n     }\n \n     if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {"}, {"sha": "f5ee44d69cc6353b1cf8e66d29eb89d59f289dc3", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -126,8 +126,11 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n-        if !qualif.intersects(check_const::PREFER_IN_PLACE) {\n+    if !qualif.intersects(\n+        check_const::ConstQualif::NOT_CONST |\n+        check_const::ConstQualif::NEEDS_DROP\n+    ) {\n+        if !qualif.intersects(check_const::ConstQualif::PREFER_IN_PLACE) {\n             if let SaveIn(lldest) = dest {\n                 let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n                                                             bcx.fcx.param_substs);\n@@ -209,12 +212,15 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n     let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    let adjusted_global = !qualif.intersects(check_const::NON_STATIC_BORROWS);\n-    let global = if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n+    let adjusted_global = !qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS);\n+    let global = if !qualif.intersects(\n+        check_const::ConstQualif::NOT_CONST |\n+        check_const::ConstQualif::NEEDS_DROP\n+    ) {\n         let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n                                                       bcx.fcx.param_substs);\n \n-        if qualif.intersects(check_const::HAS_STATIC_BORROWS) {\n+        if qualif.intersects(check_const::ConstQualif::HAS_STATIC_BORROWS) {\n             // Is borrowed as 'static, must return lvalue.\n \n             // Cast pointer to global, because constants have different types."}, {"sha": "d760b2c52ca1b0217d14137f00ace8b5488fc193", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -349,8 +349,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // The outptr can be noalias and nocapture because it's entirely\n         // invisible to the program. We also know it's nonnull as well\n         // as how many bytes we can dereference\n-        attrs.arg(1, llvm::NoAliasAttribute)\n-             .arg(1, llvm::NoCaptureAttribute)\n+        attrs.arg(1, llvm::Attribute::NoAliasAttribute)\n+             .arg(1, llvm::Attribute::NoCaptureAttribute)\n              .arg(1, llvm::DereferenceableAttribute(llret_sz));\n     };\n "}, {"sha": "a2a9e89ff6351cd5a0d8fd05d72ad7f65693c965", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 102, "deletions": 91, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -30,7 +30,6 @@ use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n-use trans::datum;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n@@ -132,14 +131,26 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n                            t: Ty<'tcx>,\n-                           debug_loc: DebugLoc)\n-                           -> Block<'blk, 'tcx> {\n+                           debug_loc: DebugLoc) -> Block<'blk, 'tcx> {\n+    drop_ty_core(bcx, v, t, debug_loc, false)\n+}\n+\n+pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                v: ValueRef,\n+                                t: Ty<'tcx>,\n+                                debug_loc: DebugLoc,\n+                                skip_dtor: bool) -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n+    debug!(\"drop_ty_core(t={}, skip_dtor={})\", t.repr(bcx.tcx()), skip_dtor);\n     let _icx = push_ctxt(\"drop_ty\");\n     if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n-        let glue = get_drop_glue(ccx, t);\n+        let g = if skip_dtor {\n+            DropGlueKind::TyContents(t)\n+        } else {\n+            DropGlueKind::Ty(t)\n+        };\n+        let glue = get_drop_glue_core(ccx, g);\n         let glue_type = get_drop_glue_type(ccx, t);\n         let ptr = if glue_type != t {\n             PointerCast(bcx, v, type_of(ccx, glue_type).ptr_to())\n@@ -155,22 +166,64 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      v: ValueRef,\n                                      t: Ty<'tcx>,\n-                                     debug_loc: DebugLoc)\n+                                     debug_loc: DebugLoc,\n+                                     skip_dtor: bool)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     store_ty(bcx, v, vp, t);\n-    drop_ty(bcx, vp, t, debug_loc)\n+    drop_ty_core(bcx, vp, t, debug_loc, skip_dtor)\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n-    debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    let t = get_drop_glue_type(ccx, t);\n-    debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    match ccx.drop_glues().borrow().get(&t) {\n+    get_drop_glue_core(ccx, DropGlueKind::Ty(t))\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum DropGlueKind<'tcx> {\n+    /// The normal path; runs the dtor, and then recurs on the contents\n+    Ty(Ty<'tcx>),\n+    /// Skips the dtor, if any, for ty; drops the contents directly.\n+    /// Note that the dtor is only skipped at the most *shallow*\n+    /// level, namely, an `impl Drop for Ty` itself. So, for example,\n+    /// if Ty is Newtype(S) then only the Drop impl for for Newtype\n+    /// itself will be skipped, while the Drop impl for S, if any,\n+    /// will be invoked.\n+    TyContents(Ty<'tcx>),\n+}\n+\n+impl<'tcx> DropGlueKind<'tcx> {\n+    fn ty(&self) -> Ty<'tcx> {\n+        match *self { DropGlueKind::Ty(t) | DropGlueKind::TyContents(t) => t }\n+    }\n+\n+    fn map_ty<F>(&self, mut f: F) -> DropGlueKind<'tcx> where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n+    {\n+        match *self {\n+            DropGlueKind::Ty(t) => DropGlueKind::Ty(f(t)),\n+            DropGlueKind::TyContents(t) => DropGlueKind::TyContents(f(t)),\n+        }\n+    }\n+\n+    fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n+        let t_str = ppaux::ty_to_string(ccx.tcx(), self.ty());\n+        match *self {\n+            DropGlueKind::Ty(_) => format!(\"DropGlueKind::Ty({})\", t_str),\n+            DropGlueKind::TyContents(_) => format!(\"DropGlueKind::TyContents({})\", t_str),\n+        }\n+    }\n+}\n+\n+fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                g: DropGlueKind<'tcx>) -> ValueRef {\n+    debug!(\"make drop glue for {}\", g.to_string(ccx));\n+    let g = g.map_ty(|t| get_drop_glue_type(ccx, t));\n+    debug!(\"drop glue type {}\", g.to_string(ccx));\n+    match ccx.drop_glues().borrow().get(&g) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n+    let t = g.ty();\n \n     let llty = if type_is_sized(ccx.tcx(), t) {\n         type_of(ccx, t).ptr_to()\n@@ -182,17 +235,17 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     // To avoid infinite recursion, don't `make_drop_glue` until after we've\n     // added the entry to the `drop_glues` cache.\n-    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&t) {\n+    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&g) {\n         let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n-        ccx.drop_glues().borrow_mut().insert(t, llfn);\n+        ccx.drop_glues().borrow_mut().insert(g, llfn);\n         return llfn;\n     };\n \n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n     let llfn = declare::define_cfn(ccx, &fn_nm, llfnty, ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n        ccx.sess().bug(&format!(\"symbol `{}` already defined\", fn_nm));\n     });\n-    ccx.available_drop_glues().borrow_mut().insert(t, fn_nm);\n+    ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n \n     let _s = StatRecorder::new(ccx, format!(\"drop {}\", ty_to_short_str(ccx.tcx(), t)));\n \n@@ -217,7 +270,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n     // type, so we don't need to explicitly cast the function parameter.\n \n     let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n-    let bcx = make_drop_glue(bcx, llrawptr0, t);\n+    let bcx = make_drop_glue(bcx, llrawptr0, g);\n     finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n \n     llfn\n@@ -307,88 +360,36 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  substs: &subst::Substs<'tcx>)\n                                  -> Block<'blk, 'tcx>\n {\n-    let repr = adt::represent_type(bcx.ccx(), t);\n+    debug!(\"trans_struct_drop t: {}\", bcx.ty_to_string(t));\n \n     // Find and call the actual destructor\n-    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t,\n-                                 class_did, substs);\n+    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t, class_did, substs);\n \n-    // The first argument is the \"self\" argument for drop\n+    // Class dtors have no explicit args, so the params should\n+    // just consist of the environment (self).\n     let params = unsafe {\n         let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n         ty.element_type().func_params()\n     };\n+    assert_eq!(params.len(), 1);\n \n-    let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n-    let self_ty = match fty.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n-            let sig = ty::erase_late_bound_regions(bcx.tcx(), &f.sig);\n-            assert!(sig.inputs.len() == 1);\n-            sig.inputs[0]\n-        }\n-        _ => bcx.sess().bug(&format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty)))\n-    };\n-\n-    let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n-        (v0, None)\n-    } else {\n-        let data = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-        let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n-        (Load(bcx, data), Some(Load(bcx, info)))\n-    };\n-\n-    adt::fold_variants(bcx, &*repr, struct_data, |variant_cx, st, value| {\n-        // Be sure to put all of the fields into a scope so we can use an invoke\n-        // instruction to call the user destructor but still call the field\n-        // destructors if the user destructor panics.\n-        let field_scope = variant_cx.fcx.push_custom_cleanup_scope();\n-\n-        // Class dtors have no explicit args, so the params should\n-        // just consist of the environment (self).\n-        assert_eq!(params.len(), 1);\n-        let self_arg = if type_is_fat_ptr(bcx.tcx(), self_ty) {\n-            // The dtor expects a fat pointer, so make one, even if we have to fake it.\n-            let scratch = datum::rvalue_scratch_datum(bcx, t, \"__fat_ptr_drop_self\");\n-            Store(bcx, value, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n-            Store(bcx,\n-                  // If we just had a thin pointer, make a fat pointer by sticking\n-                  // null where we put the unsizing info. This works because t\n-                  // is a sized type, so we will only unpack the fat pointer, never\n-                  // use the fake info.\n-                  info.unwrap_or(C_null(Type::i8p(bcx.ccx()))),\n-                  GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n-            PointerCast(variant_cx, scratch.val, params[0])\n-        } else {\n-            PointerCast(variant_cx, value, params[0])\n-        };\n-        let args = vec!(self_arg);\n+    // Be sure to put the contents into a scope so we can use an invoke\n+    // instruction to call the user destructor but still call the field\n+    // destructors if the user destructor panics.\n+    //\n+    // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n+    // might well consider changing below to more direct code.\n+    let contents_scope = bcx.fcx.push_custom_cleanup_scope();\n \n-        // Add all the fields as a value which needs to be cleaned at the end of\n-        // this scope. Iterate in reverse order so a Drop impl doesn't reverse\n-        // the order in which fields get dropped.\n-        for (i, &ty) in st.fields.iter().enumerate().rev() {\n-            let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n+    // Issue #23611: schedule cleanup of contents, re-inspecting the\n+    // discriminant (if any) in case of variant swap in drop code.\n+    bcx.fcx.schedule_drop_adt_contents(cleanup::CustomScope(contents_scope), v0, t);\n \n-            let val = if type_is_sized(bcx.tcx(), ty) {\n-                llfld_a\n-            } else {\n-                let scratch = datum::rvalue_scratch_datum(bcx, ty, \"__fat_ptr_drop_field\");\n-                Store(bcx, llfld_a, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n-                Store(bcx, info.unwrap(), GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n-                scratch.val\n-            };\n-            variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope), val, ty);\n-        }\n-\n-        let dtor_ty = ty::mk_ctor_fn(bcx.tcx(),\n-                                     class_did,\n-                                     &[get_drop_glue_type(bcx.ccx(), t)],\n-                                     ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[..], dtor_ty, DebugLoc::None);\n+    let glue_type = get_drop_glue_type(bcx.ccx(), t);\n+    let dtor_ty = ty::mk_ctor_fn(bcx.tcx(), class_did, &[glue_type], ty::mk_nil(bcx.tcx()));\n+    let (_, bcx) = invoke(bcx, dtor_addr, &[v0], dtor_ty, DebugLoc::None);\n \n-        variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope)\n-    })\n+    bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n \n fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n@@ -454,8 +455,10 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n     }\n }\n \n-fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n+fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueKind<'tcx>)\n                               -> Block<'blk, 'tcx> {\n+    let t = g.ty();\n+    let skip_dtor = match g { DropGlueKind::Ty(_) => false, DropGlueKind::TyContents(_) => true };\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n \n@@ -469,6 +472,10 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n \n     match t.sty {\n         ty::ty_uniq(content_ty) => {\n+            // Support for ty_uniq is built-in and its drop glue is\n+            // special. It may move to library and have Drop impl. As\n+            // a safe-guard, assert ty_uniq not used with TyContents.\n+            assert!(!skip_dtor);\n             if !type_is_sized(bcx.tcx(), content_ty) {\n                 let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n                 let llbox = Load(bcx, llval);\n@@ -505,8 +512,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         }\n         ty::ty_struct(did, substs) | ty::ty_enum(did, substs) => {\n             let tcx = bcx.tcx();\n-            match ty::ty_dtor(tcx, did) {\n-                ty::TraitDtor(dtor, true) => {\n+            match (ty::ty_dtor(tcx, did), skip_dtor) {\n+                (ty::TraitDtor(dtor, true), false) => {\n                     // FIXME(16758) Since the struct is unsized, it is hard to\n                     // find the drop flag (which is at the end of the struct).\n                     // Lets just ignore the flag and pretend everything will be\n@@ -523,16 +530,20 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n-                ty::TraitDtor(dtor, false) => {\n+                (ty::TraitDtor(dtor, false), false) => {\n                     trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                 }\n-                ty::NoDtor => {\n+                (ty::NoDtor, _) | (_, true) => {\n                     // No dtor? Just the default case\n                     iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n                 }\n             }\n         }\n         ty::ty_trait(..) => {\n+            // No support in vtable for distinguishing destroying with\n+            // versus without calling Drop::drop. Assert caller is\n+            // okay with always calling the Drop impl, if any.\n+            assert!(!skip_dtor);\n             let data_ptr = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n             let vtable_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]));\n             let dtor = Load(bcx, vtable_ptr);"}, {"sha": "3f44bc40f356b7f51362525272d4123adade4c39", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -134,6 +134,14 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n \n+            // Associated consts already have to be evaluated in `typeck`, so\n+            // the logic to do that already exists in `middle`. In order to\n+            // reuse that code, it needs to be able to look up the traits for\n+            // inlined items.\n+            let ty_trait_item = ty::impl_or_trait_item(ccx.tcx(), fn_id).clone();\n+            ccx.tcx().impl_or_trait_items.borrow_mut()\n+                     .insert(local_def(trait_item.id), ty_trait_item);\n+\n             // If this is a default method, we can't look up the\n             // impl type. But we aren't going to translate anyways, so\n             // don't."}, {"sha": "7188fdebeecf4c170ddb47f2a67f6a4ebb3f654a", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -144,6 +144,9 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n     ccx.sess().abort_if_errors();\n }\n \n+/// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n+/// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n+/// add them to librustc_trans/trans/context.rs\n pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             node: ast::NodeId,\n                                             callee_ty: Ty<'tcx>,\n@@ -676,6 +679,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                     llargs[1],\n                                     call_debug_location),\n \n+        (_, \"unchecked_udiv\") => UDiv(bcx, llargs[0], llargs[1], call_debug_location),\n+        (_, \"unchecked_sdiv\") => SDiv(bcx, llargs[0], llargs[1], call_debug_location),\n+        (_, \"unchecked_urem\") => URem(bcx, llargs[0], llargs[1], call_debug_location),\n+        (_, \"unchecked_srem\") => SRem(bcx, llargs[0], llargs[1], call_debug_location),\n+\n         (_, \"overflowing_add\") => Add(bcx, llargs[0], llargs[1], call_debug_location),\n         (_, \"overflowing_sub\") => Sub(bcx, llargs[0], llargs[1], call_debug_location),\n         (_, \"overflowing_mul\") => Mul(bcx, llargs[0], llargs[1], call_debug_location),\n@@ -763,7 +771,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"fence\" => {\n-                    AtomicFence(bcx, order);\n+                    AtomicFence(bcx, order, llvm::CrossThread);\n+                    C_nil(ccx)\n+                }\n+\n+                \"singlethreadfence\" => {\n+                    AtomicFence(bcx, order, llvm::SingleThread);\n                     C_nil(ccx)\n                 }\n "}, {"sha": "fda931fde6e6c8b14a03acf55092f3ea5cbfdea5", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -74,8 +74,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 ast::MethodImplItem(..) => {\n                     visit::walk_impl_item(&mut v, impl_item);\n                 }\n-                ast::TypeImplItem(_) |\n-                ast::MacImplItem(_) => {}\n+                _ => {}\n             }\n         }\n         return;\n@@ -98,8 +97,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 }\n                 visit::walk_impl_item(&mut v, impl_item);\n             }\n-            ast::TypeImplItem(_) |\n-            ast::MacImplItem(_) => {}\n+            _ => {}\n         }\n     }\n }\n@@ -336,9 +334,9 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let impl_did = vtable_impl.impl_def_id;\n             let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n                 ty::MethodTraitItem(method) => method.name,\n-                ty::TypeTraitItem(_) => {\n-                    bcx.tcx().sess.bug(\"can't monomorphize an associated \\\n-                                        type\")\n+                _ => {\n+                    bcx.tcx().sess.bug(\"can't monomorphize a non-method trait \\\n+                                        item\")\n                 }\n             };\n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n@@ -579,8 +577,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n     // Lookup the type of this method as declared in the trait and apply substitutions.\n     let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n         ty::MethodTraitItem(method) => method,\n-        ty::TypeTraitItem(_) => {\n-            tcx.sess.bug(\"can't create a method shim for an associated type\")\n+        _ => {\n+            tcx.sess.bug(\"can't create a method shim for a non-method item\")\n         }\n     };\n     let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n@@ -789,11 +787,11 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     trait_item_def_ids\n         .iter()\n \n-        // Filter out the associated types.\n+        // Filter out non-method items.\n         .filter_map(|item_def_id| {\n             match *item_def_id {\n                 ty::MethodTraitItemId(def_id) => Some(def_id),\n-                ty::TypeTraitItemId(_) => None,\n+                _ => None,\n             }\n         })\n \n@@ -806,7 +804,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n-                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+                _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n             let name = trait_method_type.name;\n \n@@ -824,7 +822,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let impl_method_def_id = method_with_name(ccx, impl_id, name);\n             let impl_method_type = match ty::impl_or_trait_item(tcx, impl_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n-                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+                _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n \n             debug!(\"emit_vtable_methods: impl_method_type={}\","}, {"sha": "03fdd0c45c16ae6aa37d19e01b8673ca26956ed5", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -236,11 +236,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     }\n                     d\n                 }\n-                ast::TypeImplItem(_) => {\n-                    ccx.sess().bug(\"can't monomorphize an associated type\")\n-                }\n-                ast::MacImplItem(_) => {\n-                    ccx.sess().bug(\"can't monomorphize an unexpanded macro\")\n+                _ => {\n+                    ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n+                                           map_node))\n                 }\n             }\n         }"}, {"sha": "1f4d6cc2fd471b4b8e04539edcb12438dedc6c36", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -11,12 +11,14 @@\n use middle::const_eval;\n use middle::def;\n use middle::infer;\n-use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n+use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n+use middle::pat_util::pat_is_resolved_const;\n+use middle::privacy::{AllPublic, LastMod};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n-use check::{instantiate_path, structurally_resolved_type};\n+use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n@@ -118,7 +120,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // subtyping doesn't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n-        ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n+        ast::PatEnum(..) | ast::PatIdent(..) if pat_is_resolved_const(&tcx.def_map, pat) => {\n             let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n             assert!(const_scheme.generics.is_empty());\n@@ -181,6 +183,37 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let subpats = subpats.as_ref().map(|v| &v[..]);\n             check_pat_enum(pcx, pat, path, subpats, expected);\n         }\n+        ast::PatQPath(ref qself, ref path) => {\n+            let self_ty = fcx.to_ty(&qself.ty);\n+            let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n+                d\n+            } else if qself.position == 0 {\n+                def::PathResolution {\n+                    // This is just a sentinel for finish_resolving_def_to_ty.\n+                    base_def: def::DefMod(ast_util::local_def(ast::CRATE_NODE_ID)),\n+                    last_private: LastMod(AllPublic),\n+                    depth: path.segments.len()\n+                }\n+            } else {\n+                tcx.sess.span_bug(pat.span,\n+                                  &format!(\"unbound path {}\", pat.repr(tcx)))\n+            };\n+            if let Some((opt_ty, segments, def)) =\n+                    resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),\n+                                            path, pat.span, pat.id) {\n+                if check_assoc_item_is_const(pcx, def, pat.span) {\n+                    let scheme = ty::lookup_item_type(tcx, def.def_id());\n+                    let predicates = ty::lookup_predicates(tcx, def.def_id());\n+                    instantiate_path(fcx, segments,\n+                                     scheme, &predicates,\n+                                     opt_ty, def, pat.span, pat.id);\n+                    let const_ty = fcx.node_ty(pat.id);\n+                    demand::suptype(fcx, pat.span, expected, const_ty);\n+                } else {\n+                    fcx.write_error(pat.id)\n+                }\n+            }\n+        }\n         ast::PatStruct(ref path, ref fields, etc) => {\n             check_pat_struct(pcx, pat, path, fields, etc, expected);\n         }\n@@ -331,6 +364,21 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     // subtyping.\n }\n \n+fn check_assoc_item_is_const(pcx: &pat_ctxt, def: def::Def, span: Span) -> bool {\n+    match def {\n+        def::DefAssociatedConst(..) => true,\n+        def::DefMethod(..) => {\n+            span_err!(pcx.fcx.ccx.tcx.sess, span, E0327,\n+                      \"associated items in match patterns must be constants\");\n+            false\n+        }\n+        _ => {\n+            pcx.fcx.ccx.tcx.sess.span_bug(span, \"non-associated item in\n+                                                 check_assoc_item_is_const\");\n+        }\n+    }\n+}\n+\n pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                       span: Span, expected: Ty<'tcx>,\n                                       inner: &ast::Pat) -> bool {\n@@ -532,7 +580,24 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+    let path_res = *tcx.def_map.borrow().get(&pat.id).unwrap();\n+\n+    let (opt_ty, segments, def) = match resolve_ty_and_def_ufcs(fcx, path_res,\n+                                                                None, path,\n+                                                                pat.span, pat.id) {\n+        Some(resolution) => resolution,\n+        // Error handling done inside resolve_ty_and_def_ufcs, so if\n+        // resolution fails just return.\n+        None => {return;}\n+    };\n+\n+    // Items that were partially resolved before should have been resolved to\n+    // associated constants (i.e. not methods).\n+    if path_res.depth != 0 && !check_assoc_item_is_const(pcx, def, pat.span) {\n+        fcx.write_error(pat.id);\n+        return;\n+    }\n+\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n@@ -547,13 +612,23 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     } else {\n         ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, &path.segments,\n+    instantiate_path(pcx.fcx, segments,\n                      path_scheme, &ctor_predicates,\n-                     None, def, pat.span, pat.id);\n+                     opt_ty, def, pat.span, pat.id);\n+\n+    // If we didn't have a fully resolved path to start with, we had an\n+    // associated const, and we should quit now, since the rest of this\n+    // function uses checks specific to structs and enums.\n+    if path_res.depth != 0 {\n+        let pat_ty = fcx.node_ty(pat.id);\n+        demand::suptype(fcx, pat.span, expected, pat_ty);\n+        return;\n+    }\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n+\n     let real_path_ty = fcx.node_ty(pat.id);\n     let (arg_tys, kind_name): (Vec<_>, &'static str) = match real_path_ty.sty {\n         ty::ty_enum(enum_def_id, expected_substs)"}, {"sha": "b3267a5be495b4df92f5157913b5ff93bee04b76", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -412,3 +412,85 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return true;\n     }\n }\n+\n+pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                impl_c: &ty::AssociatedConst<'tcx>,\n+                                impl_c_span: Span,\n+                                trait_c: &ty::AssociatedConst<'tcx>,\n+                                impl_trait_ref: &ty::TraitRef<'tcx>) {\n+    debug!(\"compare_const_impl(impl_trait_ref={})\",\n+           impl_trait_ref.repr(tcx));\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+\n+    // The below is for the most part highly similar to the procedure\n+    // for methods above. It is simpler in many respects, especially\n+    // because we shouldn't really have to deal with lifetimes or\n+    // predicates. In fact some of this should probably be put into\n+    // shared functions because of DRY violations...\n+    let trait_to_impl_substs = &impl_trait_ref.substs;\n+\n+    // Create a parameter environment that represents the implementation's\n+    // method.\n+    let impl_param_env =\n+        ty::ParameterEnvironment::for_item(tcx, impl_c.def_id.node);\n+\n+    // Create mapping from impl to skolemized.\n+    let impl_to_skol_substs = &impl_param_env.free_substs;\n+\n+    // Create mapping from trait to skolemized.\n+    let trait_to_skol_substs =\n+        trait_to_impl_substs\n+        .subst(tcx, impl_to_skol_substs)\n+        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n+                     impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n+    debug!(\"compare_const_impl: trait_to_skol_substs={}\",\n+           trait_to_skol_substs.repr(tcx));\n+\n+    // Compute skolemized form of impl and trait const tys.\n+    let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n+    let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n+\n+    let err = infcx.commit_if_ok(|_| {\n+        let origin = infer::Misc(impl_c_span);\n+\n+        // There is no \"body\" here, so just pass dummy id.\n+        let impl_ty =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_c_span,\n+                                                 0,\n+                                                 &impl_ty);\n+        debug!(\"compare_const_impl: impl_ty={}\",\n+               impl_ty.repr(tcx));\n+\n+        let trait_ty =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_c_span,\n+                                                 0,\n+                                                 &trait_ty);\n+        debug!(\"compare_const_impl: trait_ty={}\",\n+               trait_ty.repr(tcx));\n+\n+        infer::mk_subty(&infcx, false, origin, impl_ty, trait_ty)\n+    });\n+\n+    match err {\n+        Ok(()) => { }\n+        Err(terr) => {\n+            debug!(\"checking associated const for compatibility: impl ty {}, trait ty {}\",\n+                   impl_ty.repr(tcx),\n+                   trait_ty.repr(tcx));\n+            span_err!(tcx.sess, impl_c_span, E0326,\n+                      \"implemented const `{}` has an incompatible type for \\\n+                      trait: {}\",\n+                      token::get_name(trait_c.name),\n+                      ty::type_err_to_str(tcx, &terr));\n+            return;\n+        }\n+    }\n+}"}, {"sha": "008ba1c6bf83e3a3a9b30b1a3275eb8dee1a5bb5", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -464,9 +464,9 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                     ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n                         let def_id = t_pred.trait_ref.def_id;\n                         match rcx.tcx().lang_items.to_builtin_kind(def_id) {\n+                            // Issue 24895: deliberately do not include `BoundCopy` here.\n                             Some(ty::BoundSend) |\n                             Some(ty::BoundSized) |\n-                            Some(ty::BoundCopy) |\n                             Some(ty::BoundSync) => false,\n                             _ => true,\n                         }"}, {"sha": "cf1323e71bd0e94806d8ab03db4b9ff273af31db", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -109,10 +109,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.add_obligations(&pick, &all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n+        let method_ty = pick.item.as_opt_method().unwrap();\n         let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n-            unsafety: pick.method_ty.fty.unsafety,\n-            abi: pick.method_ty.fty.abi.clone(),\n+            unsafety: method_ty.fty.unsafety,\n+            abi: method_ty.fty.abi.clone(),\n         }));\n         let callee = MethodCallee {\n             origin: method_origin,\n@@ -204,7 +205,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         \"impl {:?} is not an inherent impl\", impl_def_id);\n                 let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n \n-                (impl_polytype.substs, MethodStatic(pick.method_ty.def_id))\n+                (impl_polytype.substs, MethodStatic(pick.item.def_id()))\n             }\n \n             probe::ObjectPick(trait_def_id, method_num, vtable_index) => {\n@@ -336,7 +337,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let num_method_types = pick.method_ty.generics.types.len(subst::FnSpace);\n+        let num_method_types = pick.item.as_opt_method().unwrap()\n+                                   .generics.types.len(subst::FnSpace);\n         let method_types = {\n             if num_supplied_types == 0 {\n                 self.fcx.infcx().next_ty_vars(num_method_types)\n@@ -360,7 +362,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let method_regions =\n             self.fcx.infcx().region_vars_for_defs(\n                 self.span,\n-                pick.method_ty.generics.regions.get_slice(subst::FnSpace));\n+                pick.item.as_opt_method().unwrap()\n+                    .generics.regions.get_slice(subst::FnSpace));\n \n         (method_types, method_regions)\n     }\n@@ -397,7 +400,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n-        let method_predicates = pick.method_ty.predicates.instantiate(self.tcx(), &all_substs);\n+        let method_predicates = pick.item.as_opt_method().unwrap()\n+                                    .predicates.instantiate(self.tcx(), &all_substs);\n         let method_predicates = self.fcx.normalize_associated_types_in(self.span,\n                                                                        &method_predicates);\n \n@@ -410,7 +414,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&pick.method_ty.fty.sig);\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(\n+            &pick.item.as_opt_method().unwrap().fty.sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n                method_sig.repr(self.tcx()));\n \n@@ -616,7 +621,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n-        match pick.method_ty.container {\n+        match pick.item.container() {\n             ty::TraitContainer(trait_def_id) => {\n                 callee::check_legal_trait_for_method_call(self.fcx.ccx, self.span, trait_def_id)\n             }\n@@ -625,7 +630,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 // potential calls to it will wind up in the other\n                 // arm. But just to be sure, check that the method id\n                 // does not appear in the list of destructors.\n-                assert!(!self.tcx().destructors.borrow().contains(&pick.method_ty.def_id));\n+                assert!(!self.tcx().destructors.borrow().contains(&pick.item.def_id()));\n             }\n         }\n     }"}, {"sha": "c5d8e2758ba5c6a9c3538538862bc261c6646470", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -58,7 +58,7 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ ast::DefId),\n }\n \n-type MethodIndex = usize; // just for doc purposes\n+type ItemIndex = usize; // just for doc purposes\n \n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -312,18 +312,25 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n-    let def_id = pick.method_ty.def_id;\n+    let def_id = pick.item.def_id();\n     let mut lp = LastMod(AllPublic);\n     let provenance = match pick.kind {\n         probe::InherentImplPick(impl_def_id) => {\n-            if pick.method_ty.vis != ast::Public {\n+            if pick.item.vis() != ast::Public {\n                 lp = LastMod(DependsOn(def_id));\n             }\n             def::FromImpl(impl_def_id)\n         }\n-        _ => def::FromTrait(pick.method_ty.container.id())\n+        _ => def::FromTrait(pick.item.container().id())\n     };\n-    Ok((def::DefMethod(def_id, provenance), lp))\n+    let def_result = match pick.item {\n+        ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n+        ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id, provenance),\n+        ImplOrTraitItem::TypeTraitItem(..) => {\n+            fcx.tcx().sess.span_bug(span, \"resolve_ufcs: probe picked associated type\");\n+        }\n+    };\n+    Ok((def_result, lp))\n }\n \n "}, {"sha": "7ff1355184b56ade0e49fc903c3b849dc06e7cdb", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 142, "deletions": 134, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::MethodError;\n-use super::MethodIndex;\n+use super::ItemIndex;\n use super::{CandidateSource,ImplSource,TraitSource};\n use super::suggest;\n \n@@ -37,7 +37,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    method_name: ast::Name,\n+    item_name: ast::Name,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n@@ -54,22 +54,22 @@ struct CandidateStep<'tcx> {\n \n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n-    method_ty: Rc<ty::Method<'tcx>>,\n+    item: ty::ImplOrTraitItem<'tcx>,\n     kind: CandidateKind<'tcx>,\n }\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n     ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n-                           subst::Substs<'tcx>, MethodIndex),\n-    ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n-    ProjectionCandidate(ast::DefId, MethodIndex),\n+                           subst::Substs<'tcx>, ItemIndex),\n+    ClosureCandidate(/* Trait */ ast::DefId, ItemIndex),\n+    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, ItemIndex),\n+    ProjectionCandidate(ast::DefId, ItemIndex),\n }\n \n pub struct Pick<'tcx> {\n-    pub method_ty: Rc<ty::Method<'tcx>>,\n+    pub item: ty::ImplOrTraitItem<'tcx>,\n     pub kind: PickKind<'tcx>,\n \n     // Indicates that the source expression should be autoderef'd N times\n@@ -94,20 +94,20 @@ pub struct Pick<'tcx> {\n pub enum PickKind<'tcx> {\n     InherentImplPick(/* Impl */ ast::DefId),\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ usize, /* real_index */ usize),\n-    ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n-    TraitPick(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, MethodIndex),\n+    ExtensionImplPick(/* Impl */ ast::DefId, ItemIndex),\n+    TraitPick(/* Trait */ ast::DefId, ItemIndex),\n+    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, ItemIndex),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n \n-#[derive(PartialEq, Eq, Copy, Clone)]\n+#[derive(PartialEq, Eq, Copy, Clone, Debug)]\n pub enum Mode {\n     // An expression of the form `receiver.method_name(...)`.\n     // Autoderefs are performed on `receiver`, lookup is done based on the\n     // `self` argument  of the method, and static methods aren't considered.\n     MethodCall,\n-    // An expression of the form `Type::method` or `<T>::method`.\n+    // An expression of the form `Type::item` or `<T>::item`.\n     // No autoderefs are performed, lookup is done based on the type each\n     // implementation is for, and static methods are included.\n     Path\n@@ -116,14 +116,14 @@ pub enum Mode {\n pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        span: Span,\n                        mode: Mode,\n-                       method_name: ast::Name,\n+                       item_name: ast::Name,\n                        self_ty: Ty<'tcx>,\n                        scope_expr_id: ast::NodeId)\n                        -> PickResult<'tcx>\n {\n-    debug!(\"probe(self_ty={}, method_name={}, scope_expr_id={})\",\n+    debug!(\"probe(self_ty={}, item_name={}, scope_expr_id={})\",\n            self_ty.repr(fcx.tcx()),\n-           method_name,\n+           item_name,\n            scope_expr_id);\n \n     // FIXME(#18741) -- right now, creating the steps involves evaluating the\n@@ -171,7 +171,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let mut probe_cx = ProbeContext::new(fcx,\n                                              span,\n                                              mode,\n-                                             method_name,\n+                                             item_name,\n                                              steps,\n                                              opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n@@ -221,7 +221,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>,\n            span: Span,\n            mode: Mode,\n-           method_name: ast::Name,\n+           item_name: ast::Name,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>)\n            -> ProbeContext<'a,'tcx>\n@@ -230,7 +230,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             fcx: fcx,\n             span: span,\n             mode: mode,\n-            method_name: method_name,\n+            item_name: item_name,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: HashSet::new(),\n@@ -387,12 +387,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let method = match impl_method(self.tcx(), impl_def_id, self.method_name) {\n+        let item = match impl_item(self.tcx(), impl_def_id, self.item_name) {\n             Some(m) => m,\n             None => { return; } // No method with correct name on this impl\n         };\n \n-        if !self.has_applicable_self(&*method) {\n+        if !self.has_applicable_self(&item) {\n             // No receiver declared. Not a candidate.\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n@@ -402,11 +402,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // Determine the receiver type that the method itself expects.\n         let xform_self_ty =\n-            self.xform_self_ty(&method, impl_ty, &impl_substs);\n+            self.xform_self_ty(&item, impl_ty, &impl_substs);\n \n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n-            method_ty: method,\n+            item: item,\n             kind: InherentImplCandidate(impl_def_id, impl_substs)\n         });\n     }\n@@ -427,23 +427,23 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n-        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, item, item_num| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n             let vtable_index =\n                 traits::get_vtable_index_of_object_method(tcx,\n                                                           trait_ref.clone(),\n                                                           new_trait_ref.def_id,\n-                                                          method_num);\n+                                                          item_num);\n \n-            let xform_self_ty = this.xform_self_ty(&m,\n+            let xform_self_ty = this.xform_self_ty(&item,\n                                                    new_trait_ref.self_ty(),\n                                                    new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: m,\n-                kind: ObjectCandidate(new_trait_ref.def_id, method_num, vtable_index)\n+                item: item,\n+                kind: ObjectCandidate(new_trait_ref.def_id, item_num, vtable_index)\n             });\n         });\n     }\n@@ -476,27 +476,29 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(&bounds, |this, poly_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&bounds, |this, poly_trait_ref, item, item_num| {\n             let trait_ref =\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n             let xform_self_ty =\n-                this.xform_self_ty(&m,\n+                this.xform_self_ty(&item,\n                                    trait_ref.self_ty(),\n                                    trait_ref.substs);\n \n-            debug!(\"found match: trait_ref={} substs={} m={}\",\n-                   trait_ref.repr(this.tcx()),\n-                   trait_ref.substs.repr(this.tcx()),\n-                   m.repr(this.tcx()));\n-            assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n-            assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n-            assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n-            assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+            if let Some(ref m) = item.as_opt_method() {\n+                debug!(\"found match: trait_ref={} substs={} m={}\",\n+                       trait_ref.repr(this.tcx()),\n+                       trait_ref.substs.repr(this.tcx()),\n+                       m.repr(this.tcx()));\n+                assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n+                           trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n+                assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n+                           trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n+                assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n+                           trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n+                assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n+                           trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+            }\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n@@ -507,8 +509,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: m,\n-                kind: WhereClauseCandidate(poly_trait_ref, method_num)\n+                item: item,\n+                kind: WhereClauseCandidate(poly_trait_ref, item_num)\n             });\n         });\n     }\n@@ -523,25 +525,25 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         F: for<'b> FnMut(\n             &mut ProbeContext<'b, 'tcx>,\n             ty::PolyTraitRef<'tcx>,\n-            Rc<ty::Method<'tcx>>,\n+            ty::ImplOrTraitItem<'tcx>,\n             usize,\n         ),\n     {\n         debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n \n         let tcx = self.tcx();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let (pos, method) = match trait_method(tcx,\n-                                                   bound_trait_ref.def_id(),\n-                                                   self.method_name) {\n+            let (pos, item) = match trait_item(tcx,\n+                                               bound_trait_ref.def_id(),\n+                                               self.item_name) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n \n-            if !self.has_applicable_self(&*method) {\n+            if !self.has_applicable_self(&item) {\n                 self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n             } else {\n-                mk_cand(self, bound_trait_ref, method, pos);\n+                mk_cand(self, bound_trait_ref, item, pos);\n             }\n         }\n     }\n@@ -584,46 +586,43 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             ty::trait_items(self.tcx(), trait_def_id);\n         let matching_index =\n             trait_items.iter()\n-                       .position(|item| item.name() == self.method_name);\n+                       .position(|item| item.name() == self.item_name);\n         let matching_index = match matching_index {\n             Some(i) => i,\n             None => { return Ok(()); }\n         };\n-        let method = match (&*trait_items)[matching_index].as_opt_method() {\n-            Some(m) => m,\n-            None => { return Ok(()); }\n-        };\n+        let ref item = (&*trait_items)[matching_index];\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n-        if !self.has_applicable_self(&*method) {\n+        if !self.has_applicable_self(item) {\n             debug!(\"method has inapplicable self\");\n             self.record_static_candidate(TraitSource(trait_def_id));\n             return Ok(());\n         }\n \n         self.assemble_extension_candidates_for_trait_impls(trait_def_id,\n-                                                           method.clone(),\n+                                                           item.clone(),\n                                                            matching_index);\n \n         try!(self.assemble_closure_candidates(trait_def_id,\n-                                              method.clone(),\n+                                              item.clone(),\n                                               matching_index));\n \n         self.assemble_projection_candidates(trait_def_id,\n-                                            method.clone(),\n+                                            item.clone(),\n                                             matching_index);\n \n         self.assemble_where_clause_candidates(trait_def_id,\n-                                              method,\n+                                              item.clone(),\n                                               matching_index);\n \n         Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: ast::DefId,\n-                                                     method: Rc<ty::Method<'tcx>>,\n-                                                     method_index: usize)\n+                                                     item: ty::ImplOrTraitItem<'tcx>,\n+                                                     item_index: usize)\n     {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n                                                             trait_def_id);\n@@ -657,16 +656,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n-                self.xform_self_ty(&method,\n+                self.xform_self_ty(&item,\n                                    impl_trait_ref.self_ty(),\n                                    impl_trait_ref.substs);\n \n             debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: method.clone(),\n-                kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, method_index)\n+                item: item.clone(),\n+                kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, item_index)\n             });\n         }\n     }\n@@ -689,8 +688,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: ast::DefId,\n-                                   method_ty: Rc<ty::Method<'tcx>>,\n-                                   method_index: usize)\n+                                   item: ty::ImplOrTraitItem<'tcx>,\n+                                   item_index: usize)\n                                    -> Result<(),MethodError>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n@@ -736,13 +735,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                              &trait_def.generics,\n                                                              step.self_ty);\n \n-            let xform_self_ty = self.xform_self_ty(&method_ty,\n+            let xform_self_ty = self.xform_self_ty(&item,\n                                                    step.self_ty,\n                                                    &substs);\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: method_ty.clone(),\n-                kind: ClosureCandidate(trait_def_id, method_index)\n+                item: item.clone(),\n+                kind: ClosureCandidate(trait_def_id, item_index)\n             });\n         }\n \n@@ -751,16 +750,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: ast::DefId,\n-                                      method: Rc<ty::Method<'tcx>>,\n-                                      method_index: usize)\n+                                      item: ty::ImplOrTraitItem<'tcx>,\n+                                      item_index: usize)\n     {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={}, \\\n-               method={}, \\\n-               method_index={})\",\n+               item={}, \\\n+               item_index={})\",\n                trait_def_id.repr(self.tcx()),\n-               method.repr(self.tcx()),\n-               method_index);\n+               item.repr(self.tcx()),\n+               item_index);\n \n         for step in &*self.steps {\n             debug!(\"assemble_projection_candidates: step={}\",\n@@ -792,7 +791,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                        bound.repr(self.tcx()));\n \n                 if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n-                    let xform_self_ty = self.xform_self_ty(&method,\n+                    let xform_self_ty = self.xform_self_ty(&item,\n                                                            bound.self_ty(),\n                                                            bound.substs);\n \n@@ -802,8 +801,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                     self.extension_candidates.push(Candidate {\n                         xform_self_ty: xform_self_ty,\n-                        method_ty: method.clone(),\n-                        kind: ProjectionCandidate(trait_def_id, method_index)\n+                        item: item.clone(),\n+                        kind: ProjectionCandidate(trait_def_id, item_index)\n                     });\n                 }\n             }\n@@ -812,8 +811,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n-                                        method_ty: Rc<ty::Method<'tcx>>,\n-                                        method_index: usize)\n+                                        item: ty::ImplOrTraitItem<'tcx>,\n+                                        item_index: usize)\n     {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n@@ -824,7 +823,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                           .filter(|b| b.def_id() == trait_def_id)\n         {\n             let bound = self.erase_late_bound_regions(&poly_bound);\n-            let xform_self_ty = self.xform_self_ty(&method_ty,\n+            let xform_self_ty = self.xform_self_ty(&item,\n                                                    bound.self_ty(),\n                                                    bound.substs);\n \n@@ -834,8 +833,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: method_ty.clone(),\n-                kind: WhereClauseCandidate(poly_bound, method_index)\n+                item: item.clone(),\n+                kind: WhereClauseCandidate(poly_bound, item_index)\n             });\n         }\n     }\n@@ -860,7 +859,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         try!(self.assemble_extension_candidates_for_all_traits());\n \n         let out_of_scope_traits = match self.pick_core() {\n-            Some(Ok(p)) => vec![p.method_ty.container.id()],\n+            Some(Ok(p)) => vec![p.item.container().id()],\n             Some(Err(MethodError::Ambiguity(v))) => v.into_iter().map(|source| {\n                 match source {\n                     TraitSource(id) => id,\n@@ -1099,11 +1098,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         // If so, just use this trait and call it a day.\n-        let (trait_def_id, method_num) = trait_data;\n-        let method_ty = probes[0].method_ty.clone();\n+        let (trait_def_id, item_num) = trait_data;\n+        let item = probes[0].item.clone();\n         Some(Pick {\n-            method_ty: method_ty,\n-            kind: TraitPick(trait_def_id, method_num),\n+            item: item,\n+            kind: TraitPick(trait_def_id, item_num),\n             autoderefs: 0,\n             autoref: None,\n             unsize: None\n@@ -1117,39 +1116,49 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n     }\n \n-    fn has_applicable_self(&self, method: &ty::Method) -> bool {\n+    fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {\n         // \"fast track\" -- check for usage of sugar\n-        match method.explicit_self {\n-            ty::StaticExplicitSelfCategory => {\n-                if self.mode == Mode::Path {\n-                    return true;\n-                }\n-            }\n-            ty::ByValueExplicitSelfCategory |\n-            ty::ByReferenceExplicitSelfCategory(..) |\n-            ty::ByBoxExplicitSelfCategory => {\n-                return true;\n-            }\n+        match *item {\n+            ty::ImplOrTraitItem::MethodTraitItem(ref method) =>\n+                match method.explicit_self {\n+                    ty::StaticExplicitSelfCategory => self.mode == Mode::Path,\n+                    ty::ByValueExplicitSelfCategory |\n+                    ty::ByReferenceExplicitSelfCategory(..) |\n+                    ty::ByBoxExplicitSelfCategory => true,\n+                },\n+            ty::ImplOrTraitItem::ConstTraitItem(..) => self.mode == Mode::Path,\n+            _ => false,\n         }\n-\n         // FIXME -- check for types that deref to `Self`,\n         // like `Rc<Self>` and so on.\n         //\n         // Note also that the current code will break if this type\n         // includes any of the type parameters defined on the method\n         // -- but this could be overcome.\n-        return false;\n     }\n \n     fn record_static_candidate(&mut self, source: CandidateSource) {\n         self.static_candidates.push(source);\n     }\n \n     fn xform_self_ty(&self,\n-                     method: &Rc<ty::Method<'tcx>>,\n+                     item: &ty::ImplOrTraitItem<'tcx>,\n                      impl_ty: Ty<'tcx>,\n                      substs: &subst::Substs<'tcx>)\n                      -> Ty<'tcx>\n+    {\n+        match item.as_opt_method() {\n+            Some(ref method) => self.xform_method_self_ty(method, impl_ty,\n+                                                          substs),\n+            None => impl_ty,\n+        }\n+    }\n+\n+    fn xform_method_self_ty(&self,\n+                            method: &Rc<ty::Method<'tcx>>,\n+                            impl_ty: Ty<'tcx>,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> Ty<'tcx>\n     {\n         debug!(\"xform_self_ty(impl_ty={}, self_ty={}, substs={})\",\n                impl_ty.repr(self.tcx()),\n@@ -1245,46 +1254,45 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n }\n \n-fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                     impl_def_id: ast::DefId,\n-                     method_name: ast::Name)\n-                     -> Option<Rc<ty::Method<'tcx>>>\n+fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                   impl_def_id: ast::DefId,\n+                   item_name: ast::Name)\n+                   -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n     let impl_items = tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n         .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n-        .find(|m| m.name() == method_name)\n-        .and_then(|item| item.as_opt_method())\n+        .find(|item| item.name() == item_name)\n }\n \n-/// Find method with name `method_name` defined in `trait_def_id` and return it, along with its\n-/// index (or `None`, if no such method).\n-fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                      trait_def_id: ast::DefId,\n-                      method_name: ast::Name)\n-                      -> Option<(usize, Rc<ty::Method<'tcx>>)>\n+/// Find item with name `item_name` defined in `trait_def_id` and return it,\n+/// along with its index (or `None`, if no such item).\n+fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                    trait_def_id: ast::DefId,\n+                    item_name: ast::Name)\n+                    -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n     trait_items\n         .iter()\n         .enumerate()\n-        .find(|&(_, ref item)| item.name() == method_name)\n-        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+        .find(|&(_, ref item)| item.name() == item_name)\n+        .map(|(num, ref item)| (num, (*item).clone()))\n }\n \n impl<'tcx> Candidate<'tcx> {\n     fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {\n-            method_ty: self.method_ty.clone(),\n+            item: self.item.clone(),\n             kind: match self.kind {\n                 InherentImplCandidate(def_id, _) => {\n                     InherentImplPick(def_id)\n                 }\n-                ObjectCandidate(def_id, method_num, real_index) => {\n-                    ObjectPick(def_id, method_num, real_index)\n+                ObjectCandidate(def_id, item_num, real_index) => {\n+                    ObjectPick(def_id, item_num, real_index)\n                 }\n                 ExtensionImplCandidate(def_id, _, _, index) => {\n                     ExtensionImplPick(def_id, index)\n@@ -1323,25 +1331,25 @@ impl<'tcx> Candidate<'tcx> {\n         }\n     }\n \n-    fn to_trait_data(&self) -> Option<(ast::DefId,MethodIndex)> {\n+    fn to_trait_data(&self) -> Option<(ast::DefId, ItemIndex)> {\n         match self.kind {\n             InherentImplCandidate(..) => {\n                 None\n             }\n-            ObjectCandidate(trait_def_id, method_num, _) => {\n-                Some((trait_def_id, method_num))\n+            ObjectCandidate(trait_def_id, item_num, _) => {\n+                Some((trait_def_id, item_num))\n             }\n-            ClosureCandidate(trait_def_id, method_num) => {\n-                Some((trait_def_id, method_num))\n+            ClosureCandidate(trait_def_id, item_num) => {\n+                Some((trait_def_id, item_num))\n             }\n-            ExtensionImplCandidate(_, ref trait_ref, _, method_num) => {\n-                Some((trait_ref.def_id, method_num))\n+            ExtensionImplCandidate(_, ref trait_ref, _, item_num) => {\n+                Some((trait_ref.def_id, item_num))\n             }\n-            WhereClauseCandidate(ref trait_ref, method_num) => {\n-                Some((trait_ref.def_id(), method_num))\n+            WhereClauseCandidate(ref trait_ref, item_num) => {\n+                Some((trait_ref.def_id(), item_num))\n             }\n-            ProjectionCandidate(trait_def_id, method_num) => {\n-                Some((trait_def_id, method_num))\n+            ProjectionCandidate(trait_def_id, item_num) => {\n+                Some((trait_def_id, item_num))\n             }\n         }\n     }\n@@ -1392,9 +1400,9 @@ impl<'tcx> Repr<'tcx> for PickKind<'tcx> {\n \n impl<'tcx> Repr<'tcx> for Pick<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Pick(method_ty={}, autoderefs={},\n+        format!(\"Pick(item={}, autoderefs={},\n                  autoref={}, unsize={}, kind={:?})\",\n-                self.method_ty.repr(tcx),\n+                self.item.repr(tcx),\n                 self.autoderefs,\n                 self.autoref.repr(tcx),\n                 self.unsize.repr(tcx),"}, {"sha": "17658675ee2807bc1a660b4a57cb2cd82a883dac", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -364,7 +364,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n }\n \n pub struct AllTraits<'a> {\n-    borrow: cell::Ref<'a Option<AllTraitsVec>>,\n+    borrow: cell::Ref<'a, Option<AllTraitsVec>>,\n     idx: usize\n }\n "}, {"sha": "cb5b569fd79cb284a4ccce936aa6cecfed8ecd32", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 166, "deletions": 63, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -78,7 +78,7 @@ type parameter).\n \n pub use self::LvaluePreference::*;\n pub use self::Expectation::*;\n-pub use self::compare_method::compare_impl_method;\n+pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n@@ -807,6 +807,9 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n \n         for impl_item in impl_items {\n             match impl_item.node {\n+                ast::ConstImplItem(_, ref expr) => {\n+                    check_const(ccx, impl_item.span, &*expr, impl_item.id)\n+                }\n                 ast::MethodImplItem(ref sig, ref body) => {\n                     check_method_body(ccx, &impl_pty.generics, sig, body,\n                                       impl_item.id, impl_item.span);\n@@ -822,14 +825,15 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n-                ast::MethodTraitItem(_, None) => {\n-                    // Nothing to do, since required methods don't have\n-                    // bodies to check.\n+                ast::ConstTraitItem(_, Some(ref expr)) => {\n+                    check_const(ccx, trait_item.span, &*expr, trait_item.id)\n                 }\n                 ast::MethodTraitItem(ref sig, Some(ref body)) => {\n                     check_method_body(ccx, &trait_def.generics, sig, body,\n                                       trait_item.id, trait_item.span);\n                 }\n+                ast::ConstTraitItem(_, None) |\n+                ast::MethodTraitItem(_, None) |\n                 ast::TypeTraitItem(..) => {\n                     // Nothing to do.\n                 }\n@@ -919,6 +923,48 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // and compatible with trait signature\n     for impl_item in impl_items {\n         match impl_item.node {\n+            ast::ConstImplItem(..) => {\n+                let impl_const_def_id = local_def(impl_item.id);\n+                let impl_const_ty = ty::impl_or_trait_item(ccx.tcx,\n+                                                           impl_const_def_id);\n+\n+                // Find associated const definition.\n+                let opt_associated_const =\n+                    trait_items.iter()\n+                               .find(|ac| ac.name() == impl_const_ty.name());\n+                match opt_associated_const {\n+                    Some(associated_const) => {\n+                        match (associated_const, &impl_const_ty) {\n+                            (&ty::ConstTraitItem(ref const_trait),\n+                             &ty::ConstTraitItem(ref const_impl)) => {\n+                                compare_const_impl(ccx.tcx,\n+                                                   &const_impl,\n+                                                   impl_item.span,\n+                                                   &const_trait,\n+                                                   &*impl_trait_ref);\n+                            }\n+                            _ => {\n+                                span_err!(tcx.sess, impl_item.span, E0323,\n+                                          \"item `{}` is an associated const, \\\n+                                          which doesn't match its trait `{}`\",\n+                                          token::get_name(impl_const_ty.name()),\n+                                          impl_trait_ref.repr(tcx))\n+                            }\n+                        }\n+                    }\n+                    None => {\n+                        // This is `span_bug` as it should have already been\n+                        // caught in resolve.\n+                        tcx.sess.span_bug(\n+                            impl_item.span,\n+                            &format!(\n+                                \"associated const `{}` is not a member of \\\n+                                 trait `{}`\",\n+                                token::get_name(impl_const_ty.name()),\n+                                impl_trait_ref.repr(tcx)));\n+                    }\n+                }\n+            }\n             ast::MethodImplItem(_, ref body) => {\n                 let impl_method_def_id = local_def(impl_item.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n@@ -942,13 +988,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     &*impl_trait_ref);\n                             }\n                             _ => {\n-                                // This is span_bug as it should have already been\n-                                // caught in resolve.\n-                                tcx.sess.span_bug(\n-                                    impl_item.span,\n-                                    &format!(\"item `{}` is of a different kind from its trait `{}`\",\n-                                             token::get_name(impl_item_ty.name()),\n-                                             impl_trait_ref.repr(tcx)));\n+                                span_err!(tcx.sess, impl_item.span, E0324,\n+                                          \"item `{}` is an associated method, \\\n+                                          which doesn't match its trait `{}`\",\n+                                          token::get_name(impl_item_ty.name()),\n+                                          impl_trait_ref.repr(tcx))\n                             }\n                         }\n                     }\n@@ -978,13 +1022,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         match (associated_type, &typedef_ty) {\n                             (&ty::TypeTraitItem(_), &ty::TypeTraitItem(_)) => {}\n                             _ => {\n-                                // This is `span_bug` as it should have\n-                                // already been caught in resolve.\n-                                tcx.sess.span_bug(\n-                                    impl_item.span,\n-                                    &format!(\"item `{}` is of a different kind from its trait `{}`\",\n-                                             token::get_name(typedef_ty.name()),\n-                                             impl_trait_ref.repr(tcx)));\n+                                span_err!(tcx.sess, impl_item.span, E0325,\n+                                          \"item `{}` is an associated type, \\\n+                                          which doesn't match its trait `{}`\",\n+                                          token::get_name(typedef_ty.name()),\n+                                          impl_trait_ref.repr(tcx))\n                             }\n                         }\n                     }\n@@ -1008,18 +1050,35 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Check for missing items from trait\n     let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n+    let associated_consts = ty::associated_consts(tcx, impl_trait_ref.def_id);\n     let mut missing_methods = Vec::new();\n     for trait_item in &*trait_items {\n         match *trait_item {\n+            ty::ConstTraitItem(ref associated_const) => {\n+                let is_implemented = impl_items.iter().any(|ii| {\n+                    match ii.node {\n+                        ast::ConstImplItem(..) => {\n+                            ii.ident.name == associated_const.name\n+                        }\n+                        _ => false,\n+                    }\n+                });\n+                let is_provided =\n+                    associated_consts.iter().any(|ac| ac.default.is_some() &&\n+                                                 ac.name == associated_const.name);\n+                if !is_implemented && !is_provided {\n+                    missing_methods.push(format!(\"`{}`\",\n+                                                 token::get_name(associated_const.name)));\n+                }\n+            }\n             ty::MethodTraitItem(ref trait_method) => {\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n                         match ii.node {\n                             ast::MethodImplItem(..) => {\n                                 ii.ident.name == trait_method.name\n                             }\n-                            ast::TypeImplItem(_) |\n-                            ast::MacImplItem(_) => false,\n+                            _ => false,\n                         }\n                     });\n                 let is_provided =\n@@ -1034,8 +1093,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         ast::TypeImplItem(_) => {\n                             ii.ident.name == associated_type.name\n                         }\n-                        ast::MethodImplItem(..) |\n-                        ast::MacImplItem(_) => false,\n+                        _ => false,\n                     }\n                 });\n                 if !is_implemented {\n@@ -3171,53 +3229,20 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 &format!(\"unbound path {}\", expr.repr(tcx)))\n           };\n \n-          let def = path_res.base_def;\n-          if path_res.depth == 0 {\n+          if let Some((opt_ty, segments, def)) =\n+                  resolve_ty_and_def_ufcs(fcx, path_res, opt_self_ty, path,\n+                                          expr.span, expr.id) {\n               let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx,\n                                                                             expr.span,\n                                                                             def);\n               instantiate_path(fcx,\n-                               &path.segments,\n+                               segments,\n                                scheme,\n                                &predicates,\n-                               opt_self_ty,\n+                               opt_ty,\n                                def,\n                                expr.span,\n                                id);\n-          } else {\n-              let ty_segments = path.segments.init();\n-              let base_ty_end = path.segments.len() - path_res.depth;\n-              let ty = astconv::finish_resolving_def_to_ty(fcx,\n-                                                           fcx,\n-                                                           expr.span,\n-                                                           PathParamMode::Optional,\n-                                                           &def,\n-                                                           opt_self_ty,\n-                                                           &ty_segments[..base_ty_end],\n-                                                           &ty_segments[base_ty_end..]);\n-              let method_segment = path.segments.last().unwrap();\n-              let method_name = method_segment.identifier.name;\n-              match method::resolve_ufcs(fcx, expr.span, method_name, ty, id) {\n-                  Ok((def, lp)) => {\n-                      // Write back the new resolution.\n-                      tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n-                          base_def: def,\n-                          last_private: path_res.last_private.or(lp),\n-                          depth: 0\n-                      });\n-\n-                      let (scheme, predicates) =\n-                          type_scheme_and_predicates_for_def(fcx, expr.span, def);\n-                      instantiate_path(fcx, slice::ref_slice(method_segment),\n-                                       scheme, &predicates,\n-                                       Some(ty), def, expr.span, id);\n-                  }\n-                  Err(error) => {\n-                      method::report_error(fcx, expr.span, ty,\n-                                           method_name, None, error);\n-                      fcx.write_error(id);\n-                  }\n-              }\n           }\n \n           // We always require that the type provided as the value for\n@@ -3679,6 +3704,52 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     unifier();\n }\n \n+pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n+                                             path_res: def::PathResolution,\n+                                             opt_self_ty: Option<Ty<'tcx>>,\n+                                             path: &'a ast::Path,\n+                                             span: Span,\n+                                             node_id: ast::NodeId)\n+                                             -> Option<(Option<Ty<'tcx>>,\n+                                                        &'a [ast::PathSegment],\n+                                                        def::Def)>\n+{\n+    // If fully resolved already, we don't have to do anything.\n+    if path_res.depth == 0 {\n+        Some((opt_self_ty, &path.segments, path_res.base_def))\n+    } else {\n+        let mut def = path_res.base_def;\n+        let ty_segments = path.segments.init();\n+        let base_ty_end = path.segments.len() - path_res.depth;\n+        let ty = astconv::finish_resolving_def_to_ty(fcx, fcx, span,\n+                                                     PathParamMode::Optional,\n+                                                     &mut def,\n+                                                     opt_self_ty,\n+                                                     &ty_segments[..base_ty_end],\n+                                                     &ty_segments[base_ty_end..]);\n+        let item_segment = path.segments.last().unwrap();\n+        let item_name = item_segment.identifier.name;\n+        match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n+            Ok((def, lp)) => {\n+                // Write back the new resolution.\n+                fcx.ccx.tcx.def_map.borrow_mut()\n+                       .insert(node_id, def::PathResolution {\n+                   base_def: def,\n+                   last_private: path_res.last_private.or(lp),\n+                   depth: 0\n+                });\n+                Some((Some(ty), slice::ref_slice(item_segment), def))\n+            }\n+            Err(error) => {\n+                method::report_error(fcx, span, ty,\n+                                     item_name, None, error);\n+                fcx.write_error(node_id);\n+                None\n+            }\n+        }\n+    }\n+}\n+\n fn constrain_path_type_parameters(fcx: &FnCtxt,\n                                   expr: &ast::Expr)\n {\n@@ -4207,7 +4278,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         def::DefFn(id, _) | def::DefMethod(id, _) |\n         def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n-        def::DefStruct(id) | def::DefConst(id) => {\n+        def::DefStruct(id) | def::DefConst(id) | def::DefAssociatedConst(id, _) => {\n             (ty::lookup_item_type(fcx.tcx(), id), ty::lookup_predicates(fcx.tcx(), id))\n         }\n         def::DefTrait(_) |\n@@ -4249,7 +4320,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Luckily, we can (at least for now) deduce the intermediate steps\n     // just from the end-point.\n     //\n-    // There are basically three cases to consider:\n+    // There are basically four cases to consider:\n     //\n     // 1. Reference to a *type*, such as a struct or enum:\n     //\n@@ -4299,6 +4370,16 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n     //    final segment, `foo::<B>` contains parameters in fn space.\n     //\n+    // 4. Reference to an *associated const*:\n+    //\n+    // impl<A> AnotherStruct<A> {\n+    // const FOO: B = BAR;\n+    // }\n+    //\n+    // The path in this case will look like\n+    // `a::b::AnotherStruct::<A>::FOO`, so the penultimate segment\n+    // only will have parameters in TypeSpace.\n+    //\n     // The first step then is to categorize the segments appropriately.\n \n     assert!(!segments.is_empty());\n@@ -4350,6 +4431,23 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n \n+        def::DefAssociatedConst(_, provenance) => {\n+            match provenance {\n+                def::FromTrait(trait_did) => {\n+                    callee::check_legal_trait_for_method_call(fcx.ccx, span, trait_did)\n+                }\n+                def::FromImpl(_) => {}\n+            }\n+\n+            if segments.len() >= 2 {\n+                segment_spaces = repeat(None).take(segments.len() - 2).collect();\n+                segment_spaces.push(Some(subst::TypeSpace));\n+                segment_spaces.push(None);\n+            } else {\n+                segment_spaces = vec![None];\n+            }\n+        }\n+\n         // Other cases. Various nonsense that really shouldn't show up\n         // here. If they do, an error will have been reported\n         // elsewhere. (I hope)\n@@ -4784,6 +4882,8 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n+/// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n+/// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n         let name = token::intern(&format!(\"P{}\", n));\n@@ -4812,7 +4912,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                 (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n                  param(ccx, 0))\n             }\n-            \"fence\" => {\n+            \"fence\" | \"singlethreadfence\" => {\n                 (0, Vec::new(), ty::mk_nil(tcx))\n             }\n             op => {\n@@ -5021,6 +5121,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                 (0, vec!(tcx.types.u64, tcx.types.u64),\n                 ty::mk_tup(tcx, vec!(tcx.types.u64, tcx.types.bool))),\n \n+            \"unchecked_udiv\" | \"unchecked_sdiv\" | \"unchecked_urem\" | \"unchecked_srem\" =>\n+                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+\n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n                 (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n "}, {"sha": "19cb570c82d13463a8f34a75fa57b4ab16788d6e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -562,11 +562,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             }\n             Err(..) => {\n                 let tcx = rcx.fcx.tcx();\n-                if tcx.sess.has_errors() {\n-                    // cannot run dropck; okay b/c in error state anyway.\n-                } else {\n-                    tcx.sess.span_bug(expr.span, \"cat_expr_unadjusted Errd\");\n-                }\n+                tcx.sess.delay_span_bug(expr.span, \"cat_expr_unadjusted Errd\");\n             }\n         }\n     }\n@@ -583,11 +579,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n         Err(..) => {\n             let tcx = rcx.fcx.tcx();\n-            if tcx.sess.has_errors() {\n-                // cannot run dropck; okay b/c in error state anyway.\n-            } else {\n-                tcx.sess.span_bug(expr.span, \"cat_expr Errd\");\n-            }\n+            tcx.sess.delay_span_bug(expr.span, \"cat_expr Errd\");\n         }\n     }\n "}, {"sha": "fbfe73674e16088eb95388debd7338ffe97c53d9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -20,8 +20,9 @@ use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use middle::subst::{self, Subst};\n use middle::ty::RegionEscape;\n-use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n-use middle::ty::{ParameterEnvironment, TypeTraitItemId, lookup_item_type};\n+use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n+use middle::ty::{MethodTraitItemId, TypeTraitItemId};\n+use middle::ty::{ParameterEnvironment, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n@@ -278,6 +279,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 let mut items: Vec<ImplOrTraitItemId> =\n                         impl_items.iter().map(|impl_item| {\n                     match impl_item.node {\n+                        ast::ConstImplItem(..) => {\n+                            ConstTraitItemId(local_def(impl_item.id))\n+                        }\n                         ast::MethodImplItem(..) => {\n                             MethodTraitItemId(local_def(impl_item.id))\n                         }\n@@ -348,7 +352,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                            .insert(item_def_id.def_id(), source);\n                     }\n                 }\n-                ty::TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n "}, {"sha": "6cb6df008c1cf7e505ae8c8616809a5dcf37dd8b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 112, "deletions": 56, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -197,7 +197,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         let def_id = local_def(method_id);\n         match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n             ty::MethodTraitItem(ref mty) => mty.clone(),\n-            ty::TypeTraitItem(..) => {\n+            _ => {\n                 self.tcx.sess.bug(&format!(\"method with id {} has the wrong type\", method_id));\n             }\n         }\n@@ -692,11 +692,37 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n+fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                      container: ImplOrTraitItemContainer,\n+                                      ident: ast::Ident,\n+                                      id: ast::NodeId,\n+                                      vis: ast::Visibility,\n+                                      ty: ty::Ty<'tcx>,\n+                                      default: Option<&ast::Expr>)\n+{\n+    ccx.tcx.predicates.borrow_mut().insert(local_def(id),\n+                                           ty::GenericPredicates::empty());\n+\n+    write_ty_to_tcx(ccx.tcx, id, ty);\n+    let default_id = default.map(|expr| local_def(expr.id));\n+\n+    let associated_const = Rc::new(ty::AssociatedConst {\n+        name: ident.name,\n+        vis: vis,\n+        def_id: local_def(id),\n+        container: container,\n+        ty: ty,\n+        default: default_id,\n+    });\n+    ccx.tcx.impl_or_trait_items.borrow_mut()\n+       .insert(local_def(id), ty::ConstTraitItem(associated_const));\n+}\n+\n fn as_refsociated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     container: ImplOrTraitItemContainer,\n-                                     ident: ast::Ident,\n-                                     id: ast::NodeId,\n-                                     vis: ast::Visibility)\n+                                 container: ImplOrTraitItemContainer,\n+                                 ident: ast::Ident,\n+                                 id: ast::NodeId,\n+                                 vis: ast::Visibility)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: ident.name,\n@@ -829,45 +855,56 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n-            // Convert all the associated types.\n+            // Convert all the associated consts.\n             for impl_item in impl_items {\n-                match impl_item.node {\n-                    ast::TypeImplItem(ref ty) => {\n-                        if opt_trait_ref.is_none() {\n-                            span_err!(tcx.sess, impl_item.span, E0202,\n-                                              \"associated items are not allowed in inherent impls\");\n-                        }\n-\n-                        as_refsociated_type(ccx, ImplContainer(local_def(it.id)),\n-                                                impl_item.ident, impl_item.id, impl_item.vis);\n+                if let ast::ConstImplItem(ref ty, ref expr) = impl_item.node {\n+                    let ty = ccx.icx(&ty_predicates)\n+                                .to_ty(&ExplicitRscope, &*ty);\n+                    tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n+                                                   TypeScheme {\n+                                                       generics: ty_generics.clone(),\n+                                                       ty: ty,\n+                                                   });\n+                    convert_associated_const(ccx, ImplContainer(local_def(it.id)),\n+                                             impl_item.ident, impl_item.id,\n+                                             impl_item.vis.inherit_from(parent_visibility),\n+                                             ty, Some(&*expr));\n+                }\n+            }\n \n-                        let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n-                        tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n-                                                       TypeScheme {\n-                                                           generics: ty::Generics::empty(),\n-                                                           ty: typ,\n-                                                       });\n-                        tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n-                                                           ty::GenericPredicates::empty());\n-                        write_ty_to_tcx(tcx, impl_item.id, typ);\n+            // Convert all the associated types.\n+            for impl_item in impl_items {\n+                if let ast::TypeImplItem(ref ty) = impl_item.node {\n+                    if opt_trait_ref.is_none() {\n+                        span_err!(tcx.sess, impl_item.span, E0202,\n+                                  \"associated items are not allowed in inherent impls\");\n                     }\n-                    ast::MethodImplItem(..) |\n-                    ast::MacImplItem(_) => {}\n+\n+                    as_refsociated_type(ccx, ImplContainer(local_def(it.id)),\n+                                        impl_item.ident, impl_item.id, impl_item.vis);\n+\n+                    let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n+                    tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n+                                                   TypeScheme {\n+                                                       generics: ty::Generics::empty(),\n+                                                       ty: typ,\n+                                                   });\n+                    tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n+                                                       ty::GenericPredicates::empty());\n+                    write_ty_to_tcx(tcx, impl_item.id, typ);\n                 }\n             }\n \n             let methods = impl_items.iter().filter_map(|ii| {\n-                match ii.node {\n-                    ast::MethodImplItem(ref sig, _) => {\n-                        // if the method specifies a visibility, use that, otherwise\n-                        // inherit the visibility from the impl (so `foo` in `pub impl\n-                        // { fn foo(); }` is public, but private in `priv impl { fn\n-                        // foo(); }`).\n-                        let method_vis = ii.vis.inherit_from(parent_visibility);\n-                        Some((sig, ii.id, ii.ident, method_vis, ii.span))\n-                    }\n-                    ast::TypeImplItem(_) |\n-                    ast::MacImplItem(_) => None\n+                if let ast::MethodImplItem(ref sig, _) = ii.node {\n+                    // if the method specifies a visibility, use that, otherwise\n+                    // inherit the visibility from the impl (so `foo` in `pub impl\n+                    // { fn foo(); }` is public, but private in `priv impl { fn\n+                    // foo(); }`).\n+                    let method_vis = ii.vis.inherit_from(parent_visibility);\n+                    Some((sig, ii.id, ii.ident, method_vis, ii.span))\n+                } else {\n+                    None\n                 }\n             });\n             convert_methods(ccx,\n@@ -878,18 +915,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                             &ty_predicates);\n \n             for impl_item in impl_items {\n-                match impl_item.node {\n-                    ast::MethodImplItem(ref sig, ref body) => {\n-                        let body_id = body.id;\n-                        check_method_self_type(ccx,\n-                                               &BindingRscope::new(),\n-                                               ccx.method_ty(impl_item.id),\n-                                               selfty,\n-                                               &sig.explicit_self,\n-                                               body_id);\n-                    }\n-                    ast::TypeImplItem(_) |\n-                    ast::MacImplItem(_) => {}\n+                if let ast::MethodImplItem(ref sig, ref body) = impl_item.node {\n+                    let body_id = body.id;\n+                    check_method_self_type(ccx,\n+                                           &BindingRscope::new(),\n+                                           ccx.method_ty(impl_item.id),\n+                                           selfty,\n+                                           &sig.explicit_self,\n+                                           body_id);\n                 }\n             }\n \n@@ -920,18 +953,37 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             // Convert all the associated types.\n             for trait_item in trait_items {\n                 match trait_item.node {\n-                    ast::MethodTraitItem(..) => {}\n+                    ast::ConstTraitItem(ref ty, ref default) => {\n+                        let ty = ccx.icx(&trait_predicates)\n+                                    .to_ty(&ExplicitRscope, ty);\n+                        tcx.tcache.borrow_mut().insert(local_def(trait_item.id),\n+                                                       TypeScheme {\n+                                                           generics: trait_def.generics.clone(),\n+                                                           ty: ty,\n+                                                       });\n+                        convert_associated_const(ccx, TraitContainer(local_def(it.id)),\n+                                                 trait_item.ident, trait_item.id,\n+                                                 ast::Public, ty, default.as_ref().map(|d| &**d));\n+                    }\n+                    _ => {}\n+                }\n+            };\n+\n+            // Convert all the associated types.\n+            for trait_item in trait_items {\n+                match trait_item.node {\n                     ast::TypeTraitItem(..) => {\n                         as_refsociated_type(ccx, TraitContainer(local_def(it.id)),\n                                                 trait_item.ident, trait_item.id, ast::Public);\n                     }\n+                    _ => {}\n                 }\n             };\n \n             let methods = trait_items.iter().filter_map(|ti| {\n                 let sig = match ti.node {\n                     ast::MethodTraitItem(ref sig, _) => sig,\n-                    ast::TypeTraitItem(..) => return None,\n+                    _ => return None,\n                 };\n                 Some((sig, ti.id, ti.ident, ast::Inherited, ti.span))\n             });\n@@ -948,6 +1000,9 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n                 let def_id = local_def(trait_item.id);\n                 match trait_item.node {\n+                    ast::ConstTraitItem(..) => {\n+                        ty::ConstTraitItemId(def_id)\n+                    }\n                     ast::MethodTraitItem(..) => {\n                         ty::MethodTraitItemId(def_id)\n                     }\n@@ -963,7 +1018,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             for trait_item in trait_items {\n                 let sig = match trait_item.node {\n                     ast::MethodTraitItem(ref sig, _) => sig,\n-                    ast::TypeTraitItem(..) => continue\n+                    _ => continue\n                 };\n                 check_method_self_type(ccx,\n                                        &BindingRscope::new(),\n@@ -1186,8 +1241,8 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n-            ast::MethodTraitItem(..) => None,\n             ast::TypeTraitItem(..) => Some(trait_item.ident.name),\n+            _ => None,\n         }\n     }).collect();\n \n@@ -1261,7 +1316,7 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n     trait_items.iter().any(|trait_item| {\n         match trait_item.node {\n             ast::TypeTraitItem(..) => trait_item.ident.name == assoc_name,\n-            ast::MethodTraitItem(..) => false,\n+            _ => false,\n         }\n     })\n }\n@@ -1321,7 +1376,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         trait_items.iter().flat_map(|trait_item| {\n             let bounds = match trait_item.node {\n                 ast::TypeTraitItem(ref bounds, _) => bounds,\n-                ast::MethodTraitItem(..) => {\n+                _ => {\n                     return vec!().into_iter();\n                 }\n             };\n@@ -2237,7 +2292,8 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n         impl_items.iter()\n                   .filter_map(|item| match item.node {\n                       ast::TypeImplItem(..) => Some(ty::node_id_to_type(tcx, item.id)),\n-                      ast::MethodImplItem(..) | ast::MacImplItem(..) => None,\n+                      ast::ConstImplItem(..) | ast::MethodImplItem(..) |\n+                      ast::MacImplItem(..) => None,\n                   })\n                   .flat_map(|ty| ctp::parameters_for_type(ty).into_iter())\n                   .filter_map(|p| match p {"}, {"sha": "0af19e445f26e554eb3129950393de8ce9fb0074", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -176,12 +176,15 @@ register_diagnostics! {\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n     E0322, // cannot implement Sized explicitly\n+    E0323, // implemented an associated const when another trait item expected\n+    E0324, // implemented a method when another trait item expected\n+    E0325, // implemented an associated type when another trait item expected\n+    E0326, // associated const implemented with different type from trait\n+    E0327, // referred to method instead of constant in match pattern\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0368, // binary operation `<op>=` cannot be applied to types\n     E0369, // binary operation `<op>` cannot be applied to types\n     E0371, // impl Trait for Trait is illegal\n     E0372  // impl Trait for Trait where Trait is not object safe\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "e50693ea804b6993a852ea82bbcea5ae054dccb5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -82,7 +82,6 @@ This API is completely unstable and subject to change.\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(unsafe_destructor)]\n #![feature(staged_api)]\n \n #[macro_use] extern crate log;\n@@ -344,3 +343,8 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();\n }\n+\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "0d59577a6d802ce1552cd45cf9267dad1c06f9f5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -22,12 +22,13 @@ use rustc::middle::def;\n use rustc::middle::ty;\n use rustc::middle::subst;\n use rustc::middle::stability;\n+use rustc::middle::const_eval;\n \n use core::DocContext;\n use doctree;\n use clean;\n \n-use super::Clean;\n+use super::{Clean, ToSource};\n \n /// Attempt to inline the definition of a local node id into this AST.\n ///\n@@ -106,7 +107,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n             record_extern_fqn(cx, did, clean::TypeStatic);\n             clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n-        def::DefConst(did) => {\n+        def::DefConst(did) | def::DefAssociatedConst(did, _) => {\n             record_extern_fqn(cx, did, clean::TypeConst);\n             clean::ConstantItem(build_const(cx, tcx, did))\n         }\n@@ -312,6 +313,27 @@ pub fn build_impl(cx: &DocContext,\n         let did = did.def_id();\n         let impl_item = ty::impl_or_trait_item(tcx, did);\n         match impl_item {\n+            ty::ConstTraitItem(ref assoc_const) => {\n+                let did = assoc_const.def_id;\n+                let type_scheme = ty::lookup_item_type(tcx, did);\n+                let default = match assoc_const.default {\n+                    Some(_) => Some(const_eval::lookup_const_by_id(tcx, did, None)\n+                                               .unwrap().span.to_src(cx)),\n+                    None => None,\n+                };\n+                Some(clean::Item {\n+                    name: Some(assoc_const.name.clean(cx)),\n+                    inner: clean::AssociatedConstItem(\n+                        type_scheme.ty.clean(cx),\n+                        default,\n+                    ),\n+                    source: clean::Span::empty(),\n+                    attrs: vec![],\n+                    visibility: None,\n+                    stability: stability::lookup(tcx, did).clean(cx),\n+                    def_id: did\n+                })\n+            }\n             ty::MethodTraitItem(method) => {\n                 if method.vis != ast::Public && associated_trait.is_none() {\n                     return None\n@@ -443,7 +465,7 @@ fn build_const(cx: &DocContext, tcx: &ty::ctxt,\n     use rustc::middle::const_eval;\n     use syntax::print::pprust;\n \n-    let expr = const_eval::lookup_const_by_id(tcx, did).unwrap_or_else(|| {\n+    let expr = const_eval::lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);"}, {"sha": "1e6e9a7562a7c1be287fe5e69e42ff7f49dce460", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -361,6 +361,7 @@ pub enum ItemEnum {\n     ForeignStaticItem(Static),\n     MacroItem(Macro),\n     PrimitiveItem(PrimitiveType),\n+    AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n     DefaultImplItem(DefaultImpl),\n }\n@@ -1235,6 +1236,11 @@ impl Clean<PolyTrait> for ast::PolyTraitRef {\n impl Clean<Item> for ast::TraitItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n+            ast::ConstTraitItem(ref ty, ref default) => {\n+                AssociatedConstItem(ty.clean(cx),\n+                                    default.as_ref().map(|expr|\n+                                                         expr.span.to_src(cx)))\n+            }\n             ast::MethodTraitItem(ref sig, Some(_)) => {\n                 MethodItem(sig.clean(cx))\n             }\n@@ -1260,6 +1266,12 @@ impl Clean<Item> for ast::TraitItem {\n impl Clean<Item> for ast::ImplItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                ConstantItem(Constant{\n+                    type_: ty.clean(cx),\n+                    expr: expr.span.to_src(cx),\n+                })\n+            }\n             ast::MethodImplItem(ref sig, _) => {\n                 MethodItem(sig.clean(cx))\n             }\n@@ -1363,6 +1375,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n impl<'tcx> Clean<Item> for ty::ImplOrTraitItem<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         match *self {\n+            ty::ConstTraitItem(ref cti) => cti.clean(cx),\n             ty::MethodTraitItem(ref mti) => mti.clean(cx),\n             ty::TypeTraitItem(ref tti) => tti.clean(cx),\n         }\n@@ -2509,6 +2522,8 @@ fn name_from_pat(p: &ast::Pat) -> String {\n         PatWild(PatWildMulti) => \"..\".to_string(),\n         PatIdent(_, ref p, _) => token::get_ident(p.node).to_string(),\n         PatEnum(ref p, _) => path_to_string(p),\n+        PatQPath(..) => panic!(\"tried to get argument name from PatQPath, \\\n+                                which is not allowed in function arguments\"),\n         PatStruct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n@@ -2672,6 +2687,20 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n+impl<'tcx> Clean<Item> for ty::AssociatedConst<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            source: DUMMY_SP.clean(cx),\n+            name: Some(self.name.clean(cx)),\n+            attrs: Vec::new(),\n+            inner: AssociatedConstItem(self.ty.clean(cx), None),\n+            visibility: None,\n+            def_id: self.def_id,\n+            stability: None,\n+        }\n+    }\n+}\n+\n impl Clean<Item> for ty::AssociatedType {\n     fn clean(&self, cx: &DocContext) -> Item {\n         // When loading a cross-crate associated type, the bounds for this type"}, {"sha": "afc93f41172e84498729ceece2adebcc6845022d", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -39,6 +39,7 @@ pub enum ItemType {\n     Primitive       = 15,\n     AssociatedType  = 16,\n     Constant        = 17,\n+    AssociatedConst = 18,\n }\n \n impl ItemType {\n@@ -63,6 +64,7 @@ impl ItemType {\n             clean::ForeignStaticItem(..)   => ItemType::Static, // no ForeignStatic\n             clean::MacroItem(..)           => ItemType::Macro,\n             clean::PrimitiveItem(..)       => ItemType::Primitive,\n+            clean::AssociatedConstItem(..) => ItemType::AssociatedConst,\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::DefaultImplItem(..)     => ItemType::Impl,\n         }\n@@ -102,6 +104,7 @@ impl ItemType {\n             ItemType::Primitive       => \"primitive\",\n             ItemType::AssociatedType  => \"associatedtype\",\n             ItemType::Constant        => \"constant\",\n+            ItemType::AssociatedConst => \"associatedconstant\",\n         }\n     }\n }"}, {"sha": "9a26a925847e41dbb045b32b809ce24f4009b537", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1460,7 +1460,7 @@ impl<'a> fmt::Display for Item<'a> {\n         try!(write!(fmt, \"<span class='out-of-band'>\"));\n         try!(write!(fmt,\n         r##\"<span id='render-detail'>\n-            <a id=\"toggle-all-docs\" href=\"#\" title=\"collapse all docs\">[-]</a>\n+            <a id=\"toggle-all-docs\" href=\"#\" title=\"collapse all docs\">[&minus;]</a>\n         </span>\"##));\n \n         // Write `src` tag\n@@ -1629,6 +1629,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::Macro           => (\"macros\", \"Macros\"),\n                 ItemType::Primitive       => (\"primitives\", \"Primitive Types\"),\n                 ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n+                ItemType::AssociatedConst => (\"associated-consts\", \"Associated Constants\"),\n             };\n             try!(write!(w,\n                         \"<h2 id='{id}' class='section-header'>\\\n@@ -1799,23 +1800,23 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"{{\\n\"));\n         for t in &types {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, t, MethodLink::Anchor));\n+            try!(render_assoc_item(w, t, AssocItemLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n         if !types.is_empty() && !required.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &required {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m, MethodLink::Anchor));\n+            try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n         if !required.is_empty() && !provided.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &provided {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m, MethodLink::Anchor));\n+            try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n             try!(write!(w, \" {{ ... }}\\n\"));\n         }\n         try!(write!(w, \"}}\"));\n@@ -1831,7 +1832,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     ty = shortty(m),\n                     name = *m.name.as_ref().unwrap(),\n                     stab = m.stability_class()));\n-        try!(render_method(w, m, MethodLink::Anchor));\n+        try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n         try!(write!(w, \"</code></h3>\"));\n         try!(document(w, m));\n         Ok(())\n@@ -1871,7 +1872,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    try!(render_methods(w, it.def_id, MethodRender::All));\n+    try!(render_assoc_items(w, it.def_id, AssocItemRender::All));\n \n     let cache = cache();\n     try!(write!(w, \"\n@@ -1903,6 +1904,17 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     Ok(())\n }\n \n+fn assoc_const(w: &mut fmt::Formatter, it: &clean::Item,\n+               ty: &clean::Type, default: &Option<String>)\n+               -> fmt::Result {\n+    try!(write!(w, \"const {}\", it.name.as_ref().unwrap()));\n+    try!(write!(w, \": {}\", ty));\n+    if let Some(ref default) = *default {\n+        try!(write!(w, \" = {}\", default));\n+    }\n+    Ok(())\n+}\n+\n fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               bounds: &Vec<clean::TyParamBound>,\n               default: &Option<clean::Type>)\n@@ -1917,19 +1929,19 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_method(w: &mut fmt::Formatter, meth: &clean::Item,\n-                 link: MethodLink) -> fmt::Result {\n+fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n+                     link: AssocItemLink) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter, it: &clean::Item,\n               unsafety: ast::Unsafety, abi: abi::Abi,\n               g: &clean::Generics, selfty: &clean::SelfTy,\n-              d: &clean::FnDecl, link: MethodLink) -> fmt::Result {\n+              d: &clean::FnDecl, link: AssocItemLink) -> fmt::Result {\n         use syntax::abi::Abi;\n \n         let name = it.name.as_ref().unwrap();\n         let anchor = format!(\"#{}.{}\", shortty(it), name);\n         let href = match link {\n-            MethodLink::Anchor => anchor,\n-            MethodLink::GotoSource(did) => {\n+            AssocItemLink::Anchor => anchor,\n+            AssocItemLink::GotoSource(did) => {\n                 href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n             }\n         };\n@@ -1958,10 +1970,13 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item,\n             method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl,\n                    link)\n         }\n+        clean::AssociatedConstItem(ref ty, ref default) => {\n+            assoc_const(w, meth, ty, default)\n+        }\n         clean::AssociatedTypeItem(ref bounds, ref default) => {\n             assoc_type(w, meth, bounds, default)\n         }\n-        _ => panic!(\"render_method called on non-method\")\n+        _ => panic!(\"render_assoc_item called on non-associated-item\")\n     }\n }\n \n@@ -2001,7 +2016,7 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             try!(write!(w, \"</table>\"));\n         }\n     }\n-    render_methods(w, it.def_id, MethodRender::All)\n+    render_assoc_items(w, it.def_id, AssocItemRender::All)\n }\n \n fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n@@ -2100,7 +2115,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \"</table>\"));\n \n     }\n-    try!(render_methods(w, it.def_id, MethodRender::All));\n+    try!(render_assoc_items(w, it.def_id, AssocItemRender::All));\n     Ok(())\n }\n \n@@ -2184,19 +2199,19 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n #[derive(Copy, Clone)]\n-enum MethodLink {\n+enum AssocItemLink {\n     Anchor,\n     GotoSource(ast::DefId),\n }\n \n-enum MethodRender<'a> {\n+enum AssocItemRender<'a> {\n     All,\n     DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type },\n }\n \n-fn render_methods(w: &mut fmt::Formatter,\n-                  it: ast::DefId,\n-                  what: MethodRender) -> fmt::Result {\n+fn render_assoc_items(w: &mut fmt::Formatter,\n+                      it: ast::DefId,\n+                      what: AssocItemRender) -> fmt::Result {\n     let c = cache();\n     let v = match c.impls.get(&it) {\n         Some(v) => v,\n@@ -2207,21 +2222,21 @@ fn render_methods(w: &mut fmt::Formatter,\n     });\n     if !non_trait.is_empty() {\n         let render_header = match what {\n-            MethodRender::All => {\n+            AssocItemRender::All => {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                 true\n             }\n-            MethodRender::DerefFor { trait_, type_ } => {\n+            AssocItemRender::DerefFor { trait_, type_ } => {\n                 try!(write!(w, \"<h2 id='deref-methods'>Methods from \\\n                                     {}&lt;Target={}&gt;</h2>\", trait_, type_));\n                 false\n             }\n         };\n         for i in &non_trait {\n-            try!(render_impl(w, i, MethodLink::Anchor, render_header));\n+            try!(render_impl(w, i, AssocItemLink::Anchor, render_header));\n         }\n     }\n-    if let MethodRender::DerefFor { .. } = what {\n+    if let AssocItemRender::DerefFor { .. } = what {\n         return Ok(())\n     }\n     if !traits.is_empty() {\n@@ -2243,15 +2258,15 @@ fn render_methods(w: &mut fmt::Formatter,\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n+            try!(render_impl(w, i, AssocItemLink::GotoSource(did), true));\n         }\n         if !derived.is_empty() {\n             try!(write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n             </h3>\"));\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n+                try!(render_impl(w, i, AssocItemLink::GotoSource(did), true));\n             }\n         }\n     }\n@@ -2266,22 +2281,22 @@ fn render_deref_methods(w: &mut fmt::Formatter, impl_: &Impl) -> fmt::Result {\n             _ => None,\n         }\n     }).next().unwrap();\n-    let what = MethodRender::DerefFor { trait_: deref_type, type_: target };\n+    let what = AssocItemRender::DerefFor { trait_: deref_type, type_: target };\n     match *target {\n-        clean::ResolvedPath { did, .. } => render_methods(w, did, what),\n+        clean::ResolvedPath { did, .. } => render_assoc_items(w, did, what),\n         _ => {\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n                     let did = ast::DefId { krate: *c, node: prim.to_node_id() };\n-                    try!(render_methods(w, did, what));\n+                    try!(render_assoc_items(w, did, what));\n                 }\n             }\n             Ok(())\n         }\n     }\n }\n \n-fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n+fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n                render_header: bool) -> fmt::Result {\n     if render_header {\n         try!(write!(w, \"<h3 class='impl'><code>impl{} \",\n@@ -2300,13 +2315,13 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n     }\n \n     fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item,\n-                    link: MethodLink) -> fmt::Result {\n+                    link: AssocItemLink) -> fmt::Result {\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 try!(write!(w, \"<h4 id='method.{}' class='{}'><code>\",\n                             *item.name.as_ref().unwrap(),\n                             shortty(item)));\n-                try!(render_method(w, item, link));\n+                try!(render_assoc_item(w, item, link));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::TypedefItem(ref tydef) => {\n@@ -2317,6 +2332,14 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n+            clean::AssociatedConstItem(ref ty, ref default) => {\n+                let name = item.name.as_ref().unwrap();\n+                try!(write!(w, \"<h4 id='assoc_const.{}' class='{}'><code>\",\n+                            *name,\n+                            shortty(item)));\n+                try!(assoc_const(w, item, ty, default));\n+                try!(write!(w, \"</code></h4>\\n\"));\n+            }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let name = item.name.as_ref().unwrap();\n                 try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\",\n@@ -2327,7 +2350,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n             }\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n-        if let MethodLink::Anchor = link {\n+        if let AssocItemLink::Anchor = link {\n             document(w, item)\n         } else {\n             Ok(())\n@@ -2339,18 +2362,18 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n         try!(doctraititem(w, trait_item, link));\n     }\n \n-    fn render_default_methods(w: &mut fmt::Formatter,\n-                              did: ast::DefId,\n-                              t: &clean::Trait,\n-                              i: &clean::Impl) -> fmt::Result {\n+    fn render_default_items(w: &mut fmt::Formatter,\n+                            did: ast::DefId,\n+                            t: &clean::Trait,\n+                            i: &clean::Impl) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n             match i.items.iter().find(|m| { m.name == n }) {\n                 Some(..) => continue,\n                 None => {}\n             }\n \n-            try!(doctraititem(w, trait_item, MethodLink::GotoSource(did)));\n+            try!(doctraititem(w, trait_item, AssocItemLink::GotoSource(did)));\n         }\n         Ok(())\n     }\n@@ -2361,7 +2384,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n     // for them work.\n     if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n         if let Some(t) = cache().traits.get(&did) {\n-            try!(render_default_methods(w, did, t, &i.impl_));\n+            try!(render_default_items(w, did, t, &i.impl_));\n         }\n     }\n     try!(write!(w, \"</div>\"));\n@@ -2458,7 +2481,7 @@ fn item_primitive(w: &mut fmt::Formatter,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n     try!(document(w, it));\n-    render_methods(w, it.def_id, MethodRender::All)\n+    render_assoc_items(w, it.def_id, AssocItemRender::All)\n }\n \n fn get_basic_keywords() -> &'static str {"}, {"sha": "b907e9e20b69867df2040215fb2b2ad68f8158cf", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -392,7 +392,7 @@ a {\n     text-decoration: underline;\n }\n \n-.content span.trait, .content a.trait, .block a.current.trait { color: #ed9603; }\n+.content span.trait, .content a.trait, .block a.current.trait { color: #8866ff; }\n .content span.mod, .content a.mod, block a.current.mod { color: #4d76ae; }\n .content span.enum, .content a.enum, .block a.current.enum { color: #5e9766; }\n .content span.struct, .content a.struct, .block a.current.struct { color: #e53700; }"}, {"sha": "c2a59278a86dc79dbaff558c130461602299871f", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -808,20 +808,20 @@\n \n     $(\"#toggle-all-docs\").on(\"click\", function() {\n         var toggle = $(\"#toggle-all-docs\");\n-        if (toggle.html() == \"[-]\") {\n-            toggle.html(\"[+]\");\n+        if (toggle.html() == \"[&minus;]\") {\n+            toggle.html(\"[&plus;]\");\n             toggle.attr(\"title\", \"expand all docs\");\n             $(\".docblock\").hide();\n             $(\".toggle-label\").show();\n             $(\".toggle-wrapper\").addClass(\"collapsed\");\n-            $(\".collapse-toggle\").children(\".inner\").html(\"+\");\n+            $(\".collapse-toggle\").children(\".inner\").html(\"&plus;\");\n         } else {\n-            toggle.html(\"[-]\");\n+            toggle.html(\"[&minus;]\");\n             toggle.attr(\"title\", \"collapse all docs\");\n             $(\".docblock\").show();\n             $(\".toggle-label\").hide();\n             $(\".toggle-wrapper\").removeClass(\"collapsed\");\n-            $(\".collapse-toggle\").children(\".inner\").html(\"-\");\n+            $(\".collapse-toggle\").children(\".inner\").html(\"&minus;\");\n         }\n     });\n \n@@ -835,20 +835,20 @@\n             if (relatedDoc.is(\":visible\")) {\n                 relatedDoc.slideUp({duration:'fast', easing:'linear'});\n                 toggle.parent(\".toggle-wrapper\").addClass(\"collapsed\");\n-                toggle.children(\".inner\").html(\"+\");\n+                toggle.children(\".inner\").html(\"&plus;\");\n                 toggle.children(\".toggle-label\").fadeIn();\n             } else {\n                 relatedDoc.slideDown({duration:'fast', easing:'linear'});\n                 toggle.parent(\".toggle-wrapper\").removeClass(\"collapsed\");\n-                toggle.children(\".inner\").html(\"-\");\n+                toggle.children(\".inner\").html(\"&minus;\");\n                 toggle.children(\".toggle-label\").hide();\n             }\n         }\n     });\n \n     $(function() {\n         var toggle = $(\"<a/>\", {'href': 'javascript:void(0)', 'class': 'collapse-toggle'})\n-            .html(\"[<span class='inner'>-</span>]\");\n+            .html(\"[<span class='inner'>&minus;</span>]\");\n \n         $(\".method\").each(function() {\n             if ($(this).next().is(\".docblock\") ||"}, {"sha": "93aa74d7005f6d8989cbae865218d8d421165596", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -198,7 +198,7 @@ impl fmt::Display for Toc {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use super::{TocBuilder, Toc, TocEntry};\n \n     #[test]"}, {"sha": "74c16127f41ccac87c3bf3aba6d2acb37b644c7e", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -184,7 +184,8 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             // Primitives are never stripped\n             clean::PrimitiveItem(..) => {}\n \n-            // Associated types are never stripped\n+            // Associated consts and types are never stripped\n+            clean::AssociatedConstItem(..) |\n             clean::AssociatedTypeItem(..) => {}\n         }\n "}, {"sha": "4841f36c7f74719d15e0a51fb20209f4399351f5", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -943,7 +943,6 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     fn len(&self) -> usize { self.table.size() }\n }\n \n-#[unsafe_destructor]\n impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> {\n     fn drop(&mut self) {\n         for _ in self.by_ref() {}\n@@ -986,7 +985,6 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<K, V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n         if self.capacity == 0 || self.capacity == mem::POST_DROP_USIZE {"}, {"sha": "8b90fce6fc4fc075709c354600e9d1daf4b18782", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -117,15 +117,17 @@ impl DynamicLibrary {\n }\n \n #[cfg(all(test, not(target_os = \"ios\")))]\n-mod test {\n+mod tests {\n     use super::*;\n     use prelude::v1::*;\n     use libc;\n     use mem;\n     use path::Path;\n \n     #[test]\n-    #[cfg_attr(any(windows, target_os = \"android\"), ignore)] // FIXME #8818, #10379\n+    #[cfg_attr(any(windows,\n+                   target_os = \"android\",  // FIXME #10379\n+                   target_env = \"musl\"), ignore)]\n     fn test_loading_cosine() {\n         // The math library does not need to be loaded since it is already\n         // statically linked in"}, {"sha": "2b15a4ff83ed13a94939240b68d5c45a44f6e056", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 275, "deletions": 19, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -20,6 +20,7 @@\n use core::prelude::*;\n \n use fmt;\n+use ffi::OsString;\n use io::{self, Error, ErrorKind, SeekFrom, Seek, Read, Write};\n use path::{Path, PathBuf};\n use sys::fs2 as fs_imp;\n@@ -146,6 +147,20 @@ pub struct OpenOptions(fs_imp::OpenOptions);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Permissions(fs_imp::FilePermissions);\n \n+/// An structure representing a type of file with accessors for each file type.\n+#[unstable(feature = \"file_type\", reason = \"recently added API\")]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct FileType(fs_imp::FileType);\n+\n+/// A builder used to create directories in various manners.\n+///\n+/// This builder also supports platform-specific options.\n+#[unstable(feature = \"dir_builder\", reason = \"recently added API\")]\n+pub struct DirBuilder {\n+    inner: fs_imp::DirBuilder,\n+    recursive: bool,\n+}\n+\n impl File {\n     /// Attempts to open a file in read-only mode.\n     ///\n@@ -485,6 +500,12 @@ impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n }\n \n impl Metadata {\n+    /// Returns the file type for this metadata.\n+    #[unstable(feature = \"file_type\", reason = \"recently added API\")]\n+    pub fn file_type(&self) -> FileType {\n+        FileType(self.0.file_type())\n+    }\n+\n     /// Returns whether this metadata is for a directory.\n     ///\n     /// # Examples\n@@ -500,7 +521,7 @@ impl Metadata {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_dir(&self) -> bool { self.0.is_dir() }\n+    pub fn is_dir(&self) -> bool { self.file_type().is_dir() }\n \n     /// Returns whether this metadata is for a regular file.\n     ///\n@@ -517,7 +538,7 @@ impl Metadata {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_file(&self) -> bool { self.0.is_file() }\n+    pub fn is_file(&self) -> bool { self.file_type().is_file() }\n \n     /// Returns the size of the file, in bytes, this metadata is for.\n     ///\n@@ -562,7 +583,11 @@ impl Metadata {\n                reason = \"the return type of u64 is not quite appropriate for \\\n                          this method and may change if the standard library \\\n                          gains a type to represent a moment in time\")]\n-    pub fn accessed(&self) -> u64 { self.0.accessed() }\n+    #[deprecated(since = \"1.1.0\",\n+                 reason = \"use os::platform::fs::MetadataExt extension traits\")]\n+    pub fn accessed(&self) -> u64 {\n+        self.adjust_time(self.0.accessed())\n+    }\n \n     /// Returns the most recent modification time for a file.\n     ///\n@@ -571,7 +596,21 @@ impl Metadata {\n                reason = \"the return type of u64 is not quite appropriate for \\\n                          this method and may change if the standard library \\\n                          gains a type to represent a moment in time\")]\n-    pub fn modified(&self) -> u64 { self.0.modified() }\n+    #[deprecated(since = \"1.1.0\",\n+                 reason = \"use os::platform::fs::MetadataExt extension traits\")]\n+    pub fn modified(&self) -> u64 {\n+        self.adjust_time(self.0.modified())\n+    }\n+\n+    fn adjust_time(&self, val: u64) -> u64 {\n+        // FILETIME (what `val` represents) is in 100ns intervals and there are\n+        // 10000 intervals in a millisecond.\n+        if cfg!(windows) {val / 10000} else {val}\n+    }\n+}\n+\n+impl AsInner<fs_imp::FileAttr> for Metadata {\n+    fn as_inner(&self) -> &fs_imp::FileAttr { &self.0 }\n }\n \n impl Permissions {\n@@ -624,6 +663,18 @@ impl Permissions {\n     }\n }\n \n+#[unstable(feature = \"file_type\", reason = \"recently added API\")]\n+impl FileType {\n+    /// Test whether this file type represents a directory.\n+    pub fn is_dir(&self) -> bool { self.0.is_dir() }\n+\n+    /// Test whether this file type represents a regular file.\n+    pub fn is_file(&self) -> bool { self.0.is_file() }\n+\n+    /// Test whether this file type represents a symbolic link.\n+    pub fn is_symlink(&self) -> bool { self.0.is_symlink() }\n+}\n+\n impl FromInner<fs_imp::FilePermissions> for Permissions {\n     fn from_inner(f: fs_imp::FilePermissions) -> Permissions {\n         Permissions(f)\n@@ -674,6 +725,47 @@ impl DirEntry {\n     /// The exact text, of course, depends on what files you have in `.`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn path(&self) -> PathBuf { self.0.path() }\n+\n+    /// Return the metadata for the file that this entry points at.\n+    ///\n+    /// This function will not traverse symlinks if this entry points at a\n+    /// symlink.\n+    ///\n+    /// # Platform behavior\n+    ///\n+    /// On Windows this function is cheap to call (no extra system calls\n+    /// needed), but on Unix platforms this function is the equivalent of\n+    /// calling `symlink_metadata` on the path.\n+    #[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+    pub fn metadata(&self) -> io::Result<Metadata> {\n+        self.0.metadata().map(Metadata)\n+    }\n+\n+    /// Return the file type for the file that this entry points at.\n+    ///\n+    /// This function will not traverse symlinks if this entry points at a\n+    /// symlink.\n+    ///\n+    /// # Platform behavior\n+    ///\n+    /// On Windows and most Unix platforms this function is free (no extra\n+    /// system calls needed), but some Unix platforms may require the equivalent\n+    /// call to `symlink_metadata` to learn about the target file type.\n+    #[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        self.0.file_type().map(FileType)\n+    }\n+\n+    /// Returns the bare file name of this directory entry without any other\n+    /// leading path component.\n+    #[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+    pub fn file_name(&self) -> OsString {\n+        self.0.file_name()\n+    }\n+}\n+\n+impl AsInner<fs_imp::DirEntry> for DirEntry {\n+    fn as_inner(&self) -> &fs_imp::DirEntry { &self.0 }\n }\n \n /// Removes a file from the underlying filesystem.\n@@ -731,6 +823,25 @@ pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n     fs_imp::stat(path.as_ref()).map(Metadata)\n }\n \n+/// Query the metadata about a file without following symlinks.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// #![feature(symlink_metadata)]\n+/// # fn foo() -> std::io::Result<()> {\n+/// use std::fs;\n+///\n+/// let attr = try!(fs::symlink_metadata(\"/some/file/path.txt\"));\n+/// // inspect attr ...\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[unstable(feature = \"symlink_metadata\", reason = \"recently added API\")]\n+pub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n+    fs_imp::lstat(path.as_ref()).map(Metadata)\n+}\n+\n /// Rename a file or directory to a new name.\n ///\n /// # Errors\n@@ -869,6 +980,13 @@ pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n     fs_imp::readlink(path.as_ref())\n }\n \n+/// Returns the canonical form of a path with all intermediate components\n+/// normalized and symbolic links resolved.\n+#[unstable(feature = \"fs_canonicalize\", reason = \"recently added API\")]\n+pub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n+    fs_imp::canonicalize(path.as_ref())\n+}\n+\n /// Creates a new, empty directory at the provided path\n ///\n /// # Errors\n@@ -888,7 +1006,7 @@ pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n-    fs_imp::mkdir(path.as_ref())\n+    DirBuilder::new().create(path.as_ref())\n }\n \n /// Recursively create a directory and all of its parent components if they\n@@ -913,10 +1031,7 @@ pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n-    let path = path.as_ref();\n-    if path == Path::new(\"\") || path.is_dir() { return Ok(()) }\n-    if let Some(p) = path.parent() { try!(create_dir_all(p)) }\n-    create_dir(path)\n+    DirBuilder::new().recursive(true).create(path.as_ref())\n }\n \n /// Removes an existing, empty directory.\n@@ -966,19 +1081,14 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n     let path = path.as_ref();\n     for child in try!(read_dir(path)) {\n         let child = try!(child).path();\n-        let stat = try!(lstat(&*child));\n+        let stat = try!(symlink_metadata(&*child));\n         if stat.is_dir() {\n             try!(remove_dir_all(&*child));\n         } else {\n             try!(remove_file(&*child));\n         }\n     }\n-    return remove_dir(path);\n-\n-    #[cfg(unix)]\n-    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::lstat(path) }\n-    #[cfg(windows)]\n-    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::stat(path) }\n+    remove_dir(path)\n }\n \n /// Returns an iterator over the entries within a directory.\n@@ -1073,11 +1183,37 @@ impl Iterator for WalkDir {\n pub trait PathExt {\n     /// Gets information on the file, directory, etc at this path.\n     ///\n-    /// Consult the `fs::stat` documentation for more info.\n+    /// Consult the `fs::metadata` documentation for more info.\n     ///\n-    /// This call preserves identical runtime/error semantics with `file::stat`.\n+    /// This call preserves identical runtime/error semantics with\n+    /// `fs::metadata`.\n     fn metadata(&self) -> io::Result<Metadata>;\n \n+    /// Gets information on the file, directory, etc at this path.\n+    ///\n+    /// Consult the `fs::symlink_metadata` documentation for more info.\n+    ///\n+    /// This call preserves identical runtime/error semantics with\n+    /// `fs::symlink_metadata`.\n+    fn symlink_metadata(&self) -> io::Result<Metadata>;\n+\n+    /// Returns the canonical form of a path, normalizing all components and\n+    /// eliminate all symlinks.\n+    ///\n+    /// This call preserves identical runtime/error semantics with\n+    /// `fs::canonicalize`.\n+    fn canonicalize(&self) -> io::Result<PathBuf>;\n+\n+    /// Reads the symlink at this path.\n+    ///\n+    /// For more information see `fs::read_link`.\n+    fn read_link(&self) -> io::Result<PathBuf>;\n+\n+    /// Reads the directory at this path.\n+    ///\n+    /// For more information see `fs::read_dir`.\n+    fn read_dir(&self) -> io::Result<ReadDir>;\n+\n     /// Boolean value indicator whether the underlying file exists on the local\n     /// filesystem. Returns false in exactly the cases where `fs::stat` fails.\n     fn exists(&self) -> bool;\n@@ -1098,12 +1234,16 @@ pub trait PathExt {\n \n impl PathExt for Path {\n     fn metadata(&self) -> io::Result<Metadata> { metadata(self) }\n-\n+    fn symlink_metadata(&self) -> io::Result<Metadata> { symlink_metadata(self) }\n+    fn canonicalize(&self) -> io::Result<PathBuf> { canonicalize(self) }\n+    fn read_link(&self) -> io::Result<PathBuf> { read_link(self) }\n+    fn read_dir(&self) -> io::Result<ReadDir> { read_dir(self) }\n     fn exists(&self) -> bool { metadata(self).is_ok() }\n \n     fn is_file(&self) -> bool {\n         metadata(self).map(|s| s.is_file()).unwrap_or(false)\n     }\n+\n     fn is_dir(&self) -> bool {\n         metadata(self).map(|s| s.is_dir()).unwrap_or(false)\n     }\n@@ -1152,6 +1292,52 @@ pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions) -> io::Result\n     fs_imp::set_perm(path.as_ref(), perm.0)\n }\n \n+impl DirBuilder {\n+    /// Creates a new set of options with default mode/security settings for all\n+    /// platforms and also non-recursive.\n+    pub fn new() -> DirBuilder {\n+        DirBuilder {\n+            inner: fs_imp::DirBuilder::new(),\n+            recursive: false,\n+        }\n+    }\n+\n+    /// Indicate that directories create should be created recursively, creating\n+    /// all parent directories if they do not exist with the same security and\n+    /// permissions settings.\n+    ///\n+    /// This option defaults to `false`\n+    pub fn recursive(&mut self, recursive: bool) -> &mut Self {\n+        self.recursive = recursive;\n+        self\n+    }\n+\n+    /// Create the specified directory with the options configured in this\n+    /// builder.\n+    pub fn create<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        let path = path.as_ref();\n+        if self.recursive {\n+            self.create_dir_all(path)\n+        } else {\n+            self.inner.mkdir(path)\n+        }\n+    }\n+\n+    fn create_dir_all(&self, path: &Path) -> io::Result<()> {\n+        if path == Path::new(\"\") || path.is_dir() { return Ok(()) }\n+        if let Some(p) = path.parent() {\n+            try!(self.create_dir_all(p))\n+        }\n+        self.inner.mkdir(path)\n+    }\n+}\n+\n+impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n+    fn as_inner_mut(&mut self) -> &mut fs_imp::DirBuilder {\n+        &mut self.inner\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     #![allow(deprecated)] //rand\n@@ -1924,4 +2110,74 @@ mod tests {\n         let path = tmpdir.join(\"file\");\n         check!(fs::create_dir_all(&path.join(\"a/\")));\n     }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn realpath_works() {\n+        let tmpdir = tmpdir();\n+        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+        let file = tmpdir.join(\"test\");\n+        let dir = tmpdir.join(\"test2\");\n+        let link = dir.join(\"link\");\n+        let linkdir = tmpdir.join(\"test3\");\n+\n+        File::create(&file).unwrap();\n+        fs::create_dir(&dir).unwrap();\n+        fs::soft_link(&file, &link).unwrap();\n+        fs::soft_link(&dir, &linkdir).unwrap();\n+\n+        assert!(link.symlink_metadata().unwrap().file_type().is_symlink());\n+\n+        assert_eq!(fs::canonicalize(&tmpdir).unwrap(), tmpdir);\n+        assert_eq!(fs::canonicalize(&file).unwrap(), file);\n+        assert_eq!(fs::canonicalize(&link).unwrap(), file);\n+        assert_eq!(fs::canonicalize(&linkdir).unwrap(), dir);\n+        assert_eq!(fs::canonicalize(&linkdir.join(\"link\")).unwrap(), file);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn realpath_works_tricky() {\n+        let tmpdir = tmpdir();\n+        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+\n+        let a = tmpdir.join(\"a\");\n+        let b = a.join(\"b\");\n+        let c = b.join(\"c\");\n+        let d = a.join(\"d\");\n+        let e = d.join(\"e\");\n+        let f = a.join(\"f\");\n+\n+        fs::create_dir_all(&b).unwrap();\n+        fs::create_dir_all(&d).unwrap();\n+        File::create(&f).unwrap();\n+        fs::soft_link(\"../d/e\", &c).unwrap();\n+        fs::soft_link(\"../f\", &e).unwrap();\n+\n+        assert_eq!(fs::canonicalize(&c).unwrap(), f);\n+        assert_eq!(fs::canonicalize(&e).unwrap(), f);\n+    }\n+\n+    #[test]\n+    fn dir_entry_methods() {\n+        let tmpdir = tmpdir();\n+\n+        fs::create_dir_all(&tmpdir.join(\"a\")).unwrap();\n+        File::create(&tmpdir.join(\"b\")).unwrap();\n+\n+        for file in tmpdir.path().read_dir().unwrap().map(|f| f.unwrap()) {\n+            let fname = file.file_name();\n+            match fname.to_str() {\n+                Some(\"a\") => {\n+                    assert!(file.file_type().unwrap().is_dir());\n+                    assert!(file.metadata().unwrap().is_dir());\n+                }\n+                Some(\"b\") => {\n+                    assert!(file.file_type().unwrap().is_file());\n+                    assert!(file.metadata().unwrap().is_file());\n+                }\n+                f => panic!(\"unknown file name: {:?}\", f),\n+            }\n+        }\n+    }\n }"}, {"sha": "ed6023b2b81310013bd70277bb02e4cde06441ee", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -292,7 +292,6 @@ impl<W: Write+Seek> Seek for BufWriter<W> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<W: Write> Drop for BufWriter<W> {\n     fn drop(&mut self) {\n         if self.inner.is_some() {"}, {"sha": "561c37ad950b05708f6e4b6f53472a1fbb1b2504", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -70,8 +70,7 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n     where F: FnOnce(&mut Vec<u8>) -> Result<usize>\n {\n     struct Guard<'a> { s: &'a mut Vec<u8>, len: usize }\n-    #[unsafe_destructor]\n-    impl<'a> Drop for Guard<'a> {\n+        impl<'a> Drop for Guard<'a> {\n         fn drop(&mut self) {\n             unsafe { self.s.set_len(self.len); }\n         }"}, {"sha": "a9dab8191fd9c90dfa43d3a562e1fc532e6fab84", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -418,7 +418,7 @@ pub fn _print(args: fmt::Arguments) {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use thread;\n     use super::*;\n "}, {"sha": "d797e757a483ecf687d686327ed876a64c987223", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -102,7 +102,7 @@ impl Write for Sink {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n \n     use io::prelude::*;"}, {"sha": "6a84c6ace47b4d397875b8deab57a042e1196950", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -107,27 +107,27 @@\n #![doc(test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n #![feature(alloc)]\n+#![feature(allow_internal_unstable)]\n+#![feature(associated_consts)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(debug_builders)]\n+#![feature(into_cow)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n+#![feature(macro_reexport)]\n #![feature(optin_builtin_traits)]\n #![feature(rand)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n+#![feature(std_misc)]\n+#![feature(str_char)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(unsafe_destructor)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n-#![feature(macro_reexport)]\n #![feature(unique)]\n-#![feature(allow_internal_unstable)]\n-#![feature(str_char)]\n-#![feature(into_cow)]\n-#![feature(std_misc)]\n-#![feature(slice_patterns)]\n-#![feature(debug_builders)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(zero_one)]\n #![cfg_attr(test, feature(float_from_str_radix))]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n@@ -308,13 +308,12 @@ mod std {\n     pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n-    pub use option; // used for bitflags!{}\n+    pub use option; // used for thread_local!{}\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]\n     pub use cell; // used for tls!\n     pub use thread; // used for thread_local!\n     pub use marker;  // used for tls!\n-    pub use ops; // used for bitflags!\n \n     // The test runner calls ::std::env::args() but really wants realstd\n     #[cfg(test)] pub use realstd::env as env;"}, {"sha": "fcebe9c5e98d60e7c59c8df0c655267af8e9af8c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -38,30 +38,6 @@\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n-#[cfg(stage0)]\n-macro_rules! panic {\n-    () => ({\n-        panic!(\"explicit panic\")\n-    });\n-    ($msg:expr) => ({\n-        $crate::rt::begin_unwind($msg, {\n-            // static requires less code at runtime, more constant data\n-            static _FILE_LINE: (&'static str, usize) = (file!(), line!() as usize);\n-            &_FILE_LINE\n-        })\n-    });\n-    ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::rt::begin_unwind_fmt(format_args!($fmt, $($arg)+), {\n-            // The leading _'s are to avoid dead code warnings if this is\n-            // used inside a dead function. Just `#[allow(dead_code)]` is\n-            // insufficient, since the user may have\n-            // `#[forbid(dead_code)]` and which cannot be overridden.\n-            static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-            &_FILE_LINE\n-        })\n-    });\n-}\n-\n /// The entry point for panic of Rust tasks.\n ///\n /// This macro is used to inject panic into a Rust task, causing the task to\n@@ -84,7 +60,6 @@ macro_rules! panic {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n-#[cfg(not(stage0))]\n macro_rules! panic {\n     () => ({\n         panic!(\"explicit panic\")"}, {"sha": "b0bf9d0f8062674785c21a37fdb27c82ca530cfe", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -41,7 +41,7 @@ pub enum SocketAddr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV4 { inner: libc::sockaddr_in }\n \n-/// An IPv6 socket address\n+/// An IPv6 socket address.\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV6 { inner: libc::sockaddr_in6 }\n@@ -56,7 +56,7 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Gets the IP address associated with this socket address.\n+    /// Returns the IP address associated with this socket address.\n     #[unstable(feature = \"ip_addr\", reason = \"recent addition\")]\n     pub fn ip(&self) -> IpAddr {\n         match *self {\n@@ -65,7 +65,7 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Gets the port number associated with this socket address\n+    /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 {\n         match *self {\n@@ -89,15 +89,15 @@ impl SocketAddrV4 {\n         }\n     }\n \n-    /// Gets the IP address associated with this socket address.\n+    /// Returns the IP address associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv4Addr {\n         unsafe {\n             &*(&self.inner.sin_addr as *const libc::in_addr as *const Ipv4Addr)\n         }\n     }\n \n-    /// Gets the port number associated with this socket address\n+    /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 { ntoh(self.inner.sin_port) }\n }\n@@ -120,24 +120,24 @@ impl SocketAddrV6 {\n         }\n     }\n \n-    /// Gets the IP address associated with this socket address.\n+    /// Returns the IP address associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv6Addr {\n         unsafe {\n             &*(&self.inner.sin6_addr as *const libc::in6_addr as *const Ipv6Addr)\n         }\n     }\n \n-    /// Gets the port number associated with this socket address\n+    /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 { ntoh(self.inner.sin6_port) }\n \n-    /// Gets scope ID associated with this address, corresponding to the\n+    /// Returns scope ID associated with this address, corresponding to the\n     /// `sin6_flowinfo` field in C.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn flowinfo(&self) -> u32 { ntoh(self.inner.sin6_flowinfo) }\n \n-    /// Gets scope ID associated with this address, corresponding to the\n+    /// Returns scope ID associated with this address, corresponding to the\n     /// `sin6_scope_id` field in C.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn scope_id(&self) -> u32 { ntoh(self.inner.sin6_scope_id) }"}, {"sha": "9fd69840f7f054ee93927945b2211297bec44463", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -60,7 +60,7 @@ pub enum Ipv6MulticastScope {\n impl Ipv4Addr {\n     /// Creates a new IPv4 address from four eight-bit octets.\n     ///\n-    /// The result will represent the IP address a.b.c.d\n+    /// The result will represent the IP address `a`.`b`.`c`.`d`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n         Ipv4Addr {\n@@ -73,19 +73,19 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Returns the four eight-bit integers that make up this address\n+    /// Returns the four eight-bit integers that make up this address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn octets(&self) -> [u8; 4] {\n         let bits = ntoh(self.inner.s_addr);\n         [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]\n     }\n \n-    /// Returns true for the special 'unspecified' address 0.0.0.0\n+    /// Returns true for the special 'unspecified' address 0.0.0.0.\n     pub fn is_unspecified(&self) -> bool {\n         self.inner.s_addr == 0\n     }\n \n-    /// Returns true if this is a loopback address (127.0.0.0/8)\n+    /// Returns true if this is a loopback address (127.0.0.0/8).\n     pub fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n     }\n@@ -106,7 +106,7 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Returns true if the address is link-local (169.254.0.0/16)\n+    /// Returns true if the address is link-local (169.254.0.0/16).\n     pub fn is_link_local(&self) -> bool {\n         self.octets()[0] == 169 && self.octets()[1] == 254\n     }\n@@ -116,7 +116,7 @@ impl Ipv4Addr {\n     /// Non-globally-routable networks include the private networks (10.0.0.0/8,\n     /// 172.16.0.0/12 and 192.168.0.0/16), the loopback network (127.0.0.0/8),\n     /// the link-local network (169.254.0.0/16), the broadcast address (255.255.255.255/32) and\n-    /// the test networks used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24)\n+    /// the test networks used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24).\n     pub fn is_global(&self) -> bool {\n         !self.is_private() && !self.is_loopback() && !self.is_link_local() &&\n         !self.is_broadcast() && !self.is_documentation()\n@@ -131,13 +131,13 @@ impl Ipv4Addr {\n \n     /// Returns true if this is a broadcast address.\n     ///\n-    /// A broadcast address has all octets set to 255 as defined in RFC 919\n+    /// A broadcast address has all octets set to 255 as defined in RFC 919.\n     pub fn is_broadcast(&self) -> bool {\n         self.octets()[0] == 255 && self.octets()[1] == 255 &&\n         self.octets()[2] == 255 && self.octets()[3] == 255\n     }\n \n-    /// Returns true if this address is in a range designated for documentation\n+    /// Returns true if this address is in a range designated for documentation.\n     ///\n     /// This is defined in RFC 5737\n     /// - 192.0.2.0/24 (TEST-NET-1)\n@@ -152,7 +152,7 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Converts this address to an IPv4-compatible IPv6 address\n+    /// Converts this address to an IPv4-compatible IPv6 address.\n     ///\n     /// a.b.c.d becomes ::a.b.c.d\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -162,7 +162,7 @@ impl Ipv4Addr {\n                       ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n     }\n \n-    /// Converts this address to an IPv4-mapped IPv6 address\n+    /// Converts this address to an IPv4-mapped IPv6 address.\n     ///\n     /// a.b.c.d becomes ::ffff:a.b.c.d\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -247,7 +247,7 @@ impl FromInner<libc::in_addr> for Ipv4Addr {\n impl Ipv6Addr {\n     /// Creates a new IPv6 address from eight 16-bit segments.\n     ///\n-    /// The result will represent the IP address a:b:c:d:e:f:g:h\n+    /// The result will represent the IP address a:b:c:d:e:f:g:h.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n                h: u16) -> Ipv6Addr {\n@@ -259,7 +259,7 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Returns the eight 16-bit segments that make up this address\n+    /// Returns the eight 16-bit segments that make up this address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn segments(&self) -> [u16; 8] {\n         [ntoh(self.inner.s6_addr[0]),\n@@ -272,12 +272,12 @@ impl Ipv6Addr {\n          ntoh(self.inner.s6_addr[7])]\n     }\n \n-    /// Returns true for the special 'unspecified' address ::\n+    /// Returns true for the special 'unspecified' address ::.\n     pub fn is_unspecified(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 0]\n     }\n \n-    /// Returns true if this is a loopback address (::1)\n+    /// Returns true if this is a loopback address (::1).\n     pub fn is_loopback(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 1]\n     }\n@@ -295,25 +295,25 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Returns true if this is a unique local address (IPv6)\n+    /// Returns true if this is a unique local address (IPv6).\n     ///\n-    /// Unique local addresses are defined in RFC4193 and have the form fc00::/7\n+    /// Unique local addresses are defined in RFC4193 and have the form fc00::/7.\n     pub fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n     }\n \n-    /// Returns true if the address is unicast and link-local (fe80::/10)\n+    /// Returns true if the address is unicast and link-local (fe80::/10).\n     pub fn is_unicast_link_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n     }\n \n     /// Returns true if this is a deprecated unicast site-local address (IPv6\n-    /// fec0::/10)\n+    /// fec0::/10).\n     pub fn is_unicast_site_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfec0\n     }\n \n-    /// Returns true if the address is a globally routable unicast address\n+    /// Returns true if the address is a globally routable unicast address.\n     ///\n     /// Non-globally-routable unicast addresses include the loopback address,\n     /// the link-local addresses, the deprecated site-local addresses and the"}, {"sha": "2e7c0a2c80e59bac54a00eeaf686df2bbe70a169", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Networking primitives for TCP/UDP communication\n-//!\n-//! > **NOTE**: This module is very much a work in progress and is under active\n-//! > development.\n+//! Networking primitives for TCP/UDP communication.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "130e1eee8f924e1a456f93e923da329d186663bd", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -125,7 +125,7 @@ impl TcpStream {\n         self.0.duplicate().map(TcpStream)\n     }\n \n-    /// Sets the nodelay flag on this connection to the boolean specified\n+    /// Sets the nodelay flag on this connection to the boolean specified.\n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n         self.0.set_nodelay(nodelay)\n     }"}, {"sha": "0b04ecb1b7228565577b5a958348922a5e596db6", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -50,8 +50,8 @@ pub struct UdpSocket(net_imp::UdpSocket);\n impl UdpSocket {\n     /// Creates a UDP socket from the given address.\n     ///\n-    /// Address type can be any implementor of `ToSocketAddr` trait. See its\n-    /// documentation for concrete examples.\n+    /// The address type can be any implementor of `ToSocketAddr` trait. See\n+    /// its documentation for concrete examples.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n@@ -64,8 +64,8 @@ impl UdpSocket {\n         self.0.recv_from(buf)\n     }\n \n-    /// Sends data on the socket to the given address. Returns nothing on\n-    /// success.\n+    /// Sends data on the socket to the given address. On success, returns the\n+    /// number of bytes written.\n     ///\n     /// Address type can be any implementor of `ToSocketAddrs` trait. See its\n     /// documentation for concrete examples.\n@@ -95,34 +95,34 @@ impl UdpSocket {\n         self.0.duplicate().map(UdpSocket)\n     }\n \n-    /// Sets the broadcast flag on or off\n+    /// Sets the broadcast flag on or off.\n     pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n         self.0.set_broadcast(on)\n     }\n \n-    /// Sets the multicast loop flag to the specified value\n+    /// Sets the multicast loop flag to the specified value.\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n     pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {\n         self.0.set_multicast_loop(on)\n     }\n \n-    /// Joins a multicast IP address (becomes a member of it)\n+    /// Joins a multicast IP address (becomes a member of it).\n     pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n         self.0.join_multicast(multi)\n     }\n \n-    /// Leaves a multicast IP address (drops membership from it)\n+    /// Leaves a multicast IP address (drops membership from it).\n     pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n         self.0.leave_multicast(multi)\n     }\n \n-    /// Sets the multicast TTL\n+    /// Sets the multicast TTL.\n     pub fn set_multicast_time_to_live(&self, ttl: i32) -> io::Result<()> {\n         self.0.multicast_time_to_live(ttl)\n     }\n \n-    /// Sets this socket's TTL\n+    /// Sets this socket's TTL.\n     pub fn set_time_to_live(&self, ttl: i32) -> io::Result<()> {\n         self.0.time_to_live(ttl)\n     }"}, {"sha": "346a903c4d9a9b7f99581553a769ed64a7805fb7", "filename": "src/libstd/os/android/mod.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! OS-specific functionality\n+//! Android-specific definitions\n \n-#![stable(feature = \"os\", since = \"1.0.0\")]\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n \n-#[cfg(unix)] pub use sys::ext as unix;\n-#[cfg(windows)] pub use sys::ext as windows;\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}", "previous_filename": "src/libstd/os.rs"}, {"sha": "538ed7c4688c77f12a58ce6b85a9002fd9b14399", "filename": "src/libstd/os/android/raw.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Android-specific raw type definitions\n+\n+use os::raw::{c_uint, c_uchar, c_ulonglong, c_longlong, c_ulong};\n+use os::unix::raw::{uid_t, gid_t};\n+\n+pub type blkcnt_t = u32;\n+pub type blksize_t = u32;\n+pub type dev_t = u32;\n+pub type ino_t = u32;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i32;\n+pub type time_t = i32;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: c_ulonglong,\n+    pub __pad0: [c_uchar; 4],\n+    pub __st_ino: ino_t,\n+    pub st_mode: c_uint,\n+    pub st_nlink: c_uint,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: c_ulonglong,\n+    pub __pad3: [c_uchar; 4],\n+    pub st_size: c_longlong,\n+    pub st_blksize: blksize_t,\n+    pub st_blocks: c_ulonglong,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_ulong,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_ulong,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_ulong,\n+    pub st_ino: c_ulonglong,\n+}"}, {"sha": "01ea542b3b71379dea8691638c32c7e1c960b793", "filename": "src/libstd/os/bitrig/mod.rs", "status": "renamed", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -8,18 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that `#[unsafe_destructor]` attribute is gated by `unsafe_destructor`\n-// feature gate.\n-//\n-// (This test can be removed entirely when we remove the\n-// `unsafe_destructor` feature itself.)\n+//! Bitrig-specific definitions\n \n-struct D<'a>(&'a u32);\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n \n-#[unsafe_destructor]\n-//~^ ERROR `#[unsafe_destructor]` does nothing anymore\n-impl<'a> Drop for D<'a> {\n-    fn drop(&mut self) { }\n-}\n+pub mod raw;\n \n-pub fn main() { }\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}", "previous_filename": "src/test/compile-fail/gated-unsafe-destructor.rs"}, {"sha": "aebc21aa71856c701a04fa38f4a4ead6cd30a05c", "filename": "src/libstd/os/bitrig/raw.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Bitrig-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = u32;\n+pub type dev_t = i32;\n+pub type fflags_t = u32; // type not declared, but struct stat have u_int32_t\n+pub type ino_t = u64;\n+pub type mode_t = u32;\n+pub type nlink_t = u32;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_mode: mode_t,\n+    pub st_dev: dev_t,\n+    pub st_ino: ino_t,\n+    pub st_nlink: nlink_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: u32,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+}"}, {"sha": "677f8b706cdbddd120c6542115f463802fb0d690", "filename": "src/libstd/os/dragonfly/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Dragonfly-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "22c811ead43351518600ed9942d919c2a055b66e", "filename": "src/libstd/os/dragonfly/raw.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Dragonfly-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{pid_t, uid_t, gid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = u32;\n+pub type dev_t = u32;\n+pub type fflags_t = u32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_ino: ino_t,\n+    pub st_nlink: nlink_t,\n+    pub st_dev: dev_t,\n+    pub st_mode: mode_t,\n+    pub st_padding1: u16,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: uint32_t,\n+    pub st_lspare: int32_t,\n+    pub st_qspare1: int64_t,\n+    pub st_qspare2: int64_t,\n+}"}, {"sha": "73b6fd211371cb21415f42c57f7c4e24f233c7d8", "filename": "src/libstd/os/freebsd/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! FreeBSD-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "a810eff45d32e27fb47d8e6496a7b604625c1e68", "filename": "src/libstd/os/freebsd/raw.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! FreeBSD-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t, pid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i64;\n+pub type dev_t = u32;\n+pub type fflags_t = u32;\n+pub type ino_t = u32;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: dev_t,\n+    pub st_ino: ino_t,\n+    pub st_mode: mode_t,\n+    pub st_nlink: nlink_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+    pub __unused: [u8; 2],\n+}"}, {"sha": "d471cf12fe63e7d60b5c8b1739a8ec401d1fe9e0", "filename": "src/libstd/os/ios/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! iOS-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "3266b3846d899aa3d957c75aa684f789cf3d3190", "filename": "src/libstd/os/ios/raw.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! iOS-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t, pid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i32;\n+pub type dev_t = i32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = c_long;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: dev_t,\n+    pub st_mode: mode_t,\n+    pub st_nlink: nlink_t,\n+    pub st_ino: ino_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: u32,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_qspare: [i64; 2],\n+}"}, {"sha": "43376a1baeb928c214051ea21ec2ead98b90d308", "filename": "src/libstd/os/linux/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Linux-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "adce5f22ebc10b919e9c87b297f191c20a98ebb4", "filename": "src/libstd/os/linux/raw.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Linux-specific raw type definitions\n+\n+pub type dev_t = u64;\n+pub type mode_t = u32;\n+\n+#[doc(inline)]\n+pub use self::arch::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+\n+#[cfg(any(target_arch = \"x86\",\n+          target_arch = \"le32\",\n+          target_arch = \"powerpc\",\n+          target_arch = \"arm\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_short};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub __pad1: c_short,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad2: c_short,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused4: c_long,\n+        pub __unused5: c_long,\n+    }\n+}\n+\n+#[cfg(any(target_arch = \"mips\",\n+          target_arch = \"mipsel\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::c_long;\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: c_ulong,\n+        pub st_pad1: [c_long; 3],\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: c_ulong,\n+        pub st_pad2: [c_long; 2],\n+        pub st_size: off_t,\n+        pub st_pad3: c_long,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_pad5: [c_long; 14],\n+    }\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u32;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad1: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub __pad2: c_int,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_int; 2],\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i64;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u64;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_nlink: nlink_t,\n+        pub st_mode: mode_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub __pad0: c_int,\n+        pub st_rdev: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_long; 3],\n+    }\n+}"}, {"sha": "bc5ff5b25d2fa1d77bfa16d1090e674971e6feea", "filename": "src/libstd/os/macos/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! MacOS-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "03fcb768c119aabafc1ad0c6da5c596666ac8478", "filename": "src/libstd/os/macos/raw.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! MacOS-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i32;\n+pub type dev_t = i32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = c_long;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: dev_t,\n+    pub st_mode: mode_t,\n+    pub st_nlink: nlink_t,\n+    pub st_ino: ino_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: u32,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_qspare: [i64; 2],\n+}"}, {"sha": "cc4b1c944e7861124462ef7c53e4239fe1c2b302", "filename": "src/libstd/os/mod.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OS-specific functionality\n+\n+#![stable(feature = \"os\", since = \"1.0.0\")]\n+#![allow(missing_docs, bad_style)]\n+\n+#[cfg(unix)]    pub use sys::ext as unix;\n+#[cfg(windows)] pub use sys::ext as windows;\n+\n+#[cfg(target_os = \"android\")]   pub mod android;\n+#[cfg(target_os = \"bitrig\")]    pub mod bitrig;\n+#[cfg(target_os = \"dragonfly\")] pub mod dragonfly;\n+#[cfg(target_os = \"freebsd\")]   pub mod freebsd;\n+#[cfg(target_os = \"ios\")]       pub mod ios;\n+#[cfg(target_os = \"linux\")]     pub mod linux;\n+#[cfg(target_os = \"macos\")]     pub mod macos;\n+#[cfg(target_os = \"nacl\")]      pub mod nacl;\n+#[cfg(target_os = \"openbsd\")]   pub mod openbsd;\n+\n+pub mod raw;"}, {"sha": "6baed03951467ac4e447b6089e74c82314bb364b", "filename": "src/libstd/os/nacl/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Nacl-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "9defa8301ea3428fba09198597482b0403563eff", "filename": "src/libstd/os/nacl/raw.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Nacl-specific raw type definitions\n+\n+pub type dev_t = u64;\n+pub type mode_t = u32;\n+\n+pub use self::arch::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+\n+#[cfg(any(target_arch = \"x86\",\n+          target_arch = \"le32\",\n+          target_arch = \"powerpc\",\n+          target_arch = \"arm\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_short};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub __pad1: c_short,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad2: c_short,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused4: c_long,\n+        pub __unused5: c_long,\n+    }\n+}\n+\n+#[cfg(any(target_arch = \"mips\",\n+          target_arch = \"mipsel\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::c_long;\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: c_ulong,\n+        pub st_pad1: [c_long; 3],\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: c_ulong,\n+        pub st_pad2: [c_long; 2],\n+        pub st_size: off_t,\n+        pub st_pad3: c_long,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_pad5: [c_long; 14],\n+    }\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u32;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad1: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub __pad2: c_int,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_int; 2],\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i64;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u64;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_nlink: nlink_t,\n+        pub st_mode: mode_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub __pad0: c_int,\n+        pub st_rdev: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_long; 3],\n+    }\n+}"}, {"sha": "1b1a10055902bce06fbfde23b94ae3636a91b03e", "filename": "src/libstd/os/openbsd/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OpenBSD-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "632a8c336b78dc869d952437c0beab67bf083272", "filename": "src/libstd/os/openbsd/raw.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OpenBSD-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t, pid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = u32;\n+pub type dev_t = i32;\n+pub type fflags_t = u32; // type not declared, but struct stat have u_int32_t\n+pub type ino_t = u64;\n+pub type mode_t = u32;\n+pub type nlink_t = u32;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_mode: mode_t,\n+    pub st_dev: dev_t,\n+    pub st_ino: ino_t,\n+    pub st_nlink: nlink_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: u32,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+}"}, {"sha": "44f4a1c828b54e864189b292a0bef2a6508757f6", "filename": "src/libstd/os/raw.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Raw OS-specific types for the current platform/architecture\n+\n+#![unstable(feature = \"raw_os\", reason = \"recently added API\")]\n+\n+#[cfg(target_arch = \"aarch64\")]      pub type c_char = u8;\n+#[cfg(not(target_arch = \"aarch64\"))] pub type c_char = i8;\n+pub type c_schar = i8;\n+pub type c_uchar = u8;\n+pub type c_short = i16;\n+pub type c_ushort = u16;\n+pub type c_int = i32;\n+pub type c_uint = u32;\n+#[cfg(any(target_pointer_width = \"32\", windows))] pub type c_long = i32;\n+#[cfg(any(target_pointer_width = \"32\", windows))] pub type c_ulong = u32;\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] pub type c_long = i64;\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] pub type c_ulong = u64;\n+pub type c_longlong = i64;\n+pub type c_ulonglong = u64;\n+pub type c_float = f32;\n+pub type c_double = f64;\n+\n+/// Type used to construct void pointers for use with C.\n+///\n+/// This type is only useful as a pointer target. Do not use it as a\n+/// return type for FFI functions which have the `void` return type in\n+/// C. Use the unit type `()` or omit the return type instead.\n+// NB: For LLVM to recognize the void pointer type and by extension\n+//     functions like malloc(), we need to have it represented as i8* in\n+//     LLVM bitcode. The enum used here ensures this and prevents misuse\n+//     of the \"raw\" type by only having private variants.. We need two\n+//     variants, because the compiler complains about the repr attribute\n+//     otherwise.\n+#[repr(u8)]\n+pub enum c_void {\n+    #[doc(hidden)] __variant1,\n+    #[doc(hidden)] __variant2,\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use any::TypeId;\n+    use libc;\n+    use mem;\n+\n+    macro_rules! ok {\n+        ($($t:ident)*) => {$(\n+            assert!(TypeId::of::<libc::$t>() == TypeId::of::<raw::$t>(),\n+                    \"{} is wrong\", stringify!($t));\n+        )*}\n+    }\n+\n+    macro_rules! ok_size {\n+        ($($t:ident)*) => {$(\n+            assert!(mem::size_of::<libc::$t>() == mem::size_of::<raw::$t>(),\n+                    \"{} is wrong\", stringify!($t));\n+        )*}\n+    }\n+\n+    #[test]\n+    fn same() {\n+        use os::raw;\n+        ok!(c_char c_schar c_uchar c_short c_ushort c_int c_uint c_long c_ulong\n+            c_longlong c_ulonglong c_float c_double);\n+    }\n+\n+    #[cfg(unix)]\n+    fn unix() {\n+        {\n+            use os::unix::raw;\n+            ok!(uid_t gid_t dev_t ino_t mode_t nlink_t off_t blksize_t blkcnt_t);\n+        }\n+        {\n+            use sys::platform::raw;\n+            ok_size!(stat);\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    fn windows() {\n+        use os::windows::raw;\n+    }\n+}"}, {"sha": "7366524fd7ea82f1729f67578920b5e0ac2adc41", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -17,7 +17,7 @@ use any::Any;\n use cell::RefCell;\n use rt::{backtrace, unwind};\n use sys::stdio::Stderr;\n-use thread;\n+use sys_common::thread_info;\n \n thread_local! {\n     pub static LOCAL_STDERR: RefCell<Option<Box<Write + Send>>> = {\n@@ -34,8 +34,8 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) {\n         }\n     };\n     let mut err = Stderr::new();\n-    let thread = thread::current();\n-    let name = thread.name().unwrap_or(\"<unnamed>\");\n+    let thread = thread_info::current_thread();\n+    let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n     let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n     match prev {\n         Some(mut stderr) => {"}, {"sha": "2ceb60cc3aa9f7132b518f4708eb5f2fb7b982a9", "filename": "src/libstd/path.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -1241,6 +1241,16 @@ impl Path {\n     ///\n     /// Path::new(\"foo.txt\");\n     /// ```\n+    ///\n+    /// You can create `Path`s from `String`s, or even other `Path`s:\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let s = String::from(\"bar.txt\");\n+    /// let p = Path::new(&s);\n+    /// Path::new(&p);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path {\n         unsafe { mem::transmute(s.as_ref()) }"}, {"sha": "8f8699f4b9fea9f29f48a3530286ca1a8059a50f", "filename": "src/libstd/process.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -40,11 +40,15 @@ use thread;\n /// ```should_panic\n /// use std::process::Command;\n ///\n-/// let output = Command::new(\"/bin/cat\").arg(\"file.txt\").output().unwrap_or_else(|e| {\n-///     panic!(\"failed to execute child: {}\", e)\n-/// });\n-/// let contents = output.stdout;\n-/// assert!(output.status.success());\n+/// let mut child = Command::new(\"/bin/cat\")\n+///                         .arg(\"file.txt\")\n+///                         .spawn()\n+///                         .unwrap_or_else(|e| { panic!(\"failed to execute child: {}\", e) });\n+///\n+/// let ecode = child.wait()\n+///                  .unwrap_or_else(|e| { panic!(\"failed to wait on child: {}\", e) });\n+///\n+/// assert!(ecode.success());\n /// ```\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Child {\n@@ -118,9 +122,11 @@ impl Read for ChildStderr {\n /// ```\n /// use std::process::Command;\n ///\n-/// let output = Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").output().unwrap_or_else(|e| {\n-///   panic!(\"failed to execute process: {}\", e)\n-/// });\n+/// let output = Command::new(\"sh\")\n+///                      .arg(\"-c\")\n+///                      .arg(\"echo hello\")\n+///                      .output()\n+///                      .unwrap_or_else(|e| { panic!(\"failed to execute process: {}\", e) });\n /// let hello = output.stdout;\n /// ```\n #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -140,7 +146,7 @@ impl Command {\n     /// * No arguments to the program\n     /// * Inherit the current process's environment\n     /// * Inherit the current process's working directory\n-    /// * Inherit stdin/stdout/stderr for `run` or `status`, but create pipes for `output`\n+    /// * Inherit stdin/stdout/stderr for `spawn` or `status`, but create pipes for `output`\n     ///\n     /// Builder methods are provided to change these defaults and\n     /// otherwise configure the process.\n@@ -202,23 +208,20 @@ impl Command {\n     }\n \n     /// Configuration for the child process's stdin handle (file descriptor 0).\n-    /// Defaults to `CreatePipe(true, false)` so the input can be written to.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdin(&mut self, cfg: Stdio) -> &mut Command {\n         self.stdin = Some(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stdout handle (file descriptor 1).\n-    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdout(&mut self, cfg: Stdio) -> &mut Command {\n         self.stdout = Some(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stderr handle (file descriptor 2).\n-    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stderr(&mut self, cfg: Stdio) -> &mut Command {\n         self.stderr = Some(cfg.0);\n@@ -356,7 +359,7 @@ pub struct Output {\n     pub stderr: Vec<u8>,\n }\n \n-/// Describes what to do with a standard io stream for a child process.\n+/// Describes what to do with a standard I/O stream for a child process.\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Stdio(StdioImp);\n "}, {"sha": "a04bb6705b32167c9329bbce4c1b2d94f065d3d5", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -346,7 +346,7 @@ mod imp {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;"}, {"sha": "d19bc5b617f8462e62f0ddc5f1c618ccd74d6d0a", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -63,7 +63,7 @@ impl<R: Read> Rng for ReaderRng<R> {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n \n     use super::ReaderRng;"}, {"sha": "72cbe2b533bb7fc6b62cf366861085d55945e186", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -38,7 +38,7 @@ pub fn log_enabled() -> bool {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n     use sys_common;\n     macro_rules! t { ($a:expr, $b:expr) => ({"}, {"sha": "8f75ae5ef5cc8441cd5b3e687a8465687e7928f1", "filename": "src/libstd/rt/libunwind.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -97,10 +97,15 @@ pub type _Unwind_Exception_Cleanup_Fn =\n         extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n                       exception: *mut _Unwind_Exception);\n \n-#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n+#[cfg(any(all(target_os = \"linux\", not(target_env = \"musl\")),\n+          target_os = \"freebsd\"))]\n #[link(name = \"gcc_s\")]\n extern {}\n \n+#[cfg(all(target_os = \"linux\", target_env = \"musl\", not(test)))]\n+#[link(name = \"unwind\", kind = \"static\")]\n+extern {}\n+\n #[cfg(any(target_os = \"android\", target_os = \"openbsd\"))]\n #[link(name = \"gcc\")]\n extern {}"}, {"sha": "a764b99e2805d88a3c722258a94687d20b285960", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -510,23 +510,6 @@ pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, u32)) ->\n \n /// This is the entry point of unwinding for panic!() and assert!().\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n-#[cfg(stage0)]\n-pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, usize)) -> ! {\n-    // Note that this should be the only allocation performed in this code path.\n-    // Currently this means that panic!() on OOM will invoke this code path,\n-    // but then again we're not really ready for panic on OOM anyway. If\n-    // we do start doing this, then we should propagate this allocation to\n-    // be performed in the parent of this thread instead of the thread that's\n-    // panicking.\n-\n-    // see below for why we do the `Any` coercion here.\n-    let (file, line) = *file_line;\n-    begin_unwind_inner(Box::new(msg), &(file, line as u32))\n-}\n-\n-/// This is the entry point of unwinding for panic!() and assert!().\n-#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n-#[cfg(not(stage0))]\n pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> ! {\n     // Note that this should be the only allocation performed in this code path.\n     // Currently this means that panic!() on OOM will invoke this code path,"}, {"sha": "a7f3bc2bdc82c3a07d5d9441599f74afc9a0d819", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -24,7 +24,7 @@ extern {}\n //\n // On Linux, librt and libdl are indirect dependencies via std,\n // and binutils 2.22+ won't add them automatically\n-#[cfg(target_os = \"linux\")]\n+#[cfg(all(target_os = \"linux\", not(target_env = \"musl\")))]\n #[link(name = \"dl\")]\n #[link(name = \"pthread\")]\n extern {}"}, {"sha": "2d281eb4e249ca2be556107d114a100b9c6523f1", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -155,7 +155,7 @@ impl<A:Send+'static> Future<A> {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n     use sync::mpsc::channel;\n     use sync::Future;"}, {"sha": "61932225d79660472bccf97e4748dc0cdb2cb775", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -619,7 +619,6 @@ impl<T> Clone for Sender<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n@@ -683,7 +682,6 @@ impl<T> Clone for SyncSender<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n@@ -930,7 +928,6 @@ impl <T> IntoIterator for Receiver<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n@@ -1065,7 +1062,7 @@ impl error::Error for TryRecvError {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n \n     use std::env;"}, {"sha": "4ab5a796fcb43e3a0a38b570e987d59fa0cb4050", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -138,7 +138,6 @@ impl<T> Queue<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Queue<T> {\n     fn drop(&mut self) {"}, {"sha": "ab45b722c45237dbc6a47d29ed07e69a9687392d", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -367,7 +367,6 @@ impl<T> Packet<T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<T> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.state.load(Ordering::SeqCst), DISCONNECTED);"}, {"sha": "fde99e11040d2a69e95171b4e3cc68f9cc8938a2", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -315,15 +315,13 @@ impl<'rx, T: Send> Handle<'rx, T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl Drop for Select {\n     fn drop(&mut self) {\n         assert!(self.head.is_null());\n         assert!(self.tail.is_null());\n     }\n }\n \n-#[unsafe_destructor]\n impl<'rx, T: Send> Drop for Handle<'rx, T> {\n     fn drop(&mut self) {\n         unsafe { self.remove() }\n@@ -346,7 +344,7 @@ impl Iterator for Packets {\n \n #[cfg(test)]\n #[allow(unused_imports)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n \n     use thread;"}, {"sha": "09a02923f140c2727a1f31df39e1447f48dec4ad", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -473,7 +473,6 @@ impl<T> Packet<T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<T> Drop for Packet<T> {\n     fn drop(&mut self) {\n         // Note that this load is not only an assert for correctness about"}, {"sha": "f4b9c7d45fd2eb7afe6deb7aa107c7143af6d173", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -226,7 +226,6 @@ impl<T> Queue<T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<T> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {\n@@ -241,7 +240,7 @@ impl<T> Drop for Queue<T> {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n \n     use sync::Arc;"}, {"sha": "1200e71d9afed23a3f84f1532fbbd8aa28abe99b", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -471,7 +471,6 @@ impl<T> Packet<T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<T> Drop for Packet<T> {\n     fn drop(&mut self) {\n         // Note that this load is not only an assert for correctness about"}, {"sha": "4687df107f6b1157e375c3c5149057650a614c87", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -411,7 +411,6 @@ impl<T> Packet<T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<T> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.channels.load(Ordering::SeqCst), 0);"}, {"sha": "30c7407a96d97f161df7f2281f1e3abc446a08c9", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -244,7 +244,6 @@ impl<T> Mutex<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Mutex<T> {\n     fn drop(&mut self) {\n@@ -340,7 +339,6 @@ impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for MutexGuard<'a, T> {\n     #[inline]\n@@ -361,7 +359,7 @@ pub fn guard_poison<'a, T>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;"}, {"sha": "2d7123692289d32e17f71c777096fcdd8cac30ad", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -59,7 +59,11 @@ impl Once {\n     /// routine is currently running.\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n-    /// has run and completed (it may not be the closure specified).\n+    /// has run and completed (it may not be the closure specified). It is also\n+    /// guaranteed that any memory writes performed by the executed closure can\n+    /// be reliably observed by other tasks at this point (there is a\n+    /// happens-before relation between the closure and code executing after the\n+    /// return).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add.\n@@ -121,7 +125,7 @@ impl Once {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n \n     use thread;"}, {"sha": "a133bb01b610b9acf50f21287b33bb78c49b334e", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -249,7 +249,6 @@ impl<T> RwLock<T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for RwLock<T> {\n     fn drop(&mut self) {\n@@ -387,15 +386,13 @@ impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {"}, {"sha": "776b3c5064ced43f905e158b600ed4e9dc06fba1", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -100,7 +100,6 @@ impl Semaphore {\n     }\n }\n \n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Drop for SemaphoreGuard<'a> {\n     fn drop(&mut self) {"}, {"sha": "48c74b8d89effc23c21e861bf5b94099f20b9fb3", "filename": "src/libstd/sys/common/remutex.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -96,7 +96,6 @@ impl<T> ReentrantMutex<T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<T> Drop for ReentrantMutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n@@ -138,7 +137,6 @@ impl<'mutex, T> Deref for ReentrantMutexGuard<'mutex, T> {\n     }\n }\n \n-#[unsafe_destructor]\n impl<'a, T> Drop for ReentrantMutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {\n@@ -151,7 +149,7 @@ impl<'a, T> Drop for ReentrantMutexGuard<'a, T> {\n \n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use prelude::v1::*;\n     use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n     use cell::RefCell;"}, {"sha": "ae55bae37aa884e3870e7b43315f745e425a927d", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -25,10 +25,9 @@ struct ThreadInfo {\n thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(None) }\n \n impl ThreadInfo {\n-    fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R {\n+    fn with<R, F>(f: F) -> Option<R> where F: FnOnce(&mut ThreadInfo) -> R {\n         if THREAD_INFO.state() == LocalKeyState::Destroyed {\n-            panic!(\"Use of std::thread::current() is not possible after \\\n-                    the thread's local data has been destroyed\");\n+            return None\n         }\n \n         THREAD_INFO.with(move |c| {\n@@ -38,16 +37,16 @@ impl ThreadInfo {\n                     thread: NewThread::new(None),\n                 })\n             }\n-            f(c.borrow_mut().as_mut().unwrap())\n+            Some(f(c.borrow_mut().as_mut().unwrap()))\n         })\n     }\n }\n \n-pub fn current_thread() -> Thread {\n+pub fn current_thread() -> Option<Thread> {\n     ThreadInfo::with(|info| info.thread.clone())\n }\n \n-pub fn stack_guard() -> usize {\n+pub fn stack_guard() -> Option<usize> {\n     ThreadInfo::with(|info| info.stack_guard)\n }\n "}, {"sha": "1e68eac5a67354b880b5a7e678a7ae8e67fda3ea", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ddd937b20d8fc26132cb7ec665784422d92926/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=b2ddd937b20d8fc26132cb7ec665784422d92926", "patch": "@@ -161,6 +161,8 @@ extern {\n     pub fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n     pub fn setgroups(ngroups: libc::c_int,\n                      ptr: *const libc::c_void) -> libc::c_int;\n+    pub fn realpath(pathname: *const libc::c_char, resolved: *mut libc::c_char)\n+                    -> *mut libc::c_char;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}]}