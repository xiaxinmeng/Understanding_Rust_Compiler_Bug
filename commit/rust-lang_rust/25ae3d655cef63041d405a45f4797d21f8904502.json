{"sha": "25ae3d655cef63041d405a45f4797d21f8904502", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YWUzZDY1NWNlZjYzMDQxZDQwNWE0NWY0Nzk3ZDIxZjg5MDQ1MDI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-06T21:03:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-07T17:32:58Z"}, "message": "Rewrite spawn yet again\n\nThe motivation here is that the bottom of each stack needs to contain a C++\ntry/catch block so that we can unwind. This is already the case for main, but\nnot spawned tasks.\n\nIssue #236", "tree": {"sha": "6a6dc9c15050df636670e36709a1a3ed7f2a8759", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a6dc9c15050df636670e36709a1a3ed7f2a8759"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25ae3d655cef63041d405a45f4797d21f8904502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25ae3d655cef63041d405a45f4797d21f8904502", "html_url": "https://github.com/rust-lang/rust/commit/25ae3d655cef63041d405a45f4797d21f8904502", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25ae3d655cef63041d405a45f4797d21f8904502/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bd627039ed6979c59d25aee67548091522c6ff9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bd627039ed6979c59d25aee67548091522c6ff9", "html_url": "https://github.com/rust-lang/rust/commit/1bd627039ed6979c59d25aee67548091522c6ff9"}], "stats": {"total": 177, "additions": 85, "deletions": 92}, "files": [{"sha": "b00e6c1999149ab50fcc1dcbd566b25b24e404a8", "filename": "src/lib/task.rs", "status": "modified", "additions": 15, "deletions": 62, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/25ae3d655cef63041d405a45f4797d21f8904502/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ae3d655cef63041d405a45f4797d21f8904502/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=25ae3d655cef63041d405a45f4797d21f8904502", "patch": "@@ -39,20 +39,17 @@ native \"rust\" mod rustrt {\n     fn new_task() -> task_id;\n     fn drop_task(task: *rust_task);\n     fn get_task_pointer(id: task_id) -> *rust_task;\n-    fn start_task(id: task_id);\n     fn get_task_trampoline() -> u32;\n \n     fn migrate_alloc(alloc: *u8, target: task_id);\n+    fn start_task(id: task_id, closure: *u8);\n }\n \n type rust_task =\n     {id: task,\n      mutable notify_enabled: u32,\n      mutable notify_chan: comm::chan<task_notification>,\n-     ctx: task_context,\n-     stack_ptr: *u8};\n-\n-type task_context = {regs: x86_registers, next: *u8};\n+     mutable stack_ptr: *u8};\n \n resource rust_task_ptr(task: *rust_task) { rustrt::drop_task(task); }\n \n@@ -115,20 +112,22 @@ fn spawn_inner(thunk: -fn(), notify: option<comm::chan<task_notification>>) ->\n    task_id {\n     let id = rustrt::new_task();\n \n-    // the order of arguments are outptr, taskptr, envptr.\n-    // LLVM fastcall puts the first two in ecx, edx, and the rest on the\n-    // stack.\n+    let raw_thunk: {code: u32, env: u32} = cast(thunk);\n \n     // set up the task pointer\n     let task_ptr = rust_task_ptr(rustrt::get_task_pointer(id));\n-    let regs = ptr::addr_of((**task_ptr).ctx.regs);\n-    (*regs).edx = cast(*task_ptr);;\n-    (*regs).esp = cast((**task_ptr).stack_ptr);\n \n     assert (ptr::null() != (**task_ptr).stack_ptr);\n \n-    let raw_thunk: {code: u32, env: u32} = cast(thunk);\n-    (*regs).eip = raw_thunk.code;\n+    // copy the thunk from our stack to the new stack\n+    let sp: uint = cast((**task_ptr).stack_ptr);\n+    let ptrsize = sys::size_of::<*u8>();\n+    let thunkfn: *mutable uint = cast(sp - ptrsize * 2u);\n+    let thunkenv: *mutable uint = cast(sp - ptrsize);\n+    *thunkfn = cast(raw_thunk.code);\n+    *thunkenv = cast(raw_thunk.env);\n+    // align the stack to 16 bytes\n+    (**task_ptr).stack_ptr = cast(sp - ptrsize * 4u);\n \n     // set up notifications if they are enabled.\n     alt notify {\n@@ -139,60 +138,14 @@ fn spawn_inner(thunk: -fn(), notify: option<comm::chan<task_notification>>) ->\n       none { }\n     };\n \n-    // okay, now we align the stack and add the environment pointer and a fake\n-    // return address.\n-\n-    // -12 for the taskm output location, the env pointer\n-    // -4 for the return address.\n-    (*regs).esp = align_down((*regs).esp - 12u32) - 4u32;\n-\n-    let ra: *mutable u32 = cast((*regs).esp);\n-    let env: *mutable u32 = cast((*regs).esp + 4u32);\n-    let tptr: *mutable u32 = cast((*regs).esp + 12u32);\n-\n-    // put the return pointer in ecx.\n-    (*regs).ecx = (*regs).esp + 8u32;;\n-\n-    *tptr = cast(*task_ptr);;\n-    *env = raw_thunk.env;;\n-    *ra = rustrt::get_task_trampoline();\n-\n+    // give the thunk environment's allocation to the new task\n     rustrt::migrate_alloc(cast(raw_thunk.env), id);\n-    rustrt::start_task(id);\n-\n+    rustrt::start_task(id, cast(thunkfn));\n+    // don't cleanup the thunk in this task\n     unsafe::leak(thunk);\n-\n     ret id;\n }\n \n-// Who says we can't write an operating system in Rust?\n-type x86_registers =\n-    // This needs to match the structure in context.h\n-\n-\n-    {mutable eax: u32,\n-     mutable ebx: u32,\n-     mutable ecx: u32,\n-     mutable edx: u32,\n-     mutable ebp: u32,\n-     mutable esi: u32,\n-     mutable edi: u32,\n-     mutable esp: u32,\n-     mutable cs: u16,\n-     mutable ds: u16,\n-     mutable ss: u16,\n-     mutable es: u16,\n-     mutable fs: u16,\n-     mutable gs: u16,\n-     mutable eflags: u32,\n-     mutable eip: u32};\n-\n-fn align_down(x: u32) -> u32 {\n-\n-    // Aligns x down to 16 bytes\n-    x & !15u32\n-}\n-\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "d7ad044da50a7dec9b0188dea4cbc41d171d35dc", "filename": "src/rt/arch/i386/_context.S", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Farch%2Fi386%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Farch%2Fi386%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2F_context.S?ref=25ae3d655cef63041d405a45f4797d21f8904502", "patch": "@@ -75,11 +75,3 @@ swap_registers:\n     jmp *48(%eax)\n \n \n-.globl task_trampoline\n-task_trampoline:\n-    // This gets set up by std::task::_spawn.\n-#if defined(__APPLE__) || defined(__WIN32__)\n-    call _task_exit\n-#else\n-    call task_exit\n-#endif"}, {"sha": "739e0530de5160f488f896732dff7e5da4833536", "filename": "src/rt/main.ll.in", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Fmain.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Fmain.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmain.ll.in?ref=25ae3d655cef63041d405a45f4797d21f8904502", "patch": "@@ -24,7 +24,20 @@ define void @_rust_main_wrap(i1* nocapture, %task *, %2* nocapture, %vec *)\n   ret void\n }\n \n+%nullary_fn = type void (i1*, %task*, %2*)\n+\n+define void @_rust_spawn_wrap(\n+       i1* nocapture, %task*, %2* nocapture, %nullary_fn* %f)\n+{\n+  call fastcc void %f(i1* %0, %task *%1, %2* nocapture %2)\n+  ret void\n+}\n+\n+declare external void @set_spawn_wrapper(void (i1*, %task*, %2*, %nullary_fn*)*);\n+\n define i32 @\"MAIN\"(i32, i32) {\n-  %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %vec*)* @_rust_main_wrap to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32))\n-  ret i32 %3\n+  call void @set_spawn_wrapper(void (i1*, %task*, %2*, %nullary_fn*)* @_rust_spawn_wrap)\n+\n+  %result = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %vec*)* @_rust_main_wrap to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32))\n+  ret i32 %result\n }"}, {"sha": "7614269a1228bf6ae8e205bc6e9bdcf731b9356f", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=25ae3d655cef63041d405a45f4797d21f8904502", "patch": "@@ -440,18 +440,24 @@ get_task_pointer(rust_task *task, rust_task_id id) {\n     return task->kernel->get_task_by_id(id);\n }\n \n-extern \"C\" CDECL void\n-start_task(rust_task *task, rust_task_id id) {\n-    rust_task * target = task->kernel->get_task_by_id(id);\n-    target->start();\n-    target->deref();\n+// FIXME: Transitional. Remove\n+extern \"C\" CDECL void **\n+get_task_trampoline(rust_task *task) {\n+    return NULL;\n }\n \n-extern \"C\" void *task_trampoline asm(\"task_trampoline\");\n+struct fn_env_pair {\n+    intptr_t f;\n+    intptr_t env;\n+};\n+\n+extern \"C\" CDECL uintptr_t get_spawn_wrapper();\n \n-extern \"C\" CDECL void **\n-get_task_trampoline(rust_task *task) {\n-    return &task_trampoline;\n+extern \"C\" CDECL void\n+start_task(rust_task *task, rust_task_id id, fn_env_pair *f) {\n+    rust_task *target = task->kernel->get_task_by_id(id);\n+    target->start(get_spawn_wrapper(), f->f, f->env);\n+    target->deref();\n }\n \n extern \"C\" CDECL void"}, {"sha": "3a69184d3fe83046c2e4b9509db184bf48af8715", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=25ae3d655cef63041d405a45f4797d21f8904502", "patch": "@@ -48,10 +48,10 @@ void\n rust_scheduler::activate(rust_task *task) {\n     context ctx;\n \n-    task->user.ctx.next = &ctx;\n+    task->ctx.next = &ctx;\n     DLOG(this, task, \"descheduling...\");\n     lock.unlock();\n-    task->user.ctx.swap(ctx);\n+    task->ctx.swap(ctx);\n     lock.lock();\n     DLOG(this, task, \"task has returned\");\n }"}, {"sha": "ab29b1067830e510b28a994ae3ced549c84f8734", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=25ae3d655cef63041d405a45f4797d21f8904502", "patch": "@@ -125,13 +125,13 @@ struct spawn_args {\n                        uintptr_t, uintptr_t);\n };\n \n-struct rust_closure {\n+struct rust_closure_env {\n     intptr_t ref_count;\n     type_desc *td;\n };\n \n extern \"C\" CDECL\n-void task_exit(rust_closure *env, int rval, rust_task *task) {\n+void task_exit(rust_closure_env *env, int rval, rust_task *task) {\n     LOG(task, task, \"task exited with value %d\", rval);\n     if(env) {\n         // free the environment.\n@@ -155,14 +155,32 @@ void task_start_wrapper(spawn_args *a)\n     int rval = 42;\n \n     a->f(&rval, task, a->a3, a->a4);\n-    task_exit(NULL, rval, task);\n+    task_exit((rust_closure_env*)a->a3, rval, task);\n+}\n+\n+/* We spawn a rust (fastcc) function through a CDECL function\n+   defined in main.ll, which is built as part of each crate. These accessors\n+   allow each rust program to install that function at startup */\n+\n+uintptr_t spawn_wrapper;\n+\n+extern \"C\" CDECL void\n+set_spawn_wrapper(uintptr_t f) {\n+    spawn_wrapper = f;\n+}\n+\n+extern \"C\" CDECL uintptr_t\n+get_spawn_wrapper() {\n+    return spawn_wrapper;\n }\n \n void\n rust_task::start(uintptr_t spawnee_fn,\n-                 uintptr_t args)\n+                 uintptr_t args,\n+                 uintptr_t env)\n {\n-    LOGPTR(sched, \"from spawnee\", spawnee_fn);\n+    LOG(this, task, \"starting task from fn 0x%\" PRIxPTR\n+        \" with args 0x%\" PRIxPTR, spawnee_fn, args);\n \n     I(sched, stk->data != NULL);\n \n@@ -173,16 +191,23 @@ rust_task::start(uintptr_t spawnee_fn,\n     spawn_args *a = (spawn_args *)sp;\n \n     a->task = this;\n-    a->a3 = 0;\n+    a->a3 = env;\n     a->a4 = args;\n     void **f = (void **)&a->f;\n     *f = (void *)spawnee_fn;\n \n-    user.ctx.call((void *)task_start_wrapper, a, sp);\n+    ctx.call((void *)task_start_wrapper, a, sp);\n \n     this->start();\n }\n \n+void\n+rust_task::start(uintptr_t spawnee_fn,\n+                 uintptr_t args)\n+{\n+    start(spawnee_fn, args, 0);\n+}\n+\n void rust_task::start()\n {\n     yield_timer.reset_us(0);\n@@ -213,7 +238,7 @@ rust_task::yield(size_t time_in_us) {\n     yield_timer.reset_us(time_in_us);\n \n     // Return to the scheduler.\n-    user.ctx.next->swap(user.ctx);\n+    ctx.next->swap(ctx);\n }\n \n void"}, {"sha": "3ac44e58a6e158920760c0323a5cf2930f5425f2", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=25ae3d655cef63041d405a45f4797d21f8904502", "patch": "@@ -29,7 +29,6 @@ struct rust_task_user {\n     uint32_t notify_enabled;   // this is way more bits than necessary, but it\n                                // simplifies the alignment.\n     chan_handle notify_chan;\n-    context ctx;\n     uintptr_t rust_sp;         // Saved sp when not running.\n };\n \n@@ -55,6 +54,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     RUST_ATOMIC_REFCOUNT();\n \n     // Fields known to the compiler.\n+    context ctx;\n     stk_seg *stk;\n     uintptr_t runtime_sp;      // Runtime sp while task running.\n     void *gc_alloc_chain;      // Linked list of GC allocations.\n@@ -118,6 +118,9 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n \n     ~rust_task();\n \n+    void start(uintptr_t spawnee_fn,\n+               uintptr_t args,\n+               uintptr_t env);\n     void start(uintptr_t spawnee_fn,\n                uintptr_t args);\n     void start();"}, {"sha": "46916c5ab495a9341876dc2b32e696ba53375d66", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/25ae3d655cef63041d405a45f4797d21f8904502/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=25ae3d655cef63041d405a45f4797d21f8904502", "patch": "@@ -55,6 +55,7 @@ rust_run_program\n rust_start\n rust_getcwd\n set_min_stack\n+set_spawn_wrapper\n sched_threads\n size_of\n squareroot"}]}