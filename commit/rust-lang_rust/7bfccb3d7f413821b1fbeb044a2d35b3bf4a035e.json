{"sha": "7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "node_id": "C_kwDOAAsO6NoAKDdiZmNjYjNkN2Y0MTM4MjFiMWZiZWIwNDRhMmQzNWIzYmY0YTAzNWU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-14T19:11:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-14T19:11:10Z"}, "message": "Rollup merge of #108687 - compiler-errors:reformulate-point_at_expr_source_of_inferred_type, r=oli-obk\n\nReformulate `point_at_expr_source_of_inferred_type` to be more accurate\n\nBe more accurate when deducing where along the several usages of a binding it is constrained to be some type that is incompatible with an expectation.\n\nThis also renames the method to `note_source_of_type_mismatch_constraint` because I prefer that name, though I guess I can revert that. (Also drive-by rename `note_result_coercion` -> `suggest_coercing_result_via_try_operator`, because it's suggesting, not noting!)\n\nThis PR is (probably?) best reviewed per commit, but it does regress a bit only to fix it later on, so it could also be reviewed as a whole if that makes the final results more clear.\n\nr? `@estebank`", "tree": {"sha": "5133abdbb6639c789b68f8c0fb97353e9d3a26cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5133abdbb6639c789b68f8c0fb97353e9d3a26cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkOaVOCRBK7hj4Ov3rIwAAR8sIACnzEINIZRliw1ajqQtaKN3C\nxadMvpqRRQxxBMyxPYMaMjMA+kt43mhAv/RQB9ZFvhxkhZllLPN2JHTtw5BWh/VL\nNn9uF/WfHR7OIABUnTQStIsBmR3g9eUomFYZlxMaNPD0bgz21zwqlMprMapP0/P+\n+UXFreQ0tGQF6Ad5tsKzPYQuh8t3Ihn2NtKYNJpP4RTefvu/h+R0d0GvHKA5RnYj\n7o/MjMVRG/xJzuadsetS3m8NzjfMkOqGX/r70oBcflnKbSXniQWqbheWA/G8PTvN\nYoz2nC8CFaQ1fnXYMAs+MW/IoAFBP//IOLRwmTEkwo9Hg1YKygb1UJYc2L12PVA=\n=XN/O\n-----END PGP SIGNATURE-----\n", "payload": "tree 5133abdbb6639c789b68f8c0fb97353e9d3a26cd\nparent 660c966ff941ddf995d3251df32508b383cd4cee\nparent 5cc475742151cd458091ca3c67598ddece3ee39b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1681499470 +0200\ncommitter GitHub <noreply@github.com> 1681499470 +0200\n\nRollup merge of #108687 - compiler-errors:reformulate-point_at_expr_source_of_inferred_type, r=oli-obk\n\nReformulate `point_at_expr_source_of_inferred_type` to be more accurate\n\nBe more accurate when deducing where along the several usages of a binding it is constrained to be some type that is incompatible with an expectation.\n\nThis also renames the method to `note_source_of_type_mismatch_constraint` because I prefer that name, though I guess I can revert that. (Also drive-by rename `note_result_coercion` -> `suggest_coercing_result_via_try_operator`, because it's suggesting, not noting!)\n\nThis PR is (probably?) best reviewed per commit, but it does regress a bit only to fix it later on, so it could also be reviewed as a whole if that makes the final results more clear.\n\nr? `@estebank`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "html_url": "https://github.com/rust-lang/rust/commit/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "660c966ff941ddf995d3251df32508b383cd4cee", "url": "https://api.github.com/repos/rust-lang/rust/commits/660c966ff941ddf995d3251df32508b383cd4cee", "html_url": "https://github.com/rust-lang/rust/commit/660c966ff941ddf995d3251df32508b383cd4cee"}, {"sha": "5cc475742151cd458091ca3c67598ddece3ee39b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc475742151cd458091ca3c67598ddece3ee39b", "html_url": "https://github.com/rust-lang/rust/commit/5cc475742151cd458091ca3c67598ddece3ee39b"}], "stats": {"total": 478, "additions": 257, "deletions": 221}, "files": [{"sha": "13442c3164928305d4c9fc4a51fbc6858a9de8f2", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 220, "deletions": 186, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -1,6 +1,5 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -13,15 +12,13 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::fold::{BottomUpFolder, TypeFolder};\n-use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n-use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitableExt};\n+use rustc_middle::ty::fold::BottomUpFolder;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n use rustc_target::abi::FieldIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::error_reporting::method_chain::CollectAllMismatches;\n use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n@@ -62,9 +59,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_into(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected)\n             || self.suggest_null_ptr_for_literal_zero_given_to_ptr_arg(err, expr, expected)\n-            || self.note_result_coercion(err, expr, expected, expr_ty);\n+            || self.suggest_coercing_result_via_try_operator(err, expr, expected, expr_ty);\n+\n         if !suggested {\n-            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected, expr.span);\n+            self.note_source_of_type_mismatch_constraint(\n+                err,\n+                expr,\n+                TypeMismatchSource::Ty(expected),\n+            );\n         }\n     }\n \n@@ -218,37 +220,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n-    pub fn point_at_expr_source_of_inferred_type(\n+    /// Notes the point at which a variable is constrained to some type incompatible\n+    /// with some expectation given by `source`.\n+    pub fn note_source_of_type_mismatch_constraint(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        found: Ty<'tcx>,\n-        expected: Ty<'tcx>,\n-        mismatch_span: Span,\n+        source: TypeMismatchSource<'tcx>,\n     ) -> bool {\n-        let map = self.tcx.hir();\n+        let hir = self.tcx.hir();\n \n         let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind else { return false; };\n         let [hir::PathSegment { ident, args: None, .. }] = p.segments else { return false; };\n-        let hir::def::Res::Local(hir_id) = p.res else { return false; };\n-        let Some(hir::Node::Pat(pat)) = map.find(hir_id) else { return false; };\n-        let Some(hir::Node::Local(hir::Local {\n-            ty: None,\n-            init: Some(init),\n-            ..\n-        })) = map.find_parent(pat.hir_id) else { return false; };\n-        let Some(ty) = self.node_ty_opt(init.hir_id) else { return false; };\n-        if ty.is_closure() || init.span.overlaps(expr.span) || pat.span.from_expansion() {\n-            return false;\n-        }\n+        let hir::def::Res::Local(local_hir_id) = p.res else { return false; };\n+        let hir::Node::Pat(pat) = hir.get(local_hir_id) else { return false; };\n+        let (init_ty_hir_id, init) = match hir.get_parent(pat.hir_id) {\n+            hir::Node::Local(hir::Local { ty: Some(ty), init, .. }) => (ty.hir_id, *init),\n+            hir::Node::Local(hir::Local { init: Some(init), .. }) => (init.hir_id, Some(*init)),\n+            _ => return false,\n+        };\n+        let Some(init_ty) = self.node_ty_opt(init_ty_hir_id) else { return false; };\n \n         // Locate all the usages of the relevant binding.\n-        struct FindExprs<'hir> {\n+        struct FindExprs<'tcx> {\n             hir_id: hir::HirId,\n-            uses: Vec<&'hir hir::Expr<'hir>>,\n+            uses: Vec<&'tcx hir::Expr<'tcx>>,\n         }\n-        impl<'v> Visitor<'v> for FindExprs<'v> {\n-            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        impl<'tcx> Visitor<'tcx> for FindExprs<'tcx> {\n+            fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n                 if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = ex.kind\n                     && let hir::def::Res::Local(hir_id) = path.res\n                     && hir_id == self.hir_id\n@@ -259,180 +258,205 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let mut expr_finder = FindExprs { hir_id, uses: vec![] };\n-        let id = map.get_parent_item(hir_id);\n-        let hir_id: hir::HirId = id.into();\n-\n-        let Some(node) = map.find(hir_id) else { return false; };\n-        let Some(body_id) = node.body_id() else { return false; };\n-        let body = map.body(body_id);\n+        let mut expr_finder = FindExprs { hir_id: local_hir_id, uses: init.into_iter().collect() };\n+        let body =\n+            hir.body(hir.maybe_body_owned_by(self.body_id).expect(\"expected item to have body\"));\n         expr_finder.visit_expr(body.value);\n-        // Hack to make equality checks on types with inference variables and regions useful.\n-        let mut eraser = BottomUpFolder {\n+\n+        use rustc_infer::infer::type_variable::*;\n+        use rustc_middle::infer::unify_key::*;\n+        // Replaces all of the variables in the given type with a fresh inference variable.\n+        let mut fudger = BottomUpFolder {\n             tcx: self.tcx,\n+            ty_op: |ty| {\n+                if let ty::Infer(infer) = ty.kind() {\n+                    match infer {\n+                        ty::InferTy::TyVar(_) => self.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: DUMMY_SP,\n+                        }),\n+                        ty::InferTy::IntVar(_) => self.next_int_var(),\n+                        ty::InferTy::FloatVar(_) => self.next_float_var(),\n+                        _ => bug!(),\n+                    }\n+                } else {\n+                    ty\n+                }\n+            },\n             lt_op: |_| self.tcx.lifetimes.re_erased,\n-            ct_op: |c| c,\n-            ty_op: |t| match *t.kind() {\n-                ty::Infer(ty::TyVar(_)) => self.tcx.mk_ty_var(ty::TyVid::from_u32(0)),\n-                ty::Infer(ty::IntVar(_)) => self.tcx.mk_int_var(ty::IntVid { index: 0 }),\n-                ty::Infer(ty::FloatVar(_)) => self.tcx.mk_float_var(ty::FloatVid { index: 0 }),\n-                _ => t,\n+            ct_op: |ct| {\n+                if let ty::ConstKind::Infer(_) = ct.kind() {\n+                    self.next_const_var(\n+                        ct.ty(),\n+                        ConstVariableOrigin {\n+                            kind: ConstVariableOriginKind::MiscVariable,\n+                            span: DUMMY_SP,\n+                        },\n+                    )\n+                } else {\n+                    ct\n+                }\n             },\n         };\n-        let mut prev = eraser.fold_ty(ty);\n-        let mut prev_span: Option<Span> = None;\n-\n-        for binding in expr_finder.uses {\n-            // In every expression where the binding is referenced, we will look at that\n-            // expression's type and see if it is where the incorrect found type was fully\n-            // \"materialized\" and point at it. We will also try to provide a suggestion there.\n-            if let Some(hir::Node::Expr(expr)\n-            | hir::Node::Stmt(hir::Stmt {\n-                kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n-                ..\n-            })) = &map.find_parent(binding.hir_id)\n-                && let hir::ExprKind::MethodCall(segment, rcvr, args, _span) = expr.kind\n-                && rcvr.hir_id == binding.hir_id\n-                && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n-            {\n-                // We special case methods, because they can influence inference through the\n-                // call's arguments and we can provide a more explicit span.\n-                let sig = self.tcx.fn_sig(def_id).subst_identity();\n-                let def_self_ty = sig.input(0).skip_binder();\n-                let param_tys = sig.inputs().skip_binder().iter().skip(1);\n-                // If there's an arity mismatch, pointing out the call as the source of an inference\n-                // can be misleading, so we skip it.\n-                if param_tys.len() != args.len() {\n-                    continue;\n-                }\n-                let rcvr_ty = self.node_ty(rcvr.hir_id);\n-                // Get the evaluated type *after* calling the method call, so that the influence\n-                // of the arguments can be reflected in the receiver type. The receiver\n-                // expression has the type *before* this analysis is done.\n-                let ty = match self.lookup_probe_for_diagnostic(\n-                    segment.ident,\n-                    rcvr_ty,\n-                    expr,\n-                    probe::ProbeScope::TraitsInScope,\n-                    None,\n-                ) {\n-                    Ok(pick) => eraser.fold_ty(pick.self_ty),\n-                    Err(_) => rcvr_ty,\n+\n+        let expected_ty = match source {\n+            TypeMismatchSource::Ty(expected_ty) => expected_ty,\n+            // Try to deduce what the possible value of `expr` would be if the\n+            // incompatible arg were compatible. For example, given `Vec<i32>`\n+            // and `vec.push(1u32)`, we ideally want to deduce that the type of\n+            // `vec` *should* have been `Vec<u32>`. This will allow us to then\n+            // run the subsequent code with this expectation, finding out exactly\n+            // when this type diverged from our expectation.\n+            TypeMismatchSource::Arg { call_expr, incompatible_arg: idx } => {\n+                let hir::ExprKind::MethodCall(segment, _, args, _) = call_expr.kind else {\n+                    return false;\n                 };\n-                // Remove one layer of references to account for `&mut self` and\n-                // `&self`, so that we can compare it against the binding.\n-                let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n-                    (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n-                    _ => (ty, def_self_ty),\n+                let Some(arg_ty) = self.node_ty_opt(args[idx].hir_id) else {\n+                    return false;\n                 };\n-                let mut param_args = FxHashMap::default();\n-                let mut param_expected = FxHashMap::default();\n-                let mut param_found = FxHashMap::default();\n-                if self.can_eq(self.param_env, ty, found) {\n-                    // We only point at the first place where the found type was inferred.\n-                    for (param_ty, arg) in param_tys.zip(args) {\n-                        if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n-                            // We found an argument that references a type parameter in `Self`,\n-                            // so we assume that this is the argument that caused the found\n-                            // type, which we know already because of `can_eq` above was first\n-                            // inferred in this method call.\n-                            let arg_ty = self.node_ty(arg.hir_id);\n-                            if !arg.span.overlaps(mismatch_span) {\n-                                err.span_label(\n-                                    arg.span,\n-                                    &format!(\n-                                        \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n-                                        inferred as `{ty}`\",\n-                                    ),\n-                                );\n-                            }\n-                            param_args.insert(param_ty, (arg, arg_ty));\n-                        }\n-                    }\n+                let possible_rcvr_ty = expr_finder.uses.iter().find_map(|binding| {\n+                    let possible_rcvr_ty = self.node_ty_opt(binding.hir_id)?;\n+                    // Fudge the receiver, so we can do new inference on it.\n+                    let possible_rcvr_ty = possible_rcvr_ty.fold_with(&mut fudger);\n+                    let method = self\n+                        .lookup_method(\n+                            possible_rcvr_ty,\n+                            segment,\n+                            DUMMY_SP,\n+                            call_expr,\n+                            binding,\n+                            args,\n+                        )\n+                        .ok()?;\n+                    // Unify the method signature with our incompatible arg, to\n+                    // do inference in the *opposite* direction and to find out\n+                    // what our ideal rcvr ty would look like.\n+                    let _ = self\n+                        .at(&ObligationCause::dummy(), self.param_env)\n+                        .eq(DefineOpaqueTypes::No, method.sig.inputs()[idx + 1], arg_ty)\n+                        .ok()?;\n+                    self.select_obligations_where_possible(|errs| {\n+                        // Yeet the errors, we're already reporting errors.\n+                        errs.clear();\n+                    });\n+                    Some(self.resolve_vars_if_possible(possible_rcvr_ty))\n+                });\n+                if let Some(rcvr_ty) = possible_rcvr_ty {\n+                    rcvr_ty\n+                } else {\n+                    return false;\n                 }\n+            }\n+        };\n \n-                // Here we find, for a type param `T`, the type that `T` is in the current\n-                // method call *and* in the original expected type. That way, we can see if we\n-                // can give any structured suggestion for the function argument.\n-                let mut c = CollectAllMismatches {\n-                    infcx: &self.infcx,\n-                    param_env: self.param_env,\n-                    errors: vec![],\n+        // If our expected_ty does not equal init_ty, then it *began* as incompatible.\n+        // No need to note in this case...\n+        if !self.can_eq(self.param_env, expected_ty, init_ty.fold_with(&mut fudger)) {\n+            return false;\n+        }\n+\n+        for window in expr_finder.uses.windows(2) {\n+            // Bindings always update their recorded type after the fact, so we\n+            // need to look at the *following* usage's type to see when the\n+            // binding became incompatible.\n+            let [binding, next_usage] = *window else { continue; };\n+\n+            // Don't go past the binding (always gonna be a nonsense label if so)\n+            if binding.hir_id == expr.hir_id {\n+                break;\n+            }\n+\n+            let Some(next_use_ty) = self.node_ty_opt(next_usage.hir_id) else { continue; };\n+\n+            // If the type is not constrained in a way making it not possible to\n+            // equate with `expected_ty` by this point, skip.\n+            if self.can_eq(self.param_env, expected_ty, next_use_ty.fold_with(&mut fudger)) {\n+                continue;\n+            }\n+\n+            if let hir::Node::Expr(parent_expr) = hir.get_parent(binding.hir_id)\n+                && let hir::ExprKind::MethodCall(segment, rcvr, args, _) = parent_expr.kind\n+                && rcvr.hir_id == binding.hir_id\n+            {\n+                // If our binding became incompatible while it was a receiver\n+                // to a method call, we may be able to make a better guess to\n+                // the source of a type mismatch.\n+                let Some(rcvr_ty) = self.node_ty_opt(rcvr.hir_id) else { continue; };\n+                let rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n+                let Ok(method) =\n+                    self.lookup_method(rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                else {\n+                    continue;\n                 };\n-                let _ = c.relate(def_self_ty, ty);\n-                for error in c.errors {\n-                    if let TypeError::Sorts(error) = error {\n-                        param_found.insert(error.expected, error.found);\n-                    }\n-                }\n-                c.errors = vec![];\n-                let _ = c.relate(def_self_ty, expected);\n-                for error in c.errors {\n-                    if let TypeError::Sorts(error) = error {\n-                        param_expected.insert(error.expected, error.found);\n-                    }\n-                }\n-                for (param, (arg, arg_ty)) in param_args.iter() {\n-                    let Some(expected) = param_expected.get(param) else { continue; };\n-                    let Some(found) = param_found.get(param) else { continue; };\n-                    if !self.can_eq(self.param_env, *arg_ty, *found) { continue; }\n-                    self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n-                }\n \n-                let ty = eraser.fold_ty(ty);\n-                if ty.references_error() {\n-                    break;\n-                }\n-                if ty != prev\n-                    && param_args.is_empty()\n-                    && self.can_eq(self.param_env, ty, found)\n+                let ideal_rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n+                let ideal_method = self\n+                    .lookup_method(ideal_rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                    .ok()\n+                    .and_then(|method| {\n+                        let _ = self.at(&ObligationCause::dummy(), self.param_env)\n+                            .eq(DefineOpaqueTypes::No, ideal_rcvr_ty, expected_ty)\n+                            .ok()?;\n+                        Some(method)\n+                    });\n+\n+                // Find what argument caused our rcvr to become incompatible\n+                // with the expected ty.\n+                for (idx, (expected_arg_ty, arg_expr)) in\n+                    std::iter::zip(&method.sig.inputs()[1..], args).enumerate()\n                 {\n-                    // We only point at the first place where the found type was inferred.\n-                    if !segment.ident.span.overlaps(mismatch_span) {\n+                    let Some(arg_ty) = self.node_ty_opt(arg_expr.hir_id) else { continue; };\n+                    let arg_ty = arg_ty.fold_with(&mut fudger);\n+                    let _ = self.try_coerce(\n+                        arg_expr,\n+                        arg_ty,\n+                        *expected_arg_ty,\n+                        AllowTwoPhase::No,\n+                        None,\n+                    );\n+                    self.select_obligations_where_possible(|errs| {\n+                        // Yeet the errors, we're already reporting errors.\n+                        errs.clear();\n+                    });\n+                    // If our rcvr, after inference due to unifying the signature\n+                    // with the expected argument type, is still compatible with\n+                    // the rcvr, then it must've not been the source of blame.\n+                    if self.can_eq(self.param_env, rcvr_ty, expected_ty) {\n+                        continue;\n+                    }\n+                    err.span_label(arg_expr.span, format!(\"this argument has type `{arg_ty}`...\"));\n                     err.span_label(\n-                        segment.ident.span,\n-                        with_forced_trimmed_paths!(format!(\n-                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                        )),\n-                    );}\n-                    break;\n-                } else if !param_args.is_empty() {\n-                    break;\n-                }\n-                prev = ty;\n-            } else {\n-                let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n-                if ty.references_error() {\n-                    break;\n-                }\n-                if ty != prev\n-                    && let Some(span) = prev_span\n-                    && self.can_eq(self.param_env, ty, found)\n-                {\n-                    // We only point at the first place where the found type was inferred.\n-                    // We use the *previous* span because if the type is known *here* it means\n-                    // it was *evaluated earlier*. We don't do this for method calls because we\n-                    // evaluate the method's self type eagerly, but not in any other case.\n-                    if !span.overlaps(mismatch_span) {\n-                        err.span_label(\n-                            span,\n-                            with_forced_trimmed_paths!(format!(\n-                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                            )),\n+                        binding.span,\n+                        format!(\"... which causes `{ident}` to have type `{next_use_ty}`\"),\n+                    );\n+                    // Using our \"ideal\" method signature, suggest a fix to this\n+                    // blame arg, if possible. Don't do this if we're coming from\n+                    // arg mismatch code, because we'll possibly suggest a mutually\n+                    // incompatible fix at the original mismatch site.\n+                    if matches!(source, TypeMismatchSource::Ty(_))\n+                        && let Some(ideal_method) = ideal_method\n+                    {\n+                        self.emit_type_mismatch_suggestions(\n+                            err,\n+                            arg_expr,\n+                            arg_ty,\n+                            self.resolve_vars_if_possible(ideal_method.sig.inputs()[idx + 1]),\n+                            None,\n+                            None,\n                         );\n                     }\n-                    break;\n+                    return true;\n                 }\n-                prev = ty;\n-            }\n-            if binding.hir_id == expr.hir_id {\n-                // Do not look at expressions that come after the expression we were originally\n-                // evaluating and had a type error.\n-                break;\n             }\n-            prev_span = Some(binding.span);\n+            err.span_label(\n+                binding.span,\n+                format!(\"here the type of `{ident}` is inferred to be `{next_use_ty}`\"),\n+            );\n+            return true;\n         }\n-        true\n+\n+        // We must've not found something that constrained the expr.\n+        false\n     }\n \n     fn annotate_expected_due_to_let_ty(\n@@ -708,7 +732,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    pub(crate) fn note_result_coercion(\n+    pub(crate) fn suggest_coercing_result_via_try_operator(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n@@ -2094,3 +2118,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n+\n+pub enum TypeMismatchSource<'tcx> {\n+    /// Expected the binding to have the given type, but it was found to have\n+    /// a different type. Find out when that type first became incompatible.\n+    Ty(Ty<'tcx>),\n+    /// When we fail during method argument checking, try to find out if a previous\n+    /// expression has constrained the method's receiver in a way that makes the\n+    /// argument's type incompatible.\n+    Arg { call_expr: &'tcx hir::Expr<'tcx>, incompatible_arg: usize },\n+}"}, {"sha": "ea1b52daaa5e59b368422b93678b1bd40a7079d8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -472,7 +472,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n         call_span: Span,\n-        call_expr: &hir::Expr<'tcx>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n     ) {\n         // Next, let's construct the error\n         let (error_span, full_call_span, call_name, is_method) = match &call_expr.kind {\n@@ -807,24 +807,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 full_call_span,\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n-            if let (Some(callee_ty), hir::ExprKind::MethodCall(_, rcvr, _, _)) =\n-                (callee_ty, &call_expr.kind)\n+\n+            if let hir::ExprKind::MethodCall(_, rcvr, _, _) = call_expr.kind\n+                && provided_idx.as_usize() == expected_idx.as_usize()\n             {\n-                // Type that would have accepted this argument if it hadn't been inferred earlier.\n-                // FIXME: We leave an inference variable for now, but it'd be nice to get a more\n-                // specific type to increase the accuracy of the diagnostic.\n-                let expected = self.infcx.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::MiscVariable,\n-                    span: full_call_span,\n-                });\n-                self.point_at_expr_source_of_inferred_type(\n+                self.note_source_of_type_mismatch_constraint(\n                     &mut err,\n                     rcvr,\n-                    expected,\n-                    callee_ty,\n-                    provided_arg_span,\n+                    crate::demand::TypeMismatchSource::Arg {\n+                        call_expr,\n+                        incompatible_arg: provided_idx.as_usize(),\n+                    },\n                 );\n             }\n+\n             // Call out where the function is defined\n             self.label_fn_like(\n                 &mut err,"}, {"sha": "9f4558adab150708696dc1aba163bd6cdbacca3d", "filename": "tests/ui/type/type-check/assignment-in-if.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -67,9 +67,6 @@ LL |             x == 5\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:18\n    |\n-LL |     if y = (Foo { foo: x }) {\n-   |                        - here the type of `x` is inferred to be `usize`\n-...\n LL |     if x == x && x = x && x == x {\n    |        ------    ^ expected `bool`, found `usize`\n    |        |\n@@ -78,9 +75,6 @@ LL |     if x == x && x = x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:22\n    |\n-LL |     if y = (Foo { foo: x }) {\n-   |                        - here the type of `x` is inferred to be `usize`\n-...\n LL |     if x == x && x = x && x == x {\n    |                      ^ expected `bool`, found `usize`\n \n@@ -98,9 +92,6 @@ LL |     if x == x && x == x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:51:28\n    |\n-LL |     if y = (Foo { foo: x }) {\n-   |                        - here the type of `x` is inferred to be `usize`\n-...\n LL |     if x == x && x == x && x = x {\n    |        ----------------    ^ expected `bool`, found `usize`\n    |        |"}, {"sha": "15a3b580568d6228164a4b6296c9b5de623b96f0", "filename": "tests/ui/type/type-check/point-at-inference-3.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -2,7 +2,8 @@\n fn main() {\n     let mut v = Vec::new();\n     v.push(0i32);\n-    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+    //~^ NOTE this argument has type `i32`...\n+    //~| NOTE ... which causes `v` to have type `Vec<i32>`\n     v.push(0);\n     v.push(1i32); //~ ERROR mismatched types\n     //~^ NOTE expected `i32`, found `u32`"}, {"sha": "a48c4f9862f75777befe63a3371d5e43735e0e5a", "filename": "tests/ui/type/type-check/point-at-inference-3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -2,7 +2,8 @@\n fn main() {\n     let mut v = Vec::new();\n     v.push(0i32);\n-    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+    //~^ NOTE this argument has type `i32`...\n+    //~| NOTE ... which causes `v` to have type `Vec<i32>`\n     v.push(0);\n     v.push(1u32); //~ ERROR mismatched types\n     //~^ NOTE expected `i32`, found `u32`"}, {"sha": "238764812364cc1c56053efa9b728c665bf4df4d", "filename": "tests/ui/type/type-check/point-at-inference-3.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -1,8 +1,10 @@\n error[E0308]: mismatched types\n-  --> $DIR/point-at-inference-3.rs:7:12\n+  --> $DIR/point-at-inference-3.rs:8:12\n    |\n LL |     v.push(0i32);\n-   |            ---- this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+   |     -      ---- this argument has type `i32`...\n+   |     |\n+   |     ... which causes `v` to have type `Vec<i32>`\n ...\n LL |     v.push(1u32);\n    |       ---- ^^^^ expected `i32`, found `u32`"}, {"sha": "3deb234c2751e308bd2f877eda759e745e2bba21", "filename": "tests/ui/type/type-check/point-at-inference-4.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -11,8 +11,11 @@ fn main() {\n     let s = S(None);\n     s.infer(0i32);\n     //~^ ERROR this method takes 2 arguments but 1 argument was supplied\n+    //~| NOTE this argument has type `i32`...\n+    //~| NOTE ... which causes `s` to have type `S<i32, _>`\n     //~| NOTE an argument is missing\n     //~| HELP provide the argument\n+    //~| HELP change the type of the numeric literal from `i32` to `u32`\n     let t: S<u32, _> = s;\n     //~^ ERROR mismatched types\n     //~| NOTE expected `S<u32, _>`, found `S<i32, _>`"}, {"sha": "5f7bb8b9367ec6d256fb523bb059b95ac7071ce5", "filename": "tests/ui/type/type-check/point-at-inference-4.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -15,15 +15,24 @@ LL |     s.infer(0i32, /* b */);\n    |            ~~~~~~~~~~~~~~~\n \n error[E0308]: mismatched types\n-  --> $DIR/point-at-inference-4.rs:16:24\n+  --> $DIR/point-at-inference-4.rs:19:24\n    |\n+LL |     s.infer(0i32);\n+   |     -       ---- this argument has type `i32`...\n+   |     |\n+   |     ... which causes `s` to have type `S<i32, _>`\n+...\n LL |     let t: S<u32, _> = s;\n    |            ---------   ^ expected `S<u32, _>`, found `S<i32, _>`\n    |            |\n    |            expected due to this\n    |\n    = note: expected struct `S<u32, _>`\n               found struct `S<i32, _>`\n+help: change the type of the numeric literal from `i32` to `u32`\n+   |\n+LL |     s.infer(0u32);\n+   |              ~~~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5fc94d4d1b6baacfc0d8958815041bde4fbf7f89", "filename": "tests/ui/type/type-check/point-at-inference.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/point-at-inference.rs:12:9\n    |\n LL |         foo.push(i);\n-   |                  - this is of type `&{integer}`, which causes `foo` to be inferred as `Vec<&{integer}>`\n+   |         ---      - this argument has type `&{integer}`...\n+   |         |\n+   |         ... which causes `foo` to have type `Vec<&{integer}>`\n ...\n LL |     bar(foo);\n    |     --- ^^^ expected `Vec<i32>`, found `Vec<&{integer}>`"}, {"sha": "72533ab1fa37f8a7384283e0201a0ef92d68c67d", "filename": "tests/ui/typeck/bad-type-in-vec-contains.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -7,7 +7,6 @@ LL |     primes.contains(3);\n    |            |        expected `&_`, found integer\n    |            |        help: consider borrowing here: `&3`\n    |            arguments to this method are incorrect\n-   |            here the type of `primes` is inferred to be `[_]`\n    |\n    = note: expected reference `&_`\n                    found type `{integer}`"}, {"sha": "1d5337260fa0ab289f33a6b575385c8f5d914cf2", "filename": "tests/ui/typeck/bad-type-in-vec-push.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -1,8 +1,6 @@\n error[E0308]: mismatched types\n   --> $DIR/bad-type-in-vec-push.rs:11:17\n    |\n-LL |     vector.sort();\n-   |     ------ here the type of `vector` is inferred to be `Vec<_>`\n LL |     result.push(vector);\n    |            ---- ^^^^^^ expected integer, found `Vec<_>`\n    |            |"}, {"sha": "b97e74b7e53fa22d08189a899a1abfeb1caf01ca", "filename": "tests/ui/typeck/issue-107775.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107775.stderr?ref=7bfccb3d7f413821b1fbeb044a2d35b3bf4a035e", "patch": "@@ -2,9 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-107775.rs:35:16\n    |\n LL |         map.insert(1, Struct::do_something);\n-   |                    -  -------------------- this is of type `fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}`, which causes `map` to be inferred as `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n-   |                    |\n-   |                    this is of type `{integer}`, which causes `map` to be inferred as `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n+   |         ---           -------------------- this argument has type `fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}`...\n+   |         |\n+   |         ... which causes `map` to have type `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n LL |         Self { map }\n    |                ^^^ expected `HashMap<u16, fn(u8) -> Pin<...>>`, found `HashMap<{integer}, ...>`\n    |"}]}