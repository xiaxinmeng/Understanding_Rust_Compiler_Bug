{"sha": "aab3bcecb7da86b141d9a39079afedd0820115e6", "node_id": "C_kwDOAAsO6NoAKGFhYjNiY2VjYjdkYTg2YjE0MWQ5YTM5MDc5YWZlZGQwODIwMTE1ZTY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-09T07:54:39Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-09T07:54:39Z"}, "message": "Merge from rustc", "tree": {"sha": "2f4932efa6ea145fbecbf32cb89dff3bc62e0d85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f4932efa6ea145fbecbf32cb89dff3bc62e0d85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aab3bcecb7da86b141d9a39079afedd0820115e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aab3bcecb7da86b141d9a39079afedd0820115e6", "html_url": "https://github.com/rust-lang/rust/commit/aab3bcecb7da86b141d9a39079afedd0820115e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aab3bcecb7da86b141d9a39079afedd0820115e6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e9f8393f87f8bdfad388fe112464d97661a8cb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9f8393f87f8bdfad388fe112464d97661a8cb2", "html_url": "https://github.com/rust-lang/rust/commit/4e9f8393f87f8bdfad388fe112464d97661a8cb2"}, {"sha": "b70a869d8f49e87d8432de6af6d209243a7053a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b70a869d8f49e87d8432de6af6d209243a7053a4", "html_url": "https://github.com/rust-lang/rust/commit/b70a869d8f49e87d8432de6af6d209243a7053a4"}], "stats": {"total": 7857, "additions": 4804, "deletions": 3053}, "files": [{"sha": "4011a6fa6b95b3e0104a4f99ab5c912790d7a333", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -28,7 +28,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/15.0-2022-08-09\n+\tbranch = rustc/15.0-2022-12-07\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "844cf99b4688d0cc0daa3a85d09d985df4822147", "filename": "Cargo.lock", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -581,6 +581,7 @@ dependencies = [\n  \"libc\",\n  \"num-integer\",\n  \"num-traits\",\n+ \"serde\",\n  \"time\",\n  \"winapi\",\n ]\n@@ -730,6 +731,16 @@ dependencies = [\n  \"rustc-semver\",\n ]\n \n+[[package]]\n+name = \"collect-license-metadata\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"spdx-rs\",\n+]\n+\n [[package]]\n name = \"color-eyre\"\n version = \"0.6.2\"\n@@ -1552,6 +1563,15 @@ dependencies = [\n  \"termcolor\",\n ]\n \n+[[package]]\n+name = \"generate-copyright\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"generic-array\"\n version = \"0.14.4\"\n@@ -2085,9 +2105,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.135\"\n+version = \"0.2.138\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n+checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -4328,6 +4348,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n+ \"termize\",\n  \"tracing\",\n  \"winapi\",\n ]\n@@ -4864,6 +4885,35 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"spdx-expression\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"53d7ac03c67c572d85049d6db815e20a4a19b41b3d5cca732ac582342021ad77\"\n+dependencies = [\n+ \"nom\",\n+ \"serde\",\n+ \"thiserror\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"spdx-rs\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b3c02f6eb7e7b4100c272f685a9ccaccaab302324e8c7ec3e2ee72340fb29ff3\"\n+dependencies = [\n+ \"chrono\",\n+ \"log\",\n+ \"nom\",\n+ \"serde\",\n+ \"spdx-expression\",\n+ \"strum\",\n+ \"strum_macros\",\n+ \"thiserror\",\n+ \"uuid\",\n+]\n+\n [[package]]\n name = \"stable_deref_trait\"\n version = \"1.2.0\"\n@@ -4967,6 +5017,25 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n \n+[[package]]\n+name = \"strum\"\n+version = \"0.24.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"063e6045c0e62079840579a7e47a355ae92f60eb74daaf156fb1e84ba164e63f\"\n+\n+[[package]]\n+name = \"strum_macros\"\n+version = \"0.24.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e385be0d24f186b4ce2f9982191e7101bb737312ad61c1f2f984f34bcf85d59\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"rustversion\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"syn\"\n version = \"1.0.102\"\n@@ -5596,6 +5665,15 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8772a4ccbb4e89959023bc5b7cb8623a795caa7092d99f3aa9501b9484d4557d\"\n \n+[[package]]\n+name = \"uuid\"\n+version = \"0.8.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bc5cf98d8186244414c848017f0e2676b3fcb46807f6668a97dfe67359a3c4b7\"\n+dependencies = [\n+ \"getrandom 0.2.0\",\n+]\n+\n [[package]]\n name = \"valuable\"\n version = \"0.1.0\""}, {"sha": "000c10a1f906d6c161f1835651754679e35c3bd9", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -39,6 +39,8 @@ members = [\n   \"src/tools/bump-stage0\",\n   \"src/tools/replace-version-placeholder\",\n   \"src/tools/lld-wrapper\",\n+  \"src/tools/collect-license-metadata\",\n+  \"src/tools/generate-copyright\",\n ]\n \n exclude = ["}, {"sha": "e14c9ea9a5d1a913d1af20f97776f5a7a43f4b9f", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -9,6 +9,8 @@ use std::ops::{Add, AddAssign, Mul, RangeInclusive, Sub};\n use std::str::FromStr;\n \n use bitflags::bitflags;\n+#[cfg(feature = \"nightly\")]\n+use rustc_data_structures::stable_hasher::StableOrd;\n use rustc_index::vec::{Idx, IndexVec};\n #[cfg(feature = \"nightly\")]\n use rustc_macros::HashStable_Generic;\n@@ -403,6 +405,11 @@ pub struct Size {\n     raw: u64,\n }\n \n+// Safety: Ord is implement as just comparing numerical values and numerical values\n+// are not changed by (de-)serialization.\n+#[cfg(feature = \"nightly\")]\n+unsafe impl StableOrd for Size {}\n+\n // This is debug-printed a lot in larger structs, don't waste too much space there\n impl fmt::Debug for Size {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "24e2985cf567a3838ee13e168d5d944c7078e6f5", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 87, "deletions": 123, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::DUMMY_SP;\n use thin_vec::thin_vec;\n \n@@ -147,6 +147,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ),\n                 ExprKind::Async(capture_clause, closure_node_id, block) => self.make_async_expr(\n                     *capture_clause,\n+                    None,\n                     *closure_node_id,\n                     None,\n                     e.span,\n@@ -435,18 +436,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let lhs = self.lower_cond(lhs);\n                 let rhs = self.lower_cond(rhs);\n \n-                self.arena.alloc(self.expr(\n-                    cond.span,\n-                    hir::ExprKind::Binary(op, lhs, rhs),\n-                    AttrVec::new(),\n-                ))\n+                self.arena.alloc(self.expr(cond.span, hir::ExprKind::Binary(op, lhs, rhs)))\n             }\n             ExprKind::Let(..) => self.lower_expr(cond),\n             _ => {\n                 let cond = self.lower_expr(cond);\n                 let reason = DesugaringKind::CondTemporary;\n                 let span_block = self.mark_span_with_reason(reason, cond.span, None);\n-                self.expr_drop_temps(span_block, cond, AttrVec::new())\n+                self.expr_drop_temps(span_block, cond)\n             }\n         }\n     }\n@@ -476,12 +473,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         let lowered_cond = self.with_loop_condition_scope(|t| t.lower_cond(cond));\n         let then = self.lower_block_expr(body);\n-        let expr_break = self.expr_break(span, AttrVec::new());\n+        let expr_break = self.expr_break(span);\n         let stmt_break = self.stmt_expr(span, expr_break);\n         let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n-        let else_expr = self.arena.alloc(self.expr_block(else_blk, AttrVec::new()));\n+        let else_expr = self.arena.alloc(self.expr_block(else_blk));\n         let if_kind = hir::ExprKind::If(lowered_cond, self.arena.alloc(then), Some(else_expr));\n-        let if_expr = self.expr(span, if_kind, AttrVec::new());\n+        let if_expr = self.expr(span, if_kind);\n         let block = self.block_expr(self.arena.alloc(if_expr));\n         let span = self.lower_span(span.with_hi(cond.span.hi()));\n         let opt_label = self.lower_label(opt_label);\n@@ -537,12 +534,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         expr: &'hir hir::Expr<'hir>,\n         overall_span: Span,\n     ) -> &'hir hir::Expr<'hir> {\n-        let constructor = self.arena.alloc(self.expr_lang_item_path(\n-            method_span,\n-            lang_item,\n-            AttrVec::new(),\n-            None,\n-        ));\n+        let constructor = self.arena.alloc(self.expr_lang_item_path(method_span, lang_item, None));\n         self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n     }\n \n@@ -584,6 +576,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n+        outer_hir_id: Option<hir::HirId>,\n         closure_node_id: NodeId,\n         ret_ty: Option<hir::FnRetTy<'hir>>,\n         span: Span,\n@@ -592,14 +585,38 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         let output = ret_ty.unwrap_or_else(|| hir::FnRetTy::DefaultReturn(self.lower_span(span)));\n \n-        // Resume argument type: `ResumeTy`\n-        let unstable_span =\n-            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n-        let resume_ty = hir::QPath::LangItem(hir::LangItem::ResumeTy, unstable_span, None);\n+        // Resume argument type, which should be `&mut Context<'_>`.\n+        // NOTE: Using the `'static` lifetime here is technically cheating.\n+        // The `Future::poll` argument really is `&'a mut Context<'b>`, but we cannot\n+        // express the fact that we are not storing it across yield-points yet,\n+        // and we would thus run into lifetime errors.\n+        // See <https://github.com/rust-lang/rust/issues/68923>.\n+        // Our lowering makes sure we are not mis-using the `_task_context` input type\n+        // in the sense that we are indeed not using it across yield points. We\n+        // get a fresh `&mut Context` for each resume / call of `Future::poll`.\n+        // This \"cheating\" was previously done with a `ResumeTy` that contained a raw\n+        // pointer, and a `get_context` accessor that pulled the `Context` lifetimes\n+        // out of thin air.\n+        let context_lifetime_ident = Ident::with_dummy_span(kw::StaticLifetime);\n+        let context_lifetime = self.arena.alloc(hir::Lifetime {\n+            hir_id: self.next_id(),\n+            ident: context_lifetime_ident,\n+            res: hir::LifetimeName::Static,\n+        });\n+        let context_path =\n+            hir::QPath::LangItem(hir::LangItem::Context, self.lower_span(span), None);\n+        let context_ty = hir::MutTy {\n+            ty: self.arena.alloc(hir::Ty {\n+                hir_id: self.next_id(),\n+                kind: hir::TyKind::Path(context_path),\n+                span: self.lower_span(span),\n+            }),\n+            mutbl: hir::Mutability::Mut,\n+        };\n         let input_ty = hir::Ty {\n             hir_id: self.next_id(),\n-            kind: hir::TyKind::Path(resume_ty),\n-            span: unstable_span,\n+            kind: hir::TyKind::Rptr(context_lifetime, context_ty),\n+            span: self.lower_span(span),\n         };\n \n         // The closure/generator `FnDecl` takes a single (resume) argument of type `input_ty`.\n@@ -651,18 +668,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             hir::ExprKind::Closure(c)\n         };\n-        let parent_has_track_caller = self\n-            .attrs\n-            .values()\n-            .find(|attrs| attrs.into_iter().find(|attr| attr.has_name(sym::track_caller)).is_some())\n-            .is_some();\n+\n+        let track_caller = outer_hir_id\n+            .and_then(|id| self.attrs.get(&id.local_id))\n+            .map_or(false, |attrs| attrs.into_iter().any(|attr| attr.has_name(sym::track_caller)));\n+\n+        let hir_id = self.lower_node_id(closure_node_id);\n         let unstable_span =\n             self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n-\n-        let hir_id = if parent_has_track_caller {\n-            let generator_hir_id = self.lower_node_id(closure_node_id);\n+        if track_caller {\n             self.lower_attrs(\n-                generator_hir_id,\n+                hir_id,\n                 &[Attribute {\n                     kind: AttrKind::Normal(ptr::P(NormalAttr {\n                         item: AttrItem {\n@@ -677,10 +693,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     span: unstable_span,\n                 }],\n             );\n-            generator_hir_id\n-        } else {\n-            self.lower_node_id(closure_node_id)\n-        };\n+        }\n \n         let generator = hir::Expr { hir_id, kind: generator_kind, span: self.lower_span(span) };\n \n@@ -693,12 +706,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // E0700 in src/test/ui/self/self_lifetime-async.rs\n \n         // `future::identity_future`:\n-        let identity_future = self.expr_lang_item_path(\n-            unstable_span,\n-            hir::LangItem::IdentityFuture,\n-            AttrVec::new(),\n-            None,\n-        );\n+        let identity_future =\n+            self.expr_lang_item_path(unstable_span, hir::LangItem::IdentityFuture, None);\n \n         // `future::identity_future(generator)`:\n         hir::ExprKind::Call(self.arena.alloc(identity_future), arena_vec![self; generator])\n@@ -710,7 +719,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ///     mut __awaitee => loop {\n     ///         match unsafe { ::std::future::Future::poll(\n     ///             <::std::pin::Pin>::new_unchecked(&mut __awaitee),\n-    ///             ::std::future::get_context(task_context),\n+    ///             task_context,\n     ///         ) } {\n     ///             ::std::task::Poll::Ready(result) => break result,\n     ///             ::std::task::Poll::Pending => {}\n@@ -751,7 +760,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // unsafe {\n         //     ::std::future::Future::poll(\n         //         ::std::pin::Pin::new_unchecked(&mut __awaitee),\n-        //         ::std::future::get_context(task_context),\n+        //         task_context,\n         //     )\n         // }\n         let poll_expr = {\n@@ -769,16 +778,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 arena_vec![self; ref_mut_awaitee],\n                 Some(expr_hir_id),\n             );\n-            let get_context = self.expr_call_lang_item_fn_mut(\n-                gen_future_span,\n-                hir::LangItem::GetContext,\n-                arena_vec![self; task_context],\n-                Some(expr_hir_id),\n-            );\n             let call = self.expr_call_lang_item_fn(\n                 span,\n                 hir::LangItem::FuturePoll,\n-                arena_vec![self; new_unchecked, get_context],\n+                arena_vec![self; new_unchecked, task_context],\n                 Some(expr_hir_id),\n             );\n             self.arena.alloc(self.expr_unsafe(call))\n@@ -801,7 +804,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let break_x = self.with_loop_scope(loop_node_id, move |this| {\n                 let expr_break =\n                     hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n-                this.arena.alloc(this.expr(gen_future_span, expr_break, AttrVec::new()))\n+                this.arena.alloc(this.expr(gen_future_span, expr_break))\n             });\n             self.arm(ready_pat, break_x)\n         };\n@@ -834,17 +837,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let yield_expr = self.expr(\n                 span,\n                 hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr_hir_id) }),\n-                AttrVec::new(),\n             );\n             let yield_expr = self.arena.alloc(yield_expr);\n \n             if let Some(task_context_hid) = self.task_context {\n                 let lhs = self.expr_ident(span, task_context_ident, task_context_hid);\n-                let assign = self.expr(\n-                    span,\n-                    hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)),\n-                    AttrVec::new(),\n-                );\n+                let assign =\n+                    self.expr(span, hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)));\n                 self.stmt_expr(span, assign)\n             } else {\n                 // Use of `await` outside of an async context. Return `yield_expr` so that we can\n@@ -1019,13 +1018,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 let async_body = this.make_async_expr(\n                     capture_clause,\n+                    // FIXME(nbdd0121): This should also use a proper HIR id so `#[track_caller]`\n+                    // can be applied on async closures as well.\n+                    None,\n                     inner_closure_id,\n                     async_ret_ty,\n                     body.span,\n                     hir::AsyncGeneratorKind::Closure,\n                     |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n                 );\n-                this.expr(fn_decl_span, async_body, AttrVec::new())\n+                this.expr(fn_decl_span, async_body)\n             });\n             body_id\n         });\n@@ -1285,7 +1287,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let ident = self.expr_ident(lhs.span, ident, binding);\n         let assign =\n             hir::ExprKind::Assign(self.lower_expr(lhs), ident, self.lower_span(eq_sign_span));\n-        let expr = self.expr(lhs.span, assign, AttrVec::new());\n+        let expr = self.expr(lhs.span, assign);\n         assignments.push(self.stmt_expr(lhs.span, expr));\n         pat\n     }\n@@ -1326,8 +1328,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let e2 = self.lower_expr_mut(e2);\n         let fn_path =\n             hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, self.lower_span(span), None);\n-        let fn_expr =\n-            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), AttrVec::new()));\n+        let fn_expr = self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path)));\n         hir::ExprKind::Call(fn_expr, arena_vec![self; e1, e2])\n     }\n \n@@ -1499,8 +1500,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `None => break`\n         let none_arm = {\n-            let break_expr =\n-                self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span, AttrVec::new()));\n+            let break_expr = self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span));\n             let pat = self.pat_none(for_span);\n             self.arm(pat, break_expr)\n         };\n@@ -1509,7 +1509,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let some_arm = {\n             let some_pat = self.pat_some(pat_span, pat);\n             let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n-            let body_expr = self.arena.alloc(self.expr_block(body_block, AttrVec::new()));\n+            let body_expr = self.arena.alloc(self.expr_block(body_block));\n             self.arm(some_pat, body_expr)\n         };\n \n@@ -1572,7 +1572,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // surrounding scope of the `match` since the `match` is not a terminating scope.\n         //\n         // Also, add the attributes to the outer returned expr node.\n-        self.expr_drop_temps_mut(for_span, match_expr, e.attrs.clone())\n+        let expr = self.expr_drop_temps_mut(for_span, match_expr);\n+        self.lower_attrs(expr.hir_id, &e.attrs);\n+        expr\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:\n@@ -1627,12 +1629,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let continue_arm = {\n             let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n-            let val_expr = self.arena.alloc(self.expr_ident_with_attrs(\n-                span,\n-                val_ident,\n-                val_pat_nid,\n-                attrs.clone(),\n-            ));\n+            let val_expr = self.expr_ident(span, val_ident, val_pat_nid);\n+            self.lower_attrs(val_expr.hir_id, &attrs);\n             let continue_pat = self.pat_cf_continue(unstable_span, val_pat);\n             self.arm(continue_pat, val_expr)\n         };\n@@ -1658,15 +1656,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::Destination { label: None, target_id },\n                         Some(from_residual_expr),\n                     ),\n-                    attrs,\n                 ))\n             } else {\n-                self.arena.alloc(self.expr(\n-                    try_span,\n-                    hir::ExprKind::Ret(Some(from_residual_expr)),\n-                    attrs,\n-                ))\n+                self.arena.alloc(self.expr(try_span, hir::ExprKind::Ret(Some(from_residual_expr))))\n             };\n+            self.lower_attrs(ret_expr.hir_id, &attrs);\n \n             let break_pat = self.pat_cf_break(try_span, residual_local);\n             self.arm(break_pat, ret_expr)\n@@ -1731,18 +1725,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         expr: &'hir hir::Expr<'hir>,\n-        attrs: AttrVec,\n     ) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr_drop_temps_mut(span, expr, attrs))\n+        self.arena.alloc(self.expr_drop_temps_mut(span, expr))\n     }\n \n     pub(super) fn expr_drop_temps_mut(\n         &mut self,\n         span: Span,\n         expr: &'hir hir::Expr<'hir>,\n-        attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n+        self.expr(span, hir::ExprKind::DropTemps(expr))\n     }\n \n     fn expr_match(\n@@ -1752,29 +1744,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         arms: &'hir [hir::Arm<'hir>],\n         source: hir::MatchSource,\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Match(arg, arms, source), AttrVec::new())\n+        self.expr(span, hir::ExprKind::Match(arg, arms, source))\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> hir::Expr<'hir> {\n+    fn expr_break(&mut self, span: Span) -> hir::Expr<'hir> {\n         let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n-        self.expr(span, expr_break, attrs)\n+        self.expr(span, expr_break)\n     }\n \n-    fn expr_break_alloc(&mut self, span: Span, attrs: AttrVec) -> &'hir hir::Expr<'hir> {\n-        let expr_break = self.expr_break(span, attrs);\n+    fn expr_break_alloc(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n+        let expr_break = self.expr_break(span);\n         self.arena.alloc(expr_break)\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n-        self.expr(\n-            span,\n-            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n-            AttrVec::new(),\n-        )\n+        self.expr(span, hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e))\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), AttrVec::new()))\n+        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[])))\n     }\n \n     fn expr_call_mut(\n@@ -1783,7 +1771,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         e: &'hir hir::Expr<'hir>,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Call(e, args), AttrVec::new())\n+        self.expr(span, hir::ExprKind::Call(e, args))\n     }\n \n     fn expr_call(\n@@ -1802,8 +1790,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         args: &'hir [hir::Expr<'hir>],\n         hir_id: Option<hir::HirId>,\n     ) -> hir::Expr<'hir> {\n-        let path =\n-            self.arena.alloc(self.expr_lang_item_path(span, lang_item, AttrVec::new(), hir_id));\n+        let path = self.arena.alloc(self.expr_lang_item_path(span, lang_item, hir_id));\n         self.expr_call_mut(span, path, args)\n     }\n \n@@ -1821,13 +1808,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         lang_item: hir::LangItem,\n-        attrs: AttrVec,\n         hir_id: Option<hir::HirId>,\n     ) -> hir::Expr<'hir> {\n         self.expr(\n             span,\n             hir::ExprKind::Path(hir::QPath::LangItem(lang_item, self.lower_span(span), hir_id)),\n-            attrs,\n         )\n     }\n \n@@ -1841,20 +1826,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn expr_ident_mut(\n-        &mut self,\n-        sp: Span,\n-        ident: Ident,\n-        binding: hir::HirId,\n-    ) -> hir::Expr<'hir> {\n-        self.expr_ident_with_attrs(sp, ident, binding, AttrVec::new())\n-    }\n-\n-    fn expr_ident_with_attrs(\n         &mut self,\n         span: Span,\n         ident: Ident,\n         binding: hir::HirId,\n-        attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n         let res = Res::Local(binding);\n@@ -1867,7 +1842,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }),\n         ));\n \n-        self.expr(span, expr_path, attrs)\n+        self.expr(span, expr_path)\n     }\n \n     fn expr_unsafe(&mut self, expr: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n@@ -1886,32 +1861,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }),\n                 None,\n             ),\n-            AttrVec::new(),\n         )\n     }\n \n     fn expr_block_empty(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n         let blk = self.block_all(span, &[], None);\n-        let expr = self.expr_block(blk, AttrVec::new());\n+        let expr = self.expr_block(blk);\n         self.arena.alloc(expr)\n     }\n \n-    pub(super) fn expr_block(\n-        &mut self,\n-        b: &'hir hir::Block<'hir>,\n-        attrs: AttrVec,\n-    ) -> hir::Expr<'hir> {\n-        self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n+    pub(super) fn expr_block(&mut self, b: &'hir hir::Block<'hir>) -> hir::Expr<'hir> {\n+        self.expr(b.span, hir::ExprKind::Block(b, None))\n     }\n \n-    pub(super) fn expr(\n-        &mut self,\n-        span: Span,\n-        kind: hir::ExprKind<'hir>,\n-        attrs: AttrVec,\n-    ) -> hir::Expr<'hir> {\n+    pub(super) fn expr(&mut self, span: Span, kind: hir::ExprKind<'hir>) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n-        self.lower_attrs(hir_id, &attrs);\n         hir::Expr { hir_id, kind, span: self.lower_span(span) }\n     }\n "}, {"sha": "d73d6d3918ea618dde2c3bbaa77e0954c73f5627", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -253,8 +253,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n                     let asyncness = header.asyncness;\n-                    let body_id =\n-                        this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n+                    let body_id = this.lower_maybe_async_body(\n+                        span,\n+                        hir_id,\n+                        &decl,\n+                        asyncness,\n+                        body.as_deref(),\n+                    );\n \n                     let mut itctx = ImplTraitContext::Universal;\n                     let (generics, decl) = this.lower_generics(generics, id, &mut itctx, |this| {\n@@ -701,6 +706,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_trait_item(&mut self, i: &AssocItem) -> &'hir hir::TraitItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n+        self.lower_attrs(hir_id, &i.attrs);\n         let trait_item_def_id = hir_id.expect_owner();\n \n         let (generics, kind, has_default) = match &i.kind {\n@@ -724,7 +730,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::Fn(box Fn { sig, generics, body: Some(body), .. }) => {\n                 let asyncness = sig.header.asyncness;\n                 let body_id =\n-                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, Some(&body));\n+                    self.lower_maybe_async_body(i.span, hir_id, &sig.decl, asyncness, Some(&body));\n                 let (generics, sig) = self.lower_method_sig(\n                     generics,\n                     sig,\n@@ -759,7 +765,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::MacCall(..) => panic!(\"macro item shouldn't exist at this point\"),\n         };\n \n-        self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::TraitItem {\n             owner_id: trait_item_def_id,\n             ident: self.lower_ident(i.ident),\n@@ -791,13 +796,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     /// Construct `ExprKind::Err` for the given `span`.\n     pub(crate) fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Err, AttrVec::new())\n+        self.expr(span, hir::ExprKind::Err)\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> &'hir hir::ImplItem<'hir> {\n         // Since `default impl` is not yet implemented, this is always true in impls.\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n+        let hir_id = self.lower_node_id(i.id);\n+        self.lower_attrs(hir_id, &i.attrs);\n \n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n@@ -810,8 +817,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::Fn(box Fn { sig, generics, body, .. }) => {\n                 self.current_item = Some(i.span);\n                 let asyncness = sig.header.asyncness;\n-                let body_id =\n-                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, body.as_deref());\n+                let body_id = self.lower_maybe_async_body(\n+                    i.span,\n+                    hir_id,\n+                    &sig.decl,\n+                    asyncness,\n+                    body.as_deref(),\n+                );\n                 let (generics, sig) = self.lower_method_sig(\n                     generics,\n                     sig,\n@@ -844,8 +856,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::MacCall(..) => panic!(\"`TyMac` should have been expanded by now\"),\n         };\n \n-        let hir_id = self.lower_node_id(i.id);\n-        self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ImplItem {\n             owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(i.ident),\n@@ -978,6 +988,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_maybe_async_body(\n         &mut self,\n         span: Span,\n+        fn_id: hir::HirId,\n         decl: &FnDecl,\n         asyncness: Async,\n         body: Option<&Block>,\n@@ -1128,6 +1139,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value,\n+                Some(fn_id),\n                 closure_id,\n                 None,\n                 body.span,\n@@ -1139,11 +1151,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // Transform into `drop-temps { <user-body> }`, an expression:\n                     let desugared_span =\n                         this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None);\n-                    let user_body = this.expr_drop_temps(\n-                        desugared_span,\n-                        this.arena.alloc(user_body),\n-                        AttrVec::new(),\n-                    );\n+                    let user_body =\n+                        this.expr_drop_temps(desugared_span, this.arena.alloc(user_body));\n \n                     // As noted above, create the final block like\n                     //\n@@ -1160,14 +1169,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         Some(user_body),\n                     );\n \n-                    this.expr_block(body, AttrVec::new())\n+                    this.expr_block(body)\n                 },\n             );\n \n-            (\n-                this.arena.alloc_from_iter(parameters),\n-                this.expr(body.span, async_expr, AttrVec::new()),\n-            )\n+            (this.arena.alloc_from_iter(parameters), this.expr(body.span, async_expr))\n         })\n     }\n "}, {"sha": "4fa18907fcd466cd262eeddc2968514d01022945", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -259,6 +259,8 @@ enum ImplTraitContext {\n     },\n     /// Impl trait in type aliases.\n     TypeAliasesOpaqueTy,\n+    /// `impl Trait` is unstably accepted in this position.\n+    FeatureGated(ImplTraitPosition, Symbol),\n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n }\n@@ -1372,25 +1374,23 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         path\n                     }\n-                    ImplTraitContext::Disallowed(\n-                        position @ (ImplTraitPosition::TraitReturn | ImplTraitPosition::ImplReturn),\n-                    ) => {\n+                    ImplTraitContext::FeatureGated(position, feature) => {\n                         self.tcx\n                             .sess\n                             .create_feature_err(\n                                 MisplacedImplTrait {\n                                     span: t.span,\n-                                    position: DiagnosticArgFromDisplay(&position),\n+                                    position: DiagnosticArgFromDisplay(position),\n                                 },\n-                                sym::return_position_impl_trait_in_trait,\n+                                *feature,\n                             )\n                             .emit();\n                         hir::TyKind::Err\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n                         self.tcx.sess.emit_err(MisplacedImplTrait {\n                             span: t.span,\n-                            position: DiagnosticArgFromDisplay(&position),\n+                            position: DiagnosticArgFromDisplay(position),\n                         });\n                         hir::TyKind::Err\n                     }\n@@ -1739,14 +1739,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         } else {\n             match &decl.output {\n                 FnRetTy::Ty(ty) => {\n-                    let mut context = if kind.return_impl_trait_allowed(self.tcx) {\n+                    let context = if kind.return_impl_trait_allowed(self.tcx) {\n                         let fn_def_id = self.local_def_id(fn_node_id);\n                         ImplTraitContext::ReturnPositionOpaqueTy {\n                             origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                             in_trait: matches!(kind, FnDeclKind::Trait),\n                         }\n                     } else {\n-                        ImplTraitContext::Disallowed(match kind {\n+                        let position = match kind {\n                             FnDeclKind::Fn | FnDeclKind::Inherent => {\n                                 unreachable!(\"fn should allow in-band lifetimes\")\n                             }\n@@ -1755,9 +1755,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             FnDeclKind::Pointer => ImplTraitPosition::PointerReturn,\n                             FnDeclKind::Trait => ImplTraitPosition::TraitReturn,\n                             FnDeclKind::Impl => ImplTraitPosition::ImplReturn,\n-                        })\n+                        };\n+                        match kind {\n+                            FnDeclKind::Trait | FnDeclKind::Impl => ImplTraitContext::FeatureGated(\n+                                position,\n+                                sym::return_position_impl_trait_in_trait,\n+                            ),\n+                            _ => ImplTraitContext::Disallowed(position),\n+                        }\n                     };\n-                    hir::FnRetTy::Return(self.lower_ty(ty, &mut context))\n+                    hir::FnRetTy::Return(self.lower_ty(ty, &context))\n                 }\n                 FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(self.lower_span(*span)),\n             }\n@@ -1938,7 +1945,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     output,\n                     span,\n                     if in_trait && !this.tcx.features().return_position_impl_trait_in_trait {\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::TraitReturn)\n+                        ImplTraitContext::FeatureGated(\n+                            ImplTraitPosition::TraitReturn,\n+                            sym::return_position_impl_trait_in_trait,\n+                        )\n                     } else {\n                         ImplTraitContext::ReturnPositionOpaqueTy {\n                             origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n@@ -2291,7 +2301,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// has no attributes and is not targeted by a `break`.\n     fn lower_block_expr(&mut self, b: &Block) -> hir::Expr<'hir> {\n         let block = self.lower_block(b, false);\n-        self.expr_block(block, AttrVec::new())\n+        self.expr_block(block)\n     }\n \n     fn lower_array_length(&mut self, c: &AnonConst) -> hir::ArrayLen {"}, {"sha": "592fc5aa6456f064e0d399f5a0c1487067f147ce", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::{self as ast, *};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, PartialRes, Res};\n use rustc_hir::GenericArg;\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use smallvec::{smallvec, SmallVec};\n@@ -352,11 +352,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // fn f(_: impl Fn() -> impl Debug) -> impl Fn() -> impl Debug\n             // //      disallowed --^^^^^^^^^^        allowed --^^^^^^^^^^\n             // ```\n-            FnRetTy::Ty(ty)\n-                if matches!(itctx, ImplTraitContext::ReturnPositionOpaqueTy { .. })\n-                    && self.tcx.features().impl_trait_in_fn_trait_return =>\n-            {\n-                self.lower_ty(&ty, itctx)\n+            FnRetTy::Ty(ty) if matches!(itctx, ImplTraitContext::ReturnPositionOpaqueTy { .. }) => {\n+                if self.tcx.features().impl_trait_in_fn_trait_return {\n+                    self.lower_ty(&ty, itctx)\n+                } else {\n+                    self.lower_ty(\n+                        &ty,\n+                        &ImplTraitContext::FeatureGated(\n+                            ImplTraitPosition::FnTraitReturn,\n+                            sym::impl_trait_in_fn_trait_return,\n+                        ),\n+                    )\n+                }\n             }\n             FnRetTy::Ty(ty) => {\n                 self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))"}, {"sha": "5b6a07721e2bbdb605710cfb2a701f5e90078584", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -348,21 +348,10 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"trait\"));\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                // FIXME(durka) this seems to be some quite outdated syntax\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ptr, ast::TraitBoundModifier::Maybe) = b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b.clone());\n-                    }\n-                }\n                 self.nbsp();\n-                if !real_bounds.is_empty() {\n+                if !bounds.is_empty() {\n                     self.word_nbsp(\"=\");\n-                    self.print_type_bounds(&real_bounds);\n+                    self.print_type_bounds(&bounds);\n                 }\n                 self.print_where_clause(&generics.where_clause);\n                 self.word(\";\");"}, {"sha": "ab5e19050ead2ffbb0a0d475c69d985ec86fb588", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 69, "deletions": 65, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -277,8 +277,7 @@ where\n             allowed_through_unstable_modules = true;\n         }\n         // attributes with data\n-        else if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta {\n-            let meta = meta.as_ref().unwrap();\n+        else if let Some(meta @ MetaItem { kind: MetaItemKind::List(metas), .. }) = &meta {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(\n@@ -533,25 +532,24 @@ where\n \n     // Merge the const-unstable info into the stability info\n     if promotable {\n-        if let Some((ref mut stab, _)) = const_stab {\n-            stab.promotable = promotable;\n-        } else {\n-            sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp });\n+        match &mut const_stab {\n+            Some((stab, _)) => stab.promotable = promotable,\n+            _ => _ = sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp }),\n         }\n     }\n \n     if allowed_through_unstable_modules {\n-        if let Some((\n-            Stability {\n-                level: StabilityLevel::Stable { ref mut allowed_through_unstable_modules, .. },\n-                ..\n-            },\n-            _,\n-        )) = stab\n-        {\n-            *allowed_through_unstable_modules = true;\n-        } else {\n-            sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+        match &mut stab {\n+            Some((\n+                Stability {\n+                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n+                    ..\n+                },\n+                _,\n+            )) => *allowed_through_unstable_modules = true,\n+            _ => {\n+                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+            }\n         }\n     }\n \n@@ -654,8 +652,8 @@ pub fn eval_condition(\n     features: Option<&Features>,\n     eval: &mut impl FnMut(Condition) -> bool,\n ) -> bool {\n-    match cfg.kind {\n-        ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n+    match &cfg.kind {\n+        ast::MetaItemKind::List(mis) if cfg.name_or_empty() == sym::version => {\n             try_gate_cfg(sym::version, cfg.span, sess, features);\n             let (min_version, span) = match &mis[..] {\n                 [NestedMetaItem::Lit(MetaItemLit { kind: LitKind::Str(sym, ..), span, .. })] => {\n@@ -688,7 +686,7 @@ pub fn eval_condition(\n                 rustc_version >= min_version\n             }\n         }\n-        ast::MetaItemKind::List(ref mis) => {\n+        ast::MetaItemKind::List(mis) => {\n             for mi in mis.iter() {\n                 if !mi.is_meta_item() {\n                     handle_errors(\n@@ -759,7 +757,7 @@ pub fn eval_condition(\n             sess.emit_err(session_diagnostics::CfgPredicateIdentifier { span: cfg.path.span });\n             true\n         }\n-        MetaItemKind::NameValue(ref lit) if !lit.kind.is_str() => {\n+        MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n             handle_errors(\n                 sess,\n                 lit.span,\n@@ -1036,52 +1034,58 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     });\n                 }\n             } else if let Some(meta_item) = item.meta_item() {\n-                if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n-                    if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n-                        let name = meta_item.name_or_empty().to_ident_string();\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n-                            span: item.span(),\n-                            repr_arg: &name,\n-                            cause: IncorrectReprFormatGenericCause::from_lit_kind(\n-                                item.span(),\n-                                &value.kind,\n-                                &name,\n-                            ),\n-                        });\n-                    } else if matches!(\n-                        meta_item.name_or_empty(),\n-                        sym::C | sym::simd | sym::transparent\n-                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                    {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n-                            span: meta_item.span,\n-                            name: meta_item.name_or_empty().to_ident_string(),\n-                        });\n+                match &meta_item.kind {\n+                    MetaItemKind::NameValue(value) => {\n+                        if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n+                            let name = meta_item.name_or_empty().to_ident_string();\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n+                                span: item.span(),\n+                                repr_arg: &name,\n+                                cause: IncorrectReprFormatGenericCause::from_lit_kind(\n+                                    item.span(),\n+                                    &value.kind,\n+                                    &name,\n+                                ),\n+                            });\n+                        } else if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n+                        }\n                     }\n-                } else if let MetaItemKind::List(_) = meta_item.kind {\n-                    if meta_item.has_name(sym::align) {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n-                            span: meta_item.span,\n-                        });\n-                    } else if meta_item.has_name(sym::packed) {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n-                            span: meta_item.span,\n-                        });\n-                    } else if matches!(\n-                        meta_item.name_or_empty(),\n-                        sym::C | sym::simd | sym::transparent\n-                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                    {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n-                            span: meta_item.span,\n-                            name: meta_item.name_or_empty().to_ident_string(),\n-                        });\n+                    MetaItemKind::List(_) => {\n+                        if meta_item.has_name(sym::align) {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n+                                span: meta_item.span,\n+                            });\n+                        } else if meta_item.has_name(sym::packed) {\n+                            recognised = true;\n+                            sess.emit_err(\n+                                session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n+                                    span: meta_item.span,\n+                                },\n+                            );\n+                        } else if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n+                        }\n                     }\n+                    _ => (),\n                 }\n             }\n             if !recognised {"}, {"sha": "5bb92a3582612f829cadce85e1b52118f4047916", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         rvalue: &mir::Rvalue<'tcx>,\n         location: mir::Location,\n     ) {\n-        if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n+        if let &mir::Rvalue::Ref(region, kind, borrowed_place) = rvalue {\n             if borrowed_place.ignore_borrow(self.tcx, self.body, &self.locals_state_at_exit) {\n                 debug!(\"ignoring_borrow of {:?}\", borrowed_place);\n                 return;\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 region,\n                 reserve_location: location,\n                 activation_location: TwoPhaseActivation::NotTwoPhase,\n-                borrowed_place: *borrowed_place,\n+                borrowed_place,\n                 assigned_place: *assigned_place,\n             };\n             let (idx, _) = self.location_map.insert_full(location, borrow);\n@@ -273,14 +273,14 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: mir::Location) {\n-        if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n+        if let &mir::Rvalue::Ref(region, kind, place) = rvalue {\n             // double-check that we already registered a BorrowData for this\n \n             let borrow_data = &self.location_map[&location];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n             assert_eq!(borrow_data.region, region.to_region_vid());\n-            assert_eq!(borrow_data.borrowed_place, *place);\n+            assert_eq!(borrow_data.borrowed_place, place);\n         }\n \n         self.super_rvalue(rvalue, location)"}, {"sha": "f825b1d8f70ef502952699fe81e4aecf57edb849", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -358,9 +358,9 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n         stmt: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        match stmt.kind {\n-            mir::StatementKind::Assign(box (lhs, ref rhs)) => {\n-                if let mir::Rvalue::Ref(_, _, place) = *rhs {\n+        match &stmt.kind {\n+            mir::StatementKind::Assign(box (lhs, rhs)) => {\n+                if let mir::Rvalue::Ref(_, _, place) = rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n                         self.body,\n@@ -377,13 +377,13 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n \n                 // Make sure there are no remaining borrows for variables\n                 // that are assigned over.\n-                self.kill_borrows_on_place(trans, lhs);\n+                self.kill_borrows_on_place(trans, *lhs);\n             }\n \n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_place(trans, Place::from(local));\n+                self.kill_borrows_on_place(trans, Place::from(*local));\n             }\n \n             mir::StatementKind::FakeRead(..)"}, {"sha": "1550958ab8eee3942710ba5103fab472f560fa02", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -243,9 +243,9 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n         type_op_prove_predicate_with_cause(&ocx, key, cause);\n         try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n@@ -284,9 +284,9 @@ where\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n \n         // FIXME(lqd): Unify and de-duplicate the following with the actual\n         // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n@@ -328,9 +328,9 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n         type_op_ascribe_user_type_with_span(&ocx, key, Some(cause.span)).ok()?;\n         try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }"}, {"sha": "5e3745f17353af8543cc8cbdf52dcf7b1e25cfd6", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -265,7 +265,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n             );\n             let note_msg = match opt_name {\n-                Some(ref name) => format!(\"`{}`\", name),\n+                Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n             if self.suggest_borrow_fn_like(&mut err, ty, &move_site_vec, &note_msg) {\n@@ -1417,7 +1417,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // then just use the normal error. The closure isn't escaping\n             // and `move` will not help here.\n             (\n-                Some(ref name),\n+                Some(name),\n                 BorrowExplanation::MustBeValidFor {\n                     category:\n                         category @ (ConstraintCategory::Return(_)\n@@ -1438,7 +1438,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     &format!(\"`{}`\", name),\n                 ),\n             (\n-                ref name,\n+                name,\n                 BorrowExplanation::MustBeValidFor {\n                     category: ConstraintCategory::Assignment,\n                     from_closure: false,\n@@ -1450,7 +1450,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     span,\n                     ..\n                 },\n-            ) => self.report_escaping_data(borrow_span, name, upvar_span, upvar_name, span),\n+            ) => self.report_escaping_data(borrow_span, &name, upvar_span, upvar_name, span),\n             (Some(name), explanation) => self.report_local_value_does_not_live_long_enough(\n                 location,\n                 &name,\n@@ -2452,7 +2452,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // and it'll make sense.\n         let location = borrow.reserve_location;\n         debug!(\"annotate_argument_and_return_for_borrow: location={:?}\", location);\n-        if let Some(&Statement { kind: StatementKind::Assign(box (ref reservation, _)), .. }) =\n+        if let Some(Statement { kind: StatementKind::Assign(box (reservation, _)), .. }) =\n             &self.body[location.block].statements.get(location.statement_index)\n         {\n             debug!(\"annotate_argument_and_return_for_borrow: reservation={:?}\", reservation);\n@@ -2480,8 +2480,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Check if our `target` was captured by a closure.\n                         if let Rvalue::Aggregate(\n                             box AggregateKind::Closure(def_id, substs),\n-                            ref operands,\n-                        ) = *rvalue\n+                            operands,\n+                        ) = rvalue\n                         {\n                             for operand in operands {\n                                 let (Operand::Copy(assigned_from) | Operand::Move(assigned_from)) = operand else {\n@@ -2505,7 +2505,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 // into a place then we should annotate the closure in\n                                 // case it ends up being assigned into the return place.\n                                 annotated_closure =\n-                                    self.annotate_fn_sig(def_id, substs.as_closure().sig());\n+                                    self.annotate_fn_sig(*def_id, substs.as_closure().sig());\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: \\\n                                      annotated_closure={:?} assigned_from_local={:?} \\"}, {"sha": "304683618d83ef9dc531c7fcb7f7ed91ed329a7f", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -469,8 +469,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 } else if self.was_captured_by_trait_object(borrow) {\n                     LaterUseKind::TraitCapture\n                 } else if location.statement_index == block.statements.len() {\n-                    if let TerminatorKind::Call { ref func, from_hir_call: true, .. } =\n-                        block.terminator().kind\n+                    if let TerminatorKind::Call { func, from_hir_call: true, .. } =\n+                        &block.terminator().kind\n                     {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n@@ -515,19 +515,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // will only ever have one item at any given time, but by using a vector, we can pop from\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n-        let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(box (ref place, _)),\n-            ..\n-        }) = stmt\n-        {\n-            if let Some(local) = place.as_local() {\n-                local\n+        let mut target =\n+            if let Some(Statement { kind: StatementKind::Assign(box (place, _)), .. }) = stmt {\n+                if let Some(local) = place.as_local() {\n+                    local\n+                } else {\n+                    return false;\n+                }\n             } else {\n                 return false;\n-            }\n-        } else {\n-            return false;\n-        };\n+            };\n \n         debug!(\"was_captured_by_trait: target={:?} queue={:?}\", target, queue);\n         while let Some(current_location) = queue.pop() {"}, {"sha": "4e2271a30672270a5ff8c49c1b4460ab8c11938b", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -78,7 +78,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let StatementKind::Assign(box (into, Rvalue::Use(from))) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n                 match from {\n-                    Operand::Copy(ref place) | Operand::Move(ref place)\n+                    Operand::Copy(place) | Operand::Move(place)\n                         if target == place.local_or_deref_local() =>\n                     {\n                         target = into.local_or_deref_local()\n@@ -101,7 +101,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"add_moved_or_invoked_closure_note: id={:?}\", id);\n                 if Some(self.infcx.tcx.parent(id)) == self.infcx.tcx.lang_items().fn_once_trait() {\n                     let closure = match args.first() {\n-                        Some(Operand::Copy(ref place)) | Some(Operand::Move(ref place))\n+                        Some(Operand::Copy(place) | Operand::Move(place))\n                             if target == place.local_or_deref_local() =>\n                         {\n                             place.local_or_deref_local().unwrap()\n@@ -439,9 +439,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if !is_terminator {\n                         continue;\n                     } else if let Some(Terminator {\n-                        kind: TerminatorKind::Call { ref func, from_hir_call: false, .. },\n+                        kind: TerminatorKind::Call { func, from_hir_call: false, .. },\n                         ..\n-                    }) = bbd.terminator\n+                    }) = &bbd.terminator\n                     {\n                         if let Some(source) =\n                             BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n@@ -811,33 +811,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n-        if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            match **kind {\n-                AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) => {\n-                    debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n-                    if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n-                        self.closure_span(def_id, moved_place, places)\n-                    {\n-                        return ClosureUse {\n-                            generator_kind,\n-                            args_span,\n-                            capture_kind_span,\n-                            path_span,\n-                        };\n-                    }\n-                }\n-                _ => {}\n+        if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind\n+            && let AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) = **kind\n+        {\n+            debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+            if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n+                self.closure_span(def_id, moved_place, places)\n+            {\n+                return ClosureUse {\n+                    generator_kind,\n+                    args_span,\n+                    capture_kind_span,\n+                    path_span,\n+                };\n             }\n         }\n \n         // StatementKind::FakeRead only contains a def_id if they are introduced as a result\n         // of pattern matching within a closure.\n-        if let StatementKind::FakeRead(box (cause, ref place)) = stmt.kind {\n+        if let StatementKind::FakeRead(box (cause, place)) = stmt.kind {\n             match cause {\n                 FakeReadCause::ForMatchedPlace(Some(closure_def_id))\n                 | FakeReadCause::ForLet(Some(closure_def_id)) => {\n                     debug!(\"move_spans: def_id={:?} place={:?}\", closure_def_id, place);\n-                    let places = &[Operand::Move(*place)];\n+                    let places = &[Operand::Move(place)];\n                     if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n                         self.closure_span(closure_def_id, moved_place, places)\n                     {\n@@ -924,7 +921,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n         let target = match self.body[location.block].statements.get(location.statement_index) {\n-            Some(&Statement { kind: StatementKind::Assign(box (ref place, _)), .. }) => {\n+            Some(Statement { kind: StatementKind::Assign(box (place, _)), .. }) => {\n                 if let Some(local) = place.as_local() {\n                     local\n                 } else {\n@@ -940,9 +937,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n-            if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) =\n-                stmt.kind\n-            {\n+            if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind {\n                 let (&def_id, is_generator) = match kind {\n                     box AggregateKind::Closure(def_id, _) => (def_id, false),\n                     box AggregateKind::Generator(def_id, _, _) => (def_id, true),"}, {"sha": "3319a80681fde277dc0fd3f361c2656adfafe6b6", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -219,8 +219,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 local,\n                 projection:\n-                    &[\n-                        ref proj_base @ ..,\n+                    [\n+                        proj_base @ ..,\n                         ProjectionElem::Deref,\n                         ProjectionElem::Field(field, _),\n                         ProjectionElem::Deref,\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let Some(span) = get_mut_span_in_struct_field(\n                     self.infcx.tcx,\n                     Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty,\n-                    field,\n+                    *field,\n                 ) {\n                     err.span_suggestion_verbose(\n                         span,"}, {"sha": "9bc2e79e29bc17c9b96a77b7ca99013312159a76", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -921,7 +921,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             hir::ExprKind::Block(blk, _) => {\n-                if let Some(ref expr) = blk.expr {\n+                if let Some(expr) = blk.expr {\n                     // only when the block is a closure\n                     if let hir::ExprKind::Closure(hir::Closure {\n                         capture_clause: hir::CaptureBy::Ref,"}, {"sha": "171e62d91e136463dfd600eb3dc9b51977b6ca59", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -254,7 +254,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_arg_position_impl_trait(fr));\n \n-        if let Some(ref value) = value {\n+        if let Some(value) = &value {\n             self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n         }\n "}, {"sha": "f66a7ab3c031aa87ae54fc658047f2b4cf8384be", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -69,9 +69,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 self.consume_operand(location, op);\n             }\n             StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(mir::CopyNonOverlapping {\n-                ref src,\n-                ref dst,\n-                ref count,\n+                src,\n+                dst,\n+                count,\n             })) => {\n                 self.consume_operand(location, src);\n                 self.consume_operand(location, dst);\n@@ -106,7 +106,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.check_activations(location);\n \n         match &terminator.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n             TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {\n@@ -119,16 +119,16 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::DropAndReplace {\n                 place: drop_place,\n-                value: ref new_value,\n+                value: new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n                 self.mutate_place(location, *drop_place, Deep);\n                 self.consume_operand(location, new_value);\n             }\n             TerminatorKind::Call {\n-                ref func,\n-                ref args,\n+                func,\n+                args,\n                 destination,\n                 target: _,\n                 cleanup: _,\n@@ -141,15 +141,15 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 }\n                 self.mutate_place(location, *destination, Deep);\n             }\n-            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n                 self.consume_operand(location, cond);\n                 use rustc_middle::mir::AssertKind;\n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     self.consume_operand(location, len);\n                     self.consume_operand(location, index);\n                 }\n             }\n-            TerminatorKind::Yield { ref value, resume, resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { value, resume, resume_arg, drop: _ } => {\n                 self.consume_operand(location, value);\n \n                 // Invalidate all borrows of local places\n@@ -175,25 +175,25 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::InlineAsm {\n                 template: _,\n-                ref operands,\n+                operands,\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n                 cleanup: _,\n             } => {\n                 for op in operands {\n-                    match *op {\n-                        InlineAsmOperand::In { reg: _, ref value } => {\n+                    match op {\n+                        InlineAsmOperand::In { reg: _, value } => {\n                             self.consume_operand(location, value);\n                         }\n                         InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n-                            if let Some(place) = place {\n+                            if let &Some(place) = place {\n                                 self.mutate_place(location, place, Shallow(None));\n                             }\n                         }\n-                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                        InlineAsmOperand::InOut { reg: _, late: _, in_value, out_place } => {\n                             self.consume_operand(location, in_value);\n-                            if let Some(out_place) = out_place {\n+                            if let &Some(out_place) = out_place {\n                                 self.mutate_place(location, out_place, Shallow(None));\n                             }\n                         }\n@@ -252,8 +252,8 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n     // Simulates consumption of an rvalue\n     fn consume_rvalue(&mut self, location: Location, rvalue: &Rvalue<'tcx>) {\n-        match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n+        match rvalue {\n+            &Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -272,7 +272,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 self.access_place(location, place, access_kind, LocalMutationIsAllowed::No);\n             }\n \n-            Rvalue::AddressOf(mutability, place) => {\n+            &Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -288,20 +288,19 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n             Rvalue::ThreadLocalRef(_) => {}\n \n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n-            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/)\n-            | Rvalue::ShallowInitBox(ref operand, _ /*ty*/) => {\n-                self.consume_operand(location, operand)\n-            }\n-            Rvalue::CopyForDeref(ref place) => {\n-                let op = &Operand::Copy(*place);\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, operand, _ /*ty*/)\n+            | Rvalue::ShallowInitBox(operand, _ /*ty*/) => self.consume_operand(location, operand),\n+\n+            &Rvalue::CopyForDeref(place) => {\n+                let op = &Operand::Copy(place);\n                 self.consume_operand(location, op);\n             }\n \n-            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n-                let af = match *rvalue {\n+            &(Rvalue::Len(place) | Rvalue::Discriminant(place)) => {\n+                let af = match rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n                     _ => unreachable!(),\n@@ -314,15 +313,15 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, box (ref operand1, ref operand2))\n-            | Rvalue::CheckedBinaryOp(_bin_op, box (ref operand1, ref operand2)) => {\n+            Rvalue::BinaryOp(_bin_op, box (operand1, operand2))\n+            | Rvalue::CheckedBinaryOp(_bin_op, box (operand1, operand2)) => {\n                 self.consume_operand(location, operand1);\n                 self.consume_operand(location, operand2);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {}\n \n-            Rvalue::Aggregate(_, ref operands) => {\n+            Rvalue::Aggregate(_, operands) => {\n                 for operand in operands {\n                     self.consume_operand(location, operand);\n                 }"}, {"sha": "74b4e4a0cabdd6826807ba410ff4af8884fb2c4d", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -578,12 +578,12 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n         self.check_activations(location, span, flow_state);\n \n         match &stmt.kind {\n-            StatementKind::Assign(box (lhs, ref rhs)) => {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n                 self.consume_rvalue(location, (rhs, span), flow_state);\n \n                 self.mutate_place(location, (*lhs, span), Shallow(None), flow_state);\n             }\n-            StatementKind::FakeRead(box (_, ref place)) => {\n+            StatementKind::FakeRead(box (_, place)) => {\n                 // Read for match doesn't access any memory and is used to\n                 // assert that a place is safe and live. So we don't have to\n                 // do any checks here.\n@@ -601,7 +601,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                     flow_state,\n                 );\n             }\n-            StatementKind::Intrinsic(box ref kind) => match kind {\n+            StatementKind::Intrinsic(box kind) => match kind {\n                 NonDivergingIntrinsic::Assume(op) => self.consume_operand(location, (op, span), flow_state),\n                 NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n                     span,\n@@ -643,8 +643,8 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n \n         self.check_activations(loc, span, flow_state);\n \n-        match term.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n+        match &term.kind {\n+            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n             TerminatorKind::Drop { place, target: _, unwind: _ } => {\n@@ -656,24 +656,24 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n \n                 self.access_place(\n                     loc,\n-                    (place, span),\n+                    (*place, span),\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n                 place: drop_place,\n-                value: ref new_value,\n+                value: new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n-                self.mutate_place(loc, (drop_place, span), Deep, flow_state);\n+                self.mutate_place(loc, (*drop_place, span), Deep, flow_state);\n                 self.consume_operand(loc, (new_value, span), flow_state);\n             }\n             TerminatorKind::Call {\n-                ref func,\n-                ref args,\n+                func,\n+                args,\n                 destination,\n                 target: _,\n                 cleanup: _,\n@@ -684,43 +684,43 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                 for arg in args {\n                     self.consume_operand(loc, (arg, span), flow_state);\n                 }\n-                self.mutate_place(loc, (destination, span), Deep, flow_state);\n+                self.mutate_place(loc, (*destination, span), Deep, flow_state);\n             }\n-            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n                 self.consume_operand(loc, (cond, span), flow_state);\n                 use rustc_middle::mir::AssertKind;\n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     self.consume_operand(loc, (len, span), flow_state);\n                     self.consume_operand(loc, (index, span), flow_state);\n                 }\n             }\n \n-            TerminatorKind::Yield { ref value, resume: _, resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n                 self.consume_operand(loc, (value, span), flow_state);\n-                self.mutate_place(loc, (resume_arg, span), Deep, flow_state);\n+                self.mutate_place(loc, (*resume_arg, span), Deep, flow_state);\n             }\n \n             TerminatorKind::InlineAsm {\n                 template: _,\n-                ref operands,\n+                operands,\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n                 cleanup: _,\n             } => {\n                 for op in operands {\n-                    match *op {\n-                        InlineAsmOperand::In { reg: _, ref value } => {\n+                    match op {\n+                        InlineAsmOperand::In { reg: _, value } => {\n                             self.consume_operand(loc, (value, span), flow_state);\n                         }\n                         InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n                             if let Some(place) = place {\n-                                self.mutate_place(loc, (place, span), Shallow(None), flow_state);\n+                                self.mutate_place(loc, (*place, span), Shallow(None), flow_state);\n                             }\n                         }\n-                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                        InlineAsmOperand::InOut { reg: _, late: _, in_value, out_place } => {\n                             self.consume_operand(loc, (in_value, span), flow_state);\n-                            if let Some(out_place) = out_place {\n+                            if let &Some(out_place) = out_place {\n                                 self.mutate_place(\n                                     loc,\n                                     (out_place, span),\n@@ -1164,8 +1164,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         (rvalue, span): (&'cx Rvalue<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n-        match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n+        match rvalue {\n+            &Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -1203,7 +1203,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::AddressOf(mutability, place) => {\n+            &Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -1232,14 +1232,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             Rvalue::ThreadLocalRef(_) => {}\n \n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n-            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/)\n-            | Rvalue::ShallowInitBox(ref operand, _ /*ty*/) => {\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, operand, _ /*ty*/)\n+            | Rvalue::ShallowInitBox(operand, _ /*ty*/) => {\n                 self.consume_operand(location, (operand, span), flow_state)\n             }\n-            Rvalue::CopyForDeref(place) => {\n+\n+            &Rvalue::CopyForDeref(place) => {\n                 self.access_place(\n                     location,\n                     (place, span),\n@@ -1257,7 +1258,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n+            &(Rvalue::Len(place) | Rvalue::Discriminant(place)) => {\n                 let af = match *rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n@@ -1278,8 +1279,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, box (ref operand1, ref operand2))\n-            | Rvalue::CheckedBinaryOp(_bin_op, box (ref operand1, ref operand2)) => {\n+            Rvalue::BinaryOp(_bin_op, box (operand1, operand2))\n+            | Rvalue::CheckedBinaryOp(_bin_op, box (operand1, operand2)) => {\n                 self.consume_operand(location, (operand1, span), flow_state);\n                 self.consume_operand(location, (operand2, span), flow_state);\n             }\n@@ -1288,7 +1289,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // nullary ops take no dynamic input; no borrowck effect.\n             }\n \n-            Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n+            Rvalue::Aggregate(aggregate_kind, operands) => {\n                 // We need to report back the list of mutable upvars that were\n                 // moved into the closure and subsequently used by the closure,\n                 // in order to populate our used_mut set."}, {"sha": "3617bf58be9dd48dd17c18c8738eb566024e18c9", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -121,9 +121,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n     pub(super) fn prove_predicates(\n         &mut self,\n-        predicates: impl IntoIterator<\n-            Item = impl ToPredicate<'tcx, ty::Predicate<'tcx>> + std::fmt::Debug,\n-        >,\n+        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx> + std::fmt::Debug>,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n     ) {\n@@ -135,7 +133,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn prove_predicate(\n         &mut self,\n-        predicate: impl ToPredicate<'tcx, ty::Predicate<'tcx>> + std::fmt::Debug,\n+        predicate: impl ToPredicate<'tcx> + std::fmt::Debug,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n     ) {"}, {"sha": "6d4ec6b726eb027f6e330b084370048445bce315", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1189,8 +1189,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         let tcx = self.tcx();\n         debug!(\"stmt kind: {:?}\", stmt.kind);\n-        match stmt.kind {\n-            StatementKind::Assign(box (ref place, ref rv)) => {\n+        match &stmt.kind {\n+            StatementKind::Assign(box (place, rv)) => {\n                 // Assignments to temporaries are not \"interesting\";\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n@@ -1279,11 +1279,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::AscribeUserType(box (ref place, ref projection), variance) => {\n+            StatementKind::AscribeUserType(box (place, projection), variance) => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n-                    variance,\n+                    *variance,\n                     projection,\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::Intrinsic(box ref kind) => match kind {\n+            StatementKind::Intrinsic(box kind) => match kind {\n                 NonDivergingIntrinsic::Assume(op) => self.check_operand(op, location),\n                 NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n                     stmt.source_info.span,\n@@ -1328,7 +1328,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx();\n         debug!(\"terminator kind: {:?}\", term.kind);\n-        match term.kind {\n+        match &term.kind {\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n             | TerminatorKind::Abort\n@@ -1342,7 +1342,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // no checks needed for these\n             }\n \n-            TerminatorKind::DropAndReplace { ref place, ref value, target: _, unwind: _ } => {\n+            TerminatorKind::DropAndReplace { place, value, target: _, unwind: _ } => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 let rv_ty = value.ty(body, tcx);\n \n@@ -1360,13 +1360,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty, .. } => {\n                 self.check_operand(discr, term_location);\n \n                 let discr_ty = discr.ty(body, tcx);\n                 if let Err(terr) = self.sub_types(\n                     discr_ty,\n-                    switch_ty,\n+                    *switch_ty,\n                     term_location.to_locations(),\n                     ConstraintCategory::Assignment,\n                 ) {\n@@ -1384,14 +1384,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 // FIXME: check the values\n             }\n-            TerminatorKind::Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                from_hir_call,\n-                target,\n-                ..\n-            } => {\n+            TerminatorKind::Call { func, args, destination, from_hir_call, target, .. } => {\n                 self.check_operand(func, term_location);\n                 for arg in args {\n                     self.check_operand(arg, term_location);\n@@ -1431,7 +1424,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     ConstraintCategory::Boring,\n                 );\n                 let sig = self.normalize(sig, term_location);\n-                self.check_call_dest(body, term, &sig, *destination, target, term_location);\n+                self.check_call_dest(body, term, &sig, *destination, *target, term_location);\n \n                 // The ordinary liveness rules will ensure that all\n                 // regions in the type of the callee are live here. We\n@@ -1449,17 +1442,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         .add_element(region_vid, term_location);\n                 }\n \n-                self.check_call_inputs(body, term, &sig, args, term_location, from_hir_call);\n+                self.check_call_inputs(body, term, &sig, args, term_location, *from_hir_call);\n             }\n-            TerminatorKind::Assert { ref cond, ref msg, .. } => {\n+            TerminatorKind::Assert { cond, msg, .. } => {\n                 self.check_operand(cond, term_location);\n \n                 let cond_ty = cond.ty(body, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     if len.ty(body, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }\n@@ -1468,7 +1461,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            TerminatorKind::Yield { ref value, .. } => {\n+            TerminatorKind::Yield { value, .. } => {\n                 self.check_operand(value, term_location);\n \n                 let value_ty = value.ty(body, tcx);\n@@ -2630,7 +2623,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(ref closure_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+        if let Some(closure_requirements) = &tcx.mir_borrowck(def_id).closure_requirements {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx,\n                 self.borrowck_context.universal_regions,"}, {"sha": "a4a0c5b90fed32d2a20372aa908806b81aa9a2fe", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -587,9 +587,9 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, typeck_root_def_id);\n         let fr_substs = match defining_ty {\n-            DefiningTy::Closure(_, ref substs)\n-            | DefiningTy::Generator(_, ref substs, _)\n-            | DefiningTy::InlineConst(_, ref substs) => {\n+            DefiningTy::Closure(_, substs)\n+            | DefiningTy::Generator(_, substs, _)\n+            | DefiningTy::InlineConst(_, substs) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n                 // inherited from the `typeck_root_def_id`."}, {"sha": "95e38e4b053f496604f25079b22722e2fbf3dc4b", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -17,32 +17,23 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::alloc_error_handler);\n \n     let orig_item = item.clone();\n-    let not_function = || {\n-        ecx.sess\n-            .parse_sess\n-            .span_diagnostic\n-            .span_err(item.span(), \"alloc_error_handler must be a function\");\n-        vec![orig_item.clone()]\n-    };\n \n     // Allow using `#[alloc_error_handler]` on an item statement\n     // FIXME - if we get deref patterns, use them to reduce duplication here\n-    let (item, is_stmt, sig_span) = match &item {\n-        Annotatable::Item(item) => match item.kind {\n-            ItemKind::Fn(ref fn_kind) => (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span)),\n-            _ => return not_function(),\n-        },\n-        Annotatable::Stmt(stmt) => match &stmt.kind {\n-            StmtKind::Item(item_) => match item_.kind {\n-                ItemKind::Fn(ref fn_kind) => {\n-                    (item_, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n-                }\n-                _ => return not_function(),\n-            },\n-            _ => return not_function(),\n-        },\n-        _ => return not_function(),\n-    };\n+    let (item, is_stmt, sig_span) =\n+        if let Annotatable::Item(item) = &item\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else if let Annotatable::Stmt(stmt) = &item\n+            && let StmtKind::Item(item) = &stmt.kind\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else {\n+            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"alloc_error_handler must be a function\");\n+            return vec![orig_item.clone()];\n+        };\n \n     // Generate a bunch of new items using the AllocFnFactory\n     let span = ecx.with_def_site_ctxt(item.span);"}, {"sha": "93b07801e035d7de24d995980ccd1568063ffb29", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -191,19 +191,19 @@ impl<'cx, 'a> Context<'cx, 'a> {\n     ///\n     /// See [Self::manage_initial_capture] and [Self::manage_try_capture]\n     fn manage_cond_expr(&mut self, expr: &mut P<Expr>) {\n-        match (*expr).kind {\n-            ExprKind::AddrOf(_, mutability, ref mut local_expr) => {\n+        match &mut expr.kind {\n+            ExprKind::AddrOf(_, mutability, local_expr) => {\n                 self.with_is_consumed_management(\n                     matches!(mutability, Mutability::Mut),\n                     |this| this.manage_cond_expr(local_expr)\n                 );\n             }\n-            ExprKind::Array(ref mut local_exprs) => {\n+            ExprKind::Array(local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Binary(ref op, ref mut lhs, ref mut rhs) => {\n+            ExprKind::Binary(op, lhs, rhs) => {\n                 self.with_is_consumed_management(\n                     matches!(\n                         op.node,\n@@ -226,56 +226,56 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     }\n                 );\n             }\n-            ExprKind::Call(_, ref mut local_exprs) => {\n+            ExprKind::Call(_, local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Cast(ref mut local_expr, _) => {\n+            ExprKind::Cast(local_expr, _) => {\n                 self.manage_cond_expr(local_expr);\n             }\n-            ExprKind::Index(ref mut prefix, ref mut suffix) => {\n+            ExprKind::Index(prefix, suffix) => {\n                 self.manage_cond_expr(prefix);\n                 self.manage_cond_expr(suffix);\n             }\n-            ExprKind::MethodCall(ref mut call) => {\n-                for arg in call.args.iter_mut() {\n+            ExprKind::MethodCall(call) => {\n+                for arg in &mut call.args {\n                     self.manage_cond_expr(arg);\n                 }\n             }\n-            ExprKind::Path(_, Path { ref segments, .. }) if let &[ref path_segment] = &segments[..] => {\n+            ExprKind::Path(_, Path { segments, .. }) if let [path_segment] = &segments[..] => {\n                 let path_ident = path_segment.ident;\n                 self.manage_initial_capture(expr, path_ident);\n             }\n-            ExprKind::Paren(ref mut local_expr) => {\n+            ExprKind::Paren(local_expr) => {\n                 self.manage_cond_expr(local_expr);\n             }\n-            ExprKind::Range(ref mut prefix, ref mut suffix, _) => {\n-                if let Some(ref mut elem) = prefix {\n+            ExprKind::Range(prefix, suffix, _) => {\n+                if let Some(elem) = prefix {\n                     self.manage_cond_expr(elem);\n                 }\n-                if let Some(ref mut elem) = suffix {\n+                if let Some(elem) = suffix {\n                     self.manage_cond_expr(elem);\n                 }\n             }\n-            ExprKind::Repeat(ref mut local_expr, ref mut elem) => {\n+            ExprKind::Repeat(local_expr, elem) => {\n                 self.manage_cond_expr(local_expr);\n                 self.manage_cond_expr(&mut elem.value);\n             }\n-            ExprKind::Struct(ref mut elem) => {\n+            ExprKind::Struct(elem) => {\n                 for field in &mut elem.fields {\n                     self.manage_cond_expr(&mut field.expr);\n                 }\n-                if let StructRest::Base(ref mut local_expr) = elem.rest {\n+                if let StructRest::Base(local_expr) = &mut elem.rest {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Tup(ref mut local_exprs) => {\n+            ExprKind::Tup(local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Unary(un_op, ref mut local_expr) => {\n+            ExprKind::Unary(un_op, local_expr) => {\n                 self.with_is_consumed_management(\n                     matches!(un_op, UnOp::Neg | UnOp::Not),\n                     |this| this.manage_cond_expr(local_expr)"}, {"sha": "e2d71825d556f69ca9bbc4277848b4aaf89047ad", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -20,7 +20,7 @@ pub fn expand_concat(\n     for e in es {\n         match e.kind {\n             ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n-                Ok(ast::LitKind::Str(ref s, _) | ast::LitKind::Float(ref s, _)) => {\n+                Ok(ast::LitKind::Str(s, _) | ast::LitKind::Float(s, _)) => {\n                     accumulator.push_str(s.as_str());\n                 }\n                 Ok(ast::LitKind::Char(c)) => {"}, {"sha": "d1124145dcbbb663febddf26081de93812aa39d5", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -144,8 +144,8 @@ pub fn expand_concat_bytes(\n     let mut missing_literals = vec![];\n     let mut has_errors = false;\n     for e in es {\n-        match e.kind {\n-            ast::ExprKind::Array(ref exprs) => {\n+        match &e.kind {\n+            ast::ExprKind::Array(exprs) => {\n                 for expr in exprs {\n                     if let Some(elem) =\n                         handle_array_element(cx, &mut has_errors, &mut missing_literals, expr)\n@@ -154,7 +154,7 @@ pub fn expand_concat_bytes(\n                     }\n                 }\n             }\n-            ast::ExprKind::Repeat(ref expr, ref count) => {\n+            ast::ExprKind::Repeat(expr, count) => {\n                 if let ast::ExprKind::Lit(token_lit) = count.value.kind\n                 && let Ok(ast::LitKind::Int(count_val, _)) =\n                     ast::LitKind::from_token_lit(token_lit)\n@@ -170,7 +170,7 @@ pub fn expand_concat_bytes(\n                     cx.span_err(count.value.span, \"repeat count is not a positive number\");\n                 }\n             }\n-            ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n+            &ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n                 Ok(ast::LitKind::Byte(val)) => {\n                     accumulator.push(val);\n                 }\n@@ -184,7 +184,7 @@ pub fn expand_concat_bytes(\n                     has_errors = true;\n                 }\n             },\n-            ast::ExprKind::IncludedBytes(ref bytes) => {\n+            ast::ExprKind::IncludedBytes(bytes) => {\n                 accumulator.extend_from_slice(bytes);\n             }\n             ast::ExprKind::Err => {"}, {"sha": "d59b3b8c86d35ef6303bb8a3adbd5e9aecf2d1f1", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -32,10 +32,10 @@ pub fn expand_deriving_clone(\n     let bounds;\n     let substructure;\n     let is_simple;\n-    match *item {\n-        Annotatable::Item(ref annitem) => match annitem.kind {\n-            ItemKind::Struct(_, Generics { ref params, .. })\n-            | ItemKind::Enum(_, Generics { ref params, .. }) => {\n+    match item {\n+        Annotatable::Item(annitem) => match &annitem.kind {\n+            ItemKind::Struct(_, Generics { params, .. })\n+            | ItemKind::Enum(_, Generics { params, .. }) => {\n                 let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n                 let has_derive_copy = cx.resolver.has_derive_copy(container_id);\n                 if has_derive_copy\n@@ -166,13 +166,13 @@ fn cs_clone(\n     };\n \n     let vdata;\n-    match *substr.fields {\n-        Struct(vdata_, ref af) => {\n+    match substr.fields {\n+        Struct(vdata_, af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident]);\n             all_fields = af;\n-            vdata = vdata_;\n+            vdata = *vdata_;\n         }\n-        EnumMatching(.., variant, ref af) => {\n+        EnumMatching(.., variant, af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.ident]);\n             all_fields = af;\n             vdata = &variant.data;"}, {"sha": "62af02c2bb4b2d35304cf4eafd42036fba31d5ef", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -78,11 +78,11 @@ fn decodable_substructure(\n     let blkarg = Ident::new(sym::_d, trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n-    let expr = match *substr.fields {\n-        StaticStruct(_, ref summary) => {\n-            let nfields = match *summary {\n-                Unnamed(ref fields, _) => fields.len(),\n-                Named(ref fields) => fields.len(),\n+    let expr = match substr.fields {\n+        StaticStruct(_, summary) => {\n+            let nfields = match summary {\n+                Unnamed(fields, _) => fields.len(),\n+                Named(fields) => fields.len(),\n             };\n             let fn_read_struct_field_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_struct_field]);\n@@ -119,7 +119,7 @@ fn decodable_substructure(\n                 ],\n             )\n         }\n-        StaticEnum(_, ref fields) => {\n+        StaticEnum(_, fields) => {\n             let variant = Ident::new(sym::i, trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n@@ -194,10 +194,10 @@ fn decode_static_fields<F>(\n where\n     F: FnMut(&mut ExtCtxt<'_>, Span, Symbol, usize) -> P<Expr>,\n {\n-    match *fields {\n-        Unnamed(ref fields, is_tuple) => {\n+    match fields {\n+        Unnamed(fields, is_tuple) => {\n             let path_expr = cx.expr_path(outer_pat_path);\n-            if !is_tuple {\n+            if !*is_tuple {\n                 path_expr\n             } else {\n                 let fields = fields\n@@ -209,7 +209,7 @@ where\n                 cx.expr_call(trait_span, path_expr, fields)\n             }\n         }\n-        Named(ref fields) => {\n+        Named(fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields\n                 .iter()"}, {"sha": "eb66c4a69a69bc25bab4126e1649d5f3097a940f", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -62,15 +62,12 @@ fn default_struct_substructure(\n     let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n     let expr = match summary {\n-        Unnamed(ref fields, is_tuple) => {\n-            if !is_tuple {\n-                cx.expr_ident(trait_span, substr.type_ident)\n-            } else {\n-                let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n-                cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n-            }\n+        Unnamed(_, false) => cx.expr_ident(trait_span, substr.type_ident),\n+        Unnamed(fields, true) => {\n+            let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n+            cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n         }\n-        Named(ref fields) => {\n+        Named(fields) => {\n             let default_fields = fields\n                 .iter()\n                 .map(|&(ident, span)| cx.field_imm(span, ident, default_call(span)))"}, {"sha": "68bc0ff2ec0b41c553339586a0874ef5fcb6a1f1", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -164,8 +164,8 @@ fn encodable_substructure(\n         ],\n     ));\n \n-    match *substr.fields {\n-        Struct(_, ref fields) => {\n+    match substr.fields {\n+        Struct(_, fields) => {\n             let fn_emit_struct_field_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n             let mut stmts = Vec::new();\n@@ -224,7 +224,7 @@ fn encodable_substructure(\n             BlockOrExpr::new_expr(expr)\n         }\n \n-        EnumMatching(idx, _, variant, ref fields) => {\n+        EnumMatching(idx, _, variant, fields) => {\n             // We're not generating an AST that the borrow checker is expecting,\n             // so we need to generate a unique local variable to take the\n             // mutable loan out on, otherwise we get conflicts which don't\n@@ -274,7 +274,7 @@ fn encodable_substructure(\n                 vec![\n                     blkencoder,\n                     name,\n-                    cx.expr_usize(trait_span, idx),\n+                    cx.expr_usize(trait_span, *idx),\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n                 ],"}, {"sha": "beac591bfc879065a2c6fd411be0673ba59a3383", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -369,15 +369,14 @@ fn find_type_parameters(\n \n     impl<'a, 'b> visit::Visitor<'a> for Visitor<'a, 'b> {\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-            if let ast::TyKind::Path(_, ref path) = ty.kind {\n-                if let Some(segment) = path.segments.first() {\n-                    if self.ty_param_names.contains(&segment.ident.name) {\n-                        self.type_params.push(TypeParameter {\n-                            bound_generic_params: self.bound_generic_params_stack.clone(),\n-                            ty: P(ty.clone()),\n-                        });\n-                    }\n-                }\n+            if let ast::TyKind::Path(_, path) = &ty.kind\n+                && let Some(segment) = path.segments.first()\n+                && self.ty_param_names.contains(&segment.ident.name)\n+            {\n+                self.type_params.push(TypeParameter {\n+                    bound_generic_params: self.bound_generic_params_stack.clone(),\n+                    ty: P(ty.clone()),\n+                });\n             }\n \n             visit::walk_ty(self, ty)\n@@ -428,8 +427,8 @@ impl<'a> TraitDef<'a> {\n         push: &mut dyn FnMut(Annotatable),\n         from_scratch: bool,\n     ) {\n-        match *item {\n-            Annotatable::Item(ref item) => {\n+        match item {\n+            Annotatable::Item(item) => {\n                 let is_packed = item.attrs.iter().any(|attr| {\n                     for r in attr::find_repr_attrs(&cx.sess, attr) {\n                         if let attr::ReprPacked(_) = r {\n@@ -438,10 +437,10 @@ impl<'a> TraitDef<'a> {\n                     }\n                     false\n                 });\n-                let has_no_type_params = match item.kind {\n-                    ast::ItemKind::Struct(_, ref generics)\n-                    | ast::ItemKind::Enum(_, ref generics)\n-                    | ast::ItemKind::Union(_, ref generics) => !generics\n+                let has_no_type_params = match &item.kind {\n+                    ast::ItemKind::Struct(_, generics)\n+                    | ast::ItemKind::Enum(_, generics)\n+                    | ast::ItemKind::Union(_, generics) => !generics\n                         .params\n                         .iter()\n                         .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. })),\n@@ -451,24 +450,24 @@ impl<'a> TraitDef<'a> {\n                 let copy_fields =\n                     is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n-                let newitem = match item.kind {\n-                    ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n+                let newitem = match &item.kind {\n+                    ast::ItemKind::Struct(struct_def, generics) => self.expand_struct_def(\n                         cx,\n                         &struct_def,\n                         item.ident,\n                         generics,\n                         from_scratch,\n                         copy_fields,\n                     ),\n-                    ast::ItemKind::Enum(ref enum_def, ref generics) => {\n+                    ast::ItemKind::Enum(enum_def, generics) => {\n                         // We ignore `is_packed` here, because `repr(packed)`\n                         // enums cause an error later on.\n                         //\n                         // This can only cause further compilation errors\n                         // downstream in blatantly illegal code, so it is fine.\n                         self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n-                    ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                    ast::ItemKind::Union(struct_def, generics) => {\n                         if self.supports_unions {\n                             self.expand_struct_def(\n                                 cx,\n@@ -663,12 +662,11 @@ impl<'a> TraitDef<'a> {\n \n                     for field_ty_param in field_ty_params {\n                         // if we have already handled this type, skip it\n-                        if let ast::TyKind::Path(_, ref p) = field_ty_param.ty.kind {\n-                            if p.segments.len() == 1\n-                                && ty_param_names.contains(&p.segments[0].ident.name)\n-                            {\n-                                continue;\n-                            };\n+                        if let ast::TyKind::Path(_, p) = &field_ty_param.ty.kind\n+                            && let [sole_segment] = &*p.segments\n+                            && ty_param_names.contains(&sole_segment.ident.name)\n+                        {\n+                            continue;\n                         }\n                         let mut bounds: Vec<_> = self\n                             .additional_bounds"}, {"sha": "eaa4881906a8e3aed446cec6b99657d64972d02f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -115,7 +115,7 @@ impl Ty {\n         self_ty: Ident,\n         generics: &Generics,\n     ) -> ast::Path {\n-        match *self {\n+        match self {\n             Self_ => {\n                 let params: Vec<_> = generics\n                     .params\n@@ -135,7 +135,7 @@ impl Ty {\n \n                 cx.path_all(span, false, vec![self_ty], params)\n             }\n-            Path(ref p) => p.to_path(cx, span, self_ty, generics),\n+            Path(p) => p.to_path(cx, span, self_ty, generics),\n             Ref(..) => cx.span_bug(span, \"ref in a path in generic `derive`\"),\n             Unit => cx.span_bug(span, \"unit in a path in generic `derive`\"),\n         }\n@@ -180,10 +180,7 @@ impl Bounds {\n         let params = self\n             .bounds\n             .iter()\n-            .map(|t| {\n-                let (name, ref bounds) = *t;\n-                mk_ty_param(cx, span, name, &bounds, self_ty, self_generics)\n-            })\n+            .map(|&(name, ref bounds)| mk_ty_param(cx, span, name, &bounds, self_ty, self_generics))\n             .collect();\n \n         Generics {"}, {"sha": "de657e4e6006dcd8aea6ce578dd2657242a488b2", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -125,12 +125,12 @@ fn inject_impl_of_structural_trait(\n     structural_path: generic::ty::Path,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let Annotatable::Item(ref item) = *item else {\n+    let Annotatable::Item(item) = item else {\n         unreachable!();\n     };\n \n-    let generics = match item.kind {\n-        ItemKind::Struct(_, ref generics) | ItemKind::Enum(_, ref generics) => generics,\n+    let generics = match &item.kind {\n+        ItemKind::Struct(_, generics) | ItemKind::Enum(_, generics) => generics,\n         // Do not inject `impl Structural for Union`. (`PartialEq` does not\n         // support unions, so we will see error downstream.)\n         ItemKind::Union(..) => return,"}, {"sha": "0b4e545f7a3d0360757c9588e97742e7f4e1f0c6", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -53,7 +53,7 @@ pub fn expand_env<'cx>(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n-        Some(ref exprs) if exprs.is_empty() => {\n+        Some(exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::any(sp);\n         }"}, {"sha": "6f7fc3a95ba640e21311aca2d37b403f0f25a2c4", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -13,23 +13,23 @@ pub(crate) mod printf {\n \n     impl<'a> Substitution<'a> {\n         pub fn as_str(&self) -> &str {\n-            match *self {\n-                Substitution::Format(ref fmt) => fmt.span,\n+            match self {\n+                Substitution::Format(fmt) => fmt.span,\n                 Substitution::Escape(_) => \"%%\",\n             }\n         }\n \n         pub fn position(&self) -> Option<InnerSpan> {\n-            match *self {\n-                Substitution::Format(ref fmt) => Some(fmt.position),\n-                Substitution::Escape((start, end)) => Some(InnerSpan::new(start, end)),\n+            match self {\n+                Substitution::Format(fmt) => Some(fmt.position),\n+                &Substitution::Escape((start, end)) => Some(InnerSpan::new(start, end)),\n             }\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n             match self {\n-                Substitution::Format(ref mut fmt) => fmt.position = InnerSpan::new(start, end),\n-                Substitution::Escape(ref mut pos) => *pos = (start, end),\n+                Substitution::Format(fmt) => fmt.position = InnerSpan::new(start, end),\n+                Substitution::Escape(pos) => *pos = (start, end),\n             }\n         }\n \n@@ -38,8 +38,8 @@ pub(crate) mod printf {\n         /// This ignores cases where the substitution does not have an exact equivalent, or where\n         /// the substitution would be unnecessary.\n         pub fn translate(&self) -> Result<String, Option<String>> {\n-            match *self {\n-                Substitution::Format(ref fmt) => fmt.translate(),\n+            match self {\n+                Substitution::Format(fmt) => fmt.translate(),\n                 Substitution::Escape(_) => Err(None),\n             }\n         }\n@@ -635,23 +635,17 @@ pub mod shell {\n         }\n \n         pub fn position(&self) -> Option<InnerSpan> {\n-            match self {\n-                Substitution::Ordinal(_, pos)\n-                | Substitution::Name(_, pos)\n-                | Substitution::Escape(pos) => Some(InnerSpan::new(pos.0, pos.1)),\n-            }\n+            let (Self::Ordinal(_, pos) | Self::Name(_, pos) | Self::Escape(pos)) = self;\n+            Some(InnerSpan::new(pos.0, pos.1))\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n-            match self {\n-                Substitution::Ordinal(_, ref mut pos)\n-                | Substitution::Name(_, ref mut pos)\n-                | Substitution::Escape(ref mut pos) => *pos = (start, end),\n-            }\n+            let (Self::Ordinal(_, pos) | Self::Name(_, pos) | Self::Escape(pos)) = self;\n+            *pos = (start, end);\n         }\n \n         pub fn translate(&self) -> Result<String, Option<String>> {\n-            match *self {\n+            match self {\n                 Substitution::Ordinal(n, _) => Ok(format!(\"{{{}}}\", n)),\n                 Substitution::Name(n, _) => Ok(format!(\"{{{}}}\", n)),\n                 Substitution::Escape(_) => Err(None),"}, {"sha": "41531580c1987ca92c0a2e76c10dc993c1c7e16a", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -20,27 +20,23 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n \n     let orig_item = item.clone();\n-    let not_static = || {\n-        ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n-        vec![orig_item.clone()]\n-    };\n \n     // Allow using `#[global_allocator]` on an item statement\n     // FIXME - if we get deref patterns, use them to reduce duplication here\n-    let (item, is_stmt, ty_span) = match &item {\n-        Annotatable::Item(item) => match item.kind {\n-            ItemKind::Static(ref ty, ..) => (item, false, ecx.with_def_site_ctxt(ty.span)),\n-            _ => return not_static(),\n-        },\n-        Annotatable::Stmt(stmt) => match &stmt.kind {\n-            StmtKind::Item(item_) => match item_.kind {\n-                ItemKind::Static(ref ty, ..) => (item_, true, ecx.with_def_site_ctxt(ty.span)),\n-                _ => return not_static(),\n-            },\n-            _ => return not_static(),\n-        },\n-        _ => return not_static(),\n-    };\n+    let (item, is_stmt, ty_span) =\n+        if let Annotatable::Item(item) = &item\n+            && let ItemKind::Static(ty, ..) = &item.kind\n+        {\n+            (item, false, ecx.with_def_site_ctxt(ty.span))\n+        } else if let Annotatable::Stmt(stmt) = &item\n+            && let StmtKind::Item(item) = &stmt.kind\n+            && let ItemKind::Static(ty, ..) = &item.kind\n+        {\n+            (item, true, ecx.with_def_site_ctxt(ty.span))\n+        } else {\n+            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+            return vec![orig_item.clone()]\n+        };\n \n     // Generate a bunch of new items using the AllocFnFactory\n     let span = ecx.with_def_site_ctxt(item.span);"}, {"sha": "f5f02fc772ab6b5b08b1082ab3fdb8ee6ec99f3c", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -466,61 +466,67 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n     let sd = &cx.sess.parse_sess.span_diagnostic;\n-    if let ast::ItemKind::Fn(box ast::Fn { ref sig, ref generics, .. }) = i.kind {\n-        if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n-            sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n-                .span_label(span, \"`unsafe` because of this\")\n-                .emit();\n-            return false;\n-        }\n-        if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n-            sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n-                .span_label(span, \"`async` because of this\")\n-                .emit();\n-            return false;\n-        }\n-\n-        // If the termination trait is active, the compiler will check that the output\n-        // type implements the `Termination` trait as `libtest` enforces that.\n-        let has_output = match sig.decl.output {\n-            ast::FnRetTy::Default(..) => false,\n-            ast::FnRetTy::Ty(ref t) if t.kind.is_unit() => false,\n-            _ => true,\n-        };\n-\n-        if !sig.decl.inputs.is_empty() {\n-            sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n-            return false;\n-        }\n+    match &i.kind {\n+        ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {\n+            if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n+                sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n+                    .span_label(span, \"`unsafe` because of this\")\n+                    .emit();\n+                return false;\n+            }\n+            if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n+                sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n+                    .span_label(span, \"`async` because of this\")\n+                    .emit();\n+                return false;\n+            }\n \n-        match (has_output, has_should_panic_attr) {\n-            (true, true) => {\n-                sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n-                false\n+            // If the termination trait is active, the compiler will check that the output\n+            // type implements the `Termination` trait as `libtest` enforces that.\n+            let has_output = match &sig.decl.output {\n+                ast::FnRetTy::Default(..) => false,\n+                ast::FnRetTy::Ty(t) if t.kind.is_unit() => false,\n+                _ => true,\n+            };\n+\n+            if !sig.decl.inputs.is_empty() {\n+                sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n+                return false;\n             }\n-            (true, false) => {\n-                if !generics.params.is_empty() {\n-                    sd.span_err(i.span, \"functions used as tests must have signature fn() -> ()\");\n+\n+            match (has_output, has_should_panic_attr) {\n+                (true, true) => {\n+                    sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n                     false\n-                } else {\n-                    true\n                 }\n+                (true, false) => {\n+                    if !generics.params.is_empty() {\n+                        sd.span_err(\n+                            i.span,\n+                            \"functions used as tests must have signature fn() -> ()\",\n+                        );\n+                        false\n+                    } else {\n+                        true\n+                    }\n+                }\n+                (false, _) => true,\n             }\n-            (false, _) => true,\n         }\n-    } else {\n-        // should be unreachable because `is_test_fn_item` should catch all non-fn items\n-        false\n+        _ => {\n+            // should be unreachable because `is_test_fn_item` should catch all non-fn items\n+            debug_assert!(false);\n+            false\n+        }\n     }\n }\n \n fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_sig = if let ast::ItemKind::Fn(box ast::Fn { ref sig, .. }) = i.kind {\n+    let has_sig = match &i.kind {\n         // N.B., inadequate check, but we're running\n         // well before resolve, can't get too deep.\n-        sig.decl.inputs.len() == 1\n-    } else {\n-        false\n+        ast::ItemKind::Fn(box ast::Fn { sig, .. }) => sig.decl.inputs.len() == 1,\n+        _ => false,\n     };\n \n     if !has_sig {"}, {"sha": "ad8871080910640e11e123b8f27221101f2a543d", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -131,8 +131,9 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(_, ModKind::Loaded(.., ref spans)) = item.kind {\n-            let ast::ModSpans { inner_span: span, inject_use_span: _ } = *spans;\n+        if let ast::ItemKind::Mod(_, ModKind::Loaded(.., ast::ModSpans { inner_span: span, .. })) =\n+            item.kind\n+        {\n             let prev_tests = mem::take(&mut self.tests);\n             noop_visit_item_kind(&mut item.kind, self);\n             self.add_test_cases(item.id, span, prev_tests);"}, {"sha": "ea8ab76114604208ed7a9b619dc257e4e9e9c4ff", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -8,13 +8,11 @@ use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::mir::interpret::{self, ConstAllocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n-use rustc_span::Span;\n use rustc_span::def_id::DefId;\n use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRange};\n \n use crate::base;\n use crate::context::CodegenCx;\n-use crate::errors::LinkageConstOrMutType;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -239,12 +237,12 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n                     }\n \n                     Node::ForeignItem(&hir::ForeignItem {\n-                        span,\n+                        span: _,\n                         kind: hir::ForeignItemKind::Static(..),\n                         ..\n                     }) => {\n                         let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n-                        check_and_apply_linkage(&self, &fn_attrs, ty, sym, span)\n+                        check_and_apply_linkage(&self, &fn_attrs, ty, sym)\n                     }\n \n                     item => bug!(\"get_static: expected static, found {:?}\", item),\n@@ -257,8 +255,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n                 //debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n \n                 let attrs = self.tcx.codegen_fn_attrs(def_id);\n-                let span = self.tcx.def_span(def_id);\n-                let global = check_and_apply_linkage(&self, &attrs, ty, sym, span);\n+                let global = check_and_apply_linkage(&self, &attrs, ty, sym);\n \n                 let needs_dll_storage_attr = false; // TODO(antoyo)\n \n@@ -355,24 +352,12 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n     Ok((const_alloc_to_gcc(cx, alloc), alloc))\n }\n \n-fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> LValue<'gcc> {\n+fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n     let llty = cx.layout_of(ty).gcc_type(cx, true);\n-    if let Some(linkage) = attrs.linkage {\n-        // If this is a static with a linkage specified, then we need to handle\n-        // it a little specially. The typesystem prevents things like &T and\n-        // extern \"C\" fn() from being non-null, so we can't just declare a\n-        // static and call it a day. Some linkages (like weak) will make it such\n-        // that the static actually has a null value.\n-        let llty2 =\n-            if let ty::RawPtr(ref mt) = ty.kind() {\n-                cx.layout_of(mt.ty).gcc_type(cx, true)\n-            }\n-            else {\n-                cx.sess().emit_fatal(LinkageConstOrMutType { span: span })\n-            };\n+    if let Some(linkage) = attrs.import_linkage {\n         // Declare a symbol `foo` with the desired linkage.\n-        let global1 = cx.declare_global_with_linkage(&sym, llty2, base::global_linkage_to_gcc(linkage));\n+        let global1 = cx.declare_global_with_linkage(&sym, cx.type_i8(), base::global_linkage_to_gcc(linkage));\n \n         // Declare an internal global `extern_with_linkage_foo` which\n         // is initialized with the address of `foo`.  If `foo` is"}, {"sha": "d0ba7e2479111fed3ee8661f86984a3fbfd18cf2", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -211,13 +211,6 @@ pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n     pub in_elem: Ty<'a>,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_gcc_linkage_const_or_mut_type)]\n-pub(crate) struct LinkageConstOrMutType {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_gcc_lto_not_supported)]\n pub(crate) struct LTONotSupported;"}, {"sha": "3626aa901c0ef45b02dfa23fe54487d491436f11", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,7 +1,7 @@\n use crate::base;\n use crate::common::{self, CodegenCx};\n use crate::debuginfo;\n-use crate::errors::{InvalidMinimumAlignment, LinkageConstOrMutType, SymbolAlreadyDefined};\n+use crate::errors::{InvalidMinimumAlignment, SymbolAlreadyDefined};\n use crate::llvm::{self, True};\n use crate::llvm_util;\n use crate::type_::Type;\n@@ -162,22 +162,12 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n     def_id: DefId,\n ) -> &'ll Value {\n     let llty = cx.layout_of(ty).llvm_type(cx);\n-    if let Some(linkage) = attrs.linkage {\n+    if let Some(linkage) = attrs.import_linkage {\n         debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n \n-        // If this is a static with a linkage specified, then we need to handle\n-        // it a little specially. The typesystem prevents things like &T and\n-        // extern \"C\" fn() from being non-null, so we can't just declare a\n-        // static and call it a day. Some linkages (like weak) will make it such\n-        // that the static actually has a null value.\n-        let llty2 = if let ty::RawPtr(ref mt) = ty.kind() {\n-            cx.layout_of(mt.ty).llvm_type(cx)\n-        } else {\n-            cx.sess().emit_fatal(LinkageConstOrMutType { span: cx.tcx.def_span(def_id) })\n-        };\n         unsafe {\n             // Declare a symbol `foo` with the desired linkage.\n-            let g1 = cx.declare_global(sym, llty2);\n+            let g1 = cx.declare_global(sym, cx.type_i8());\n             llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n \n             // Declare an internal global `extern_with_linkage_foo` which\n@@ -195,7 +185,7 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n                 })\n             });\n             llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n-            llvm::LLVMSetInitializer(g2, g1);\n+            llvm::LLVMSetInitializer(g2, cx.const_ptrcast(g1, llty));\n             g2\n         }\n     } else if cx.tcx.sess.target.arch == \"x86\" &&"}, {"sha": "af9f31fc3249309ee4aee8db7d4b0176f5fabf75", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -61,13 +61,6 @@ pub(crate) struct InvalidMinimumAlignment {\n     pub err: String,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_linkage_const_or_mut_type)]\n-pub(crate) struct LinkageConstOrMutType {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_llvm_sanitizer_memtag_requires_mte)]\n pub(crate) struct SanitizerMemtagRequiresMte;"}, {"sha": "882430694e16d7f65668154330f9796d7f8ff924", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -102,7 +102,7 @@ pub fn link_binary<'a>(\n                 sess,\n                 crate_type,\n                 outputs,\n-                codegen_results.crate_info.local_crate_name.as_str(),\n+                codegen_results.crate_info.local_crate_name,\n             );\n             match crate_type {\n                 CrateType::Rlib => {\n@@ -2352,15 +2352,6 @@ fn add_native_libs_from_crate(\n                                 &search_paths.get_or_init(|| archive_search_paths(sess)),\n                             );\n                         } else {\n-                            // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n-                            // with glibc. This logic should be moved to the libc crate.\n-                            if cnum != LOCAL_CRATE\n-                                && sess.target.os == \"linux\"\n-                                && sess.target.env == \"gnu\"\n-                                && name == \"c\"\n-                            {\n-                                cmd.link_staticlib(\"gcc\", false);\n-                            }\n                             cmd.link_staticlib(name, verbatim)\n                         }\n                     }"}, {"sha": "3dfded2d930a052c305859ed257536285303eda8", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -240,7 +240,7 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n                     let align = ImmTy::from_uint(target_align, args[1].layout).into();\n                     let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n \n-                    // We replace the entire entire function call with a \"tail call\".\n+                    // We replace the entire function call with a \"tail call\".\n                     // Note that this happens before the frame of the original function\n                     // is pushed on the stack.\n                     self.eval_fn_call("}, {"sha": "e17d3e516a64fb72ae438726e275956340bb2e24", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -676,6 +676,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n         trace!(\"body: {:#?}\", body);\n+        // Clobber previous return place contents, nobody is supposed to be able to see them any more\n+        // This also checks dereferenceable, but not align. We rely on all constructed places being\n+        // sufficiently aligned (in particular we rely on `deref_operand` checking alignment).\n+        self.write_uninit(return_place)?;\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,"}, {"sha": "0604d5ee6fa4c93e94211111da45abd2e4715f15", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -373,9 +373,21 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Executes a retagging operation.\n+    /// Executes a retagging operation for a single pointer.\n+    /// Returns the possibly adjusted pointer.\n     #[inline]\n-    fn retag(\n+    fn retag_ptr_value(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _kind: mir::RetagKind,\n+        val: &ImmTy<'tcx, Self::Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Self::Provenance>> {\n+        Ok(val.clone())\n+    }\n+\n+    /// Executes a retagging operation on a compound value.\n+    /// Replaces all pointers stored in the given place.\n+    #[inline]\n+    fn retag_place_contents(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: &PlaceTy<'tcx, Self::Provenance>,"}, {"sha": "81b44a49484d0a72e213d8a32b510e784b7938b1", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpResult, Scalar};\n use rustc_middle::ty::layout::LayoutOf;\n \n-use super::{InterpCx, Machine};\n+use super::{ImmTy, InterpCx, Machine};\n \n /// Classify whether an operator is \"left-homogeneous\", i.e., the LHS has the\n /// same type as the result.\n@@ -108,7 +108,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Stacked Borrows.\n             Retag(kind, place) => {\n                 let dest = self.eval_place(**place)?;\n-                M::retag(self, *kind, &dest)?;\n+                M::retag_place_contents(self, *kind, &dest)?;\n             }\n \n             Intrinsic(box ref intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n@@ -247,10 +247,41 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n             }\n \n-            AddressOf(_, place) | Ref(_, _, place) => {\n+            Ref(_, borrow_kind, place) => {\n                 let src = self.eval_place(place)?;\n                 let place = self.force_allocation(&src)?;\n-                self.write_immediate(place.to_ref(self), &dest)?;\n+                let val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n+                // A fresh reference was created, make sure it gets retagged.\n+                let val = M::retag_ptr_value(\n+                    self,\n+                    if borrow_kind.allows_two_phase_borrow() {\n+                        mir::RetagKind::TwoPhase\n+                    } else {\n+                        mir::RetagKind::Default\n+                    },\n+                    &val,\n+                )?;\n+                self.write_immediate(*val, &dest)?;\n+            }\n+\n+            AddressOf(_, place) => {\n+                // Figure out whether this is an addr_of of an already raw place.\n+                let place_base_raw = if place.has_deref() {\n+                    let ty = self.frame().body.local_decls[place.local].ty;\n+                    ty.is_unsafe_ptr()\n+                } else {\n+                    // Not a deref, and thus not raw.\n+                    false\n+                };\n+\n+                let src = self.eval_place(place)?;\n+                let place = self.force_allocation(&src)?;\n+                let mut val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n+                if !place_base_raw {\n+                    // If this was not already raw, it needs retagging.\n+                    val = M::retag_ptr_value(self, mir::RetagKind::Raw, &val)?;\n+                }\n+                self.write_immediate(*val, &dest)?;\n             }\n \n             NullaryOp(null_op, ty) => {"}, {"sha": "d98f4e43fe8843890fa1044df400b9b8113ea49f", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -140,7 +140,7 @@ impl stable_hasher::StableHasherResult for Fingerprint {\n     }\n }\n \n-impl_stable_hash_via_hash!(Fingerprint);\n+impl_stable_traits_for_trivial_type!(Fingerprint);\n \n impl<E: Encoder> Encodable<E> for Fingerprint {\n     #[inline]"}, {"sha": "ba94f3776eb90bc5da1e4e534508d689aa20dda7", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -4,8 +4,6 @@ use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use std::ptr;\n \n-use crate::fingerprint::Fingerprint;\n-\n mod private {\n     #[derive(Clone, Copy, Debug)]\n     pub struct PrivateZst;\n@@ -110,86 +108,5 @@ where\n     }\n }\n \n-/// A helper type that you can wrap round your own type in order to automatically\n-/// cache the stable hash on creation and not recompute it whenever the stable hash\n-/// of the type is computed.\n-/// This is only done in incremental mode. You can also opt out of caching by using\n-/// StableHash::ZERO for the hash, in which case the hash gets computed each time.\n-/// This is useful if you have values that you intern but never (can?) use for stable\n-/// hashing.\n-#[derive(Copy, Clone)]\n-pub struct WithStableHash<T> {\n-    pub internee: T,\n-    pub stable_hash: Fingerprint,\n-}\n-\n-impl<T: PartialEq> PartialEq for WithStableHash<T> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.internee.eq(&other.internee)\n-    }\n-}\n-\n-impl<T: Eq> Eq for WithStableHash<T> {}\n-\n-impl<T: Ord> PartialOrd for WithStableHash<T> {\n-    fn partial_cmp(&self, other: &WithStableHash<T>) -> Option<Ordering> {\n-        Some(self.internee.cmp(&other.internee))\n-    }\n-}\n-\n-impl<T: Ord> Ord for WithStableHash<T> {\n-    fn cmp(&self, other: &WithStableHash<T>) -> Ordering {\n-        self.internee.cmp(&other.internee)\n-    }\n-}\n-\n-impl<T> Deref for WithStableHash<T> {\n-    type Target = T;\n-\n-    #[inline]\n-    fn deref(&self) -> &T {\n-        &self.internee\n-    }\n-}\n-\n-impl<T: Hash> Hash for WithStableHash<T> {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        if self.stable_hash != Fingerprint::ZERO {\n-            self.stable_hash.hash(s)\n-        } else {\n-            self.internee.hash(s)\n-        }\n-    }\n-}\n-\n-impl<T: HashStable<CTX>, CTX> HashStable<CTX> for WithStableHash<T> {\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        if self.stable_hash == Fingerprint::ZERO || cfg!(debug_assertions) {\n-            // No cached hash available. This can only mean that incremental is disabled.\n-            // We don't cache stable hashes in non-incremental mode, because they are used\n-            // so rarely that the performance actually suffers.\n-\n-            // We need to build the hash as if we cached it and then hash that hash, as\n-            // otherwise the hashes will differ between cached and non-cached mode.\n-            let stable_hash: Fingerprint = {\n-                let mut hasher = StableHasher::new();\n-                self.internee.hash_stable(hcx, &mut hasher);\n-                hasher.finish()\n-            };\n-            if cfg!(debug_assertions) && self.stable_hash != Fingerprint::ZERO {\n-                assert_eq!(\n-                    stable_hash, self.stable_hash,\n-                    \"cached stable hash does not match freshly computed stable hash\"\n-                );\n-            }\n-            stable_hash.hash_stable(hcx, hasher);\n-        } else {\n-            self.stable_hash.hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "d13313dfd0ebfc4c145ad4a8756141a9f62c7a7c", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,4 +1,4 @@\n-use crate::stable_hasher::{HashStable, StableHasher};\n+use crate::stable_hasher::{HashStable, StableHasher, StableOrd};\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n use std::iter::FromIterator;\n@@ -308,7 +308,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for SortedMap<K, V> {\n     }\n }\n \n-impl<K: HashStable<CTX>, V: HashStable<CTX>, CTX> HashStable<CTX> for SortedMap<K, V> {\n+impl<K: HashStable<CTX> + StableOrd, V: HashStable<CTX>, CTX> HashStable<CTX> for SortedMap<K, V> {\n     #[inline]\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.data.hash_stable(ctx, hasher);"}, {"sha": "c2f0ae328962be15a9ac787fd62f51dd2f464b19", "filename": "compiler/rustc_data_structures/src/sorted_map/index_map.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -120,13 +120,20 @@ where\n         self.items.hash(hasher)\n     }\n }\n+\n impl<I: Idx, K, V, C> HashStable<C> for SortedIndexMultiMap<I, K, V>\n where\n     K: HashStable<C>,\n     V: HashStable<C>,\n {\n     fn hash_stable(&self, ctx: &mut C, hasher: &mut StableHasher) {\n-        self.items.hash_stable(ctx, hasher)\n+        let SortedIndexMultiMap {\n+            items,\n+            // We can ignore this field because it is not observable from the outside.\n+            idx_sorted_by_item_key: _,\n+        } = self;\n+\n+        items.hash_stable(ctx, hasher)\n     }\n }\n "}, {"sha": "1a728f82f006fa33a92597defccda7ac8e441431", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 68, "deletions": 29, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -219,42 +219,72 @@ pub trait ToStableHashKey<HCX> {\n     fn to_stable_hash_key(&self, hcx: &HCX) -> Self::KeyType;\n }\n \n-/// Implement HashStable by just calling `Hash::hash()`.\n+/// Trait for marking a type as having a sort order that is\n+/// stable across compilation session boundaries. More formally:\n+///\n+/// ```txt\n+/// Ord::cmp(a1, b1) == Ord:cmp(a2, b2)\n+///    where a2 = decode(encode(a1, context1), context2)\n+///          b2 = decode(encode(b1, context1), context2)\n+/// ```\n+///\n+/// i.e. the result of `Ord::cmp` is not influenced by encoding\n+/// the values in one session and then decoding them in another\n+/// session.\n+///\n+/// This is trivially true for types where encoding and decoding\n+/// don't change the bytes of the values that are used during\n+/// comparison and comparison only depends on these bytes (as\n+/// opposed to some non-local state). Examples are u32, String,\n+/// Path, etc.\n+///\n+/// But it is not true for:\n+///  - `*const T` and `*mut T` because the values of these pointers\n+///    will change between sessions.\n+///  - `DefIndex`, `CrateNum`, `LocalDefId`, because their concrete\n+///    values depend on state that might be different between\n+///    compilation sessions.\n+pub unsafe trait StableOrd: Ord {}\n+\n+/// Implement HashStable by just calling `Hash::hash()`. Also implement `StableOrd` for the type since\n+/// that has the same requirements.\n ///\n /// **WARNING** This is only valid for types that *really* don't need any context for fingerprinting.\n /// But it is easy to misuse this macro (see [#96013](https://github.com/rust-lang/rust/issues/96013)\n /// for examples). Therefore this macro is not exported and should only be used in the limited cases\n /// here in this module.\n ///\n /// Use `#[derive(HashStable_Generic)]` instead.\n-macro_rules! impl_stable_hash_via_hash {\n+macro_rules! impl_stable_traits_for_trivial_type {\n     ($t:ty) => {\n         impl<CTX> $crate::stable_hasher::HashStable<CTX> for $t {\n             #[inline]\n             fn hash_stable(&self, _: &mut CTX, hasher: &mut $crate::stable_hasher::StableHasher) {\n                 ::std::hash::Hash::hash(self, hasher);\n             }\n         }\n+\n+        unsafe impl $crate::stable_hasher::StableOrd for $t {}\n     };\n }\n \n-impl_stable_hash_via_hash!(i8);\n-impl_stable_hash_via_hash!(i16);\n-impl_stable_hash_via_hash!(i32);\n-impl_stable_hash_via_hash!(i64);\n-impl_stable_hash_via_hash!(isize);\n+impl_stable_traits_for_trivial_type!(i8);\n+impl_stable_traits_for_trivial_type!(i16);\n+impl_stable_traits_for_trivial_type!(i32);\n+impl_stable_traits_for_trivial_type!(i64);\n+impl_stable_traits_for_trivial_type!(isize);\n \n-impl_stable_hash_via_hash!(u8);\n-impl_stable_hash_via_hash!(u16);\n-impl_stable_hash_via_hash!(u32);\n-impl_stable_hash_via_hash!(u64);\n-impl_stable_hash_via_hash!(usize);\n+impl_stable_traits_for_trivial_type!(u8);\n+impl_stable_traits_for_trivial_type!(u16);\n+impl_stable_traits_for_trivial_type!(u32);\n+impl_stable_traits_for_trivial_type!(u64);\n+impl_stable_traits_for_trivial_type!(usize);\n \n-impl_stable_hash_via_hash!(u128);\n-impl_stable_hash_via_hash!(i128);\n+impl_stable_traits_for_trivial_type!(u128);\n+impl_stable_traits_for_trivial_type!(i128);\n \n-impl_stable_hash_via_hash!(char);\n-impl_stable_hash_via_hash!(());\n+impl_stable_traits_for_trivial_type!(char);\n+impl_stable_traits_for_trivial_type!(());\n \n impl<CTX> HashStable<CTX> for ! {\n     fn hash_stable(&self, _ctx: &mut CTX, _hasher: &mut StableHasher) {\n@@ -444,6 +474,10 @@ impl<CTX> HashStable<CTX> for String {\n     }\n }\n \n+// Safety: String comparison only depends on their contents and the\n+// contents are not changed by (de-)serialization.\n+unsafe impl StableOrd for String {}\n+\n impl<HCX> ToStableHashKey<HCX> for String {\n     type KeyType = String;\n     #[inline]\n@@ -459,6 +493,9 @@ impl<CTX> HashStable<CTX> for bool {\n     }\n }\n \n+// Safety: sort order of bools is not changed by (de-)serialization.\n+unsafe impl StableOrd for bool {}\n+\n impl<T, CTX> HashStable<CTX> for Option<T>\n where\n     T: HashStable<CTX>,\n@@ -474,6 +511,9 @@ where\n     }\n }\n \n+// Safety: the Option wrapper does not add instability to comparison.\n+unsafe impl<T: StableOrd> StableOrd for Option<T> {}\n+\n impl<T1, T2, CTX> HashStable<CTX> for Result<T1, T2>\n where\n     T1: HashStable<CTX>,\n@@ -550,8 +590,8 @@ where\n     }\n }\n \n-impl_stable_hash_via_hash!(::std::path::Path);\n-impl_stable_hash_via_hash!(::std::path::PathBuf);\n+impl_stable_traits_for_trivial_type!(::std::path::Path);\n+impl_stable_traits_for_trivial_type!(::std::path::PathBuf);\n \n impl<K, V, R, HCX> HashStable<HCX> for ::std::collections::HashMap<K, V, R>\n where\n@@ -584,27 +624,26 @@ where\n \n impl<K, V, HCX> HashStable<HCX> for ::std::collections::BTreeMap<K, V>\n where\n-    K: ToStableHashKey<HCX>,\n+    K: HashStable<HCX> + StableOrd,\n     V: HashStable<HCX>,\n {\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n-        stable_hash_reduce(hcx, hasher, self.iter(), self.len(), |hasher, hcx, (key, value)| {\n-            let key = key.to_stable_hash_key(hcx);\n-            key.hash_stable(hcx, hasher);\n-            value.hash_stable(hcx, hasher);\n-        });\n+        self.len().hash_stable(hcx, hasher);\n+        for entry in self.iter() {\n+            entry.hash_stable(hcx, hasher);\n+        }\n     }\n }\n \n impl<K, HCX> HashStable<HCX> for ::std::collections::BTreeSet<K>\n where\n-    K: ToStableHashKey<HCX>,\n+    K: HashStable<HCX> + StableOrd,\n {\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n-        stable_hash_reduce(hcx, hasher, self.iter(), self.len(), |hasher, hcx, key| {\n-            let key = key.to_stable_hash_key(hcx);\n-            key.hash_stable(hcx, hasher);\n-        });\n+        self.len().hash_stable(hcx, hasher);\n+        for entry in self.iter() {\n+            entry.hash_stable(hcx, hasher);\n+        }\n     }\n }\n "}, {"sha": "f06ca5a0733a58039724c244df9f27ba871be246", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -25,6 +25,7 @@ use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{ErrorGuaranteed, PResult};\n use rustc_feature::find_gated_cfg;\n+use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n@@ -374,14 +375,14 @@ fn run_compiler(\n             queries.global_ctxt()?.peek_mut().enter(|tcx| {\n                 let result = tcx.analysis(());\n                 if sess.opts.unstable_opts.save_analysis {\n-                    let crate_name = queries.crate_name()?.peek().clone();\n+                    let crate_name = tcx.crate_name(LOCAL_CRATE);\n                     sess.time(\"save_analysis\", || {\n                         save::process_crate(\n                             tcx,\n-                            &crate_name,\n+                            crate_name,\n                             compiler.input(),\n                             None,\n-                            DumpHandler::new(compiler.output_dir().as_deref(), &crate_name),\n+                            DumpHandler::new(compiler.output_dir().as_deref(), crate_name),\n                         )\n                     });\n                 }\n@@ -678,7 +679,7 @@ fn print_crate_info(\n                 let crate_types = collect_crate_types(sess, attrs);\n                 for &style in &crate_types {\n                     let fname =\n-                        rustc_session::output::filename_for_input(sess, style, &id, &t_outputs);\n+                        rustc_session::output::filename_for_input(sess, style, id, &t_outputs);\n                     println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n                 }\n             }"}, {"sha": "31a709c36d4bc57461cf93cc57840ece6635ebc2", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -494,6 +494,7 @@ E0786: include_str!(\"./error_codes/E0786.md\"),\n E0787: include_str!(\"./error_codes/E0787.md\"),\n E0788: include_str!(\"./error_codes/E0788.md\"),\n E0790: include_str!(\"./error_codes/E0790.md\"),\n+E0791: include_str!(\"./error_codes/E0791.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "61d2f511a348db34cd81db91fb581945e5ae605f", "filename": "compiler/rustc_error_codes/src/error_codes/E0791.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0791.md", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0791.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0791.md?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,41 @@\n+Static variables with the `#[linkage]` attribute within external blocks\n+must have one of the following types, which are equivalent to a nullable\n+pointer in C:\n+\n+* `*mut T` or `*const T`, where `T` may be any type.\n+\n+* An enumerator type with no `#[repr]` attribute and with two variants, where\n+  one of the variants has no fields, and the other has a single field of one of\n+  the following non-nullable types:\n+  * Reference type\n+  * Function pointer type\n+\n+  The variants can appear in either order.\n+\n+For example, the following declaration is invalid:\n+\n+```compile_fail,E0791\n+#![feature(linkage)]\n+\n+extern \"C\" {\n+    #[linkage = \"extern_weak\"]\n+    static foo: i8;\n+}\n+```\n+\n+The following declarations are valid:\n+\n+```\n+#![feature(linkage)]\n+\n+extern \"C\" {\n+    #[linkage = \"extern_weak\"]\n+    static foo: Option<unsafe extern \"C\" fn()>;\n+\n+    #[linkage = \"extern_weak\"]\n+    static bar: Option<&'static i8>;\n+\n+    #[linkage = \"extern_weak\"]\n+    static baz: *mut i8;\n+}\n+```"}, {"sha": "08ce5172574ac3bb1af28314ec2200a26b8d221a", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_gcc.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,6 +1,3 @@\n-codegen_gcc_linkage_const_or_mut_type =\n-    must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n-\n codegen_gcc_unwinding_inline_asm =\n     GCC backend does not support unwinding from inline asm\n "}, {"sha": "97198cb4be2c827def75802a49b4af95bc5adaf0", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -23,9 +23,6 @@ codegen_llvm_branch_protection_requires_aarch64 =\n codegen_llvm_invalid_minimum_alignment =\n     invalid minimum global alignment: {$err}\n \n-codegen_llvm_linkage_const_or_mut_type =\n-    must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n-\n codegen_llvm_sanitizer_memtag_requires_mte =\n     `-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\n "}, {"sha": "a9ea161b93eda2251a9c779dc1eabfad0a36baa1", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -17,6 +17,8 @@ hir_analysis_lifetimes_or_bounds_mismatch_on_trait =\n     lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n     .label = lifetimes do not match {$item_kind} in trait\n     .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n+    .where_label = this `where` clause might not match the one in the trait\n+    .bounds_label = this bound might be missing in the impl\n \n hir_analysis_drop_impl_on_wrong_item =\n     the `Drop` trait may only be implemented for local structs, enums, and unions\n@@ -113,3 +115,6 @@ hir_analysis_const_bound_for_non_const_trait =\n hir_analysis_self_in_impl_self =\n     `Self` is not valid in the self type of an impl block\n     .note = replace `Self` with a different type\n+\n+hir_analysis_linkage_type =\n+    invalid type for variable with `#[linkage]` attribute"}, {"sha": "b53550e5fd556c02e58acd21fbae26252bb2b69a", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -362,3 +362,6 @@ parse_fn_ptr_with_generics = function pointer types may not have generic paramet\n \n parse_invalid_identifier_with_leading_number = expected identifier, found number literal\n     .label = identifiers cannot start with a number\n+\n+parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of `fn`\n+    .suggestion = replace `fn` with `impl` here"}, {"sha": "9d6a4f9a1fd7d063dfc06c704e5084abf31de117", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -960,7 +960,7 @@ pub trait LintStoreExpand {\n         node_id: NodeId,\n         attrs: &[Attribute],\n         items: &[P<Item>],\n-        name: &str,\n+        name: Symbol,\n     );\n }\n "}, {"sha": "1014ec2209c614cec4fef55cbbc9481be3192792", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1122,7 +1122,7 @@ impl InvocationCollectorNode for P<ast::Item> {\n                         ecx.current_expansion.lint_node_id,\n                         &attrs,\n                         &items,\n-                        ident.name.as_str(),\n+                        ident.name,\n                     );\n                 }\n "}, {"sha": "8bc022e1e178e19b50698104254dad839b950461", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -827,7 +827,7 @@ impl<'tcx> AttributeMap<'tcx> {\n pub struct OwnerNodes<'tcx> {\n     /// Pre-computed hash of the full HIR.\n     pub hash_including_bodies: Fingerprint,\n-    /// Pre-computed hash of the item signature, sithout recursing into the body.\n+    /// Pre-computed hash of the item signature, without recursing into the body.\n     pub hash_without_bodies: Fingerprint,\n     /// Full HIR for the current owner.\n     // The zeroth node's parent should never be accessed: the owner's parent is computed by the"}, {"sha": "060f40919f5c8d16fd4490d5aab593aa5b4e8452", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,5 +1,5 @@\n use crate::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_ID};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableOrd, ToStableHashKey};\n use rustc_span::{def_id::DefPathHash, HashStableContext};\n use std::fmt;\n \n@@ -146,6 +146,10 @@ impl ItemLocalId {\n     pub const INVALID: ItemLocalId = ItemLocalId::MAX;\n }\n \n+// Safety: Ord is implement as just comparing the LocalItemId's numerical\n+// values and these are not changed by (de-)serialization.\n+unsafe impl StableOrd for ItemLocalId {}\n+\n /// The `HirId` corresponding to `CRATE_NODE_ID` and `CRATE_DEF_ID`.\n pub const CRATE_HIR_ID: HirId =\n     HirId { owner: OwnerId { def_id: CRATE_DEF_ID }, local_id: ItemLocalId::from_u32(0) };"}, {"sha": "b51257df713ea37a273bc14fc579d3ac38eb7e9f", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -286,10 +286,9 @@ language_item_table! {\n \n     // FIXME(swatinem): the following lang items are used for async lowering and\n     // should become obsolete eventually.\n-    ResumeTy,                sym::ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n     IdentityFuture,          sym::identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n-    GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n+    Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n     FromFrom,                sym::from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;"}, {"sha": "d4791150947fb1fa3fa9f7a529ee113f59fea059", "filename": "compiler/rustc_hir/src/tests.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftests.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,5 +1,7 @@\n use crate::definitions::{DefKey, DefPathData, DisambiguatedDefPathData};\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n+use rustc_span::edition::Edition;\n+use rustc_span::{create_session_if_not_set_then, Symbol};\n \n #[test]\n fn def_path_hash_depends_on_crate_id() {\n@@ -11,26 +13,28 @@ fn def_path_hash_depends_on_crate_id() {\n     // the crate by changing the crate disambiguator (e.g. via bumping the\n     // crate's version number).\n \n-    let id0 = StableCrateId::new(\"foo\", false, vec![\"1\".to_string()]);\n-    let id1 = StableCrateId::new(\"foo\", false, vec![\"2\".to_string()]);\n+    create_session_if_not_set_then(Edition::Edition2024, |_| {\n+        let id0 = StableCrateId::new(Symbol::intern(\"foo\"), false, vec![\"1\".to_string()]);\n+        let id1 = StableCrateId::new(Symbol::intern(\"foo\"), false, vec![\"2\".to_string()]);\n \n-    let h0 = mk_test_hash(id0);\n-    let h1 = mk_test_hash(id1);\n+        let h0 = mk_test_hash(id0);\n+        let h1 = mk_test_hash(id1);\n \n-    assert_ne!(h0.stable_crate_id(), h1.stable_crate_id());\n-    assert_ne!(h0.local_hash(), h1.local_hash());\n+        assert_ne!(h0.stable_crate_id(), h1.stable_crate_id());\n+        assert_ne!(h0.local_hash(), h1.local_hash());\n \n-    fn mk_test_hash(stable_crate_id: StableCrateId) -> DefPathHash {\n-        let parent_hash = DefPathHash::new(stable_crate_id, 0);\n+        fn mk_test_hash(stable_crate_id: StableCrateId) -> DefPathHash {\n+            let parent_hash = DefPathHash::new(stable_crate_id, 0);\n \n-        let key = DefKey {\n-            parent: None,\n-            disambiguated_data: DisambiguatedDefPathData {\n-                data: DefPathData::CrateRoot,\n-                disambiguator: 0,\n-            },\n-        };\n+            let key = DefKey {\n+                parent: None,\n+                disambiguated_data: DisambiguatedDefPathData {\n+                    data: DefPathData::CrateRoot,\n+                    disambiguator: 0,\n+                },\n+            };\n \n-        key.compute_stable_hash(parent_hash)\n-    }\n+            key.compute_stable_hash(parent_hash)\n+        }\n+    })\n }"}, {"sha": "66906b331da2ece663b3b06fb9883a144b5d474a", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1930,6 +1930,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     adt_substs,\n                 );\n                 let ty = tcx.bound_type_of(assoc_ty_did).subst(tcx, item_substs);\n+                let ty = self.normalize_ty(span, ty);\n                 return Ok((ty, DefKind::AssocTy, assoc_ty_did));\n             }\n         }"}, {"sha": "fc0ca62090d19c62b3a1656963ef85f026d1b793", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,4 +1,5 @@\n use crate::check::intrinsicck::InlineAsmCtxt;\n+use crate::errors::LinkageType;\n \n use super::compare_method::check_type_bounds;\n use super::compare_method::{compare_impl_method, compare_ty_impl};\n@@ -20,7 +21,7 @@ use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::{self, AdtDef, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n@@ -478,6 +479,36 @@ fn check_opaque_meets_bounds<'tcx>(\n     let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n }\n \n+fn is_enum_of_nonnullable_ptr<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    adt_def: AdtDef<'tcx>,\n+    substs: SubstsRef<'tcx>,\n+) -> bool {\n+    if adt_def.repr().inhibit_enum_layout_opt() {\n+        return false;\n+    }\n+\n+    let [var_one, var_two] = &adt_def.variants().raw[..] else {\n+        return false;\n+    };\n+    let (([], [field]) | ([field], [])) = (&var_one.fields[..], &var_two.fields[..]) else {\n+        return false;\n+    };\n+    matches!(field.ty(tcx, substs).kind(), ty::FnPtr(..) | ty::Ref(..))\n+}\n+\n+fn check_static_linkage<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n+    if tcx.codegen_fn_attrs(def_id).import_linkage.is_some() {\n+        if match tcx.type_of(def_id).kind() {\n+            ty::RawPtr(_) => false,\n+            ty::Adt(adt_def, substs) => !is_enum_of_nonnullable_ptr(tcx, *adt_def, *substs),\n+            _ => true,\n+        } {\n+            tcx.sess.emit_err(LinkageType { span: tcx.def_span(def_id) });\n+        }\n+    }\n+}\n+\n fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     debug!(\n         \"check_item_type(it.def_id={:?}, it.name={})\",\n@@ -490,6 +521,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             tcx.ensure().typeck(id.owner_id.def_id);\n             maybe_check_static_with_link_section(tcx, id.owner_id.def_id);\n             check_static_inhabited(tcx, id.owner_id.def_id);\n+            check_static_linkage(tcx, id.owner_id.def_id);\n         }\n         DefKind::Const => {\n             tcx.ensure().typeck(id.owner_id.def_id);\n@@ -627,6 +659,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                         }\n                         hir::ForeignItemKind::Static(..) => {\n                             check_static_inhabited(tcx, def_id);\n+                            check_static_linkage(tcx, def_id);\n                         }\n                         _ => {}\n                     }"}, {"sha": "1d6f9b29176518a30f487dca7eab58e0610b3ccf", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -751,27 +751,56 @@ fn check_region_bounds_on_impl_item<'tcx>(\n             .get_generics(impl_m.def_id.expect_local())\n             .expect(\"expected impl item to have generics or else we can't compare them\")\n             .span;\n-        let generics_span = if let Some(local_def_id) = trait_m.def_id.as_local() {\n-            Some(\n-                tcx.hir()\n-                    .get_generics(local_def_id)\n-                    .expect(\"expected trait item to have generics or else we can't compare them\")\n-                    .span,\n-            )\n-        } else {\n-            None\n-        };\n \n+        let mut generics_span = None;\n+        let mut bounds_span = vec![];\n+        let mut where_span = None;\n+        if let Some(trait_node) = tcx.hir().get_if_local(trait_m.def_id)\n+            && let Some(trait_generics) = trait_node.generics()\n+        {\n+            generics_span = Some(trait_generics.span);\n+            // FIXME: we could potentially look at the impl's bounds to not point at bounds that\n+            // *are* present in the impl.\n+            for p in trait_generics.predicates {\n+                if let hir::WherePredicate::BoundPredicate(pred) = p {\n+                    for b in pred.bounds {\n+                        if let hir::GenericBound::Outlives(lt) = b {\n+                            bounds_span.push(lt.ident.span);\n+                        }\n+                    }\n+                }\n+            }\n+            if let Some(impl_node) = tcx.hir().get_if_local(impl_m.def_id)\n+                && let Some(impl_generics) = impl_node.generics()\n+            {\n+                let mut impl_bounds = 0;\n+                for p in impl_generics.predicates {\n+                    if let hir::WherePredicate::BoundPredicate(pred) = p {\n+                        for b in pred.bounds {\n+                            if let hir::GenericBound::Outlives(_) = b {\n+                                impl_bounds += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+                if impl_bounds == bounds_span.len() {\n+                    bounds_span = vec![];\n+                } else if impl_generics.has_where_clause_predicates {\n+                    where_span = Some(impl_generics.where_clause_span);\n+                }\n+            }\n+        }\n         let reported = tcx\n             .sess\n             .create_err(LifetimesOrBoundsMismatchOnTrait {\n                 span,\n                 item_kind: assoc_item_kind_str(impl_m),\n                 ident: impl_m.ident(tcx),\n                 generics_span,\n+                bounds_span,\n+                where_span,\n             })\n             .emit_unless(delay);\n-\n         return Err(reported);\n     }\n "}, {"sha": "945361ef43a4eff5e85557adb4244bfecef68041", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1814,7 +1814,12 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             );\n         } else if attr.has_name(sym::linkage) {\n             if let Some(val) = attr.value_str() {\n-                codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n+                let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n+                if tcx.is_foreign_item(did) {\n+                    codegen_fn_attrs.import_linkage = linkage;\n+                } else {\n+                    codegen_fn_attrs.linkage = linkage;\n+                }\n             }\n         } else if attr.has_name(sym::link_section) {\n             if let Some(val) = attr.value_str() {"}, {"sha": "0a7e25300cba84b38c551cc6ea84fc71ef786e7f", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -4,7 +4,6 @@ use hir::{\n     GenericParamKind, HirId, Node,\n };\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint;\n@@ -143,20 +142,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             Some(tcx.typeck_root_def_id(def_id))\n         }\n         Node::Item(item) => match item.kind {\n-            ItemKind::OpaqueTy(hir::OpaqueTy {\n-                origin:\n-                    hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n-                in_trait,\n-                ..\n-            }) => {\n-                if in_trait {\n-                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn))\n-                } else {\n-                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn | DefKind::Fn))\n-                }\n-                Some(fn_def_id.to_def_id())\n-            }\n-            ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n+            ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n                 let parent_id = tcx.hir().get_parent_item(hir_id);\n                 assert_ne!(parent_id, hir::CRATE_OWNER_ID);\n                 debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);"}, {"sha": "c92ab749bc1f7dc4a7e44023f684401aecde76b7", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -43,6 +43,10 @@ pub struct LifetimesOrBoundsMismatchOnTrait {\n     pub span: Span,\n     #[label(generics_label)]\n     pub generics_span: Option<Span>,\n+    #[label(where_label)]\n+    pub where_span: Option<Span>,\n+    #[label(bounds_label)]\n+    pub bounds_span: Vec<Span>,\n     pub item_kind: &'static str,\n     pub ident: Ident,\n }\n@@ -285,3 +289,10 @@ pub struct SelfInImplSelf {\n     #[note]\n     pub note: (),\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_linkage_type, code = \"E0791\")]\n+pub(crate) struct LinkageType {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "8b2719c2f8aaaef1add2f372c81751f7b6bdc8c2", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -7,7 +7,8 @@ use rustc_arena::DroplessArena;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, CrateVariancesMap, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::{self, CrateVariancesMap, SubstsRef, Ty, TyCtxt};\n+use rustc_middle::ty::{DefIdTree, TypeSuperVisitable, TypeVisitable};\n use std::ops::ControlFlow;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n@@ -75,18 +76,50 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n     // type Foo<'a, 'b, 'c> = impl Trait<'a> + 'b;\n     // ```\n     // we may not use `'c` in the hidden type.\n-    struct OpaqueTypeLifetimeCollector {\n+    struct OpaqueTypeLifetimeCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        root_def_id: DefId,\n         variances: Vec<ty::Variance>,\n     }\n \n-    impl<'tcx> ty::TypeVisitor<'tcx> for OpaqueTypeLifetimeCollector {\n+    impl<'tcx> OpaqueTypeLifetimeCollector<'tcx> {\n+        #[instrument(level = \"trace\", skip(self), ret)]\n+        fn visit_opaque(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) -> ControlFlow<!> {\n+            if def_id != self.root_def_id && self.tcx.is_descendant_of(def_id, self.root_def_id) {\n+                let child_variances = self.tcx.variances_of(def_id);\n+                for (a, v) in substs.iter().zip(child_variances) {\n+                    if *v != ty::Bivariant {\n+                        a.visit_with(self)?;\n+                    }\n+                }\n+                ControlFlow::CONTINUE\n+            } else {\n+                substs.visit_with(self)\n+            }\n+        }\n+    }\n+\n+    impl<'tcx> ty::TypeVisitor<'tcx> for OpaqueTypeLifetimeCollector<'tcx> {\n         #[instrument(level = \"trace\", skip(self), ret)]\n         fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n             if let ty::RegionKind::ReEarlyBound(ebr) = r.kind() {\n                 self.variances[ebr.index as usize] = ty::Invariant;\n             }\n             r.super_visit_with(self)\n         }\n+\n+        #[instrument(level = \"trace\", skip(self), ret)]\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            match t.kind() {\n+                ty::Opaque(def_id, substs) => self.visit_opaque(*def_id, substs),\n+                ty::Projection(proj)\n+                    if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+                {\n+                    self.visit_opaque(proj.item_def_id, proj.substs)\n+                }\n+                _ => t.super_visit_with(self),\n+            }\n+        }\n     }\n \n     // By default, RPIT are invariant wrt type and const generics, but they are bivariant wrt\n@@ -111,7 +144,8 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n         }\n     }\n \n-    let mut collector = OpaqueTypeLifetimeCollector { variances };\n+    let mut collector =\n+        OpaqueTypeLifetimeCollector { tcx, root_def_id: item_def_id.to_def_id(), variances };\n     let id_substs = ty::InternalSubsts::identity_for_item(tcx, item_def_id.to_def_id());\n     for pred in tcx.bound_explicit_item_bounds(item_def_id.to_def_id()).transpose_iter() {\n         let pred = pred.map_bound(|(pred, _)| *pred).subst(tcx, id_substs);"}, {"sha": "94bab9f339d8c9e0b8d0c5741975506184e1bbca", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -695,19 +695,8 @@ impl<'a> State<'a> {\n                 self.head(\"trait\");\n                 self.print_ident(item.ident);\n                 self.print_generic_params(generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                // FIXME(durka) this seems to be some quite outdated syntax\n-                for b in bounds {\n-                    if let GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b);\n-                    }\n-                }\n                 self.nbsp();\n-                self.print_bounds(\"=\", real_bounds);\n+                self.print_bounds(\"=\", bounds);\n                 self.print_where_clause(generics);\n                 self.word(\";\");\n                 self.end(); // end inner head-block"}, {"sha": "32f86b8042c11c39d36baa268dc8cb40d1c1a1c3", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,7 +1,7 @@\n use crate::coercion::CoerceMany;\n use crate::gather_locals::GatherLocalsVisitor;\n use crate::FnCtxt;\n-use crate::{GeneratorTypes, UnsafetyState};\n+use crate::GeneratorTypes;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::intravisit::Visitor;\n@@ -30,7 +30,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n     can_be_generator: Option<hir::Movability>,\n ) -> Option<GeneratorTypes<'tcx>> {\n     let fn_id = fcx.tcx.hir().local_def_id_to_hir_id(fn_def_id);\n-    fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n \n     let tcx = fcx.tcx;\n     let hir = tcx.hir();"}, {"sha": "ed87b94a040d0f87b4d665898481ea2efa3c10d9", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1647,6 +1647,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // the fields with the base_expr. This could cause us to hit errors later\n         // when certain fields are assumed to exist that in fact do not.\n         if error_happened {\n+            if let Some(base_expr) = base_expr {\n+                self.check_expr(base_expr);\n+            }\n             return;\n         }\n "}, {"sha": "03b174c77955fb400eab47aa6071b3cec6bef94a", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -523,6 +523,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n             self.consume_expr(field.expr);\n+\n+            // The struct path probably didn't resolve\n+            if self.mc.typeck_results.opt_field_index(field.hir_id).is_none() {\n+                self.tcx().sess.delay_span_bug(field.span, \"couldn't resolve index for field\");\n+            }\n         }\n \n         let with_expr = match *opt_with {\n@@ -540,9 +545,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n-                    let is_mentioned = fields.iter().any(|f| {\n-                        self.tcx().field_index(f.hir_id, self.mc.typeck_results) == f_index\n-                    });\n+                    let is_mentioned = fields\n+                        .iter()\n+                        .any(|f| self.mc.typeck_results.opt_field_index(f.hir_id) == Some(f_index));\n                     if !is_mentioned {\n                         let field_place = self.mc.cat_projection(\n                             &*with_expr,"}, {"sha": "60fec05d36d6d57545a223bda2a4d1c7d73af4d5", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1393,8 +1393,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         blk: &'tcx hir::Block<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        let prev = self.ps.replace(self.ps.get().recurse(blk));\n-\n         // In some cases, blocks have just one exit, but other blocks\n         // can be targeted by multiple breaks. This can happen both\n         // with labeled blocks as well as when we desugar\n@@ -1558,7 +1556,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.write_ty(blk.hir_id, ty);\n \n-        self.ps.set(prev);\n         ty\n     }\n \n@@ -1918,15 +1915,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         receiver: Option<&'tcx hir::Expr<'tcx>>,\n         args: &'tcx [hir::Expr<'tcx>],\n     ) -> bool {\n-        // Do not call `fn_sig` on non-functions.\n-        if !matches!(\n-            self.tcx.def_kind(def_id),\n-            DefKind::Fn | DefKind::AssocFn | DefKind::Variant | DefKind::Ctor(..)\n-        ) {\n+        let ty = self.tcx.type_of(def_id);\n+        if !ty.is_fn() {\n             return false;\n         }\n-\n-        let sig = self.tcx.fn_sig(def_id).skip_binder();\n+        let sig = ty.fn_sig(self.tcx).skip_binder();\n         let args_referencing_param: Vec<_> = sig\n             .inputs()\n             .iter()"}, {"sha": "30b59da7852d46f1e96543ef7566668e00834910", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::ErrorGuaranteed;\n pub use suggestions::*;\n \n use crate::coercion::DynamicCoerceMany;\n-use crate::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n+use crate::{Diverges, EnclosingBreakables, Inherited};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir_analysis::astconv::AstConv;\n@@ -74,8 +74,6 @@ pub struct FnCtxt<'a, 'tcx> {\n \n     pub(super) resume_yield_tys: Option<(Ty<'tcx>, Ty<'tcx>)>,\n \n-    pub(super) ps: Cell<UnsafetyState>,\n-\n     /// Whether the last checked node generates a divergence (e.g.,\n     /// `return` will set this to `Always`). In general, when entering\n     /// an expression or other node in the tree, the initial value\n@@ -129,7 +127,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ret_coercion: None,\n             ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,\n-            ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             enclosing_breakables: RefCell::new(EnclosingBreakables {\n                 stack: Vec::new(),"}, {"sha": "4f92477b5d87ef221239c71054742025efb7bf32", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -32,11 +32,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub(in super::super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut Diagnostic) {\n+        // This suggestion is incorrect for\n+        // fn foo() -> bool { match () { () => true } || match () { () => true } }\n         err.span_suggestion_short(\n             span.shrink_to_hi(),\n             \"consider using a semicolon here\",\n             \";\",\n-            Applicability::MachineApplicable,\n+            Applicability::MaybeIncorrect,\n         );\n     }\n "}, {"sha": "5b2352cda34b3ee5fa9bcfa2f98d11acee4af2c4", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -89,38 +89,6 @@ pub struct LocalTy<'tcx> {\n     revealed_ty: Ty<'tcx>,\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnsafetyState {\n-    pub def: hir::HirId,\n-    pub unsafety: hir::Unsafety,\n-    from_fn: bool,\n-}\n-\n-impl UnsafetyState {\n-    pub fn function(unsafety: hir::Unsafety, def: hir::HirId) -> UnsafetyState {\n-        UnsafetyState { def, unsafety, from_fn: true }\n-    }\n-\n-    pub fn recurse(self, blk: &hir::Block<'_>) -> UnsafetyState {\n-        use hir::BlockCheckMode;\n-        match self.unsafety {\n-            // If this unsafe, then if the outer function was already marked as\n-            // unsafe we shouldn't attribute the unsafe'ness to the block. This\n-            // way the block can be warned about instead of ignoring this\n-            // extraneous block (functions are never warned about).\n-            hir::Unsafety::Unsafe if self.from_fn => self,\n-\n-            unsafety => {\n-                let (unsafety, def) = match blk.rules {\n-                    BlockCheckMode::UnsafeBlock(..) => (hir::Unsafety::Unsafe, blk.hir_id),\n-                    BlockCheckMode::DefaultBlock => (unsafety, self.def),\n-                };\n-                UnsafetyState { def, unsafety, from_fn: false }\n-            }\n-        }\n-    }\n-}\n-\n /// If this `DefId` is a \"primary tables entry\", returns\n /// `Some((body_id, body_ty, fn_sig))`. Otherwise, returns `None`.\n ///"}, {"sha": "db93cfab2c0dbd6a45508b9c35607b642cfe6c51", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1482,25 +1482,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ident_name: Symbol,\n         }\n \n+        // FIXME: This really should be taking scoping, etc into account.\n         impl<'v> Visitor<'v> for LetVisitor<'v> {\n             fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n-                if let hir::StmtKind::Local(hir::Local { pat, init, .. }) = &ex.kind {\n-                    if let Binding(_, _, ident, ..) = pat.kind &&\n-                        ident.name == self.ident_name {\n-                        self.result = *init;\n-                    }\n+                if let hir::StmtKind::Local(hir::Local { pat, init, .. }) = &ex.kind\n+                    && let Binding(_, _, ident, ..) = pat.kind\n+                    && ident.name == self.ident_name\n+                {\n+                    self.result = *init;\n+                } else {\n+                    hir::intravisit::walk_stmt(self, ex);\n                 }\n-                hir::intravisit::walk_stmt(self, ex);\n             }\n         }\n \n         let mut visitor = LetVisitor { result: None, ident_name: seg1.ident.name };\n         visitor.visit_body(&body);\n \n         let parent = self.tcx.hir().get_parent_node(seg1.hir_id);\n-        if let Some(Node::Expr(call_expr)) = self.tcx.hir().find(parent) &&\n-            let Some(expr) = visitor.result {\n-            let self_ty = self.node_ty(expr.hir_id);\n+        if let Some(Node::Expr(call_expr)) = self.tcx.hir().find(parent)\n+            && let Some(expr) = visitor.result\n+            && let Some(self_ty) = self.node_ty_opt(expr.hir_id)\n+        {\n             let probe = self.lookup_probe(\n                 seg2.ident,\n                 self_ty,\n@@ -1513,7 +1516,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     sm.span_extend_while(seg1.ident.span.shrink_to_hi(), |c| c == ':').unwrap(),\n                     \"you may have meant to call an instance method\",\n                     \".\".to_string(),\n-                    Applicability::MaybeIncorrect\n+                    Applicability::MaybeIncorrect,\n                 );\n             }\n         }"}, {"sha": "97ebed0585579ab99bb60bc2b6eb0889f842261c", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -109,6 +109,7 @@ use rustc_data_structures::{base_n, flock};\n use rustc_errors::ErrorGuaranteed;\n use rustc_fs_util::{link_or_copy, LinkOrCopy};\n use rustc_session::{Session, StableCrateId};\n+use rustc_span::Symbol;\n \n use std::fs as std_fs;\n use std::io::{self, ErrorKind};\n@@ -202,7 +203,7 @@ pub fn in_incr_comp_dir(incr_comp_session_dir: &Path, file_name: &str) -> PathBu\n /// [`rustc_interface::queries::dep_graph`]: ../../rustc_interface/struct.Queries.html#structfield.dep_graph\n pub fn prepare_session_directory(\n     sess: &Session,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     stable_crate_id: StableCrateId,\n ) -> Result<(), ErrorGuaranteed> {\n     if sess.opts.incremental.is_none() {\n@@ -657,7 +658,7 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n     Ok(UNIX_EPOCH + duration)\n }\n \n-fn crate_path(sess: &Session, crate_name: &str, stable_crate_id: StableCrateId) -> PathBuf {\n+fn crate_path(sess: &Session, crate_name: Symbol, stable_crate_id: StableCrateId) -> PathBuf {\n     let incr_dir = sess.opts.incremental.as_ref().unwrap().clone();\n \n     let stable_crate_id = base_n::encode(stable_crate_id.to_u64() as u128, INT_ENCODE_BASE);"}, {"sha": "980a17e41e13f0909df8526f53cb63362ca4483a", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 112, "deletions": 79, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -80,6 +80,7 @@ use rustc_middle::ty::{\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::{ControlFlow, Deref};\n+use std::path::PathBuf;\n use std::{cmp, fmt, iter};\n \n mod note;\n@@ -341,7 +342,15 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n \n impl<'tcx> InferCtxt<'tcx> {\n     pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-        let ty::Opaque(def_id, substs) = *ty.kind() else { return None; };\n+        let (def_id, substs) = match *ty.kind() {\n+            ty::Opaque(def_id, substs) => (def_id, substs),\n+            ty::Projection(data)\n+                if self.tcx.def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            {\n+                (data.item_def_id, data.substs)\n+            }\n+            _ => return None,\n+        };\n \n         let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n         let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n@@ -1344,10 +1353,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                             .map(|(mod_str, _)| mod_str.len() + separator_len)\n                             .sum();\n \n-                    debug!(\n-                        \"cmp: separator_len={}, split_idx={}, min_len={}\",\n-                        separator_len, split_idx, min_len\n-                    );\n+                    debug!(?separator_len, ?split_idx, ?min_len, \"cmp\");\n \n                     if split_idx >= min_len {\n                         // paths are identical, highlight everything\n@@ -1358,7 +1364,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     } else {\n                         let (common, uniq1) = t1_str.split_at(split_idx);\n                         let (_, uniq2) = t2_str.split_at(split_idx);\n-                        debug!(\"cmp: common={}, uniq1={}, uniq2={}\", common, uniq1, uniq2);\n+                        debug!(?common, ?uniq1, ?uniq2, \"cmp\");\n \n                         values.0.push_normal(common);\n                         values.0.push_highlighted(uniq1);\n@@ -1651,17 +1657,14 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     }\n                     ValuePairs::Regions(_) => (false, Mismatch::Fixed(\"lifetime\")),\n                 };\n-                let vals = match self.values_str(values) {\n-                    Some((expected, found)) => Some((expected, found)),\n-                    None => {\n-                        // Derived error. Cancel the emitter.\n-                        // NOTE(eddyb) this was `.cancel()`, but `diag`\n-                        // is borrowed, so we can't fully defuse it.\n-                        diag.downgrade_to_delayed_bug();\n-                        return;\n-                    }\n+                let Some(vals) = self.values_str(values) else {\n+                    // Derived error. Cancel the emitter.\n+                    // NOTE(eddyb) this was `.cancel()`, but `diag`\n+                    // is borrowed, so we can't fully defuse it.\n+                    diag.downgrade_to_delayed_bug();\n+                    return;\n                 };\n-                (vals, exp_found, is_simple_error, Some(values))\n+                (Some(vals), exp_found, is_simple_error, Some(values))\n             }\n         };\n \n@@ -1693,7 +1696,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             label_or_note(span, &terr.to_string());\n         }\n \n-        if let Some((expected, found)) = expected_found {\n+        if let Some((expected, found, exp_p, found_p)) = expected_found {\n             let (expected_label, found_label, exp_found) = match exp_found {\n                 Mismatch::Variable(ef) => (\n                     ef.expected.prefix_string(self.tcx),\n@@ -1810,32 +1813,41 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 }\n                 TypeError::Sorts(values) => {\n                     let extra = expected == found;\n-                    let sort_string = |ty: Ty<'tcx>| match (extra, ty.kind()) {\n-                        (true, ty::Opaque(def_id, _)) => {\n-                            let sm = self.tcx.sess.source_map();\n-                            let pos = sm.lookup_char_pos(self.tcx.def_span(*def_id).lo());\n-                            format!(\n-                                \" (opaque type at <{}:{}:{}>)\",\n-                                sm.filename_for_diagnostics(&pos.file.name),\n-                                pos.line,\n-                                pos.col.to_usize() + 1,\n-                            )\n-                        }\n-                        (true, ty::Projection(proj))\n-                            if self.tcx.def_kind(proj.item_def_id)\n-                                == DefKind::ImplTraitPlaceholder =>\n-                        {\n-                            let sm = self.tcx.sess.source_map();\n-                            let pos = sm.lookup_char_pos(self.tcx.def_span(proj.item_def_id).lo());\n-                            format!(\n-                                \" (trait associated opaque type at <{}:{}:{}>)\",\n-                                sm.filename_for_diagnostics(&pos.file.name),\n-                                pos.line,\n-                                pos.col.to_usize() + 1,\n-                            )\n+                    let sort_string = |ty: Ty<'tcx>, path: Option<PathBuf>| {\n+                        let mut s = match (extra, ty.kind()) {\n+                            (true, ty::Opaque(def_id, _)) => {\n+                                let sm = self.tcx.sess.source_map();\n+                                let pos = sm.lookup_char_pos(self.tcx.def_span(*def_id).lo());\n+                                format!(\n+                                    \" (opaque type at <{}:{}:{}>)\",\n+                                    sm.filename_for_diagnostics(&pos.file.name),\n+                                    pos.line,\n+                                    pos.col.to_usize() + 1,\n+                                )\n+                            }\n+                            (true, ty::Projection(proj))\n+                                if self.tcx.def_kind(proj.item_def_id)\n+                                    == DefKind::ImplTraitPlaceholder =>\n+                            {\n+                                let sm = self.tcx.sess.source_map();\n+                                let pos = sm.lookup_char_pos(self.tcx.def_span(proj.item_def_id).lo());\n+                                format!(\n+                                    \" (trait associated opaque type at <{}:{}:{}>)\",\n+                                    sm.filename_for_diagnostics(&pos.file.name),\n+                                    pos.line,\n+                                    pos.col.to_usize() + 1,\n+                                )\n+                            }\n+                            (true, _) => format!(\" ({})\", ty.sort_string(self.tcx)),\n+                            (false, _) => \"\".to_string(),\n+                        };\n+                        if let Some(path) = path {\n+                            s.push_str(&format!(\n+                                \"\\nthe full type name has been written to '{}'\",\n+                                path.display(),\n+                            ));\n                         }\n-                        (true, _) => format!(\" ({})\", ty.sort_string(self.tcx)),\n-                        (false, _) => \"\".to_string(),\n+                        s\n                     };\n                     if !(values.expected.is_simple_text() && values.found.is_simple_text())\n                         || (exp_found.map_or(false, |ef| {\n@@ -1857,8 +1869,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                             expected,\n                             &found_label,\n                             found,\n-                            &sort_string(values.expected),\n-                            &sort_string(values.found),\n+                            &sort_string(values.expected, exp_p),\n+                            &sort_string(values.found, found_p),\n                         );\n                     }\n                 }\n@@ -2331,7 +2343,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 let code = trace.cause.code();\n                 if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n                     && let hir::MatchSource::TryDesugar = source\n-                    && let Some((expected_ty, found_ty)) = self.values_str(trace.values)\n+                    && let Some((expected_ty, found_ty, _, _)) = self.values_str(trace.values)\n                 {\n                     err.note(&format!(\n                         \"`?` operator cannot convert from `{}` to `{}`\",\n@@ -2447,7 +2459,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     fn values_str(\n         &self,\n         values: ValuePairs<'tcx>,\n-    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString, Option<PathBuf>, Option<PathBuf>)>\n+    {\n         match values {\n             infer::Regions(exp_found) => self.expected_found_str(exp_found),\n             infer::Terms(exp_found) => self.expected_found_str_term(exp_found),\n@@ -2457,7 +2470,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     found: exp_found.found.print_only_trait_path(),\n                 };\n                 match self.expected_found_str(pretty_exp_found) {\n-                    Some((expected, found)) if expected == found => {\n+                    Some((expected, found, _, _)) if expected == found => {\n                         self.expected_found_str(exp_found)\n                     }\n                     ret => ret,\n@@ -2469,7 +2482,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     found: exp_found.found.print_only_trait_path(),\n                 };\n                 match self.expected_found_str(pretty_exp_found) {\n-                    Some((expected, found)) if expected == found => {\n+                    Some((expected, found, _, _)) if expected == found => {\n                         self.expected_found_str(exp_found)\n                     }\n                     ret => ret,\n@@ -2481,17 +2494,41 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     fn expected_found_str_term(\n         &self,\n         exp_found: ty::error::ExpectedFound<ty::Term<'tcx>>,\n-    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString, Option<PathBuf>, Option<PathBuf>)>\n+    {\n         let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n \n         Some(match (exp_found.expected.unpack(), exp_found.found.unpack()) {\n-            (ty::TermKind::Ty(expected), ty::TermKind::Ty(found)) => self.cmp(expected, found),\n+            (ty::TermKind::Ty(expected), ty::TermKind::Ty(found)) => {\n+                let (mut exp, mut fnd) = self.cmp(expected, found);\n+                // Use the terminal width as the basis to determine when to compress the printed\n+                // out type, but give ourselves some leeway to avoid ending up creating a file for\n+                // a type that is somewhat shorter than the path we'd write to.\n+                let len = self.tcx.sess().diagnostic_width() + 40;\n+                let exp_s = exp.content();\n+                let fnd_s = fnd.content();\n+                let mut exp_p = None;\n+                let mut fnd_p = None;\n+                if exp_s.len() > len {\n+                    let (exp_s, exp_path) = self.tcx.short_ty_string(expected);\n+                    exp = DiagnosticStyledString::highlighted(exp_s);\n+                    exp_p = exp_path;\n+                }\n+                if fnd_s.len() > len {\n+                    let (fnd_s, fnd_path) = self.tcx.short_ty_string(found);\n+                    fnd = DiagnosticStyledString::highlighted(fnd_s);\n+                    fnd_p = fnd_path;\n+                }\n+                (exp, fnd, exp_p, fnd_p)\n+            }\n             _ => (\n                 DiagnosticStyledString::highlighted(exp_found.expected.to_string()),\n                 DiagnosticStyledString::highlighted(exp_found.found.to_string()),\n+                None,\n+                None,\n             ),\n         })\n     }\n@@ -2500,7 +2537,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: ty::error::ExpectedFound<T>,\n-    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString, Option<PathBuf>, Option<PathBuf>)>\n+    {\n         let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n@@ -2509,6 +2547,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         Some((\n             DiagnosticStyledString::highlighted(exp_found.expected.to_string()),\n             DiagnosticStyledString::highlighted(exp_found.found.to_string()),\n+            None,\n+            None,\n         ))\n     }\n \n@@ -2842,36 +2882,29 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n         debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n \n-        if let (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) =\n-            (&sup_origin, &sub_origin)\n+        if let infer::Subtype(ref sup_trace) = sup_origin\n+            && let infer::Subtype(ref sub_trace) = sub_origin\n+            && let Some((sup_expected, sup_found, _, _)) = self.values_str(sup_trace.values)\n+            && let Some((sub_expected, sub_found, _, _)) = self.values_str(sub_trace.values)\n+            && sub_expected == sup_expected\n+            && sub_found == sup_found\n         {\n-            debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n-            debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n-            debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);\n-            debug!(\"report_sub_sup_conflict: sub_trace.values={:?}\", sub_trace.values);\n-\n-            if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) =\n-                (self.values_str(sup_trace.values), self.values_str(sub_trace.values))\n-            {\n-                if sub_expected == sup_expected && sub_found == sup_found {\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"...but the lifetime must also be valid for \",\n-                        sub_region,\n-                        \"...\",\n-                        None,\n-                    );\n-                    err.span_note(\n-                        sup_trace.cause.span,\n-                        &format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n-                    );\n+            note_and_explain_region(\n+                self.tcx,\n+                &mut err,\n+                \"...but the lifetime must also be valid for \",\n+                sub_region,\n+                \"...\",\n+                None,\n+            );\n+            err.span_note(\n+                sup_trace.cause.span,\n+                &format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n+            );\n \n-                    err.note_expected_found(&\"\", sup_expected, &\"\", sup_found);\n-                    err.emit();\n-                    return;\n-                }\n-            }\n+            err.note_expected_found(&\"\", sup_expected, &\"\", sup_found);\n+            err.emit();\n+            return;\n         }\n \n         self.note_region_origin(&mut err, &sup_origin);"}, {"sha": "d2dffa4a0b78e5ef1d75606e165b0a137fbf87e0", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -16,7 +16,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n                 span: trace.cause.span,\n                 requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n-                expected_found: self.values_str(trace.values),\n+                expected_found: self.values_str(trace.values).map(|(e, f, _, _)| (e, f)),\n             }\n             .add_to_diagnostic(err),\n             infer::Reborrow(span) => {"}, {"sha": "f808c1438bfc5b91b5b4bed4eaf5acbd7e0960b3", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -12,6 +12,7 @@ use rustc_ast::{self as ast, visit};\n use rustc_borrowck as mir_borrowck;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::parallel;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::{ErrorGuaranteed, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n@@ -157,7 +158,7 @@ pub fn create_resolver(\n     sess: Lrc<Session>,\n     metadata_loader: Box<MetadataLoaderDyn>,\n     krate: &ast::Crate,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> BoxedResolver {\n     trace!(\"create_resolver\");\n     BoxedResolver::new(sess, move |sess, resolver_arenas| {\n@@ -170,7 +171,7 @@ pub fn register_plugins<'a>(\n     metadata_loader: &'a dyn MetadataLoader,\n     register_lints: impl Fn(&Session, &mut LintStore),\n     mut krate: ast::Crate,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> Result<(ast::Crate, LintStore)> {\n     krate = sess.time(\"attributes_injection\", || {\n         rustc_builtin_macros::cmdline_attrs::inject(\n@@ -227,19 +228,21 @@ fn pre_expansion_lint<'a>(\n     lint_store: &LintStore,\n     registered_tools: &RegisteredTools,\n     check_node: impl EarlyCheckNode<'a>,\n-    node_name: &str,\n+    node_name: Symbol,\n ) {\n-    sess.prof.generic_activity_with_arg(\"pre_AST_expansion_lint_checks\", node_name).run(|| {\n-        rustc_lint::check_ast_node(\n-            sess,\n-            true,\n-            lint_store,\n-            registered_tools,\n-            None,\n-            rustc_lint::BuiltinCombinedPreExpansionLintPass::new(),\n-            check_node,\n-        );\n-    });\n+    sess.prof.generic_activity_with_arg(\"pre_AST_expansion_lint_checks\", node_name.as_str()).run(\n+        || {\n+            rustc_lint::check_ast_node(\n+                sess,\n+                true,\n+                lint_store,\n+                registered_tools,\n+                None,\n+                rustc_lint::BuiltinCombinedPreExpansionLintPass::new(),\n+                check_node,\n+            );\n+        },\n+    );\n }\n \n // Cannot implement directly for `LintStore` due to trait coherence.\n@@ -253,7 +256,7 @@ impl LintStoreExpand for LintStoreExpandImpl<'_> {\n         node_id: ast::NodeId,\n         attrs: &[ast::Attribute],\n         items: &[rustc_ast::ptr::P<ast::Item>],\n-        name: &str,\n+        name: Symbol,\n     ) {\n         pre_expansion_lint(sess, self.0, registered_tools, (node_id, attrs, items), name);\n     }\n@@ -267,7 +270,7 @@ pub fn configure_and_expand(\n     sess: &Session,\n     lint_store: &LintStore,\n     mut krate: ast::Crate,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     resolver: &mut Resolver<'_>,\n ) -> Result<ast::Crate> {\n     trace!(\"configure_and_expand\");\n@@ -461,7 +464,7 @@ fn generated_output_paths(\n     sess: &Session,\n     outputs: &OutputFilenames,\n     exact_name: bool,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> Vec<PathBuf> {\n     let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.keys() {\n@@ -660,7 +663,7 @@ pub fn prepare_outputs(\n     compiler: &Compiler,\n     krate: &ast::Crate,\n     boxed_resolver: &RefCell<BoxedResolver>,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> Result<OutputFilenames> {\n     let _timer = sess.timer(\"prepare_outputs\");\n \n@@ -770,7 +773,7 @@ pub fn create_global_ctxt<'tcx>(\n     dep_graph: DepGraph,\n     resolver: Rc<RefCell<BoxedResolver>>,\n     outputs: OutputFilenames,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     queries: &'tcx OnceCell<TcxQueries<'tcx>>,\n     global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n@@ -801,14 +804,21 @@ pub fn create_global_ctxt<'tcx>(\n         TcxQueries::new(local_providers, extern_providers, query_result_on_disk_cache)\n     });\n \n+    let ty::ResolverOutputs {\n+        definitions,\n+        global_ctxt: untracked_resolutions,\n+        ast_lowering: untracked_resolver_for_lowering,\n+    } = resolver_outputs;\n+\n     let gcx = sess.time(\"setup_global_ctxt\", || {\n         global_ctxt.get_or_init(move || {\n             TyCtxt::create_global_ctxt(\n                 sess,\n                 lint_store,\n                 arena,\n                 hir_arena,\n-                resolver_outputs,\n+                definitions,\n+                untracked_resolutions,\n                 krate,\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n@@ -820,7 +830,12 @@ pub fn create_global_ctxt<'tcx>(\n         })\n     });\n \n-    QueryContext { gcx }\n+    let mut qcx = QueryContext { gcx };\n+    qcx.enter(|tcx| {\n+        tcx.feed_unit_query()\n+            .resolver_for_lowering(tcx.arena.alloc(Steal::new(untracked_resolver_for_lowering)))\n+    });\n+    qcx\n }\n \n /// Runs the resolution, type-checking, region checking and other\n@@ -965,12 +980,10 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n pub fn start_codegen<'tcx>(\n     codegen_backend: &dyn CodegenBackend,\n     tcx: TyCtxt<'tcx>,\n-    outputs: &OutputFilenames,\n ) -> Box<dyn Any> {\n     info!(\"Pre-codegen\\n{:?}\", tcx.debug_stats());\n \n-    let (metadata, need_metadata_module) =\n-        rustc_metadata::fs::encode_and_write_metadata(tcx, outputs);\n+    let (metadata, need_metadata_module) = rustc_metadata::fs::encode_and_write_metadata(tcx);\n \n     let codegen = tcx.sess.time(\"codegen_crate\", move || {\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n@@ -986,7 +999,7 @@ pub fn start_codegen<'tcx>(\n     info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n-        if let Err(error) = rustc_mir_transform::dump_mir::emit_mir(tcx, outputs) {\n+        if let Err(error) = rustc_mir_transform::dump_mir::emit_mir(tcx) {\n             tcx.sess.emit_err(CantEmitMIR { error });\n             tcx.sess.abort_if_errors();\n         }"}, {"sha": "39e1f2204b002010176277dadfb531098f096730", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -17,9 +17,11 @@ use rustc_query_impl::Queries as TcxQueries;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;\n+use rustc_span::Symbol;\n use std::any::Any;\n use std::cell::{Ref, RefCell, RefMut};\n use std::rc::Rc;\n+use std::sync::Arc;\n \n /// Represent the result of a query.\n ///\n@@ -73,7 +75,7 @@ pub struct Queries<'tcx> {\n \n     dep_graph_future: Query<Option<DepGraphFuture>>,\n     parse: Query<ast::Crate>,\n-    crate_name: Query<String>,\n+    crate_name: Query<Symbol>,\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n     expansion: Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n@@ -134,7 +136,7 @@ impl<'tcx> Queries<'tcx> {\n                 &*self.codegen_backend().metadata_loader(),\n                 self.compiler.register_lints.as_deref().unwrap_or_else(|| empty),\n                 krate,\n-                &crate_name,\n+                crate_name,\n             )?;\n \n             // Compute the dependency graph (in the background). We want to do\n@@ -148,7 +150,7 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn crate_name(&self) -> Result<&Query<String>> {\n+    pub fn crate_name(&self) -> Result<&Query<Symbol>> {\n         self.crate_name.compute(|| {\n             Ok({\n                 let parse_result = self.parse()?;\n@@ -164,18 +166,18 @@ impl<'tcx> Queries<'tcx> {\n     ) -> Result<&Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>> {\n         trace!(\"expansion\");\n         self.expansion.compute(|| {\n-            let crate_name = self.crate_name()?.peek().clone();\n+            let crate_name = *self.crate_name()?.peek();\n             let (krate, lint_store) = self.register_plugins()?.take();\n             let _timer = self.session().timer(\"configure_and_expand\");\n             let sess = self.session();\n             let mut resolver = passes::create_resolver(\n                 sess.clone(),\n                 self.codegen_backend().metadata_loader(),\n                 &krate,\n-                &crate_name,\n+                crate_name,\n             );\n             let krate = resolver.access(|resolver| {\n-                passes::configure_and_expand(sess, &lint_store, krate, &crate_name, resolver)\n+                passes::configure_and_expand(sess, &lint_store, krate, crate_name, resolver)\n             })?;\n             Ok((Lrc::new(krate), Rc::new(RefCell::new(resolver)), lint_store))\n         })\n@@ -200,21 +202,21 @@ impl<'tcx> Queries<'tcx> {\n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n         self.prepare_outputs.compute(|| {\n             let (krate, boxed_resolver, _) = &*self.expansion()?.peek();\n-            let crate_name = self.crate_name()?.peek();\n+            let crate_name = *self.crate_name()?.peek();\n             passes::prepare_outputs(\n                 self.session(),\n                 self.compiler,\n                 krate,\n                 &*boxed_resolver,\n-                &crate_name,\n+                crate_name,\n             )\n         })\n     }\n \n     pub fn global_ctxt(&'tcx self) -> Result<&Query<QueryContext<'tcx>>> {\n         self.global_ctxt.compute(|| {\n-            let crate_name = self.crate_name()?.peek().clone();\n-            let outputs = self.prepare_outputs()?.peek().clone();\n+            let crate_name = *self.crate_name()?.peek();\n+            let outputs = self.prepare_outputs()?.take();\n             let dep_graph = self.dep_graph()?.peek().clone();\n             let (krate, resolver, lint_store) = self.expansion()?.take();\n             Ok(passes::create_global_ctxt(\n@@ -224,7 +226,7 @@ impl<'tcx> Queries<'tcx> {\n                 dep_graph,\n                 resolver,\n                 outputs,\n-                &crate_name,\n+                crate_name,\n                 &self.queries,\n                 &self.gcx,\n                 &self.arena,\n@@ -235,7 +237,6 @@ impl<'tcx> Queries<'tcx> {\n \n     pub fn ongoing_codegen(&'tcx self) -> Result<&Query<Box<dyn Any>>> {\n         self.ongoing_codegen.compute(|| {\n-            let outputs = self.prepare_outputs()?;\n             self.global_ctxt()?.peek_mut().enter(|tcx| {\n                 tcx.analysis(()).ok();\n \n@@ -249,7 +250,7 @@ impl<'tcx> Queries<'tcx> {\n                 // Hook for UI tests.\n                 Self::check_for_rustc_errors_attr(tcx);\n \n-                Ok(passes::start_codegen(&***self.codegen_backend(), tcx, &*outputs.peek()))\n+                Ok(passes::start_codegen(&***self.codegen_backend(), tcx))\n             })\n         })\n     }\n@@ -293,8 +294,10 @@ impl<'tcx> Queries<'tcx> {\n         let codegen_backend = self.codegen_backend().clone();\n \n         let dep_graph = self.dep_graph()?.peek().clone();\n-        let prepare_outputs = self.prepare_outputs()?.take();\n-        let crate_hash = self.global_ctxt()?.peek_mut().enter(|tcx| tcx.crate_hash(LOCAL_CRATE));\n+        let (crate_hash, prepare_outputs) = self\n+            .global_ctxt()?\n+            .peek_mut()\n+            .enter(|tcx| (tcx.crate_hash(LOCAL_CRATE), tcx.output_filenames(()).clone()));\n         let ongoing_codegen = self.ongoing_codegen()?.take();\n \n         Ok(Linker {\n@@ -316,7 +319,7 @@ pub struct Linker {\n \n     // compilation outputs\n     dep_graph: DepGraph,\n-    prepare_outputs: OutputFilenames,\n+    prepare_outputs: Arc<OutputFilenames>,\n     crate_hash: Svh,\n     ongoing_codegen: Box<dyn Any>,\n }"}, {"sha": "2b8f6557c829b32042879be2c525ed09e4fbef8f", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -747,6 +747,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(link_only, true);\n     tracked!(llvm_plugins, vec![String::from(\"plugin_name\")]);\n     tracked!(location_detail, LocationDetail { file: true, line: false, column: false });\n+    tracked!(maximal_hir_to_mir_coverage, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));\n     tracked!(mir_emit_retag, true);\n     tracked!(mir_enable_passes, vec![(\"DestProp\".to_string(), false)]);"}, {"sha": "d0d34d8d2b40ee23be061701dc4bf7926d070f32", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -259,7 +259,7 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                 }\n                 if let PatKind::Binding(binding_annot, _, ident, None) = fieldpat.pat.kind {\n                     if cx.tcx.find_field_index(ident, &variant)\n-                        == Some(cx.tcx.field_index(fieldpat.hir_id, cx.typeck_results()))\n+                        == Some(cx.typeck_results().field_index(fieldpat.hir_id))\n                     {\n                         cx.struct_span_lint(\n                             NON_SHORTHAND_FIELD_PATTERNS,"}, {"sha": "52363b0be2db90fc51eb062847498a0ce8745be9", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 42, "deletions": 65, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -20,21 +20,23 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::{self as ast_visit, Visitor};\n use rustc_ast::{self as ast, walk_list, HasAttrs};\n use rustc_middle::ty::RegisteredTools;\n-use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n+use rustc_session::lint::{BufferedEarlyLint, LintBuffer};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    $cx.pass.$f(&$cx.context, $($args),*);\n+macro_rules! run_early_passes { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    for pass in $cx.passes.iter_mut() {\n+        pass.$f(&$cx.context, $($args),*);\n+    }\n }) }\n \n-pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n+pub struct EarlyContextAndPasses<'a> {\n     context: EarlyContext<'a>,\n-    pass: T,\n+    passes: Vec<EarlyLintPassObject>,\n }\n \n-impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n+impl<'a> EarlyContextAndPasses<'a> {\n     fn check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.context.buffered.take(id) {\n             let BufferedEarlyLint { span, msg, node_id: _, lint_id, diagnostic } = early_lint;\n@@ -61,27 +63,27 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n \n         self.check_id(id);\n         debug!(\"early context: enter_attrs({:?})\", attrs);\n-        run_early_pass!(self, enter_lint_attrs, attrs);\n+        run_early_passes!(self, enter_lint_attrs, attrs);\n         f(self);\n         debug!(\"early context: exit_attrs({:?})\", attrs);\n-        run_early_pass!(self, exit_lint_attrs, attrs);\n+        run_early_passes!(self, exit_lint_attrs, attrs);\n         self.context.builder.pop(push);\n     }\n }\n \n-impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n+impl<'a> ast_visit::Visitor<'a> for EarlyContextAndPasses<'a> {\n     fn visit_param(&mut self, param: &'a ast::Param) {\n         self.with_lint_attrs(param.id, &param.attrs, |cx| {\n-            run_early_pass!(cx, check_param, param);\n+            run_early_passes!(cx, check_param, param);\n             ast_visit::walk_param(cx, param);\n         });\n     }\n \n     fn visit_item(&mut self, it: &'a ast::Item) {\n         self.with_lint_attrs(it.id, &it.attrs, |cx| {\n-            run_early_pass!(cx, check_item, it);\n+            run_early_passes!(cx, check_item, it);\n             ast_visit::walk_item(cx, it);\n-            run_early_pass!(cx, check_item_post, it);\n+            run_early_passes!(cx, check_item_post, it);\n         })\n     }\n \n@@ -92,10 +94,10 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n-        run_early_pass!(self, check_pat, p);\n+        run_early_passes!(self, check_pat, p);\n         self.check_id(p.id);\n         ast_visit::walk_pat(self, p);\n-        run_early_pass!(self, check_pat_post, p);\n+        run_early_passes!(self, check_pat_post, p);\n     }\n \n     fn visit_pat_field(&mut self, field: &'a ast::PatField) {\n@@ -111,7 +113,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         self.with_lint_attrs(e.id, &e.attrs, |cx| {\n-            run_early_pass!(cx, check_expr, e);\n+            run_early_passes!(cx, check_expr, e);\n             ast_visit::walk_expr(cx, e);\n         })\n     }\n@@ -132,7 +134,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         // Note that statements get their attributes from\n         // the AST struct that they wrap (e.g. an item)\n         self.with_lint_attrs(s.id, s.attrs(), |cx| {\n-            run_early_pass!(cx, check_stmt, s);\n+            run_early_passes!(cx, check_stmt, s);\n             cx.check_id(s.id);\n         });\n         // The visitor for the AST struct wrapped\n@@ -143,7 +145,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_fn(&mut self, fk: ast_visit::FnKind<'a>, span: Span, id: ast::NodeId) {\n-        run_early_pass!(self, check_fn, fk, span, id);\n+        run_early_passes!(self, check_fn, fk, span, id);\n         self.check_id(id);\n         ast_visit::walk_fn(self, fk);\n \n@@ -171,37 +173,37 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n \n     fn visit_variant(&mut self, v: &'a ast::Variant) {\n         self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            run_early_pass!(cx, check_variant, v);\n+            run_early_passes!(cx, check_variant, v);\n             ast_visit::walk_variant(cx, v);\n         })\n     }\n \n     fn visit_ty(&mut self, t: &'a ast::Ty) {\n-        run_early_pass!(self, check_ty, t);\n+        run_early_passes!(self, check_ty, t);\n         self.check_id(t.id);\n         ast_visit::walk_ty(self, t);\n     }\n \n     fn visit_ident(&mut self, ident: Ident) {\n-        run_early_pass!(self, check_ident, ident);\n+        run_early_passes!(self, check_ident, ident);\n     }\n \n     fn visit_local(&mut self, l: &'a ast::Local) {\n         self.with_lint_attrs(l.id, &l.attrs, |cx| {\n-            run_early_pass!(cx, check_local, l);\n+            run_early_passes!(cx, check_local, l);\n             ast_visit::walk_local(cx, l);\n         })\n     }\n \n     fn visit_block(&mut self, b: &'a ast::Block) {\n-        run_early_pass!(self, check_block, b);\n+        run_early_passes!(self, check_block, b);\n         self.check_id(b.id);\n         ast_visit::walk_block(self, b);\n     }\n \n     fn visit_arm(&mut self, a: &'a ast::Arm) {\n         self.with_lint_attrs(a.id, &a.attrs, |cx| {\n-            run_early_pass!(cx, check_arm, a);\n+            run_early_passes!(cx, check_arm, a);\n             ast_visit::walk_arm(cx, a);\n         })\n     }\n@@ -220,19 +222,19 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_generic_arg(&mut self, arg: &'a ast::GenericArg) {\n-        run_early_pass!(self, check_generic_arg, arg);\n+        run_early_passes!(self, check_generic_arg, arg);\n         ast_visit::walk_generic_arg(self, arg);\n     }\n \n     fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n         self.with_lint_attrs(param.id, &param.attrs, |cx| {\n-            run_early_pass!(cx, check_generic_param, param);\n+            run_early_passes!(cx, check_generic_param, param);\n             ast_visit::walk_generic_param(cx, param);\n         });\n     }\n \n     fn visit_generics(&mut self, g: &'a ast::Generics) {\n-        run_early_pass!(self, check_generics, g);\n+        run_early_passes!(self, check_generics, g);\n         ast_visit::walk_generics(self, g);\n     }\n \n@@ -241,18 +243,18 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef) {\n-        run_early_pass!(self, check_poly_trait_ref, t);\n+        run_early_passes!(self, check_poly_trait_ref, t);\n         ast_visit::walk_poly_trait_ref(self, t);\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a ast::AssocItem, ctxt: ast_visit::AssocCtxt) {\n         self.with_lint_attrs(item.id, &item.attrs, |cx| match ctxt {\n             ast_visit::AssocCtxt::Trait => {\n-                run_early_pass!(cx, check_trait_item, item);\n+                run_early_passes!(cx, check_trait_item, item);\n                 ast_visit::walk_assoc_item(cx, item, ctxt);\n             }\n             ast_visit::AssocCtxt::Impl => {\n-                run_early_pass!(cx, check_impl_item, item);\n+                run_early_passes!(cx, check_impl_item, item);\n                 ast_visit::walk_assoc_item(cx, item, ctxt);\n             }\n         });\n@@ -273,53 +275,28 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n-        run_early_pass!(self, check_attribute, attr);\n+        run_early_passes!(self, check_attribute, attr);\n     }\n \n     fn visit_mac_def(&mut self, mac: &'a ast::MacroDef, id: ast::NodeId) {\n-        run_early_pass!(self, check_mac_def, mac);\n+        run_early_passes!(self, check_mac_def, mac);\n         self.check_id(id);\n     }\n \n     fn visit_mac_call(&mut self, mac: &'a ast::MacCall) {\n-        run_early_pass!(self, check_mac, mac);\n+        run_early_passes!(self, check_mac, mac);\n         ast_visit::walk_mac(self, mac);\n     }\n }\n \n-struct EarlyLintPassObjects<'a> {\n-    lints: &'a mut [EarlyLintPassObject],\n-}\n-\n-#[allow(rustc::lint_pass_impl_without_macro)]\n-impl LintPass for EarlyLintPassObjects<'_> {\n-    fn name(&self) -> &'static str {\n-        panic!()\n-    }\n-}\n-\n-macro_rules! early_lint_pass_impl {\n-    ([], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        impl EarlyLintPass for EarlyLintPassObjects<'_> {\n-            $(fn $name(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n-                for obj in self.lints.iter_mut() {\n-                    obj.$name(context, $($param),*);\n-                }\n-            })*\n-        }\n-    )\n-}\n-\n-crate::early_lint_methods!(early_lint_pass_impl, []);\n-\n /// Early lints work on different nodes - either on the crate root, or on freshly loaded modules.\n /// This trait generalizes over those nodes.\n pub trait EarlyCheckNode<'a>: Copy {\n     fn id(self) -> ast::NodeId;\n     fn attrs<'b>(self) -> &'b [ast::Attribute]\n     where\n         'a: 'b;\n-    fn check<'b>(self, cx: &mut EarlyContextAndPass<'b, impl EarlyLintPass>)\n+    fn check<'b>(self, cx: &mut EarlyContextAndPasses<'b>)\n     where\n         'a: 'b;\n }\n@@ -334,13 +311,13 @@ impl<'a> EarlyCheckNode<'a> for &'a ast::Crate {\n     {\n         &self.attrs\n     }\n-    fn check<'b>(self, cx: &mut EarlyContextAndPass<'b, impl EarlyLintPass>)\n+    fn check<'b>(self, cx: &mut EarlyContextAndPasses<'b>)\n     where\n         'a: 'b,\n     {\n-        run_early_pass!(cx, check_crate, self);\n+        run_early_passes!(cx, check_crate, self);\n         ast_visit::walk_crate(cx, self);\n-        run_early_pass!(cx, check_crate_post, self);\n+        run_early_passes!(cx, check_crate_post, self);\n     }\n }\n \n@@ -354,7 +331,7 @@ impl<'a> EarlyCheckNode<'a> for (ast::NodeId, &'a [ast::Attribute], &'a [P<ast::\n     {\n         self.1\n     }\n-    fn check<'b>(self, cx: &mut EarlyContextAndPass<'b, impl EarlyLintPass>)\n+    fn check<'b>(self, cx: &mut EarlyContextAndPasses<'b>)\n     where\n         'a: 'b,\n     {\n@@ -374,18 +351,18 @@ pub fn check_ast_node<'a>(\n ) {\n     let passes =\n         if pre_expansion { &lint_store.pre_expansion_passes } else { &lint_store.early_passes };\n-    let mut passes: Vec<_> = passes.iter().map(|p| (p)()).collect();\n+    let mut passes: Vec<EarlyLintPassObject> = passes.iter().map(|p| (p)()).collect();\n     passes.push(Box::new(builtin_lints));\n \n-    let mut cx = EarlyContextAndPass {\n+    let mut cx = EarlyContextAndPasses {\n         context: EarlyContext::new(\n             sess,\n             !pre_expansion,\n             lint_store,\n             registered_tools,\n             lint_buffer.unwrap_or_default(),\n         ),\n-        pass: EarlyLintPassObjects { lints: &mut passes[..] },\n+        passes,\n     };\n     cx.with_lint_attrs(check_node.id(), check_node.attrs(), |cx| check_node.check(cx));\n "}, {"sha": "8a50cb1f19ef5821b843911f5d1b65d06a152344", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -23,7 +23,6 @@ use rustc_hir::intravisit as hir_visit;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::lint::LintPass;\n use rustc_span::Span;\n \n use std::any::Any;\n@@ -37,15 +36,17 @@ pub fn unerased_lint_store(tcx: TyCtxt<'_>) -> &LintStore {\n }\n \n macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    $cx.pass.$f(&$cx.context, $($args),*);\n+    for pass in $cx.passes.iter_mut() {\n+        pass.$f(&$cx.context, $($args),*);\n+    }\n }) }\n \n-struct LateContextAndPass<'tcx, T: LateLintPass<'tcx>> {\n+struct LateContextAndPasses<'tcx> {\n     context: LateContext<'tcx>,\n-    pass: T,\n+    passes: Vec<LateLintPassObject<'tcx>>,\n }\n \n-impl<'tcx, T: LateLintPass<'tcx>> LateContextAndPass<'tcx, T> {\n+impl<'tcx> LateContextAndPasses<'tcx> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n@@ -81,7 +82,7 @@ impl<'tcx, T: LateLintPass<'tcx>> LateContextAndPass<'tcx, T> {\n     }\n }\n \n-impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPass<'tcx, T> {\n+impl<'tcx> hir_visit::Visitor<'tcx> for LateContextAndPasses<'tcx> {\n     type NestedFilter = nested_filter::All;\n \n     /// Because lints are scoped lexically, we want to walk nested\n@@ -301,31 +302,6 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n }\n \n-struct LateLintPassObjects<'a, 'tcx> {\n-    lints: &'a mut [LateLintPassObject<'tcx>],\n-}\n-\n-#[allow(rustc::lint_pass_impl_without_macro)]\n-impl LintPass for LateLintPassObjects<'_, '_> {\n-    fn name(&self) -> &'static str {\n-        panic!()\n-    }\n-}\n-\n-macro_rules! late_lint_pass_impl {\n-    ([], [$hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => {\n-        impl<$hir> LateLintPass<$hir> for LateLintPassObjects<'_, $hir> {\n-            $(fn $name(&mut self, context: &LateContext<$hir>, $($param: $arg),*) {\n-                for obj in self.lints.iter_mut() {\n-                    obj.$name(context, $($param),*);\n-                }\n-            })*\n-        }\n-    };\n-}\n-\n-crate::late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n-\n pub(super) fn late_lint_mod<'tcx, T: LateLintPass<'tcx> + 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     module_def_id: LocalDefId,\n@@ -346,9 +322,8 @@ pub(super) fn late_lint_mod<'tcx, T: LateLintPass<'tcx> + 'tcx>(\n     let mut passes: Vec<_> =\n         unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)(tcx)).collect();\n     passes.push(Box::new(builtin_lints));\n-    let pass = LateLintPassObjects { lints: &mut passes[..] };\n \n-    let mut cx = LateContextAndPass { context, pass };\n+    let mut cx = LateContextAndPasses { context, passes };\n \n     let (module, _span, hir_id) = tcx.hir().get_module(module_def_id);\n     cx.process_mod(module, hir_id);\n@@ -377,9 +352,8 @@ fn late_lint_crate<'tcx, T: LateLintPass<'tcx> + 'tcx>(tcx: TyCtxt<'tcx>, builti\n     let mut passes =\n         unerased_lint_store(tcx).late_passes.iter().map(|p| (p)(tcx)).collect::<Vec<_>>();\n     passes.push(Box::new(builtin_lints));\n-    let pass = LateLintPassObjects { lints: &mut passes[..] };\n \n-    let mut cx = LateContextAndPass { context, pass };\n+    let mut cx = LateContextAndPasses { context, passes };\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(hir::CRATE_HIR_ID, |cx| {"}, {"sha": "0fa81b7e4e0bc20f2c644783199734475e474359", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -10,7 +10,7 @@ declare_tool_lint! {\n     /// The `rustc_pass_by_value` lint marks a type with `#[rustc_pass_by_value]` requiring it to\n     /// always be passed by value. This is usually used for types that are thin wrappers around\n     /// references, so there is no benefit to an extra layer of indirection. (Example: `Ty` which\n-    /// is a reference to an `Interned<TyS>`)\n+    /// is a reference to an `Interned<TyKind>`)\n     pub rustc::PASS_BY_VALUE,\n     Warn,\n     \"pass by reference of a type flagged as `#[rustc_pass_by_value]`\","}, {"sha": "b5db94f8c0684b3235fa92972c5f453df2c71c6f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -633,13 +633,34 @@ trait UnusedDelimLint {\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n     ) {\n+        // If `value` has `ExprKind::Err`, unused delim lint can be broken.\n+        // For example, the following code caused ICE.\n+        // This is because the `ExprKind::Call` in `value` has `ExprKind::Err` as its argument\n+        // and this leads to wrong spans. #104897\n+        //\n+        // ```\n+        // fn f(){(print!(\u00e1\n+        // ```\n+        use rustc_ast::visit::{walk_expr, Visitor};\n+        struct ErrExprVisitor {\n+            has_error: bool,\n+        }\n+        impl<'ast> Visitor<'ast> for ErrExprVisitor {\n+            fn visit_expr(&mut self, expr: &'ast ast::Expr) {\n+                if let ExprKind::Err = expr.kind {\n+                    self.has_error = true;\n+                    return;\n+                }\n+                walk_expr(self, expr)\n+            }\n+        }\n+        let mut visitor = ErrExprVisitor { has_error: false };\n+        visitor.visit_expr(value);\n+        if visitor.has_error {\n+            return;\n+        }\n         let spans = match value.kind {\n             ast::ExprKind::Block(ref block, None) if block.stmts.len() == 1 => {\n-                if let StmtKind::Expr(expr) = &block.stmts[0].kind\n-                    && let ExprKind::Err = expr.kind\n-                {\n-                    return\n-                }\n                 if let Some(span) = block.stmts[0].span.find_ancestor_inside(value.span) {\n                     Some((value.span.with_hi(span.lo()), value.span.with_lo(span.hi())))\n                 } else {"}, {"sha": "1a3d458c30067cfce22e11625a5c9e5fa9ccaf53", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -205,7 +205,12 @@ enum class LLVMRustCodeModel {\n   None,\n };\n \n-static Optional<CodeModel::Model> fromRust(LLVMRustCodeModel Model) {\n+#if LLVM_VERSION_LT(16, 0)\n+static Optional<CodeModel::Model>\n+#else\n+static std::optional<CodeModel::Model>\n+#endif\n+fromRust(LLVMRustCodeModel Model) {\n   switch (Model) {\n   case LLVMRustCodeModel::Tiny:\n     return CodeModel::Tiny;\n@@ -638,7 +643,11 @@ LLVMRustOptimize(\n     LLVMSelfProfileInitializeCallbacks(PIC,LlvmSelfProfiler,BeforePassCallback,AfterPassCallback);\n   }\n \n+#if LLVM_VERSION_LT(16, 0)\n   Optional<PGOOptions> PGOOpt;\n+#else\n+  std::optional<PGOOptions> PGOOpt;\n+#endif\n   if (PGOGenPath) {\n     assert(!PGOUsePath && !PGOSampleUsePath);\n     PGOOpt = PGOOptions(PGOGenPath, \"\", \"\", PGOOptions::IRInstr,"}, {"sha": "3a748f38995bbc77bf8102379e227ab4a922d2f4", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -17,7 +17,9 @@\n #include \"llvm/Pass.h\"\n #include \"llvm/Bitcode/BitcodeWriter.h\"\n #include \"llvm/Support/Signals.h\"\n+#if LLVM_VERSION_LT(16, 0)\n #include \"llvm/ADT/Optional.h\"\n+#endif\n \n #include <iostream>\n \n@@ -708,7 +710,11 @@ enum class LLVMRustChecksumKind {\n   SHA256,\n };\n \n+#if LLVM_VERSION_LT(16, 0)\n static Optional<DIFile::ChecksumKind> fromRust(LLVMRustChecksumKind Kind) {\n+#else\n+static std::optional<DIFile::ChecksumKind> fromRust(LLVMRustChecksumKind Kind) {\n+#endif\n   switch (Kind) {\n   case LLVMRustChecksumKind::None:\n     return None;\n@@ -787,8 +793,18 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFile(\n     const char *Filename, size_t FilenameLen,\n     const char *Directory, size_t DirectoryLen, LLVMRustChecksumKind CSKind,\n     const char *Checksum, size_t ChecksumLen) {\n+\n+#if LLVM_VERSION_LT(16, 0)\n   Optional<DIFile::ChecksumKind> llvmCSKind = fromRust(CSKind);\n+#else\n+  std::optional<DIFile::ChecksumKind> llvmCSKind = fromRust(CSKind);\n+#endif\n+\n+#if LLVM_VERSION_LT(16, 0)\n   Optional<DIFile::ChecksumInfo<StringRef>> CSInfo{};\n+#else\n+  std::optional<DIFile::ChecksumInfo<StringRef>> CSInfo{};\n+#endif\n   if (llvmCSKind)\n     CSInfo.emplace(*llvmCSKind, StringRef{Checksum, ChecksumLen});\n   return wrap(Builder->createFile(StringRef(Filename, FilenameLen),"}, {"sha": "789d83a0dd00d496f39eeee157d924d6f3cfd31b", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -364,10 +364,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 modifiers.eval_always.is_none(),\n                 \"Query {name} cannot be both `feedable` and `eval_always`.\"\n             );\n-            assert!(\n-                modifiers.no_hash.is_none(),\n-                \"Query {name} cannot be both `feedable` and `no_hash`.\"\n-            );\n             feedable_queries.extend(quote! {\n                 #(#doc_comments)*\n                 [#attribute_stream] fn #name(#arg) #result,"}, {"sha": "efeaac8fe9a0f8523c1861ae8dd6fb6160af091b", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -245,15 +245,15 @@ impl<'a> CrateLoader<'a> {\n     pub fn new(\n         sess: &'a Session,\n         metadata_loader: Box<MetadataLoaderDyn>,\n-        local_crate_name: &str,\n+        local_crate_name: Symbol,\n     ) -> Self {\n         let mut stable_crate_ids = FxHashMap::default();\n         stable_crate_ids.insert(sess.local_stable_crate_id(), LOCAL_CRATE);\n \n         CrateLoader {\n             sess,\n             metadata_loader,\n-            local_crate_name: Symbol::intern(local_crate_name),\n+            local_crate_name,\n             cstore: CStore {\n                 // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n                 // order to make array indices in `metas` match with the\n@@ -1000,7 +1000,7 @@ impl<'a> CrateLoader<'a> {\n                 );\n                 let name = match orig_name {\n                     Some(orig_name) => {\n-                        validate_crate_name(self.sess, orig_name.as_str(), Some(item.span));\n+                        validate_crate_name(self.sess, orig_name, Some(item.span));\n                         orig_name\n                     }\n                     None => item.ident.name,"}, {"sha": "7601f6bd3221efaae15ef9b76f4c54366cd9628c", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -6,7 +6,7 @@ use crate::{encode_metadata, EncodedMetadata};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{CrateType, OutputFilenames, OutputType};\n+use rustc_session::config::{CrateType, OutputType};\n use rustc_session::output::filename_for_metadata;\n use rustc_session::Session;\n use tempfile::Builder as TempFileBuilder;\n@@ -38,10 +38,7 @@ pub fn emit_wrapper_file(\n     out_filename\n }\n \n-pub fn encode_and_write_metadata(\n-    tcx: TyCtxt<'_>,\n-    outputs: &OutputFilenames,\n-) -> (EncodedMetadata, bool) {\n+pub fn encode_and_write_metadata(tcx: TyCtxt<'_>) -> (EncodedMetadata, bool) {\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n     enum MetadataKind {\n         None,\n@@ -64,7 +61,7 @@ pub fn encode_and_write_metadata(\n         .unwrap_or(MetadataKind::None);\n \n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    let out_filename = filename_for_metadata(tcx.sess, crate_name.as_str(), outputs);\n+    let out_filename = filename_for_metadata(tcx.sess, crate_name, tcx.output_filenames(()));\n     // To avoid races with another rustc process scanning the output directory,\n     // we need to write the file somewhere else and atomically move it to its\n     // final destination, with an `fs::rename` call. In order for the rename to"}, {"sha": "6de68841fe91f41fa84faa97f77ce3448350d9e9", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,3 +1,5 @@\n+#![allow(rustc::usage_of_ty_tykind)]\n+\n /// This higher-order macro declares a list of types which can be allocated by `Arena`.\n ///\n /// Specifying the `decode` modifier will add decode impls for `&T` and `&[T]` where `T` is the type\n@@ -28,6 +30,7 @@ macro_rules! arena_types {\n             [decode] typeck_results: rustc_middle::ty::TypeckResults<'tcx>,\n             [decode] borrowck_result:\n                 rustc_middle::mir::BorrowCheckResult<'tcx>,\n+            [] resolver: rustc_data_structures::steal::Steal<rustc_middle::ty::ResolverAstLowering>,\n             [decode] unsafety_check_result: rustc_middle::mir::UnsafetyCheckResult,\n             [decode] code_region: rustc_middle::mir::coverage::CodeRegion,\n             [] const_allocs: rustc_middle::mir::interpret::Allocation,\n@@ -88,8 +91,8 @@ macro_rules! arena_types {\n             [] hir_id_set: rustc_hir::HirIdSet,\n \n             // Interned types\n-            [] tys: rustc_data_structures::intern::WithStableHash<rustc_middle::ty::TyS<'tcx>>,\n-            [] predicates: rustc_data_structures::intern::WithStableHash<rustc_middle::ty::PredicateS<'tcx>>,\n+            [] tys: rustc_type_ir::WithCachedTypeInfo<rustc_middle::ty::TyKind<'tcx>>,\n+            [] predicates: rustc_type_ir::WithCachedTypeInfo<rustc_middle::ty::PredicateKind<'tcx>>,\n             [] consts: rustc_middle::ty::ConstS<'tcx>,\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,"}, {"sha": "bea884c856a95bd616b229e20f9f2984154ab573", "filename": "compiler/rustc_middle/src/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -26,8 +26,10 @@ pub struct CodegenFnAttrs {\n     /// The `#[target_feature(enable = \"...\")]` attribute and the enabled\n     /// features (only enabled features are supported right now).\n     pub target_features: Vec<Symbol>,\n-    /// The `#[linkage = \"...\"]` attribute and the value we found.\n+    /// The `#[linkage = \"...\"]` attribute on Rust-defined items and the value we found.\n     pub linkage: Option<Linkage>,\n+    /// The `#[linkage = \"...\"]` attribute on foreign items and the value we found.\n+    pub import_linkage: Option<Linkage>,\n     /// The `#[link_section = \"...\"]` attribute, or what executable section this\n     /// should be placed in.\n     pub link_section: Option<Symbol>,\n@@ -113,6 +115,7 @@ impl CodegenFnAttrs {\n             link_ordinal: None,\n             target_features: vec![],\n             linkage: None,\n+            import_linkage: None,\n             link_section: None,\n             no_sanitize: SanitizerSet::empty(),\n             instruction_set: None,"}, {"sha": "221105ac48f79b5487374c7969cdd058d1515755", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -103,7 +103,7 @@ impl hash::Hash for Allocation {\n /// Interned types generally have an `Outer` type and an `Inner` type, where\n /// `Outer` is a newtype around `Interned<Inner>`, and all the operations are\n /// done on `Outer`, because all occurrences are interned. E.g. `Ty` is an\n-/// outer type and `TyS` is its inner type.\n+/// outer type and `TyKind` is its inner type.\n ///\n /// Here things are different because only const allocations are interned. This\n /// means that both the inner type (`Allocation`) and the outer type"}, {"sha": "614e0d012b35a672a0da08663ff8ae65a6d02d13", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -400,7 +400,7 @@ impl std::fmt::Display for NonDivergingIntrinsic<'_> {\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, Hash, HashStable)]\n #[rustc_pass_by_value]\n pub enum RetagKind {\n-    /// The initial retag when entering a function.\n+    /// The initial retag of arguments when entering a function.\n     FnEntry,\n     /// Retag preparing for a two-phase borrow.\n     TwoPhase,"}, {"sha": "f2f2b22f52a37b81834c82f7e06f9a25e36c6c27", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -33,7 +33,7 @@ rustc_queries! {\n     }\n \n     query resolver_for_lowering(_: ()) -> &'tcx Steal<ty::ResolverAstLowering> {\n-        eval_always\n+        feedable\n         no_hash\n         desc { \"getting the resolver for lowering\" }\n     }"}, {"sha": "b44bc14ec26c83bc75bb746d2d831e3634a3159a", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 60, "deletions": 75, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,5 +1,7 @@\n //! Type context book-keeping.\n \n+#![allow(rustc::usage_of_ty_tykind)]\n+\n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n@@ -19,15 +21,15 @@ use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n     ClosureSizeProfileData, Const, ConstS, DefIdTree, FloatTy, FloatVar, FloatVid,\n     GenericParamDefKind, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n-    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy,\n-    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n-    UintTy, Visibility,\n+    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, ProjectionTy, Region,\n+    RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, UintTy,\n+    Visibility,\n };\n use crate::ty::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef, UserSubsts};\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::intern::{Interned, WithStableHash};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n@@ -68,6 +70,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n use rustc_type_ir::sty::TyKind::*;\n+use rustc_type_ir::WithCachedTypeInfo;\n use rustc_type_ir::{DynKind, InternAs, InternIteratorElement, Interner, TypeFlags};\n \n use std::any::Any;\n@@ -81,7 +84,7 @@ use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n-use super::{ImplPolarity, ResolverOutputs, RvalueScopes};\n+use super::{ImplPolarity, RvalueScopes};\n \n pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n@@ -137,13 +140,13 @@ pub struct CtxtInterners<'tcx> {\n \n     // Specifically use a speedy hash algorithm for these hash sets, since\n     // they're accessed quite often.\n-    type_: InternedSet<'tcx, WithStableHash<TyS<'tcx>>>,\n+    type_: InternedSet<'tcx, WithCachedTypeInfo<TyKind<'tcx>>>,\n     const_lists: InternedSet<'tcx, List<ty::Const<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind<'tcx>>,\n     poly_existential_predicates: InternedSet<'tcx, List<PolyExistentialPredicate<'tcx>>>,\n-    predicate: InternedSet<'tcx, WithStableHash<PredicateS<'tcx>>>,\n+    predicate: InternedSet<'tcx, WithCachedTypeInfo<ty::Binder<'tcx, PredicateKind<'tcx>>>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -194,15 +197,12 @@ impl<'tcx> CtxtInterners<'tcx> {\n                     let stable_hash =\n                         self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n \n-                    let ty_struct = TyS {\n-                        kind,\n+                    InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n+                        internee: kind,\n+                        stable_hash,\n                         flags: flags.flags,\n                         outer_exclusive_binder: flags.outer_exclusive_binder,\n-                    };\n-\n-                    InternedInSet(\n-                        self.arena.alloc(WithStableHash { internee: ty_struct, stable_hash }),\n-                    )\n+                    }))\n                 })\n                 .0,\n         ))\n@@ -246,16 +246,12 @@ impl<'tcx> CtxtInterners<'tcx> {\n                     let stable_hash =\n                         self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n \n-                    let predicate_struct = PredicateS {\n-                        kind,\n+                    InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n+                        internee: kind,\n+                        stable_hash,\n                         flags: flags.flags,\n                         outer_exclusive_binder: flags.outer_exclusive_binder,\n-                    };\n-\n-                    InternedInSet(\n-                        self.arena\n-                            .alloc(WithStableHash { internee: predicate_struct, stable_hash }),\n-                    )\n+                    }))\n                 })\n                 .0,\n         ))\n@@ -671,6 +667,14 @@ impl<'tcx> TypeckResults<'tcx> {\n         LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n     }\n \n+    pub fn field_index(&self, id: hir::HirId) -> usize {\n+        self.field_indices().get(id).cloned().expect(\"no index for a field\")\n+    }\n+\n+    pub fn opt_field_index(&self, id: hir::HirId) -> Option<usize> {\n+        self.field_indices().get(id).cloned()\n+    }\n+\n     pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n         LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n     }\n@@ -1034,16 +1038,29 @@ pub struct FreeRegionInfo {\n \n /// This struct should only be created by `create_def`.\n #[derive(Copy, Clone)]\n-pub struct TyCtxtFeed<'tcx> {\n+pub struct TyCtxtFeed<'tcx, KEY: Copy> {\n     pub tcx: TyCtxt<'tcx>,\n     // Do not allow direct access, as downstream code must not mutate this field.\n-    def_id: LocalDefId,\n+    key: KEY,\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub fn feed_unit_query(self) -> TyCtxtFeed<'tcx, ()> {\n+        TyCtxtFeed { tcx: self, key: () }\n+    }\n+}\n+\n+impl<'tcx, KEY: Copy> TyCtxtFeed<'tcx, KEY> {\n+    #[inline(always)]\n+    pub fn key(&self) -> KEY {\n+        self.key\n+    }\n }\n \n-impl<'tcx> TyCtxtFeed<'tcx> {\n+impl<'tcx> TyCtxtFeed<'tcx, LocalDefId> {\n     #[inline(always)]\n     pub fn def_id(&self) -> LocalDefId {\n-        self.def_id\n+        self.key\n     }\n }\n \n@@ -1099,7 +1116,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Output of the resolver.\n     pub(crate) untracked_resolutions: ty::ResolverGlobalCtxt,\n-    untracked_resolver_for_lowering: Steal<ty::ResolverAstLowering>,\n     /// The entire crate as AST. This field serves as the input for the hir_crate query,\n     /// which lowers it from AST to HIR. It must not be read or used by anything else.\n     pub untracked_crate: Steal<Lrc<ast::Crate>>,\n@@ -1262,20 +1278,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n-        resolver_outputs: ResolverOutputs,\n+        definitions: Definitions,\n+        untracked_resolutions: ty::ResolverGlobalCtxt,\n         krate: Lrc<ast::Crate>,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n         query_kinds: &'tcx [DepKindStruct<'tcx>],\n-        crate_name: &str,\n+        crate_name: Symbol,\n         output_filenames: OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n-        let ResolverOutputs {\n-            definitions,\n-            global_ctxt: untracked_resolutions,\n-            ast_lowering: untracked_resolver_for_lowering,\n-        } = resolver_outputs;\n         let data_layout = s.target.parse_data_layout().unwrap_or_else(|err| {\n             s.emit_fatal(err);\n         });\n@@ -1304,7 +1316,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n             untracked_resolutions,\n-            untracked_resolver_for_lowering: Steal::new(untracked_resolver_for_lowering),\n             untracked_crate: Steal::new(krate),\n             on_disk_cache,\n             queries,\n@@ -1314,7 +1325,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n-            crate_name: Symbol::intern(crate_name),\n+            crate_name,\n             data_layout,\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             output_filenames: Arc::new(output_filenames),\n@@ -1515,7 +1526,7 @@ impl<'tcx> TyCtxtAt<'tcx> {\n         self,\n         parent: LocalDefId,\n         data: hir::definitions::DefPathData,\n-    ) -> TyCtxtFeed<'tcx> {\n+    ) -> TyCtxtFeed<'tcx, LocalDefId> {\n         // This function modifies `self.definitions` using a side-effect.\n         // We need to ensure that these side effects are re-run by the incr. comp. engine.\n         // Depending on the forever-red node will tell the graph that the calling query\n@@ -1536,9 +1547,9 @@ impl<'tcx> TyCtxtAt<'tcx> {\n         // This is fine because:\n         // - those queries are `eval_always` so we won't miss their result changing;\n         // - this write will have happened before these queries are called.\n-        let def_id = self.definitions.write().create_def(parent, data);\n+        let key = self.definitions.write().create_def(parent, data);\n \n-        let feed = TyCtxtFeed { tcx: self.tcx, def_id };\n+        let feed = TyCtxtFeed { tcx: self.tcx, key };\n         feed.def_span(self.span);\n         feed\n     }\n@@ -2097,7 +2108,7 @@ macro_rules! sty_debug_print {\n                 let shards = tcx.interners.type_.lock_shards();\n                 let types = shards.iter().flat_map(|shard| shard.keys());\n                 for &InternedInSet(t) in types {\n-                    let variant = match t.kind {\n+                    let variant = match t.internee {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n                         ty::Error(_) => /* unimportant */ continue,\n@@ -2207,51 +2218,26 @@ impl<'tcx, T: 'tcx + ?Sized> IntoPointer for InternedInSet<'tcx, T> {\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx> Borrow<TyKind<'tcx>> for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n-        &self.0.kind\n-    }\n-}\n-\n-impl<'tcx> PartialEq for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n-    fn eq(&self, other: &InternedInSet<'tcx, WithStableHash<TyS<'tcx>>>) -> bool {\n-        // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n-        // `x == y`.\n-        self.0.kind == other.0.kind\n-    }\n-}\n-\n-impl<'tcx> Eq for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {}\n-\n-impl<'tcx> Hash for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n-        self.0.kind.hash(s)\n-    }\n-}\n-\n-impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>>\n-    for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>>\n-{\n-    fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n-        &self.0.kind\n+impl<'tcx, T> Borrow<T> for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n+    fn borrow<'a>(&'a self) -> &'a T {\n+        &self.0.internee\n     }\n }\n \n-impl<'tcx> PartialEq for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {\n-    fn eq(&self, other: &InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>>) -> bool {\n+impl<'tcx, T: PartialEq> PartialEq for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, WithCachedTypeInfo<T>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n-        self.0.kind == other.0.kind\n+        self.0.internee == other.0.internee\n     }\n }\n \n-impl<'tcx> Eq for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {}\n+impl<'tcx, T: Eq> Eq for InternedInSet<'tcx, WithCachedTypeInfo<T>> {}\n \n-impl<'tcx> Hash for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {\n+impl<'tcx, T: Hash> Hash for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n-        self.0.kind.hash(s)\n+        self.0.internee.hash(s)\n     }\n }\n \n@@ -3107,7 +3093,6 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     providers.resolutions = |tcx, ()| &tcx.untracked_resolutions;\n-    providers.resolver_for_lowering = |tcx, ()| &tcx.untracked_resolver_for_lowering;\n     providers.module_reexports =\n         |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);\n     providers.crate_name = |tcx, id| {"}, {"sha": "aa61c39b8d81931d9f78c15695641b5873464c47", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -986,23 +986,32 @@ fn foo(&self) -> Self::T { String::new() }\n     }\n \n     pub fn short_ty_string(self, ty: Ty<'tcx>) -> (String, Option<PathBuf>) {\n-        let length_limit = 50;\n-        let type_limit = 4;\n+        let width = self.sess.diagnostic_width();\n+        let length_limit = width.saturating_sub(30);\n+        let mut type_limit = 50;\n         let regular = FmtPrinter::new(self, hir::def::Namespace::TypeNS)\n             .pretty_print_type(ty)\n             .expect(\"could not write to `String`\")\n             .into_buffer();\n-        if regular.len() <= length_limit {\n+        if regular.len() <= width {\n             return (regular, None);\n         }\n-        let short = FmtPrinter::new_with_limit(\n-            self,\n-            hir::def::Namespace::TypeNS,\n-            rustc_session::Limit(type_limit),\n-        )\n-        .pretty_print_type(ty)\n-        .expect(\"could not write to `String`\")\n-        .into_buffer();\n+        let mut short;\n+        loop {\n+            // Look for the longest properly trimmed path that still fits in lenght_limit.\n+            short = FmtPrinter::new_with_limit(\n+                self,\n+                hir::def::Namespace::TypeNS,\n+                rustc_session::Limit(type_limit),\n+            )\n+            .pretty_print_type(ty)\n+            .expect(\"could not write to `String`\")\n+            .into_buffer();\n+            if short.len() <= length_limit || type_limit == 0 {\n+                break;\n+            }\n+            type_limit -= 1;\n+        }\n         if regular == short {\n             return (regular, None);\n         }"}, {"sha": "48329da3e63326049a5878ba502c28f0b1c73a19", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -101,6 +101,20 @@ impl GenericParamDef {\n             _ => None,\n         }\n     }\n+\n+    pub fn to_error<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        preceding_substs: &[ty::GenericArg<'tcx>],\n+    ) -> ty::GenericArg<'tcx> {\n+        match &self.kind {\n+            ty::GenericParamDefKind::Lifetime => tcx.lifetimes.re_static.into(),\n+            ty::GenericParamDefKind::Type { .. } => tcx.ty_error().into(),\n+            ty::GenericParamDefKind::Const { .. } => {\n+                tcx.const_error(tcx.bound_type_of(self.def_id).subst(tcx, preceding_substs)).into()\n+            }\n+        }\n+    }\n }\n \n #[derive(Default)]"}, {"sha": "c062e508ee3df26ed93a1fd7b48aa34f6625b126", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 31, "deletions": 122, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -9,6 +9,8 @@\n //!\n //! [\"The `ty` module: representing types\"]: https://rustc-dev-guide.rust-lang.org/ty.html\n \n+#![allow(rustc::usage_of_ty_tykind)]\n+\n pub use self::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeSuperFoldable};\n pub use self::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n pub use self::AssocItemContainer::*;\n@@ -32,7 +34,7 @@ use rustc_ast::node_id::NodeMap;\n use rustc_attr as attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n-use rustc_data_structures::intern::{Interned, WithStableHash};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n@@ -50,6 +52,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, Span};\n use rustc_target::abi::{Align, Integer, IntegerType, VariantIdx};\n pub use rustc_target::abi::{ReprFlags, ReprOptions};\n+use rustc_type_ir::WithCachedTypeInfo;\n pub use subst::*;\n pub use vtable::*;\n \n@@ -82,8 +85,8 @@ pub use self::consts::{\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GeneratorDiagnosticData,\n-    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TypeckResults, UserType,\n-    UserTypeAnnotationIndex,\n+    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TyCtxtFeed, TypeckResults,\n+    UserType, UserTypeAnnotationIndex,\n };\n pub use self::instance::{Instance, InstanceDef, ShortInstance};\n pub use self::list::List;\n@@ -445,86 +448,22 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-/// Represents a type.\n-///\n-/// IMPORTANT:\n-/// - This is a very \"dumb\" struct (with no derives and no `impls`).\n-/// - Values of this type are always interned and thus unique, and are stored\n-///   as an `Interned<TyS>`.\n-/// - `Ty` (which contains a reference to a `Interned<TyS>`) or `Interned<TyS>`\n-///   should be used everywhere instead of `TyS`. In particular, `Ty` has most\n-///   of the relevant methods.\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-#[allow(rustc::usage_of_ty_tykind)]\n-pub(crate) struct TyS<'tcx> {\n-    /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `Ty::kind()` instead.\n-    kind: TyKind<'tcx>,\n-\n-    /// This field provides fast access to information that is also contained\n-    /// in `kind`.\n-    ///\n-    /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `Ty::flags()` instead.\n-    flags: TypeFlags,\n-\n-    /// This field provides fast access to information that is also contained\n-    /// in `kind`.\n-    ///\n-    /// This is a kind of confusing thing: it stores the smallest\n-    /// binder such that\n-    ///\n-    /// (a) the binder itself captures nothing but\n-    /// (b) all the late-bound things within the type are captured\n-    ///     by some sub-binder.\n-    ///\n-    /// So, for a type without any late-bound things, like `u32`, this\n-    /// will be *innermost*, because that is the innermost binder that\n-    /// captures nothing. But for a type `&'D u32`, where `'D` is a\n-    /// late-bound region with De Bruijn index `D`, this would be `D + 1`\n-    /// -- the binder itself does not capture `D`, but `D` is captured\n-    /// by an inner binder.\n-    ///\n-    /// We call this concept an \"exclusive\" binder `D` because all\n-    /// De Bruijn indices within the type are contained within `0..D`\n-    /// (exclusive).\n-    outer_exclusive_binder: ty::DebruijnIndex,\n-}\n-\n-/// Use this rather than `TyS`, whenever possible.\n+/// Use this rather than `TyKind`, whenever possible.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n #[rustc_diagnostic_item = \"Ty\"]\n #[rustc_pass_by_value]\n-pub struct Ty<'tcx>(Interned<'tcx, WithStableHash<TyS<'tcx>>>);\n+pub struct Ty<'tcx>(Interned<'tcx, WithCachedTypeInfo<TyKind<'tcx>>>);\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// A \"bool\" type used in rustc_mir_transform unit tests when we\n     /// have not spun up a TyCtxt.\n-    pub const BOOL_TY_FOR_UNIT_TESTING: Ty<'tcx> = Ty(Interned::new_unchecked(&WithStableHash {\n-        internee: TyS {\n-            kind: ty::Bool,\n+    pub const BOOL_TY_FOR_UNIT_TESTING: Ty<'tcx> =\n+        Ty(Interned::new_unchecked(&WithCachedTypeInfo {\n+            internee: ty::Bool,\n+            stable_hash: Fingerprint::ZERO,\n             flags: TypeFlags::empty(),\n             outer_exclusive_binder: DebruijnIndex::from_usize(0),\n-        },\n-        stable_hash: Fingerprint::ZERO,\n-    }));\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let TyS {\n-            kind,\n-\n-            // The other fields just provide fast access to information that is\n-            // also contained in `kind`, so no need to hash them.\n-            flags: _,\n-\n-            outer_exclusive_binder: _,\n-        } = self;\n-\n-        kind.hash_stable(hcx, hasher)\n-    }\n+        }));\n }\n \n impl ty::EarlyBoundRegion {\n@@ -535,28 +474,18 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n-/// Represents a predicate.\n-///\n-/// See comments on `TyS`, which apply here too (albeit for\n-/// `PredicateS`/`Predicate` rather than `TyS`/`Ty`).\n-#[derive(Debug)]\n-pub(crate) struct PredicateS<'tcx> {\n-    kind: Binder<'tcx, PredicateKind<'tcx>>,\n-    flags: TypeFlags,\n-    /// See the comment for the corresponding field of [TyS].\n-    outer_exclusive_binder: ty::DebruijnIndex,\n-}\n-\n-/// Use this rather than `PredicateS`, whenever possible.\n+/// Use this rather than `PredicateKind`, whenever possible.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n #[rustc_pass_by_value]\n-pub struct Predicate<'tcx>(Interned<'tcx, WithStableHash<PredicateS<'tcx>>>);\n+pub struct Predicate<'tcx>(\n+    Interned<'tcx, WithCachedTypeInfo<ty::Binder<'tcx, PredicateKind<'tcx>>>>,\n+);\n \n impl<'tcx> Predicate<'tcx> {\n     /// Gets the inner `Binder<'tcx, PredicateKind<'tcx>>`.\n     #[inline]\n     pub fn kind(self) -> Binder<'tcx, PredicateKind<'tcx>> {\n-        self.0.kind\n+        self.0.internee\n     }\n \n     #[inline(always)]\n@@ -631,21 +560,6 @@ impl<'tcx> Predicate<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for PredicateS<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let PredicateS {\n-            ref kind,\n-\n-            // The other fields just provide fast access to information that is\n-            // also contained in `kind`, so no need to hash them.\n-            flags: _,\n-            outer_exclusive_binder: _,\n-        } = self;\n-\n-        kind.hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl rustc_errors::IntoDiagnosticArg for Predicate<'_> {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         rustc_errors::DiagnosticArgValue::Str(std::borrow::Cow::Owned(self.to_string()))\n@@ -1028,7 +942,7 @@ impl<'tcx> Term<'tcx> {\n         unsafe {\n             match ptr & TAG_MASK {\n                 TYPE_TAG => TermKind::Ty(Ty(Interned::new_unchecked(\n-                    &*((ptr & !TAG_MASK) as *const WithStableHash<ty::TyS<'tcx>>),\n+                    &*((ptr & !TAG_MASK) as *const WithCachedTypeInfo<ty::TyKind<'tcx>>),\n                 ))),\n                 CONST_TAG => TermKind::Const(ty::Const(Interned::new_unchecked(\n                     &*((ptr & !TAG_MASK) as *const ty::ConstS<'tcx>),\n@@ -1072,7 +986,7 @@ impl<'tcx> TermKind<'tcx> {\n             TermKind::Ty(ty) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(&*ty.0.0) & TAG_MASK, 0);\n-                (TYPE_TAG, ty.0.0 as *const WithStableHash<ty::TyS<'tcx>> as usize)\n+                (TYPE_TAG, ty.0.0 as *const WithCachedTypeInfo<ty::TyKind<'tcx>> as usize)\n             }\n             TermKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n@@ -1150,8 +1064,8 @@ impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n     }\n }\n \n-pub trait ToPredicate<'tcx, Predicate> {\n-    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate;\n+pub trait ToPredicate<'tcx, P = Predicate<'tcx>> {\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> P;\n }\n \n impl<'tcx, T> ToPredicate<'tcx, T> for T {\n@@ -1160,21 +1074,21 @@ impl<'tcx, T> ToPredicate<'tcx, T> for T {\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Binder<'tcx, PredicateKind<'tcx>> {\n+impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, PredicateKind<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         tcx.mk_predicate(self)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Clause<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for Clause<'tcx> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         tcx.mk_predicate(ty::Binder::dummy(ty::PredicateKind::Clause(self)))\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Binder<'tcx, TraitRef<'tcx>> {\n+impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         let pred: PolyTraitPredicate<'tcx> = self.to_predicate(tcx);\n@@ -1193,25 +1107,25 @@ impl<'tcx> ToPredicate<'tcx, PolyTraitPredicate<'tcx>> for Binder<'tcx, TraitRef\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyTraitPredicate<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for PolyTraitPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::Trait(p))).to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyRegionOutlivesPredicate<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::RegionOutlives(p))).to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyTypeOutlivesPredicate<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::TypeOutlives(p))).to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyProjectionPredicate<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::Projection(p))).to_predicate(tcx)\n     }\n@@ -2228,10 +2142,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn field_index(self, hir_id: hir::HirId, typeck_results: &TypeckResults<'_>) -> usize {\n-        typeck_results.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n-    }\n-\n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant\n             .fields\n@@ -2692,8 +2602,7 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // tidy-alphabetical-start\n-    static_assert_size!(PredicateS<'_>, 48);\n-    static_assert_size!(TyS<'_>, 40);\n-    static_assert_size!(WithStableHash<TyS<'_>>, 56);\n+    static_assert_size!(PredicateKind<'_>, 32);\n+    static_assert_size!(WithCachedTypeInfo<TyKind<'_>>, 56);\n     // tidy-alphabetical-end\n }"}, {"sha": "642900d3ab4299108844ded337ec7fb8e5c64b6b", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -328,13 +328,25 @@ macro_rules! define_callbacks {\n     };\n }\n \n+macro_rules! hash_result {\n+    ([]) => {{\n+        Some(dep_graph::hash_result)\n+    }};\n+    ([(no_hash) $($rest:tt)*]) => {{\n+        None\n+    }};\n+    ([$other:tt $($modifiers:tt)*]) => {\n+        hash_result!([$($modifiers)*])\n+    };\n+}\n+\n macro_rules! define_feedable {\n     ($($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n-        impl<'tcx> TyCtxtFeed<'tcx> {\n-            $($(#[$attr])*\n+        $(impl<'tcx, K: IntoQueryParam<$($K)*> + Copy> TyCtxtFeed<'tcx, K> {\n+            $(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, value: $V) -> query_stored::$name<'tcx> {\n-                let key = self.def_id().into_query_param();\n+                let key = self.key().into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n                 let tcx = self.tcx;\n@@ -358,11 +370,11 @@ macro_rules! define_feedable {\n                     tcx,\n                     key,\n                     &value,\n-                    dep_graph::hash_result,\n+                    hash_result!([$($modifiers)*]),\n                 );\n                 cache.complete(key, value, dep_node_index)\n-            })*\n-        }\n+            }\n+        })*\n     }\n }\n "}, {"sha": "9cbda95a4df7a7f1e582dadbcf021829f45791a4", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -722,8 +722,17 @@ impl<'tcx> PolyExistentialPredicate<'tcx> {\n                 self.rebind(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n-                let trait_ref = self.rebind(tcx.mk_trait_ref(did, [self_ty]));\n-                trait_ref.without_const().to_predicate(tcx)\n+                let generics = tcx.generics_of(did);\n+                let trait_ref = if generics.params.len() == 1 {\n+                    tcx.mk_trait_ref(did, [self_ty])\n+                } else {\n+                    // If this is an ill-formed auto trait, then synthesize\n+                    // new error substs for the missing generics.\n+                    let err_substs =\n+                        ty::InternalSubsts::extend_with_error(tcx, did, &[self_ty.into()]);\n+                    tcx.mk_trait_ref(did, err_substs)\n+                };\n+                self.rebind(trait_ref).without_const().to_predicate(tcx)\n             }\n         }\n     }\n@@ -1602,7 +1611,7 @@ impl<'tcx> Region<'tcx> {\n impl<'tcx> Ty<'tcx> {\n     #[inline(always)]\n     pub fn kind(self) -> &'tcx TyKind<'tcx> {\n-        &self.0.0.kind\n+        &self.0.0\n     }\n \n     #[inline(always)]"}, {"sha": "a1b084a5e891eca1bb2bf780597bae2fb06cbb40", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -6,10 +6,11 @@ use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n use crate::ty::visit::{TypeVisitable, TypeVisitor};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n-use rustc_data_structures::intern::{Interned, WithStableHash};\n+use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Decodable, Encodable};\n+use rustc_type_ir::WithCachedTypeInfo;\n use smallvec::SmallVec;\n \n use core::intrinsics;\n@@ -84,7 +85,7 @@ impl<'tcx> GenericArgKind<'tcx> {\n             GenericArgKind::Type(ty) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(&*ty.0.0) & TAG_MASK, 0);\n-                (TYPE_TAG, ty.0.0 as *const WithStableHash<ty::TyS<'tcx>> as usize)\n+                (TYPE_TAG, ty.0.0 as *const WithCachedTypeInfo<ty::TyKind<'tcx>> as usize)\n             }\n             GenericArgKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n@@ -162,7 +163,7 @@ impl<'tcx> GenericArg<'tcx> {\n                     &*((ptr & !TAG_MASK) as *const ty::RegionKind<'tcx>),\n                 ))),\n                 TYPE_TAG => GenericArgKind::Type(Ty(Interned::new_unchecked(\n-                    &*((ptr & !TAG_MASK) as *const WithStableHash<ty::TyS<'tcx>>),\n+                    &*((ptr & !TAG_MASK) as *const WithCachedTypeInfo<ty::TyKind<'tcx>>),\n                 ))),\n                 CONST_TAG => GenericArgKind::Const(ty::Const(Interned::new_unchecked(\n                     &*((ptr & !TAG_MASK) as *const ty::ConstS<'tcx>),\n@@ -352,6 +353,22 @@ impl<'tcx> InternalSubsts<'tcx> {\n         }\n     }\n \n+    // Extend an `original_substs` list to the full number of substs expected by `def_id`,\n+    // filling in the missing parameters with error ty/ct or 'static regions.\n+    pub fn extend_with_error(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        original_substs: &[GenericArg<'tcx>],\n+    ) -> SubstsRef<'tcx> {\n+        ty::InternalSubsts::for_item(tcx, def_id, |def, substs| {\n+            if let Some(subst) = original_substs.get(def.index as usize) {\n+                *subst\n+            } else {\n+                def.to_error(tcx, substs)\n+            }\n+        })\n+    }\n+\n     #[inline]\n     pub fn types(&'tcx self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'tcx {\n         self.iter()"}, {"sha": "007f3b55ec8bb156b6c53c338fdfbbfacd3641f8", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -948,20 +948,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         original_source_scope: SourceScope,\n         pattern_span: Span,\n     ) {\n-        let tcx = self.tcx;\n-        let current_root = tcx.maybe_lint_level_root_bounded(arg_hir_id, self.hir_id);\n-        let parent_root = tcx.maybe_lint_level_root_bounded(\n-            self.source_scopes[original_source_scope]\n-                .local_data\n-                .as_ref()\n-                .assert_crate_local()\n-                .lint_root,\n-            self.hir_id,\n-        );\n-        if current_root != parent_root {\n-            self.source_scope =\n-                self.new_source_scope(pattern_span, LintLevel::Explicit(current_root), None);\n-        }\n+        let parent_id = self.source_scopes[original_source_scope]\n+            .local_data\n+            .as_ref()\n+            .assert_crate_local()\n+            .lint_root;\n+        self.maybe_new_source_scope(pattern_span, None, arg_hir_id, parent_id);\n     }\n \n     fn get_unit_temp(&mut self) -> Place<'tcx> {"}, {"sha": "33f49ffdaf6403fd4ae06a43b763e86789ab567b", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -85,6 +85,7 @@ use std::mem;\n \n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n@@ -567,25 +568,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>,\n     {\n         let source_scope = self.source_scope;\n-        let tcx = self.tcx;\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n-            // Use `maybe_lint_level_root_bounded` with `root_lint_level` as a bound\n-            // to avoid adding Hir dependencies on our parents.\n-            // We estimate the true lint roots here to avoid creating a lot of source scopes.\n-\n-            let parent_root = tcx.maybe_lint_level_root_bounded(\n-                self.source_scopes[source_scope].local_data.as_ref().assert_crate_local().lint_root,\n-                self.hir_id,\n-            );\n-            let current_root = tcx.maybe_lint_level_root_bounded(current_hir_id, self.hir_id);\n-\n-            if parent_root != current_root {\n-                self.source_scope = self.new_source_scope(\n-                    region_scope.1.span,\n-                    LintLevel::Explicit(current_root),\n-                    None,\n-                );\n-            }\n+            let parent_id =\n+                self.source_scopes[source_scope].local_data.as_ref().assert_crate_local().lint_root;\n+            self.maybe_new_source_scope(region_scope.1.span, None, current_hir_id, parent_id);\n         }\n         self.push_scope(region_scope);\n         let mut block;\n@@ -758,6 +744,40 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         ))\n     }\n \n+    /// Possibly creates a new source scope if `current_root` and `parent_root`\n+    /// are different, or if -Zmaximal-hir-to-mir-coverage is enabled.\n+    pub(crate) fn maybe_new_source_scope(\n+        &mut self,\n+        span: Span,\n+        safety: Option<Safety>,\n+        current_id: HirId,\n+        parent_id: HirId,\n+    ) {\n+        let (current_root, parent_root) =\n+            if self.tcx.sess.opts.unstable_opts.maximal_hir_to_mir_coverage {\n+                // Some consumers of rustc need to map MIR locations back to HIR nodes. Currently the\n+                // the only part of rustc that tracks MIR -> HIR is the `SourceScopeLocalData::lint_root`\n+                // field that tracks lint levels for MIR locations.  Normally the number of source scopes\n+                // is limited to the set of nodes with lint annotations. The -Zmaximal-hir-to-mir-coverage\n+                // flag changes this behavior to maximize the number of source scopes, increasing the\n+                // granularity of the MIR->HIR mapping.\n+                (current_id, parent_id)\n+            } else {\n+                // Use `maybe_lint_level_root_bounded` with `self.hir_id` as a bound\n+                // to avoid adding Hir dependencies on our parents.\n+                // We estimate the true lint roots here to avoid creating a lot of source scopes.\n+                (\n+                    self.tcx.maybe_lint_level_root_bounded(current_id, self.hir_id),\n+                    self.tcx.maybe_lint_level_root_bounded(parent_id, self.hir_id),\n+                )\n+            };\n+\n+        if current_root != parent_root {\n+            let lint_level = LintLevel::Explicit(current_root);\n+            self.source_scope = self.new_source_scope(span, lint_level, safety);\n+        }\n+    }\n+\n     /// Creates a new source scope, nested in the current one.\n     pub(crate) fn new_source_scope(\n         &mut self,"}, {"sha": "261b95ba95b0e36781448e9fdc7be376773f99cb", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -704,7 +704,7 @@ impl<'tcx> Cx<'tcx> {\n             hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n                 lhs: self.mirror_expr(source),\n                 variant_index: VariantIdx::new(0),\n-                name: Field::new(tcx.field_index(expr.hir_id, self.typeck_results)),\n+                name: Field::new(self.typeck_results.field_index(expr.hir_id)),\n             },\n             hir::ExprKind::Cast(ref source, ref cast_ty) => {\n                 // Check for a user-given type annotation on this `cast`\n@@ -1079,7 +1079,7 @@ impl<'tcx> Cx<'tcx> {\n         fields\n             .iter()\n             .map(|field| FieldExpr {\n-                name: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n+                name: Field::new(self.typeck_results.field_index(field.hir_id)),\n                 expr: self.mirror_expr(field.expr),\n             })\n             .collect()"}, {"sha": "48a231a6cd6b7c4648396131e1743e0a71065b04", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let subpatterns = fields\n                     .iter()\n                     .map(|field| FieldPat {\n-                        field: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n+                        field: Field::new(self.typeck_results.field_index(field.hir_id)),\n                         pattern: self.lower_pattern(&field.pat),\n                     })\n                     .collect();"}, {"sha": "7df0114226418c890378eea776e08cc4b6b82973", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -406,7 +406,7 @@ impl<V: Clone> Clone for StateData<V> {\n /// The dataflow state for an instance of [`ValueAnalysis`].\n ///\n /// Every instance specifies a lattice that represents the possible values of a single tracked\n-/// place. If we call this lattice `V` and set set of tracked places `P`, then a [`State`] is an\n+/// place. If we call this lattice `V` and set of tracked places `P`, then a [`State`] is an\n /// element of `{unreachable} \u222a (P -> V)`. This again forms a lattice, where the bottom element is\n /// `unreachable` and the top element is the mapping `p \u21a6 \u22a4`. Note that the mapping `p \u21a6 \u22a5` is not\n /// the bottom element (because joining an unreachable and any other reachable state yields a"}, {"sha": "3d22035f0785ed57509c86c251355156d92d3665", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 13, "deletions": 40, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -10,16 +10,6 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub struct AddRetag;\n \n-/// Determines whether this place is \"stable\": Whether, if we evaluate it again\n-/// after the assignment, we can be sure to obtain the same place value.\n-/// (Concurrent accesses by other threads are no problem as these are anyway non-atomic\n-/// copies.  Data races are UB.)\n-fn is_stable(place: PlaceRef<'_>) -> bool {\n-    // Which place this evaluates to can change with any memory write,\n-    // so cannot assume deref to be stable.\n-    !place.has_deref()\n-}\n-\n /// Determine whether this type may contain a reference (or box), and thus needs retagging.\n /// We will only recurse `depth` times into Tuples/ADTs to bound the cost of this.\n fn may_contain_reference<'tcx>(ty: Ty<'tcx>, depth: u32, tcx: TyCtxt<'tcx>) -> bool {\n@@ -69,22 +59,10 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         let basic_blocks = body.basic_blocks.as_mut();\n         let local_decls = &body.local_decls;\n         let needs_retag = |place: &Place<'tcx>| {\n-            // FIXME: Instead of giving up for unstable places, we should introduce\n-            // a temporary and retag on that.\n-            is_stable(place.as_ref())\n+            !place.has_deref() // we're not eally interested in stores to \"outside\" locations, they are hard to keep track of anyway\n                 && may_contain_reference(place.ty(&*local_decls, tcx).ty, /*depth*/ 3, tcx)\n                 && !local_decls[place.local].is_deref_temp()\n         };\n-        let place_base_raw = |place: &Place<'tcx>| {\n-            // If this is a `Deref`, get the type of what we are deref'ing.\n-            if place.has_deref() {\n-                let ty = &local_decls[place.local].ty;\n-                ty.is_unsafe_ptr()\n-            } else {\n-                // Not a deref, and thus not raw.\n-                false\n-            }\n-        };\n \n         // PART 1\n         // Retag arguments at the beginning of the start block.\n@@ -108,7 +86,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         }\n \n         // PART 2\n-        // Retag return values of functions.  Also escape-to-raw the argument of `drop`.\n+        // Retag return values of functions.\n         // We collect the return destinations because we cannot mutate while iterating.\n         let returns = basic_blocks\n             .iter_mut()\n@@ -140,30 +118,25 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         }\n \n         // PART 3\n-        // Add retag after assignment.\n+        // Add retag after assignments where data \"enters\" this function: the RHS is behind a deref and the LHS is not.\n         for block_data in basic_blocks {\n             // We want to insert statements as we iterate.  To this end, we\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 let (retag_kind, place) = match block_data.statements[i].kind {\n-                    // Retag-as-raw after escaping to a raw pointer, if the referent\n-                    // is not already a raw pointer.\n-                    StatementKind::Assign(box (lplace, Rvalue::AddressOf(_, ref rplace)))\n-                        if !place_base_raw(rplace) =>\n-                    {\n-                        (RetagKind::Raw, lplace)\n-                    }\n                     // Retag after assignments of reference type.\n                     StatementKind::Assign(box (ref place, ref rvalue)) if needs_retag(place) => {\n-                        let kind = match rvalue {\n-                            Rvalue::Ref(_, borrow_kind, _)\n-                                if borrow_kind.allows_two_phase_borrow() =>\n-                            {\n-                                RetagKind::TwoPhase\n-                            }\n-                            _ => RetagKind::Default,\n+                        let add_retag = match rvalue {\n+                            // Ptr-creating operations already do their own internal retagging, no\n+                            // need to also add a retag statement.\n+                            Rvalue::Ref(..) | Rvalue::AddressOf(..) => false,\n+                            _ => true,\n                         };\n-                        (kind, *place)\n+                        if add_retag {\n+                            (RetagKind::Default, *place)\n+                        } else {\n+                            continue;\n+                        }\n                     }\n                     // Do nothing for the rest\n                     _ => continue,"}, {"sha": "594cbd8977ebbf55dca5294946ce15eecde9076e", "filename": "compiler/rustc_mir_transform/src/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdump_mir.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -7,7 +7,7 @@ use crate::MirPass;\n use rustc_middle::mir::write_mir_pretty;\n use rustc_middle::mir::Body;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{OutputFilenames, OutputType};\n+use rustc_session::config::OutputType;\n \n pub struct Marker(pub &'static str);\n \n@@ -19,8 +19,8 @@ impl<'tcx> MirPass<'tcx> for Marker {\n     fn run_pass(&self, _tcx: TyCtxt<'tcx>, _body: &mut Body<'tcx>) {}\n }\n \n-pub fn emit_mir(tcx: TyCtxt<'_>, outputs: &OutputFilenames) -> io::Result<()> {\n-    let path = outputs.path(OutputType::Mir);\n+pub fn emit_mir(tcx: TyCtxt<'_>) -> io::Result<()> {\n+    let path = tcx.output_filenames(()).path(OutputType::Mir);\n     let mut f = io::BufWriter::new(File::create(&path)?);\n     write_mir_pretty(tcx, None, &mut f)?;\n     Ok(())"}, {"sha": "69f96fe48ea2ff37365b16595428320b8927bac9", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -985,16 +985,6 @@ fn create_generator_drop_shim<'tcx>(\n         tcx.mk_ptr(ty::TypeAndMut { ty: gen_ty, mutbl: hir::Mutability::Mut }),\n         source_info,\n     );\n-    if tcx.sess.opts.unstable_opts.mir_emit_retag {\n-        // Alias tracking must know we changed the type\n-        body.basic_blocks_mut()[START_BLOCK].statements.insert(\n-            0,\n-            Statement {\n-                source_info,\n-                kind: StatementKind::Retag(RetagKind::Raw, Box::new(Place::from(SELF_ARG))),\n-            },\n-        )\n-    }\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the resume part of the function"}, {"sha": "220cf7df9c6c7e99cd35d103fa959988f9b1db34", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -8,7 +8,6 @@ use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n-use rustc_span::def_id::DefId;\n use rustc_span::{hygiene::ExpnKind, ExpnData, LocalExpnId, Span};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n@@ -87,13 +86,8 @@ fn inline<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) -> bool {\n \n     let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n-    let mut this = Inliner {\n-        tcx,\n-        param_env,\n-        codegen_fn_attrs: tcx.codegen_fn_attrs(def_id),\n-        history: Vec::new(),\n-        changed: false,\n-    };\n+    let mut this =\n+        Inliner { tcx, param_env, codegen_fn_attrs: tcx.codegen_fn_attrs(def_id), changed: false };\n     let blocks = BasicBlock::new(0)..body.basic_blocks.next_index();\n     this.process_blocks(body, blocks);\n     this.changed\n@@ -104,12 +98,6 @@ struct Inliner<'tcx> {\n     param_env: ParamEnv<'tcx>,\n     /// Caller codegen attributes.\n     codegen_fn_attrs: &'tcx CodegenFnAttrs,\n-    /// Stack of inlined instances.\n-    /// We only check the `DefId` and not the substs because we want to\n-    /// avoid inlining cases of polymorphic recursion.\n-    /// The number of `DefId`s is finite, so checking history is enough\n-    /// to ensure that we do not loop endlessly while inlining.\n-    history: Vec<DefId>,\n     /// Indicates that the caller body has been modified.\n     changed: bool,\n }\n@@ -134,12 +122,12 @@ impl<'tcx> Inliner<'tcx> {\n                     debug!(\"not-inlined {} [{}]\", callsite.callee, reason);\n                     continue;\n                 }\n-                Ok(new_blocks) => {\n+                Ok(_) => {\n                     debug!(\"inlined {}\", callsite.callee);\n                     self.changed = true;\n-                    self.history.push(callsite.callee.def_id());\n-                    self.process_blocks(caller_body, new_blocks);\n-                    self.history.pop();\n+                    // We could process the blocks returned by `try_inlining` here. However, that\n+                    // leads to exponential compile times due to the top-down nature of this kind\n+                    // of inlining.\n                 }\n             }\n         }\n@@ -313,10 +301,6 @@ impl<'tcx> Inliner<'tcx> {\n                     return None;\n                 }\n \n-                if self.history.contains(&callee.def_id()) {\n-                    return None;\n-                }\n-\n                 let fn_sig = self.tcx.bound_fn_sig(def_id).subst(self.tcx, substs);\n \n                 return Some(CallSite {"}, {"sha": "569e783fee847b17a561293e001783627773ab9e", "filename": "compiler/rustc_mir_transform/src/remove_zsts.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,8 +1,7 @@\n //! Removes assignments to ZST places.\n \n use crate::MirPass;\n-use rustc_middle::mir::tcx::PlaceTy;\n-use rustc_middle::mir::{Body, LocalDecls, Place, StatementKind};\n+use rustc_middle::mir::{Body, StatementKind};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub struct RemoveZsts;\n@@ -35,9 +34,6 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n                     if !layout.is_zst() {\n                         continue;\n                     }\n-                    if involves_a_union(place, local_decls, tcx) {\n-                        continue;\n-                    }\n                     if tcx.consider_optimizing(|| {\n                         format!(\n                             \"RemoveZsts - Place: {:?} SourceInfo: {:?}\",\n@@ -63,24 +59,3 @@ fn maybe_zst(ty: Ty<'_>) -> bool {\n         _ => false,\n     }\n }\n-\n-/// Miri lazily allocates memory for locals on assignment,\n-/// so we must preserve writes to unions and union fields,\n-/// or it will ICE on reads of those fields.\n-fn involves_a_union<'tcx>(\n-    place: Place<'tcx>,\n-    local_decls: &LocalDecls<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-) -> bool {\n-    let mut place_ty = PlaceTy::from_ty(local_decls[place.local].ty);\n-    if place_ty.ty.is_union() {\n-        return true;\n-    }\n-    for elem in place.projection {\n-        place_ty = place_ty.projection_ty(tcx, elem);\n-        if place_ty.ty.is_union() {\n-            return true;\n-        }\n-    }\n-    return false;\n-}"}, {"sha": "16b7dcad17e77843e6f90a458b5b2441d755542c", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -177,16 +177,6 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     if ty.is_some() {\n         // The first argument (index 0), but add 1 for the return value.\n         let dropee_ptr = Place::from(Local::new(1 + 0));\n-        if tcx.sess.opts.unstable_opts.mir_emit_retag {\n-            // Function arguments should be retagged, and we make this one raw.\n-            body.basic_blocks_mut()[START_BLOCK].statements.insert(\n-                0,\n-                Statement {\n-                    source_info,\n-                    kind: StatementKind::Retag(RetagKind::Raw, Box::new(dropee_ptr)),\n-                },\n-            );\n-        }\n         let patch = {\n             let param_env = tcx.param_env_reveal_all_normalized(def_id);\n             let mut elaborator ="}, {"sha": "18a0bee9c2e5ee83ba98e4543fdc54b2befb3d8d", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1221,3 +1221,11 @@ pub(crate) struct UnexpectedIfWithIf(\n     #[suggestion(applicability = \"machine-applicable\", code = \" \", style = \"verbose\")]\n     pub Span,\n );\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_maybe_fn_typo_with_impl)]\n+pub(crate) struct FnTypoWithImpl {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"impl\", style = \"verbose\")]\n+    pub fn_span: Span,\n+}"}, {"sha": "f6a6ed379a2b595de95d36534b1e234187e6a40d", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -390,20 +390,11 @@ impl<'a> Parser<'a> {\n             // want to keep their span info to improve diagnostics in these cases in a later stage.\n             (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n             (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n-            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n-            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n-            // `if x { a } else { b } && if y { c } else { d }`\n-            if !self.look_ahead(1, |t| t.is_used_keyword()) => {\n-                // These cases are ambiguous and can't be identified in the parser alone.\n-                let sp = self.sess.source_map().start_point(self.token.span);\n-                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n-                false\n-            }\n-            (true, Some(AssocOp::LAnd)) |\n-            (true, Some(AssocOp::LOr)) |\n-            (true, Some(AssocOp::BitOr)) => {\n-                // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`. Separated from the\n-                // above due to #74233.\n+            (true, Some(AssocOp::Add)) | // `{ 42 } + 42` (unary plus)\n+            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`\n+            (true, Some(AssocOp::LOr)) | // `{ 42 } || 42` (\"logical or\" or closure)\n+            (true, Some(AssocOp::BitOr)) // `{ 42 } | 42` or `{ 42 } |x| 42`\n+            => {\n                 // These cases are ambiguous and can't be identified in the parser alone.\n                 //\n                 // Bitwise AND is left out because guessing intent is hard. We can make"}, {"sha": "ce4bc929c5cd79e7438c189f9a3cdde1481564f8", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -3,6 +3,7 @@ use crate::errors::{DocCommentDoesNotDocumentAnything, UseEmptyBlockNotSemi};\n use super::diagnostics::{dummy_arg, ConsumeClosingDelim};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{AttrWrapper, FollowedByType, ForceCollect, Parser, PathStyle, TrailingToken};\n+use crate::errors::FnTypoWithImpl;\n use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n@@ -1414,7 +1415,10 @@ impl<'a> Parser<'a> {\n \n                 Ok((Some(vr), TrailingToken::MaybeComma))\n             },\n-        )\n+        ).map_err(|mut err|{\n+            err.help(\"enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\");\n+            err\n+        })\n     }\n \n     /// Parses `struct Foo { ... }`.\n@@ -2123,11 +2127,26 @@ impl<'a> Parser<'a> {\n         vis: &Visibility,\n         case: Case,\n     ) -> PResult<'a, (Ident, FnSig, Generics, Option<P<Block>>)> {\n+        let fn_span = self.token.span;\n         let header = self.parse_fn_front_matter(vis, case)?; // `const ... fn`\n         let ident = self.parse_ident()?; // `foo`\n         let mut generics = self.parse_generics()?; // `<'a, T, ...>`\n-        let decl =\n-            self.parse_fn_decl(fn_parse_mode.req_name, AllowPlus::Yes, RecoverReturnSign::Yes)?; // `(p: u8, ...)`\n+        let decl = match self.parse_fn_decl(\n+            fn_parse_mode.req_name,\n+            AllowPlus::Yes,\n+            RecoverReturnSign::Yes,\n+        ) {\n+            Ok(decl) => decl,\n+            Err(old_err) => {\n+                // If we see `for Ty ...` then user probably meant `impl` item.\n+                if self.token.is_keyword(kw::For) {\n+                    old_err.cancel();\n+                    return Err(self.sess.create_err(FnTypoWithImpl { fn_span }));\n+                } else {\n+                    return Err(old_err);\n+                }\n+            }\n+        };\n         generics.where_clause = self.parse_where_clause()?; // `where T: Ord`\n \n         let mut sig_hi = self.prev_token.span;"}, {"sha": "bebb012660a16ae140a780bb5da5049761bc0faa", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -943,6 +943,10 @@ impl<'a> Parser<'a> {\n                                 Err(e) => {\n                                     // Parsing failed, therefore it must be something more serious\n                                     // than just a missing separator.\n+                                    for xx in &e.children {\n+                                        // propagate the help message from sub error 'e' to main error 'expect_err;\n+                                        expect_err.children.push(xx.clone());\n+                                    }\n                                     expect_err.emit();\n \n                                     e.cancel();"}, {"sha": "a71ae717a508d37ee42db75d1a5add8a994fac0b", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -124,7 +124,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     fn handle_field_access(&mut self, lhs: &hir::Expr<'_>, hir_id: hir::HirId) {\n         match self.typeck_results().expr_ty_adjusted(lhs).kind() {\n             ty::Adt(def, _) => {\n-                let index = self.tcx.field_index(hir_id, self.typeck_results());\n+                let index = self.typeck_results().field_index(hir_id);\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n             ty::Tuple(..) => {}\n@@ -208,7 +208,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n             if let PatKind::Wild = pat.pat.kind {\n                 continue;\n             }\n-            let index = self.tcx.field_index(pat.hir_id, self.typeck_results());\n+            let index = self.typeck_results().field_index(pat.hir_id);\n             self.insert_def_id(variant.fields[index].did);\n         }\n     }\n@@ -341,7 +341,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     fn mark_as_used_if_union(&mut self, adt: ty::AdtDef<'tcx>, fields: &[hir::ExprField<'_>]) {\n         if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did().is_local() {\n             for field in fields {\n-                let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n+                let index = self.typeck_results().field_index(field.hir_id);\n                 self.insert_def_id(adt.non_enum_variant().fields[index].did);\n             }\n         }"}, {"sha": "1f65cc8b6096775368cd47562ecf3e55cf48ea4b", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1548,7 +1548,13 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 .or_insert_with(|| (ln, var, vec![id_and_sp]));\n         });\n \n-        let can_remove = matches!(&pat.kind, hir::PatKind::Struct(_, _, true));\n+        let can_remove = match pat.kind {\n+            hir::PatKind::Struct(_, fields, true) => {\n+                // if all fields are shorthand, remove the struct field, otherwise, mark with _ as prefix\n+                fields.iter().all(|f| f.is_shorthand)\n+            }\n+            _ => false,\n+        };\n \n         for (_, (ln, var, hir_ids_and_spans)) in vars {\n             if self.used_on_entry(ln, var) {"}, {"sha": "a254c892478cf19815f2ccf79e670f3db96f08dd", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1065,9 +1065,9 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n                 // are checked for privacy (RFC 736). Rather than computing the set of\n                 // unmentioned fields, just check them all.\n                 for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n-                    let field = fields.iter().find(|f| {\n-                        self.tcx.field_index(f.hir_id, self.typeck_results()) == vf_index\n-                    });\n+                    let field = fields\n+                        .iter()\n+                        .find(|f| self.typeck_results().field_index(f.hir_id) == vf_index);\n                     let (use_ctxt, span) = match field {\n                         Some(field) => (field.ident.span, field.span),\n                         None => (base.span, base.span),\n@@ -1077,7 +1077,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n             } else {\n                 for field in fields {\n                     let use_ctxt = field.ident.span;\n-                    let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n+                    let index = self.typeck_results().field_index(field.hir_id);\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n                 }\n             }\n@@ -1093,7 +1093,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n             let variant = adt.variant_of_res(res);\n             for field in fields {\n                 let use_ctxt = field.ident.span;\n-                let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n+                let index = self.typeck_results().field_index(field.hir_id);\n                 self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n             }\n         }"}, {"sha": "38c7c6cce67650680b967749481eee26dcbd1b9a", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -510,7 +510,7 @@ impl<K: DepKind> DepGraph<K> {\n         cx: Ctxt,\n         key: A,\n         result: &R,\n-        hash_result: fn(&mut StableHashingContext<'_>, &R) -> Fingerprint,\n+        hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n     ) -> DepNodeIndex {\n         if let Some(data) = self.data.as_ref() {\n             // The caller query has more dependencies than the node we are creating.  We may\n@@ -521,10 +521,12 @@ impl<K: DepKind> DepGraph<K> {\n             // For sanity, we still check that the loaded stable hash and the new one match.\n             if let Some(dep_node_index) = self.dep_node_index_of_opt(&node) {\n                 let _current_fingerprint =\n-                    crate::query::incremental_verify_ich(cx, result, &node, Some(hash_result));\n+                    crate::query::incremental_verify_ich(cx, result, &node, hash_result);\n \n                 #[cfg(debug_assertions)]\n-                data.current.record_edge(dep_node_index, node, _current_fingerprint);\n+                if hash_result.is_some() {\n+                    data.current.record_edge(dep_node_index, node, _current_fingerprint);\n+                }\n \n                 return dep_node_index;\n             }\n@@ -539,8 +541,9 @@ impl<K: DepKind> DepGraph<K> {\n             });\n \n             let hashing_timer = cx.profiler().incr_result_hashing();\n-            let current_fingerprint =\n-                cx.with_stable_hashing_context(|mut hcx| hash_result(&mut hcx, result));\n+            let current_fingerprint = hash_result.map(|hash_result| {\n+                cx.with_stable_hashing_context(|mut hcx| hash_result(&mut hcx, result))\n+            });\n \n             let print_status = cfg!(debug_assertions) && cx.sess().opts.unstable_opts.dep_tasks;\n \n@@ -550,7 +553,7 @@ impl<K: DepKind> DepGraph<K> {\n                 &data.previous,\n                 node,\n                 edges,\n-                Some(current_fingerprint),\n+                current_fingerprint,\n                 print_status,\n             );\n "}, {"sha": "cf3e5946053fe514f5b9195784e93e37d63e053f", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1927,7 +1927,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                 // We have a single lifetime => success.\n                                 elision_lifetime = Elision::Param(res)\n                             } else {\n-                                // We have have multiple lifetimes => error.\n+                                // We have multiple lifetimes => error.\n                                 elision_lifetime = Elision::Err;\n                             }\n                         }\n@@ -2360,8 +2360,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     if let GenericParamKind::Lifetime = param.kind {\n                         // Record lifetime res, so lowering knows there is something fishy.\n                         self.record_lifetime_param(param.id, LifetimeRes::Error);\n-                        continue;\n                     }\n+                    continue;\n                 }\n                 Entry::Vacant(entry) => {\n                     entry.insert(param.ident.span);"}, {"sha": "82f5d0f534a4bf76d6ca2e37bc7a83015abc92ca", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1196,7 +1196,7 @@ impl<'a> Resolver<'a> {\n     pub fn new(\n         session: &'a Session,\n         krate: &Crate,\n-        crate_name: &str,\n+        crate_name: Symbol,\n         metadata_loader: Box<MetadataLoaderDyn>,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a> {"}, {"sha": "9ae07cb005bd41b0db70ee91e528cf9db13bd741", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -111,7 +111,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.save_ctxt.lookup_def_id(ref_id)\n     }\n \n-    pub fn dump_crate_info(&mut self, name: &str) {\n+    pub fn dump_crate_info(&mut self, name: Symbol) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n             let source_file = Path::new(source_file);\n@@ -124,7 +124,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n \n         let data = CratePreludeData {\n             crate_id: GlobalCrateId {\n-                name: name.into(),\n+                name: name.to_string(),\n                 disambiguator: (self.tcx.sess.local_stable_crate_id().to_u64(), 0),\n             },\n             crate_root: crate_root.unwrap_or_else(|| \"<no source>\".to_owned()),\n@@ -135,7 +135,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.dumper.crate_prelude(data);\n     }\n \n-    pub fn dump_compilation_options(&mut self, input: &Input, crate_name: &str) {\n+    pub fn dump_compilation_options(&mut self, input: &Input, crate_name: Symbol) {\n         // Apply possible `remap-path-prefix` remapping to the input source file\n         // (and don't include remapping args anymore)\n         let (program, arguments) = {"}, {"sha": "7735c571310dd2c4e3018026b956d08e23334754", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -95,7 +95,7 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     /// Returns path to the compilation output (e.g., libfoo-12345678.rmeta)\n-    pub fn compilation_output(&self, crate_name: &str) -> PathBuf {\n+    pub fn compilation_output(&self, crate_name: Symbol) -> PathBuf {\n         let sess = &self.tcx.sess;\n         // Save-analysis is emitted per whole session, not per each crate type\n         let crate_type = sess.crate_types()[0];\n@@ -894,8 +894,8 @@ pub struct DumpHandler<'a> {\n }\n \n impl<'a> DumpHandler<'a> {\n-    pub fn new(odir: Option<&'a Path>, cratename: &str) -> DumpHandler<'a> {\n-        DumpHandler { odir, cratename: cratename.to_owned() }\n+    pub fn new(odir: Option<&'a Path>, cratename: Symbol) -> DumpHandler<'a> {\n+        DumpHandler { odir, cratename: cratename.to_string() }\n     }\n \n     fn output_file(&self, ctx: &SaveContext<'_>) -> (BufWriter<File>, PathBuf) {\n@@ -960,7 +960,7 @@ impl SaveHandler for CallbackHandler<'_> {\n \n pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n     tcx: TyCtxt<'tcx>,\n-    cratename: &str,\n+    cratename: Symbol,\n     input: &'l Input,\n     config: Option<Config>,\n     mut handler: H,"}, {"sha": "cbbba2252bf600b34b61a783c49c1bded1891f22", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -18,6 +18,7 @@ rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n smallvec = \"1.8.1\"\n+termize = \"0.1.1\"\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\""}, {"sha": "7a20100fd313368ebe24f86e539789af442ed514", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -10,7 +10,7 @@ use crate::{lint, HashStableContext};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n-use rustc_data_structures::stable_hasher::ToStableHashKey;\n+use rustc_data_structures::stable_hasher::{StableOrd, ToStableHashKey};\n use rustc_target::abi::Align;\n use rustc_target::spec::{PanicStrategy, SanitizerSet, SplitDebuginfo};\n use rustc_target::spec::{Target, TargetTriple, TargetWarnings, TARGETS};\n@@ -288,6 +288,9 @@ pub enum OutputType {\n     DepInfo,\n }\n \n+// Safety: Trivial C-Style enums have a stable sort order across compilation sessions.\n+unsafe impl StableOrd for OutputType {}\n+\n impl<HCX: HashStableContext> ToStableHashKey<HCX> for OutputType {\n     type KeyType = Self;\n "}, {"sha": "ee492f802a70c08d21fcd119dc81755cb307aa4e", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -129,10 +129,10 @@ pub struct FileIsNotWriteable<'a> {\n \n #[derive(Diagnostic)]\n #[diag(session_crate_name_does_not_match)]\n-pub struct CrateNameDoesNotMatch<'a> {\n+pub struct CrateNameDoesNotMatch {\n     #[primary_span]\n     pub span: Span,\n-    pub s: &'a str,\n+    pub s: Symbol,\n     pub name: Symbol,\n }\n \n@@ -151,11 +151,11 @@ pub struct CrateNameEmpty {\n \n #[derive(Diagnostic)]\n #[diag(session_invalid_character_in_create_name)]\n-pub struct InvalidCharacterInCrateName<'a> {\n+pub struct InvalidCharacterInCrateName {\n     #[primary_span]\n     pub span: Option<Span>,\n     pub character: char,\n-    pub crate_name: &'a str,\n+    pub crate_name: Symbol,\n }\n \n #[derive(Subdiagnostic)]"}, {"sha": "8e9198b79dff7cb39284333ad0f1fe6f53e27d78", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1382,6 +1382,9 @@ options! {\n         \"list the symbols defined by a library crate (default: no)\"),\n     macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n         \"show macro backtraces (default: no)\"),\n+    maximal_hir_to_mir_coverage: bool = (false, parse_bool, [TRACKED],\n+        \"save as much information as possible about the correspondence between MIR and HIR \\\n+        as source scopes (default: no)\"),\n     merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n         \"control the operation of the MergeFunctions LLVM pass, taking \\\n         the same values as the target option of the same name\"),"}, {"sha": "8ee3057de625ef3b08c9faad46c824ae9c685130", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -7,14 +7,14 @@ use crate::errors::{\n use crate::Session;\n use rustc_ast as ast;\n use rustc_span::symbol::sym;\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use std::path::{Path, PathBuf};\n \n pub fn out_filename(\n     sess: &Session,\n     crate_type: CrateType,\n     outputs: &OutputFilenames,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> PathBuf {\n     let default_filename = filename_for_input(sess, crate_type, crate_name, outputs);\n     let out_filename = outputs\n@@ -45,9 +45,9 @@ fn is_writeable(p: &Path) -> bool {\n     }\n }\n \n-pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input) -> String {\n-    let validate = |s: String, span: Option<Span>| {\n-        validate_crate_name(sess, &s, span);\n+pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input) -> Symbol {\n+    let validate = |s: Symbol, span: Option<Span>| {\n+        validate_crate_name(sess, s, span);\n         s\n     };\n \n@@ -59,38 +59,39 @@ pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input)\n         sess.find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(ref s) = sess.opts.crate_name {\n+        let s = Symbol::intern(s);\n         if let Some((attr, name)) = attr_crate_name {\n-            if name.as_str() != s {\n+            if name != s {\n                 sess.emit_err(CrateNameDoesNotMatch { span: attr.span, s, name });\n             }\n         }\n-        return validate(s.clone(), None);\n+        return validate(s, None);\n     }\n \n     if let Some((attr, s)) = attr_crate_name {\n-        return validate(s.to_string(), Some(attr.span));\n+        return validate(s, Some(attr.span));\n     }\n     if let Input::File(ref path) = *input {\n         if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n             if s.starts_with('-') {\n                 sess.emit_err(CrateNameInvalid { s });\n             } else {\n-                return validate(s.replace('-', \"_\"), None);\n+                return validate(Symbol::intern(&s.replace('-', \"_\")), None);\n             }\n         }\n     }\n \n-    \"rust_out\".to_string()\n+    Symbol::intern(\"rust_out\")\n }\n \n-pub fn validate_crate_name(sess: &Session, s: &str, sp: Option<Span>) {\n+pub fn validate_crate_name(sess: &Session, s: Symbol, sp: Option<Span>) {\n     let mut err_count = 0;\n     {\n         if s.is_empty() {\n             err_count += 1;\n             sess.emit_err(CrateNameEmpty { span: sp });\n         }\n-        for c in s.chars() {\n+        for c in s.as_str().chars() {\n             if c.is_alphanumeric() {\n                 continue;\n             }\n@@ -109,7 +110,7 @@ pub fn validate_crate_name(sess: &Session, s: &str, sp: Option<Span>) {\n \n pub fn filename_for_metadata(\n     sess: &Session,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     outputs: &OutputFilenames,\n ) -> PathBuf {\n     // If the command-line specified the path, use that directly.\n@@ -132,7 +133,7 @@ pub fn filename_for_metadata(\n pub fn filename_for_input(\n     sess: &Session,\n     crate_type: CrateType,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     outputs: &OutputFilenames,\n ) -> PathBuf {\n     let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);"}, {"sha": "4c049a8d628ef0e4336f111cb57c49fddbd3166d", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -952,6 +952,17 @@ impl Session {\n     ) -> Option<Symbol> {\n         attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n     }\n+\n+    pub fn diagnostic_width(&self) -> usize {\n+        let default_column_width = 140;\n+        if let Some(width) = self.opts.diagnostic_width {\n+            width\n+        } else if self.opts.unstable_opts.ui_testing {\n+            default_column_width\n+        } else {\n+            termize::dimensions().map_or(default_column_width, |(w, _)| w)\n+        }\n+    }\n }\n \n // JUSTIFICATION: defn of the suggested wrapper fns"}, {"sha": "e62ce2c266aa04ca507edd377ab92672d193a336", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,4 +1,4 @@\n-use crate::HashStableContext;\n+use crate::{HashStableContext, Symbol};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_data_structures::AtomicRef;\n@@ -149,9 +149,11 @@ impl StableCrateId {\n \n     /// Computes the stable ID for a crate with the given name and\n     /// `-Cmetadata` arguments.\n-    pub fn new(crate_name: &str, is_exe: bool, mut metadata: Vec<String>) -> StableCrateId {\n+    pub fn new(crate_name: Symbol, is_exe: bool, mut metadata: Vec<String>) -> StableCrateId {\n         let mut hasher = StableHasher::new();\n-        crate_name.hash(&mut hasher);\n+        // We must hash the string text of the crate name, not the id, as the id is not stable\n+        // across builds.\n+        crate_name.as_str().hash(&mut hasher);\n \n         // We don't want the stable crate ID to depend on the order of\n         // -C metadata arguments, so sort them:\n@@ -274,7 +276,7 @@ impl Ord for DefId {\n impl PartialOrd for DefId {\n     #[inline]\n     fn partial_cmp(&self, other: &DefId) -> Option<std::cmp::Ordering> {\n-        Some(Ord::cmp(self, other))\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "61253845497238c664ac8116ae14f4b29be7f12f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -165,6 +165,7 @@ symbols! {\n         Capture,\n         Center,\n         Clone,\n+        Context,\n         Continue,\n         Copy,\n         Count,\n@@ -264,7 +265,6 @@ symbols! {\n         Relaxed,\n         Release,\n         Result,\n-        ResumeTy,\n         Return,\n         Right,\n         Rust,\n@@ -754,7 +754,6 @@ symbols! {\n         generic_associated_types_extended,\n         generic_const_exprs,\n         generic_param_attrs,\n-        get_context,\n         global_allocator,\n         global_asm,\n         globs,"}, {"sha": "06529c2e4039d768b198ecac3558adaf95cda447", "filename": "compiler/rustc_target/src/spec/wasm32_unknown_unknown.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_unknown.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -33,12 +33,6 @@ pub fn target() -> Target {\n             // For now this target just never has an entry symbol no matter the output\n             // type, so unconditionally pass this.\n             \"--no-entry\",\n-            // Rust really needs a way for users to specify exports and imports in\n-            // the source code. --export-dynamic isn't the right tool for this job,\n-            // however it does have the side effect of automatically exporting a lot\n-            // of symbols, which approximates what people want when compiling for\n-            // wasm32-unknown-unknown expect, so use it for now.\n-            \"--export-dynamic\",\n         ],\n     );\n     options.add_pre_link_args(\n@@ -48,7 +42,6 @@ pub fn target() -> Target {\n             // otherwise\n             \"--target=wasm32-unknown-unknown\",\n             \"-Wl,--no-entry\",\n-            \"-Wl,--export-dynamic\",\n         ],\n     );\n "}, {"sha": "0102d268b42e18b51e558247d042f9120092fabd", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -70,7 +70,7 @@ pub fn codegen_select_candidate<'tcx>(\n         // `rustc_ty_utils::resolve_associated_item` doesn't return `None` post-monomorphization.\n         for err in errors {\n             if let FulfillmentErrorCode::CodeCycle(cycle) = err.code {\n-                infcx.err_ctxt().report_overflow_error_cycle(&cycle);\n+                infcx.err_ctxt().report_overflow_obligation_cycle(&cycle);\n             }\n         }\n         return Err(CodegenObligationError::FulfillmentError);"}, {"sha": "7c9fde27420bc2b12ba79a6d08083b507dc2b8ec", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -25,15 +25,13 @@ use crate::traits::ObligationCtxt;\n #[instrument(skip(infcx), level = \"debug\")]\n pub fn is_const_evaluatable<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n-    ct: ty::Const<'tcx>,\n+    unexpanded_ct: ty::Const<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n ) -> Result<(), NotConstEvaluatable> {\n     let tcx = infcx.tcx;\n-    let uv = match ct.kind() {\n-        ty::ConstKind::Unevaluated(uv) => uv,\n-        // FIXME(generic_const_exprs): this seems wrong but I couldn't find a way to get this to trigger\n-        ty::ConstKind::Expr(_) => bug!(\"unexpected expr in `is_const_evaluatable: {ct:?}\"),\n+    match tcx.expand_abstract_consts(unexpanded_ct).kind() {\n+        ty::ConstKind::Unevaluated(_) | ty::ConstKind::Expr(_) => (),\n         ty::ConstKind::Param(_)\n         | ty::ConstKind::Bound(_, _)\n         | ty::ConstKind::Placeholder(_)\n@@ -43,7 +41,7 @@ pub fn is_const_evaluatable<'tcx>(\n     };\n \n     if tcx.features().generic_const_exprs {\n-        let ct = tcx.expand_abstract_consts(ct);\n+        let ct = tcx.expand_abstract_consts(unexpanded_ct);\n \n         let is_anon_ct = if let ty::ConstKind::Unevaluated(uv) = ct.kind() {\n             tcx.def_kind(uv.def.did) == DefKind::AnonConst\n@@ -62,18 +60,40 @@ pub fn is_const_evaluatable<'tcx>(\n             }\n         }\n \n-        let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n-        match concrete {\n-            Err(ErrorHandled::TooGeneric) => Err(NotConstEvaluatable::Error(\n-                infcx\n-                    .tcx\n-                    .sess\n-                    .delay_span_bug(span, \"Missing value for constant, but no error reported?\"),\n-            )),\n-            Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n-            Ok(_) => Ok(()),\n+        match unexpanded_ct.kind() {\n+            ty::ConstKind::Expr(_) => {\n+                // FIXME(generic_const_exprs): we have a `ConstKind::Expr` which is fully concrete, but\n+                // currently it is not possible to evaluate `ConstKind::Expr` so we are unable to tell if it\n+                // is evaluatable or not. For now we just ICE until this is implemented.\n+                Err(NotConstEvaluatable::Error(tcx.sess.delay_span_bug(\n+                    span,\n+                    \"evaluating `ConstKind::Expr` is not currently supported\",\n+                )))\n+            }\n+            ty::ConstKind::Unevaluated(uv) => {\n+                let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n+                match concrete {\n+                    Err(ErrorHandled::TooGeneric) => {\n+                        Err(NotConstEvaluatable::Error(infcx.tcx.sess.delay_span_bug(\n+                            span,\n+                            \"Missing value for constant, but no error reported?\",\n+                        )))\n+                    }\n+                    Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n+                    Ok(_) => Ok(()),\n+                }\n+            }\n+            _ => bug!(\"unexpected constkind in `is_const_evalautable: {unexpanded_ct:?}`\"),\n         }\n     } else {\n+        let uv = match unexpanded_ct.kind() {\n+            ty::ConstKind::Unevaluated(uv) => uv,\n+            ty::ConstKind::Expr(_) => {\n+                bug!(\"`ConstKind::Expr` without `feature(generic_const_exprs)` enabled\")\n+            }\n+            _ => bug!(\"unexpected constkind in `is_const_evalautable: {unexpanded_ct:?}`\"),\n+        };\n+\n         // FIXME: We should only try to evaluate a given constant here if it is fully concrete\n         // as we don't want to allow things like `[u8; std::mem::size_of::<*mut T>()]`.\n         //\n@@ -92,7 +112,7 @@ pub fn is_const_evaluatable<'tcx>(\n                     && satisfied_from_param_env(\n                         tcx,\n                         infcx,\n-                        tcx.expand_abstract_consts(ct),\n+                        tcx.expand_abstract_consts(unexpanded_ct),\n                         param_env,\n                     ) =>\n             {\n@@ -152,6 +172,7 @@ fn satisfied_from_param_env<'tcx>(\n     impl<'a, 'tcx> TypeVisitor<'tcx> for Visitor<'a, 'tcx> {\n         type BreakTy = ();\n         fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            debug!(\"is_const_evaluatable: candidate={:?}\", c);\n             if let Ok(()) = self.infcx.commit_if_ok(|_| {\n                 let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n                 if let Ok(()) = ocx.eq(&ObligationCause::dummy(), self.param_env, c.ty(), self.ct.ty())\n@@ -187,13 +208,14 @@ fn satisfied_from_param_env<'tcx>(\n                 let result = b_ct.visit_with(&mut v);\n \n                 if let ControlFlow::Break(()) = result {\n-                    debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                    debug!(\"is_const_evaluatable: yes\");\n                     return true;\n                 }\n             }\n             _ => {} // don't care\n         }\n     }\n \n+    debug!(\"is_const_evaluatable: no\");\n     false\n }"}, {"sha": "dda7b2b2fa5b0b392ce3d19f080c236152a8284e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 74, "deletions": 24, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -99,26 +99,36 @@ pub trait InferCtxtExt<'tcx> {\n }\n \n pub trait TypeErrCtxtExt<'tcx> {\n+    fn report_overflow_error<T>(\n+        &self,\n+        predicate: &T,\n+        span: Span,\n+        suggest_increasing_limit: bool,\n+        mutate: impl FnOnce(&mut Diagnostic),\n+    ) -> !\n+    where\n+        T: fmt::Display\n+            + TypeFoldable<'tcx>\n+            + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n+        <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug;\n+\n     fn report_fulfillment_errors(\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n         body_id: Option<hir::BodyId>,\n     ) -> ErrorGuaranteed;\n \n-    fn report_overflow_error<T>(\n+    fn report_overflow_obligation<T>(\n         &self,\n         obligation: &Obligation<'tcx, T>,\n         suggest_increasing_limit: bool,\n     ) -> !\n     where\n-        T: fmt::Display\n-            + TypeFoldable<'tcx>\n-            + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n-        <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug;\n+        T: ToPredicate<'tcx> + Clone;\n \n     fn suggest_new_overflow_limit(&self, err: &mut Diagnostic);\n \n-    fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> !;\n+    fn report_overflow_obligation_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> !;\n \n     /// The `root_obligation` parameter should be the `root_obligation` field\n     /// from a `FulfillmentError`. If no `FulfillmentError` is available,\n@@ -458,17 +468,20 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     /// occurrences in any case.\n     fn report_overflow_error<T>(\n         &self,\n-        obligation: &Obligation<'tcx, T>,\n+        predicate: &T,\n+        span: Span,\n         suggest_increasing_limit: bool,\n+        mutate: impl FnOnce(&mut Diagnostic),\n     ) -> !\n     where\n         T: fmt::Display\n             + TypeFoldable<'tcx>\n             + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n         <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug,\n     {\n-        let predicate = self.resolve_vars_if_possible(obligation.predicate.clone());\n+        let predicate = self.resolve_vars_if_possible(predicate.clone());\n         let mut pred_str = predicate.to_string();\n+\n         if pred_str.len() > 50 {\n             // We don't need to save the type to a file, we will be talking about this type already\n             // in a separate note when we explain the obligation, so it will be available that way.\n@@ -483,7 +496,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n-            obligation.cause.span,\n+            span,\n             E0275,\n             \"overflow evaluating the requirement `{}`\",\n             pred_str,\n@@ -493,20 +506,46 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             self.suggest_new_overflow_limit(&mut err);\n         }\n \n-        self.note_obligation_cause_code(\n-            &mut err,\n-            &obligation.predicate,\n-            obligation.param_env,\n-            obligation.cause.code(),\n-            &mut vec![],\n-            &mut Default::default(),\n-        );\n+        mutate(&mut err);\n \n         err.emit();\n         self.tcx.sess.abort_if_errors();\n         bug!();\n     }\n \n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    fn report_overflow_obligation<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: ToPredicate<'tcx> + Clone,\n+    {\n+        let predicate = obligation.predicate.clone().to_predicate(self.tcx);\n+        let predicate = self.resolve_vars_if_possible(predicate);\n+        self.report_overflow_error(\n+            &predicate,\n+            obligation.cause.span,\n+            suggest_increasing_limit,\n+            |err| {\n+                self.note_obligation_cause_code(\n+                    err,\n+                    &predicate,\n+                    obligation.param_env,\n+                    obligation.cause.code(),\n+                    &mut vec![],\n+                    &mut Default::default(),\n+                );\n+            },\n+        );\n+    }\n+\n     fn suggest_new_overflow_limit(&self, err: &mut Diagnostic) {\n         let suggested_limit = match self.tcx.recursion_limit() {\n             Limit(0) => Limit(2),\n@@ -521,19 +560,22 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     }\n \n     /// Reports that a cycle was detected which led to overflow and halts\n-    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// compilation. This is equivalent to `report_overflow_obligation` except\n     /// that we can give a more helpful error message (and, in particular,\n     /// we do not suggest increasing the overflow limit, which is not\n     /// going to help).\n-    fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+    fn report_overflow_obligation_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n         let cycle = self.resolve_vars_if_possible(cycle.to_owned());\n         assert!(!cycle.is_empty());\n \n         debug!(?cycle, \"report_overflow_error_cycle\");\n \n         // The 'deepest' obligation is most likely to have a useful\n         // cause 'backtrace'\n-        self.report_overflow_error(cycle.iter().max_by_key(|p| p.recursion_depth).unwrap(), false);\n+        self.report_overflow_obligation(\n+            cycle.iter().max_by_key(|p| p.recursion_depth).unwrap(),\n+            false,\n+        );\n     }\n \n     fn report_selection_error(\n@@ -1554,7 +1596,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 diag.emit();\n             }\n             FulfillmentErrorCode::CodeCycle(ref cycle) => {\n-                self.report_overflow_error_cycle(cycle);\n+                self.report_overflow_obligation_cycle(cycle);\n             }\n         }\n     }\n@@ -1607,7 +1649,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         | ObligationCauseCode::ObjectCastObligation(..)\n                         | ObligationCauseCode::OpaqueType\n                 );\n-                let expected_ty = data.term.ty().unwrap();\n+                let expected_ty = data.term.ty().unwrap_or_else(|| self.tcx.ty_error());\n \n                 // constrain inference variables a bit more to nested obligations from normalize so\n                 // we can have more helpful errors.\n@@ -1810,7 +1852,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         &self,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> Vec<ImplCandidate<'tcx>> {\n-        self.tcx\n+        let mut candidates: Vec<_> = self\n+            .tcx\n             .all_impls(trait_pred.def_id())\n             .filter_map(|def_id| {\n                 if self.tcx.impl_polarity(def_id) == ty::ImplPolarity::Negative\n@@ -1826,7 +1869,14 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 self.fuzzy_match_tys(trait_pred.skip_binder().self_ty(), imp.self_ty(), false)\n                     .map(|similarity| ImplCandidate { trait_ref: imp, similarity })\n             })\n-            .collect()\n+            .collect();\n+        if candidates.iter().any(|c| matches!(c.similarity, CandidateSimilarity::Exact { .. })) {\n+            // If any of the candidates is a perfect match, we don't want to show all of them.\n+            // This is particularly relevant for the case of numeric types (as they all have the\n+            // same cathegory).\n+            candidates.retain(|c| matches!(c.similarity, CandidateSimilarity::Exact { .. }));\n+        }\n+        candidates\n     }\n \n     fn report_similar_impl_candidates("}, {"sha": "6ea54b625bbc0f8e533de1fabf88c6ad5f9dcdbc", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -298,7 +298,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display + ToPredicate<'tcx, T>;\n+        T: fmt::Display + ToPredicate<'tcx>;\n \n     /// Suggest to await before try: future? => future.await?\n     fn suggest_await_before_try(\n@@ -2353,7 +2353,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display,\n+        T: fmt::Display + ToPredicate<'tcx>,\n     {\n         let tcx = self.tcx;\n         match *cause_code {"}, {"sha": "d3cfd61e1956d7d82fd433772f0dd2275995a6b2", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -150,7 +150,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n fn pred_known_to_hold_modulo_regions<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    pred: impl ToPredicate<'tcx, ty::Predicate<'tcx>> + TypeVisitable<'tcx>,\n+    pred: impl ToPredicate<'tcx> + TypeVisitable<'tcx>,\n     span: Span,\n ) -> bool {\n     let has_non_region_infer = pred.has_non_region_infer();"}, {"sha": "5789754e4fcefd6f19fa458f1f80cd5e4d7e5445", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -504,14 +504,12 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                     Reveal::All => {\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.depth) {\n-                            let obligation = Obligation::with_depth(\n-                                self.tcx(),\n-                                self.cause.clone(),\n-                                recursion_limit.0,\n-                                self.param_env,\n-                                ty,\n+                            self.selcx.infcx.err_ctxt().report_overflow_error(\n+                                &ty,\n+                                self.cause.span,\n+                                true,\n+                                |_| {},\n                             );\n-                            self.selcx.infcx.err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let substs = substs.fold_with(self);\n@@ -2321,11 +2319,10 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n     nested: &mut Vec<PredicateObligation<'tcx>>,\n ) {\n     let tcx = selcx.tcx();\n-    for predicate in tcx\n+    let own = tcx\n         .predicates_of(obligation.predicate.item_def_id)\n-        .instantiate_own(tcx, obligation.predicate.substs)\n-        .predicates\n-    {\n+        .instantiate_own(tcx, obligation.predicate.substs);\n+    for (predicate, span) in std::iter::zip(own.predicates, own.spans) {\n         let normalized = normalize_with_depth_to(\n             selcx,\n             obligation.param_env,\n@@ -2334,9 +2331,30 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n             predicate,\n             nested,\n         );\n+\n+        let nested_cause = if matches!(\n+            obligation.cause.code(),\n+            super::CompareImplItemObligation { .. }\n+                | super::CheckAssociatedTypeBounds { .. }\n+                | super::AscribeUserTypeProvePredicate(..)\n+        ) {\n+            obligation.cause.clone()\n+        } else if span.is_dummy() {\n+            ObligationCause::new(\n+                obligation.cause.span,\n+                obligation.cause.body_id,\n+                super::ItemObligation(obligation.predicate.item_def_id),\n+            )\n+        } else {\n+            ObligationCause::new(\n+                obligation.cause.span,\n+                obligation.cause.body_id,\n+                super::BindingObligation(obligation.predicate.item_def_id, span),\n+            )\n+        };\n         nested.push(Obligation::with_depth(\n             tcx,\n-            obligation.cause.clone(),\n+            nested_cause,\n             obligation.recursion_depth + 1,\n             obligation.param_env,\n             normalized,"}, {"sha": "7ad532d8a34645544996dd1930fbf45284d9d1b7", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -7,7 +7,7 @@ use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::{needs_normalization, BoundVarReplacer, PlaceholderReplacer};\n-use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n+use crate::traits::{ObligationCause, PredicateObligation, Reveal};\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_infer::traits::Normalized;\n@@ -214,14 +214,12 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         let substs = substs.try_fold_with(self)?;\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.anon_depth) {\n-                            let obligation = Obligation::with_depth(\n-                                self.tcx(),\n-                                self.cause.clone(),\n-                                recursion_limit.0,\n-                                self.param_env,\n-                                ty,\n+                            self.infcx.err_ctxt().report_overflow_error(\n+                                &ty,\n+                                self.cause.span,\n+                                true,\n+                                |_| {},\n                             );\n-                            self.infcx.err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let generic_ty = self.tcx().bound_type_of(def_id);"}, {"sha": "035deb61639817c57d897a9ffdcb75db304aacaa", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -43,7 +43,6 @@ use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::fold::BottomUpFolder;\n-use rustc_middle::ty::print::{FmtPrinter, Print};\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, EarlyBinder, PolyProjectionPredicate, ToPolyTraitRef, ToPredicate};\n@@ -1313,18 +1312,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         error_obligation: &Obligation<'tcx, T>,\n     ) -> Result<(), OverflowError>\n     where\n-        T: fmt::Display\n-            + TypeFoldable<'tcx>\n-            + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n-        <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug,\n+        T: ToPredicate<'tcx> + Clone,\n     {\n         if !self.infcx.tcx.recursion_limit().value_within_limit(depth) {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n                     if let Some(e) = self.infcx.tainted_by_errors() {\n                         return Err(OverflowError::Error(e));\n                     }\n-                    self.infcx.err_ctxt().report_overflow_error(error_obligation, true);\n+                    self.infcx.err_ctxt().report_overflow_obligation(error_obligation, true);\n                 }\n                 TraitQueryMode::Canonical => {\n                     return Err(OverflowError::Canonical);\n@@ -1345,10 +1341,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         error_obligation: &Obligation<'tcx, V>,\n     ) -> Result<(), OverflowError>\n     where\n-        V: fmt::Display\n-            + TypeFoldable<'tcx>\n-            + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n-        <V as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug,\n+        V: ToPredicate<'tcx> + Clone,\n     {\n         self.check_recursion_depth(obligation.recursion_depth, error_obligation)\n     }"}, {"sha": "e47ba64245f50732f0b95a7eddf143b5341bc555", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -476,9 +476,24 @@ impl<'tcx> WfPredicates<'tcx> {\n                                 ty::Binder::dummy(ty::PredicateKind::WellFormed(ct.into())),\n                             ));\n                         }\n-                        // FIXME(generic_const_exprs): This seems wrong but I could not find a way to get this to trigger\n                         ty::ConstKind::Expr(_) => {\n-                            bug!(\"checking wfness of `ConstKind::Expr` is unsupported\")\n+                            // FIXME(generic_const_exprs): this doesnt verify that given `Expr(N + 1)` the\n+                            // trait bound `typeof(N): Add<typeof(1)>` holds. This is currently unnecessary\n+                            // as `ConstKind::Expr` is only produced via normalization of `ConstKind::Unevaluated`\n+                            // which means that the `DefId` would have been typeck'd elsewhere. However in\n+                            // the future we may allow directly lowering to `ConstKind::Expr` in which case\n+                            // we would not be proving bounds we should.\n+\n+                            let predicate =\n+                                ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ct));\n+                            let cause = self.cause(traits::WellFormed(None));\n+                            self.out.push(traits::Obligation::with_depth(\n+                                self.tcx(),\n+                                cause,\n+                                self.recursion_depth,\n+                                self.param_env,\n+                                predicate,\n+                            ));\n                         }\n \n                         ty::ConstKind::Error(_)"}, {"sha": "e3f7a1bd033cea39b7ed706a45ed49ce7e8474e6", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -19,9 +19,11 @@ use std::mem::discriminant;\n \n pub mod codec;\n pub mod sty;\n+pub mod ty_info;\n \n pub use codec::*;\n pub use sty::*;\n+pub use ty_info::*;\n \n /// Needed so we can use #[derive(HashStable_Generic)]\n pub trait HashStableContext {}"}, {"sha": "3ed616d709b1edf4e1b38933c8002417eea0fb67", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 212, "deletions": 370, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -301,61 +301,44 @@ impl<I: Interner> Clone for TyKind<I> {\n impl<I: Interner> PartialEq for TyKind<I> {\n     #[inline]\n     fn eq(&self, other: &TyKind<I>) -> bool {\n-        let __self_vi = tykind_discriminant(self);\n-        let __arg_1_vi = tykind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&Int(ref __self_0), &Int(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Float(ref __self_0), &Float(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+        tykind_discriminant(self) == tykind_discriminant(other)\n+            && match (self, other) {\n+                (Int(a_i), Int(b_i)) => a_i == b_i,\n+                (Uint(a_u), Uint(b_u)) => a_u == b_u,\n+                (Float(a_f), Float(b_f)) => a_f == b_f,\n+                (Adt(a_d, a_s), Adt(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Foreign(a_d), Foreign(b_d)) => a_d == b_d,\n+                (Array(a_t, a_c), Array(b_t, b_c)) => a_t == b_t && a_c == b_c,\n+                (Slice(a_t), Slice(b_t)) => a_t == b_t,\n+                (RawPtr(a_t), RawPtr(b_t)) => a_t == b_t,\n+                (Ref(a_r, a_t, a_m), Ref(b_r, b_t, b_m)) => a_r == b_r && a_t == b_t && a_m == b_m,\n+                (FnDef(a_d, a_s), FnDef(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (FnPtr(a_s), FnPtr(b_s)) => a_s == b_s,\n+                (Dynamic(a_p, a_r, a_repr), Dynamic(b_p, b_r, b_repr)) => {\n+                    a_p == b_p && a_r == b_r && a_repr == b_repr\n                 }\n-                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                (Closure(a_d, a_s), Closure(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Generator(a_d, a_s, a_m), Generator(b_d, b_s, b_m)) => {\n+                    a_d == b_d && a_s == b_s && a_m == b_m\n                 }\n-                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (\n-                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n-                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n-                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g == b_g,\n+                (Tuple(a_t), Tuple(b_t)) => a_t == b_t,\n+                (Projection(a_p), Projection(b_p)) => a_p == b_p,\n+                (Opaque(a_d, a_s), Opaque(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Param(a_p), Param(b_p)) => a_p == b_p,\n+                (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d == b_d && a_b == b_b,\n+                (Placeholder(a_p), Placeholder(b_p)) => a_p == b_p,\n+                (Infer(a_t), Infer(b_t)) => a_t == b_t,\n+                (Error(a_e), Error(b_e)) => a_e == b_e,\n+                (Bool, Bool) | (Char, Char) | (Str, Str) | (Never, Never) => true,\n+                _ => {\n+                    debug_assert!(\n+                        false,\n+                        \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\"\n+                    );\n+                    true\n                 }\n-                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (\n-                    &Dynamic(ref __self_0, ref __self_1, ref self_repr),\n-                    &Dynamic(ref __arg_1_0, ref __arg_1_1, ref arg_repr),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && self_repr == arg_repr,\n-                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (\n-                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n-                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n-                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n-                    __self_0 == __arg_1_0\n-                }\n-                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (&Param(ref __self_0), &Param(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Error(ref __self_0), &Error(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                _ => true,\n             }\n-        } else {\n-            false\n-        }\n     }\n }\n \n@@ -366,259 +349,149 @@ impl<I: Interner> Eq for TyKind<I> {}\n impl<I: Interner> PartialOrd for TyKind<I> {\n     #[inline]\n     fn partial_cmp(&self, other: &TyKind<I>) -> Option<Ordering> {\n-        Some(Ord::cmp(self, other))\n+        Some(self.cmp(other))\n     }\n }\n \n // This is manually implemented because a derive would require `I: Ord`\n impl<I: Interner> Ord for TyKind<I> {\n     #[inline]\n     fn cmp(&self, other: &TyKind<I>) -> Ordering {\n-        let __self_vi = tykind_discriminant(self);\n-        let __arg_1_vi = tykind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&Int(ref __self_0), &Int(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Float(ref __self_0), &Float(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (\n-                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n-                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n-                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n-                        cmp => cmp,\n-                    },\n-                    cmp => cmp,\n-                },\n-                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n+        tykind_discriminant(self).cmp(&tykind_discriminant(other)).then_with(|| {\n+            match (self, other) {\n+                (Int(a_i), Int(b_i)) => a_i.cmp(b_i),\n+                (Uint(a_u), Uint(b_u)) => a_u.cmp(b_u),\n+                (Float(a_f), Float(b_f)) => a_f.cmp(b_f),\n+                (Adt(a_d, a_s), Adt(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (Foreign(a_d), Foreign(b_d)) => a_d.cmp(b_d),\n+                (Array(a_t, a_c), Array(b_t, b_c)) => a_t.cmp(b_t).then_with(|| a_c.cmp(b_c)),\n+                (Slice(a_t), Slice(b_t)) => a_t.cmp(b_t),\n+                (RawPtr(a_t), RawPtr(b_t)) => a_t.cmp(b_t),\n+                (Ref(a_r, a_t, a_m), Ref(b_r, b_t, b_m)) => {\n+                    a_r.cmp(b_r).then_with(|| a_t.cmp(b_t).then_with(|| a_m.cmp(b_m)))\n                 }\n-                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (\n-                    &Dynamic(ref __self_0, ref __self_1, ref self_repr),\n-                    &Dynamic(ref __arg_1_0, ref __arg_1_1, ref arg_repr),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n-                        Ordering::Equal => Ord::cmp(self_repr, arg_repr),\n-                        cmp => cmp,\n-                    },\n-                    cmp => cmp,\n-                },\n-                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n+                (FnDef(a_d, a_s), FnDef(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (FnPtr(a_s), FnPtr(b_s)) => a_s.cmp(b_s),\n+                (Dynamic(a_p, a_r, a_repr), Dynamic(b_p, b_r, b_repr)) => {\n+                    a_p.cmp(b_p).then_with(|| a_r.cmp(b_r).then_with(|| a_repr.cmp(b_repr)))\n                 }\n-                (\n-                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n-                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n-                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n-                        cmp => cmp,\n-                    },\n-                    cmp => cmp,\n-                },\n-                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n+                (Closure(a_p, a_s), Closure(b_p, b_s)) => a_p.cmp(b_p).then_with(|| a_s.cmp(b_s)),\n+                (Generator(a_d, a_s, a_m), Generator(b_d, b_s, b_m)) => {\n+                    a_d.cmp(b_d).then_with(|| a_s.cmp(b_s).then_with(|| a_m.cmp(b_m)))\n                 }\n-                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n+                (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g.cmp(b_g),\n+                (Tuple(a_t), Tuple(b_t)) => a_t.cmp(b_t),\n+                (Projection(a_p), Projection(b_p)) => a_p.cmp(b_p),\n+                (Opaque(a_d, a_s), Opaque(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (Param(a_p), Param(b_p)) => a_p.cmp(b_p),\n+                (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d.cmp(b_d).then_with(|| a_b.cmp(b_b)),\n+                (Placeholder(a_p), Placeholder(b_p)) => a_p.cmp(b_p),\n+                (Infer(a_t), Infer(b_t)) => a_t.cmp(b_t),\n+                (Error(a_e), Error(b_e)) => a_e.cmp(b_e),\n+                (Bool, Bool) | (Char, Char) | (Str, Str) | (Never, Never) => Ordering::Equal,\n+                _ => {\n+                    debug_assert!(false, \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\");\n+                    Ordering::Equal\n                 }\n-                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Param(ref __self_0), &Param(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n-                }\n-                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Error(ref __self_0), &Error(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                _ => Ordering::Equal,\n             }\n-        } else {\n-            Ord::cmp(&__self_vi, &__arg_1_vi)\n-        }\n+        })\n     }\n }\n \n // This is manually implemented because a derive would require `I: Hash`\n impl<I: Interner> hash::Hash for TyKind<I> {\n     fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&Int(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Uint(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Float(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Adt(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Foreign(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Array(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Slice(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&RawPtr(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Ref(ref __self_0, ref __self_1, ref __self_2),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state);\n-                hash::Hash::hash(__self_2, state)\n-            }\n-            (&FnDef(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&FnPtr(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Dynamic(ref __self_0, ref __self_1, ref repr),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state);\n-                hash::Hash::hash(repr, state)\n-            }\n-            (&Closure(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Generator(ref __self_0, ref __self_1, ref __self_2),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state);\n-                hash::Hash::hash(__self_2, state)\n-            }\n-            (&GeneratorWitness(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Tuple(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Projection(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Opaque(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Param(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Bound(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Placeholder(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Infer(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n+        tykind_discriminant(self).hash(state);\n+        match self {\n+            Int(i) => i.hash(state),\n+            Uint(u) => u.hash(state),\n+            Float(f) => f.hash(state),\n+            Adt(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            Foreign(d) => d.hash(state),\n+            Array(t, c) => {\n+                t.hash(state);\n+                c.hash(state)\n             }\n-            (&Error(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n+            Slice(t) => t.hash(state),\n+            RawPtr(t) => t.hash(state),\n+            Ref(r, t, m) => {\n+                r.hash(state);\n+                t.hash(state);\n+                m.hash(state)\n+            }\n+            FnDef(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            FnPtr(s) => s.hash(state),\n+            Dynamic(p, r, repr) => {\n+                p.hash(state);\n+                r.hash(state);\n+                repr.hash(state)\n+            }\n+            Closure(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            Generator(d, s, m) => {\n+                d.hash(state);\n+                s.hash(state);\n+                m.hash(state)\n+            }\n+            GeneratorWitness(g) => g.hash(state),\n+            Tuple(t) => t.hash(state),\n+            Projection(p) => p.hash(state),\n+            Opaque(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            Param(p) => p.hash(state),\n+            Bound(d, b) => {\n+                d.hash(state);\n+                b.hash(state)\n             }\n-            _ => hash::Hash::hash(&tykind_discriminant(self), state),\n+            Placeholder(p) => p.hash(state),\n+            Infer(t) => t.hash(state),\n+            Error(e) => e.hash(state),\n+            Bool | Char | Str | Never => (),\n         }\n     }\n }\n \n // This is manually implemented because a derive would require `I: Debug`\n impl<I: Interner> fmt::Debug for TyKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use std::fmt::*;\n         match self {\n-            Bool => Formatter::write_str(f, \"Bool\"),\n-            Char => Formatter::write_str(f, \"Char\"),\n-            Int(f0) => Formatter::debug_tuple_field1_finish(f, \"Int\", f0),\n-            Uint(f0) => Formatter::debug_tuple_field1_finish(f, \"Uint\", f0),\n-            Float(f0) => Formatter::debug_tuple_field1_finish(f, \"Float\", f0),\n-            Adt(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Adt\", f0, f1),\n-            Foreign(f0) => Formatter::debug_tuple_field1_finish(f, \"Foreign\", f0),\n-            Str => Formatter::write_str(f, \"Str\"),\n-            Array(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Array\", f0, f1),\n-            Slice(f0) => Formatter::debug_tuple_field1_finish(f, \"Slice\", f0),\n-            RawPtr(f0) => Formatter::debug_tuple_field1_finish(f, \"RawPtr\", f0),\n-            Ref(f0, f1, f2) => Formatter::debug_tuple_field3_finish(f, \"Ref\", f0, f1, f2),\n-            FnDef(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"FnDef\", f0, f1),\n-            FnPtr(f0) => Formatter::debug_tuple_field1_finish(f, \"FnPtr\", f0),\n-            Dynamic(f0, f1, f2) => Formatter::debug_tuple_field3_finish(f, \"Dynamic\", f0, f1, f2),\n-            Closure(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Closure\", f0, f1),\n-            Generator(f0, f1, f2) => {\n-                Formatter::debug_tuple_field3_finish(f, \"Generator\", f0, f1, f2)\n-            }\n-            GeneratorWitness(f0) => Formatter::debug_tuple_field1_finish(f, \"GeneratorWitness\", f0),\n-            Never => Formatter::write_str(f, \"Never\"),\n-            Tuple(f0) => Formatter::debug_tuple_field1_finish(f, \"Tuple\", f0),\n-            Projection(f0) => Formatter::debug_tuple_field1_finish(f, \"Projection\", f0),\n-            Opaque(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Opaque\", f0, f1),\n-            Param(f0) => Formatter::debug_tuple_field1_finish(f, \"Param\", f0),\n-            Bound(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Bound\", f0, f1),\n-            Placeholder(f0) => Formatter::debug_tuple_field1_finish(f, \"Placeholder\", f0),\n-            Infer(f0) => Formatter::debug_tuple_field1_finish(f, \"Infer\", f0),\n-            TyKind::Error(f0) => Formatter::debug_tuple_field1_finish(f, \"Error\", f0),\n+            Bool => f.write_str(\"Bool\"),\n+            Char => f.write_str(\"Char\"),\n+            Int(i) => f.debug_tuple_field1_finish(\"Int\", i),\n+            Uint(u) => f.debug_tuple_field1_finish(\"Uint\", u),\n+            Float(float) => f.debug_tuple_field1_finish(\"Float\", float),\n+            Adt(d, s) => f.debug_tuple_field2_finish(\"Adt\", d, s),\n+            Foreign(d) => f.debug_tuple_field1_finish(\"Foreign\", d),\n+            Str => f.write_str(\"Str\"),\n+            Array(t, c) => f.debug_tuple_field2_finish(\"Array\", t, c),\n+            Slice(t) => f.debug_tuple_field1_finish(\"Slice\", t),\n+            RawPtr(t) => f.debug_tuple_field1_finish(\"RawPtr\", t),\n+            Ref(r, t, m) => f.debug_tuple_field3_finish(\"Ref\", r, t, m),\n+            FnDef(d, s) => f.debug_tuple_field2_finish(\"FnDef\", d, s),\n+            FnPtr(s) => f.debug_tuple_field1_finish(\"FnPtr\", s),\n+            Dynamic(p, r, repr) => f.debug_tuple_field3_finish(\"Dynamic\", p, r, repr),\n+            Closure(d, s) => f.debug_tuple_field2_finish(\"Closure\", d, s),\n+            Generator(d, s, m) => f.debug_tuple_field3_finish(\"Generator\", d, s, m),\n+            GeneratorWitness(g) => f.debug_tuple_field1_finish(\"GeneratorWitness\", g),\n+            Never => f.write_str(\"Never\"),\n+            Tuple(t) => f.debug_tuple_field1_finish(\"Tuple\", t),\n+            Projection(p) => f.debug_tuple_field1_finish(\"Projection\", p),\n+            Opaque(d, s) => f.debug_tuple_field2_finish(\"Opaque\", d, s),\n+            Param(p) => f.debug_tuple_field1_finish(\"Param\", p),\n+            Bound(d, b) => f.debug_tuple_field2_finish(\"Bound\", d, b),\n+            Placeholder(p) => f.debug_tuple_field1_finish(\"Placeholder\", p),\n+            Infer(t) => f.debug_tuple_field1_finish(\"Infer\", t),\n+            TyKind::Error(e) => f.debug_tuple_field1_finish(\"Error\", e),\n         }\n     }\n }\n@@ -1091,12 +964,12 @@ where\n impl<I: Interner> Clone for RegionKind<I> {\n     fn clone(&self) -> Self {\n         match self {\n-            ReEarlyBound(a) => ReEarlyBound(a.clone()),\n-            ReLateBound(a, b) => ReLateBound(a.clone(), b.clone()),\n-            ReFree(a) => ReFree(a.clone()),\n+            ReEarlyBound(r) => ReEarlyBound(r.clone()),\n+            ReLateBound(d, r) => ReLateBound(d.clone(), r.clone()),\n+            ReFree(r) => ReFree(r.clone()),\n             ReStatic => ReStatic,\n-            ReVar(a) => ReVar(a.clone()),\n-            RePlaceholder(a) => RePlaceholder(a.clone()),\n+            ReVar(r) => ReVar(r.clone()),\n+            RePlaceholder(r) => RePlaceholder(r.clone()),\n             ReErased => ReErased,\n         }\n     }\n@@ -1106,29 +979,23 @@ impl<I: Interner> Clone for RegionKind<I> {\n impl<I: Interner> PartialEq for RegionKind<I> {\n     #[inline]\n     fn eq(&self, other: &RegionKind<I>) -> bool {\n-        let __self_vi = regionkind_discriminant(self);\n-        let __arg_1_vi = regionkind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&ReEarlyBound(ref __self_0), &ReEarlyBound(ref __arg_1_0)) => {\n-                    __self_0 == __arg_1_0\n+        regionkind_discriminant(self) == regionkind_discriminant(other)\n+            && match (self, other) {\n+                (ReEarlyBound(a_r), ReEarlyBound(b_r)) => a_r == b_r,\n+                (ReLateBound(a_d, a_r), ReLateBound(b_d, b_r)) => a_d == b_d && a_r == b_r,\n+                (ReFree(a_r), ReFree(b_r)) => a_r == b_r,\n+                (ReStatic, ReStatic) => true,\n+                (ReVar(a_r), ReVar(b_r)) => a_r == b_r,\n+                (RePlaceholder(a_r), RePlaceholder(b_r)) => a_r == b_r,\n+                (ReErased, ReErased) => true,\n+                _ => {\n+                    debug_assert!(\n+                        false,\n+                        \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\"\n+                    );\n+                    true\n                 }\n-                (\n-                    &ReLateBound(ref __self_0, ref __self_1),\n-                    &ReLateBound(ref __arg_1_0, ref __arg_1_1),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1,\n-                (&ReFree(ref __self_0), &ReFree(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&ReStatic, &ReStatic) => true,\n-                (&ReVar(ref __self_0), &ReVar(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n-                    __self_0 == __arg_1_0\n-                }\n-                (&ReErased, &ReErased) => true,\n-                _ => true,\n             }\n-        } else {\n-            false\n-        }\n     }\n }\n \n@@ -1139,74 +1006,49 @@ impl<I: Interner> Eq for RegionKind<I> {}\n impl<I: Interner> PartialOrd for RegionKind<I> {\n     #[inline]\n     fn partial_cmp(&self, other: &RegionKind<I>) -> Option<Ordering> {\n-        Some(Ord::cmp(self, other))\n+        Some(self.cmp(other))\n     }\n }\n \n // This is manually implemented because a derive would require `I: Ord`\n impl<I: Interner> Ord for RegionKind<I> {\n     #[inline]\n     fn cmp(&self, other: &RegionKind<I>) -> Ordering {\n-        let __self_vi = regionkind_discriminant(self);\n-        let __arg_1_vi = regionkind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&ReEarlyBound(ref __self_0), &ReEarlyBound(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n+        regionkind_discriminant(self).cmp(&regionkind_discriminant(other)).then_with(|| {\n+            match (self, other) {\n+                (ReEarlyBound(a_r), ReEarlyBound(b_r)) => a_r.cmp(b_r),\n+                (ReLateBound(a_d, a_r), ReLateBound(b_d, b_r)) => {\n+                    a_d.cmp(b_d).then_with(|| a_r.cmp(b_r))\n                 }\n-                (\n-                    &ReLateBound(ref __self_0, ref __self_1),\n-                    &ReLateBound(ref __arg_1_0, ref __arg_1_1),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                    cmp => cmp,\n-                },\n-                (&ReFree(ref __self_0), &ReFree(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&ReStatic, &ReStatic) => Ordering::Equal,\n-                (&ReVar(ref __self_0), &ReVar(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n+                (ReFree(a_r), ReFree(b_r)) => a_r.cmp(b_r),\n+                (ReStatic, ReStatic) => Ordering::Equal,\n+                (ReVar(a_r), ReVar(b_r)) => a_r.cmp(b_r),\n+                (RePlaceholder(a_r), RePlaceholder(b_r)) => a_r.cmp(b_r),\n+                (ReErased, ReErased) => Ordering::Equal,\n+                _ => {\n+                    debug_assert!(false, \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\");\n+                    Ordering::Equal\n                 }\n-                (&ReErased, &ReErased) => Ordering::Equal,\n-                _ => Ordering::Equal,\n             }\n-        } else {\n-            Ord::cmp(&__self_vi, &__arg_1_vi)\n-        }\n+        })\n     }\n }\n \n // This is manually implemented because a derive would require `I: Hash`\n impl<I: Interner> hash::Hash for RegionKind<I> {\n-    fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&ReEarlyBound(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&ReLateBound(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&ReFree(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&ReStatic,) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-            }\n-            (&ReVar(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&RePlaceholder(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&ReErased,) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-            }\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) -> () {\n+        regionkind_discriminant(self).hash(state);\n+        match self {\n+            ReEarlyBound(r) => r.hash(state),\n+            ReLateBound(d, r) => {\n+                d.hash(state);\n+                r.hash(state)\n+            }\n+            ReFree(r) => r.hash(state),\n+            ReStatic => (),\n+            ReVar(r) => r.hash(state),\n+            RePlaceholder(r) => r.hash(state),\n+            ReErased => (),\n         }\n     }\n }\n@@ -1215,21 +1057,21 @@ impl<I: Interner> hash::Hash for RegionKind<I> {\n impl<I: Interner> fmt::Debug for RegionKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            ReEarlyBound(ref data) => write!(f, \"ReEarlyBound({:?})\", data),\n+            ReEarlyBound(data) => write!(f, \"ReEarlyBound({:?})\", data),\n \n-            ReLateBound(binder_id, ref bound_region) => {\n+            ReLateBound(binder_id, bound_region) => {\n                 write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n             }\n \n-            ReFree(ref fr) => fr.fmt(f),\n+            ReFree(fr) => fr.fmt(f),\n \n-            ReStatic => write!(f, \"ReStatic\"),\n+            ReStatic => f.write_str(\"ReStatic\"),\n \n-            ReVar(ref vid) => vid.fmt(f),\n+            ReVar(vid) => vid.fmt(f),\n \n             RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n \n-            ReErased => write!(f, \"ReErased\"),\n+            ReErased => f.write_str(\"ReErased\"),\n         }\n     }\n }\n@@ -1317,18 +1159,18 @@ where\n             ReErased | ReStatic => {\n                 // No variant fields to hash for these ...\n             }\n-            ReLateBound(db, br) => {\n-                db.hash_stable(hcx, hasher);\n-                br.hash_stable(hcx, hasher);\n+            ReLateBound(d, r) => {\n+                d.hash_stable(hcx, hasher);\n+                r.hash_stable(hcx, hasher);\n             }\n-            ReEarlyBound(eb) => {\n-                eb.hash_stable(hcx, hasher);\n+            ReEarlyBound(r) => {\n+                r.hash_stable(hcx, hasher);\n             }\n-            ReFree(ref free_region) => {\n-                free_region.hash_stable(hcx, hasher);\n+            ReFree(r) => {\n+                r.hash_stable(hcx, hasher);\n             }\n-            RePlaceholder(p) => {\n-                p.hash_stable(hcx, hasher);\n+            RePlaceholder(r) => {\n+                r.hash_stable(hcx, hasher);\n             }\n             ReVar(_) => {\n                 panic!(\"region variables should not be hashed: {self:?}\")"}, {"sha": "4e5d424886ad8017e91627f310d848e3288a59ee", "filename": "compiler/rustc_type_ir/src/ty_info.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_type_ir%2Fsrc%2Fty_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/compiler%2Frustc_type_ir%2Fsrc%2Fty_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fty_info.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,122 @@\n+use std::{\n+    cmp::Ordering,\n+    hash::{Hash, Hasher},\n+    ops::Deref,\n+};\n+\n+use rustc_data_structures::{\n+    fingerprint::Fingerprint,\n+    stable_hasher::{HashStable, StableHasher},\n+};\n+\n+use crate::{DebruijnIndex, TypeFlags};\n+\n+/// A helper type that you can wrap round your own type in order to automatically\n+/// cache the stable hash, type flags and debruijn index on creation and\n+/// not recompute it whenever the information is needed.\n+/// This is only done in incremental mode. You can also opt out of caching by using\n+/// StableHash::ZERO for the hash, in which case the hash gets computed each time.\n+/// This is useful if you have values that you intern but never (can?) use for stable\n+/// hashing.\n+#[derive(Copy, Clone)]\n+pub struct WithCachedTypeInfo<T> {\n+    pub internee: T,\n+    pub stable_hash: Fingerprint,\n+\n+    /// This field provides fast access to information that is also contained\n+    /// in `kind`.\n+    ///\n+    /// This field shouldn't be used directly and may be removed in the future.\n+    /// Use `Ty::flags()` instead.\n+    pub flags: TypeFlags,\n+\n+    /// This field provides fast access to information that is also contained\n+    /// in `kind`.\n+    ///\n+    /// This is a kind of confusing thing: it stores the smallest\n+    /// binder such that\n+    ///\n+    /// (a) the binder itself captures nothing but\n+    /// (b) all the late-bound things within the type are captured\n+    ///     by some sub-binder.\n+    ///\n+    /// So, for a type without any late-bound things, like `u32`, this\n+    /// will be *innermost*, because that is the innermost binder that\n+    /// captures nothing. But for a type `&'D u32`, where `'D` is a\n+    /// late-bound region with De Bruijn index `D`, this would be `D + 1`\n+    /// -- the binder itself does not capture `D`, but `D` is captured\n+    /// by an inner binder.\n+    ///\n+    /// We call this concept an \"exclusive\" binder `D` because all\n+    /// De Bruijn indices within the type are contained within `0..D`\n+    /// (exclusive).\n+    pub outer_exclusive_binder: DebruijnIndex,\n+}\n+\n+impl<T: PartialEq> PartialEq for WithCachedTypeInfo<T> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.internee.eq(&other.internee)\n+    }\n+}\n+\n+impl<T: Eq> Eq for WithCachedTypeInfo<T> {}\n+\n+impl<T: Ord> PartialOrd for WithCachedTypeInfo<T> {\n+    fn partial_cmp(&self, other: &WithCachedTypeInfo<T>) -> Option<Ordering> {\n+        Some(self.internee.cmp(&other.internee))\n+    }\n+}\n+\n+impl<T: Ord> Ord for WithCachedTypeInfo<T> {\n+    fn cmp(&self, other: &WithCachedTypeInfo<T>) -> Ordering {\n+        self.internee.cmp(&other.internee)\n+    }\n+}\n+\n+impl<T> Deref for WithCachedTypeInfo<T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &T {\n+        &self.internee\n+    }\n+}\n+\n+impl<T: Hash> Hash for WithCachedTypeInfo<T> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        if self.stable_hash != Fingerprint::ZERO {\n+            self.stable_hash.hash(s)\n+        } else {\n+            self.internee.hash(s)\n+        }\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for WithCachedTypeInfo<T> {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        if self.stable_hash == Fingerprint::ZERO || cfg!(debug_assertions) {\n+            // No cached hash available. This can only mean that incremental is disabled.\n+            // We don't cache stable hashes in non-incremental mode, because they are used\n+            // so rarely that the performance actually suffers.\n+\n+            // We need to build the hash as if we cached it and then hash that hash, as\n+            // otherwise the hashes will differ between cached and non-cached mode.\n+            let stable_hash: Fingerprint = {\n+                let mut hasher = StableHasher::new();\n+                self.internee.hash_stable(hcx, &mut hasher);\n+                hasher.finish()\n+            };\n+            if cfg!(debug_assertions) && self.stable_hash != Fingerprint::ZERO {\n+                assert_eq!(\n+                    stable_hash, self.stable_hash,\n+                    \"cached stable hash does not match freshly computed stable hash\"\n+                );\n+            }\n+            stable_hash.hash_stable(hcx, hasher);\n+        } else {\n+            self.stable_hash.hash_stable(hcx, hasher);\n+        }\n+    }\n+}"}, {"sha": "ca54cbd2d68dc213051f86673ddf3e7fa965cba7", "filename": "config.toml.example", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -255,6 +255,16 @@ changelog-seen = 2\n # Defaults to the Python interpreter used to execute x.py\n #python = \"python\"\n \n+# The path to the REUSE executable to use. Note that REUSE is not required in\n+# most cases, as our tooling relies on a cached (and shrinked) copy of the\n+# REUSE output present in the git repository and in our source tarballs.\n+#\n+# REUSE is only needed if your changes caused the overral licensing of the\n+# repository to change, and the cached copy has to be regenerated.\n+#\n+# Defaults to the \"reuse\" command in the system path.\n+#reuse = \"reuse\"\n+\n # Force Cargo to check that Cargo.lock describes the precise dependency\n # set that all the Cargo.toml files create, instead of updating it.\n #locked-deps = false"}, {"sha": "949896e57480677b8192509782d00380558c9ed9", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -29,15 +29,16 @@ use crate::marker::StructuralPartialEq;\n \n use self::Ordering::*;\n \n-/// Trait for equality comparisons which are [partial equivalence\n-/// relations](https://en.wikipedia.org/wiki/Partial_equivalence_relation).\n+/// Trait for equality comparisons.\n ///\n /// `x.eq(y)` can also be written `x == y`, and `x.ne(y)` can be written `x != y`.\n /// We use the easier-to-read infix notation in the remainder of this documentation.\n ///\n /// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not [`trait@Eq`].\n+/// Formally speaking, when `Rhs == Self`, this trait corresponds to a [partial equivalence\n+/// relation](https://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n /// Implementations must ensure that `eq` and `ne` are consistent with each other:\n ///"}, {"sha": "9c0d7e9a1e89e25014d5d42809caecd70c485a7f", "filename": "library/core/src/convert/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -49,7 +49,7 @@ macro_rules! impl_from {\n             // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n             // Rustdocs on functions do not.\n             #[doc = $doc]\n-            #[inline]\n+            #[inline(always)]\n             fn from(small: $Small) -> Self {\n                 small as Self\n             }"}, {"sha": "2a8e12fd4cf60fcc2bbc8aa749c500a6229f009c", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -44,7 +44,7 @@ pub use poll_fn::{poll_fn, PollFn};\n ///    non-Send/Sync as well, and we don't want that.\n ///\n /// It also simplifies the HIR lowering of `.await`.\n-#[cfg_attr(not(bootstrap), lang = \"ResumeTy\")]\n+// FIXME(swatinem): This type can be removed when bumping the bootstrap compiler\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Debug, Copy, Clone)]\n@@ -61,6 +61,7 @@ unsafe impl Sync for ResumeTy {}\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n // This is `const` to avoid extra errors after we recover from `const async fn`\n+// FIXME(swatinem): This fn can be removed when bumping the bootstrap compiler\n #[cfg_attr(bootstrap, lang = \"from_generator\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n@@ -102,7 +103,8 @@ where\n     GenFuture(gen)\n }\n \n-#[lang = \"get_context\"]\n+// FIXME(swatinem): This fn can be removed when bumping the bootstrap compiler\n+#[cfg_attr(bootstrap, lang = \"get_context\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[must_use]\n@@ -113,6 +115,10 @@ pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n     unsafe { &mut *cx.0.as_ptr().cast() }\n }\n \n+// FIXME(swatinem): This fn is currently needed to work around shortcomings\n+// in type and lifetime inference.\n+// See the comment at the bottom of `LoweringContext::make_async_expr` and\n+// <https://github.com/rust-lang/rust/issues/104826>.\n #[cfg_attr(not(bootstrap), lang = \"identity_future\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]"}, {"sha": "fd8d25ce1a55e3b2280652cbf9bf2ac593edf4fd", "filename": "library/core/src/iter/sources/repeat_n.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -20,7 +20,7 @@ use crate::mem::ManuallyDrop;\n /// #![feature(iter_repeat_n)]\n /// use std::iter;\n ///\n-/// // four of the the number four:\n+/// // four of the number four:\n /// let mut four_fours = iter::repeat_n(4, 4);\n ///\n /// assert_eq!(Some(4), four_fours.next());"}, {"sha": "ac7f579ebb5aa8bc8cd059b40d8dfab09de89dfb", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -4,12 +4,14 @@\n \n use crate::ascii;\n use crate::convert::TryInto;\n-use crate::error::Error;\n use crate::intrinsics;\n use crate::mem;\n use crate::ops::{Add, Mul, Sub};\n use crate::str::FromStr;\n \n+#[cfg(not(no_fp_fmt_parse))]\n+use crate::error::Error;\n+\n // Used because the `?` operator is not allowed in a const context.\n macro_rules! try_opt {\n     ($e:expr) => {"}, {"sha": "19da6d2fbecbc678960fcd282219f63cc5c2264a", "filename": "library/core/src/str/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1894,7 +1894,7 @@ unsafe fn small_slice_eq(x: &[u8], y: &[u8]) -> bool {\n     // Thus, derefencing both `px` and `py` in the loop below is safe.\n     //\n     // Moreover, we set `pxend` and `pyend` to be 4 bytes before the actual\n-    // end of of `px` and `py`. Thus, the final dereference outside of the\n+    // end of `px` and `py`. Thus, the final dereference outside of the\n     // loop is guaranteed to be valid. (The final comparison will overlap with\n     // the last comparison done in the loop for lengths that aren't multiples\n     // of four.)"}, {"sha": "9ab9b0ba1c79739548fc891ba34d5d0f33bb82dc", "filename": "library/core/src/task/wake.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -174,6 +174,7 @@ impl RawWakerVTable {\n /// Currently, `Context` only serves to provide access to a [`&Waker`](Waker)\n /// which can be used to wake the current task.\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+#[cfg_attr(not(bootstrap), lang = \"Context\")]\n pub struct Context<'a> {\n     waker: &'a Waker,\n     // Ensure we future-proof against variance changes by forcing"}, {"sha": "a7aefc26b97c7e0ac8008303e3e92b674a55e2cc", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -15,7 +15,7 @@ cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.135\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.138\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.82\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "f71edc6c525a2aeb61abe424c19588741786326b", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -225,7 +225,7 @@ impl<T> Channel<T> {\n             let slot = unsafe { self.buffer.get_unchecked(index) };\n             let stamp = slot.stamp.load(Ordering::Acquire);\n \n-            // If the the stamp is ahead of the head by 1, we may attempt to pop.\n+            // If the stamp is ahead of the head by 1, we may attempt to pop.\n             if head + 1 == stamp {\n                 let new = if index + 1 < self.cap {\n                     // Same lap, incremented index."}, {"sha": "adb488d4378f0391140e6eadf604603720f8776f", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -629,9 +629,7 @@ impl<T> Clone for Sender<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Sender<T> {\n-    fn drop(&mut self) {\n-        let _ = self.inner;\n-    }\n+    fn drop(&mut self) {}\n }\n \n #[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\n@@ -751,9 +749,7 @@ impl<T> Clone for SyncSender<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for SyncSender<T> {\n-    fn drop(&mut self) {\n-        let _ = self.inner;\n-    }\n+    fn drop(&mut self) {}\n }\n \n #[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\n@@ -1094,9 +1090,7 @@ impl<T> IntoIterator for Receiver<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Receiver<T> {\n-    fn drop(&mut self) {\n-        let _ = self.inner;\n-    }\n+    fn drop(&mut self) {}\n }\n \n #[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]"}, {"sha": "7a47cc6696a34908a0bea6f832dbf14e8b68087d", "filename": "library/std/src/sys/itron/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -71,7 +71,7 @@ impl Condvar {\n             }\n         }\n \n-        unsafe { mutex.lock() };\n+        mutex.lock();\n     }\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n@@ -109,7 +109,7 @@ impl Condvar {\n         // we woke up because of `notify_*`.\n         let success = self.waiters.with_locked(|waiters| unsafe { !waiters.remove(waiter) });\n \n-        unsafe { mutex.lock() };\n+        mutex.lock();\n         success\n     }\n }"}, {"sha": "1f6cc41947602be1a7f81d443972de6e26b78d69", "filename": "library/std/src/sys/itron/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -72,7 +72,7 @@ pub(super) struct MutexGuard<'a>(&'a Mutex);\n impl<'a> MutexGuard<'a> {\n     #[inline]\n     pub(super) fn lock(x: &'a Mutex) -> Self {\n-        unsafe { x.lock() };\n+        x.lock();\n         Self(x)\n     }\n }"}, {"sha": "c2b3668087225cdc884a28d3a15660974c16b98d", "filename": "library/std/src/sys/itron/thread.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -11,18 +11,25 @@ use crate::{\n     ffi::CStr,\n     hint, io,\n     mem::ManuallyDrop,\n+    ptr::NonNull,\n     sync::atomic::{AtomicUsize, Ordering},\n     sys::thread_local_dtor::run_dtors,\n     time::Duration,\n };\n \n pub struct Thread {\n-    inner: ManuallyDrop<Box<ThreadInner>>,\n+    p_inner: NonNull<ThreadInner>,\n \n     /// The ID of the underlying task.\n     task: abi::ID,\n }\n \n+// Safety: There's nothing in `Thread` that ties it to the original creator. It\n+//         can be dropped by any threads.\n+unsafe impl Send for Thread {}\n+// Safety: `Thread` provides no methods that take `&self`.\n+unsafe impl Sync for Thread {}\n+\n /// State data shared between a parent thread and child thread. It's dropped on\n /// a transition to one of the final states.\n struct ThreadInner {\n@@ -90,8 +97,9 @@ impl Thread {\n         });\n \n         unsafe extern \"C\" fn trampoline(exinf: isize) {\n+            let p_inner: *mut ThreadInner = crate::ptr::from_exposed_addr_mut(exinf as usize);\n             // Safety: `ThreadInner` is alive at this point\n-            let inner = unsafe { &*(exinf as *const ThreadInner) };\n+            let inner = unsafe { &*p_inner };\n \n             // Safety: Since `trampoline` is called only once for each\n             //         `ThreadInner` and only `trampoline` touches `start`,\n@@ -119,13 +127,13 @@ impl Thread {\n                     // No one will ever join, so we'll ask the collector task to\n                     // delete the task.\n \n-                    // In this case, `inner`'s ownership has been moved to us,\n-                    // And we are responsible for dropping it. The acquire\n+                    // In this case, `*p_inner`'s ownership has been moved to\n+                    // us, and we are responsible for dropping it. The acquire\n                     // ordering is not necessary because the parent thread made\n                     // no memory access needing synchronization since the call\n                     // to `acre_tsk`.\n                     // Safety: See above.\n-                    let _ = unsafe { Box::from_raw(inner as *const _ as *mut ThreadInner) };\n+                    let _ = unsafe { Box::from_raw(p_inner) };\n \n                     // Safety: There are no pinned references to the stack\n                     unsafe { terminate_and_delete_current_task() };\n@@ -162,13 +170,14 @@ impl Thread {\n             }\n         }\n \n-        let inner_ptr = (&*inner) as *const ThreadInner;\n+        // Safety: `Box::into_raw` returns a non-null pointer\n+        let p_inner = unsafe { NonNull::new_unchecked(Box::into_raw(inner)) };\n \n         let new_task = ItronError::err_if_negative(unsafe {\n             abi::acre_tsk(&abi::T_CTSK {\n                 // Activate this task immediately\n                 tskatr: abi::TA_ACT,\n-                exinf: inner_ptr as abi::EXINF,\n+                exinf: p_inner.as_ptr().expose_addr() as abi::EXINF,\n                 // The entry point\n                 task: Some(trampoline),\n                 // Inherit the calling task's base priority\n@@ -180,7 +189,7 @@ impl Thread {\n         })\n         .map_err(|e| e.as_io_error())?;\n \n-        Ok(Self { inner: ManuallyDrop::new(inner), task: new_task })\n+        Ok(Self { p_inner, task: new_task })\n     }\n \n     pub fn yield_now() {\n@@ -197,8 +206,9 @@ impl Thread {\n         }\n     }\n \n-    pub fn join(mut self) {\n-        let inner = &*self.inner;\n+    pub fn join(self) {\n+        // Safety: `ThreadInner` is alive at this point\n+        let inner = unsafe { self.p_inner.as_ref() };\n         // Get the current task ID. Panicking here would cause a resource leak,\n         // so just abort on failure.\n         let current_task = task::current_task_id_aborting();\n@@ -243,8 +253,8 @@ impl Thread {\n         unsafe { terminate_and_delete_task(self.task) };\n \n         // In either case, we are responsible for dropping `inner`.\n-        // Safety: The contents of `self.inner` will not be accessed hereafter\n-        let _inner = unsafe { ManuallyDrop::take(&mut self.inner) };\n+        // Safety: The contents of `*p_inner` will not be accessed hereafter\n+        let _inner = unsafe { Box::from_raw(self.p_inner.as_ptr()) };\n \n         // Skip the destructor (because it would attempt to detach the thread)\n         crate::mem::forget(self);\n@@ -253,13 +263,16 @@ impl Thread {\n \n impl Drop for Thread {\n     fn drop(&mut self) {\n+        // Safety: `ThreadInner` is alive at this point\n+        let inner = unsafe { self.p_inner.as_ref() };\n+\n         // Detach the thread.\n-        match self.inner.lifecycle.swap(LIFECYCLE_DETACHED_OR_JOINED, Ordering::Acquire) {\n+        match inner.lifecycle.swap(LIFECYCLE_DETACHED_OR_JOINED, Ordering::Acquire) {\n             LIFECYCLE_INIT => {\n                 // [INIT \u2192 DETACHED]\n                 // When the time comes, the child will figure out that no\n                 // one will ever join it.\n-                // The ownership of `self.inner` is moved to the child thread.\n+                // The ownership of `*p_inner` is moved to the child thread.\n                 // However, the release ordering is not necessary because we\n                 // made no memory access needing synchronization since the call\n                 // to `acre_tsk`.\n@@ -278,10 +291,9 @@ impl Drop for Thread {\n                 //         delete by entering the `FINISHED` state.\n                 unsafe { terminate_and_delete_task(self.task) };\n \n-                // Wwe are responsible for dropping `inner`.\n-                // Safety: The contents of `self.inner` will not be accessed\n-                //         hereafter\n-                unsafe { ManuallyDrop::drop(&mut self.inner) };\n+                // Wwe are responsible for dropping `*p_inner`.\n+                // Safety: The contents of `*p_inner` will not be accessed hereafter\n+                let _ = unsafe { Box::from_raw(self.p_inner.as_ptr()) };\n             }\n             _ => unsafe { hint::unreachable_unchecked() },\n         }"}, {"sha": "a862bb7870264e72ece3f8ee5c6bfc2a9ef0992f", "filename": "library/std/src/sys/solid/io.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fio.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -75,3 +75,7 @@ impl<'a> IoSliceMut<'a> {\n         unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }\n+\n+pub fn is_terminal<T>(_: &T) -> bool {\n+    false\n+}"}, {"sha": "6135921f0b5a89a6694d7d151130255981423c73", "filename": "library/std/src/sys/solid/os.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,7 +1,6 @@\n use super::unsupported;\n-use crate::convert::TryFrom;\n use crate::error::Error as StdError;\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n+use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::os::{"}, {"sha": "f5a4ce929b2a9219311c6c6d1298fad26c695b0c", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -29,7 +29,21 @@ use crate::ptr;\n use crate::sync::atomic::{self, AtomicPtr, Ordering};\n \n // We can use true weak linkage on ELF targets.\n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+#[cfg(all(not(any(target_os = \"macos\", target_os = \"ios\")), not(bootstrap)))]\n+pub(crate) macro weak {\n+    (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n+        let ref $name: ExternWeak<unsafe extern \"C\" fn($($t),*) -> $ret> = {\n+            extern \"C\" {\n+                #[linkage = \"extern_weak\"]\n+                static $name: Option<unsafe extern \"C\" fn($($t),*) -> $ret>;\n+            }\n+            #[allow(unused_unsafe)]\n+            ExternWeak::new(unsafe { $name })\n+        };\n+    )\n+}\n+\n+#[cfg(all(not(any(target_os = \"macos\", target_os = \"ios\")), bootstrap))]\n pub(crate) macro weak {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n         let ref $name: ExternWeak<unsafe extern \"C\" fn($($t),*) -> $ret> = {\n@@ -47,18 +61,39 @@ pub(crate) macro weak {\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n pub(crate) use self::dlsym as weak;\n \n+#[cfg(not(bootstrap))]\n+pub(crate) struct ExternWeak<F: Copy> {\n+    weak_ptr: Option<F>,\n+}\n+\n+#[cfg(not(bootstrap))]\n+impl<F: Copy> ExternWeak<F> {\n+    #[inline]\n+    pub(crate) fn new(weak_ptr: Option<F>) -> Self {\n+        ExternWeak { weak_ptr }\n+    }\n+\n+    #[inline]\n+    pub(crate) fn get(&self) -> Option<F> {\n+        self.weak_ptr\n+    }\n+}\n+\n+#[cfg(bootstrap)]\n pub(crate) struct ExternWeak<F> {\n     weak_ptr: *const libc::c_void,\n     _marker: PhantomData<F>,\n }\n \n+#[cfg(bootstrap)]\n impl<F> ExternWeak<F> {\n     #[inline]\n     pub(crate) fn new(weak_ptr: *const libc::c_void) -> Self {\n         ExternWeak { weak_ptr, _marker: PhantomData }\n     }\n }\n \n+#[cfg(bootstrap)]\n impl<F> ExternWeak<F> {\n     #[inline]\n     pub(crate) fn get(&self) -> Option<F> {"}, {"sha": "31e9b34fb9efdf1739cebdd4b100977fb5269af8", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -252,10 +252,6 @@ impl Command {\n     ) -> io::Result<(Process, StdioPipes)> {\n         let maybe_env = self.env.capture_if_changed();\n \n-        let mut si = zeroed_startupinfo();\n-        si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n-        si.dwFlags = c::STARTF_USESTDHANDLES;\n-\n         let child_paths = if let Some(env) = maybe_env.as_ref() {\n             env.get(&EnvKey::new(\"PATH\")).map(|s| s.as_os_str())\n         } else {\n@@ -314,9 +310,21 @@ impl Command {\n         let stdin = stdin.to_handle(c::STD_INPUT_HANDLE, &mut pipes.stdin)?;\n         let stdout = stdout.to_handle(c::STD_OUTPUT_HANDLE, &mut pipes.stdout)?;\n         let stderr = stderr.to_handle(c::STD_ERROR_HANDLE, &mut pipes.stderr)?;\n-        si.hStdInput = stdin.as_raw_handle();\n-        si.hStdOutput = stdout.as_raw_handle();\n-        si.hStdError = stderr.as_raw_handle();\n+\n+        let mut si = zeroed_startupinfo();\n+        si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n+\n+        // If at least one of stdin, stdout or stderr are set (i.e. are non null)\n+        // then set the `hStd` fields in `STARTUPINFO`.\n+        // Otherwise skip this and allow the OS to apply its default behaviour.\n+        // This provides more consistent behaviour between Win7 and Win8+.\n+        let is_set = |stdio: &Handle| !stdio.as_raw_handle().is_null();\n+        if is_set(&stderr) || is_set(&stdout) || is_set(&stdin) {\n+            si.dwFlags |= c::STARTF_USESTDHANDLES;\n+            si.hStdInput = stdin.as_raw_handle();\n+            si.hStdOutput = stdout.as_raw_handle();\n+            si.hStdError = stderr.as_raw_handle();\n+        }\n \n         unsafe {\n             cvt(c::CreateProcessW(\n@@ -513,17 +521,15 @@ fn program_exists(path: &Path) -> Option<Vec<u16>> {\n impl Stdio {\n     fn to_handle(&self, stdio_id: c::DWORD, pipe: &mut Option<AnonPipe>) -> io::Result<Handle> {\n         match *self {\n-            // If no stdio handle is available, then inherit means that it\n-            // should still be unavailable so propagate the\n-            // INVALID_HANDLE_VALUE.\n             Stdio::Inherit => match stdio::get_handle(stdio_id) {\n                 Ok(io) => unsafe {\n                     let io = Handle::from_raw_handle(io);\n                     let ret = io.duplicate(0, true, c::DUPLICATE_SAME_ACCESS);\n                     io.into_raw_handle();\n                     ret\n                 },\n-                Err(..) => unsafe { Ok(Handle::from_raw_handle(c::INVALID_HANDLE_VALUE)) },\n+                // If no stdio handle is available, then propagate the null value.\n+                Err(..) => unsafe { Ok(Handle::from_raw_handle(ptr::null_mut())) },\n             },\n \n             Stdio::MakePipe => {\n@@ -730,9 +736,9 @@ fn zeroed_startupinfo() -> c::STARTUPINFO {\n         wShowWindow: 0,\n         cbReserved2: 0,\n         lpReserved2: ptr::null_mut(),\n-        hStdInput: c::INVALID_HANDLE_VALUE,\n-        hStdOutput: c::INVALID_HANDLE_VALUE,\n-        hStdError: c::INVALID_HANDLE_VALUE,\n+        hStdInput: ptr::null_mut(),\n+        hStdOutput: ptr::null_mut(),\n+        hStdError: ptr::null_mut(),\n     }\n }\n "}, {"sha": "ada69aa8269f6cb1ea4779486c5e07d90e8c30a6", "filename": "library/std/src/thread/scoped.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -46,7 +46,7 @@ impl ScopeData {\n         // We check for 'overflow' with usize::MAX / 2, to make sure there's no\n         // chance it overflows to 0, which would result in unsoundness.\n         if self.num_running_threads.fetch_add(1, Ordering::Relaxed) > usize::MAX / 2 {\n-            // This can only reasonably happen by mem::forget()'ing many many ScopedJoinHandles.\n+            // This can only reasonably happen by mem::forget()'ing a lot of ScopedJoinHandles.\n             self.decrement_num_running_threads(false);\n             panic!(\"too many running threads in thread scope\");\n         }"}, {"sha": "8ee6d49da8f0e419b4fc9ff2898a4e21f5c47bae", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -754,6 +754,8 @@ impl<'a> Builder<'a> {\n                 run::BumpStage0,\n                 run::ReplaceVersionPlaceholder,\n                 run::Miri,\n+                run::CollectLicenseMetadata,\n+                run::GenerateCopyright,\n             ),\n             // These commands either don't use paths, or they're special-cased in Build::build()\n             Kind::Clean | Kind::Format | Kind::Setup => vec![],"}, {"sha": "d8c15c76e2d615b3a936a0b4e8616077a92d3c87", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -213,6 +213,7 @@ pub struct Config {\n     pub npm: Option<PathBuf>,\n     pub gdb: Option<PathBuf>,\n     pub python: Option<PathBuf>,\n+    pub reuse: Option<PathBuf>,\n     pub cargo_native_static: bool,\n     pub configure_args: Vec<String>,\n \n@@ -611,6 +612,7 @@ define_config! {\n         nodejs: Option<String> = \"nodejs\",\n         npm: Option<String> = \"npm\",\n         python: Option<String> = \"python\",\n+        reuse: Option<String> = \"reuse\",\n         locked_deps: Option<bool> = \"locked-deps\",\n         vendor: Option<bool> = \"vendor\",\n         full_bootstrap: Option<bool> = \"full-bootstrap\",\n@@ -1004,6 +1006,7 @@ impl Config {\n         config.npm = build.npm.map(PathBuf::from);\n         config.gdb = build.gdb.map(PathBuf::from);\n         config.python = build.python.map(PathBuf::from);\n+        config.reuse = build.reuse.map(PathBuf::from);\n         config.submodules = build.submodules;\n         set(&mut config.low_priority, build.low_priority);\n         set(&mut config.compiler_docs, build.compiler_docs);"}, {"sha": "37a8eb884efb02beba7ca57c462108a1bca96ae1", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -143,7 +143,7 @@ pub enum Subcommand {\n         args: Vec<String>,\n     },\n     Setup {\n-        profile: Profile,\n+        profile: Option<Profile>,\n     },\n }\n \n@@ -628,14 +628,15 @@ Arguments:\n                         |path| format!(\"{} is not a valid UTF8 string\", path.to_string_lossy())\n                     ));\n \n-                    profile_string.parse().unwrap_or_else(|err| {\n+                    let profile = profile_string.parse().unwrap_or_else(|err| {\n                         eprintln!(\"error: {}\", err);\n                         eprintln!(\"help: the available profiles are:\");\n                         eprint!(\"{}\", Profile::all_for_help(\"- \"));\n                         crate::detail_exit(1);\n-                    })\n+                    });\n+                    Some(profile)\n                 } else {\n-                    t!(crate::setup::interactive_path())\n+                    None\n                 };\n                 Subcommand::Setup { profile }\n             }"}, {"sha": "3ed53452309c76a54d0c11eec05cfb28b8d39447", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -542,16 +542,6 @@ impl Build {\n             metrics: metrics::BuildMetrics::init(),\n         };\n \n-        build.verbose(\"finding compilers\");\n-        cc_detect::find(&mut build);\n-        // When running `setup`, the profile is about to change, so any requirements we have now may\n-        // be different on the next invocation. Don't check for them until the next time x.py is\n-        // run. This is ok because `setup` never runs any build commands, so it won't fail if commands are missing.\n-        if !matches!(build.config.cmd, Subcommand::Setup { .. }) {\n-            build.verbose(\"running sanity check\");\n-            sanity::check(&mut build);\n-        }\n-\n         // If local-rust is the same major.minor as the current version, then force a\n         // local-rebuild\n         let local_version_verbose =\n@@ -567,16 +557,34 @@ impl Build {\n             build.local_rebuild = true;\n         }\n \n-        // Make sure we update these before gathering metadata so we don't get an error about missing\n-        // Cargo.toml files.\n-        let rust_submodules =\n-            [\"src/tools/rust-installer\", \"src/tools/cargo\", \"library/backtrace\", \"library/stdarch\"];\n-        for s in rust_submodules {\n-            build.update_submodule(Path::new(s));\n-        }\n+        build.verbose(\"finding compilers\");\n+        cc_detect::find(&mut build);\n+        // When running `setup`, the profile is about to change, so any requirements we have now may\n+        // be different on the next invocation. Don't check for them until the next time x.py is\n+        // run. This is ok because `setup` never runs any build commands, so it won't fail if commands are missing.\n+        //\n+        // Similarly, for `setup` we don't actually need submodules or cargo metadata.\n+        if !matches!(build.config.cmd, Subcommand::Setup { .. }) {\n+            build.verbose(\"running sanity check\");\n+            sanity::check(&mut build);\n+\n+            // Make sure we update these before gathering metadata so we don't get an error about missing\n+            // Cargo.toml files.\n+            let rust_submodules = [\n+                \"src/tools/rust-installer\",\n+                \"src/tools/cargo\",\n+                \"library/backtrace\",\n+                \"library/stdarch\",\n+            ];\n+            for s in rust_submodules {\n+                build.update_submodule(Path::new(s));\n+            }\n+            // Now, update all existing submodules.\n+            build.update_existing_submodules();\n \n-        build.verbose(\"learning about cargo\");\n-        metadata::build(&mut build);\n+            build.verbose(\"learning about cargo\");\n+            metadata::build(&mut build);\n+        }\n \n         build\n     }\n@@ -668,7 +676,7 @@ impl Build {\n \n     /// If any submodule has been initialized already, sync it unconditionally.\n     /// This avoids contributors checking in a submodule change by accident.\n-    pub fn maybe_update_submodules(&self) {\n+    pub fn update_existing_submodules(&self) {\n         // Avoid running git when there isn't a git checkout.\n         if !self.config.submodules(&self.rust_info()) {\n             return;\n@@ -697,8 +705,6 @@ impl Build {\n             job::setup(self);\n         }\n \n-        self.maybe_update_submodules();\n-\n         if let Subcommand::Format { check, paths } = &self.config.cmd {\n             return format::format(&builder::Builder::new(&self), *check, &paths);\n         }"}, {"sha": "05de51f8cc57933b886fb6a7b1d2436e4c728316", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,3 +1,4 @@\n+use std::path::PathBuf;\n use std::process::Command;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -189,3 +190,65 @@ impl Step for Miri {\n         builder.run(&mut miri);\n     }\n }\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct CollectLicenseMetadata;\n+\n+impl Step for CollectLicenseMetadata {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/collect-license-metadata\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(CollectLicenseMetadata);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let Some(reuse) = &builder.config.reuse else {\n+            panic!(\"REUSE is required to collect the license metadata\");\n+        };\n+\n+        // Temporary location, it will be moved to src/etc once it's accurate.\n+        let dest = builder.out.join(\"license-metadata.json\");\n+\n+        let mut cmd = builder.tool_cmd(Tool::CollectLicenseMetadata);\n+        cmd.env(\"REUSE_EXE\", reuse);\n+        cmd.env(\"DEST\", &dest);\n+        builder.run(&mut cmd);\n+\n+        dest\n+    }\n+}\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct GenerateCopyright;\n+\n+impl Step for GenerateCopyright {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/generate-copyright\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(GenerateCopyright);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let license_metadata = builder.ensure(CollectLicenseMetadata);\n+\n+        // Temporary location, it will be moved to the proper one once it's accurate.\n+        let dest = builder.out.join(\"COPYRIGHT.md\");\n+\n+        let mut cmd = builder.tool_cmd(Tool::GenerateCopyright);\n+        cmd.env(\"LICENSE_METADATA\", &license_metadata);\n+        cmd.env(\"DEST\", &dest);\n+        builder.run(&mut cmd);\n+\n+        dest\n+    }\n+}"}, {"sha": "8a40b0f64f4b6c5673ce6fc1c885f4622958c0e0", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -140,6 +140,13 @@ than building it.\n         .map(|p| cmd_finder.must_have(p))\n         .or_else(|| cmd_finder.maybe_have(\"gdb\"));\n \n+    build.config.reuse = build\n+        .config\n+        .reuse\n+        .take()\n+        .map(|p| cmd_finder.must_have(p))\n+        .or_else(|| cmd_finder.maybe_have(\"reuse\"));\n+\n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n     for target in &build.targets {"}, {"sha": "c7f98a7d0d149ae28c21ad6dadb109034e9bbff6", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 47, "deletions": 44, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,15 +1,13 @@\n+use crate::Config;\n use crate::{t, VERSION};\n-use crate::{Config, TargetSelection};\n use std::env::consts::EXE_SUFFIX;\n use std::fmt::Write as _;\n use std::fs::File;\n+use std::io::Write;\n use std::path::{Path, PathBuf, MAIN_SEPARATOR};\n use std::process::Command;\n use std::str::FromStr;\n-use std::{\n-    env, fmt, fs,\n-    io::{self, Write},\n-};\n+use std::{fmt, fs, io};\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n pub enum Profile {\n@@ -81,38 +79,10 @@ impl fmt::Display for Profile {\n     }\n }\n \n-pub fn setup(config: &Config, profile: Profile) {\n-    let path = &config.config.clone().unwrap_or(PathBuf::from(\"config.toml\"));\n-\n-    if path.exists() {\n-        eprintln!(\n-            \"error: you asked `x.py` to setup a new config file, but one already exists at `{}`\",\n-            path.display()\n-        );\n-        eprintln!(\"help: try adding `profile = \\\"{}\\\"` at the top of {}\", profile, path.display());\n-        eprintln!(\n-            \"note: this will use the configuration in {}\",\n-            profile.include_path(&config.src).display()\n-        );\n-        crate::detail_exit(1);\n-    }\n-\n-    let settings = format!(\n-        \"# Includes one of the default files in src/bootstrap/defaults\\n\\\n-    profile = \\\"{}\\\"\\n\\\n-    changelog-seen = {}\\n\",\n-        profile, VERSION\n-    );\n-    t!(fs::write(path, settings));\n-\n-    let include_path = profile.include_path(&config.src);\n-    println!(\"`x.py` will now use the configuration at {}\", include_path.display());\n-\n-    let build = TargetSelection::from_user(&env!(\"BUILD_TRIPLE\"));\n+pub fn setup(config: &Config, profile: Option<Profile>) {\n+    let profile = profile.unwrap_or_else(|| t!(interactive_path()));\n     let stage_path =\n-        [\"build\", build.rustc_target_arg(), \"stage1\"].join(&MAIN_SEPARATOR.to_string());\n-\n-    println!();\n+        [\"build\", config.build.rustc_target_arg(), \"stage1\"].join(&MAIN_SEPARATOR.to_string());\n \n     if !rustup_installed() && profile != Profile::User {\n         eprintln!(\"`rustup` is not installed; cannot link `stage1` toolchain\");\n@@ -134,8 +104,6 @@ pub fn setup(config: &Config, profile: Profile) {\n         Profile::User => &[\"dist\", \"build\"],\n     };\n \n-    println!();\n-\n     t!(install_git_hook_maybe(&config));\n \n     println!();\n@@ -150,6 +118,36 @@ pub fn setup(config: &Config, profile: Profile) {\n             \"For more suggestions, see https://rustc-dev-guide.rust-lang.org/building/suggested.html\"\n         );\n     }\n+\n+    let path = &config.config.clone().unwrap_or(PathBuf::from(\"config.toml\"));\n+    setup_config_toml(path, profile, config);\n+}\n+\n+fn setup_config_toml(path: &PathBuf, profile: Profile, config: &Config) {\n+    if path.exists() {\n+        eprintln!();\n+        eprintln!(\n+            \"error: you asked `x.py` to setup a new config file, but one already exists at `{}`\",\n+            path.display()\n+        );\n+        eprintln!(\"help: try adding `profile = \\\"{}\\\"` at the top of {}\", profile, path.display());\n+        eprintln!(\n+            \"note: this will use the configuration in {}\",\n+            profile.include_path(&config.src).display()\n+        );\n+        crate::detail_exit(1);\n+    }\n+\n+    let settings = format!(\n+        \"# Includes one of the default files in src/bootstrap/defaults\\n\\\n+    profile = \\\"{}\\\"\\n\\\n+    changelog-seen = {}\\n\",\n+        profile, VERSION\n+    );\n+    t!(fs::write(path, settings));\n+\n+    let include_path = profile.include_path(&config.src);\n+    println!(\"`x.py` will now use the configuration at {}\", include_path.display());\n }\n \n fn rustup_installed() -> bool {\n@@ -303,7 +301,18 @@ pub fn interactive_path() -> io::Result<Profile> {\n \n // install a git hook to automatically run tidy --bless, if they want\n fn install_git_hook_maybe(config: &Config) -> io::Result<()> {\n+    let git = t!(config.git().args(&[\"rev-parse\", \"--git-common-dir\"]).output().map(|output| {\n+        assert!(output.status.success(), \"failed to run `git`\");\n+        PathBuf::from(t!(String::from_utf8(output.stdout)).trim())\n+    }));\n+    let dst = git.join(\"hooks\").join(\"pre-push\");\n+    if dst.exists() {\n+        // The git hook has already been set up, or the user already has a custom hook.\n+        return Ok(());\n+    }\n+\n     let mut input = String::new();\n+    println!();\n     println!(\n         \"Rust's CI will automatically fail if it doesn't pass `tidy`, the internal tool for ensuring code quality.\n If you'd like, x.py can install a git hook for you that will automatically run `tidy --bless` before\n@@ -329,12 +338,6 @@ undesirable, simply delete the `pre-push` file from .git/hooks.\"\n \n     if should_install {\n         let src = config.src.join(\"src\").join(\"etc\").join(\"pre-push.sh\");\n-        let git =\n-            t!(config.git().args(&[\"rev-parse\", \"--git-common-dir\"]).output().map(|output| {\n-                assert!(output.status.success(), \"failed to run `git`\");\n-                PathBuf::from(t!(String::from_utf8(output.stdout)).trim())\n-            }));\n-        let dst = git.join(\"hooks\").join(\"pre-push\");\n         match fs::hard_link(src, &dst) {\n             Err(e) => eprintln!(\n                 \"error: could not create hook {}: do you already have the git hook installed?\\n{}\","}, {"sha": "e0be4c432f168baceeb1a32666d3a1c482d94e90", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -380,6 +380,8 @@ bootstrap_tool!(\n     HtmlChecker, \"src/tools/html-checker\", \"html-checker\";\n     BumpStage0, \"src/tools/bump-stage0\", \"bump-stage0\";\n     ReplaceVersionPlaceholder, \"src/tools/replace-version-placeholder\", \"replace-version-placeholder\";\n+    CollectLicenseMetadata, \"src/tools/collect-license-metadata\", \"collect-license-metadata\";\n+    GenerateCopyright, \"src/tools/generate-copyright\", \"generate-copyright\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]"}, {"sha": "699938c37184285eef21b68354f85efd3455f03f", "filename": "src/ci/docker/host-aarch64/aarch64-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-aarch64%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-aarch64%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-aarch64%2Faarch64-gnu%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -14,7 +14,8 @@ RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-ins\n   gdb \\\n   libssl-dev \\\n   pkg-config \\\n-  xz-utils\n+  xz-utils \\\n+  && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "ea4a2a2427dbf8ba29e66719bbd6d4163fb0b340", "filename": "src/ci/docker/host-x86_64/dist-i686-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-linux%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -32,7 +32,8 @@ RUN yum upgrade -y && \\\n       wget \\\n       xz \\\n       zlib-devel.i686 \\\n-      zlib-devel.x86_64\n+      zlib-devel.x86_64 \\\n+      && yum clean all\n \n RUN mkdir -p /rustroot/bin && ln -s /usr/bin/cmake3 /rustroot/bin/cmake\n "}, {"sha": "67cee0148b24ec4cbb9a3e47f1aa379879106319", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -2,15 +2,15 @@\n \n set -ex\n \n-# Originally from https://github.com/llvm/llvm-project/releases/download/llvmorg-14.0.0/clang+llvm-14.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz\n-curl https://ci-mirrors.rust-lang.org/rustc/2022-05-10-clang%2Bllvm-14.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz | \\\n+# Originally from https://github.com/llvm/llvm-project/releases/download/llvmorg-15.0.6/clang+llvm-15.0.6-x86_64-linux-gnu-ubuntu-18.04.tar.xz\n+curl https://ci-mirrors.rust-lang.org/rustc/2022-12-06-clang%2Bllvm-15.0.6-x86_64-linux-gnu-ubuntu-18.04.tar.xz | \\\n   tar xJf -\n-bin=\"$PWD/clang+llvm-14.0.0-x86_64-linux-gnu-ubuntu-18.04/bin\"\n+bin=\"$PWD/clang+llvm-15.0.6-x86_64-linux-gnu-ubuntu-18.04/bin\"\n \n git clone https://github.com/WebAssembly/wasi-libc\n \n cd wasi-libc\n-git reset --hard 9886d3d6200fcc3726329966860fc058707406cd\n+git reset --hard 8b7148f69ae241a2749b3defe4606da8143b72e0\n make -j$(nproc) \\\n     CC=\"$bin/clang\" \\\n     NM=\"$bin/llvm-nm\" \\"}, {"sha": "377d4a9ce5ebde94f3ef2a56a24c890d8071908e", "filename": "src/ci/docker/host-x86_64/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -15,7 +15,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils \\\n   wget \\\n   libssl-dev \\\n-  pkg-config\n+  pkg-config \\\n+  && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/freebsd-toolchain.sh /tmp/\n RUN /tmp/freebsd-toolchain.sh x86_64"}, {"sha": "4e46bdee5acb581e412ec6b4f9a7313dc3abb245", "filename": "src/ci/docker/host-x86_64/dist-x86_64-illumos/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-illumos%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-illumos%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-illumos%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -11,7 +11,8 @@ RUN apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n       libgmp-dev \\\n       libmpfr-dev \\\n-      libmpc-dev\n+      libmpc-dev \\\n+      && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/illumos-toolchain.sh /tmp/\n "}, {"sha": "6bdc88e18f530f8d9e2dc64ce6f41564a354c65f", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -32,7 +32,8 @@ RUN yum upgrade -y && \\\n       wget \\\n       xz \\\n       zlib-devel.i686 \\\n-      zlib-devel.x86_64\n+      zlib-devel.x86_64 \\\n+      && yum clean all\n \n RUN mkdir -p /rustroot/bin && ln -s /usr/bin/cmake3 /rustroot/bin/cmake\n "}, {"sha": "13eaf7fce8cd76ae1a921b9dbdafb447537dde9f", "filename": "src/ci/docker/host-x86_64/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -16,7 +16,8 @@ RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-ins\n   gdb \\\n   patch \\\n   libssl-dev \\\n-  pkg-config\n+  pkg-config \\\n+  && rm -rf /var/lib/apt/lists/*\n \n WORKDIR /build/\n "}, {"sha": "e2b66c2cff1d8258e6721013559367b499e1005c", "filename": "src/ci/docker/host-x86_64/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -15,7 +15,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   zlib1g-dev \\\n   lib32z1-dev \\\n-  xz-utils\n+  xz-utils \\\n+  && rm -rf /var/lib/apt/lists/*\n \n \n COPY scripts/sccache.sh /scripts/"}, {"sha": "cb6559707d962b53ab03f97515b1a9a68cd53425", "filename": "src/ci/docker/host-x86_64/i686-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -15,7 +15,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   zlib1g-dev \\\n   lib32z1-dev \\\n-  xz-utils\n+  xz-utils \\\n+  && rm -rf /var/lib/apt/lists/*\n \n \n COPY scripts/sccache.sh /scripts/"}, {"sha": "40caa7c50135d31dae92b8331501572436f874dd", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -20,20 +20,20 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils \\\n   libssl-dev \\\n   pkg-config \\\n-  mingw-w64\n+  mingw-w64 \\\n+  && rm -rf /var/lib/apt/lists/*\n \n RUN curl -sL https://nodejs.org/dist/v16.9.0/node-v16.9.0-linux-x64.tar.xz | tar -xJ\n ENV PATH=\"/node-v16.9.0-linux-x64/bin:${PATH}\"\n # Install es-check\n # Pin its version to prevent unrelated CI failures due to future es-check versions.\n-RUN npm install es-check@6.1.1 -g\n-RUN npm install eslint@8.6.0 -g\n+RUN npm install es-check@6.1.1 eslint@8.6.0 -g\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n COPY host-x86_64/mingw-check/reuse-requirements.txt /tmp/\n-RUN pip3 install --no-deps --require-hashes -r /tmp/reuse-requirements.txt\n+RUN pip3 install --no-deps --no-cache-dir --require-hashes -r /tmp/reuse-requirements.txt\n \n COPY host-x86_64/mingw-check/validate-toolstate.sh /scripts/\n COPY host-x86_64/mingw-check/validate-error-codes.sh /scripts/"}, {"sha": "cf4451f8b33b64faa99c717e4ccb6f340b6014fb", "filename": "src/ci/docker/host-x86_64/test-various/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -21,7 +21,8 @@ RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-ins\n   ovmf \\\n   qemu-efi-aarch64 \\\n   qemu-system-arm \\\n-  qemu-system-x86\n+  qemu-system-x86 \\\n+  && rm -rf /var/lib/apt/lists/*\n \n RUN curl -sL https://nodejs.org/dist/v15.14.0/node-v15.14.0-linux-x64.tar.xz | \\\n   tar -xJ"}, {"sha": "ef1fde1c3b924711c29829f75df0d1f89880e3dd", "filename": "src/ci/docker/host-x86_64/wasm32/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fwasm32%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -13,7 +13,8 @@ RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-ins\n   sudo \\\n   gdb \\\n   xz-utils \\\n-  bzip2\n+  bzip2 \\\n+  && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/emscripten.sh /scripts/\n RUN bash /scripts/emscripten.sh"}, {"sha": "e08c4e1e8b7dec7c07fc11c9791e70b528b36554", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-aux/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-aux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-aux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-aux%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -19,7 +19,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   llvm-dev \\\n   libfreetype6-dev \\\n   libexpat1-dev \\\n-  tidy\n+  tidy \\\n+  && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "c2b002055a8fcc9c6176fbf16986c3b2e4b66a55", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-debug%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -23,7 +23,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config \\\n   xz-utils \\\n   lld \\\n-  clang\n+  clang \\\n+  && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "7e640c49f015a4a413fc657b7f2567164b7ad5eb", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-distcheck/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-distcheck%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -15,7 +15,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils \\\n   libssl-dev \\\n-  pkg-config\n+  pkg-config \\\n+  && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "16976a9428ef1ebd3e8b4c34ffea94740ef7afdd", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-13-stage1/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13-stage1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13-stage1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13-stage1%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -21,7 +21,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n     pkg-config \\\n     zlib1g-dev \\\n     xz-utils \\\n-    nodejs\n+    nodejs \\\n+    && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "06f15bd121174eb5a195056bf12e75bfab390775", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-13/Dockerfile", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -24,15 +24,15 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config \\\n   zlib1g-dev \\\n   xz-utils \\\n-  nodejs\n-\n+  nodejs \\\n+  \\\n # Install powershell so we can test x.ps1 on Linux\n-RUN apt-get update && \\\n-    apt-get install -y apt-transport-https software-properties-common && \\\n+    apt-transport-https software-properties-common && \\\n     curl -s \"https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb\" > packages-microsoft-prod.deb && \\\n     dpkg -i packages-microsoft-prod.deb && \\\n     apt-get update && \\\n-    apt-get install -y powershell\n+    apt-get install -y powershell \\\n+    && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "9fdc78406fbd1f0f04f69c9006f6f32fe37ea820", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -15,7 +15,8 @@ RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-ins\n   gdb \\\n   libssl-dev \\\n   pkg-config \\\n-  xz-utils\n+  xz-utils \\\n+  && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "58c0c5db1a5d613a962e15ec93002e0e13b0a0bc", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -14,10 +14,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   sudo \\\n   xz-utils \\\n-  tidy\n-\n+  tidy \\\n+  \\\n # Install dependencies for chromium browser\n-RUN apt-get install -y \\\n   gconf-service \\\n   libasound2 \\\n   libatk1.0-0 \\\n@@ -56,7 +55,8 @@ RUN apt-get install -y \\\n   libnss3 \\\n   lsb-release \\\n   xdg-utils \\\n-  wget\n+  wget \\\n+  && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "5b9581f72a64ef63dcc2df31a5100efe82fb83fc", "filename": "src/ci/docker/host-x86_64/x86_64-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -15,7 +15,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   libssl-dev \\\n   pkg-config \\\n-  xz-utils\n+  xz-utils \\\n+  && rm -rf /var/lib/apt/lists/*\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "17cd456b995a1fcccd4970777a693ef7cc81bfba", "filename": "src/ci/docker/scripts/freebsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -53,7 +53,7 @@ files_to_extract=(\n for lib in c cxxrt gcc_s m thr util; do\n   files_to_extract=(\"${files_to_extract[@]}\" \"./lib/lib${lib}.*\" \"./usr/lib/lib${lib}.*\")\n done\n-for lib in c++ c_nonshared compiler_rt execinfo gcc pthread rt ssp_nonshared procstat devstat kvm; do\n+for lib in c++ c_nonshared compiler_rt execinfo gcc pthread rt ssp_nonshared procstat devstat kvm memstat; do\n   files_to_extract=(\"${files_to_extract[@]}\" \"./usr/lib/lib${lib}.*\")\n done\n "}, {"sha": "a60f4316ec923a5ac2ed6a2eba6960edb832d855", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1 +1 @@\n-Subproject commit 3f64052c048c6def93b94a2b514ee88bba918744\n+Subproject commit a60f4316ec923a5ac2ed6a2eba6960edb832d855"}, {"sha": "19f798d448835a4888e3b3eae7fe69f1d61d8681", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1 +1 @@\n-Subproject commit c533348edd69f11a8f4225d633a05d7093fddbf3\n+Subproject commit 19f798d448835a4888e3b3eae7fe69f1d61d8681"}, {"sha": "ae406aa5287a9e025abb72343aaceec98458c117", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1 +1 @@\n-Subproject commit 05532356e7a4dbea2330aabb77611f5179493bb8\n+Subproject commit ae406aa5287a9e025abb72343aaceec98458c117"}, {"sha": "3ae62681ff236d5528ef7c8c28ba7c6b2ecc6731", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1 +1 @@\n-Subproject commit 9f0cc13ffcd27c1fbe1ab766a9491e15ddcf4d19\n+Subproject commit 3ae62681ff236d5528ef7c8c28ba7c6b2ecc6731"}, {"sha": "a9869b4a3c4cac3bc6099b41f088679e268400b8", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1 +1 @@\n-Subproject commit 2b15c0abf2bada6e00553814336bc3e2d8399097\n+Subproject commit a9869b4a3c4cac3bc6099b41f088679e268400b8"}, {"sha": "e269950a57fa6fcda356426545fb5aa3691a7ced", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1 +1 @@\n-Subproject commit d0dc6c97a6486f68bac782fff135086eae6d77ec\n+Subproject commit e269950a57fa6fcda356426545fb5aa3691a7ced"}, {"sha": "b492da88474ee297d63fa6fbafc08fbd9c1f8ae5", "filename": "src/doc/unstable-book/src/language-features/abi-efiapi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-efiapi.md", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-efiapi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fabi-efiapi.md?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -12,7 +12,7 @@ Specification].\n \n Example:\n \n-```rust\n+```rust,ignore (not-all-targets-support-uefi)\n #![feature(abi_efiapi)]\n \n extern \"efiapi\" { fn f1(); }"}, {"sha": "111361796075b863cf22b061d09e015cf51705ca", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -195,8 +195,7 @@ h1, h2, h3, h4, h5, h6,\n span.since,\n a.srclink,\n #help-button > a,\n-details.rustdoc-toggle.top-doc > summary,\n-details.rustdoc-toggle.non-exhaustive > summary,\n+summary.hideme,\n .scraped-example-list,\n /* This selector is for the items listed in the \"all items\" page. */\n ul.all-items {\n@@ -213,8 +212,7 @@ pre.rust a,\n .mobile-topbar h2 a,\n h1 a,\n .search-results a,\n-.module-item .stab,\n-.import-item .stab,\n+.item-left .stab,\n .result-name .primitive > i, .result-name .keyword > i {\n \tcolor: var(--main-color);\n }\n@@ -1011,11 +1009,9 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \t\t0 -1px 0 black;\n }\n \n-.module-item .stab,\n-.import-item .stab {\n+.item-left .stab {\n \tborder-radius: 3px;\n \tdisplay: inline-block;\n-\tfont-size: 0.875rem;\n \tline-height: 1.2;\n \tmargin-bottom: 0;\n \tmargin-left: 0.3125em;\n@@ -1484,6 +1480,7 @@ details.rustdoc-toggle {\n \t\"Expand description\" or \"Show methods\". */\n details.rustdoc-toggle > summary.hideme {\n \tcursor: pointer;\n+\tfont-size: 1rem;\n }\n \n details.rustdoc-toggle > summary {\n@@ -1546,13 +1543,6 @@ details.rustdoc-toggle > summary:focus-visible::before {\n \toutline-offset: 1px;\n }\n \n-details.rustdoc-toggle.top-doc > summary,\n-details.rustdoc-toggle.top-doc > summary::before,\n-details.rustdoc-toggle.non-exhaustive > summary,\n-details.rustdoc-toggle.non-exhaustive > summary::before {\n-\tfont-size: 1rem;\n-}\n-\n details.non-exhaustive {\n \tmargin-bottom: 8px;\n }\n@@ -1660,8 +1650,6 @@ in storage.js\n \t\t/* Hide the sidebar offscreen while not in use. Doing this instead of display: none means\n \t\t   the sidebar stays visible for screen readers, which is useful for navigation. */\n \t\tleft: -1000px;\n-\t\tmargin: 0;\n-\t\tpadding: 0;\n \t\tz-index: 11;\n \t\t/* Reduce height slightly to account for mobile topbar. */\n \t\theight: calc(100vh - 45px);\n@@ -1978,7 +1966,9 @@ in storage.js\n }\n \n .scraped-example .code-wrapper .example-wrap {\n-\tflex: 1;\n+\tdisplay: grid;\n+\tgrid-template-columns: max-content auto;\n+\twidth: 100%;\n \toverflow-x: auto;\n \toverflow-y: hidden;\n \tmargin-bottom: 0;"}, {"sha": "e328e656edda4caa59625cdca9b5c0b9d53b143f", "filename": "src/librustdoc/html/static/js/scrape-examples.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fscrape-examples.js", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fscrape-examples.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fscrape-examples.js?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -57,7 +57,7 @@\n                     });\n                 });\n \n-            example.querySelector(\"next\")\n+            example.querySelector(\".next\")\n                 .addEventListener(\"click\", () => {\n                     onChangeLoc(() => {\n                         locIndex = (locIndex + 1) % locs.length;"}, {"sha": "b48b82307ebc3c672a87b2af3765250ea6081748", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -130,4 +130,4 @@ static_files! {\n     nanum_barun_gothic_license => \"static/fonts/NanumBarunGothic-LICENSE.txt\",\n }\n \n-pub(crate) static SCRAPE_EXAMPLES_HELP_MD: &str = include_str!(\"static/js/scrape-examples.js\");\n+pub(crate) static SCRAPE_EXAMPLES_HELP_MD: &str = include_str!(\"static/scrape-examples-help.md\");"}, {"sha": "3dfd4d93fa013e1c0578d3ceac5c8f4ebba4b6ec", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1 +1 @@\n-Subproject commit a1232c451fc27173f8718e05d174b2503ca0b607\n+Subproject commit 3dfd4d93fa013e1c0578d3ceac5c8f4ebba4b6ec"}, {"sha": "afe157ccd7faa3d08361122791c41967f3014620", "filename": "src/test/mir-opt/inline/cycle.g.Inline.diff", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -10,8 +10,6 @@\n +         let _3: ();                      // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         let mut _4: &fn() {main};        // in scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         let mut _5: ();                  // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         scope 2 (inlined <fn() {main} as Fn<()>>::call - shim(fn() {main})) { // at $DIR/cycle.rs:6:5: 6:8\n-+         }\n +     }\n   \n       bb0: {\n@@ -29,7 +27,10 @@\n +         StorageLive(_4);                 // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         _4 = &_2;                        // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         StorageLive(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         _3 = move (*_4)() -> [return: bb4, unwind: bb2]; // scope 2 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n++         _3 = <fn() {main} as Fn<()>>::call(move _4, move _5) -> [return: bb2, unwind: bb3]; // scope 1 at $DIR/cycle.rs:6:5: 6:8\n++                                          // mir::Constant\n++                                          // + span: $DIR/cycle.rs:6:5: 6:6\n++                                          // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a fn() {main}, ()) -> <fn() {main} as FnOnce<()>>::Output {<fn() {main} as Fn<()>>::call}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n@@ -39,19 +40,19 @@\n           return;                          // scope 0 at $DIR/cycle.rs:+2:2: +2:2\n +     }\n + \n-+     bb2 (cleanup): {\n-+         drop(_2) -> bb3;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n++     bb2: {\n++         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n++         StorageDead(_4);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n++         StorageDead(_3);                 // scope 1 at $DIR/cycle.rs:6:8: 6:9\n++         drop(_2) -> bb1;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n +     }\n + \n +     bb3 (cleanup): {\n-+         resume;                          // scope 1 at $DIR/cycle.rs:5:1: 7:2\n++         drop(_2) -> bb4;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n +     }\n + \n-+     bb4: {\n-+         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n-+         StorageDead(_4);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n-+         StorageDead(_3);                 // scope 1 at $DIR/cycle.rs:6:8: 6:9\n-+         drop(_2) -> bb1;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n++     bb4 (cleanup): {\n++         resume;                          // scope 1 at $DIR/cycle.rs:5:1: 7:2\n       }\n   }\n   "}, {"sha": "bd89e09ecd148b4e52384621802be95f24c94e43", "filename": "src/test/mir-opt/inline/cycle.main.Inline.diff", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -10,18 +10,6 @@\n +         let _3: ();                      // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         let mut _4: &fn() {g};           // in scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         let mut _5: ();                  // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         scope 2 (inlined <fn() {g} as Fn<()>>::call - shim(fn() {g})) { // at $DIR/cycle.rs:6:5: 6:8\n-+             scope 3 (inlined g) {        // at $SRC_DIR/core/src/ops/function.rs:LL:COL\n-+                 let mut _6: fn() {main}; // in scope 3 at $DIR/cycle.rs:12:5: 12:12\n-+                 scope 4 (inlined f::<fn() {main}>) { // at $DIR/cycle.rs:12:5: 12:12\n-+                     debug g => _6;       // in scope 4 at $DIR/cycle.rs:5:6: 5:7\n-+                     let _7: ();          // in scope 4 at $DIR/cycle.rs:6:5: 6:8\n-+                     let mut _8: &fn() {main}; // in scope 4 at $DIR/cycle.rs:6:5: 6:6\n-+                     scope 5 (inlined <fn() {main} as Fn<()>>::call - shim(fn() {main})) { // at $DIR/cycle.rs:6:5: 6:8\n-+                     }\n-+                 }\n-+             }\n-+         }\n +     }\n   \n       bb0: {\n@@ -39,11 +27,10 @@\n +         StorageLive(_4);                 // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         _4 = &_2;                        // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         StorageLive(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n-+         StorageLive(_6);                 // scope 3 at $DIR/cycle.rs:12:5: 12:12\n-+         StorageLive(_7);                 // scope 4 at $DIR/cycle.rs:6:5: 6:8\n-+         StorageLive(_8);                 // scope 4 at $DIR/cycle.rs:6:5: 6:6\n-+         _8 = &_6;                        // scope 4 at $DIR/cycle.rs:6:5: 6:6\n-+         _7 = move (*_8)() -> [return: bb4, unwind: bb2]; // scope 5 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n++         _3 = <fn() {g} as Fn<()>>::call(move _4, move _5) -> [return: bb2, unwind: bb3]; // scope 1 at $DIR/cycle.rs:6:5: 6:8\n++                                          // mir::Constant\n++                                          // + span: $DIR/cycle.rs:6:5: 6:6\n++                                          // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a fn() {g}, ()) -> <fn() {g} as FnOnce<()>>::Output {<fn() {g} as Fn<()>>::call}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n@@ -53,22 +40,19 @@\n           return;                          // scope 0 at $DIR/cycle.rs:+2:2: +2:2\n +     }\n + \n-+     bb2 (cleanup): {\n-+         drop(_2) -> bb3;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n++     bb2: {\n++         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n++         StorageDead(_4);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n++         StorageDead(_3);                 // scope 1 at $DIR/cycle.rs:6:8: 6:9\n++         drop(_2) -> bb1;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n +     }\n + \n +     bb3 (cleanup): {\n-+         resume;                          // scope 1 at $DIR/cycle.rs:5:1: 7:2\n++         drop(_2) -> bb4;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n +     }\n + \n-+     bb4: {\n-+         StorageDead(_8);                 // scope 4 at $DIR/cycle.rs:6:7: 6:8\n-+         StorageDead(_7);                 // scope 4 at $DIR/cycle.rs:6:8: 6:9\n-+         StorageDead(_6);                 // scope 3 at $DIR/cycle.rs:12:5: 12:12\n-+         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n-+         StorageDead(_4);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n-+         StorageDead(_3);                 // scope 1 at $DIR/cycle.rs:6:8: 6:9\n-+         drop(_2) -> bb1;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n++     bb4 (cleanup): {\n++         resume;                          // scope 1 at $DIR/cycle.rs:5:1: 7:2\n       }\n   }\n   "}, {"sha": "d9fd7b324c7619e79a1fa373b9ebba312225d8c6", "filename": "src/test/mir-opt/inline/exponential_runtime.main.Inline.diff", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Fexponential_runtime.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Fexponential_runtime.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fexponential_runtime.main.Inline.diff?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,50 @@\n+- // MIR for `main` before Inline\n++ // MIR for `main` after Inline\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/exponential_runtime.rs:+0:11: +0:11\n+      let _1: ();                          // in scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n++     scope 1 (inlined <() as G>::call) {  // at $DIR/exponential_runtime.rs:86:5: 86:22\n++         let _2: ();                      // in scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n++         let _3: ();                      // in scope 1 at $DIR/exponential_runtime.rs:74:9: 74:25\n++         let _4: ();                      // in scope 1 at $DIR/exponential_runtime.rs:75:9: 75:25\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n+-         _1 = <() as G>::call() -> bb1;   // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n++         StorageLive(_2);                 // scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n++         _2 = <() as F>::call() -> bb1;   // scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n+                                           // mir::Constant\n+-                                          // + span: $DIR/exponential_runtime.rs:86:5: 86:20\n+-                                          // + literal: Const { ty: fn() {<() as G>::call}, val: Value(<ZST>) }\n++                                          // + span: $DIR/exponential_runtime.rs:73:9: 73:23\n++                                          // + literal: Const { ty: fn() {<() as F>::call}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n++         StorageDead(_2);                 // scope 1 at $DIR/exponential_runtime.rs:73:25: 73:26\n++         StorageLive(_3);                 // scope 1 at $DIR/exponential_runtime.rs:74:9: 74:25\n++         _3 = <() as F>::call() -> bb2;   // scope 1 at $DIR/exponential_runtime.rs:74:9: 74:25\n++                                          // mir::Constant\n++                                          // + span: $DIR/exponential_runtime.rs:74:9: 74:23\n++                                          // + literal: Const { ty: fn() {<() as F>::call}, val: Value(<ZST>) }\n++     }\n++ \n++     bb2: {\n++         StorageDead(_3);                 // scope 1 at $DIR/exponential_runtime.rs:74:25: 74:26\n++         StorageLive(_4);                 // scope 1 at $DIR/exponential_runtime.rs:75:9: 75:25\n++         _4 = <() as F>::call() -> bb3;   // scope 1 at $DIR/exponential_runtime.rs:75:9: 75:25\n++                                          // mir::Constant\n++                                          // + span: $DIR/exponential_runtime.rs:75:9: 75:23\n++                                          // + literal: Const { ty: fn() {<() as F>::call}, val: Value(<ZST>) }\n++     }\n++ \n++     bb3: {\n++         StorageDead(_4);                 // scope 1 at $DIR/exponential_runtime.rs:75:25: 75:26\n+          StorageDead(_1);                 // scope 0 at $DIR/exponential_runtime.rs:+1:22: +1:23\n+          _0 = const ();                   // scope 0 at $DIR/exponential_runtime.rs:+0:11: +2:2\n+          return;                          // scope 0 at $DIR/exponential_runtime.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "d9219d76a98bc6ee11d606eca475d588e7be1181", "filename": "src/test/mir-opt/inline/exponential_runtime.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Fexponential_runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Fexponential_runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fexponential_runtime.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,87 @@\n+// Checks that code with exponential runtime does not have exponential behavior in inlining.\n+\n+trait A {\n+    fn call();\n+}\n+\n+trait B {\n+    fn call();\n+}\n+impl<T: A> B for T {\n+    #[inline]\n+    fn call() {\n+        <T as A>::call();\n+        <T as A>::call();\n+        <T as A>::call();\n+    }\n+}\n+\n+trait C {\n+    fn call();\n+}\n+impl<T: B> C for T {\n+    #[inline]\n+    fn call() {\n+        <T as B>::call();\n+        <T as B>::call();\n+        <T as B>::call();\n+    }\n+}\n+\n+trait D {\n+    fn call();\n+}\n+impl<T: C> D for T {\n+    #[inline]\n+    fn call() {\n+        <T as C>::call();\n+        <T as C>::call();\n+        <T as C>::call();\n+    }\n+}\n+\n+trait E {\n+    fn call();\n+}\n+impl<T: D> E for T {\n+    #[inline]\n+    fn call() {\n+        <T as D>::call();\n+        <T as D>::call();\n+        <T as D>::call();\n+    }\n+}\n+\n+trait F {\n+    fn call();\n+}\n+impl<T: E> F for T {\n+    #[inline]\n+    fn call() {\n+        <T as E>::call();\n+        <T as E>::call();\n+        <T as E>::call();\n+    }\n+}\n+\n+trait G {\n+    fn call();\n+}\n+impl<T: F> G for T {\n+    #[inline]\n+    fn call() {\n+        <T as F>::call();\n+        <T as F>::call();\n+        <T as F>::call();\n+    }\n+}\n+\n+impl A for () {\n+    #[inline(never)]\n+    fn call() {}\n+}\n+\n+// EMIT_MIR exponential_runtime.main.Inline.diff\n+fn main() {\n+    <() as G>::call();\n+}"}, {"sha": "f54a1a747d47436aba941cb1ab4df23f43bad2b4", "filename": "src/test/mir-opt/inline/inline_cycle.one.Inline.diff", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.one.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.one.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.one.Inline.diff?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -5,20 +5,17 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline_cycle.rs:+0:10: +0:10\n       let _1: ();                          // in scope 0 at $DIR/inline_cycle.rs:+1:5: +1:24\n +     scope 1 (inlined <C as Call>::call) { // at $DIR/inline_cycle.rs:14:5: 14:24\n-+         scope 2 (inlined <A<C> as Call>::call) { // at $DIR/inline_cycle.rs:43:9: 43:23\n-+             scope 3 (inlined <B<C> as Call>::call) { // at $DIR/inline_cycle.rs:28:9: 28:31\n-+             }\n-+         }\n +     }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/inline_cycle.rs:+1:5: +1:24\n -         _1 = <C as Call>::call() -> bb1; // scope 0 at $DIR/inline_cycle.rs:+1:5: +1:24\n-+         _1 = <C as Call>::call() -> bb1; // scope 3 at $DIR/inline_cycle.rs:36:9: 36:28\n++         _1 = <A<C> as Call>::call() -> bb1; // scope 1 at $DIR/inline_cycle.rs:43:9: 43:23\n                                            // mir::Constant\n -                                          // + span: $DIR/inline_cycle.rs:14:5: 14:22\n-+                                          // + span: $DIR/inline_cycle.rs:36:9: 36:26\n-                                           // + literal: Const { ty: fn() {<C as Call>::call}, val: Value(<ZST>) }\n+-                                          // + literal: Const { ty: fn() {<C as Call>::call}, val: Value(<ZST>) }\n++                                          // + span: $DIR/inline_cycle.rs:43:9: 43:21\n++                                          // + literal: Const { ty: fn() {<A<C> as Call>::call}, val: Value(<ZST>) }\n       }\n   \n       bb1: {"}, {"sha": "a940848c269cda8d5a5a98dd968f334f687dd0a4", "filename": "src/test/mir-opt/inline/inline_cycle.two.Inline.diff", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -9,11 +9,6 @@\n +         debug f => _2;                   // in scope 1 at $DIR/inline_cycle.rs:53:22: 53:23\n +         let _3: ();                      // in scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n +         let mut _4: ();                  // in scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n-+         scope 2 (inlined <fn() {f} as FnOnce<()>>::call_once - shim(fn() {f})) { // at $DIR/inline_cycle.rs:54:5: 54:8\n-+             scope 3 (inlined f) {        // at $SRC_DIR/core/src/ops/function.rs:LL:COL\n-+                 let _5: ();              // in scope 3 at $DIR/inline_cycle.rs:59:5: 59:12\n-+             }\n-+         }\n +     }\n   \n       bb0: {\n@@ -23,23 +18,19 @@\n +         _2 = f;                          // scope 0 at $DIR/inline_cycle.rs:+1:5: +1:12\n                                            // mir::Constant\n -                                          // + span: $DIR/inline_cycle.rs:49:5: 49:9\n-+                                          // + span: $DIR/inline_cycle.rs:49:10: 49:11\n-+                                          // + literal: Const { ty: fn() {f}, val: Value(<ZST>) }\n+-                                          // + literal: Const { ty: fn(fn() {f}) {call::<fn() {f}>}, val: Value(<ZST>) }\n+-                                          // mir::Constant\n+                                           // + span: $DIR/inline_cycle.rs:49:10: 49:11\n+                                           // + literal: Const { ty: fn() {f}, val: Value(<ZST>) }\n +         StorageLive(_3);                 // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n +         StorageLive(_4);                 // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n-+         StorageLive(_5);                 // scope 3 at $DIR/inline_cycle.rs:59:5: 59:12\n-+         _5 = call::<fn() {f}>(f) -> bb1; // scope 3 at $DIR/inline_cycle.rs:59:5: 59:12\n++         _3 = <fn() {f} as FnOnce<()>>::call_once(move _2, move _4) -> bb1; // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n +                                          // mir::Constant\n-+                                          // + span: $DIR/inline_cycle.rs:59:5: 59:9\n-                                           // + literal: Const { ty: fn(fn() {f}) {call::<fn() {f}>}, val: Value(<ZST>) }\n-                                           // mir::Constant\n--                                          // + span: $DIR/inline_cycle.rs:49:10: 49:11\n-+                                          // + span: $DIR/inline_cycle.rs:59:10: 59:11\n-                                           // + literal: Const { ty: fn() {f}, val: Value(<ZST>) }\n++                                          // + span: $DIR/inline_cycle.rs:54:5: 54:6\n++                                          // + literal: Const { ty: extern \"rust-call\" fn(fn() {f}, ()) -> <fn() {f} as FnOnce<()>>::Output {<fn() {f} as FnOnce<()>>::call_once}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-+         StorageDead(_5);                 // scope 3 at $DIR/inline_cycle.rs:59:12: 59:13\n +         StorageDead(_4);                 // scope 1 at $DIR/inline_cycle.rs:54:7: 54:8\n +         StorageDead(_3);                 // scope 1 at $DIR/inline_cycle.rs:54:8: 54:9\n +         StorageDead(_2);                 // scope 0 at $DIR/inline_cycle.rs:+1:5: +1:12"}, {"sha": "04de3e61e5ff81f6b148d18fae783ac62bad7dc8", "filename": "src/test/mir-opt/inline/inline_cycle_generic.main.Inline.diff", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle_generic.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle_generic.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle_generic.main.Inline.diff?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -6,21 +6,18 @@\n       let _1: ();                          // in scope 0 at $DIR/inline_cycle_generic.rs:+1:5: +1:24\n +     scope 1 (inlined <C as Call>::call) { // at $DIR/inline_cycle_generic.rs:9:5: 9:24\n +         scope 2 (inlined <B<A> as Call>::call) { // at $DIR/inline_cycle_generic.rs:38:9: 38:31\n-+             scope 3 (inlined <A as Call>::call) { // at $DIR/inline_cycle_generic.rs:31:9: 31:28\n-+                 scope 4 (inlined <B<C> as Call>::call) { // at $DIR/inline_cycle_generic.rs:23:9: 23:31\n-+                 }\n-+             }\n +         }\n +     }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/inline_cycle_generic.rs:+1:5: +1:24\n -         _1 = <C as Call>::call() -> bb1; // scope 0 at $DIR/inline_cycle_generic.rs:+1:5: +1:24\n-+         _1 = <C as Call>::call() -> bb1; // scope 4 at $DIR/inline_cycle_generic.rs:31:9: 31:28\n++         _1 = <A as Call>::call() -> bb1; // scope 2 at $DIR/inline_cycle_generic.rs:31:9: 31:28\n                                            // mir::Constant\n -                                          // + span: $DIR/inline_cycle_generic.rs:9:5: 9:22\n+-                                          // + literal: Const { ty: fn() {<C as Call>::call}, val: Value(<ZST>) }\n +                                          // + span: $DIR/inline_cycle_generic.rs:31:9: 31:26\n-                                           // + literal: Const { ty: fn() {<C as Call>::call}, val: Value(<ZST>) }\n++                                          // + literal: Const { ty: fn() {<A as Call>::call}, val: Value(<ZST>) }\n       }\n   \n       bb1: {"}, {"sha": "a01bcf1645b0571fe7f662353b5bf6ce1db23725", "filename": "src/test/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -19,14 +19,6 @@\n +             scope 3 {\n +                 debug b => _9;           // in scope 3 at $DIR/inline_diverging.rs:28:9: 28:10\n +             }\n-+             scope 6 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline_diverging.rs:28:13: 28:16\n-+                 scope 7 (inlined sleep) { // at $SRC_DIR/core/src/ops/function.rs:LL:COL\n-+                 }\n-+             }\n-+         }\n-+         scope 4 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline_diverging.rs:27:13: 27:16\n-+             scope 5 (inlined sleep) {    // at $SRC_DIR/core/src/ops/function.rs:LL:COL\n-+             }\n +         }\n +     }\n   \n@@ -46,11 +38,51 @@\n +         StorageLive(_4);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n +         _4 = &_2;                        // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n +         StorageLive(_5);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n-+         goto -> bb1;                     // scope 5 at $DIR/inline_diverging.rs:39:5: 39:12\n++         _3 = <fn() -> ! {sleep} as Fn<()>>::call(move _4, move _5) -> [return: bb1, unwind: bb5]; // scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n++                                          // mir::Constant\n++                                          // + span: $DIR/inline_diverging.rs:27:13: 27:14\n++                                          // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a fn() -> ! {sleep}, ()) -> <fn() -> ! {sleep} as FnOnce<()>>::Output {<fn() -> ! {sleep} as Fn<()>>::call}, val: Value(<ZST>) }\n +     }\n + \n +     bb1: {\n-+         goto -> bb1;                     // scope 5 at $DIR/inline_diverging.rs:39:5: 39:12\n++         StorageDead(_5);                 // scope 1 at $DIR/inline_diverging.rs:27:15: 27:16\n++         StorageDead(_4);                 // scope 1 at $DIR/inline_diverging.rs:27:15: 27:16\n++         StorageLive(_6);                 // scope 2 at $DIR/inline_diverging.rs:28:13: 28:14\n++         _6 = &_2;                        // scope 2 at $DIR/inline_diverging.rs:28:13: 28:14\n++         StorageLive(_7);                 // scope 2 at $DIR/inline_diverging.rs:28:13: 28:16\n++         _9 = <fn() -> ! {sleep} as Fn<()>>::call(move _6, move _7) -> [return: bb2, unwind: bb4]; // scope 2 at $DIR/inline_diverging.rs:28:13: 28:16\n++                                          // mir::Constant\n++                                          // + span: $DIR/inline_diverging.rs:28:13: 28:14\n++                                          // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a fn() -> ! {sleep}, ()) -> <fn() -> ! {sleep} as FnOnce<()>>::Output {<fn() -> ! {sleep} as Fn<()>>::call}, val: Value(<ZST>) }\n++     }\n++ \n++     bb2: {\n++         StorageDead(_7);                 // scope 2 at $DIR/inline_diverging.rs:28:15: 28:16\n++         StorageDead(_6);                 // scope 2 at $DIR/inline_diverging.rs:28:15: 28:16\n++         StorageLive(_8);                 // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n++         _8 = move _3;                    // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n++         Deinit(_1);                      // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n++         (_1.0: !) = move _8;             // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n++         (_1.1: !) = move _9;             // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n++         StorageDead(_8);                 // scope 3 at $DIR/inline_diverging.rs:29:10: 29:11\n++         StorageDead(_3);                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n++         drop(_2) -> bb3;                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n++     }\n++ \n++     bb3: {\n++         unreachable;                     // scope 0 at $DIR/inline_diverging.rs:30:2: 30:2\n++     }\n++ \n++     bb4 (cleanup): {\n++         drop(_3) -> bb5;                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n++     }\n++ \n++     bb5 (cleanup): {\n++         drop(_2) -> bb6;                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n++     }\n++ \n++     bb6 (cleanup): {\n++         resume;                          // scope 1 at $DIR/inline_diverging.rs:26:1: 30:2\n       }\n   }\n   "}, {"sha": "60149ff36064ecc3d87e433209e01328f5dc1843", "filename": "src/test/mir-opt/inline/inline_retag.bar.Inline.after.mir", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -38,9 +38,7 @@ fn bar() -> bool {\n                                          // + literal: Const { ty: &i32, val: Unevaluated(bar, [], Some(promoted[1])) }\n         Retag(_10);                      // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n         _4 = &(*_10);                    // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n-        Retag(_4);                       // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n         _3 = &(*_4);                     // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n-        Retag(_3);                       // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n         StorageLive(_6);                 // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         StorageLive(_7);                 // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         _9 = const _;                    // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n@@ -49,9 +47,7 @@ fn bar() -> bool {\n                                          // + literal: Const { ty: &i32, val: Unevaluated(bar, [], Some(promoted[0])) }\n         Retag(_9);                       // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         _7 = &(*_9);                     // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n-        Retag(_7);                       // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         _6 = &(*_7);                     // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n-        Retag(_6);                       // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         Retag(_3);                       // scope 2 at $DIR/inline_retag.rs:16:8: 16:9\n         Retag(_6);                       // scope 2 at $DIR/inline_retag.rs:16:17: 16:18\n         StorageLive(_11);                // scope 2 at $DIR/inline_retag.rs:17:5: 17:7"}, {"sha": "12e914e25e0c83b2ef61c2c0440f0ab1796f5d49", "filename": "src/test/mir-opt/remove_zsts.get_union.PreCodegen.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fremove_zsts.get_union.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fremove_zsts.get_union.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_zsts.get_union.PreCodegen.after.mir?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `get_union` after PreCodegen\n+\n+fn get_union() -> Foo {\n+    let mut _0: Foo;                     // return place in scope 0 at $DIR/remove_zsts.rs:+0:19: +0:22\n+\n+    bb0: {\n+        Deinit(_0);                      // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n+        return;                          // scope 0 at $DIR/remove_zsts.rs:+2:2: +2:2\n+    }\n+}"}, {"sha": "169b7b1054b474a588ad675e8bbbff6bc818d2cc", "filename": "src/test/mir-opt/remove_zsts.get_union.RemoveZsts.diff", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fremove_zsts.get_union.RemoveZsts.diff", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fremove_zsts.get_union.RemoveZsts.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_zsts.get_union.RemoveZsts.diff?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,19 @@\n+- // MIR for `get_union` before RemoveZsts\n++ // MIR for `get_union` after RemoveZsts\n+  \n+  fn get_union() -> Foo {\n+      let mut _0: Foo;                     // return place in scope 0 at $DIR/remove_zsts.rs:+0:19: +0:22\n+      let mut _1: ();                      // in scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n+-         Deinit(_1);                      // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n++         nop;                             // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n+          Deinit(_0);                      // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n+-         (_0.0: ()) = move _1;            // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n++         nop;                             // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n+          StorageDead(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:17: +1:18\n+          return;                          // scope 0 at $DIR/remove_zsts.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "1cf7ad6e3667c11e058f05fb3aa1e98eadbcc747", "filename": "src/test/mir-opt/remove_zsts.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_zsts.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,14 @@\n+union Foo {\n+    x: (),\n+    y: u64,\n+}\n+\n+// EMIT_MIR remove_zsts.get_union.RemoveZsts.diff\n+// EMIT_MIR remove_zsts.get_union.PreCodegen.after.mir\n+fn get_union() -> Foo {\n+    Foo { x: () }\n+}\n+\n+fn main() {\n+    get_union();\n+}"}, {"sha": "7d9e6046202ca312023fefc4b4c35e5bd94f7dae", "filename": "src/test/mir-opt/remove_zsts_dont_touch_unions.get_union.RemoveZsts.after.mir", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f8393f87f8bdfad388fe112464d97661a8cb2/src%2Ftest%2Fmir-opt%2Fremove_zsts_dont_touch_unions.get_union.RemoveZsts.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f8393f87f8bdfad388fe112464d97661a8cb2/src%2Ftest%2Fmir-opt%2Fremove_zsts_dont_touch_unions.get_union.RemoveZsts.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_zsts_dont_touch_unions.get_union.RemoveZsts.after.mir?ref=4e9f8393f87f8bdfad388fe112464d97661a8cb2", "patch": "@@ -1,15 +0,0 @@\n-// MIR for `get_union` after RemoveZsts\n-\n-fn get_union() -> Foo {\n-    let mut _0: Foo;                     // return place in scope 0 at $DIR/remove_zsts_dont_touch_unions.rs:+0:19: +0:22\n-    let mut _1: ();                      // in scope 0 at $DIR/remove_zsts_dont_touch_unions.rs:+1:14: +1:16\n-\n-    bb0: {\n-        StorageLive(_1);                 // scope 0 at $DIR/remove_zsts_dont_touch_unions.rs:+1:14: +1:16\n-        nop;                             // scope 0 at $DIR/remove_zsts_dont_touch_unions.rs:+1:14: +1:16\n-        Deinit(_0);                      // scope 0 at $DIR/remove_zsts_dont_touch_unions.rs:+1:5: +1:18\n-        (_0.0: ()) = move _1;            // scope 0 at $DIR/remove_zsts_dont_touch_unions.rs:+1:5: +1:18\n-        StorageDead(_1);                 // scope 0 at $DIR/remove_zsts_dont_touch_unions.rs:+1:17: +1:18\n-        return;                          // scope 0 at $DIR/remove_zsts_dont_touch_unions.rs:+2:2: +2:2\n-    }\n-}"}, {"sha": "8b9de9b4d65a66fd987f2357d44fc0cecf038e42", "filename": "src/test/mir-opt/remove_zsts_dont_touch_unions.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f8393f87f8bdfad388fe112464d97661a8cb2/src%2Ftest%2Fmir-opt%2Fremove_zsts_dont_touch_unions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f8393f87f8bdfad388fe112464d97661a8cb2/src%2Ftest%2Fmir-opt%2Fremove_zsts_dont_touch_unions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_zsts_dont_touch_unions.rs?ref=4e9f8393f87f8bdfad388fe112464d97661a8cb2", "patch": "@@ -1,19 +0,0 @@\n-// unit-test: RemoveZsts\n-\n-// Ensure RemoveZsts doesn't remove ZST assignments to union fields,\n-// which causes problems in Miri.\n-\n-union Foo {\n-    x: (),\n-    y: u64,\n-}\n-\n-// EMIT_MIR remove_zsts_dont_touch_unions.get_union.RemoveZsts.after.mir\n-fn get_union() -> Foo {\n-    Foo { x: () }\n-}\n-\n-\n-fn main() {\n-    get_union();\n-}"}, {"sha": "7b69b3e07d6c56c6d5b201d3d3da7b29f79751c0", "filename": "src/test/mir-opt/retag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -68,9 +68,7 @@ fn array_casts() -> () {\n         StorageLive(_3);                 // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         StorageLive(_4);                 // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         _4 = &mut _1;                    // scope 1 at $DIR/retag.rs:+2:13: +2:19\n-        Retag(_4);                       // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         _3 = &raw mut (*_4);             // scope 1 at $DIR/retag.rs:+2:13: +2:19\n-        Retag([raw] _3);                 // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         _2 = move _3 as *mut usize (Pointer(ArrayToPointer)); // scope 1 at $DIR/retag.rs:+2:13: +2:33\n         StorageDead(_3);                 // scope 1 at $DIR/retag.rs:+2:32: +2:33\n         StorageDead(_4);                 // scope 1 at $DIR/retag.rs:+2:33: +2:34\n@@ -96,9 +94,7 @@ fn array_casts() -> () {\n         StorageLive(_10);                // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         StorageLive(_11);                // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         _11 = &_8;                       // scope 4 at $DIR/retag.rs:+6:13: +6:15\n-        Retag(_11);                      // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         _10 = &raw const (*_11);         // scope 4 at $DIR/retag.rs:+6:13: +6:15\n-        Retag([raw] _10);                // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         _9 = move _10 as *const usize (Pointer(ArrayToPointer)); // scope 4 at $DIR/retag.rs:+6:13: +6:31\n         StorageDead(_10);                // scope 4 at $DIR/retag.rs:+6:30: +6:31\n         StorageDead(_11);                // scope 4 at $DIR/retag.rs:+6:31: +6:32\n@@ -119,15 +115,13 @@ fn array_casts() -> () {\n         StorageDead(_17);                // scope 6 at $DIR/retag.rs:+7:33: +7:34\n         _15 = (*_16);                    // scope 6 at $DIR/retag.rs:+7:25: +7:34\n         _14 = &_15;                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_14);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _35 = const _;                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // + literal: Const { ty: &usize, val: Unevaluated(array_casts, [], Some(promoted[0])) }\n         Retag(_35);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _18 = &(*_35);                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_18);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Deinit(_13);                     // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         (_13.0: &usize) = move _14;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         (_13.1: &usize) = move _18;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n@@ -164,15 +158,11 @@ fn array_casts() -> () {\n         StorageLive(_30);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_31);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _31 = &(*_20);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_31);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _30 = &(*_31);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_30);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_32);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_33);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _33 = &(*_21);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_33);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _32 = &(*_33);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_32);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_34);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Deinit(_34);                     // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         discriminant(_34) = 0;           // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL"}, {"sha": "14f297e948bec91b29791e7fce4c216c06c76458", "filename": "src/test/mir-opt/retag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -6,7 +6,6 @@ fn std::ptr::drop_in_place(_1: *mut Test) -> () {\n     let mut _3: ();                      // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n \n     bb0: {\n-        Retag([raw] _1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n         _2 = &mut (*_1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n         _3 = <Test as Drop>::drop(move _2) -> bb1; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n                                          // mir::Constant"}, {"sha": "9e5c119a2b24e3300dcca541b860c806c37efe34", "filename": "src/test/mir-opt/retag.main-{closure#0}.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -15,7 +15,6 @@ fn main::{closure#0}(_1: &[closure@main::{closure#0}], _2: &i32) -> &i32 {\n         _3 = _2;                         // scope 0 at $DIR/retag.rs:+1:18: +1:19\n         Retag(_3);                       // scope 0 at $DIR/retag.rs:+1:18: +1:19\n         _0 = &(*_2);                     // scope 1 at $DIR/retag.rs:+2:9: +2:10\n-        Retag(_0);                       // scope 1 at $DIR/retag.rs:+2:9: +2:10\n         StorageDead(_3);                 // scope 0 at $DIR/retag.rs:+3:5: +3:6\n         return;                          // scope 0 at $DIR/retag.rs:+3:6: +3:6\n     }"}, {"sha": "b853e450541729d82ad1b577e63cd67309746209", "filename": "src/test/mir-opt/retag.main.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -65,13 +65,10 @@ fn main() -> () {\n         Deinit(_5);                      // scope 1 at $DIR/retag.rs:+3:17: +3:24\n         (_5.0: i32) = const 0_i32;       // scope 1 at $DIR/retag.rs:+3:17: +3:24\n         _4 = &_5;                        // scope 1 at $DIR/retag.rs:+3:17: +3:36\n-        Retag(_4);                       // scope 1 at $DIR/retag.rs:+3:17: +3:36\n         StorageLive(_6);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         StorageLive(_7);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         _7 = &mut _1;                    // scope 1 at $DIR/retag.rs:+3:29: +3:35\n-        Retag(_7);                       // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         _6 = &mut (*_7);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n-        Retag([2phase] _6);              // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         _3 = Test::foo(move _4, move _6) -> [return: bb1, unwind: bb8]; // scope 1 at $DIR/retag.rs:+3:17: +3:36\n                                          // mir::Constant\n                                          // + span: $DIR/retag.rs:33:25: 33:28\n@@ -93,15 +90,13 @@ fn main() -> () {\n         _9 = move _3;                    // scope 2 at $DIR/retag.rs:+4:19: +4:20\n         Retag(_9);                       // scope 2 at $DIR/retag.rs:+4:19: +4:20\n         _8 = &mut (*_9);                 // scope 2 at $DIR/retag.rs:+4:19: +4:20\n-        Retag(_8);                       // scope 2 at $DIR/retag.rs:+4:19: +4:20\n         StorageDead(_9);                 // scope 2 at $DIR/retag.rs:+4:22: +4:23\n         StorageLive(_10);                // scope 3 at $DIR/retag.rs:+5:13: +5:14\n         _10 = move _8;                   // scope 3 at $DIR/retag.rs:+5:17: +5:18\n         Retag(_10);                      // scope 3 at $DIR/retag.rs:+5:17: +5:18\n         StorageLive(_11);                // scope 4 at $DIR/retag.rs:+7:13: +7:15\n         StorageLive(_12);                // scope 4 at $DIR/retag.rs:+7:18: +7:29\n         _12 = &raw mut (*_10);           // scope 4 at $DIR/retag.rs:+7:18: +7:19\n-        Retag([raw] _12);                // scope 4 at $DIR/retag.rs:+7:18: +7:19\n         _11 = _12;                       // scope 4 at $DIR/retag.rs:+7:18: +7:29\n         StorageDead(_12);                // scope 4 at $DIR/retag.rs:+7:29: +7:30\n         _2 = const ();                   // scope 1 at $DIR/retag.rs:+2:5: +8:6\n@@ -122,9 +117,7 @@ fn main() -> () {\n         StorageLive(_17);                // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         StorageLive(_18);                // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         _18 = &_1;                       // scope 6 at $DIR/retag.rs:+15:16: +15:18\n-        Retag(_18);                      // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         _17 = &(*_18);                   // scope 6 at $DIR/retag.rs:+15:16: +15:18\n-        Retag(_17);                      // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         _15 = move _16(move _17) -> bb3; // scope 6 at $DIR/retag.rs:+15:14: +15:19\n     }\n \n@@ -139,7 +132,6 @@ fn main() -> () {\n         Deinit(_21);                     // scope 7 at $DIR/retag.rs:+18:5: +18:12\n         (_21.0: i32) = const 0_i32;      // scope 7 at $DIR/retag.rs:+18:5: +18:12\n         _20 = &_21;                      // scope 7 at $DIR/retag.rs:+18:5: +18:24\n-        Retag(_20);                      // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         StorageLive(_22);                // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         StorageLive(_23);                // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _28 = const _;                   // scope 7 at $DIR/retag.rs:+18:21: +18:23\n@@ -148,9 +140,7 @@ fn main() -> () {\n                                          // + literal: Const { ty: &i32, val: Unevaluated(main, [], Some(promoted[0])) }\n         Retag(_28);                      // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _23 = &(*_28);                   // scope 7 at $DIR/retag.rs:+18:21: +18:23\n-        Retag(_23);                      // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _22 = &(*_23);                   // scope 7 at $DIR/retag.rs:+18:21: +18:23\n-        Retag(_22);                      // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _19 = Test::foo_shr(move _20, move _22) -> [return: bb4, unwind: bb7]; // scope 7 at $DIR/retag.rs:+18:5: +18:24\n                                          // mir::Constant\n                                          // + span: $DIR/retag.rs:48:13: 48:20\n@@ -171,7 +161,6 @@ fn main() -> () {\n         StorageLive(_25);                // scope 7 at $DIR/retag.rs:+21:9: +21:11\n         StorageLive(_26);                // scope 7 at $DIR/retag.rs:+21:14: +21:28\n         _26 = &raw const (*_15);         // scope 7 at $DIR/retag.rs:+21:14: +21:16\n-        Retag([raw] _26);                // scope 7 at $DIR/retag.rs:+21:14: +21:16\n         _25 = _26;                       // scope 7 at $DIR/retag.rs:+21:14: +21:28\n         StorageDead(_26);                // scope 7 at $DIR/retag.rs:+21:28: +21:29\n         StorageLive(_27);                // scope 8 at $DIR/retag.rs:+23:5: +23:18"}, {"sha": "4b50205fa8081ce7e284517a96d9c43f4a013bef", "filename": "src/test/mir-opt/retag.{impl#0}-foo.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -11,9 +11,7 @@ fn <impl at $DIR/retag.rs:12:1: 12:10>::foo(_1: &Test, _2: &mut i32) -> &mut i32\n         Retag([fn entry] _2);            // scope 0 at $DIR/retag.rs:+0:23: +0:24\n         StorageLive(_3);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         _3 = &mut (*_2);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n-        Retag(_3);                       // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         _0 = &mut (*_3);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n-        Retag(_0);                       // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         StorageDead(_3);                 // scope 0 at $DIR/retag.rs:+2:5: +2:6\n         return;                          // scope 0 at $DIR/retag.rs:+2:6: +2:6\n     }"}, {"sha": "b28c6f687f70d75a37707306fa7efc2a4cb91f5b", "filename": "src/test/mir-opt/separate_const_switch.identity.SeparateConstSwitch.diff", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -22,9 +22,6 @@\n                   let mut _18: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n                   scope 9 {\n                       debug e => _16;      // in scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-                      scope 10 (inlined <i32 as From<i32>>::from) { // at $SRC_DIR/core/src/result.rs:LL:COL\n-                          debug t => _18;  // in scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                      }\n                   }\n               }\n           }\n@@ -95,18 +92,11 @@\n           StorageLive(_17);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageLive(_18);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n           _18 = move _16;                  // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _17 = move _18;                  // scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-          StorageDead(_18);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          Deinit(_0);                      // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          ((_0 as Err).0: i32) = move _17; // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          discriminant(_0) = 1;            // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_17);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_16);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n-          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+2:1: +2:2\n-          return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n+-         _17 = <i32 as From<i32>>::from(move _18) -> bb8; // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n++         _17 = <i32 as From<i32>>::from(move _18) -> bb7; // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+                                           // mir::Constant\n+                                           // + span: $SRC_DIR/core/src/result.rs:LL:COL\n+                                           // + literal: Const { ty: fn(i32) -> i32 {<i32 as From<i32>>::from}, val: Value(<ZST>) }\n       }\n   \n -     bb5: {\n@@ -152,5 +142,20 @@\n +         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n +         switchInt(move _5) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n       }\n+  \n+-     bb8: {\n++     bb7: {\n+          StorageDead(_18);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          Deinit(_0);                      // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          ((_0 as Err).0: i32) = move _17; // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          discriminant(_0) = 1;            // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageDead(_17);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageDead(_16);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n+          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n+          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+2:1: +2:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n+      }\n   }\n   "}, {"sha": "3aa57d58908bb7b30d61a7eff9ffff9e7af95eff", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -67,7 +67,7 @@ impl CodegenBackend for TheBackend {\n             if crate_type != CrateType::Rlib {\n                 sess.fatal(&format!(\"Crate type is {:?}\", crate_type));\n             }\n-            let output_name = out_filename(sess, crate_type, &outputs, &*crate_name.as_str());\n+            let output_name = out_filename(sess, crate_type, &outputs, crate_name);\n             let mut out_file = ::std::fs::File::create(output_name).unwrap();\n             write!(out_file, \"This has been \\\"compiled\\\" successfully.\").unwrap();\n         }"}, {"sha": "d06cd9c6a54f077f1e115528565d17ab902fdb08", "filename": "src/test/run-make/coverage-reports/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frun-make%2Fcoverage-reports%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frun-make%2Fcoverage-reports%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcoverage-reports%2FMakefile?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -80,7 +80,7 @@ ifdef RUSTC_BLESS_TEST\n \trm -f expected_*\n endif\n \n-include clear_expected_if_blessed\n+-include clear_expected_if_blessed\n \n %: $(SOURCEDIR)/lib/%.rs\n \t# Compile the test library with coverage instrumentation"}, {"sha": "8dfc49285f2eb6695818d2d5a6090a3728ba3349", "filename": "src/test/rustdoc-gui/enum-variants.goml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fenum-variants.goml", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fenum-variants.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fenum-variants.goml?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -3,3 +3,8 @@ goto: \"file://\" + |DOC_PATH| + \"/test_docs/enum.WhoLetTheDogOut.html\"\n \n assert-css: (\".variants > .variant\", {\"margin\": \"0px 0px 12px\"})\n assert-css: (\".variants > .docblock\", {\"margin\": \"0px 0px 32px 24px\"})\n+\n+assert-css: (\n+    \"details.non-exhaustive > summary\",\n+    {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n+)"}, {"sha": "ed36bcdec17d2261f9ad058f6b3a1724006fa910", "filename": "src/test/rustdoc-gui/method-margins.goml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fmethod-margins.goml", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fmethod-margins.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fmethod-margins.goml?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,3 +1,4 @@\n+// This test ensures that the margins on methods are coherent inside an impl block.\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/trait_members/struct.HasTrait.html#impl-TraitMembers-for-HasTrait\"\n \n assert-count: (\"#trait-implementations-list > .rustdoc-toggle\", 1)"}, {"sha": "a222139f1dc44751b44ff9fbf7b9a44e210ad96f", "filename": "src/test/rustdoc-gui/scrape-examples-button-focus.goml", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-button-focus.goml", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-button-focus.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-button-focus.goml?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,4 +1,17 @@\n goto: \"file://\" + |DOC_PATH| + \"/scrape_examples/fn.test.html\"\n+\n+store-property: (initialScrollTop, \".scraped-example-list > .scraped-example pre\", \"scrollTop\")\n+focus: \".scraped-example-list > .scraped-example .next\"\n+press-key: \"Enter\"\n+assert-property-false: (\".scraped-example-list > .scraped-example pre\", {\n+\t\"scrollTop\": |initialScrollTop|\n+})\n+focus: \".scraped-example-list > .scraped-example .prev\"\n+press-key: \"Enter\"\n+assert-property: (\".scraped-example-list > .scraped-example pre\", {\n+\t\"scrollTop\": |initialScrollTop|\n+})\n+\n store-property: (smallOffsetHeight, \".scraped-example-list > .scraped-example pre\", \"offsetHeight\")\n assert-property-false: (\".scraped-example-list > .scraped-example pre\", {\n \t\"scrollHeight\": |smallOffsetHeight|"}, {"sha": "b3f682fe4973cd2ce83decbfe9c2b60d4812cb15", "filename": "src/test/rustdoc-gui/src/scrape_examples/examples/check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fsrc%2Fscrape_examples%2Fexamples%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fsrc%2Fscrape_examples%2Fexamples%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Fscrape_examples%2Fexamples%2Fcheck.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -22,4 +22,5 @@ fn main() {\n         println!(\"hello world!\");\n         println!(\"hello world!\");\n     }\n+    scrape_examples::test();\n }"}, {"sha": "1340511d4726b381b6ca4a118d2caf5dc1d4f91f", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -76,6 +76,7 @@ impl AsRef<str> for Foo {\n ///\n /// # title!\n #[doc(alias = \"ThisIsAnAlias\")]\n+#[non_exhaustive]\n pub enum WhoLetTheDogOut {\n     /// Woof!\n     Woof,"}, {"sha": "45bb8daf1f20c575bc4bb0414e8c664b44a4b73b", "filename": "src/test/rustdoc-gui/toggle-docs.goml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs.goml", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs.goml?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -7,6 +7,10 @@ wait-for: 50\n // This is now collapsed so there shouldn't be the \"open\" attribute on details.\n assert-attribute-false: (\"#main-content > details.top-doc\", {\"open\": \"\"})\n assert-text: (\"#toggle-all-docs\", \"[+]\")\n+assert-css: (\n+    \"#main-content > details.top-doc > summary\",\n+    {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n+)\n click: \"#toggle-all-docs\"\n // Not collapsed anymore so the \"open\" attribute should be back.\n wait-for-attribute: (\"#main-content > details.top-doc\", {\"open\": \"\"})"}, {"sha": "94cf7b94241df8d79144969b852f538de8ccfa88", "filename": "src/test/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -77,6 +77,7 @@\n     -Z                         location-detail=val -- what location details should be tracked when using caller_location, either `none`, or a comma separated list of location details, for which valid options are `file`, `line`, and `column` (default: `file,line,column`)\n     -Z                                      ls=val -- list the symbols defined by a library crate (default: no)\n     -Z                         macro-backtrace=val -- show macro backtraces (default: no)\n+    -Z             maximal-hir-to-mir-coverage=val -- save as much information as possible about the correspondence between MIR and HIR as source scopes (default: no)\n     -Z                         merge-functions=val -- control the operation of the MergeFunctions LLVM pass, taking the same values as the target option of the same name\n     -Z                              meta-stats=val -- gather metadata statistics (default: no)\n     -Z                          mir-emit-retag=val -- emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0 (default: no)"}, {"sha": "a73cd1775b462e8795a456c1c9123026d6122d23", "filename": "src/test/ui/associated-inherent-types/issue-104260.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fissue-104260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fissue-104260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fissue-104260.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    type Bar<T> = u8;\n+}\n+\n+fn main() {\n+    let a: Foo::Bar<()>;\n+}"}, {"sha": "50763ecddf99c34dc1a9447e7106675f5686945e", "filename": "src/test/ui/associated-inherent-types/normalize-projection-0.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fnormalize-projection-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fnormalize-projection-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fnormalize-projection-0.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T: O> S<T> {\n+    type P = <T as O>::P;\n+}\n+\n+trait O {\n+    type P;\n+}\n+\n+impl O for i32 {\n+    type P = String;\n+}\n+\n+fn main() {\n+    let _: S<i32>::P = String::new();\n+}"}, {"sha": "2f7b2551a03eced2c807406d1c922748196f513b", "filename": "src/test/ui/associated-inherent-types/normalize-projection-1.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fnormalize-projection-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fnormalize-projection-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fnormalize-projection-1.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S;\n+\n+impl S {\n+    type P<T: O> = <T as O>::P;\n+}\n+\n+trait O {\n+    type P;\n+}\n+\n+impl O for i32 {\n+    type P = String;\n+}\n+\n+fn main() {\n+    let _: S::P<i32> = String::new();\n+}"}, {"sha": "616623ee07759eeabd7c7fb4dc211d435aedd462", "filename": "src/test/ui/async-await/async-await-let-else.drop-tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -40,7 +40,7 @@ LL |   async fn bar2<T>(_: T) -> ! {\n LL | |     panic!()\n LL | | }\n    | |_^\n-   = note: required because it captures the following types: `ResumeTy`, `Option<bool>`, `impl Future<Output = !>`, `()`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `Option<bool>`, `impl Future<Output = !>`, `()`\n note: required because it's used within this `async fn` body\n   --> $DIR/async-await-let-else.rs:21:32\n    |"}, {"sha": "28ad7767583cfbd3d994c37179783ad51d8326d6", "filename": "src/test/ui/async-await/drop-track-bad-field-in-fru.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Zdrop-tracking\n+// edition: 2021\n+\n+fn main() {}\n+\n+async fn foo() {\n+    None { value: (), ..Default::default() }.await;\n+    //~^ ERROR `Option<_>` is not a future\n+    //~| ERROR variant `Option<_>::None` has no field named `value`\n+}"}, {"sha": "819b64ad77f5dd1b1f06a51ae52fa02ba38b0aab", "filename": "src/test/ui/async-await/drop-track-bad-field-in-fru.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,23 @@\n+error[E0559]: variant `Option<_>::None` has no field named `value`\n+  --> $DIR/drop-track-bad-field-in-fru.rs:7:12\n+   |\n+LL |     None { value: (), ..Default::default() }.await;\n+   |            ^^^^^ `Option<_>::None` does not have this field\n+\n+error[E0277]: `Option<_>` is not a future\n+  --> $DIR/drop-track-bad-field-in-fru.rs:7:45\n+   |\n+LL |     None { value: (), ..Default::default() }.await;\n+   |                                             ^^^^^^\n+   |                                             |\n+   |                                             `Option<_>` is not a future\n+   |                                             help: remove the `.await`\n+   |\n+   = help: the trait `Future` is not implemented for `Option<_>`\n+   = note: Option<_> must be a future or must implement `IntoFuture` to be awaited\n+   = note: required for `Option<_>` to implement `IntoFuture`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0277, E0559.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "ae8e0aed0cc53b936f302c5d4b4ac1c6384bf099", "filename": "src/test/ui/async-await/in-trait/nested-rpit.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fnested-rpit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fnested-rpit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fnested-rpit.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+use std::marker::PhantomData;\n+\n+trait Lockable<K, V> {\n+    async fn lock_all_entries(&self) -> impl Future<Output = Guard<'_>>;\n+}\n+\n+struct Guard<'a>(PhantomData<&'a ()>);\n+\n+fn main() {}"}, {"sha": "3446761d119da5aa2ca703d8ee427324158e9633", "filename": "src/test/ui/async-await/in-trait/return-type-suggestion.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,14 @@\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+//~^ WARN the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+\n+trait A {\n+    async fn e() {\n+        Ok(())\n+        //~^ ERROR mismatched types\n+        //~| HELP consider using a semicolon here\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5a9b15e54a00869b35f5cb2974ad29d28b109ffe", "filename": "src/test/ui/async-await/in-trait/return-type-suggestion.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,23 @@\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/return-type-suggestion.rs:3:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/return-type-suggestion.rs:8:9\n+   |\n+LL |         Ok(())\n+   |         ^^^^^^- help: consider using a semicolon here: `;`\n+   |         |\n+   |         expected `()`, found enum `Result`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<(), _>`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1c90bedae790c66259bc6c47e956ebb90907e003", "filename": "src/test/ui/async-await/issue-68112.drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -57,7 +57,7 @@ note: required because it appears within the type `impl Future<Output = Arc<RefC\n    |\n LL | fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `Ready<i32>`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `Ready<i32>`\n note: required because it's used within this `async` block\n   --> $DIR/issue-68112.rs:60:20\n    |"}, {"sha": "e09ae7fedd8055f1f636f711bbe1fdd619048213", "filename": "src/test/ui/async-await/issue-68112.no_drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -57,7 +57,7 @@ note: required because it appears within the type `impl Future<Output = Arc<RefC\n    |\n LL | fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `i32`, `Ready<i32>`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `i32`, `Ready<i32>`\n note: required because it's used within this `async` block\n   --> $DIR/issue-68112.rs:60:20\n    |"}, {"sha": "e6ad2f0d444bb7e8faa44cd6cc6f4a787fc87b80", "filename": "src/test/ui/async-await/issue-69446-fnmut-capture.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -14,6 +14,9 @@ LL | |     });\n    |\n    = note: `FnMut` closures only have access to their captured variables while they are executing...\n    = note: ...therefore, they cannot allow references to captured variables to escape\n+   = note: requirement occurs because of a mutable reference to `Context<'_>`\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: aborting due to previous error\n "}, {"sha": "a8fd97cde8f7a8bd7b9f64c71b96179ed7658dce", "filename": "src/test/ui/async-await/issue-70935-complex-spans.drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -18,7 +18,7 @@ LL |   async fn baz<T>(_c: impl FnMut() -> T) where T: Future<Output=()> {\n    |  ___________________________________________________________________^\n LL | | }\n    | |_^\n-   = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = ()>`, `()`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `impl Future<Output = ()>`, `()`\n note: required because it's used within this `async` block\n   --> $DIR/issue-70935-complex-spans.rs:16:5\n    |"}, {"sha": "25876d5084015f6720a31293c78bce0bb7c67a77", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.drop_tracking.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -11,7 +11,7 @@ LL | async fn foo() {\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `NotSend`\n    = note: required because it appears within the type `(NotSend,)`\n-   = note: required because it captures the following types: `ResumeTy`, `(NotSend,)`, `()`, `impl Future<Output = ()>`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `(NotSend,)`, `()`, `impl Future<Output = ()>`\n note: required because it's used within this `async fn` body\n   --> $DIR/partial-drop-partial-reinit.rs:31:16\n    |"}, {"sha": "dba2a620779f0f446f537663fc8995a40037baaf", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.no_drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.no_drop_tracking.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -11,7 +11,7 @@ LL | async fn foo() {\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `NotSend`\n    = note: required because it appears within the type `(NotSend,)`\n-   = note: required because it captures the following types: `ResumeTy`, `(NotSend,)`, `impl Future<Output = ()>`, `()`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `(NotSend,)`, `impl Future<Output = ()>`, `()`\n note: required because it's used within this `async fn` body\n   --> $DIR/partial-drop-partial-reinit.rs:31:16\n    |"}, {"sha": "4e52b8e250b9fa6b3e8989089052fc63e4616184", "filename": "src/test/ui/async-await/track-caller/issue-105134.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fissue-105134.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fissue-105134.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fissue-105134.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// edition:2021\n+\n+#[track_caller]\n+fn f() {\n+    let _ = async {};\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "5ebfeb3f36ac162f402dc3b780f6767c2911d35a", "filename": "src/test/ui/async-await/track-caller/panic-track-caller.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -54,6 +54,19 @@ async fn foo_track_caller() {\n     bar_track_caller().await\n }\n \n+struct Foo;\n+\n+impl Foo {\n+    #[track_caller]\n+    async fn bar_assoc() {\n+        panic!();\n+    }\n+}\n+\n+async fn foo_assoc() {\n+    Foo::bar_assoc().await\n+}\n+\n fn panicked_at(f: impl FnOnce() + panic::UnwindSafe) -> u32 {\n     let loc = Arc::new(Mutex::new(None));\n \n@@ -73,4 +86,5 @@ fn panicked_at(f: impl FnOnce() + panic::UnwindSafe) -> u32 {\n fn main() {\n     assert_eq!(panicked_at(|| block_on(foo())), 41);\n     assert_eq!(panicked_at(|| block_on(foo_track_caller())), 54);\n+    assert_eq!(panicked_at(|| block_on(foo_assoc())), 67);\n }"}, {"sha": "3f8ac14c72d9538078dcf3317166b6e80a5f6750", "filename": "src/test/ui/auto-traits/bad-generics-on-dyn.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,11 @@\n+#![feature(auto_traits)]\n+\n+auto trait Trait1<'a> {}\n+//~^ ERROR auto traits cannot have generic parameters\n+\n+fn f<'a>(x: &dyn Trait1<'a>)\n+{}\n+\n+fn main() {\n+    f(&1);\n+}"}, {"sha": "ade69ced6060d32cff0b96abcf4eafe1aa999d81", "filename": "src/test/ui/auto-traits/bad-generics-on-dyn.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,11 @@\n+error[E0567]: auto traits cannot have generic parameters\n+  --> $DIR/bad-generics-on-dyn.rs:3:18\n+   |\n+LL | auto trait Trait1<'a> {}\n+   |            ------^^^^ help: remove the parameters\n+   |            |\n+   |            auto trait cannot have generic parameters\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0567`."}, {"sha": "c986bc3fd1e3e15003216d93ffe183e8eb38f271", "filename": "src/test/ui/binop/binop-mul-i32-f32.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-i32-f32.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-i32-f32.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-i32-f32.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -6,15 +6,10 @@ LL |     x * y\n    |\n    = help: the trait `Mul<f32>` is not implemented for `i32`\n    = help: the following other types implement trait `Mul<Rhs>`:\n-             <&'a f32 as Mul<f32>>\n-             <&'a f64 as Mul<f64>>\n-             <&'a i128 as Mul<i128>>\n-             <&'a i16 as Mul<i16>>\n              <&'a i32 as Mul<i32>>\n-             <&'a i64 as Mul<i64>>\n-             <&'a i8 as Mul<i8>>\n-             <&'a isize as Mul<isize>>\n-           and 49 others\n+             <&i32 as Mul<&i32>>\n+             <i32 as Mul<&i32>>\n+             <i32 as Mul>\n \n error: aborting due to previous error\n "}, {"sha": "a46bd53520b539ff8dfb6558d770d58045533b81", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -18,9 +18,7 @@ LL |\n LL |     1_u32\n    |     ----- return type was inferred to be `u32` here\n    |\n-   = help: the following other types implement trait `Traitor<N, M>`:\n-             <u32 as Traitor<N, 2>>\n-             <u64 as Traitor<1, 2>>\n+   = help: the trait `Traitor<N, 2>` is implemented for `u32`\n \n error[E0277]: the trait bound `u64: Traitor` is not satisfied\n   --> $DIR/rp_impl_trait_fail.rs:21:13\n@@ -31,9 +29,7 @@ LL |\n LL |     1_u64\n    |     ----- return type was inferred to be `u64` here\n    |\n-   = help: the following other types implement trait `Traitor<N, M>`:\n-             <u32 as Traitor<N, 2>>\n-             <u64 as Traitor<1, 2>>\n+   = help: the trait `Traitor<1, 2>` is implemented for `u64`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "14a870dc39bf6a3ca2e1754aab5aaff9ee99dbe3", "filename": "src/test/ui/const-generics/defaults/self-referential.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,4 @@\n+trait Foo<const M: u8, const M: u8 = M> {}\n+//~^ ERROR the name `M` is already used for a generic parameter in this item's generic parameters\n+impl Foo<2> for () {}\n+fn main() {}"}, {"sha": "170c1f7f7b2aedc91ec37c83159f13d281bfe3cf", "filename": "src/test/ui/const-generics/defaults/self-referential.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,11 @@\n+error[E0403]: the name `M` is already used for a generic parameter in this item's generic parameters\n+  --> $DIR/self-referential.rs:1:30\n+   |\n+LL | trait Foo<const M: u8, const M: u8 = M> {}\n+   |                 -            ^ already used\n+   |                 |\n+   |                 first use of `M`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0403`."}, {"sha": "6093fc70b16965c6153db11740f9e3a0efd02386", "filename": "src/test/ui/const-generics/generic_const_exprs/const_kind_expr/wf_obligation.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,22 @@\n+#![feature(generic_const_exprs, generic_arg_infer)]\n+#![allow(incomplete_features)]\n+\n+// minimized repro for #105205\n+//\n+// the `foo::<_, L>` call results in a `WellFormed(_)` obligation and a\n+// `ConstEvaluatable(Unevaluated(_ + 1 + L))` obligation. Attempting to fulfill the latter\n+// unifies the `_` with `Expr(L - 1)` from the paramenv which turns the `WellFormed`\n+// obligation into `WellFormed(Expr(L - 1))`\n+\n+fn foo<const N: usize, const M: usize>(_: [(); N + 1 + M]) {}\n+\n+fn ice<const L: usize>()\n+where\n+    [(); (L - 1) + 1 + L]:,\n+{\n+    foo::<_, L>([(); L + 1 + L]);\n+    //~^ ERROR: mismatched types\n+    //~^^ ERROR: unconstrained generic constant\n+}\n+\n+fn main() {}"}, {"sha": "da5194696e657bb032741d6d31fd29cf02847321", "filename": "src/test/ui/const-generics/generic_const_exprs/const_kind_expr/wf_obligation.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/wf_obligation.rs:17:17\n+   |\n+LL |     foo::<_, L>([(); L + 1 + L]);\n+   |                 ^^^^^^^^^^^^^^^ expected `N + 1 + M`, found `L + 1 + L`\n+   |\n+   = note: expected constant `N + 1 + M`\n+              found constant `L + 1 + L`\n+\n+error: unconstrained generic constant\n+  --> $DIR/wf_obligation.rs:17:22\n+   |\n+LL |     foo::<_, L>([(); L + 1 + L]);\n+   |                      ^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); L + 1 + L]:`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b37b354ae2146eeea732e6c57c6efd292bd8a0fa", "filename": "src/test/ui/const-generics/generic_const_exprs/normed_to_param_is_evaluatable.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fnormed_to_param_is_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fnormed_to_param_is_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fnormed_to_param_is_evaluatable.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features, unused_braces)]\n+\n+#[rustfmt::skip]\n+fn foo<const N: usize>() {\n+    bar::<{{{{{{ N }}}}}}>();\n+}\n+\n+fn bar<const N: usize>() {}\n+\n+fn main() {}"}, {"sha": "f199170018f20b322a6971a8b21205052e6c5425", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3b.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -12,15 +12,10 @@ LL |     = [0; (i8::MAX + 1u8) as usize];\n    |\n    = help: the trait `~const Add<u8>` is not implemented for `i8`\n    = help: the following other types implement trait `Add<Rhs>`:\n-             <&'a f32 as Add<f32>>\n-             <&'a f64 as Add<f64>>\n-             <&'a i128 as Add<i128>>\n-             <&'a i16 as Add<i16>>\n-             <&'a i32 as Add<i32>>\n-             <&'a i64 as Add<i64>>\n              <&'a i8 as Add<i8>>\n-             <&'a isize as Add<isize>>\n-           and 48 others\n+             <&i8 as Add<&i8>>\n+             <i8 as Add<&i8>>\n+             <i8 as Add>\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1f8e402317aa8d5bcb095bdbac13f453336137d5", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-4b.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -12,15 +12,10 @@ LL |     : [u32; (i8::MAX as i8 + 1u8) as usize]\n    |\n    = help: the trait `~const Add<u8>` is not implemented for `i8`\n    = help: the following other types implement trait `Add<Rhs>`:\n-             <&'a f32 as Add<f32>>\n-             <&'a f64 as Add<f64>>\n-             <&'a i128 as Add<i128>>\n-             <&'a i16 as Add<i16>>\n-             <&'a i32 as Add<i32>>\n-             <&'a i64 as Add<i64>>\n              <&'a i8 as Add<i8>>\n-             <&'a isize as Add<isize>>\n-           and 48 others\n+             <&i8 as Add<&i8>>\n+             <i8 as Add<&i8>>\n+             <i8 as Add>\n \n error[E0604]: only `u8` can be cast as `char`, not `i8`\n   --> $DIR/const-eval-overflow-4b.rs:22:13"}, {"sha": "3fd7a7110fd973191eb0fb6ab0bef6fc09a4cf24", "filename": "src/test/ui/diagnostic-width/long-E0308.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,86 @@\n+// compile-flags: --diagnostic-width=60\n+// normalize-stderr-test: \"long-type-\\d+\" -> \"long-type-hash\"\n+\n+struct Atype<T, K>(T, K);\n+struct Btype<T, K>(T, K);\n+struct Ctype<T, K>(T, K);\n+\n+fn main() {\n+    let x: Atype<\n+      Btype<\n+        Ctype<\n+          Atype<\n+            Btype<\n+              Ctype<\n+                Atype<\n+                  Btype<\n+                    Ctype<i32, i32>,\n+                    i32\n+                  >,\n+                  i32\n+                >,\n+                i32\n+              >,\n+              i32\n+            >,\n+            i32\n+          >,\n+          i32\n+        >,\n+        i32\n+      >,\n+      i32\n+    > = Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+        Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+            Ok(\"\")\n+        ))))))))))))))))))))))))))))))\n+    ))))))))))))))))))))))))))))));\n+    //~^^^^^ ERROR E0308\n+\n+    let _ = Some(Ok(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(\n+        Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(\n+            Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(\n+                Some(Some(Some(Some(Some(Some(Some(Some(Some(\"\")))))))))\n+            )))))))))))))))))\n+        ))))))))))))))))))\n+    ))))))))))))))))) == Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+        Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+            Ok(Ok(Ok(Ok(Ok(Ok(Ok(\"\")))))))\n+        ))))))))))))))))))))))))))))))\n+    ))))))))))))))))))))))));\n+    //~^^^^^ ERROR E0308\n+\n+    let x: Atype<\n+      Btype<\n+        Ctype<\n+          Atype<\n+            Btype<\n+              Ctype<\n+                Atype<\n+                  Btype<\n+                    Ctype<i32, i32>,\n+                    i32\n+                  >,\n+                  i32\n+                >,\n+                i32\n+              >,\n+              i32\n+            >,\n+            i32\n+          >,\n+          i32\n+        >,\n+        i32\n+      >,\n+      i32\n+    > = ();\n+    //~^ ERROR E0308\n+\n+    let _: () = Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+        Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+            Ok(Ok(Ok(Ok(Ok(Ok(Ok(\"\")))))))\n+        ))))))))))))))))))))))))))))))\n+    ))))))))))))))))))))))));\n+    //~^^^^^ ERROR E0308\n+}"}, {"sha": "487ab23a1c100ea37ce18f68b701a09b563454a7", "filename": "src/test/ui/diagnostic-width/long-E0308.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,80 @@\n+error[E0308]: mismatched types\n+  --> $DIR/long-E0308.rs:33:9\n+   |\n+LL |        let x: Atype<\n+   |  _____________-\n+LL | |        Btype<\n+LL | |          Ctype<\n+LL | |            Atype<\n+...  |\n+LL | |        i32\n+LL | |      > = Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok...\n+   | | _____-___^\n+   | ||_____|\n+   |  |     expected due to this\n+LL |  |         Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok...\n+LL |  |             Ok(\"\")\n+LL |  |         ))))))))))))))))))))))))))))))\n+LL |  |     ))))))))))))))))))))))))))))));\n+   |  |__________________________________^ expected struct `Atype`, found enum `Result`\n+   |\n+   = note: expected struct `Atype<Btype<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+                found enum `Result<Result<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+\n+error[E0308]: mismatched types\n+  --> $DIR/long-E0308.rs:46:26\n+   |\n+LL |       ))))))))))))))))) == Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(O...\n+   |  __________________________^\n+LL | |         Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(...\n+LL | |             Ok(Ok(Ok(Ok(Ok(Ok(Ok(\"\")))))))\n+LL | |         ))))))))))))))))))))))))))))))\n+LL | |     ))))))))))))))))))))))));\n+   | |____________________________^ expected enum `Option`, found enum `Result`\n+   |\n+   = note: expected enum `Option<Result<..., ...>>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+              found enum `Result<Result<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+\n+error[E0308]: mismatched types\n+  --> $DIR/long-E0308.rs:77:9\n+   |\n+LL |       let x: Atype<\n+   |  ____________-\n+LL | |       Btype<\n+LL | |         Ctype<\n+LL | |           Atype<\n+...  |\n+LL | |       i32\n+LL | |     > = ();\n+   | |     -   ^^ expected struct `Atype`, found `()`\n+   | |_____|\n+   |       expected due to this\n+   |\n+   = note: expected struct `Atype<Btype<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+           found unit type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/long-E0308.rs:80:17\n+   |\n+LL |       let _: () = Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(O...\n+   |  ____________--___^\n+   | |            |\n+   | |            expected due to this\n+LL | |         Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(...\n+LL | |             Ok(Ok(Ok(Ok(Ok(Ok(Ok(\"\")))))))\n+LL | |         ))))))))))))))))))))))))))))))\n+LL | |     ))))))))))))))))))))))));\n+   | |____________________________^ expected `()`, found enum `Result`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<Result<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "7229b9ac986ac73df2909af829ff3fb6d0d5730e", "filename": "src/test/ui/did_you_mean/issue-39802-show-5-trait-impls.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39802-show-5-trait-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39802-show-5-trait-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39802-show-5-trait-impls.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -12,10 +12,6 @@ LL |     Foo::<i32>::bar(&1i8);\n              <i8 as Foo<u32>>\n              <i8 as Foo<u64>>\n              <i8 as Foo<u8>>\n-             <u8 as Foo<bool>>\n-             <u8 as Foo<u16>>\n-             <u8 as Foo<u32>>\n-             <u8 as Foo<u64>>\n \n error[E0277]: the trait bound `u8: Foo<i32>` is not satisfied\n   --> $DIR/issue-39802-show-5-trait-impls.rs:25:21\n@@ -26,11 +22,6 @@ LL |     Foo::<i32>::bar(&1u8);\n    |     required by a bound introduced by this call\n    |\n    = help: the following other types implement trait `Foo<B>`:\n-             <i8 as Foo<bool>>\n-             <i8 as Foo<u16>>\n-             <i8 as Foo<u32>>\n-             <i8 as Foo<u64>>\n-             <i8 as Foo<u8>>\n              <u8 as Foo<bool>>\n              <u8 as Foo<u16>>\n              <u8 as Foo<u32>>"}, {"sha": "628f898d5c8790a7232b6dc43a184386dbc4dad5", "filename": "src/test/ui/duplicate/duplicate-type-parameter.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fduplicate%2Fduplicate-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fduplicate%2Fduplicate-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fduplicate%2Fduplicate-type-parameter.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -55,10 +55,10 @@ LL | impl<T,T> Qux<T,T> for Option<T> {}\n    |      first use of `T`\n \n error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n-  --> $DIR/duplicate-type-parameter.rs:24:6\n+  --> $DIR/duplicate-type-parameter.rs:24:8\n    |\n LL | impl<T,T> Qux<T,T> for Option<T> {}\n-   |      ^ unconstrained type parameter\n+   |        ^ unconstrained type parameter\n \n error: aborting due to 8 previous errors\n "}, {"sha": "451a683ac8a6effeec6de3067304913763e77885", "filename": "src/test/ui/error-codes/E0275.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -5,7 +5,7 @@ LL | impl<T> Foo for T where Bar<T>: Foo {}\n    |                                 ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`E0275`)\n-note: required for `Bar<Bar<Bar<Bar<Bar<Bar<...>>>>>>` to implement `Foo`\n+note: required for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<...>>>>>>>>>>>>>>>>>>>>>` to implement `Foo`\n   --> $DIR/E0275.rs:6:9\n    |\n LL | impl<T> Foo for T where Bar<T>: Foo {}"}, {"sha": "760dcb615c87903d522d89eb322e47139b919b82", "filename": "src/test/ui/feature-gates/feature-gate-impl_trait_in_fn_trait_return.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_fn_trait_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_fn_trait_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_fn_trait_return.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -3,12 +3,18 @@ error[E0562]: `impl Trait` only allowed in function and inherent method return t\n    |\n LL | fn f() -> impl Fn() -> impl Sized { || () }\n    |                        ^^^^^^^^^^\n+   |\n+   = note: see issue #99697 <https://github.com/rust-lang/rust/issues/99697> for more information\n+   = help: add `#![feature(impl_trait_in_fn_trait_return)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in `Fn` trait return\n   --> $DIR/feature-gate-impl_trait_in_fn_trait_return.rs:3:32\n    |\n LL | fn g() -> &'static dyn Fn() -> impl Sized { &|| () }\n    |                                ^^^^^^^^^^\n+   |\n+   = note: see issue #99697 <https://github.com/rust-lang/rust/issues/99697> for more information\n+   = help: add `#![feature(impl_trait_in_fn_trait_return)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n "}, {"sha": "505f31ec6388d1d2bf4ce3a8b50ab77206527412", "filename": "src/test/ui/feature-gates/feature-gate-linkage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linkage.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,5 +1,5 @@\n extern \"C\" {\n-    #[linkage = \"extern_weak\"] static foo: isize;\n+    #[linkage = \"extern_weak\"] static foo: *mut isize;\n     //~^ ERROR: the `linkage` attribute is experimental and not portable\n }\n "}, {"sha": "a1c73e555ef7a35689004863f8bdf29cfc38d3ed", "filename": "src/test/ui/feature-gates/feature-gate-linkage.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linkage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linkage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linkage.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,7 +1,7 @@\n error[E0658]: the `linkage` attribute is experimental and not portable across platforms\n   --> $DIR/feature-gate-linkage.rs:2:5\n    |\n-LL |     #[linkage = \"extern_weak\"] static foo: isize;\n+LL |     #[linkage = \"extern_weak\"] static foo: *mut isize;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #29603 <https://github.com/rust-lang/rust/issues/29603> for more information"}, {"sha": "3699f7296f5d0ac08e5b129ccd716aa4b93d7d6e", "filename": "src/test/ui/generic-associated-types/own-bound-span.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fown-bound-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fown-bound-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fown-bound-span.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,17 @@\n+struct S;\n+\n+trait D {\n+    type P<T: Copy>;\n+    //~^ NOTE required by this bound in `D::P`\n+    //~| NOTE required by a bound in `D::P`\n+}\n+\n+impl D for S {\n+    type P<T: Copy> = ();\n+}\n+\n+fn main() {\n+    let _: <S as D>::P<String>;\n+    //~^ ERROR the trait bound `String: Copy` is not satisfied\n+    //~| NOTE the trait `Copy` is not implemented for `String`\n+}"}, {"sha": "8ab8ea623b2c93d674d096da4b55fe3f19c923c5", "filename": "src/test/ui/generic-associated-types/own-bound-span.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fown-bound-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fown-bound-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fown-bound-span.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/own-bound-span.rs:14:12\n+   |\n+LL |     let _: <S as D>::P<String>;\n+   |            ^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `D::P`\n+  --> $DIR/own-bound-span.rs:4:15\n+   |\n+LL |     type P<T: Copy>;\n+   |               ^^^^ required by this bound in `D::P`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "69f4cbbbf429496a67df930d0bdd32a1a27e07f5", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -30,15 +30,10 @@ LL |         n + sum_to(n - 1)\n    |\n    = help: the trait `Add<impl Foo>` is not implemented for `u32`\n    = help: the following other types implement trait `Add<Rhs>`:\n-             <&'a f32 as Add<f32>>\n-             <&'a f64 as Add<f64>>\n-             <&'a i128 as Add<i128>>\n-             <&'a i16 as Add<i16>>\n-             <&'a i32 as Add<i32>>\n-             <&'a i64 as Add<i64>>\n-             <&'a i8 as Add<i8>>\n-             <&'a isize as Add<isize>>\n-           and 48 others\n+             <&'a u32 as Add<u32>>\n+             <&u32 as Add<&u32>>\n+             <u32 as Add<&u32>>\n+             <u32 as Add>\n \n error: aborting due to 2 previous errors; 1 warning emitted\n "}, {"sha": "cec70bb1a0d9e5e9530820b574947071ebba9d67", "filename": "src/test/ui/impl-trait/nested-return-type4.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,8 @@\n+// edition: 2021\n+\n+fn test<'s: 's>(s: &'s str) -> impl std::future::Future<Output = impl Sized> {\n+    async move { let _s = s; }\n+    //~^ ERROR hidden type for `impl Future<Output = impl Sized>` captures lifetime that does not appear in bounds\n+}\n+\n+fn main() {}"}, {"sha": "e761a60e79c2751d5f1193d41fd5da610d8cf3fe", "filename": "src/test/ui/impl-trait/nested-return-type4.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,20 @@\n+error[E0700]: hidden type for `impl Future<Output = impl Sized>` captures lifetime that does not appear in bounds\n+  --> $DIR/nested-return-type4.rs:4:5\n+   |\n+LL | fn test<'s: 's>(s: &'s str) -> impl std::future::Future<Output = impl Sized> {\n+   |         -- hidden type `[async block@$DIR/nested-return-type4.rs:4:5: 4:31]` captures the lifetime `'s` as defined here\n+LL |     async move { let _s = s; }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: to declare that `impl Future<Output = impl Sized>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | fn test<'s: 's>(s: &'s str) -> impl std::future::Future<Output = impl Sized> + 's {\n+   |                                                                              ++++\n+help: to declare that `impl Sized` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | fn test<'s: 's>(s: &'s str) -> impl std::future::Future<Output = impl Sized + 's> {\n+   |                                                                             ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "86e45f10b0e1615280a10d877293375f71163dfd", "filename": "src/test/ui/issues/issue-105330.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-105330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-105330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-105330.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,21 @@\n+pub trait TraitWAssocConst {\n+    const A:   usize;\n+}\n+pub struct Demo {}\n+\n+impl TraitWAssocConst for impl Demo { //~ ERROR E0404\n+    //~^ ERROR E0562\n+    pubconst A: str = 32; //~ ERROR expected one of\n+}\n+\n+fn foo<A: TraitWAssocConst<A=32>>() { //~ ERROR E0658\n+    foo::<Demo>()(); //~ ERROR E0271\n+    //~^ ERROR E0618\n+    //~| ERROR E0277\n+}\n+\n+fn main<A: TraitWAssocConst<A=32>>() { //~ ERROR E0131\n+    //~^ ERROR E0658\n+    foo::<Demo>(); //~ ERROR E0277\n+    //~^ ERROR E0271\n+}"}, {"sha": "92f2ccb6544b10c2ba81744c921b4b945fd91d15", "filename": "src/test/ui/issues/issue-105330.stderr", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-105330.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-105330.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-105330.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,109 @@\n+error: expected one of `!` or `::`, found `A`\n+  --> $DIR/issue-105330.rs:8:14\n+   |\n+LL | impl TraitWAssocConst for impl Demo {\n+   |                                     - while parsing this item list starting here\n+LL |\n+LL |     pubconst A: str = 32;\n+   |              ^ expected one of `!` or `::`\n+LL | }\n+   | - the item list ends here\n+\n+error[E0404]: expected trait, found struct `Demo`\n+  --> $DIR/issue-105330.rs:6:32\n+   |\n+LL | impl TraitWAssocConst for impl Demo {\n+   |                                ^^^^ not a trait\n+\n+error[E0658]: associated const equality is incomplete\n+  --> $DIR/issue-105330.rs:11:28\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |                            ^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error[E0658]: associated const equality is incomplete\n+  --> $DIR/issue-105330.rs:17:29\n+   |\n+LL | fn main<A: TraitWAssocConst<A=32>>() {\n+   |                             ^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+  --> $DIR/issue-105330.rs:6:27\n+   |\n+LL | impl TraitWAssocConst for impl Demo {\n+   |                           ^^^^^^^^^\n+\n+error[E0277]: the trait bound `Demo: TraitWAssocConst` is not satisfied\n+  --> $DIR/issue-105330.rs:12:11\n+   |\n+LL |     foo::<Demo>()();\n+   |           ^^^^ the trait `TraitWAssocConst` is not implemented for `Demo`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/issue-105330.rs:11:11\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error[E0271]: type mismatch resolving `<Demo as TraitWAssocConst>::A == 32`\n+  --> $DIR/issue-105330.rs:12:11\n+   |\n+LL |     foo::<Demo>()();\n+   |           ^^^^ types differ\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/issue-105330.rs:11:28\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |                            ^^^^ required by this bound in `foo`\n+\n+error[E0618]: expected function, found `()`\n+  --> $DIR/issue-105330.rs:12:5\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   | ----------------------------------- `foo::<Demo>` defined here returns `()`\n+LL |     foo::<Demo>()();\n+   |     ^^^^^^^^^^^^^--\n+   |     |\n+   |     call expression requires function\n+\n+error[E0277]: the trait bound `Demo: TraitWAssocConst` is not satisfied\n+  --> $DIR/issue-105330.rs:19:11\n+   |\n+LL |     foo::<Demo>();\n+   |           ^^^^ the trait `TraitWAssocConst` is not implemented for `Demo`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/issue-105330.rs:11:11\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error[E0271]: type mismatch resolving `<Demo as TraitWAssocConst>::A == 32`\n+  --> $DIR/issue-105330.rs:19:11\n+   |\n+LL |     foo::<Demo>();\n+   |           ^^^^ types differ\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/issue-105330.rs:11:28\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |                            ^^^^ required by this bound in `foo`\n+\n+error[E0131]: `main` function is not allowed to have generic parameters\n+  --> $DIR/issue-105330.rs:17:8\n+   |\n+LL | fn main<A: TraitWAssocConst<A=32>>() {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `main` cannot have generic parameters\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors have detailed explanations: E0131, E0271, E0277, E0404, E0562, E0618, E0658.\n+For more information about an error, try `rustc --explain E0131`."}, {"sha": "78df445972c94d34102044a095a0c10edc600cb4", "filename": "src/test/ui/issues/issue-20413.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -14,7 +14,7 @@ LL | impl<T> Foo for T where NoData<T>: Foo {\n    |                                    ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_20413`)\n-note: required for `NoData<NoData<NoData<NoData<NoData<NoData<...>>>>>>` to implement `Foo`\n+note: required for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<...>>>>>>>>>>>>>` to implement `Foo`\n   --> $DIR/issue-20413.rs:9:9\n    |\n LL | impl<T> Foo for T where NoData<T>: Foo {\n@@ -30,13 +30,13 @@ LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n    |                                          ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_20413`)\n-note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>` to implement `Bar`\n+note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>>` to implement `Bar`\n   --> $DIR/issue-20413.rs:28:9\n    |\n LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n    |         ^^^     ^\n    = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n-note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>` to implement `Baz`\n+note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>>` to implement `Baz`\n   --> $DIR/issue-20413.rs:35:9\n    |\n LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n@@ -52,13 +52,13 @@ LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n    |                                          ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_20413`)\n-note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>` to implement `Baz`\n+note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>>` to implement `Baz`\n   --> $DIR/issue-20413.rs:35:9\n    |\n LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n    |         ^^^     ^\n    = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n-note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>` to implement `Bar`\n+note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>>` to implement `Bar`\n   --> $DIR/issue-20413.rs:28:9\n    |\n LL | impl<T> Bar for T where EvenLessData<T>: Baz {"}, {"sha": "1f50b06a0e4c553fc5b39160878ca3bd22c0d560", "filename": "src/test/ui/issues/issue-23122-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -5,7 +5,7 @@ LL |     type Next = <GetNext<T::Next> as Next>::Next;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_23122_2`)\n-note: required for `GetNext<<<<<<... as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>` to implement `Next`\n+note: required for `GetNext<<<<<<<... as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>` to implement `Next`\n   --> $DIR/issue-23122-2.rs:10:15\n    |\n LL | impl<T: Next> Next for GetNext<T> {"}, {"sha": "1f51b6e29050cef2fa19e3c9659ae5442cd49bcd", "filename": "src/test/ui/issues/issue-24352.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-24352.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fissues%2Fissue-24352.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24352.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -6,15 +6,10 @@ LL |     1.0f64 - 1\n    |\n    = help: the trait `Sub<{integer}>` is not implemented for `f64`\n    = help: the following other types implement trait `Sub<Rhs>`:\n-             <&'a f32 as Sub<f32>>\n              <&'a f64 as Sub<f64>>\n-             <&'a i128 as Sub<i128>>\n-             <&'a i16 as Sub<i16>>\n-             <&'a i32 as Sub<i32>>\n-             <&'a i64 as Sub<i64>>\n-             <&'a i8 as Sub<i8>>\n-             <&'a isize as Sub<isize>>\n-           and 48 others\n+             <&f64 as Sub<&f64>>\n+             <f64 as Sub<&f64>>\n+             <f64 as Sub>\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     1.0f64 - 1.0"}, {"sha": "9af89159a8cfcec0f98cf91bcbbff4f358b7e34d", "filename": "src/test/ui/kindck/kindck-copy.stderr", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fkindck%2Fkindck-copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fkindck%2Fkindck-copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-copy.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -4,16 +4,7 @@ error[E0277]: the trait bound `&'static mut isize: Copy` is not satisfied\n LL |     assert_copy::<&'static mut isize>();\n    |                   ^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `&'static mut isize`\n    |\n-   = help: the following other types implement trait `Copy`:\n-             f32\n-             f64\n-             i128\n-             i16\n-             i32\n-             i64\n-             i8\n-             isize\n-           and 6 others\n+   = help: the trait `Copy` is implemented for `isize`\n note: required by a bound in `assert_copy`\n   --> $DIR/kindck-copy.rs:5:18\n    |\n@@ -26,16 +17,7 @@ error[E0277]: the trait bound `&'a mut isize: Copy` is not satisfied\n LL |     assert_copy::<&'a mut isize>();\n    |                   ^^^^^^^^^^^^^ the trait `Copy` is not implemented for `&'a mut isize`\n    |\n-   = help: the following other types implement trait `Copy`:\n-             f32\n-             f64\n-             i128\n-             i16\n-             i32\n-             i64\n-             i8\n-             isize\n-           and 6 others\n+   = help: the trait `Copy` is implemented for `isize`\n note: required by a bound in `assert_copy`\n   --> $DIR/kindck-copy.rs:5:18\n    |"}, {"sha": "ce41942467cea1a9fb34bcfe201485e2cbd3bd34", "filename": "src/test/ui/lexer/lex-bad-char-literals-6.stderr", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flexer%2Flex-bad-char-literals-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flexer%2Flex-bad-char-literals-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flexer%2Flex-bad-char-literals-6.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -42,12 +42,11 @@ LL |     if x == y {}\n              <&'a str as PartialEq<OsString>>\n              <&'a str as PartialEq<String>>\n              <&'b str as PartialEq<Cow<'a, str>>>\n-             <String as PartialEq<&'a str>>\n-             <String as PartialEq<Cow<'a, str>>>\n-             <String as PartialEq<str>>\n-             <String as PartialEq>\n              <str as PartialEq<Cow<'a, str>>>\n-           and 4 others\n+             <str as PartialEq<OsStr>>\n+             <str as PartialEq<OsString>>\n+             <str as PartialEq<String>>\n+             <str as PartialEq>\n \n error[E0308]: mismatched types\n   --> $DIR/lex-bad-char-literals-6.rs:15:20\n@@ -68,12 +67,11 @@ LL |     if x == z {}\n              <&'a str as PartialEq<OsString>>\n              <&'a str as PartialEq<String>>\n              <&'b str as PartialEq<Cow<'a, str>>>\n-             <String as PartialEq<&'a str>>\n-             <String as PartialEq<Cow<'a, str>>>\n-             <String as PartialEq<str>>\n-             <String as PartialEq>\n              <str as PartialEq<Cow<'a, str>>>\n-           and 4 others\n+             <str as PartialEq<OsStr>>\n+             <str as PartialEq<OsString>>\n+             <str as PartialEq<String>>\n+             <str as PartialEq>\n \n error: aborting due to 6 previous errors\n "}, {"sha": "2300930e513afb95497a6c244db6baa60e1c4102", "filename": "src/test/ui/linkage-attr/auxiliary/def_external.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flinkage-attr%2Fauxiliary%2Fdef_external.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flinkage-attr%2Fauxiliary%2Fdef_external.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flinkage-attr%2Fauxiliary%2Fdef_external.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "previous_filename": "src/test/ui/linkage-attr/auxiliary/def_illtyped_external.rs"}, {"sha": "f754ddc6e08fd4657337f567522ce11673609e60", "filename": "src/test/ui/linkage-attr/linkage-import.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage-import.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,8 @@\n+// build-pass\n+// aux-build:def_external.rs\n+\n+extern crate def_external as dep;\n+\n+fn main() {\n+    println!(\"{:p}\", &dep::EXTERN);\n+}"}, {"sha": "93afc537f7c6c1175970596bc2d66293d4ca7204", "filename": "src/test/ui/linkage-attr/linkage-requires-raw-ptr.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f8393f87f8bdfad388fe112464d97661a8cb2/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage-requires-raw-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f8393f87f8bdfad388fe112464d97661a8cb2/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage-requires-raw-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage-requires-raw-ptr.rs?ref=4e9f8393f87f8bdfad388fe112464d97661a8cb2", "patch": "@@ -1,11 +0,0 @@\n-// rust-lang/rust#59548: We used to ICE when trying to use a static\n-// with a type that violated its own `#[linkage]`.\n-\n-// build-fail\n-// aux-build:def_illtyped_external.rs\n-\n-extern crate def_illtyped_external as dep;\n-\n-fn main() {\n-    println!(\"{:p}\", &dep::EXTERN);\n-}"}, {"sha": "5abbe745c6a215d043d43e8ad1f5da93a908c319", "filename": "src/test/ui/linkage-attr/linkage-requires-raw-ptr.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e9f8393f87f8bdfad388fe112464d97661a8cb2/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage-requires-raw-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e9f8393f87f8bdfad388fe112464d97661a8cb2/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage-requires-raw-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage-requires-raw-ptr.stderr?ref=4e9f8393f87f8bdfad388fe112464d97661a8cb2", "patch": "@@ -1,8 +0,0 @@\n-error: must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n-  --> $DIR/auxiliary/def_illtyped_external.rs:5:1\n-   |\n-LL | pub static EXTERN: u32 = 0;\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "aa42874f7ba8a64767d80708e2282fb1e349d88c", "filename": "src/test/ui/linkage-attr/linkage2.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage2.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,16 +1,11 @@\n-// FIXME https://github.com/rust-lang/rust/issues/59774\n-\n-// build-fail\n-// normalize-stderr-test \"thread.*panicked.*Metadata module not compiled.*\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*RUST_BACKTRACE=1.*\\n\" -> \"\"\n-// ignore-sgx no weak linkages permitted\n+// check-fail\n \n #![feature(linkage)]\n \n extern \"C\" {\n     #[linkage = \"extern_weak\"]\n     static foo: i32;\n-//~^ ERROR: must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n+//~^ ERROR: invalid type for variable with `#[linkage]` attribute\n }\n \n fn main() {"}, {"sha": "7265f711fd01643ca2020957052fadab196312d4", "filename": "src/test/ui/linkage-attr/linkage2.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flinkage-attr%2Flinkage2.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -1,8 +1,9 @@\n-error: must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n-  --> $DIR/linkage2.rs:12:5\n+error[E0791]: invalid type for variable with `#[linkage]` attribute\n+  --> $DIR/linkage2.rs:7:5\n    |\n LL |     static foo: i32;\n    |     ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0791`."}, {"sha": "5fbc658f1557c9cbe1d61713592df9885356fde5", "filename": "src/test/ui/lint/issue-104897.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flint%2Fissue-104897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flint%2Fissue-104897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-104897.rs?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,6 @@\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: format argument must be a string literal\n+\n+fn f(){(print!(\u00e1"}, {"sha": "817a93c2f3bb2774d2ba158999384d4740324cbe", "filename": "src/test/ui/lint/issue-104897.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flint%2Fissue-104897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Flint%2Fissue-104897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-104897.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -0,0 +1,43 @@\n+error: this file contains an unclosed delimiter\n+  --> $DIR/issue-104897.rs:6:18\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |       --      -  ^\n+   |       ||      |\n+   |       ||      unclosed delimiter\n+   |       |unclosed delimiter\n+   |       unclosed delimiter\n+\n+error: this file contains an unclosed delimiter\n+  --> $DIR/issue-104897.rs:6:18\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |       --      -  ^\n+   |       ||      |\n+   |       ||      unclosed delimiter\n+   |       |unclosed delimiter\n+   |       unclosed delimiter\n+\n+error: this file contains an unclosed delimiter\n+  --> $DIR/issue-104897.rs:6:18\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |       --      -  ^\n+   |       ||      |\n+   |       ||      unclosed delimiter\n+   |       |unclosed delimiter\n+   |       unclosed delimiter\n+\n+error: format argument must be a string literal\n+  --> $DIR/issue-104897.rs:6:16\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |                ^\n+   |\n+help: you might be missing a string literal to format with\n+   |\n+LL | fn f(){(print!(\"{}\", \u00e1\n+   |                +++++\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c42ee9b295e1d365e4f07ff2b76200994470828c", "filename": "src/test/ui/macros/syntax-error-recovery.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aab3bcecb7da86b141d9a39079afedd0820115e6/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr?ref=aab3bcecb7da86b141d9a39079afedd0820115e6", "patch": "@@ -7,6 +7,7 @@ LL |                 $token $($inner)? = $value,\n LL | values!(STRING(1) as (String) => cfg(test),);\n    | -------------------------------------------- in this macro invocation\n    |\n+   = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n    = note: this error originates in the macro `values` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: macro expansion ignores token `(String)` and any following"}]}