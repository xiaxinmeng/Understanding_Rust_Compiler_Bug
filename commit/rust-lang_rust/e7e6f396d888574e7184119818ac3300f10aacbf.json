{"sha": "e7e6f396d888574e7184119818ac3300f10aacbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZTZmMzk2ZDg4ODU3NGU3MTg0MTE5ODE4YWMzMzAwZjEwYWFjYmY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-03-24T15:33:20Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-31T14:41:39Z"}, "message": "Preserve comments when pretty-printing.\n\nThe patch also includes a number of smaller fixes to the\npretty-printer that were encountered on the way.", "tree": {"sha": "143c2c918a5123d6ed07b8ee61909981d3aa47e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/143c2c918a5123d6ed07b8ee61909981d3aa47e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7e6f396d888574e7184119818ac3300f10aacbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e6f396d888574e7184119818ac3300f10aacbf", "html_url": "https://github.com/rust-lang/rust/commit/e7e6f396d888574e7184119818ac3300f10aacbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7e6f396d888574e7184119818ac3300f10aacbf/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffc188a4dd9262750b3f95bb3b582577836740f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc188a4dd9262750b3f95bb3b582577836740f2", "html_url": "https://github.com/rust-lang/rust/commit/ffc188a4dd9262750b3f95bb3b582577836740f2"}], "stats": {"total": 1848, "additions": 1060, "deletions": 788}, "files": [{"sha": "9ab216228a5f5802495799400a45fb979a98c3ba", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=e7e6f396d888574e7184119818ac3300f10aacbf", "patch": "@@ -77,7 +77,7 @@ impure fn pretty_print_input(session.session sess,\n     auto def = tup(0, 0);\n     auto p = front.parser.new_parser(sess, env, def, input);\n     auto crate = front.parser.parse_crate_from_source_file(p);\n-    pretty.pprust.print_ast(crate.node.module, std.io.stdout());\n+    pretty.pprust.print_file(crate.node.module, input, std.io.stdout());\n }\n \n fn warn_wrong_compiler() {"}, {"sha": "2229a4e61cfce9b20bb1b1c8e36182ea68069336", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=e7e6f396d888574e7184119818ac3300f10aacbf", "patch": "@@ -1,5 +1,6 @@\n import std.io;\n import std._str;\n+import std._vec;\n import std._int;\n import std.map;\n import std.map.hashmap;\n@@ -781,6 +782,85 @@ impure fn next_token(reader rdr) -> token.token {\n     fail;\n }\n \n+tag cmnt_ {\n+    cmnt_line(str);\n+    cmnt_block(vec[str]);\n+}\n+type cmnt = rec(cmnt_ val, common.pos pos, bool space_after);\n+\n+impure fn consume_whitespace(reader rdr) -> uint {\n+    auto lines = 0u;\n+    while (is_whitespace(rdr.curr())) {\n+        if (rdr.curr() == '\\n') {lines += 1u;}\n+        rdr.bump();\n+    }\n+    ret lines;\n+}\n+\n+impure fn read_line_comment(reader rdr) -> cmnt {\n+    auto p = rdr.get_curr_pos();\n+    rdr.bump(); rdr.bump();\n+    consume_whitespace(rdr);\n+    auto val = \"\";\n+    while (rdr.curr() != '\\n') {\n+        _str.push_char(val, rdr.curr());\n+        rdr.bump();\n+    }\n+    ret rec(val=cmnt_line(val),\n+            pos=p,\n+            space_after=consume_whitespace(rdr) > 1u);\n+}\n+\n+impure fn read_block_comment(reader rdr) -> cmnt {\n+    auto p = rdr.get_curr_pos();\n+    rdr.bump(); rdr.bump();\n+    consume_whitespace(rdr);\n+    let vec[str] lines = vec();\n+    auto val = \"\";\n+    auto level = 1;\n+    while (true) {\n+        if (rdr.curr() == '\\n') {\n+            _vec.push[str](lines, val);\n+            val = \"\";\n+            consume_whitespace(rdr);\n+        } else {\n+            if (rdr.curr() == '*' && rdr.next() == '/') {\n+                level -= 1;\n+                if (level == 0) {\n+                    rdr.bump(); rdr.bump();\n+                    _vec.push[str](lines, val);\n+                    break;\n+                }\n+            } else if (rdr.curr() == '/' && rdr.next() == '*') {\n+                level += 1;\n+            }\n+            _str.push_char(val, rdr.curr());\n+            rdr.bump();\n+        }\n+    }\n+    ret rec(val=cmnt_block(lines),\n+            pos=p,\n+            space_after=consume_whitespace(rdr) > 1u);\n+}\n+\n+impure fn gather_comments(str path) -> vec[cmnt] {\n+    auto srdr = io.file_reader(path);\n+    auto rdr = lexer.new_reader(srdr, path);\n+    let vec[cmnt] comments = vec();\n+    while (!rdr.is_eof()) {\n+        while (true) {\n+            consume_whitespace(rdr);\n+            if (rdr.curr() == '/' && rdr.next() == '/') {\n+                _vec.push[cmnt](comments, read_line_comment(rdr));\n+            } else if (rdr.curr() == '/' && rdr.next() == '*') {\n+                _vec.push[cmnt](comments, read_block_comment(rdr));\n+            } else { break; }\n+        }\n+        next_token(rdr);\n+    }\n+    ret comments;\n+}\n+\n \n //\n // Local Variables:"}, {"sha": "82f7712ff7312e07eacdeab759fcf0dedfdc4859", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=e7e6f396d888574e7184119818ac3300f10aacbf", "patch": "@@ -116,6 +116,8 @@ impure fn new_parser(session.session sess,\n     }\n     auto srdr = io.file_reader(path);\n     auto rdr = lexer.new_reader(srdr, path);\n+    // Make sure npos points at first actual token.\n+    lexer.consume_any_whitespace(rdr);\n     auto npos = rdr.get_curr_pos();\n     ret stdio_parser(sess, env, ftype, lexer.next_token(rdr),\n                      npos, npos, initial_def._1, UNRESTRICTED, initial_def._0,\n@@ -1748,8 +1750,8 @@ impure fn parse_block(parser p) -> ast.block {\n         }\n     }\n \n-    p.bump();\n     auto hi = p.get_span();\n+    p.bump();\n \n     auto bloc = index_block(stmts, expr);\n     ret spanned[ast.block_](lo, hi, bloc);"}, {"sha": "b7b0c64a17ed553cc038c3bf1bb7e3fa4aa9bd27", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 131, "deletions": 90, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=e7e6f396d888574e7184119818ac3300f10aacbf", "patch": "@@ -4,9 +4,11 @@ import std._str;\n \n tag boxtype {box_h; box_v; box_hv; box_align;}\n tag contexttype {cx_h; cx_v;}\n+tag scantype {scan_hv; scan_h; scan_none;}\n \n tag token {\n   brk(uint);\n+  hardbrk;\n   word(str);\n   cword(str); // closing token\n   open(boxtype, uint);\n@@ -18,29 +20,45 @@ type context = rec(contexttype tp, uint indent);\n type ps = @rec(mutable vec[context] context,\n                uint width,\n                io.writer out,\n-               mutable vec[token] buffered,\n-               mutable uint scandepth,\n-               mutable uint bufferedcol,\n                mutable uint col,\n-               mutable bool start_of_line);\n+               mutable uint spaces,\n+               mutable vec[token] buffered,\n+               mutable scantype scanning,\n+               mutable vec[boxtype] scandepth,\n+               mutable uint scancol,\n+               mutable bool start_of_line,\n+               mutable bool start_of_box,\n+               mutable bool potential_brk);\n \n fn mkstate(io.writer out, uint width) -> ps {\n   let vec[context] stack = vec(rec(tp=cx_v, indent=0u));\n   let vec[token] buff = vec();\n+  let vec[boxtype] sd = vec();\n   ret @rec(mutable context=stack,\n            width=width,\n            out=out,\n-           mutable buffered=buff,\n-           mutable scandepth=0u,\n-           mutable bufferedcol=0u,\n            mutable col=0u,\n-           mutable start_of_line=true);\n+           mutable spaces=0u,\n+           mutable buffered=buff,\n+           mutable scanning=scan_none,\n+           mutable scandepth=sd,\n+           mutable scancol=0u,\n+           mutable start_of_line=true,\n+           mutable start_of_box=true,\n+           mutable potential_brk=false);\n+}\n+\n+impure fn write_spaces(ps p, uint i) {\n+  while (i > 0u) {\n+    i -= 1u;\n+    p.out.write_str(\" \");\n+  }\n }\n \n impure fn push_context(ps p, contexttype tp, uint indent) {\n   before_print(p, false);\n-  _vec.push[context](p.context, rec(tp=tp, indent=base_indent(p)\n-                                    + indent));\n+  _vec.push[context](p.context, rec(tp=tp, indent=indent));\n+  p.start_of_box = true;\n }\n \n fn pop_context(ps p) {\n@@ -49,15 +67,13 @@ fn pop_context(ps p) {\n \n impure fn add_token(ps p, token tok) {\n   if (p.width == 0u) {direct_token(p, tok);}\n-  else if (p.scandepth == 0u) {do_token(p, tok);}\n+  else if (p.scanning == scan_none) {do_token(p, tok);}\n   else {buffer_token(p, tok);}\n }\n \n impure fn direct_token(ps p, token tok) {\n   alt (tok) {\n-    case (brk(?sz)) {\n-      while (sz > 0u) {p.out.write_str(\" \"); sz -= 1u;}\n-    }\n+    case (brk(?sz)) {write_spaces(p, sz);}\n     case (word(?w)) {p.out.write_str(w);}\n     case (cword(?w)) {p.out.write_str(w);}\n     case (_) {}\n@@ -66,78 +82,75 @@ impure fn direct_token(ps p, token tok) {\n \n impure fn buffer_token(ps p, token tok) {\n   p.buffered += vec(tok);\n-  p.bufferedcol += token_size(tok);\n-  alt (p.buffered.(0)) {\n-    case (brk(_)) {\n-      alt (tok) {\n-        case (brk(_)) {\n-          if (p.scandepth == 1u) {finish_break_scan(p);}\n+  auto col = p.scancol;\n+  p.scancol = col + token_size(tok);\n+  if (p.scancol > p.width) {\n+    finish_scan(p, false);\n+  } else {\n+    alt (tok) {\n+      case (open(?tp,_)) {\n+        _vec.push[boxtype](p.scandepth, tp);\n+        if (p.scanning == scan_h) {\n+          if (tp == box_h) {\n+            check_potential_brk(p);\n+          }\n         }\n-        case (open(box_h,_)) {p.scandepth += 1u;}\n-        case (open(_,_)) {finish_break_scan(p);}\n-        case (close) {\n-          p.scandepth -= 1u;\n-          if (p.scandepth == 0u) {finish_break_scan(p);}\n+      }\n+      case (close) {\n+        _vec.pop[boxtype](p.scandepth);\n+        if (_vec.len[boxtype](p.scandepth) == 0u) {\n+          finish_scan(p, true);\n         }\n-        case (_) {}\n       }\n-    }\n-    case (open(_,_)) {\n-      if (p.bufferedcol > p.width) {finish_block_scan(p, cx_v);}\n-      else {\n-        alt (tok) {\n-          case (open(_,_)) {p.scandepth += 1u;}\n-          case (close) {\n-            p.scandepth -= 1u;\n-            if (p.scandepth == 0u) {finish_block_scan(p, cx_h);}\n+      case (brk(_)) {\n+        if (p.scanning == scan_h) {\n+          if (p.scandepth.(_vec.len[boxtype](p.scandepth)-1u) == box_v) {\n+            finish_scan(p, true);\n           }\n-          case (_) {}\n         }\n       }\n+      case (_) {}\n     }\n   }\n }\n \n-impure fn finish_block_scan(ps p, contexttype tp) {\n+impure fn check_potential_brk(ps p) {\n+  for (boxtype tp in p.scandepth) {\n+    if (tp != box_h) {ret;}\n+  }\n+  p.potential_brk = true;\n+}\n+\n+impure fn finish_scan(ps p, bool fits) {\n   auto buf = p.buffered;\n   auto front = _vec.shift[token](buf);\n-  auto indent;\n-  alt (front){\n-    case (open(box_hv,?ind)) {\n-      indent = ind;\n+  auto chosen_tp = cx_h;\n+  if (!fits) {chosen_tp = cx_v;}\n+  alt (front) {\n+    case (open(box_hv, ?ind)) {\n+      push_context(p, chosen_tp, base_indent(p) + ind);\n     }\n     case (open(box_align, _)) {\n-      indent = p.col - base_indent(p);\n+      push_context(p, chosen_tp, p.col);\n+    }\n+    case (open(box_h, ?ind)) {\n+      if (!fits && !p.start_of_box && !p.start_of_line && !p.potential_brk) {\n+        line_break(p);\n+      }\n+      push_context(p, cx_h, base_indent(p) + ind);\n     }\n   }\n-  p.scandepth = 0u;\n-  p.buffered = vec();\n-  push_context(p, tp, indent);\n+  p.scandepth = vec();\n+  p.scanning = scan_none;\n   for (token t in buf) { add_token(p, t); }\n }\n \n-impure fn finish_break_scan(ps p) {\n-  auto buf = p.buffered;\n-  auto front = _vec.shift[token](buf);\n-  if (p.bufferedcol > p.width) {\n-    line_break(p);\n-  }\n-  else {\n-    auto width;\n-    alt (front) {case(brk(?w)) {width = w;}}\n-    auto i = 0u;\n-    while (i < width) {p.out.write_str(\" \"); i+=1u;}\n-    p.col += width;\n-  }\n-  p.scandepth = 0u;\n+impure fn start_scan(ps p, token tok, scantype tp) {\n   p.buffered = vec();\n-  for (token t in buf) { add_token(p, t); }\n-}\n-\n-impure fn start_scan(ps p, token tok) {\n-  p.buffered = vec(tok);\n-  p.scandepth = 1u;\n-  p.bufferedcol = p.col;\n+  p.scancol = p.col;\n+  p.scanning = tp;\n+  buffer_token(p, tok);\n+  p.potential_brk = false;\n }\n \n fn cur_context(ps p) -> context {\n@@ -152,64 +165,91 @@ fn base_indent(ps p) -> uint {\n   }\n }\n \n+fn cx_is(contexttype a, contexttype b) -> bool {\n+  if (a == b) {ret true;}\n+  else {ret false;}\n+}\n+fn box_is(boxtype a, boxtype b) -> bool {\n+  if (a == b) {ret true;}\n+  else {ret false;}\n+}\n+\n impure fn do_token(ps p, token tok) {\n+  auto start_of_box = p.start_of_box;\n+  p.start_of_box = false;\n   alt (tok) {\n     case (brk(?sz)) {\n-      alt (cur_context(p).tp) {\n-        case (cx_h) {\n-          before_print(p, false);\n-          start_scan(p, tok);\n-        }\n-        case (cx_v) {\n-          line_break(p);\n-        }\n+      if (cx_is(cur_context(p).tp, cx_v) || sz + p.col > p.width) {\n+        line_break(p);\n+      }\n+      else {\n+        p.spaces += sz;\n       }\n     }\n+    case (hardbrk) {\n+      line_break(p);\n+    }\n     case (word(?w)) {\n+      auto len = _str.char_len(w);\n+      if (len + p.col + p.spaces > p.width && !start_of_box &&\n+          !p.start_of_line) {\n+        line_break(p);\n+      }\n       before_print(p, false);\n       p.out.write_str(w);\n-      p.col += _str.byte_len(w); // TODO char_len\n+      p.col += len;\n     }\n     case (cword(?w)) {\n       before_print(p, true);\n       p.out.write_str(w);\n-      p.col += _str.byte_len(w); // TODO char_len\n+      p.col += _str.char_len(w);\n     }\n     case (open(?tp, ?indent)) {\n-      alt (tp) {\n-        case (box_hv) {start_scan(p, tok);}\n-        case (box_align) {start_scan(p, tok);}\n-        case (box_h) {push_context(p, cx_h, indent);}\n-        case (box_v) {push_context(p, cx_v, indent);}\n+      if (tp == box_v) {\n+        push_context(p, cx_v, base_indent(p) + indent);\n+      } else if (box_is(tp, box_h) && cx_is(cur_context(p).tp, cx_v)) {\n+        push_context(p, cx_h, base_indent(p) + indent);\n+      } else if (tp == box_h) {\n+        p.start_of_box = start_of_box;\n+        start_scan(p, tok, scan_h);\n+      } else {\n+        p.start_of_box = start_of_box;\n+        start_scan(p, tok, scan_hv);\n       }\n     }\n-    case (close) {pop_context(p);}\n+    case (close) {\n+      pop_context(p);\n+    }\n   }\n }\n \n impure fn line_break(ps p) {\n   p.out.write_str(\"\\n\");\n   p.col = 0u;\n+  p.spaces = cur_context(p).indent;\n   p.start_of_line = true;\n }\n \n impure fn before_print(ps p, bool closing) {\n   if (p.start_of_line) {\n     p.start_of_line = false;\n-    auto ind;\n-    if (closing) {ind = base_indent(p);}\n-    else {ind = cur_context(p).indent;}\n-    p.col = ind;\n-    while (ind > 0u) {p.out.write_str(\" \"); ind -= 1u;}\n+    if (closing) {p.spaces = base_indent(p);}\n+    else {p.spaces = cur_context(p).indent;}\n+  }\n+  if (p.spaces > 0u) {\n+    write_spaces(p, p.spaces);\n+    p.col += p.spaces;\n+    p.spaces = 0u;\n   }\n }\n \n fn token_size(token tok) -> uint {\n   alt (tok) {\n     case (brk(?sz)) {ret sz;}\n-    case (word(?w)) {ret _str.byte_len(w);}\n-    case (cword(?w)) {ret _str.byte_len(w);}\n-    case (open(_, _)) {ret 0u;} // TODO exception for V blocks?\n+    case (hardbrk) {ret 0xFFFFFFu;}\n+    case (word(?w)) {ret _str.char_len(w);}\n+    case (cword(?w)) {ret _str.char_len(w);}\n+    case (open(_, _)) {ret 0u;}\n     case (close) {ret 0u;}\n   }\n }\n@@ -224,3 +264,4 @@ impure fn cwrd(ps p, str wrd) {add_token(p, cword(wrd));}\n impure fn space(ps p) {add_token(p, brk(1u));}\n impure fn spaces(ps p, uint n) {add_token(p, brk(n));}\n impure fn line(ps p) {add_token(p, brk(0u));}\n+impure fn hardbreak(ps p) {add_token(p, hardbrk);}"}, {"sha": "ac5cec317b661d27d82cf08d437065f5ccb86939", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 845, "deletions": 696, "changes": 1541, "blob_url": "https://github.com/rust-lang/rust/blob/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e6f396d888574e7184119818ac3300f10aacbf/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=e7e6f396d888574e7184119818ac3300f10aacbf", "patch": "@@ -1,800 +1,949 @@\n import std._vec;\n import std._str;\n+import std.io;\n import std.option;\n import front.ast;\n-import pp.box; import pp.abox; import pp.vbox;\n+import front.lexer;\n import pp.end; import pp.wrd; import pp.space; import pp.line;\n-import pp.ps;\n \n-import foo = std.io;\n-\n-const uint indent_unit = 2u;\n+const uint indent_unit = 4u;\n const int as_prec = 5;\n+const uint default_columns = 78u;\n+\n+type ps = @rec(pp.ps s,\n+               option.t[vec[lexer.cmnt]] comments,\n+               mutable uint cur_cmnt);\n \n-impure fn print_ast(ast._mod _mod, std.io.writer out) {\n-  auto s = pp.mkstate(out, 80u);\n-  for (@ast.view_item vitem in _mod.view_items) {print_view_item(s, vitem);}\n-  line(s);\n-  for (@ast.item item in _mod.items) {print_item(s, item);}\n+impure fn print_file(ast._mod _mod, str filename, io.writer out) {\n+    auto cmnts = lexer.gather_comments(filename);\n+    auto s = @rec(s=pp.mkstate(out, default_columns),\n+                  comments=option.some[vec[lexer.cmnt]](cmnts),\n+                  mutable cur_cmnt=0u);\n+    print_mod(s, _mod);\n }\n \n fn ty_to_str(&@ast.ty ty) -> str {\n-  auto writer = std.io.string_writer();\n-  print_type(pp.mkstate(writer.get_writer(), 0u), ty);\n-  ret writer.get_str();\n+    auto writer = io.string_writer();\n+    auto s = @rec(s=pp.mkstate(writer.get_writer(), 0u),\n+                  comments=option.none[vec[lexer.cmnt]],\n+                  mutable cur_cmnt=0u);\n+    print_type(s, ty);\n+    ret writer.get_str();\n }\n \n impure fn hbox(ps s) {\n-  pp.hbox(s, indent_unit);\n+    pp.hbox(s.s, indent_unit);\n }\n impure fn wrd1(ps s, str word) {\n-  wrd(s, word);\n-  space(s);\n+    wrd(s.s, word);\n+    space(s.s);\n }\n impure fn popen(ps s) {\n-  wrd(s, \"(\");\n-  abox(s);\n+    wrd(s.s, \"(\");\n+    pp.abox(s.s);\n+}\n+impure fn popen_h(ps s) {\n+    wrd(s.s, \"(\");\n+    pp.hbox(s.s, 0u);\n }\n impure fn pclose(ps s) {\n-  end(s);\n-  wrd(s, \")\");\n+    end(s.s);\n+    wrd(s.s, \")\");\n }\n impure fn bopen(ps s) {\n-  wrd1(s, \"{\");\n-  vbox(s, indent_unit);\n-  line(s);\n+    wrd(s.s, \"{\");\n+    pp.vbox(s.s, indent_unit);\n+    line(s.s);\n }\n impure fn bclose(ps s) {\n-  end(s);\n-  pp.cwrd(s, \"}\");\n+    end(s.s);\n+    pp.cwrd(s.s, \"}\");\n+}\n+impure fn bclose_c(ps s, util.common.span span) {\n+    maybe_print_comment(s, span.hi);\n+    bclose(s);\n }\n impure fn commasep[IN](ps s, vec[IN] elts, impure fn (ps, &IN) op) {\n-  auto first = true;\n-  for (IN elt in elts) {\n-    if (first) {first = false;}\n-    else {wrd1(s, \",\");}\n-    op(s, elt);\n-  }\n+    auto first = true;\n+    for (IN elt in elts) {\n+        if (first) {first = false;}\n+        else {wrd1(s, \",\");}\n+        op(s, elt);\n+    }\n }\n \n-impure fn print_mt(ps s, &ast.mt mt) {\n-    alt (mt.mut) {\n-        case (ast.mut)       { wrd1(s, \"mutable\");  }\n-        case (ast.maybe_mut) { wrd1(s, \"mutable?\"); }\n-        case (ast.imm)       { /* nothing */        }\n-    }\n-    print_type(s, mt.ty);\n+impure fn print_mod(ps s, ast._mod _mod) {\n+    for (@ast.view_item vitem in _mod.view_items) {print_view_item(s, vitem);}\n+    line(s.s);\n+    for (@ast.item item in _mod.items) {print_item(s, item);}\n+    print_remaining_comments(s);\n }\n \n impure fn print_type(ps s, &@ast.ty ty) {\n-  hbox(s);\n-  alt (ty.node) {\n-    case (ast.ty_nil) {wrd(s, \"()\");}\n-    case (ast.ty_bool) {wrd(s, \"bool\");}\n-    case (ast.ty_int) {wrd(s, \"int\");}\n-    case (ast.ty_uint) {wrd(s, \"uint\");}\n-    case (ast.ty_machine(?tm)) {wrd(s, util.common.ty_mach_to_str(tm));}\n-    case (ast.ty_char) {wrd(s, \"char\");}\n-    case (ast.ty_str) {wrd(s, \"str\");}\n-    case (ast.ty_box(?mt)) {wrd(s, \"@\"); print_mt(s, mt);}\n-    case (ast.ty_vec(?mt)) {wrd(s, \"vec[\"); print_mt(s, mt); wrd(s, \"]\");}\n-    case (ast.ty_port(?t)) {wrd(s, \"port[\"); print_type(s, t); wrd(s, \"]\");}\n-    case (ast.ty_chan(?t)) {wrd(s, \"chan[\"); print_type(s, t); wrd(s, \"]\");}\n-    case (ast.ty_type) {wrd(s, \"type\");}\n-    case (ast.ty_tup(?elts)) {\n-      wrd(s, \"tup\");\n-      popen(s);\n-      auto f = print_mt;\n-      commasep[ast.mt](s, elts, f);\n-      pclose(s);\n-    }\n-    case (ast.ty_rec(?fields)) {\n-      wrd(s, \"rec\");\n-      popen(s);\n-      impure fn print_field(ps s, &ast.ty_field f) {\n-        hbox(s);\n-        print_mt(s, f.mt);\n-        space(s);\n-        wrd(s, f.ident);\n-        end(s);\n-      }\n-      auto f = print_field;\n-      commasep[ast.ty_field](s, fields, f);\n-      pclose(s);\n-    }\n-    case (ast.ty_obj(?methods)) {\n-      wrd1(s, \"obj\");\n-      bopen(s);\n-      for (ast.ty_method m in methods) {\n-        hbox(s);\n-        print_ty_fn(s, m.proto, option.some[str](m.ident),\n-                    m.inputs, m.output);\n-        wrd(s, \";\");\n-        end(s);\n-        line(s);\n-      }\n-      bclose(s);\n-    }\n-    case (ast.ty_fn(?proto,?inputs,?output)) {\n-      print_ty_fn(s, proto, option.none[str], inputs, output);\n-    }\n-    case (ast.ty_path(?path,_)) {\n-      print_path(s, path);\n+    maybe_print_comment(s, ty.span.lo);\n+    hbox(s);\n+    alt (ty.node) {\n+        case (ast.ty_nil) {wrd(s.s, \"()\");}\n+        case (ast.ty_bool) {wrd(s.s, \"bool\");}\n+        case (ast.ty_int) {wrd(s.s, \"int\");}\n+        case (ast.ty_uint) {wrd(s.s, \"uint\");}\n+        case (ast.ty_machine(?tm)) {wrd(s.s, util.common.ty_mach_to_str(tm));}\n+        case (ast.ty_char) {wrd(s.s, \"char\");}\n+        case (ast.ty_str) {wrd(s.s, \"str\");}\n+        case (ast.ty_box(?mt)) {wrd(s.s, \"@\"); print_mt(s, mt);}\n+        case (ast.ty_vec(?mt)) {\n+            wrd(s.s, \"vec[\"); print_mt(s, mt); wrd(s.s, \"]\");\n+        }\n+        case (ast.ty_port(?t)) {\n+            wrd(s.s, \"port[\"); print_type(s, t); wrd(s.s, \"]\");\n+        }\n+        case (ast.ty_chan(?t)) {\n+            wrd(s.s, \"chan[\"); print_type(s, t); wrd(s.s, \"]\");\n+        }\n+        case (ast.ty_type) {wrd(s.s, \"type\");}\n+        case (ast.ty_tup(?elts)) {\n+            wrd(s.s, \"tup\");\n+            popen(s);\n+            auto f = print_mt;\n+            commasep[ast.mt](s, elts, f);\n+            pclose(s);\n+        }\n+        case (ast.ty_rec(?fields)) {\n+            wrd(s.s, \"rec\");\n+            popen(s);\n+            impure fn print_field(ps s, &ast.ty_field f) {\n+                hbox(s);\n+                print_mt(s, f.mt);\n+                space(s.s);\n+                wrd(s.s, f.ident);\n+                end(s.s);\n+            }\n+            auto f = print_field;\n+            commasep[ast.ty_field](s, fields, f);\n+            pclose(s);\n+        }\n+        case (ast.ty_obj(?methods)) {\n+            wrd1(s, \"obj\");\n+            bopen(s);\n+            for (ast.ty_method m in methods) {\n+                hbox(s);\n+                print_ty_fn(s, m.proto, option.some[str](m.ident),\n+                            m.inputs, m.output);\n+                wrd(s.s, \";\");\n+                end(s.s);\n+                line(s.s);\n+            }\n+            bclose_c(s, ty.span);\n+        }\n+        case (ast.ty_fn(?proto,?inputs,?output)) {\n+            print_ty_fn(s, proto, option.none[str], inputs, output);\n+        }\n+        case (ast.ty_path(?path,_)) {\n+            print_path(s, path);\n+        }\n     }\n-  }\n-  end(s);\n+    end(s.s);\n }\n \n impure fn print_item(ps s, @ast.item item) {\n-  hbox(s);\n-  alt (item.node) {\n-    case (ast.item_const(?id, ?ty, ?expr, _, _)) {\n-      wrd1(s, \"const\");\n-      print_type(s, ty);\n-      space(s);\n-      wrd1(s, id);\n-      wrd1(s, \"=\");\n-      print_expr(s, expr);\n-      wrd(s, \";\");\n-    }\n-    case (ast.item_fn(?name,?_fn,?typarams,_,_)) {\n-      print_fn(s, _fn.decl, name, typarams);\n-      space(s);\n-      print_block(s, _fn.body);\n-    }\n-    case (ast.item_mod(?id,?_mod,_)) {\n-      wrd1(s, \"mod\");\n-      wrd1(s, id);\n-      bopen(s);\n-      for (@ast.item itm in _mod.items) {print_item(s, itm);}\n-      bclose(s);\n-    }\n-    case (ast.item_native_mod(?id,?nmod,_)) {\n-      wrd1(s, \"native\");\n-      alt (nmod.abi) {\n-        case (ast.native_abi_rust) {wrd1(s, \"\\\"rust\\\"\");}\n-        case (ast.native_abi_cdecl) {wrd1(s, \"\\\"cdecl\\\"\");}\n-      }\n-      wrd1(s, \"mod\");\n-      wrd1(s, id);\n-      bopen(s);\n-      for (@ast.native_item item in nmod.items) {\n-        hbox(s);\n-        alt (item.node) {\n-          case (ast.native_item_ty(?id,_)) {\n+    maybe_print_comment(s, item.span.lo);\n+    hbox(s);\n+    alt (item.node) {\n+        case (ast.item_const(?id, ?ty, ?expr, _, _)) {\n+            wrd1(s, \"const\");\n+            print_type(s, ty);\n+            space(s.s);\n+            wrd1(s, id);\n+            wrd1(s, \"=\");\n+            print_expr(s, expr);\n+            wrd(s.s, \";\");\n+        }\n+        case (ast.item_fn(?name,?_fn,?typarams,_,_)) {\n+            print_fn(s, _fn.decl, name, typarams);\n+            space(s.s);\n+            print_block(s, _fn.body);\n+        }\n+        case (ast.item_mod(?id,?_mod,_)) {\n+            wrd1(s, \"mod\");\n+            wrd1(s, id);\n+            bopen(s);\n+            for (@ast.item itm in _mod.items) {print_item(s, itm);}\n+            bclose_c(s, item.span);\n+        }\n+        case (ast.item_native_mod(?id,?nmod,_)) {\n+            wrd1(s, \"native\");\n+            alt (nmod.abi) {\n+                case (ast.native_abi_rust) {wrd1(s, \"\\\"rust\\\"\");}\n+                case (ast.native_abi_cdecl) {wrd1(s, \"\\\"cdecl\\\"\");}\n+            }\n+            wrd1(s, \"mod\");\n+            wrd1(s, id);\n+            bopen(s);\n+            for (@ast.native_item item in nmod.items) {\n+                hbox(s);\n+                maybe_print_comment(s, item.span.lo);\n+                alt (item.node) {\n+                    case (ast.native_item_ty(?id,_)) {\n+                        wrd1(s, \"type\");\n+                        wrd(s.s, id);\n+                    }\n+                    case (ast.native_item_fn(?id,?lname,?decl,\n+                                             ?typarams,_,_)) {\n+                        print_fn(s, decl, id, typarams);\n+                        alt (lname) {\n+                            case (option.none[str]) {}\n+                            case (option.some[str](?ss)) {\n+                                print_string(s, ss);\n+                            }\n+                        }\n+                    }\n+                }\n+                wrd(s.s, \";\");\n+                end(s.s);\n+            }\n+            bclose_c(s, item.span);\n+        }\n+        case (ast.item_ty(?id,?ty,?params,_,_)) {\n             wrd1(s, \"type\");\n-            wrd(s, id);\n-          }\n-          case (ast.native_item_fn(?id,?lname,?decl,?typarams,_,_)) {\n-            print_fn(s, decl, id, typarams);\n-            alt (lname) {\n-              case (option.none[str]) {}\n-              case (option.some[str](?ss)) {print_string(s,ss);}\n+            wrd(s.s, id);\n+            print_type_params(s, params);\n+            space(s.s);\n+            wrd1(s, \"=\");\n+            print_type(s, ty);\n+            wrd(s.s, \";\");\n+        }\n+        case (ast.item_tag(?id,?variants,?params,_)) {\n+            wrd1(s, \"tag\");\n+            wrd(s.s, id);\n+            print_type_params(s, params);\n+            space(s.s);\n+            bopen(s);\n+            for (ast.variant v in variants) {\n+                wrd(s.s, v.name);\n+                if (_vec.len[ast.variant_arg](v.args) > 0u) {\n+                    popen(s);\n+                    impure fn print_variant_arg(ps s, &ast.variant_arg arg) {\n+                        print_type(s, arg.ty);\n+                    }\n+                    auto f = print_variant_arg;\n+                    commasep[ast.variant_arg](s, v.args, f);\n+                    pclose(s);\n+                }\n+                wrd(s.s, \";\");\n+                line(s.s);\n             }\n-          }\n+            bclose_c(s, item.span);\n         }\n-        wrd(s, \";\");\n-        end(s);\n-      }\n-      bclose(s);\n-    }\n-    case (ast.item_ty(?id,?ty,?params,_,_)) {\n-      wrd1(s, \"type\");\n-      wrd(s, id);\n-      print_type_params(s, params);\n-      space(s);\n-      wrd1(s, \"=\");\n-      print_type(s, ty);\n-      wrd(s, \";\");\n-    }\n-    case (ast.item_tag(?id,?variants,?params,_)) {\n-      wrd1(s, \"tag\");\n-      wrd(s, id);\n-      print_type_params(s, params);\n-      space(s);\n-      bopen(s);\n-      for (ast.variant v in variants) {\n-        wrd(s, v.name);\n-        if (_vec.len[ast.variant_arg](v.args) > 0u) {\n-          popen(s);\n-          impure fn print_variant_arg(ps s, &ast.variant_arg arg) {\n-            print_type(s, arg.ty);\n-          }\n-          auto f = print_variant_arg;\n-          commasep[ast.variant_arg](s, v.args, f);\n-          pclose(s);\n-        }\n-        wrd(s, \";\");\n-        line(s);\n-      }\n-      bclose(s);\n-    }\n-    case (ast.item_obj(?id,?_obj,?params,_,_)) {\n-      wrd1(s, \"obj\");\n-      wrd(s, id);\n-      print_type_params(s, params);\n-      popen(s);\n-      impure fn print_field(ps s, &ast.obj_field field) {\n-        hbox(s);\n-        print_type(s, field.ty);\n-        space(s);\n-        wrd(s, field.ident);\n-        end(s);\n-      }\n-      auto f = print_field;\n-      commasep[ast.obj_field](s, _obj.fields, f);\n-      pclose(s);\n-      space(s);\n-      bopen(s);\n-      for (@ast.method meth in _obj.methods) {\n-        hbox(s);\n-        let vec[ast.ty_param] typarams = vec();\n-        print_fn(s, meth.node.meth.decl, meth.node.ident, typarams);\n-        space(s);\n-        print_block(s, meth.node.meth.body);\n-        end(s);\n-        line(s);\n-      }\n-      alt (_obj.dtor) {\n-        case (option.some[ast.block](?dtor)) {\n-          hbox(s);\n-          wrd1(s, \"close\");\n-          print_block(s, dtor);\n-          end(s);\n-          line(s);\n+        case (ast.item_obj(?id,?_obj,?params,_,_)) {\n+            wrd1(s, \"obj\");\n+            wrd(s.s, id);\n+            print_type_params(s, params);\n+            popen(s);\n+            impure fn print_field(ps s, &ast.obj_field field) {\n+                hbox(s);\n+                print_type(s, field.ty);\n+                space(s.s);\n+                wrd(s.s, field.ident);\n+                end(s.s);\n+            }\n+            auto f = print_field;\n+            commasep[ast.obj_field](s, _obj.fields, f);\n+            pclose(s);\n+            space(s.s);\n+            bopen(s);\n+            for (@ast.method meth in _obj.methods) {\n+                hbox(s);\n+                let vec[ast.ty_param] typarams = vec();\n+                maybe_print_comment(s, meth.span.lo);\n+                print_fn(s, meth.node.meth.decl, meth.node.ident, typarams);\n+                space(s.s);\n+                print_block(s, meth.node.meth.body);\n+                end(s.s);\n+                line(s.s);\n+            }\n+            alt (_obj.dtor) {\n+                case (option.some[ast.block](?dtor)) {\n+                    hbox(s);\n+                    wrd1(s, \"close\");\n+                    print_block(s, dtor);\n+                    end(s.s);\n+                    line(s.s);\n+                }\n+                case (_) {}\n+            }\n+            bclose_c(s, item.span);\n         }\n-        case (_) {}\n-      }\n-      bclose(s);\n     }\n-  }\n-  end(s);\n-  line(s);\n-  line(s);\n+    end(s.s);\n+    line(s.s);\n+    line(s.s);\n }\n \n impure fn print_block(ps s, ast.block blk) {\n-  bopen(s);\n-  for (@ast.stmt st in blk.node.stmts) {\n-    alt (st.node) {\n-      case (ast.stmt_decl(?decl)) {print_decl(s, decl);}\n-      case (ast.stmt_expr(?expr)) {print_expr(s, expr);}\n+    auto cur_line = 0u;\n+    maybe_print_comment(s, blk.span.lo);\n+    bopen(s);\n+    for (@ast.stmt st in blk.node.stmts) {\n+        if (cur_line != 0u && blk.span.lo.line > cur_line + 1u) {\n+            line(s.s);\n+        }\n+        cur_line = blk.span.hi.line;\n+        maybe_print_comment(s, st.span.lo);\n+        alt (st.node) {\n+            case (ast.stmt_decl(?decl)) {print_decl(s, decl);}\n+            case (ast.stmt_expr(?expr)) {print_expr(s, expr);}\n+        }\n+        if (front.parser.stmt_ends_with_semi(st)) {wrd(s.s, \";\");}\n+        if (!maybe_print_stmt_comment(s, st.span)) {line(s.s);}\n     }\n-    if (front.parser.stmt_ends_with_semi(st)) {wrd(s, \";\");}\n-    line(s);\n-  }\n-  alt (blk.node.expr) {\n-    case (option.some[@ast.expr](?expr)) {\n-      print_expr(s, expr);\n-      line(s);\n+    alt (blk.node.expr) {\n+        case (option.some[@ast.expr](?expr)) {\n+            if (cur_line != 0u && blk.span.lo.line > cur_line + 1u) {\n+                line(s.s);\n+            }\n+            print_expr(s, expr);\n+            if (!maybe_print_stmt_comment(s, expr.span)) {line(s.s);}\n+        }\n+        case (_) {}\n     }\n-    case (_) {}\n-  }\n-  bclose(s);\n+    bclose_c(s, blk.span);\n }\n \n impure fn print_literal(ps s, @ast.lit lit) {\n-  alt (lit.node) {\n-    case (ast.lit_str(?st)) {print_string(s, st);}\n-    case (ast.lit_char(?ch)) {\n-      wrd(s, \"'\" + escape_str(_str.from_bytes(vec(ch as u8)), '\\'') + \"'\");\n-    }\n-    case (ast.lit_int(?val)) {\n-      wrd(s, util.common.istr(val));\n-    }\n-    case (ast.lit_uint(?val)) { // TODO clipping? uistr?\n-      wrd(s, util.common.istr(val as int) + \"u\");\n-    }\n-    case (ast.lit_float(?fstr)) {\n-      wrd(s, fstr);\n-    }\n-    case (ast.lit_mach_int(?mach,?val)) {\n-      wrd(s, util.common.istr(val as int));\n-      wrd(s, util.common.ty_mach_to_str(mach));\n-    }\n-    case (ast.lit_nil) {wrd(s, \"()\");}\n-    case (ast.lit_bool(?val)) {\n-      if (val) {wrd(s, \"true\");} else {wrd(s, \"false\");}\n+    maybe_print_comment(s, lit.span.lo);\n+    alt (lit.node) {\n+        case (ast.lit_str(?st)) {print_string(s, st);}\n+        case (ast.lit_char(?ch)) {\n+            wrd(s.s, \"'\" + escape_str(_str.from_bytes(vec(ch as u8)), '\\'')\n+                + \"'\");\n+        }\n+        case (ast.lit_int(?val)) {\n+            wrd(s.s, util.common.istr(val));\n+        }\n+        case (ast.lit_uint(?val)) { // FIXME clipping? uistr?\n+            wrd(s.s, util.common.istr(val as int) + \"u\");\n+        }\n+        case (ast.lit_float(?fstr)) {\n+            wrd(s.s, fstr);\n+        }\n+        case (ast.lit_mach_int(?mach,?val)) {\n+            wrd(s.s, util.common.istr(val as int));\n+            wrd(s.s, util.common.ty_mach_to_str(mach));\n+        }\n+        case (ast.lit_nil) {wrd(s.s, \"()\");}\n+        case (ast.lit_bool(?val)) {\n+            if (val) {wrd(s.s, \"true\");} else {wrd(s.s, \"false\");}\n+        }\n     }\n-  }\n }\n \n impure fn print_expr(ps s, &@ast.expr expr) {\n-  auto pe = print_expr;\n-  hbox(s);\n-  alt (expr.node) {\n-    case (ast.expr_vec(?exprs,?mut,_)) {\n-      if (mut == ast.mut) {\n-        wrd1(s, \"mutable\");\n-      }\n-      wrd(s, \"vec\");\n-      popen(s);\n-      commasep[@ast.expr](s, exprs, pe);\n-      pclose(s);\n-    }\n-    case (ast.expr_tup(?exprs,_)) {\n-      impure fn printElt(ps s, &ast.elt elt) {\n-        hbox(s);\n-        if (elt.mut == ast.mut) {wrd1(s, \"mutable\");}\n-        print_expr(s, elt.expr);\n-        end(s);\n-      }\n-      wrd(s, \"tup\");\n-      popen(s);\n-      auto f = printElt;\n-      commasep[ast.elt](s, exprs, f);\n-      pclose(s);\n-    }\n-    case (ast.expr_rec(?fields,?wth,_)) {\n-      impure fn print_field(ps s, &ast.field field) {\n-        hbox(s);\n-        if (field.mut == ast.mut) {wrd1(s, \"mutable\");}\n-        wrd(s, field.ident);\n-        wrd(s, \"=\");\n-        print_expr(s, field.expr);\n-        end(s);\n-      }\n-      wrd(s, \"rec\");\n-      popen(s);\n-      auto f = print_field;\n-      commasep[ast.field](s, fields, f);\n-      alt (wth) {\n-        case (option.some[@ast.expr](?expr)) {\n-          if (_vec.len[ast.field](fields) > 0u) {space(s);}\n-          hbox(s);\n-          wrd1(s, \"with\");\n-          print_expr(s, expr);\n-          end(s);\n+    maybe_print_comment(s, expr.span.lo);\n+    auto pe = print_expr;\n+    hbox(s);\n+    alt (expr.node) {\n+        case (ast.expr_vec(?exprs,?mut,_)) {\n+            if (mut == ast.mut) {\n+                wrd1(s, \"mutable\");\n+            }\n+            wrd(s.s, \"vec\");\n+            popen(s);\n+            commasep[@ast.expr](s, exprs, pe);\n+            pclose(s);\n         }\n-        case (_) {}\n-      }\n-      pclose(s);\n-    }\n-    case (ast.expr_call(?func,?args,_)) {\n-      print_expr(s, func);\n-      popen(s);\n-      commasep[@ast.expr](s, args, pe);\n-      pclose(s);\n-    }\n-    case (ast.expr_bind(?func,?args,_)) {\n-      impure fn print_opt(ps s, &option.t[@ast.expr] expr) {\n-        alt (expr) {\n-          case (option.some[@ast.expr](?expr)) {\n+        case (ast.expr_tup(?exprs,_)) {\n+            impure fn printElt(ps s, &ast.elt elt) {\n+                hbox(s);\n+                if (elt.mut == ast.mut) {wrd1(s, \"mutable\");}\n+                print_expr(s, elt.expr);\n+                end(s.s);\n+            }\n+            wrd(s.s, \"tup\");\n+            popen(s);\n+            auto f = printElt;\n+            commasep[ast.elt](s, exprs, f);\n+            pclose(s);\n+        }\n+        case (ast.expr_rec(?fields,?wth,_)) {\n+            impure fn print_field(ps s, &ast.field field) {\n+                hbox(s);\n+                if (field.mut == ast.mut) {wrd1(s, \"mutable\");}\n+                wrd(s.s, field.ident);\n+                wrd(s.s, \"=\");\n+                print_expr(s, field.expr);\n+                end(s.s);\n+            }\n+            wrd(s.s, \"rec\");\n+            popen(s);\n+            auto f = print_field;\n+            commasep[ast.field](s, fields, f);\n+            alt (wth) {\n+                case (option.some[@ast.expr](?expr)) {\n+                    if (_vec.len[ast.field](fields) > 0u) {space(s.s);}\n+                    hbox(s);\n+                    wrd1(s, \"with\");\n+                    print_expr(s, expr);\n+                    end(s.s);\n+                }\n+                case (_) {}\n+            }\n+            pclose(s);\n+        }\n+        case (ast.expr_call(?func,?args,_)) {\n+            print_expr(s, func);\n+            popen(s);\n+            commasep[@ast.expr](s, args, pe);\n+            pclose(s);\n+        }\n+        case (ast.expr_bind(?func,?args,_)) {\n+            impure fn print_opt(ps s, &option.t[@ast.expr] expr) {\n+                alt (expr) {\n+                    case (option.some[@ast.expr](?expr)) {\n+                        print_expr(s, expr);\n+                    }\n+                    case (_) {wrd(s.s, \"_\");}\n+                }\n+            }\n+            wrd1(s, \"bind\");\n+            print_expr(s, func);\n+            popen(s);\n+            auto f = print_opt;\n+            commasep[option.t[@ast.expr]](s, args, f);\n+            pclose(s);\n+        }\n+        case (ast.expr_binary(?op,?lhs,?rhs,_)) {\n+            auto prec = operator_prec(op);\n+            print_maybe_parens(s, lhs, prec);\n+            space(s.s);\n+            wrd1(s, ast.binop_to_str(op));\n+            print_maybe_parens(s, rhs, prec + 1);\n+        }\n+        case (ast.expr_unary(?op,?expr,_)) {\n+            wrd(s.s, ast.unop_to_str(op));\n             print_expr(s, expr);\n-          }\n-          case (_) {wrd(s, \"_\");}\n-        }\n-      }\n-      wrd1(s, \"bind\");\n-      print_expr(s, func);\n-      popen(s);\n-      auto f = print_opt;\n-      commasep[option.t[@ast.expr]](s, args, f);\n-      pclose(s);\n-    }\n-    case (ast.expr_binary(?op,?lhs,?rhs,_)) {\n-      auto prec = operator_prec(op);\n-      print_maybe_parens(s, lhs, prec);\n-      space(s);\n-      wrd1(s, ast.binop_to_str(op));\n-      print_maybe_parens(s, rhs, prec + 1);\n-    }\n-    case (ast.expr_unary(?op,?expr,_)) {\n-      wrd(s, ast.unop_to_str(op));\n-      print_expr(s, expr);\n-    }\n-    case (ast.expr_lit(?lit,_)) {\n-      print_literal(s, lit);\n-    }\n-    case (ast.expr_cast(?expr,?ty,_)) {\n-      print_maybe_parens(s, expr, as_prec);\n-      space(s);\n-      wrd1(s, \"as\");\n-      print_type(s, ty);\n-    }\n-    case (ast.expr_if(?test,?block,?elseopt,_)) {\n-      wrd1(s, \"if\");\n-      popen(s);\n-      print_expr(s, test);\n-      pclose(s);\n-      space(s);\n-      print_block(s, block);\n-      alt (elseopt) {\n-        case (option.some[@ast.expr](?_else)) {\n-          space(s);\n-          wrd1(s, \"else\");\n-          print_expr(s, _else);\n-        }\n-        case (_) { /* fall through */ }\n-      }\n-    }\n-    case (ast.expr_while(?test,?block,_)) {\n-      wrd1(s, \"while\");\n-      popen(s);\n-      print_expr(s, test);\n-      pclose(s);\n-      space(s);\n-      print_block(s, block);\n-    }\n-    case (ast.expr_for(?decl,?expr,?block,_)) {\n-      wrd1(s, \"for\");\n-      popen(s);\n-      print_decl(s, decl);\n-      space(s);\n-      wrd1(s, \"in\");\n-      print_expr(s, expr);\n-      pclose(s);\n-      space(s);\n-      print_block(s, block);\n-    }\n-    case (ast.expr_for_each(?decl,?expr,?block,_)) {\n-      wrd1(s, \"for each\");\n-      popen(s);\n-      print_decl(s, decl);\n-      space(s);\n-      wrd1(s, \"in\");\n-      print_expr(s, expr);\n-      space(s);\n-      print_block(s, block);\n-    }\n-    case (ast.expr_do_while(?block,?expr,_)) {\n-      wrd1(s, \"do\");\n-      space(s);\n-      print_block(s, block);\n-      space(s);\n-      wrd1(s, \"while\");\n-      popen(s);\n-      print_expr(s, expr);\n-      pclose(s);\n-    }\n-    case (ast.expr_alt(?expr,?arms,_)) {\n-      wrd1(s, \"alt\");\n-      popen(s);\n-      print_expr(s, expr);\n-      pclose(s);\n-      space(s);\n-      bopen(s);\n-      for (ast.arm arm in arms) {\n-        hbox(s);\n-        wrd1(s, \"case\");\n-        popen(s);\n-        print_pat(s, arm.pat);\n-        pclose(s);\n-        space(s);\n-        print_block(s, arm.block);\n-        end(s);\n-        line(s);\n-      }\n-      bclose(s);\n-    }\n-    case (ast.expr_block(?block,_)) {\n-      print_block(s, block);\n-    }\n-    case (ast.expr_assign(?lhs,?rhs,_)) {\n-      print_expr(s, lhs);\n-      space(s);\n-      wrd1(s, \"=\");\n-      print_expr(s, rhs);\n-    }\n-    case (ast.expr_assign_op(?op,?lhs,?rhs,_)) {\n-      print_expr(s, lhs);\n-      space(s);\n-      wrd(s, ast.binop_to_str(op));\n-      wrd1(s, \"=\");\n-      print_expr(s, rhs);\n-    }\n-    case (ast.expr_send(?lhs, ?rhs, _)) {\n-      print_expr(s, lhs);\n-      space(s);\n-      wrd1(s, \"<|\");\n-      print_expr(s, rhs);\n-    }\n-    case (ast.expr_recv(?lhs, ?rhs, _)) {\n-      print_expr(s, lhs);\n-      space(s);\n-      wrd1(s, \"<-\");\n-      print_expr(s, rhs);\n-    }\n-    case (ast.expr_field(?expr,?id,_)) {\n-      print_expr(s, expr);\n-      wrd(s, \".\");\n-      wrd(s, id);\n-    }\n-    case (ast.expr_index(?expr,?index,_)) {\n-      print_expr(s, expr);\n-      wrd(s, \".\");\n-      popen(s);\n-      print_expr(s, index);\n-      pclose(s);\n-    }\n-    case (ast.expr_path(?path,_,_)) {\n-      print_path(s, path);\n-    }\n-    case (ast.expr_fail) {\n-      wrd(s, \"fail\");\n-    }\n-    case (ast.expr_ret(?result)) {\n-      wrd(s, \"ret\");\n-      alt (result) {\n-        case (option.some[@ast.expr](?expr)) {\n-          space(s);\n-          print_expr(s, expr);\n         }\n-        case (_) {}\n-      }\n-    }\n-    case (ast.expr_put(?result)) {\n-      wrd(s, \"put\");\n-      alt (result) {\n-        case (option.some[@ast.expr](?expr)) {\n-          space(s);\n-          print_expr(s, expr);\n+        case (ast.expr_lit(?lit,_)) {\n+            print_literal(s, lit);\n+        }\n+        case (ast.expr_cast(?expr,?ty,_)) {\n+            print_maybe_parens(s, expr, as_prec);\n+            space(s.s);\n+            wrd1(s, \"as\");\n+            print_type(s, ty);\n+        }\n+        case (ast.expr_if(?test,?block,?elseopt,_)) {\n+            wrd1(s, \"if\");\n+            popen_h(s);\n+            print_expr(s, test);\n+            pclose(s);\n+            space(s.s);\n+            print_block(s, block);\n+            alt (elseopt) {\n+                case (option.some[@ast.expr](?_else)) {\n+                    space(s.s);\n+                    wrd1(s, \"else\");\n+                    print_expr(s, _else);\n+                }\n+                case (_) { /* fall through */ }\n+            }\n+        }\n+        case (ast.expr_while(?test,?block,_)) {\n+            wrd1(s, \"while\");\n+            popen_h(s);\n+            print_expr(s, test);\n+            pclose(s);\n+            space(s.s);\n+            print_block(s, block);\n+        }\n+        case (ast.expr_for(?decl,?expr,?block,_)) {\n+            wrd1(s, \"for\");\n+            popen_h(s);\n+            print_for_decl(s, decl);\n+            space(s.s);\n+            wrd1(s, \"in\");\n+            print_expr(s, expr);\n+            pclose(s);\n+            space(s.s);\n+            print_block(s, block);\n+        }\n+        case (ast.expr_for_each(?decl,?expr,?block,_)) {\n+            wrd1(s, \"for each\");\n+            popen_h(s);\n+            print_for_decl(s, decl);\n+            space(s.s);\n+            wrd1(s, \"in\");\n+            print_expr(s, expr);\n+            pclose(s);\n+            space(s.s);\n+            print_block(s, block);\n+        }\n+        case (ast.expr_do_while(?block,?expr,_)) {\n+            wrd1(s, \"do\");\n+            space(s.s);\n+            print_block(s, block);\n+            space(s.s);\n+            wrd1(s, \"while\");\n+            popen_h(s);\n+            print_expr(s, expr);\n+            pclose(s);\n+        }\n+        case (ast.expr_alt(?expr,?arms,_)) {\n+            wrd1(s, \"alt\");\n+            popen_h(s);\n+            print_expr(s, expr);\n+            pclose(s);\n+            space(s.s);\n+            bopen(s);\n+            for (ast.arm arm in arms) {\n+                hbox(s);\n+                wrd1(s, \"case\");\n+                popen_h(s);\n+                print_pat(s, arm.pat);\n+                pclose(s);\n+                space(s.s);\n+                print_block(s, arm.block);\n+                end(s.s);\n+                line(s.s);\n+            }\n+            bclose_c(s, expr.span);\n+        }\n+        case (ast.expr_block(?block,_)) {\n+            print_block(s, block);\n+        }\n+        case (ast.expr_assign(?lhs,?rhs,_)) {\n+            print_expr(s, lhs);\n+            space(s.s);\n+            wrd1(s, \"=\");\n+            print_expr(s, rhs);\n+        }\n+        case (ast.expr_assign_op(?op,?lhs,?rhs,_)) {\n+            print_expr(s, lhs);\n+            space(s.s);\n+            wrd(s.s, ast.binop_to_str(op));\n+            wrd1(s, \"=\");\n+            print_expr(s, rhs);\n+        }\n+        case (ast.expr_send(?lhs, ?rhs, _)) {\n+            print_expr(s, lhs);\n+            space(s.s);\n+            wrd1(s, \"<|\");\n+            print_expr(s, rhs);\n+        }\n+        case (ast.expr_recv(?lhs, ?rhs, _)) {\n+            print_expr(s, lhs);\n+            space(s.s);\n+            wrd1(s, \"<-\");\n+            print_expr(s, rhs);\n+        }\n+        case (ast.expr_field(?expr,?id,_)) {\n+            print_expr(s, expr);\n+            wrd(s.s, \".\");\n+            wrd(s.s, id);\n+        }\n+        case (ast.expr_index(?expr,?index,_)) {\n+            print_expr(s, expr);\n+            wrd(s.s, \".\");\n+            popen_h(s);\n+            print_expr(s, index);\n+            pclose(s);\n+        }\n+        case (ast.expr_path(?path,_,_)) {\n+            print_path(s, path);\n+        }\n+        case (ast.expr_fail) {\n+            wrd(s.s, \"fail\");\n+        }\n+        case (ast.expr_ret(?result)) {\n+            wrd(s.s, \"ret\");\n+            alt (result) {\n+                case (option.some[@ast.expr](?expr)) {\n+                    space(s.s);\n+                    print_expr(s, expr);\n+                }\n+                case (_) {}\n+            }\n+        }\n+        case (ast.expr_put(?result)) {\n+            wrd(s.s, \"put\");\n+            alt (result) {\n+                case (option.some[@ast.expr](?expr)) {\n+                    space(s.s);\n+                    print_expr(s, expr);\n+                }\n+                case (_) {}\n+            }\n+        }\n+        case (ast.expr_be(?result)) {\n+            wrd1(s, \"be\");\n+            print_expr(s, result);\n+        }\n+        case (ast.expr_log(?expr)) {\n+            wrd1(s, \"log\");\n+            print_expr(s, expr);\n+        }\n+        case (ast.expr_check_expr(?expr)) {\n+            wrd1(s, \"check\");\n+            popen_h(s);\n+            print_expr(s, expr);\n+            pclose(s);\n+        }\n+        case (ast.expr_ext(?path, ?args, ?body, _, _)) {\n+            wrd(s.s, \"#\");\n+            print_path(s, path);\n+            if (_vec.len[@ast.expr](args) > 0u) {\n+                popen(s);\n+                commasep[@ast.expr](s, args, pe);\n+                pclose(s);\n+            }\n+            // FIXME: extension 'body'\n+        }\n+        case (ast.expr_port(_)) {\n+            wrd(s.s, \"port\");\n+            popen_h(s);\n+            pclose(s);\n+        }\n+        case (ast.expr_chan(?expr, _)) {\n+            wrd(s.s, \"chan\");\n+            popen_h(s);\n+            print_expr(s, expr);\n+            pclose(s);\n         }\n-        case (_) {}\n-      }\n-    }\n-    case (ast.expr_be(?result)) {\n-      wrd1(s, \"be\");\n-      print_expr(s, result);\n-    }\n-    case (ast.expr_log(?expr)) {\n-      wrd1(s, \"log\");\n-      print_expr(s, expr);\n-    }\n-    case (ast.expr_check_expr(?expr)) {\n-      wrd1(s, \"check\");\n-      print_expr(s, expr);\n-    }\n-    case (ast.expr_ext(?path, ?args, ?body, _, _)) {\n-      wrd(s, \"#\");\n-      print_path(s, path);\n-      if (_vec.len[@ast.expr](args) > 0u) {\n-        popen(s);\n-        commasep[@ast.expr](s, args, pe);\n-        pclose(s);\n-      }\n-      // TODO: extension 'body'\n-    }\n-    case (ast.expr_port(_)) {\n-      wrd(s, \"port\");\n-      popen(s);\n-      pclose(s);\n-    }\n-    case (ast.expr_chan(?expr, _)) {\n-      wrd(s, \"chan\");\n-      popen(s);\n-      print_expr(s, expr);\n-      pclose(s);\n     }\n-  }\n-  end(s);\n+    end(s.s);\n }\n \n impure fn print_decl(ps s, @ast.decl decl) {\n-  hbox(s);\n-  alt (decl.node) {\n-    case (ast.decl_local(?loc)) {\n-      alt (loc.ty) {\n-        case (option.some[@ast.ty](?ty)) {\n-          wrd1(s, \"let\");\n-          print_type(s, ty);\n-          space(s);\n-        }\n-        case (_) {\n-          wrd1(s, \"auto\");\n-        }\n-      }\n-      wrd(s, loc.ident);\n-      alt (loc.init) {\n-        case (option.some[ast.initializer](?init)) {\n-          space(s);\n-          alt (init.op) {\n-            case (ast.init_assign) {\n-              wrd1(s, \"=\");\n+    maybe_print_comment(s, decl.span.lo);\n+    hbox(s);\n+    alt (decl.node) {\n+        case (ast.decl_local(?loc)) {\n+            alt (loc.ty) {\n+                case (option.some[@ast.ty](?ty)) {\n+                    wrd1(s, \"let\");\n+                    print_type(s, ty);\n+                    space(s.s);\n+                }\n+                case (_) {\n+                    wrd1(s, \"auto\");\n+                }\n             }\n-            case (ast.init_recv) {\n-              wrd1(s, \"<-\");\n+            wrd(s.s, loc.ident);\n+            alt (loc.init) {\n+                case (option.some[ast.initializer](?init)) {\n+                    space(s.s);\n+                    alt (init.op) {\n+                        case (ast.init_assign) {\n+                            wrd1(s, \"=\");\n+                        }\n+                        case (ast.init_recv) {\n+                            wrd1(s, \"<-\");\n+                        }\n+                    }\n+                    print_expr(s, init.expr);\n+                }\n+                case (_) {}\n             }\n-          }\n-          print_expr(s, init.expr);\n         }\n-        case (_) {}\n-      }\n+        case (ast.decl_item(?item)) {\n+            print_item(s, item);\n+        }\n     }\n-    case (ast.decl_item(?item)) {\n-      print_item(s, item);\n+    end(s.s);\n+}\n+\n+impure fn print_for_decl(ps s, @ast.decl decl) {\n+    alt (decl.node) {\n+        case (ast.decl_local(?loc)) {\n+            print_type(s, option.get[@ast.ty](loc.ty));\n+            space(s.s);\n+            wrd(s.s, loc.ident);\n+        }\n     }\n-  }\n-  end(s);\n }\n \n impure fn print_path(ps s, ast.path path) {\n-  auto first = true;\n-  for (str id in path.node.idents) {\n-    if (first) {first = false;}\n-    else {wrd(s, \".\");}\n-    wrd(s, id);\n-  }\n-  if (_vec.len[@ast.ty](path.node.types) > 0u) {\n-    wrd(s, \"[\");\n-    auto f = print_type;\n-    commasep[@ast.ty](s, path.node.types, f);\n-    wrd(s, \"]\");\n-  }\n+    maybe_print_comment(s, path.span.lo);\n+    auto first = true;\n+    for (str id in path.node.idents) {\n+        if (first) {first = false;}\n+        else {wrd(s.s, \".\");}\n+        wrd(s.s, id);\n+    }\n+    if (_vec.len[@ast.ty](path.node.types) > 0u) {\n+        wrd(s.s, \"[\");\n+        auto f = print_type;\n+        commasep[@ast.ty](s, path.node.types, f);\n+        wrd(s.s, \"]\");\n+    }\n }\n \n impure fn print_pat(ps s, &@ast.pat pat) {\n-  alt (pat.node) {\n-    case (ast.pat_wild(_)) {wrd(s, \"_\");}\n-    case (ast.pat_bind(?id,_,_)) {wrd(s, \"?\" + id);}\n-    case (ast.pat_lit(?lit,_)) {print_literal(s, lit);}\n-    case (ast.pat_tag(?path,?args,_,_)) {\n-      print_path(s, path);\n-      if (_vec.len[@ast.pat](args) > 0u) {\n-        popen(s);\n-        auto f = print_pat;\n-        commasep[@ast.pat](s, args, f);\n-        pclose(s);\n-      }\n+    maybe_print_comment(s, pat.span.lo);\n+    alt (pat.node) {\n+        case (ast.pat_wild(_)) {wrd(s.s, \"_\");}\n+        case (ast.pat_bind(?id,_,_)) {wrd(s.s, \"?\" + id);}\n+        case (ast.pat_lit(?lit,_)) {print_literal(s, lit);}\n+        case (ast.pat_tag(?path,?args,_,_)) {\n+            print_path(s, path);\n+            if (_vec.len[@ast.pat](args) > 0u) {\n+                popen_h(s);\n+                auto f = print_pat;\n+                commasep[@ast.pat](s, args, f);\n+                pclose(s);\n+            }\n+        }\n     }\n-  }\n }\n \n impure fn print_fn(ps s, ast.fn_decl decl, str name,\n                    vec[ast.ty_param] typarams) {\n-  alt (decl.effect) {\n-    case (ast.eff_impure) {wrd1(s, \"impure\");}\n-    case (ast.eff_unsafe) {wrd1(s, \"unsafe\");}\n-    case (_) {}\n-  }\n-  wrd1(s, \"fn\");\n-  wrd(s, name);\n-  print_type_params(s, typarams);\n-  popen(s);\n-  impure fn print_arg(ps s, &ast.arg x) {\n-    hbox(s);\n-    print_type(s, x.ty);\n-    space(s);\n-    wrd(s, x.ident);\n-    end(s);\n-  }\n-  auto f = print_arg;\n-  commasep[ast.arg](s, decl.inputs, f);\n-  pclose(s);\n-  if (decl.output.node != ast.ty_nil) {\n-    space(s);\n-    hbox(s);\n-    wrd1(s, \"->\");\n-    print_type(s, decl.output);\n-    end(s);\n-  }\n+    alt (decl.effect) {\n+        case (ast.eff_impure) {wrd1(s, \"impure\");}\n+        case (ast.eff_unsafe) {wrd1(s, \"unsafe\");}\n+        case (_) {}\n+    }\n+    wrd1(s, \"fn\");\n+    wrd(s.s, name);\n+    print_type_params(s, typarams);\n+    popen(s);\n+    impure fn print_arg(ps s, &ast.arg x) {\n+        hbox(s);\n+        if (x.mode == ast.alias) {wrd(s.s, \"&\");}\n+        print_type(s, x.ty);\n+        space(s.s);\n+        wrd(s.s, x.ident);\n+        end(s.s);\n+    }\n+    auto f = print_arg;\n+    commasep[ast.arg](s, decl.inputs, f);\n+    pclose(s);\n+    maybe_print_comment(s, decl.output.span.lo);\n+    if (decl.output.node != ast.ty_nil) {\n+        space(s.s);\n+        hbox(s);\n+        wrd1(s, \"->\");\n+        print_type(s, decl.output);\n+        end(s.s);\n+    }\n }\n \n impure fn print_type_params(ps s, vec[ast.ty_param] params) {\n-  if (_vec.len[ast.ty_param](params) > 0u) {\n-    wrd(s, \"[\");\n-    impure fn printParam(ps s, &ast.ty_param param) {wrd(s, param.ident);}\n-    auto f = printParam;\n-    commasep[ast.ty_param](s, params, f);\n-    wrd(s, \"]\");\n-  }\n+    if (_vec.len[ast.ty_param](params) > 0u) {\n+        wrd(s.s, \"[\");\n+        impure fn printParam(ps s, &ast.ty_param param) {\n+            wrd(s.s, param.ident);\n+        }\n+        auto f = printParam;\n+        commasep[ast.ty_param](s, params, f);\n+        wrd(s.s, \"]\");\n+    }\n }\n \n impure fn print_view_item(ps s, @ast.view_item item) {\n-  hbox(s);\n-  alt (item.node) {\n-    case (ast.view_item_use(?id,?mta,_,_)) {\n-      wrd1(s, \"use\");\n-      wrd(s, id);\n-      if (_vec.len[@ast.meta_item](mta) > 0u) {\n-        popen(s);\n-        impure fn print_meta(ps s, &@ast.meta_item item) {\n-          hbox(s);\n-          wrd1(s, item.node.name);\n-          wrd1(s, \"=\");\n-          print_string(s, item.node.value);\n-          end(s);\n-        }\n-        auto f = print_meta;\n-        commasep[@ast.meta_item](s, mta, f);\n-        pclose(s);\n-      }\n-    }\n-    case (ast.view_item_import(?id,?ids,_,_)) {\n-      wrd1(s, \"import\");\n-      if (!_str.eq(id, ids.(_vec.len[str](ids)-1u))) {\n-        wrd1(s, id);\n-        wrd1(s, \"=\");\n-      }\n-      auto first = true;\n-      for (str elt in ids) {\n-        if (first) {first = false;}\n-        else {wrd(s, \".\");}\n-        wrd(s, elt);\n-      }\n-    }\n-    case (ast.view_item_export(?id)) {\n-      wrd1(s, \"export\");\n-      wrd(s, id);\n+    maybe_print_comment(s, item.span.lo);\n+    hbox(s);\n+    alt (item.node) {\n+        case (ast.view_item_use(?id,?mta,_,_)) {\n+            wrd1(s, \"use\");\n+            wrd(s.s, id);\n+            if (_vec.len[@ast.meta_item](mta) > 0u) {\n+                popen(s);\n+                impure fn print_meta(ps s, &@ast.meta_item item) {\n+                    hbox(s);\n+                    wrd1(s, item.node.name);\n+                    wrd1(s, \"=\");\n+                    print_string(s, item.node.value);\n+                    end(s.s);\n+                }\n+                auto f = print_meta;\n+                commasep[@ast.meta_item](s, mta, f);\n+                pclose(s);\n+            }\n+        }\n+        case (ast.view_item_import(?id,?ids,_,_)) {\n+            wrd1(s, \"import\");\n+            if (!_str.eq(id, ids.(_vec.len[str](ids)-1u))) {\n+                wrd1(s, id);\n+                wrd1(s, \"=\");\n+            }\n+            auto first = true;\n+            for (str elt in ids) {\n+                if (first) {first = false;}\n+                else {wrd(s.s, \".\");}\n+                wrd(s.s, elt);\n+            }\n+        }\n+        case (ast.view_item_export(?id)) {\n+            wrd1(s, \"export\");\n+            wrd(s.s, id);\n+        }\n     }\n-  }\n-  end(s);\n-  wrd(s, \";\");\n-  line(s);\n+    end(s.s);\n+    wrd(s.s, \";\");\n+    line(s.s);\n }\n \n // FIXME: The fact that this builds up the table anew for every call is\n // not good. Eventually, table should be a const.\n fn operator_prec(ast.binop op) -> int {\n-  for (front.parser.op_spec spec in front.parser.prec_table()) {\n-    if (spec.op == op) {ret spec.prec;}\n-  }\n-  fail;\n+    for (front.parser.op_spec spec in front.parser.prec_table()) {\n+        if (spec.op == op) {ret spec.prec;}\n+    }\n+    fail;\n }\n \n impure fn print_maybe_parens(ps s, @ast.expr expr, int outer_prec) {\n-  auto add_them;\n-  alt (expr.node) {\n-    case (ast.expr_binary(?op,_,_,_)) {\n-      add_them = operator_prec(op) < outer_prec;\n-    }\n-    case (ast.expr_cast(_,_,_)) {\n-      add_them = as_prec < outer_prec;\n-    }\n-    case (_) {\n-      add_them = false;\n+    auto add_them;\n+    alt (expr.node) {\n+        case (ast.expr_binary(?op,_,_,_)) {\n+            add_them = operator_prec(op) < outer_prec;\n+        }\n+        case (ast.expr_cast(_,_,_)) {\n+            add_them = as_prec < outer_prec;\n+        }\n+        case (_) {\n+            add_them = false;\n+        }\n     }\n-  }\n-  if (add_them) {popen(s);}\n-  print_expr(s, expr);\n-  if (add_them) {pclose(s);}\n+    if (add_them) {popen(s);}\n+    print_expr(s, expr);\n+    if (add_them) {pclose(s);}\n }\n \n fn escape_str(str st, char to_escape) -> str {\n-  let str out = \"\";\n-  auto len = _str.byte_len(st);\n-  auto i = 0u;\n-  while (i < len) {\n-    alt (st.(i) as char) {\n-      case ('\\n') {out += \"\\\\n\";}\n-      case ('\\t') {out += \"\\\\t\";}\n-      case ('\\r') {out += \"\\\\r\";}\n-      case ('\\\\') {out += \"\\\\\\\\\";}\n-      case (?cur) {\n-        if (cur == to_escape) {out += \"\\\\\";}\n-        _str.push_byte(out, cur as u8);\n-      }\n+    let str out = \"\";\n+    auto len = _str.byte_len(st);\n+    auto i = 0u;\n+    while (i < len) {\n+        alt (st.(i) as char) {\n+            case ('\\n') {out += \"\\\\n\";}\n+            case ('\\t') {out += \"\\\\t\";}\n+            case ('\\r') {out += \"\\\\r\";}\n+            case ('\\\\') {out += \"\\\\\\\\\";}\n+            case (?cur) {\n+                if (cur == to_escape) {out += \"\\\\\";}\n+                _str.push_byte(out, cur as u8);\n+            }\n+        }\n+        i += 1u;\n     }\n-    i += 1u;\n-  }\n-  ret out;\n+    ret out;\n+}\n+\n+impure fn print_mt(ps s, &ast.mt mt) {\n+    alt (mt.mut) {\n+        case (ast.mut)       { wrd1(s, \"mutable\");  }\n+        case (ast.maybe_mut) { wrd1(s, \"mutable?\"); }\n+        case (ast.imm)       { /* nothing */        }\n+    }\n+    print_type(s, mt.ty);\n }\n \n impure fn print_string(ps s, str st) {\n-  wrd(s, \"\\\"\"); wrd(s, escape_str(st, '\"')); wrd(s, \"\\\"\");\n+    wrd(s.s, \"\\\"\"); wrd(s.s, escape_str(st, '\"')); wrd(s.s, \"\\\"\");\n }\n \n impure fn print_ty_fn(ps s, ast.proto proto, option.t[str] id,\n                       vec[ast.ty_arg] inputs, @ast.ty output) {\n-  if (proto == ast.proto_fn) {wrd(s, \"fn\");}\n-  else {wrd(s, \"iter\");}\n-  alt (id) {\n-    case (option.some[str](?id)) {space(s); wrd(s, id);}\n-    case (_) {}\n-  }\n-  popen(s);\n-  impure fn print_arg(ps s, &ast.ty_arg input) {\n-    if (middle.ty.mode_is_alias(input.mode)) {wrd(s, \"&\");}\n-    print_type(s, input.ty);\n-  }\n-  auto f = print_arg;\n-  commasep[ast.ty_arg](s, inputs, f);\n-  pclose(s);\n-  if (output.node != ast.ty_nil) {\n-    space(s);\n-    hbox(s);\n-    wrd1(s, \"->\");\n-    print_type(s, output);\n-    end(s);\n-  }\n+    if (proto == ast.proto_fn) {wrd(s.s, \"fn\");}\n+    else {wrd(s.s, \"iter\");}\n+    alt (id) {\n+        case (option.some[str](?id)) {space(s.s); wrd(s.s, id);}\n+        case (_) {}\n+    }\n+    popen_h(s);\n+    impure fn print_arg(ps s, &ast.ty_arg input) {\n+        if (middle.ty.mode_is_alias(input.mode)) {wrd(s.s, \"&\");}\n+        print_type(s, input.ty);\n+    }\n+    auto f = print_arg;\n+    commasep[ast.ty_arg](s, inputs, f);\n+    pclose(s);\n+    maybe_print_comment(s, output.span.lo);\n+    if (output.node != ast.ty_nil) {\n+        space(s.s);\n+        hbox(s);\n+        wrd1(s, \"->\");\n+        print_type(s, output);\n+        end(s.s);\n+    }\n+}\n+\n+fn next_comment(ps s) -> option.t[lexer.cmnt] {\n+    alt (s.comments) {\n+        case (option.some[vec[lexer.cmnt]](?cmnts)) {\n+            if (s.cur_cmnt < _vec.len[lexer.cmnt](cmnts)) {\n+                ret option.some[lexer.cmnt](cmnts.(s.cur_cmnt));\n+            } else {ret option.none[lexer.cmnt];}\n+        }\n+        case (_) {ret option.none[lexer.cmnt];}\n+    }\n+}\n+\n+impure fn maybe_print_comment(ps s, util.common.pos pos) {\n+    while (true) {\n+        alt (next_comment(s)) {\n+            case (option.some[lexer.cmnt](?cmnt)) {\n+                if (cmnt.pos.line < pos.line ||\n+                    (cmnt.pos.line == pos.line && cmnt.pos.col < pos.col)) {\n+                    print_comment(s, cmnt.val);\n+                    if (cmnt.space_after) {line(s.s);}\n+                    s.cur_cmnt += 1u;\n+                } else { break; }\n+            }\n+            case (_) {break;}\n+        }\n+    }\n+}\n+\n+impure fn maybe_print_stmt_comment(ps s, util.common.span span) -> bool {\n+    alt (next_comment(s)) {\n+        case (option.some[lexer.cmnt](?cmnt)) {\n+            if (span.hi.line == cmnt.pos.line) {\n+                wrd(s.s, \" \");\n+                print_comment(s, cmnt.val);\n+                s.cur_cmnt += 1u;\n+                ret true;\n+            }\n+        }\n+        case (_) {}\n+    }\n+    ret false;\n+}\n+\n+impure fn print_remaining_comments(ps s) {\n+    while (true) {\n+        alt (next_comment(s)) {\n+            case (option.some[lexer.cmnt](?cmnt)) {\n+                print_comment(s, cmnt.val);\n+                if (cmnt.space_after) {line(s.s);}\n+                s.cur_cmnt += 1u;\n+            }\n+            case (_) {break;}\n+        }\n+    }\n+}\n+\n+impure fn print_comment(ps s, lexer.cmnt_ cmnt) {\n+    alt (cmnt) {\n+        case (lexer.cmnt_line(?val)) {\n+            wrd(s.s, \"// \" + val);\n+            pp.hardbreak(s.s);\n+        }\n+        case (lexer.cmnt_block(?lines)) {\n+            pp.abox(s.s);\n+            wrd(s.s, \"/* \");\n+            pp.abox(s.s);\n+            auto first = true;\n+            for (str ln in lines) {\n+                if (first) {first = false;}\n+                else {pp.hardbreak(s.s);}\n+                wrd(s.s, ln);\n+            }\n+            end(s.s);\n+            wrd(s.s, \"*/\");\n+            end(s.s);\n+            line(s.s);\n+        }\n+    }\n }"}]}