{"sha": "7b9a65ea6a3d699c2b43b7c7896307c0475a1ada", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiOWE2NWVhNmEzZDY5OWMyYjQzYjdjNzg5NjMwN2MwNDc1YTFhZGE=", "commit": {"author": {"name": "Taiki Endo", "email": "te316e89@gmail.com", "date": "2019-05-29T08:37:28Z"}, "committer": {"name": "Taiki Endo", "email": "te316e89@gmail.com", "date": "2019-07-27T03:28:03Z"}, "message": "Make is_self_ty a method on SelfVisitor", "tree": {"sha": "9f3a583ffcc337243324d1dad96309c7cb5b7718", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f3a583ffcc337243324d1dad96309c7cb5b7718"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b9a65ea6a3d699c2b43b7c7896307c0475a1ada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b9a65ea6a3d699c2b43b7c7896307c0475a1ada", "html_url": "https://github.com/rust-lang/rust/commit/7b9a65ea6a3d699c2b43b7c7896307c0475a1ada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b9a65ea6a3d699c2b43b7c7896307c0475a1ada/comments", "author": {"login": "taiki-e", "id": 43724913, "node_id": "MDQ6VXNlcjQzNzI0OTEz", "avatar_url": "https://avatars.githubusercontent.com/u/43724913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/taiki-e", "html_url": "https://github.com/taiki-e", "followers_url": "https://api.github.com/users/taiki-e/followers", "following_url": "https://api.github.com/users/taiki-e/following{/other_user}", "gists_url": "https://api.github.com/users/taiki-e/gists{/gist_id}", "starred_url": "https://api.github.com/users/taiki-e/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/taiki-e/subscriptions", "organizations_url": "https://api.github.com/users/taiki-e/orgs", "repos_url": "https://api.github.com/users/taiki-e/repos", "events_url": "https://api.github.com/users/taiki-e/events{/privacy}", "received_events_url": "https://api.github.com/users/taiki-e/received_events", "type": "User", "site_admin": false}, "committer": {"login": "taiki-e", "id": 43724913, "node_id": "MDQ6VXNlcjQzNzI0OTEz", "avatar_url": "https://avatars.githubusercontent.com/u/43724913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/taiki-e", "html_url": "https://github.com/taiki-e", "followers_url": "https://api.github.com/users/taiki-e/followers", "following_url": "https://api.github.com/users/taiki-e/following{/other_user}", "gists_url": "https://api.github.com/users/taiki-e/gists{/gist_id}", "starred_url": "https://api.github.com/users/taiki-e/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/taiki-e/subscriptions", "organizations_url": "https://api.github.com/users/taiki-e/orgs", "repos_url": "https://api.github.com/users/taiki-e/repos", "events_url": "https://api.github.com/users/taiki-e/events{/privacy}", "received_events_url": "https://api.github.com/users/taiki-e/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1fd4fa848a11698b9a21bc937f5846dff87920e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1fd4fa848a11698b9a21bc937f5846dff87920e", "html_url": "https://github.com/rust-lang/rust/commit/a1fd4fa848a11698b9a21bc937f5846dff87920e"}], "stats": {"total": 67, "additions": 35, "deletions": 32}, "files": [{"sha": "d7dd0656cb8960889657d1740b6431dc925dcdea", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7b9a65ea6a3d699c2b43b7c7896307c0475a1ada/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9a65ea6a3d699c2b43b7c7896307c0475a1ada/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7b9a65ea6a3d699c2b43b7c7896307c0475a1ada", "patch": "@@ -2146,41 +2146,44 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // First (determined here), if `self` is by-reference, then the\n         // implied output region is the region of the self parameter.\n         if has_self {\n-            // Look for `self: &'a Self` - also desugared from `&'a self`,\n-            // and if that matches, use it for elision and return early.\n-            let is_self_ty = |res: Res| {\n-                if let Res::SelfTy(..) = res {\n-                    return true;\n-                }\n-\n-                // Can't always rely on literal (or implied) `Self` due\n-                // to the way elision rules were originally specified.\n-                let impl_self = impl_self.map(|ty| &ty.node);\n-                if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) = impl_self {\n-                    match path.res {\n-                        // Whitelist the types that unambiguously always\n-                        // result in the same type constructor being used\n-                        // (it can't differ between `Self` and `self`).\n-                        Res::Def(DefKind::Struct, _)\n-                        | Res::Def(DefKind::Union, _)\n-                        | Res::Def(DefKind::Enum, _)\n-                        | Res::PrimTy(_) => {\n-                            return res == path.res\n-                        }\n-                        _ => {}\n+            struct SelfVisitor<'a> {\n+                map: &'a NamedRegionMap,\n+                impl_self: Option<&'a hir::TyKind>,\n+                lifetime: Option<Region>,\n+            }\n+\n+            impl SelfVisitor<'_> {\n+                // Look for `self: &'a Self` - also desugared from `&'a self`,\n+                // and if that matches, use it for elision and return early.\n+                fn is_self_ty(&self, res: Res) -> bool {\n+                    if let Res::SelfTy(..) = res {\n+                        return true;\n                     }\n-                }\n \n-                false\n-            };\n+                    // Can't always rely on literal (or implied) `Self` due\n+                    // to the way elision rules were originally specified.\n+                    if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) =\n+                        self.impl_self\n+                    {\n+                        match path.res {\n+                            // Whitelist the types that unambiguously always\n+                            // result in the same type constructor being used\n+                            // (it can't differ between `Self` and `self`).\n+                            Res::Def(DefKind::Struct, _)\n+                            | Res::Def(DefKind::Union, _)\n+                            | Res::Def(DefKind::Enum, _)\n+                            | Res::PrimTy(_) => {\n+                                return res == path.res\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n \n-            struct SelfVisitor<'a, F: FnMut(Res) -> bool> {\n-                is_self_ty: F,\n-                map: &'a NamedRegionMap,\n-                lifetime: Option<Region>,\n+                    false\n+                }\n             }\n \n-            impl<'a, F: FnMut(Res) -> bool> Visitor<'a> for SelfVisitor<'a, F> {\n+            impl<'a> Visitor<'a> for SelfVisitor<'a> {\n                 fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'a> {\n                     NestedVisitorMap::None\n                 }\n@@ -2189,7 +2192,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.node {\n                         if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node\n                         {\n-                            if (self.is_self_ty)(path.res) {\n+                            if self.is_self_ty(path.res) {\n                                 self.lifetime = self.map.defs.get(&lifetime_ref.hir_id).copied();\n                                 return;\n                             }\n@@ -2200,8 +2203,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             let mut visitor = SelfVisitor {\n-                is_self_ty,\n                 map: self.map,\n+                impl_self: impl_self.map(|ty| &ty.node),\n                 lifetime: None,\n             };\n             visitor.visit_ty(&inputs[0]);"}]}