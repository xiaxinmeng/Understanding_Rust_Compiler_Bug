{"sha": "a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MjZhYTEzOWVjMWM5NWNiYWQ0YzFkMzE4N2M0MzdlYjQ1ZDRiYWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-07T18:37:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-17T02:46:01Z"}, "message": "Implement named pipes for windows, touch up unix\n\n* Implementation of pipe_win32 filled out for libnative\n* Reorganize pipes to be clone-able\n* Fix a few file descriptor leaks on error\n* Factor out some common code into shared functions\n* Make use of the if_ok!() macro for less indentation\n\nCloses #11201", "tree": {"sha": "6a0092a8ac88e5842f00b74df7314faa9074de04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a0092a8ac88e5842f00b74df7314faa9074de04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "comment_count": 17, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "html_url": "https://github.com/rust-lang/rust/commit/a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94b2d9dc4dd864b481bcf279921bc7ea796355e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/94b2d9dc4dd864b481bcf279921bc7ea796355e5", "html_url": "https://github.com/rust-lang/rust/commit/94b2d9dc4dd864b481bcf279921bc7ea796355e5"}], "stats": {"total": 1068, "additions": 780, "deletions": 288}, "files": [{"sha": "0f9439b3eb5b83f32c77d6edc6caa6ee3eef1368", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "patch": "@@ -61,11 +61,11 @@ pub mod timer;\n pub mod timer;\n \n #[cfg(unix)]\n-#[path = \"path_unix.rs\"]\n+#[path = \"pipe_unix.rs\"]\n pub mod pipe;\n \n #[cfg(windows)]\n-#[path = \"path_win32.rs\"]\n+#[path = \"pipe_win32.rs\"]\n pub mod pipe;\n \n mod timer_helper;\n@@ -85,6 +85,9 @@ fn translate_error(errno: i32, detail: bool) -> IoError {\n     fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n         match errno {\n             libc::EOF => (io::EndOfFile, \"end of file\"),\n+            libc::ERROR_NO_DATA => (io::BrokenPipe, \"the pipe is being closed\"),\n+            libc::ERROR_FILE_NOT_FOUND => (io::FileNotFound, \"file not found\"),\n+            libc::ERROR_INVALID_NAME => (io::InvalidInput, \"invalid file name\"),\n             libc::WSAECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n             libc::WSAECONNRESET => (io::ConnectionReset, \"connection reset\"),\n             libc::WSAEACCES => (io::PermissionDenied, \"permission denied\"),\n@@ -94,6 +97,7 @@ fn translate_error(errno: i32, detail: bool) -> IoError {\n             libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n             libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n             libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n+            libc::ERROR_BROKEN_PIPE => (io::BrokenPipe, \"the pipe has ended\"),\n \n             x => {\n                 debug!(\"ignoring {}: {}\", x, os::last_os_error());\n@@ -116,6 +120,7 @@ fn translate_error(errno: i32, detail: bool) -> IoError {\n             libc::ECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n             libc::EADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n             libc::EADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n+            libc::ENOENT => (io::FileNotFound, \"no such file or directory\"),\n \n             // These two constants can have the same value on some systems, but\n             // different values on others, so we can't use a match clause"}, {"sha": "b33b54862dc2bcb0679da957246f536882850010", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::c_str::CString;\n use std::cast;\n use std::io::net::ip;\n use std::io;\n use std::libc;\n use std::mem;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n-use std::unstable::intrinsics;\n \n use super::{IoResult, retry};\n use super::file::keep_going;\n@@ -90,30 +88,6 @@ fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     }\n }\n \n-fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint)> {\n-    // the sun_path length is limited to SUN_LEN (with null)\n-    if addr.len() > libc::sun_len -1 {\n-        return Err(io::IoError {\n-            kind: io::OtherIoError,\n-            desc: \"path must be smaller than SUN_LEN\",\n-            detail: None,\n-        })\n-    }\n-    unsafe {\n-        let storage: libc::sockaddr_storage = intrinsics::init();\n-        let s: *mut libc::sockaddr_un = cast::transmute(&storage);\n-        (*s).sun_family = libc::AF_UNIX as libc::sa_family_t;\n-        let mut i = 0;\n-        for c in addr.iter() {\n-          (*s).sun_path[i] = c;\n-          i += 1;\n-        }\n-\n-        let len = mem::size_of::<libc::sa_family_t>() + i + 1; //count the null terminator\n-        return Ok((storage, len));\n-    }\n-}\n-\n fn socket(addr: ip::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n     unsafe {\n         let fam = match addr.ip {\n@@ -127,15 +101,6 @@ fn socket(addr: ip::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n     }\n }\n \n-fn unix_socket(ty: libc::c_int) -> IoResult<sock_t> {\n-    unsafe {\n-        match libc::socket(libc::AF_UNIX, ty, 0) {\n-            -1 => Err(super::last_error()),\n-            fd => Ok(fd)\n-        }\n-    }\n-}\n-\n fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n                  payload: T) -> IoResult<()> {\n     unsafe {\n@@ -228,24 +193,6 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n     }\n }\n \n-fn sockaddr_to_unix(storage: &libc::sockaddr_storage,\n-                    len: uint) -> IoResult<CString> {\n-    match storage.ss_family as libc::c_int {\n-        libc::AF_UNIX => {\n-            assert!(len as uint <= mem::size_of::<libc::sockaddr_un>());\n-            let storage: &libc::sockaddr_un = unsafe {\n-                cast::transmute(storage)\n-            };\n-            unsafe {\n-                Ok(CString::new(storage.sun_path.to_owned().as_ptr(), false))\n-            }\n-        }\n-        _ => {\n-            Err(io::standard_error(io::OtherIoError))\n-        }\n-    }\n-}\n-\n #[cfg(unix)]\n pub fn init() {}\n "}, {"sha": "a6d75d93d676163ef9c35652528f06337ddde0cb", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 167, "deletions": 182, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "patch": "@@ -8,46 +8,124 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::c_str::CString;\n+use std::cast;\n+use std::io;\n+use std::libc;\n+use std::mem;\n+use std::rt::rtio;\n+use std::sync::arc::UnsafeArc;\n+use std::unstable::intrinsics;\n+\n+use super::{IoResult, retry};\n+use super::file::{keep_going, fd_t};\n+\n+fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n+    match unsafe { libc::socket(libc::AF_UNIX, ty, 0) } {\n+        -1 => Err(super::last_error()),\n+        fd => Ok(fd)\n+    }\n+}\n+\n+fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint)> {\n+    // the sun_path length is limited to SUN_LEN (with null)\n+    assert!(mem::size_of::<libc::sockaddr_storage>() >=\n+            mem::size_of::<libc::sockaddr_un>());\n+    let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+    let s: &mut libc::sockaddr_un = unsafe { cast::transmute(&mut storage) };\n+\n+    let len = addr.len();\n+    if len > s.sun_path.len() - 1 {\n+        return Err(io::IoError {\n+            kind: io::InvalidInput,\n+            desc: \"path must be smaller than SUN_LEN\",\n+            detail: None,\n+        })\n+    }\n+    s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n+    for (slot, value) in s.sun_path.mut_iter().zip(addr.iter()) {\n+        *slot = value;\n+    }\n+\n+    // count the null terminator\n+    let len = mem::size_of::<libc::sa_family_t>() + len + 1;\n+    return Ok((storage, len));\n+}\n+\n+fn sockaddr_to_unix(storage: &libc::sockaddr_storage,\n+                    len: uint) -> IoResult<CString> {\n+    match storage.ss_family as libc::c_int {\n+        libc::AF_UNIX => {\n+            assert!(len as uint <= mem::size_of::<libc::sockaddr_un>());\n+            let storage: &libc::sockaddr_un = unsafe {\n+                cast::transmute(storage)\n+            };\n+            unsafe {\n+                Ok(CString::new(storage.sun_path.as_ptr(), false).clone())\n+            }\n+        }\n+        _ => Err(io::standard_error(io::InvalidInput))\n+    }\n+}\n+\n+struct Inner {\n+    fd: fd_t,\n+}\n+\n+impl Drop for Inner {\n+    fn drop(&mut self) { unsafe { let _ = libc::close(self.fd); } }\n+}\n+\n+fn connect(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n+    let (addr, len) = if_ok!(addr_to_sockaddr_un(addr));\n+    let inner = Inner { fd: if_ok!(unix_socket(ty)) };\n+    let addrp = &addr as *libc::sockaddr_storage;\n+    match retry(|| unsafe {\n+        libc::connect(inner.fd, addrp as *libc::sockaddr,\n+                      len as libc::socklen_t)\n+    }) {\n+        -1 => Err(super::last_error()),\n+        _  => Ok(inner)\n+    }\n+}\n+\n+fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n+    let (addr, len) = if_ok!(addr_to_sockaddr_un(addr));\n+    let inner = Inner { fd: if_ok!(unix_socket(ty)) };\n+    let addrp = &addr as *libc::sockaddr_storage;\n+    match unsafe {\n+        libc::bind(inner.fd, addrp as *libc::sockaddr, len as libc::socklen_t)\n+    } {\n+        -1 => Err(super::last_error()),\n+        _  => Ok(inner)\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n-// Unix\n+// Unix Streams\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct UnixStream {\n-    priv fd: sock_t,\n+    priv inner: UnsafeArc<Inner>,\n }\n \n impl UnixStream {\n-    pub fn connect(addr: &CString, ty: libc::c_int) -> IoResult<UnixStream> {\n-        unix_socket(ty).and_then(|fd| {\n-            match addr_to_sockaddr_un(addr) {\n-                Err(e)          => return Err(e),\n-                Ok((addr, len)) => {\n-                    let ret = UnixStream{ fd: fd };\n-                    let addrp = &addr as *libc::sockaddr_storage;\n-                    match retry(|| {\n-                      libc::connect(fd, addrp as *libc::sockaddr,\n-                                     len as libc::socklen_t)\n-                    }) {\n-                        -1 => return Err(super::last_error()),\n-                        _  => return Ok(ret)\n-                    }\n-                }\n-            }\n+    pub fn connect(addr: &CString) -> IoResult<UnixStream> {\n+        connect(addr, libc::SOCK_STREAM).map(|inner| {\n+            UnixStream { inner: UnsafeArc::new(inner) }\n         })\n     }\n \n-    pub fn fd(&self) -> sock_t { self.fd }\n+    fn fd(&self) -> fd_t { unsafe { (*self.inner.get()).fd } }\n }\n \n impl rtio::RtioPipe for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| {\n-            unsafe {\n-                libc::recv(self.fd,\n-                           buf.as_ptr() as *mut libc::c_void,\n-                           buf.len() as wrlen,\n-                           0) as libc::c_int\n-            }\n+        let ret = retry(|| unsafe {\n+            libc::recv(self.fd(),\n+                       buf.as_ptr() as *mut libc::c_void,\n+                       buf.len() as libc::size_t,\n+                       0) as libc::c_int\n         });\n         if ret == 0 {\n             Err(io::standard_error(io::EndOfFile))\n@@ -57,202 +135,114 @@ impl rtio::RtioPipe for UnixStream {\n             Ok(ret as uint)\n         }\n     }\n+\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::send(self.fd,\n-                           buf as *mut libc::c_void,\n-                           len as wrlen,\n-                           0) as i64\n-            }\n+        let ret = keep_going(buf, |buf, len| unsafe {\n+            libc::send(self.fd(),\n+                       buf as *mut libc::c_void,\n+                       len as libc::size_t,\n+                       0) as i64\n         });\n         if ret < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(())\n         }\n     }\n-}\n \n-impl Drop for UnixStream {\n-    fn drop(&mut self) { unsafe { close(self.fd); } }\n+    fn clone(&self) -> ~rtio::RtioPipe {\n+        ~UnixStream { inner: self.inner.clone() } as ~rtio::RtioPipe\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n // Unix Datagram\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct UnixDatagram {\n-    priv fd: sock_t,\n+    priv inner: UnsafeArc<Inner>,\n }\n \n impl UnixDatagram {\n-    pub fn connect(addr: &CString, ty: libc::c_int) -> IoResult<UnixDatagram> {\n-        unsafe {\n-            unix_socket(ty).and_then(|fd| {\n-                match addr_to_sockaddr_un(addr) {\n-                    Err(e)          => return Err(e),\n-                    Ok((addr, len)) => {\n-                        let ret = UnixDatagram{ fd: fd };\n-                        let addrp = &addr as *libc::sockaddr_storage;\n-                        match retry(|| {\n-                          libc::connect(fd, addrp as *libc::sockaddr,\n-                                         len as libc::socklen_t)\n-                        }) {\n-                            -1 => return Err(super::last_error()),\n-                            _  => return Ok(ret)\n-                        }\n-                    }\n-                }\n-            })\n-        }\n+    pub fn connect(addr: &CString) -> IoResult<UnixDatagram> {\n+        connect(addr, libc::SOCK_DGRAM).map(|inner| {\n+            UnixDatagram { inner: UnsafeArc::new(inner) }\n+        })\n     }\n \n     pub fn bind(addr: &CString) -> IoResult<UnixDatagram> {\n-        unsafe {\n-            unix_socket(libc::SOCK_DGRAM).and_then(|fd| {\n-                match addr_to_sockaddr_un(addr) {\n-                    Err(e)          => return Err(e),\n-                    Ok((addr, len)) => {\n-                        let ret = UnixDatagram{ fd: fd };\n-                        let addrp = &addr as *libc::sockaddr_storage;\n-                        match libc::bind(fd, addrp as *libc::sockaddr,\n-                                         len as libc::socklen_t) {\n-                            -1 => return Err(super::last_error()),\n-                            _  => return Ok(ret)\n-                        }\n-                    }\n-                }\n-            })\n-        }\n+        bind(addr, libc::SOCK_DGRAM).map(|inner| {\n+            UnixDatagram { inner: UnsafeArc::new(inner) }\n+        })\n     }\n \n-    pub fn fd(&self) -> sock_t { self.fd }\n-}\n+    fn fd(&self) -> fd_t { unsafe { (*self.inner.get()).fd } }\n \n-impl rtio::RtioPipe for UnixDatagram {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| {\n-            unsafe {\n-                libc::recv(self.fd,\n+    pub fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, CString)> {\n+        let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+        let storagep = &mut storage as *mut libc::sockaddr_storage;\n+        let mut addrlen: libc::socklen_t =\n+                mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n+        let ret = retry(|| unsafe {\n+            libc::recvfrom(self.fd(),\n                            buf.as_ptr() as *mut libc::c_void,\n-                           buf.len() as wrlen,\n-                           0) as libc::c_int\n-            }\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::send(self.fd,\n-                           buf as *mut libc::c_void,\n-                           len as wrlen,\n-                           0) as i64\n-            }\n+                           buf.len() as libc::size_t,\n+                           0,\n+                           storagep as *mut libc::sockaddr,\n+                           &mut addrlen) as libc::c_int\n         });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n+        if ret < 0 { return Err(super::last_error()) }\n+        sockaddr_to_unix(&storage, addrlen as uint).and_then(|addr| {\n+            Ok((ret as uint, addr))\n+        })\n     }\n-}\n \n-impl rtio::RtioDatagramPipe for UnixDatagram {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, CString)> {\n-        unsafe {\n-            let mut storage: libc::sockaddr_storage = intrinsics::init();\n-            let storagep = &mut storage as *mut libc::sockaddr_storage;\n-            let mut addrlen: libc::socklen_t =\n-                    mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-            let ret = retry(|| {\n-                libc::recvfrom(self.fd,\n-                               buf.as_ptr() as *mut libc::c_void,\n-                               buf.len() as msglen_t,\n-                               0,\n-                               storagep as *mut libc::sockaddr,\n-                               &mut addrlen) as libc::c_int\n-            });\n-            if ret < 0 { return Err(super::last_error()) }\n-            sockaddr_to_unix(&storage, addrlen as uint).and_then(|addr| {\n-                Ok((ret as uint, addr))\n-            })\n+    pub fn sendto(&mut self, buf: &[u8], dst: &CString) -> IoResult<()> {\n+        let (dst, len) = if_ok!(addr_to_sockaddr_un(dst));\n+        let dstp = &dst as *libc::sockaddr_storage;\n+        let ret = retry(|| unsafe {\n+            libc::sendto(self.fd(),\n+                         buf.as_ptr() as *libc::c_void,\n+                         buf.len() as libc::size_t,\n+                         0,\n+                         dstp as *libc::sockaddr,\n+                         len as libc::socklen_t) as libc::c_int\n+        });\n+        match ret {\n+            -1 => Err(super::last_error()),\n+            n if n as uint != buf.len() => {\n+                Err(io::IoError {\n+                    kind: io::OtherIoError,\n+                    desc: \"couldn't send entire packet at once\",\n+                    detail: None,\n+                })\n+            }\n+            _ => Ok(())\n         }\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: &CString) -> IoResult<()> {\n-        match addr_to_sockaddr_un(dst) {\n-            Err(e)         => Err(e),\n-            Ok((dst, len)) => {\n-                let dstp = &dst as *libc::sockaddr_storage;\n-                unsafe {\n-                    let ret = retry(|| {\n-                        libc::sendto(self.fd,\n-                                     buf.as_ptr() as *libc::c_void,\n-                                     buf.len() as msglen_t,\n-                                     0,\n-                                     dstp as *libc::sockaddr,\n-                                     len as libc::socklen_t) as libc::c_int\n-                    });\n-                    match ret {\n-                        -1 => Err(super::last_error()),\n-                        n if n as uint != buf.len() => {\n-                            Err(io::IoError {\n-                                kind: io::OtherIoError,\n-                                desc: \"couldn't send entire packet at once\",\n-                                detail: None,\n-                            })\n-                        }\n-                        _ => Ok(())\n-                    }\n-                }\n-            }\n-        }\n+    pub fn clone(&mut self) -> UnixDatagram {\n+        UnixDatagram { inner: self.inner.clone() }\n     }\n }\n \n-impl Drop for UnixDatagram {\n-    fn drop(&mut self) { unsafe { close(self.fd); } }\n-}\n ////////////////////////////////////////////////////////////////////////////////\n // Unix Listener\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct UnixListener {\n-    priv fd: sock_t,\n+    priv inner: Inner,\n }\n \n impl UnixListener {\n     pub fn bind(addr: &CString) -> IoResult<UnixListener> {\n-        unsafe {\n-            unix_socket(libc::SOCK_STREAM).and_then(|fd| {\n-                match addr_to_sockaddr_un(addr) {\n-                    Err(e)          => return Err(e),\n-                    Ok((addr, len)) => {\n-                        let ret = UnixListener{ fd: fd };\n-                        let addrp = &addr as *libc::sockaddr_storage;\n-                        match libc::bind(fd, addrp as *libc::sockaddr,\n-                                         len as libc::socklen_t) {\n-                            -1 => return Err(super::last_error()),\n-                            _  => return Ok(ret)\n-                        }\n-                    }\n-                }\n-            })\n-        }\n+        bind(addr, libc::SOCK_STREAM).map(|fd| UnixListener { inner: fd })\n     }\n \n-    pub fn fd(&self) -> sock_t { self.fd }\n+    fn fd(&self) -> fd_t { self.inner.fd }\n \n     pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> {\n-        match unsafe { libc::listen(self.fd, backlog as libc::c_int) } {\n+        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n             -1 => Err(super::last_error()),\n             _ => Ok(UnixAcceptor { listener: self })\n         }\n@@ -265,16 +255,12 @@ impl rtio::RtioUnixListener for UnixListener {\n     }\n }\n \n-impl Drop for UnixListener {\n-    fn drop(&mut self) { unsafe { close(self.fd); } }\n-}\n-\n pub struct UnixAcceptor {\n     priv listener: UnixListener,\n }\n \n impl UnixAcceptor {\n-    pub fn fd(&self) -> sock_t { self.listener.fd }\n+    fn fd(&self) -> fd_t { self.listener.fd() }\n \n     pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n         let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n@@ -285,9 +271,9 @@ impl UnixAcceptor {\n             libc::accept(self.fd(),\n                          storagep as *mut libc::sockaddr,\n                          &mut size as *mut libc::socklen_t) as libc::c_int\n-        }) as sock_t {\n+        }) {\n             -1 => Err(super::last_error()),\n-            fd => Ok(UnixStream { fd: fd })\n+            fd => Ok(UnixStream { inner: UnsafeArc::new(Inner { fd: fd }) })\n         }\n     }\n }\n@@ -297,4 +283,3 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n         self.native_accept().map(|s| ~s as ~rtio::RtioPipe)\n     }\n }\n-"}, {"sha": "83731cc02a6b6a0d73ad4b0960e8a9f74faa7ef6", "filename": "src/libnative/io/pipe_win32.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "patch": "@@ -0,0 +1,492 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Named pipes implementation for windows\n+//!\n+//! If are unfortunate enough to be reading this code, I would like to first\n+//! apologize. This was my first encounter with windows named pipes, and it\n+//! didn't exactly turn out very cleanly. If you, too, are new to named pipes,\n+//! read on as I'll try to explain some fun things that I ran into.\n+//!\n+//! # Unix pipes vs Named pipes\n+//!\n+//! As with everything else, named pipes on windows are pretty different from\n+//! unix pipes on unix. On unix, you use one \"server pipe\" to accept new client\n+//! pipes. So long as this server pipe is active, new children pipes can\n+//! connect. On windows, you instead have a number of \"server pipes\", and each\n+//! of these server pipes can throughout their lifetime be attached to a client\n+//! or not. Once attached to a client, a server pipe may then disconnect at a\n+//! later date.\n+//!\n+//! # Accepting clients\n+//!\n+//! As with most other I/O interfaces, our Listener/Acceptor/Stream interfaces\n+//! are built around the unix flavors. This means that we have one \"server\n+//! pipe\" to which many clients can connect. In order to make this compatible\n+//! with the windows model, each connected client consumes ownership of a server\n+//! pipe, and then a new server pipe is created for the next client.\n+//!\n+//! Note that the server pipes attached to clients are never given back to the\n+//! listener for recycling. This could possibly be implemented with a channel so\n+//! the listener half can re-use server pipes, but for now I err'd on the simple\n+//! side of things. Each stream accepted by a listener will destroy the server\n+//! pipe after the stream is dropped.\n+//!\n+//! This model ends up having a small race or two, and you can find more details\n+//! on the `native_accept` method.\n+//!\n+//! # Simultaneous reads and writes\n+//!\n+//! In testing, I found that two simultaneous writes and two simultaneous reads\n+//! on a pipe ended up working out just fine, but problems were encountered when\n+//! a read was executed simultaneously with a write. After some googling around,\n+//! it sounded like named pipes just weren't built for this kind of interaction,\n+//! and the suggested solution was to use overlapped I/O.\n+//!\n+//! I don't realy know what overlapped I/O is, but my basic understanding after\n+//! reading about it is that you have an external Event which is used to signal\n+//! I/O completion, passed around in some OVERLAPPED structures. As to what this\n+//! is, I'm not exactly sure.\n+//!\n+//! This problem implies that all named pipes are created with the\n+//! FILE_FLAG_OVERLAPPED option. This means that all of their I/O is\n+//! asynchronous. Each I/O operation has an associated OVERLAPPED structure, and\n+//! inside of this structure is a HANDLE from CreateEvent. After the I/O is\n+//! determined to be pending (may complete in the future), the\n+//! GetOverlappedResult function is used to block on the event, waiting for the\n+//! I/O to finish.\n+//!\n+//! This scheme ended up working well enough. There were two snags that I ran\n+//! into, however:\n+//!\n+//! * Each UnixStream instance needs its own read/write events to wait on. These\n+//!   can't be shared among clones of the same stream because the documentation\n+//!   states that it unsets the event when the I/O is started (would possibly\n+//!   corrupt other events simultaneously waiting). For convenience's sake,\n+//!   these events are lazily initialized.\n+//!\n+//! * Each server pipe needs to be created with FILE_FLAG_OVERLAPPED in addition\n+//!   to all pipes created through `connect`. Notably this means that the\n+//!   ConnectNamedPipe function is nonblocking, implying that the Listener needs\n+//!   to have yet another event to do the actual blocking.\n+//!\n+//! # Conclusion\n+//!\n+//! The conclusion here is that I probably don't know the best way to work with\n+//! windows named pipes, but the solution here seems to work well enough to get\n+//! the test suite passing (the suite is in libstd), and that's good enough for\n+//! me!\n+\n+use std::c_str::CString;\n+use std::libc;\n+use std::os::win32::as_utf16_p;\n+use std::ptr;\n+use std::rt::rtio;\n+use std::sync::arc::UnsafeArc;\n+use std::unstable::intrinsics;\n+\n+use super::IoResult;\n+\n+struct Event(libc::HANDLE);\n+\n+impl Event {\n+    fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> {\n+        let event = unsafe {\n+            libc::CreateEventW(ptr::mut_null(),\n+                               manual_reset as libc::BOOL,\n+                               initial_state as libc::BOOL,\n+                               ptr::null())\n+        };\n+        if event as uint == 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(Event(event))\n+        }\n+    }\n+\n+    fn handle(&self) -> libc::HANDLE { let Event(handle) = *self; handle }\n+}\n+\n+impl Drop for Event {\n+    fn drop(&mut self) {\n+        unsafe { let _ = libc::CloseHandle(self.handle()); }\n+    }\n+}\n+\n+struct Inner {\n+    handle: libc::HANDLE,\n+}\n+\n+impl Drop for Inner {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let _ = libc::FlushFileBuffers(self.handle);\n+            let _ = libc::CloseHandle(self.handle);\n+        }\n+    }\n+}\n+\n+unsafe fn pipe(name: *u16, init: bool) -> libc::HANDLE {\n+    libc::CreateNamedPipeW(\n+        name,\n+        libc::PIPE_ACCESS_DUPLEX |\n+            if init {libc::FILE_FLAG_FIRST_PIPE_INSTANCE} else {0} |\n+            libc::FILE_FLAG_OVERLAPPED,\n+        libc::PIPE_TYPE_BYTE | libc::PIPE_READMODE_BYTE |\n+            libc::PIPE_WAIT,\n+        libc::PIPE_UNLIMITED_INSTANCES,\n+        65536,\n+        65536,\n+        0,\n+        ptr::mut_null()\n+    )\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Unix Streams\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UnixStream {\n+    priv inner: UnsafeArc<Inner>,\n+    priv write: Option<Event>,\n+    priv read: Option<Event>,\n+}\n+\n+impl UnixStream {\n+    fn try_connect(p: *u16) -> Option<libc::HANDLE> {\n+        // Note that most of this is lifted from the libuv implementation.\n+        // The idea is that if we fail to open a pipe in read/write mode\n+        // that we try afterwards in just read or just write\n+        let mut result = unsafe {\n+            libc::CreateFileW(p,\n+                libc::GENERIC_READ | libc::GENERIC_WRITE,\n+                0,\n+                ptr::mut_null(),\n+                libc::OPEN_EXISTING,\n+                libc::FILE_FLAG_OVERLAPPED,\n+                ptr::mut_null())\n+        };\n+        if result != libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n+            return Some(result)\n+        }\n+\n+        let err = unsafe { libc::GetLastError() };\n+        if err == libc::ERROR_ACCESS_DENIED as libc::DWORD {\n+            result = unsafe {\n+                libc::CreateFileW(p,\n+                    libc::GENERIC_READ | libc::FILE_WRITE_ATTRIBUTES,\n+                    0,\n+                    ptr::mut_null(),\n+                    libc::OPEN_EXISTING,\n+                    libc::FILE_FLAG_OVERLAPPED,\n+                    ptr::mut_null())\n+            };\n+            if result != libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n+                return Some(result)\n+            }\n+        }\n+        let err = unsafe { libc::GetLastError() };\n+        if err == libc::ERROR_ACCESS_DENIED as libc::DWORD {\n+            result = unsafe {\n+                libc::CreateFileW(p,\n+                    libc::GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES,\n+                    0,\n+                    ptr::mut_null(),\n+                    libc::OPEN_EXISTING,\n+                    libc::FILE_FLAG_OVERLAPPED,\n+                    ptr::mut_null())\n+            };\n+            if result != libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n+                return Some(result)\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn connect(addr: &CString) -> IoResult<UnixStream> {\n+        as_utf16_p(addr.as_str().unwrap(), |p| {\n+            loop {\n+                match UnixStream::try_connect(p) {\n+                    Some(handle) => {\n+                        let inner = Inner { handle: handle };\n+                        let mut mode = libc::PIPE_TYPE_BYTE |\n+                                       libc::PIPE_READMODE_BYTE |\n+                                       libc::PIPE_WAIT;\n+                        let ret = unsafe {\n+                            libc::SetNamedPipeHandleState(inner.handle,\n+                                                          &mut mode,\n+                                                          ptr::mut_null(),\n+                                                          ptr::mut_null())\n+                        };\n+                        return if ret == 0 {\n+                            Err(super::last_error())\n+                        } else {\n+                            Ok(UnixStream {\n+                                inner: UnsafeArc::new(inner),\n+                                read: None,\n+                                write: None,\n+                            })\n+                        }\n+                    }\n+                    None => {}\n+                }\n+\n+                // On windows, if you fail to connect, you may need to call the\n+                // `WaitNamedPipe` function, and this is indicated with an error\n+                // code of ERROR_PIPE_BUSY.\n+                let code = unsafe { libc::GetLastError() };\n+                if code as int != libc::ERROR_PIPE_BUSY as int {\n+                    return Err(super::last_error())\n+                }\n+\n+                // An example I found on microsoft's website used 20 seconds,\n+                // libuv uses 30 seconds, hence we make the obvious choice of\n+                // waiting for 25 seconds.\n+                if unsafe { libc::WaitNamedPipeW(p, 25000) } == 0 {\n+                    return Err(super::last_error())\n+                }\n+            }\n+        })\n+    }\n+\n+    fn handle(&self) -> libc::HANDLE { unsafe { (*self.inner.get()).handle } }\n+}\n+\n+impl rtio::RtioPipe for UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        if self.read.is_none() {\n+            self.read = Some(if_ok!(Event::new(true, false)));\n+        }\n+\n+        let mut bytes_read = 0;\n+        let mut overlapped: libc::OVERLAPPED = unsafe { intrinsics::init() };\n+        overlapped.hEvent = self.read.get_ref().handle();\n+\n+        let ret = unsafe {\n+            libc::ReadFile(self.handle(),\n+                           buf.as_ptr() as libc::LPVOID,\n+                           buf.len() as libc::DWORD,\n+                           &mut bytes_read,\n+                           &mut overlapped)\n+        };\n+        if ret == 0 {\n+            let err = unsafe { libc::GetLastError() };\n+            if err == libc::ERROR_IO_PENDING as libc::DWORD {\n+                let ret = unsafe {\n+                    libc::GetOverlappedResult(self.handle(),\n+                                              &mut overlapped,\n+                                              &mut bytes_read,\n+                                              libc::TRUE)\n+                };\n+                if ret == 0 {\n+                    return Err(super::last_error())\n+                }\n+            } else {\n+                return Err(super::last_error())\n+            }\n+        }\n+\n+        Ok(bytes_read as uint)\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        if self.write.is_none() {\n+            self.write = Some(if_ok!(Event::new(true, false)));\n+        }\n+\n+        let mut offset = 0;\n+        let mut overlapped: libc::OVERLAPPED = unsafe { intrinsics::init() };\n+        overlapped.hEvent = self.write.get_ref().handle();\n+\n+        while offset < buf.len() {\n+            let mut bytes_written = 0;\n+            let ret = unsafe {\n+                libc::WriteFile(self.handle(),\n+                                buf.slice_from(offset).as_ptr() as libc::LPVOID,\n+                                (buf.len() - offset) as libc::DWORD,\n+                                &mut bytes_written,\n+                                &mut overlapped)\n+            };\n+            if ret == 0 {\n+                let err = unsafe { libc::GetLastError() };\n+                if err == libc::ERROR_IO_PENDING as libc::DWORD {\n+                    let ret = unsafe {\n+                        libc::GetOverlappedResult(self.handle(),\n+                                                  &mut overlapped,\n+                                                  &mut bytes_written,\n+                                                  libc::TRUE)\n+                    };\n+                    if ret == 0 {\n+                        return Err(super::last_error())\n+                    }\n+                } else {\n+                    return Err(super::last_error())\n+                }\n+            }\n+            offset += bytes_written as uint;\n+        }\n+        Ok(())\n+    }\n+\n+    fn clone(&self) -> ~rtio::RtioPipe {\n+        ~UnixStream {\n+            inner: self.inner.clone(),\n+            read: None,\n+            write: None,\n+        } as ~rtio::RtioPipe\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Unix Listener\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UnixListener {\n+    priv handle: libc::HANDLE,\n+    priv name: CString,\n+}\n+\n+impl UnixListener {\n+    pub fn bind(addr: &CString) -> IoResult<UnixListener> {\n+        // Although we technically don't need the pipe until much later, we\n+        // create the initial handle up front to test the validity of the name\n+        // and such.\n+        as_utf16_p(addr.as_str().unwrap(), |p| {\n+            let ret = unsafe { pipe(p, true) };\n+            if ret == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n+                Err(super::last_error())\n+            } else {\n+                Ok(UnixListener { handle: ret, name: addr.clone() })\n+            }\n+        })\n+    }\n+\n+    pub fn native_listen(self) -> IoResult<UnixAcceptor> {\n+        Ok(UnixAcceptor {\n+            listener: self,\n+            event: if_ok!(Event::new(true, false)),\n+        })\n+    }\n+}\n+\n+impl Drop for UnixListener {\n+    fn drop(&mut self) {\n+        unsafe { let _ = libc::CloseHandle(self.handle); }\n+    }\n+}\n+\n+impl rtio::RtioUnixListener for UnixListener {\n+    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor> {\n+        self.native_listen().map(|a| ~a as ~rtio::RtioUnixAcceptor)\n+    }\n+}\n+\n+pub struct UnixAcceptor {\n+    priv listener: UnixListener,\n+    priv event: Event,\n+}\n+\n+impl UnixAcceptor {\n+    pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n+        // This function has some funky implementation details when working with\n+        // unix pipes. On windows, each server named pipe handle can be\n+        // connected to a one or zero clients. To the best of my knowledge, a\n+        // named server is considered active and present if there exists at\n+        // least one server named pipe for it.\n+        //\n+        // The model of this function is to take the current known server\n+        // handle, connect a client to it, and then transfer ownership to the\n+        // UnixStream instance. The next time accept() is invoked, it'll need a\n+        // different server handle to connect a client to.\n+        //\n+        // Note that there is a possible race here. Once our server pipe is\n+        // handed off to a `UnixStream` object, the stream could be closed,\n+        // meaning that there would be no active server pipes, hence even though\n+        // we have a valid `UnixAcceptor`, no one can connect to it. For this\n+        // reason, we generate the next accept call's server pipe at the end of\n+        // this function call.\n+        //\n+        // This provides us an invariant that we always have at least one server\n+        // connection open at a time, meaning that all connects to this acceptor\n+        // should succeed while this is active.\n+        //\n+        // The actual implementation of doing this is a little tricky. Once a\n+        // server pipe is created, a client can connect to it at any time. I\n+        // assume that which server a client connects to is nondeterministic, so\n+        // we also need to guarantee that the only server able to be connected\n+        // to is the one that we're calling ConnectNamedPipe on. This means that\n+        // we have to create the second server pipe *after* we've already\n+        // accepted a connection. In order to at least somewhat gracefully\n+        // handle errors, this means that if the second server pipe creation\n+        // fails that we disconnect the connected client and then just keep\n+        // using the original server pipe.\n+        let handle = self.listener.handle;\n+\n+        // Once we've got a \"server handle\", we need to wait for a client to\n+        // connect. The ConnectNamedPipe function will block this thread until\n+        // someone on the other end connects. This function can \"fail\" if a\n+        // client connects after we created the pipe but before we got down\n+        // here. Thanks windows.\n+        let mut overlapped: libc::OVERLAPPED = unsafe { intrinsics::init() };\n+        overlapped.hEvent = self.event.handle();\n+        if unsafe { libc::ConnectNamedPipe(handle, &mut overlapped) == 0 } {\n+            let mut err = unsafe { libc::GetLastError() };\n+            if err == libc::ERROR_IO_PENDING as libc::DWORD {\n+                let ret = unsafe {\n+                    let mut transfer = 0;\n+                    libc::GetOverlappedResult(handle,\n+                                              &mut overlapped,\n+                                              &mut transfer,\n+                                              libc::TRUE)\n+                };\n+                if ret == 0 {\n+                    err = unsafe { libc::GetLastError() };\n+                } else {\n+                    // we succeeded, bypass the check below\n+                    err = libc::ERROR_PIPE_CONNECTED as libc::DWORD;\n+                }\n+            }\n+            if err != libc::ERROR_PIPE_CONNECTED as libc::DWORD {\n+                return Err(super::last_error())\n+            }\n+        }\n+\n+        // Now that we've got a connected client to our handle, we need to\n+        // create a second server pipe. If this fails, we disconnect the\n+        // connected client and return an error (see comments above).\n+        let new_handle = as_utf16_p(self.listener.name.as_str().unwrap(), |p| {\n+            unsafe { pipe(p, false) }\n+        });\n+        if new_handle == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n+            let ret = Err(super::last_error());\n+            // If our disconnection fails, then there's not really a whole lot\n+            // that we can do, so fail the task.\n+            let err = unsafe { libc::DisconnectNamedPipe(handle) };\n+            assert!(err != 0);\n+            return ret;\n+        } else {\n+            self.listener.handle = new_handle;\n+        }\n+\n+        // Transfer ownership of our handle into this stream\n+        Ok(UnixStream {\n+            inner: UnsafeArc::new(Inner { handle: handle }),\n+            read: None,\n+            write: None,\n+        })\n+    }\n+}\n+\n+impl rtio::RtioUnixAcceptor for UnixAcceptor {\n+    fn accept(&mut self) -> IoResult<~rtio::RtioPipe> {\n+        self.native_accept().map(|s| ~s as ~rtio::RtioPipe)\n+    }\n+}\n+"}, {"sha": "436156a12190b4d0fc96ed1aeb34ad9d8885f7fa", "filename": "src/libstd/io/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "patch": "@@ -14,5 +14,5 @@ pub mod addrinfo;\n pub mod tcp;\n pub mod udp;\n pub mod ip;\n-#[cfg(unix)]\n+// FIXME(#12093) - this should not be called unix\n pub mod unix;"}, {"sha": "a1f3cbbe326434b6ee826f3237b0bc824143774d", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "patch": "@@ -134,7 +134,7 @@ mod tests {\n     use io::*;\n     use io::test::*;\n \n-    fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n+    pub fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n         let (port, chan) = Chan::new();\n@@ -149,54 +149,61 @@ mod tests {\n         server(acceptor.accept().unwrap());\n     }\n \n-    #[test]\n-    fn bind_error() {\n-        match UnixListener::bind(&(\"path/to/nowhere\")) {\n+    iotest!(fn bind_error() {\n+        let path = \"path/to/nowhere\";\n+        match UnixListener::bind(&path) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.kind, PermissionDenied),\n+            Err(e) => {\n+                assert!(e.kind == PermissionDenied || e.kind == FileNotFound ||\n+                        e.kind == InvalidInput);\n+            }\n         }\n-    }\n-\n-    #[test]\n-    fn connect_error() {\n-        match UnixStream::connect(&(\"path/to/nowhere\")) {\n+    })\n+\n+    iotest!(fn connect_error() {\n+        let path = if cfg!(windows) {\n+            r\"\\\\.\\pipe\\this_should_not_exist_ever\"\n+        } else {\n+            \"path/to/nowhere\"\n+        };\n+        match UnixStream::connect(&path) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.kind,\n-                        if cfg!(windows) {OtherIoError} else {FileNotFound})\n+            Err(e) => {\n+                assert!(e.kind == FileNotFound || e.kind == OtherIoError);\n+            }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn smoke() {\n+    iotest!(fn smoke() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n             server.read(buf).unwrap();\n             assert!(buf[0] == 99);\n         }, proc(mut client) {\n             client.write([99]).unwrap();\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn read_eof() {\n+    iotest!(fn read_eof() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n             assert!(server.read(buf).is_err());\n             assert!(server.read(buf).is_err());\n         }, proc(_client) {\n             // drop the client\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn write_begone() {\n+    iotest!(fn write_begone() {\n         smalltest(proc(mut server) {\n             let buf = [0];\n             loop {\n                 match server.write(buf) {\n                     Ok(..) => {}\n                     Err(e) => {\n-                        assert!(e.kind == BrokenPipe || e.kind == NotConnected,\n+                        assert!(e.kind == BrokenPipe ||\n+                                e.kind == NotConnected ||\n+                                e.kind == ConnectionReset,\n                                 \"unknown error {:?}\", e);\n                         break;\n                     }\n@@ -205,10 +212,9 @@ mod tests {\n         }, proc(_client) {\n             // drop the client\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn accept_lots() {\n+    iotest!(fn accept_lots() {\n         let times = 10;\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n@@ -218,38 +224,49 @@ mod tests {\n             port.recv();\n             for _ in range(0, times) {\n                 let mut stream = UnixStream::connect(&path2);\n-                stream.write([100]).unwrap();\n+                match stream.write([100]) {\n+                    Ok(..) => {}\n+                    Err(e) => fail!(\"failed write: {}\", e)\n+                }\n             }\n         });\n \n-        let mut acceptor = UnixListener::bind(&path1).listen();\n+        let mut acceptor = match UnixListener::bind(&path1).listen() {\n+            Ok(a) => a,\n+            Err(e) => fail!(\"failed listen: {}\", e),\n+        };\n         chan.send(());\n         for _ in range(0, times) {\n             let mut client = acceptor.accept();\n             let mut buf = [0];\n-            client.read(buf).unwrap();\n+            match client.read(buf) {\n+                Ok(..) => {}\n+                Err(e) => fail!(\"failed read/accept: {}\", e),\n+            }\n             assert_eq!(buf[0], 100);\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn path_exists() {\n+    #[cfg(unix)]\n+    iotest!(fn path_exists() {\n         let path = next_test_unix();\n         let _acceptor = UnixListener::bind(&path).listen();\n         assert!(path.exists());\n-    }\n+    })\n \n-    #[test]\n-    fn unix_clone_smoke() {\n+    iotest!(fn unix_clone_smoke() {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n         spawn(proc() {\n             let mut s = UnixStream::connect(&addr);\n             let mut buf = [0, 0];\n+            debug!(\"client reading\");\n             assert_eq!(s.read(buf), Ok(1));\n             assert_eq!(buf[0], 1);\n+            debug!(\"client writing\");\n             s.write([2]).unwrap();\n+            debug!(\"client dropping\");\n         });\n \n         let mut s1 = acceptor.accept().unwrap();\n@@ -260,17 +277,20 @@ mod tests {\n         spawn(proc() {\n             let mut s2 = s2;\n             p1.recv();\n+            debug!(\"writer writing\");\n             s2.write([1]).unwrap();\n+            debug!(\"writer done\");\n             c2.send(());\n         });\n         c1.send(());\n         let mut buf = [0, 0];\n+        debug!(\"reader reading\");\n         assert_eq!(s1.read(buf), Ok(1));\n+        debug!(\"reader done\");\n         p2.recv();\n-    }\n+    })\n \n-    #[test]\n-    fn unix_clone_two_read() {\n+    iotest!(fn unix_clone_two_read() {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n         let (p, c) = Chan::new();\n@@ -300,10 +320,9 @@ mod tests {\n         c.send(());\n \n         p.recv();\n-    }\n+    })\n \n-    #[test]\n-    fn unix_clone_two_write() {\n+    iotest!(fn unix_clone_two_write() {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n@@ -326,5 +345,5 @@ mod tests {\n         s1.write([2]).unwrap();\n \n         p.recv();\n-    }\n+    })\n }"}, {"sha": "73bf4a1e69a88593ba59b11735a5abbb2b452918", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "patch": "@@ -269,7 +269,6 @@ pub mod types {\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint};\n \n-                pub static sun_len:uint = 108;\n                 pub type socklen_t = u32;\n                 pub type sa_family_t = u16;\n                 pub type in_port_t = u16;\n@@ -641,7 +640,6 @@ pub mod types {\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint};\n \n-                pub static sun_len:uint = 104;\n                 pub type socklen_t = u32;\n                 pub type sa_family_t = u8;\n                 pub type in_port_t = u16;\n@@ -844,7 +842,6 @@ pub mod types {\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n \n-                pub static sun_len:uint = 108;\n                 pub type SOCKET = c_uint;\n                 pub type socklen_t = c_int;\n                 pub type sa_family_t = u16;\n@@ -1213,7 +1210,6 @@ pub mod types {\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint};\n \n-                pub static sun_len:uint = 104;\n                 pub type socklen_t = c_int;\n                 pub type sa_family_t = u8;\n                 pub type in_port_t = u16;\n@@ -1627,11 +1623,19 @@ pub mod consts {\n             pub static O_NOINHERIT: c_int = 128;\n \n             pub static ERROR_SUCCESS : c_int = 0;\n+            pub static ERROR_FILE_NOT_FOUND: c_int = 2;\n+            pub static ERROR_ACCESS_DENIED: c_int = 5;\n             pub static ERROR_INVALID_HANDLE : c_int = 6;\n+            pub static ERROR_BROKEN_PIPE: c_int = 109;\n             pub static ERROR_DISK_FULL : c_int = 112;\n             pub static ERROR_INSUFFICIENT_BUFFER : c_int = 122;\n+            pub static ERROR_INVALID_NAME : c_int = 123;\n             pub static ERROR_ALREADY_EXISTS : c_int = 183;\n+            pub static ERROR_PIPE_BUSY: c_int = 231;\n+            pub static ERROR_NO_DATA: c_int = 232;\n             pub static ERROR_INVALID_ADDRESS : c_int = 487;\n+            pub static ERROR_PIPE_CONNECTED: c_int = 535;\n+            pub static ERROR_IO_PENDING: c_int = 997;\n             pub static ERROR_FILE_INVALID : c_int = 1006;\n             pub static INVALID_HANDLE_VALUE : c_int = -1;\n \n@@ -1770,6 +1774,7 @@ pub mod consts {\n             pub static FILE_FLAG_SESSION_AWARE: DWORD = 0x00800000;\n             pub static FILE_FLAG_SEQUENTIAL_SCAN: DWORD = 0x08000000;\n             pub static FILE_FLAG_WRITE_THROUGH: DWORD = 0x80000000;\n+            pub static FILE_FLAG_FIRST_PIPE_INSTANCE: DWORD = 0x00080000;\n \n             pub static FILE_NAME_NORMALIZED: DWORD = 0x0;\n             pub static FILE_NAME_OPENED: DWORD = 0x8;\n@@ -1783,6 +1788,8 @@ pub mod consts {\n             pub static GENERIC_WRITE: DWORD = 0x40000000;\n             pub static GENERIC_EXECUTE: DWORD = 0x20000000;\n             pub static GENERIC_ALL: DWORD = 0x10000000;\n+            pub static FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n+            pub static FILE_READ_ATTRIBUTES: DWORD = 0x00000080;\n \n             pub static FILE_BEGIN: DWORD = 0;\n             pub static FILE_CURRENT: DWORD = 1;\n@@ -1794,6 +1801,19 @@ pub mod consts {\n \n             pub static DETACHED_PROCESS: DWORD = 0x00000008;\n             pub static CREATE_NEW_PROCESS_GROUP: DWORD = 0x00000200;\n+\n+            pub static PIPE_ACCESS_DUPLEX: DWORD = 0x00000003;\n+            pub static PIPE_ACCESS_INBOUND: DWORD = 0x00000001;\n+            pub static PIPE_ACCESS_OUTBOUND: DWORD = 0x00000002;\n+            pub static PIPE_TYPE_BYTE: DWORD = 0x00000000;\n+            pub static PIPE_TYPE_MESSAGE: DWORD = 0x00000004;\n+            pub static PIPE_READMODE_BYTE: DWORD = 0x00000000;\n+            pub static PIPE_READMODE_MESSAGE: DWORD = 0x00000002;\n+            pub static PIPE_WAIT: DWORD = 0x00000000;\n+            pub static PIPE_NOWAIT: DWORD = 0x00000001;\n+            pub static PIPE_ACCEPT_REMOTE_CLIENTS: DWORD = 0x00000000;\n+            pub static PIPE_REJECT_REMOTE_CLIENTS: DWORD = 0x00000008;\n+            pub static PIPE_UNLIMITED_INSTANCES: DWORD = 255;\n         }\n         pub mod sysconf {\n         }\n@@ -2784,6 +2804,7 @@ pub mod consts {\n \n             pub static AF_INET: c_int = 2;\n             pub static AF_INET6: c_int = 28;\n+            pub static AF_UNIX: c_int = 1;\n             pub static SOCK_STREAM: c_int = 1;\n             pub static SOCK_DGRAM: c_int = 2;\n             pub static IPPROTO_TCP: c_int = 6;\n@@ -4177,6 +4198,34 @@ pub mod funcs {\n                             lpPerformanceCount: *mut LARGE_INTEGER) -> BOOL;\n \n                 pub fn GetCurrentProcessId() -> DWORD;\n+                pub fn CreateNamedPipeW(\n+                            lpName: LPCWSTR,\n+                            dwOpenMode: DWORD,\n+                            dwPipeMode: DWORD,\n+                            nMaxInstances: DWORD,\n+                            nOutBufferSize: DWORD,\n+                            nInBufferSize: DWORD,\n+                            nDefaultTimeOut: DWORD,\n+                            lpSecurityAttributes: LPSECURITY_ATTRIBUTES\n+                            ) -> HANDLE;\n+                pub fn ConnectNamedPipe(hNamedPipe: HANDLE,\n+                                        lpOverlapped: LPOVERLAPPED) -> BOOL;\n+                pub fn WaitNamedPipeW(lpNamedPipeName: LPCWSTR,\n+                                      nTimeOut: DWORD) -> BOOL;\n+                pub fn SetNamedPipeHandleState(hNamedPipe: HANDLE,\n+                                               lpMode: LPDWORD,\n+                                               lpMaxCollectionCount: LPDWORD,\n+                                               lpCollectDataTimeout: LPDWORD)\n+                                                            -> BOOL;\n+                pub fn CreateEventW(lpEventAttributes: LPSECURITY_ATTRIBUTES,\n+                                    bManualReset: BOOL,\n+                                    bInitialState: BOOL,\n+                                    lpName: LPCWSTR) -> HANDLE;\n+                pub fn GetOverlappedResult(hFile: HANDLE,\n+                                           lpOverlapped: LPOVERLAPPED,\n+                                           lpNumberOfBytesTransferred: LPDWORD,\n+                                           bWait: BOOL) -> BOOL;\n+                pub fn DisconnectNamedPipe(hNamedPipe: HANDLE) -> BOOL;\n             }\n         }\n "}, {"sha": "5573f8ec02eb3c17e457a22cf57336958f1139cd", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a526aa139ec1c95cbad4c1d3187c437eb45d4bae/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=a526aa139ec1c95cbad4c1d3187c437eb45d4bae", "patch": "@@ -260,11 +260,6 @@ pub trait RtioPipe {\n     fn clone(&self) -> ~RtioPipe;\n }\n \n-pub trait RtioDatagramPipe : RtioPipe {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, CString), IoError>;\n-    fn sendto(&mut self, buf: &[u8], dst: &CString) -> Result<(), IoError>;\n-}\n-\n pub trait RtioUnixListener {\n     fn listen(~self) -> Result<~RtioUnixAcceptor, IoError>;\n }"}]}