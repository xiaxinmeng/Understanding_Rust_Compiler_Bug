{"sha": "6b6bea9531c400aa14c69d5193634a7215381b91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNmJlYTk1MzFjNDAwYWExNGM2OWQ1MTkzNjM0YTcyMTUzODFiOTE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-23T22:51:23Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-24T00:22:08Z"}, "message": "Add boolean constants as part of const_eval\n\nDoesn't exactly eliminate a match check, but simplifies the logic a bit", "tree": {"sha": "24edf9237925df2816433314e5ebb6fb1e449420", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24edf9237925df2816433314e5ebb6fb1e449420"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b6bea9531c400aa14c69d5193634a7215381b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b6bea9531c400aa14c69d5193634a7215381b91", "html_url": "https://github.com/rust-lang/rust/commit/6b6bea9531c400aa14c69d5193634a7215381b91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b6bea9531c400aa14c69d5193634a7215381b91/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80d129aa45e897b569e7f4aed29b272860e639ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/80d129aa45e897b569e7f4aed29b272860e639ad", "html_url": "https://github.com/rust-lang/rust/commit/80d129aa45e897b569e7f4aed29b272860e639ad"}], "stats": {"total": 151, "additions": 102, "deletions": 49}, "files": [{"sha": "a1e3dc439a9745475e3667e7d9cf65964db2495e", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6b6bea9531c400aa14c69d5193634a7215381b91/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b6bea9531c400aa14c69d5193634a7215381b91/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=6b6bea9531c400aa14c69d5193634a7215381b91", "patch": "@@ -1,6 +1,6 @@\n import syntax::ast::*;\n import syntax::ast_util::{variant_def_ids, dummy_sp, unguarded_pat};\n-import const_eval::{eval_const_expr, const_val, const_int,\n+import const_eval::{eval_const_expr, const_val, const_int, const_bool,\n                     compare_const_vals};\n import syntax::codemap::span;\n import syntax::print::pprust::pat_to_str;\n@@ -90,16 +90,19 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n       useful(ty, ctor) => {\n         match ty::get(ty).struct {\n           ty::ty_bool => {\n-            match check ctor {\n-              val(const_int(1i64)) => some(~\"true\"),\n-              val(const_int(0i64)) => some(~\"false\")\n+            match ctor {\n+              val(const_bool(true)) => some(~\"true\"),\n+              val(const_bool(false)) => some(~\"false\"),\n+              _ => none\n             }\n           }\n           ty::ty_enum(id, _) => {\n-            let vid = match check ctor { variant(id) => id };\n-            match check vec::find(*ty::enum_variants(tcx, id),\n+              let vid = match ctor { variant(id) => id,\n+              _ => fail ~\"check_exhaustive: non-variant ctor\" };\n+            match vec::find(*ty::enum_variants(tcx, id),\n                                 |v| v.id == vid) {\n-              some(v) => some(tcx.sess.str_of(v.name))\n+                some(v) => some(tcx.sess.str_of(v.name)),\n+              none => fail ~\"check_exhaustive: bad variant in ctor\"\n             }\n           }\n           _ => none\n@@ -152,10 +155,10 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n           none => {\n             match ty::get(left_ty).struct {\n               ty::ty_bool => {\n-                match is_useful_specialized(tcx, m, v, val(const_int(1i64)),\n+                match is_useful_specialized(tcx, m, v, val(const_bool(true)),\n                                           0u, left_ty){\n                   not_useful => {\n-                    is_useful_specialized(tcx, m, v, val(const_int(0i64)),\n+                    is_useful_specialized(tcx, m, v, val(const_bool(false)),\n                                           0u, left_ty)\n                   }\n                   u => u\n@@ -269,15 +272,16 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n       ty::ty_bool => {\n         let mut true_found = false, false_found = false;\n         for m.each |r| {\n-            match check pat_ctor_id(tcx, r[0]) {\n+            match pat_ctor_id(tcx, r[0]) {\n               none => (),\n-              some(val(const_int(1i64))) => true_found = true,\n-              some(val(const_int(0i64))) => false_found = true\n+              some(val(const_bool(true))) => true_found = true,\n+              some(val(const_bool(false))) => false_found = true,\n+              _ => fail ~\"impossible case\"\n             }\n         }\n         if true_found && false_found { none }\n-        else if true_found { some(val(const_int(0i64))) }\n-        else { some(val(const_int(1i64))) }\n+        else if true_found { some(val(const_bool(false))) }\n+        else { some(val(const_bool(true))) }\n       }\n       _ => some(single)\n     }\n@@ -289,9 +293,11 @@ fn ctor_arity(tcx: ty::ctxt, ctor: ctor, ty: ty::t) -> uint {\n       ty::ty_rec(fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) => 1u,\n       ty::ty_enum(eid, _) => {\n-        let id = match check ctor { variant(id) => id };\n-        match check vec::find(*ty::enum_variants(tcx, eid), |v| v.id == id ) {\n-          some(v) => v.args.len()\n+          let id = match ctor { variant(id) => id,\n+          _ => fail ~\"impossible case\" };\n+        match vec::find(*ty::enum_variants(tcx, eid), |v| v.id == id ) {\n+            some(v) => v.args.len(),\n+            none => fail ~\"impossible case\"\n         }\n       }\n       ty::ty_class(cid, _) => ty::lookup_class_fields(tcx, cid).len(),\n@@ -319,20 +325,22 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         }\n       }\n       pat_enum(_, args) => {\n-        match check tcx.def_map.get(r0.id) {\n+        match tcx.def_map.get(r0.id) {\n           def_variant(_, id) if variant(id) == ctor_id => {\n             let args = match args {\n               some(args) => args,\n               none => vec::from_elem(arity, wild())\n             };\n             some(vec::append(args, vec::tail(r)))\n           }\n-          def_variant(_, _) => none\n+          def_variant(_, _) => none,\n+          _ => none\n         }\n       }\n       pat_rec(flds, _) => {\n-        let ty_flds = match check ty::get(left_ty).struct {\n-          ty::ty_rec(flds) => flds\n+        let ty_flds = match ty::get(left_ty).struct {\n+            ty::ty_rec(flds) => flds,\n+            _ => fail ~\"bad type for pat_rec\"\n         };\n         let args = vec::map(ty_flds, |ty_f| {\n             match vec::find(flds, |f| f.ident == ty_f.ident ) {\n@@ -367,21 +375,23 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n       pat_box(a) | pat_uniq(a) => some(vec::append(~[a], vec::tail(r))),\n       pat_lit(expr) => {\n         let e_v = eval_const_expr(tcx, expr);\n-        let match_ = match check ctor_id {\n+        let match_ = match ctor_id {\n           val(v) => compare_const_vals(e_v, v) == 0,\n           range(c_lo, c_hi) => {\n             compare_const_vals(c_lo, e_v) >= 0 &&\n                 compare_const_vals(c_hi, e_v) <= 0\n           }\n-          single => true\n+          single => true,\n+          _ => fail ~\"type error\"\n         };\n         if match_ { some(vec::tail(r)) } else { none }\n       }\n       pat_range(lo, hi) => {\n-        let (c_lo, c_hi) = match check ctor_id {\n+        let (c_lo, c_hi) = match ctor_id {\n           val(v) => (v, v),\n           range(lo, hi) => (lo, hi),\n           single => return some(vec::tail(r)),\n+          _ => fail ~\"type error\"\n         };\n         let v_lo = eval_const_expr(tcx, lo),\n             v_hi = eval_const_expr(tcx, hi);"}, {"sha": "a64c207ea4c417ef5224d524f2f9c611d25d098b", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b6bea9531c400aa14c69d5193634a7215381b91/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b6bea9531c400aa14c69d5193634a7215381b91/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=6b6bea9531c400aa14c69d5193634a7215381b91", "patch": "@@ -182,10 +182,11 @@ fn check_item_recursion(sess: session, ast_map: ast_map::map,\n           expr_path(path) => {\n             match env.def_map.find(e.id) {\n               some(def_const(def_id)) => {\n-                match check env.ast_map.get(def_id.node) {\n+                match env.ast_map.get(def_id.node) {\n                   ast_map::node_item(it, _) => {\n                     v.visit_item(it, env, v);\n                   }\n+                  _ => fail ~\"const not bound to an item\"\n                 }\n               }\n               _ => ()"}, {"sha": "95d688f1f11785905d1d44d2f866861cff601298", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 59, "deletions": 24, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6b6bea9531c400aa14c69d5193634a7215381b91/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b6bea9531c400aa14c69d5193634a7215381b91/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=6b6bea9531c400aa14c69d5193634a7215381b91", "patch": "@@ -186,30 +186,35 @@ enum const_val {\n     const_int(i64),\n     const_uint(u64),\n     const_str(~str),\n+    const_bool(bool)\n }\n \n // FIXME: issue #1417\n fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n     import middle::ty;\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n-    match check e.node {\n+    match e.node {\n       expr_unary(neg, inner) => {\n-        match check eval_const_expr(tcx, inner) {\n+        match eval_const_expr(tcx, inner) {\n           const_float(f) => const_float(-f),\n           const_int(i) => const_int(-i),\n-          const_uint(i) => const_uint(-i)\n+          const_uint(i) => const_uint(-i),\n+          const_str(_) => fail ~\"Negate on string\",\n+          const_bool(_) => fail ~\"Negate on boolean\"\n         }\n       }\n       expr_unary(not, inner) => {\n-        match check eval_const_expr(tcx, inner) {\n+        match eval_const_expr(tcx, inner) {\n           const_int(i) => const_int(!i),\n-          const_uint(i) => const_uint(!i)\n+          const_uint(i) => const_uint(!i),\n+          const_bool(b) => const_bool(!b),\n+          _ => fail ~\"Not on float or string\"\n         }\n       }\n       expr_binary(op, a, b) => {\n-        match check (eval_const_expr(tcx, a), eval_const_expr(tcx, b)) {\n+        match (eval_const_expr(tcx, a), eval_const_expr(tcx, b)) {\n           (const_float(a), const_float(b)) => {\n-            match check op {\n+            match op {\n               add => const_float(a + b),\n               subtract => const_float(a - b),\n               mul => const_float(a * b),\n@@ -220,11 +225,12 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n               le => fromb(a <= b),\n               ne => fromb(a != b),\n               ge => fromb(a >= b),\n-              gt => fromb(a > b)\n+              gt => fromb(a > b),\n+              _ => fail ~\"Can't do this op on floats\"\n             }\n           }\n           (const_int(a), const_int(b)) => {\n-            match check op {\n+            match op {\n               add => const_int(a + b),\n               subtract => const_int(a - b),\n               mul => const_int(a * b),\n@@ -244,7 +250,7 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n             }\n           }\n           (const_uint(a), const_uint(b)) => {\n-            match check op {\n+            match op {\n               add => const_uint(a + b),\n               subtract => const_uint(a - b),\n               mul => const_uint(a * b),\n@@ -260,54 +266,74 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n               le => fromb(a <= b),\n               ne => fromb(a != b),\n               ge => fromb(a >= b),\n-              gt => fromb(a > b)\n+              gt => fromb(a > b),\n             }\n           }\n           // shifts can have any integral type as their rhs\n           (const_int(a), const_uint(b)) => {\n-            match check op {\n+            match op {\n               shl => const_int(a << b),\n-              shr => const_int(a >> b)\n+              shr => const_int(a >> b),\n+              _ => fail ~\"Can't do this op on an int and uint\"\n             }\n           }\n           (const_uint(a), const_int(b)) => {\n-            match check op {\n+            match op {\n               shl => const_uint(a << b),\n-              shr => const_uint(a >> b)\n+              shr => const_uint(a >> b),\n+              _ => fail ~\"Can't do this op on a uint and int\"\n             }\n           }\n+          (const_bool(a), const_bool(b)) => {\n+            const_bool(match op {\n+              and => a && b,\n+              or => a || b,\n+              bitxor => a ^ b,\n+              bitand => a & b,\n+              bitor => a | b,\n+              eq => a == b,\n+              ne => a != b,\n+              _ => fail ~\"Can't do this op on bools\"\n+             })\n+          }\n+          _ => fail ~\"Bad operands for binary\"\n         }\n       }\n       expr_cast(base, _) => {\n         let ety = ty::expr_ty(tcx, e);\n         let base = eval_const_expr(tcx, base);\n-        match check ty::get(ety).struct {\n+        match ty::get(ety).struct {\n           ty::ty_float(_) => {\n-            match check base {\n+            match base {\n               const_uint(u) => const_float(u as f64),\n               const_int(i) => const_float(i as f64),\n-              const_float(_) => base\n+              const_float(_) => base,\n+              _ => fail ~\"Can't cast float to str\"\n             }\n           }\n           ty::ty_uint(_) => {\n-            match check base {\n+            match base {\n               const_uint(_) => base,\n               const_int(i) => const_uint(i as u64),\n-              const_float(f) => const_uint(f as u64)\n+              const_float(f) => const_uint(f as u64),\n+              _ => fail ~\"Can't cast str to uint\"\n             }\n           }\n           ty::ty_int(_) | ty::ty_bool => {\n-            match check base {\n+            match base {\n               const_uint(u) => const_int(u as i64),\n               const_int(_) => base,\n-              const_float(f) => const_int(f as i64)\n+              const_float(f) => const_int(f as i64),\n+              _ => fail ~\"Can't cast str to int\"\n             }\n           }\n+          _ => fail ~\"Can't cast this type\"\n         }\n       }\n       expr_lit(lit) => lit_to_const(lit),\n       // If we have a vstore, just keep going; it has to be a string\n-      expr_vstore(e, _) => eval_const_expr(tcx, e)\n+      expr_vstore(e, _) => eval_const_expr(tcx, e),\n+      _ => fail ~\"Unsupported constant expr\"\n     }\n }\n \n@@ -319,7 +345,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n       lit_int_unsuffixed(n) => const_int(n),\n       lit_float(n, _) => const_float(option::get(float::from_str(*n)) as f64),\n       lit_nil => const_int(0i64),\n-      lit_bool(b) => const_int(b as i64)\n+      lit_bool(b) => const_bool(b)\n     }\n }\n \n@@ -361,6 +387,15 @@ fn compare_const_vals(a: const_val, b: const_val) -> int {\n             1\n         }\n     }\n+    (const_bool(a), const_bool(b)) => {\n+        if a == b {\n+            0\n+        } else if a < b {\n+            -1\n+        } else {\n+            1\n+        }\n+    }\n     _ => fail ~\"compare_const_vals: ill-typed comparison\"\n   }\n }"}, {"sha": "15eaa683bae168ff5465bce6c7a9f71b0e638200", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b6bea9531c400aa14c69d5193634a7215381b91/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b6bea9531c400aa14c69d5193634a7215381b91/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=6b6bea9531c400aa14c69d5193634a7215381b91", "patch": "@@ -3379,6 +3379,13 @@ fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr, span: span) -> uint {\n                                 repeat count but found string\");\n             return 0;\n         }\n+        const_eval::const_bool(_) => {\n+            tcx.sess.span_err(span,\n+                              ~\"expected signed or unsigned integer for \\\n+                                repeat count but found boolean\");\n+            return 0;\n+        }\n+\n     }\n }\n "}]}