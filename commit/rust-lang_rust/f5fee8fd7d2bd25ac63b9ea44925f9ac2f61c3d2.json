{"sha": "f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZmVlOGZkN2QyYmQyNWFjNjNiOWVhNDQ5MjVmOWFjMmY2MWMzZDI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-03-13T22:01:12Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-03-29T11:18:20Z"}, "message": "improve worst-case performance of BTreeSet difference and intersection", "tree": {"sha": "669eceaf71b28f36b911bbc2bec44c0ee0647c65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/669eceaf71b28f36b911bbc2bec44c0ee0647c65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2", "html_url": "https://github.com/rust-lang/rust/commit/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fec737f9aad565ef0351c38f147b78394b7a8ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fec737f9aad565ef0351c38f147b78394b7a8ac", "html_url": "https://github.com/rust-lang/rust/commit/4fec737f9aad565ef0351c38f147b78394b7a8ac"}], "stats": {"total": 473, "additions": 351, "deletions": 122}, "files": [{"sha": "6357ea3ea11bd8b99a1d75e759b75af0a8e4916e", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2", "patch": "@@ -3,86 +3,86 @@ use std::collections::BTreeSet;\n use rand::{thread_rng, Rng};\n use test::{black_box, Bencher};\n \n-fn random(n1: u32, n2: u32) -> [BTreeSet<usize>; 2] {\n+fn random(n: usize) -> BTreeSet<usize> {\n     let mut rng = thread_rng();\n-    let mut set1 = BTreeSet::new();\n-    let mut set2 = BTreeSet::new();\n-    for _ in 0..n1 {\n-        let i = rng.gen::<usize>();\n-        set1.insert(i);\n+    let mut set = BTreeSet::new();\n+    while set.len() < n {\n+        set.insert(rng.gen());\n     }\n-    for _ in 0..n2 {\n-        let i = rng.gen::<usize>();\n-        set2.insert(i);\n-    }\n-    [set1, set2]\n+    assert_eq!(set.len(), n);\n+    set\n }\n \n-fn staggered(n1: u32, n2: u32) -> [BTreeSet<u32>; 2] {\n-    let mut even = BTreeSet::new();\n-    let mut odd = BTreeSet::new();\n-    for i in 0..n1 {\n-        even.insert(i * 2);\n-    }\n-    for i in 0..n2 {\n-        odd.insert(i * 2 + 1);\n+fn neg(n: usize) -> BTreeSet<i32> {\n+    let mut set = BTreeSet::new();\n+    for i in -(n as i32)..=-1 {\n+        set.insert(i);\n     }\n-    [even, odd]\n+    assert_eq!(set.len(), n);\n+    set\n }\n \n-fn neg_vs_pos(n1: u32, n2: u32) -> [BTreeSet<i32>; 2] {\n-    let mut neg = BTreeSet::new();\n-    let mut pos = BTreeSet::new();\n-    for i in -(n1 as i32)..=-1 {\n-        neg.insert(i);\n-    }\n-    for i in 1..=(n2 as i32) {\n-        pos.insert(i);\n+fn pos(n: usize) -> BTreeSet<i32> {\n+    let mut set = BTreeSet::new();\n+    for i in 1..=(n as i32) {\n+        set.insert(i);\n     }\n-    [neg, pos]\n+    assert_eq!(set.len(), n);\n+    set\n }\n \n-fn pos_vs_neg(n1: u32, n2: u32) -> [BTreeSet<i32>; 2] {\n-    let mut neg = BTreeSet::new();\n-    let mut pos = BTreeSet::new();\n-    for i in -(n1 as i32)..=-1 {\n-        neg.insert(i);\n-    }\n-    for i in 1..=(n2 as i32) {\n-        pos.insert(i);\n+\n+fn stagger(n1: usize, factor: usize) -> [BTreeSet<u32>; 2] {\n+    let n2 = n1 * factor;\n+    let mut sets = [BTreeSet::new(), BTreeSet::new()];\n+    for i in 0..(n1 + n2) {\n+        let b = i % (factor + 1) != 0;\n+        sets[b as usize].insert(i as u32);\n     }\n-    [pos, neg]\n+    assert_eq!(sets[0].len(), n1);\n+    assert_eq!(sets[1].len(), n2);\n+    sets\n }\n \n-macro_rules! set_intersection_bench {\n-    ($name: ident, $sets: expr) => {\n+macro_rules! set_bench {\n+    ($name: ident, $set_func: ident, $result_func: ident, $sets: expr) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             // setup\n             let sets = $sets;\n \n             // measure\n             b.iter(|| {\n-                let x = sets[0].intersection(&sets[1]).count();\n+                let x = sets[0].$set_func(&sets[1]).$result_func();\n                 black_box(x);\n             })\n         }\n     };\n }\n \n-set_intersection_bench! {intersect_random_100,          random(100, 100)}\n-set_intersection_bench! {intersect_random_10k,          random(10_000, 10_000)}\n-set_intersection_bench! {intersect_random_10_vs_10k,    random(10, 10_000)}\n-set_intersection_bench! {intersect_random_10k_vs_10,    random(10_000, 10)}\n-set_intersection_bench! {intersect_staggered_100,       staggered(100, 100)}\n-set_intersection_bench! {intersect_staggered_10k,       staggered(10_000, 10_000)}\n-set_intersection_bench! {intersect_staggered_10_vs_10k, staggered(10, 10_000)}\n-set_intersection_bench! {intersect_staggered_10k_vs_10, staggered(10_000, 10)}\n-set_intersection_bench! {intersect_neg_vs_pos_100,      neg_vs_pos(100, 100)}\n-set_intersection_bench! {intersect_neg_vs_pos_10k,      neg_vs_pos(10_000, 10_000)}\n-set_intersection_bench! {intersect_neg_vs_pos_10_vs_10k,neg_vs_pos(10, 10_000)}\n-set_intersection_bench! {intersect_neg_vs_pos_10k_vs_10,neg_vs_pos(10_000, 10)}\n-set_intersection_bench! {intersect_pos_vs_neg_100,      pos_vs_neg(100, 100)}\n-set_intersection_bench! {intersect_pos_vs_neg_10k,      pos_vs_neg(10_000, 10_000)}\n-set_intersection_bench! {intersect_pos_vs_neg_10_vs_10k,pos_vs_neg(10, 10_000)}\n-set_intersection_bench! {intersect_pos_vs_neg_10k_vs_10,pos_vs_neg(10_000, 10)}\n+set_bench! {intersection_100_neg_vs_100_pos, intersection, count, [neg(100), pos(100)]}\n+set_bench! {intersection_100_neg_vs_10k_pos, intersection, count, [neg(100), pos(10_000)]}\n+set_bench! {intersection_100_pos_vs_100_neg, intersection, count, [pos(100), neg(100)]}\n+set_bench! {intersection_100_pos_vs_10k_neg, intersection, count, [pos(100), neg(10_000)]}\n+set_bench! {intersection_10k_neg_vs_100_pos, intersection, count, [neg(10_000), pos(100)]}\n+set_bench! {intersection_10k_neg_vs_10k_pos, intersection, count, [neg(10_000), pos(10_000)]}\n+set_bench! {intersection_10k_pos_vs_100_neg, intersection, count, [pos(10_000), neg(100)]}\n+set_bench! {intersection_10k_pos_vs_10k_neg, intersection, count, [pos(10_000), neg(10_000)]}\n+set_bench! {intersection_random_100_vs_100, intersection, count, [random(100), random(100)]}\n+set_bench! {intersection_random_100_vs_10k, intersection, count, [random(100), random(10_000)]}\n+set_bench! {intersection_random_10k_vs_100, intersection, count, [random(10_000), random(100)]}\n+set_bench! {intersection_random_10k_vs_10k, intersection, count, [random(10_000), random(10_000)]}\n+set_bench! {intersection_staggered_100_vs_100, intersection, count, stagger(100, 1)}\n+set_bench! {intersection_staggered_10k_vs_10k, intersection, count, stagger(10_000, 1)}\n+set_bench! {intersection_staggered_100_vs_10k, intersection, count, stagger(100, 100)}\n+set_bench! {difference_random_100_vs_100, difference, count, [random(100), random(100)]}\n+set_bench! {difference_random_100_vs_10k, difference, count, [random(100), random(10_000)]}\n+set_bench! {difference_random_10k_vs_100, difference, count, [random(10_000), random(100)]}\n+set_bench! {difference_random_10k_vs_10k, difference, count, [random(10_000), random(10_000)]}\n+set_bench! {difference_staggered_100_vs_100, difference, count, stagger(100, 1)}\n+set_bench! {difference_staggered_10k_vs_10k, difference, count, stagger(10_000, 1)}\n+set_bench! {difference_staggered_100_vs_10k, difference, count, stagger(100, 100)}\n+set_bench! {is_subset_100_vs_100, is_subset, clone, [pos(100), pos(100)]}\n+set_bench! {is_subset_100_vs_10k, is_subset, clone, [pos(100), pos(10_000)]}\n+set_bench! {is_subset_10k_vs_100, is_subset, clone, [pos(10_000), pos(100)]}\n+set_bench! {is_subset_10k_vs_10k, is_subset, clone, [pos(10_000), pos(10_000)]}"}, {"sha": "e71767077ca5501a69d86bcc9176723ecd2a52d0", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 233, "deletions": 65, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2", "patch": "@@ -3,7 +3,7 @@\n \n use core::borrow::Borrow;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n-use core::cmp::{min, max};\n+use core::cmp::max;\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n@@ -118,17 +118,36 @@ pub struct Range<'a, T: 'a> {\n /// [`difference`]: struct.BTreeSet.html#method.difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n+    inner: DifferenceInner<'a, T>,\n+}\n+enum DifferenceInner<'a, T: 'a> {\n+    Stitch {\n+        self_iter: Iter<'a, T>,\n+        other_iter: Peekable<Iter<'a, T>>,\n+    },\n+    Search {\n+        self_iter: Iter<'a, T>,\n+        other_set: &'a BTreeSet<T>,\n+    },\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Difference\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        match &self.inner {\n+            DifferenceInner::Stitch {\n+                self_iter,\n+                other_iter,\n+            } => f\n+                .debug_tuple(\"Difference\")\n+                .field(&self_iter)\n+                .field(&other_iter)\n+                .finish(),\n+            DifferenceInner::Search {\n+                self_iter,\n+                other_set: _,\n+            } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n+        }\n     }\n }\n \n@@ -164,17 +183,36 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n /// [`intersection`]: struct.BTreeSet.html#method.intersection\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n+    inner: IntersectionInner<'a, T>,\n+}\n+enum IntersectionInner<'a, T: 'a> {\n+    Stitch {\n+        small_iter: Iter<'a, T>, // for size_hint, should be the smaller of the sets\n+        other_iter: Iter<'a, T>,\n+    },\n+    Search {\n+        small_iter: Iter<'a, T>,\n+        large_set: &'a BTreeSet<T>,\n+    },\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Intersection\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        match &self.inner {\n+            IntersectionInner::Stitch {\n+                small_iter,\n+                other_iter,\n+            } => f\n+                .debug_tuple(\"Intersection\")\n+                .field(&small_iter)\n+                .field(&other_iter)\n+                .finish(),\n+            IntersectionInner::Search {\n+                small_iter,\n+                large_set: _,\n+            } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n+        }\n     }\n }\n \n@@ -201,6 +239,14 @@ impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n     }\n }\n \n+// This constant is used by functions that compare two sets.\n+// It estimates the relative size at which searching performs better\n+// than iterating, based on the benchmarks in\n+// https://github.com/ssomers/rust_bench_btreeset_intersection;\n+// It's used to divide rather than multiply sizes, to rule out overflow,\n+// and it's a power of two to make that division cheap.\n+const ITER_PERFORMANCE_TIPPING_SIZE_DIFF: usize = 16;\n+\n impl<T: Ord> BTreeSet<T> {\n     /// Makes a new `BTreeSet` with a reasonable choice of B.\n     ///\n@@ -268,9 +314,24 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n-        Difference {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n+        if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Self is bigger than or not much smaller than other set.\n+            // Iterate both sets jointly, spotting matches along the way.\n+            Difference {\n+                inner: DifferenceInner::Stitch {\n+                    self_iter: self.iter(),\n+                    other_iter: other.iter().peekable(),\n+                },\n+            }\n+        } else {\n+            // Self is much smaller than other set, or both sets are empty.\n+            // Iterate the small set, searching for matches in the large set.\n+            Difference {\n+                inner: DifferenceInner::Search {\n+                    self_iter: self.iter(),\n+                    other_set: other,\n+                },\n+            }\n         }\n     }\n \n@@ -326,9 +387,29 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n-        Intersection {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n+        let (small, other) = if self.len() <= other.len() {\n+            (self, other)\n+        } else {\n+            (other, self)\n+        };\n+        if small.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Small set is not much smaller than other set.\n+            // Iterate both sets jointly, spotting matches along the way.\n+            Intersection {\n+                inner: IntersectionInner::Stitch {\n+                    small_iter: small.iter(),\n+                    other_iter: other.iter(),\n+                },\n+            }\n+        } else {\n+            // Big difference in number of elements, or both sets are empty.\n+            // Iterate the small set, searching for matches in the large set.\n+            Intersection {\n+                inner: IntersectionInner::Search {\n+                    small_iter: small.iter(),\n+                    large_set: other,\n+                },\n+            }\n         }\n     }\n \n@@ -462,28 +543,44 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n-        // Stolen from TreeMap\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() {\n-            if b.is_none() {\n-                return false;\n-            }\n+        // Same result as self.difference(other).next().is_none()\n+        // but the 3 paths below are faster (in order: hugely, 20%, 5%).\n+        if self.len() > other.len() {\n+            false\n+        } else if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Self is not much smaller than other set.\n+            // Stolen from TreeMap\n+            let mut x = self.iter();\n+            let mut y = other.iter();\n+            let mut a = x.next();\n+            let mut b = y.next();\n+            while a.is_some() {\n+                if b.is_none() {\n+                    return false;\n+                }\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n+                let a1 = a.unwrap();\n+                let b1 = b.unwrap();\n \n-            match b1.cmp(a1) {\n-                Less => (),\n-                Greater => return false,\n-                Equal => a = x.next(),\n-            }\n+                match b1.cmp(a1) {\n+                    Less => (),\n+                    Greater => return false,\n+                    Equal => a = x.next(),\n+                }\n \n-            b = y.next();\n+                b = y.next();\n+            }\n+            true\n+        } else {\n+            // Big difference in number of elements, or both sets are empty.\n+            // Iterate the small set, searching for matches in the large set.\n+            for next in self {\n+                if !other.contains(next) {\n+                    return false;\n+                }\n+            }\n+            true\n         }\n-        true\n     }\n \n     /// Returns `true` if the set is a superset of another,\n@@ -1001,8 +1098,22 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering\n impl<T> Clone for Difference<'_, T> {\n     fn clone(&self) -> Self {\n         Difference {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n+            inner: match &self.inner {\n+                DifferenceInner::Stitch {\n+                    self_iter,\n+                    other_iter,\n+                } => DifferenceInner::Stitch {\n+                    self_iter: self_iter.clone(),\n+                    other_iter: other_iter.clone(),\n+                },\n+                DifferenceInner::Search {\n+                    self_iter,\n+                    other_set,\n+                } => DifferenceInner::Search {\n+                    self_iter: self_iter.clone(),\n+                    other_set,\n+                },\n+            },\n         }\n     }\n }\n@@ -1011,24 +1122,52 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n-                Less => return self.a.next(),\n-                Equal => {\n-                    self.a.next();\n-                    self.b.next();\n-                }\n-                Greater => {\n-                    self.b.next();\n+        match &mut self.inner {\n+            DifferenceInner::Stitch {\n+                self_iter,\n+                other_iter,\n+            } => {\n+                let mut self_next = self_iter.next()?;\n+                loop {\n+                    match other_iter\n+                        .peek()\n+                        .map_or(Less, |other_next| Ord::cmp(self_next, other_next))\n+                    {\n+                        Less => return Some(self_next),\n+                        Equal => {\n+                            self_next = self_iter.next()?;\n+                            other_iter.next();\n+                        }\n+                        Greater => {\n+                            other_iter.next();\n+                        }\n+                    }\n                 }\n             }\n+            DifferenceInner::Search {\n+                self_iter,\n+                other_set,\n+            } => loop {\n+                let self_next = self_iter.next()?;\n+                if !other_set.contains(&self_next) {\n+                    return Some(self_next);\n+                }\n+            },\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let a_len = self.a.len();\n-        let b_len = self.b.len();\n-        (a_len.saturating_sub(b_len), Some(a_len))\n+        let (self_len, other_len) = match &self.inner {\n+            DifferenceInner::Stitch {\n+                self_iter,\n+                other_iter\n+            } => (self_iter.len(), other_iter.len()),\n+            DifferenceInner::Search {\n+                self_iter,\n+                other_set\n+            } => (self_iter.len(), other_set.len()),\n+        };\n+        (self_len.saturating_sub(other_len), Some(self_len))\n     }\n }\n \n@@ -1073,8 +1212,22 @@ impl<T: Ord> FusedIterator for SymmetricDifference<'_, T> {}\n impl<T> Clone for Intersection<'_, T> {\n     fn clone(&self) -> Self {\n         Intersection {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n+            inner: match &self.inner {\n+                IntersectionInner::Stitch {\n+                    small_iter,\n+                    other_iter,\n+                } => IntersectionInner::Stitch {\n+                    small_iter: small_iter.clone(),\n+                    other_iter: other_iter.clone(),\n+                },\n+                IntersectionInner::Search {\n+                    small_iter,\n+                    large_set,\n+                } => IntersectionInner::Search {\n+                    small_iter: small_iter.clone(),\n+                    large_set,\n+                },\n+            },\n         }\n     }\n }\n@@ -1083,24 +1236,39 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match Ord::cmp(self.a.peek()?, self.b.peek()?) {\n-                Less => {\n-                    self.a.next();\n-                }\n-                Equal => {\n-                    self.b.next();\n-                    return self.a.next();\n-                }\n-                Greater => {\n-                    self.b.next();\n+        match &mut self.inner {\n+            IntersectionInner::Stitch {\n+                small_iter,\n+                other_iter,\n+            } => {\n+                let mut small_next = small_iter.next()?;\n+                let mut other_next = other_iter.next()?;\n+                loop {\n+                    match Ord::cmp(small_next, other_next) {\n+                        Less => small_next = small_iter.next()?,\n+                        Greater => other_next = other_iter.next()?,\n+                        Equal => return Some(small_next),\n+                    }\n                 }\n             }\n+            IntersectionInner::Search {\n+                small_iter,\n+                large_set,\n+            } => loop {\n+                let small_next = small_iter.next()?;\n+                if large_set.contains(&small_next) {\n+                    return Some(small_next);\n+                }\n+            },\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(min(self.a.len(), self.b.len())))\n+        let min_len = match &self.inner {\n+            IntersectionInner::Stitch { small_iter, .. } => small_iter.len(),\n+            IntersectionInner::Search { small_iter, .. } => small_iter.len(),\n+        };\n+        (0, Some(min_len))\n     }\n }\n "}, {"sha": "d52814118b3c7de7c74c47f1d8700a6299be55f6", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=f5fee8fd7d2bd25ac63b9ea44925f9ac2f61c3d2", "patch": "@@ -69,6 +69,20 @@ fn test_intersection() {\n     check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n                        &[2, 11, 77, -9, -42, 5, 3],\n                        &[3, 5, 11, 77]);\n+    let large = (0..1000).collect::<Vec<_>>();\n+    check_intersection(&[], &large, &[]);\n+    check_intersection(&large, &[], &[]);\n+    check_intersection(&[-1], &large, &[]);\n+    check_intersection(&large, &[-1], &[]);\n+    check_intersection(&[0], &large, &[0]);\n+    check_intersection(&large, &[0], &[0]);\n+    check_intersection(&[999], &large, &[999]);\n+    check_intersection(&large, &[999], &[999]);\n+    check_intersection(&[1000], &large, &[]);\n+    check_intersection(&large, &[1000], &[]);\n+    check_intersection(&[11, 5000, 1, 3, 77, 8924, 103],\n+                       &large,\n+                       &[1, 3, 11, 77, 103]);\n }\n \n #[test]\n@@ -84,6 +98,18 @@ fn test_difference() {\n     check_difference(&[-5, 11, 22, 33, 40, 42],\n                      &[-12, -5, 14, 23, 34, 38, 39, 50],\n                      &[11, 22, 33, 40, 42]);\n+    let large = (0..1000).collect::<Vec<_>>();\n+    check_difference(&[], &large, &[]);\n+    check_difference(&[-1], &large, &[-1]);\n+    check_difference(&[0], &large, &[]);\n+    check_difference(&[999], &large, &[]);\n+    check_difference(&[1000], &large, &[1000]);\n+    check_difference(&[11, 5000, 1, 3, 77, 8924, 103],\n+                     &large,\n+                     &[5000, 8924]);\n+    check_difference(&large, &[], &large);\n+    check_difference(&large, &[-1], &large);\n+    check_difference(&large, &[1000], &large);\n }\n \n #[test]\n@@ -114,6 +140,41 @@ fn test_union() {\n                 &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n }\n \n+#[test]\n+// Only tests the simple function definition with respect to intersection\n+fn test_is_disjoint() {\n+    let one = [1].into_iter().collect::<BTreeSet<_>>();\n+    let two = [2].into_iter().collect::<BTreeSet<_>>();\n+    assert!(one.is_disjoint(&two));\n+}\n+\n+#[test]\n+// Also tests the trivial function definition of is_superset\n+fn test_is_subset() {\n+    fn is_subset(a: &[i32], b: &[i32]) -> bool {\n+        let set_a = a.iter().collect::<BTreeSet<_>>();\n+        let set_b = b.iter().collect::<BTreeSet<_>>();\n+        set_a.is_subset(&set_b)\n+    }\n+\n+    assert_eq!(is_subset(&[], &[]), true);\n+    assert_eq!(is_subset(&[], &[1, 2]), true);\n+    assert_eq!(is_subset(&[0], &[1, 2]), false);\n+    assert_eq!(is_subset(&[1], &[1, 2]), true);\n+    assert_eq!(is_subset(&[2], &[1, 2]), true);\n+    assert_eq!(is_subset(&[3], &[1, 2]), false);\n+    assert_eq!(is_subset(&[1, 2], &[1]), false);\n+    assert_eq!(is_subset(&[1, 2], &[1, 2]), true);\n+    assert_eq!(is_subset(&[1, 2], &[2, 3]), false);\n+    let large = (0..1000).collect::<Vec<_>>();\n+    assert_eq!(is_subset(&[], &large), true);\n+    assert_eq!(is_subset(&large, &[]), false);\n+    assert_eq!(is_subset(&[-1], &large), false);\n+    assert_eq!(is_subset(&[0], &large), true);\n+    assert_eq!(is_subset(&[1, 2], &large), true);\n+    assert_eq!(is_subset(&[999, 1000], &large), false);\n+}\n+\n #[test]\n fn test_zip() {\n     let mut x = BTreeSet::new();"}]}