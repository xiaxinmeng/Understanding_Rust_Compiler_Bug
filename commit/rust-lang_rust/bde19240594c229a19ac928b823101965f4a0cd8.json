{"sha": "bde19240594c229a19ac928b823101965f4a0cd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZTE5MjQwNTk0YzIyOWExOWFjOTI4YjgyMzEwMTk2NWY0YTBjZDg=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-07-06T19:27:55Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-08-16T15:11:18Z"}, "message": "Add new_uninit_slice and assume_init on Box, Rc, and Arc of [T]", "tree": {"sha": "72c4192dd43c6ad8fc0044f8652d7cc71b5e5296", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72c4192dd43c6ad8fc0044f8652d7cc71b5e5296"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bde19240594c229a19ac928b823101965f4a0cd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bde19240594c229a19ac928b823101965f4a0cd8", "html_url": "https://github.com/rust-lang/rust/commit/bde19240594c229a19ac928b823101965f4a0cd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bde19240594c229a19ac928b823101965f4a0cd8/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "html_url": "https://github.com/rust-lang/rust/commit/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb"}], "stats": {"total": 270, "additions": 256, "deletions": 14}, "files": [{"sha": "a759260bd8f780a5fa4331e6e3690c0587c9b81d", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bde19240594c229a19ac928b823101965f4a0cd8/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde19240594c229a19ac928b823101965f4a0cd8/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=bde19240594c229a19ac928b823101965f4a0cd8", "patch": "@@ -91,6 +91,7 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n+use core::slice;\n use core::task::{Context, Poll};\n \n use crate::alloc;\n@@ -135,7 +136,7 @@ impl<T> Box<T> {\n     ///     // Deferred initialization:\n     ///     five.as_mut_ptr().write(5);\n     ///\n-    ///     Box::assume_init(five)\n+    ///     five.assume_init()\n     /// };\n     ///\n     /// assert_eq!(*five, 5)\n@@ -148,6 +149,35 @@ impl<T> Box<T> {\n         Box(unique.cast())\n     }\n \n+    /// Construct a new boxed slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<u32>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n+        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let ptr = unsafe { alloc::alloc(layout) };\n+        let unique = Unique::new(ptr).unwrap_or_else(|| alloc::handle_alloc_error(layout));\n+        let slice = unsafe { slice::from_raw_parts_mut(unique.cast().as_ptr(), len) };\n+        Box(Unique::from(slice))\n+    }\n+\n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -179,15 +209,51 @@ impl<T> Box<mem::MaybeUninit<T>> {\n     ///     // Deferred initialization:\n     ///     five.as_mut_ptr().write(5);\n     ///\n-    ///     Box::assume_init(five)\n+    ///     five.assume_init()\n     /// };\n     ///\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"0\")]\n     #[inline]\n-    pub unsafe fn assume_init(this: Self) -> Box<T> {\n-        Box(Box::into_unique(this).cast())\n+    pub unsafe fn assume_init(self) -> Box<T> {\n+        Box(Box::into_unique(self).cast())\n+    }\n+}\n+\n+impl<T> Box<[mem::MaybeUninit<T>]> {\n+    /// Convert to `Box<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the values\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<u32>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<[T]> {\n+        Box(Unique::new_unchecked(Box::into_raw(self) as _))\n     }\n }\n "}, {"sha": "404c86a24da7bbd131d663dd71a8e1e30aaba83d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 93, "deletions": 5, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/bde19240594c229a19ac928b823101965f4a0cd8/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde19240594c229a19ac928b823101965f4a0cd8/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bde19240594c229a19ac928b823101965f4a0cd8", "patch": "@@ -343,7 +343,7 @@ impl<T> Rc<T> {\n     ///     // Deferred initialization:\n     ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n     ///\n-    ///     Rc::assume_init(five)\n+    ///     five.assume_init()\n     /// };\n     ///\n     /// assert_eq!(*five, 5)\n@@ -364,6 +364,50 @@ impl<T> Rc<T> {\n         }\n     }\n \n+    /// Construct a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<u32>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n+        let data_layout = Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let (layout, offset) = Layout::new::<RcBox<()>>().extend(data_layout).unwrap();\n+        unsafe {\n+            let allocated_ptr = Global.alloc(layout)\n+                .unwrap_or_else(|_| handle_alloc_error(layout))\n+                .as_ptr();\n+            let data_ptr = allocated_ptr.add(offset) as *mut mem::MaybeUninit<T>;\n+            let slice: *mut [mem::MaybeUninit<T>] = from_raw_parts_mut(data_ptr, len);\n+            let wide_ptr = slice as *mut RcBox<[mem::MaybeUninit<T>]>;\n+            let wide_ptr = set_data_ptr(wide_ptr, allocated_ptr);\n+            ptr::write(&mut (*wide_ptr).strong, Cell::new(1));\n+            ptr::write(&mut (*wide_ptr).weak, Cell::new(1));\n+            Rc {\n+                ptr: NonNull::new_unchecked(wide_ptr),\n+                phantom: PhantomData,\n+            }\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -439,16 +483,60 @@ impl<T> Rc<mem::MaybeUninit<T>> {\n     ///     // Deferred initialization:\n     ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n     ///\n-    ///     Rc::assume_init(five)\n+    ///     five.assume_init()\n     /// };\n     ///\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"0\")]\n     #[inline]\n-    pub unsafe fn assume_init(this: Self) -> Rc<T> {\n-        let ptr = this.ptr.cast();\n-        mem::forget(this);\n+    pub unsafe fn assume_init(self) -> Rc<T> {\n+        let ptr = self.ptr.cast();\n+        mem::forget(self);\n+        Rc {\n+            ptr,\n+            phantom: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<T> Rc<[mem::MaybeUninit<T>]> {\n+    /// Convert to `Rc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<u32>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<[T]> {\n+        let ptr = NonNull::new_unchecked(self.ptr.as_ptr() as _);\n+        mem::forget(self);\n         Rc {\n             ptr,\n             phantom: PhantomData,"}, {"sha": "3f47b9e6c7daee895ce8f295a55607a8e09898c1", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 93, "deletions": 5, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/bde19240594c229a19ac928b823101965f4a0cd8/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde19240594c229a19ac928b823101965f4a0cd8/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=bde19240594c229a19ac928b823101965f4a0cd8", "patch": "@@ -327,7 +327,7 @@ impl<T> Arc<T> {\n     ///     // Deferred initialization:\n     ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n     ///\n-    ///     Arc::assume_init(five)\n+    ///     five.assume_init()\n     /// };\n     ///\n     /// assert_eq!(*five, 5)\n@@ -348,6 +348,50 @@ impl<T> Arc<T> {\n         }\n     }\n \n+    /// Construct a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<u32>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n+        let data_layout = Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let (layout, offset) = Layout::new::<ArcInner<()>>().extend(data_layout).unwrap();\n+        unsafe {\n+            let allocated_ptr = Global.alloc(layout)\n+                .unwrap_or_else(|_| handle_alloc_error(layout))\n+                .as_ptr();\n+            let data_ptr = allocated_ptr.add(offset) as *mut mem::MaybeUninit<T>;\n+            let slice: *mut [mem::MaybeUninit<T>] = from_raw_parts_mut(data_ptr, len);\n+            let wide_ptr = slice as *mut ArcInner<[mem::MaybeUninit<T>]>;\n+            let wide_ptr = set_data_ptr(wide_ptr, allocated_ptr);\n+            ptr::write(&mut (*wide_ptr).strong, atomic::AtomicUsize::new(1));\n+            ptr::write(&mut (*wide_ptr).weak, atomic::AtomicUsize::new(1));\n+            Arc {\n+                ptr: NonNull::new_unchecked(wide_ptr),\n+                phantom: PhantomData,\n+            }\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n     /// `data` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -423,16 +467,60 @@ impl<T> Arc<mem::MaybeUninit<T>> {\n     ///     // Deferred initialization:\n     ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n     ///\n-    ///     Arc::assume_init(five)\n+    ///     five.assume_init()\n     /// };\n     ///\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"0\")]\n     #[inline]\n-    pub unsafe fn assume_init(this: Self) -> Arc<T> {\n-        let ptr = this.ptr.cast();\n-        mem::forget(this);\n+    pub unsafe fn assume_init(self) -> Arc<T> {\n+        let ptr = self.ptr.cast();\n+        mem::forget(self);\n+        Arc {\n+            ptr,\n+            phantom: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<T> Arc<[mem::MaybeUninit<T>]> {\n+    /// Convert to `Arc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<u32>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<[T]> {\n+        let ptr = NonNull::new_unchecked(self.ptr.as_ptr() as _);\n+        mem::forget(self);\n         Arc {\n             ptr,\n             phantom: PhantomData,"}]}