{"sha": "e1dcbefe52d4c5877602a17270cf5a1b6882c232", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZGNiZWZlNTJkNGM1ODc3NjAyYTE3MjcwY2Y1YTFiNjg4MmMyMzI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-07-30T00:06:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-31T14:30:49Z"}, "message": "remove serialize::ebml, add librbml\n\nOur implementation of ebml has diverged from the standard in order\nto better serve the needs of the compiler, so it doesn't make much\nsense to call what we have ebml anyore. Furthermore, our implementation\nis pretty crufty, and should eventually be rewritten into a format\nthat better suits the needs of the compiler. This patch factors out\nserialize::ebml into librbml, otherwise known as the Really Bad\nMarkup Language. This is a stopgap library that shouldn't be used\nby end users, and will eventually be replaced by something better.\n\n[breaking-change]", "tree": {"sha": "d28cb87692062adc2f25336573e7937289f2e259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d28cb87692062adc2f25336573e7937289f2e259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1dcbefe52d4c5877602a17270cf5a1b6882c232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1dcbefe52d4c5877602a17270cf5a1b6882c232", "html_url": "https://github.com/rust-lang/rust/commit/e1dcbefe52d4c5877602a17270cf5a1b6882c232", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1dcbefe52d4c5877602a17270cf5a1b6882c232/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea1b6376540ed559ed5d95567c613511390bc578", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea1b6376540ed559ed5d95567c613511390bc578", "html_url": "https://github.com/rust-lang/rust/commit/ea1b6376540ed559ed5d95567c613511390bc578"}], "stats": {"total": 1776, "additions": 897, "deletions": 879}, "files": [{"sha": "5bc4505fb05c742bf92f22bf21d65320820112d2", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n-                 url log regex graphviz core rlibc alloc debug rustrt \\\n+                 url log regex graphviz core rbml rlibc alloc debug rustrt \\\n                  unicode\n HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros \\\n \t       rustc_llvm rustc_back\n@@ -71,7 +71,7 @@ DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n DEPS_syntax := std term serialize log fmt_macros debug\n-DEPS_rustc := syntax flate arena serialize getopts \\\n+DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               time log graphviz debug rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n@@ -82,6 +82,7 @@ DEPS_arena := std\n DEPS_graphviz := std\n DEPS_glob := std\n DEPS_serialize := std log\n+DEPS_rbml := std log serialize\n DEPS_term := std log\n DEPS_semver := std\n DEPS_uuid := std serialize\n@@ -91,7 +92,7 @@ DEPS_collections := core alloc unicode\n DEPS_fourcc := rustc syntax std\n DEPS_hexfloat := rustc syntax std\n DEPS_num := std\n-DEPS_test := std getopts serialize term time regex native:rust_test_helpers\n+DEPS_test := std getopts serialize rbml term time regex native:rust_test_helpers\n DEPS_time := std serialize\n DEPS_rand := core\n DEPS_url := std"}, {"sha": "e54410b6a5d0a221182beaebeadf914b43e01195", "filename": "src/librbml/lib.rs", "status": "renamed", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -8,16 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Really Bad Markup Language (rbml) is a temporary measure until we migrate\n+//! the rust object metadata to a better serialization format. It is not\n+//! intended to be used by users.\n+//!\n+//! It is loosely based on the Extensible Binary Markup Language (ebml):\n+//!     http://www.matroska.org/technical/specs/rfc/index.html\n+\n+#![crate_name = \"rbml\"]\n+#![experimental]\n+#![crate_type = \"rlib\"]\n+#![crate_type = \"dylib\"]\n+#![license = \"MIT/ASL2\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/master/\",\n+       html_playground_url = \"http://play.rust-lang.org/\")]\n+#![feature(macro_rules, phase)]\n #![allow(missing_doc)]\n \n+extern crate serialize;\n+\n+#[phase(plugin, link)] extern crate log;\n+#[cfg(test)] extern crate test;\n+\n use std::io;\n use std::str;\n \n-// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n-// cursor model. See the specification here:\n-//     http://www.matroska.org/technical/specs/rfc/index.html\n \n-// Common data structures\n+/// Common data structures\n #[deriving(Clone)]\n pub struct Doc<'a> {\n     pub data: &'a [u8],\n@@ -107,7 +126,7 @@ pub mod reader {\n         Expected };\n \n     pub type DecodeResult<T> = Result<T, Error>;\n-    // ebml reading\n+    // rbml reading\n \n     macro_rules! try_or(\n         ($e:expr, $r:expr) => (\n@@ -637,7 +656,7 @@ pub mod writer {\n \n     pub type EncodeResult = io::IoResult<()>;\n \n-    // ebml writing\n+    // rbml writing\n     pub struct Encoder<'a, W> {\n         pub writer: &'a mut W,\n         size_positions: Vec<uint>,\n@@ -671,7 +690,7 @@ pub mod writer {\n         })\n     }\n \n-    // FIXME (#2741): Provide a function to write the standard ebml header.\n+    // FIXME (#2741): Provide a function to write the standard rbml header.\n     impl<'a, W: Writer + Seek> Encoder<'a, W> {\n         pub fn new(w: &'a mut W) -> Encoder<'a, W> {\n             Encoder {\n@@ -1018,10 +1037,8 @@ pub mod writer {\n \n #[cfg(test)]\n mod tests {\n-    use super::Doc;\n-    use ebml::reader;\n-    use ebml::writer;\n-    use {Encodable, Decodable};\n+    use super::{Doc, reader, writer};\n+    use serialize::{Encodable, Decodable};\n \n     use std::io::{IoError, IoResult, SeekStyle};\n     use std::io;\n@@ -1196,11 +1213,11 @@ mod tests {\n             debug!(\"v == {}\", v);\n             let mut wr = SeekableMemWriter::new();\n             {\n-                let mut ebml_w = writer::Encoder::new(&mut wr);\n-                let _ = v.encode(&mut ebml_w);\n+                let mut rbml_w = writer::Encoder::new(&mut wr);\n+                let _ = v.encode(&mut rbml_w);\n             }\n-            let ebml_doc = Doc::new(wr.get_ref());\n-            let mut deser = reader::Decoder::new(ebml_doc);\n+            let rbml_doc = Doc::new(wr.get_ref());\n+            let mut deser = reader::Decoder::new(rbml_doc);\n             let v1 = Decodable::decode(&mut deser).unwrap();\n             debug!(\"v1 == {}\", v1);\n             assert_eq!(v, v1);\n@@ -1215,9 +1232,8 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     #![allow(non_snake_case_functions)]\n-    extern crate test;\n-    use self::test::Bencher;\n-    use ebml::reader;\n+    use test::Bencher;\n+    use super::reader;\n \n     #[bench]\n     pub fn vuint_at_A_aligned(b: &mut Bencher) {", "previous_filename": "src/libserialize/ebml.rs"}, {"sha": "5385c610350787c39ad8744d3f6bd59ceedaeab4", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -44,6 +44,7 @@ extern crate libc;\n extern crate llvm = \"rustc_llvm\";\n extern crate rustc_back = \"rustc_back\";\n extern crate serialize;\n+extern crate rbml;\n extern crate time;\n #[phase(plugin, link)] extern crate log;\n #[phase(plugin, link)] extern crate syntax;"}, {"sha": "252d19bbb237b838cab6db360de0bcc8b1e3c018", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -20,8 +20,8 @@ use middle::ty;\n use middle::typeck;\n use middle::subst::VecPerParamSpace;\n \n-use serialize::ebml;\n-use serialize::ebml::reader;\n+use rbml;\n+use rbml::reader;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ast_map;\n@@ -218,7 +218,7 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::Polytype {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n-    let all_items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_items);\n+    let all_items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n     let class_doc = expect(tcx.sess.diagnostic(),\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || {"}, {"sha": "c9807a18383e8ef5bc932222cfb55f306e44b121", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -37,8 +37,8 @@ use std::io;\n use std::collections::hashmap::HashMap;\n use std::rc::Rc;\n use std::u64;\n-use serialize::ebml::reader;\n-use serialize::ebml;\n+use rbml::reader;\n+use rbml;\n use serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n@@ -56,8 +56,8 @@ pub type Cmd<'a> = &'a crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n-                   hash: u64) -> Option<ebml::Doc<'a>> {\n+fn lookup_hash<'a>(d: rbml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n+                   hash: u64) -> Option<rbml::Doc<'a>> {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n@@ -80,7 +80,7 @@ fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n }\n \n pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n-                           items: ebml::Doc<'a>) -> Option<ebml::Doc<'a>> {\n+                           items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n             bytes.slice(0u, 4u), 0u, 4u) as ast::NodeId\n@@ -91,17 +91,17 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                 hash::hash(&(item_id as i64)))\n }\n \n-fn find_item<'a>(item_id: ast::NodeId, items: ebml::Doc<'a>) -> ebml::Doc<'a> {\n+fn find_item<'a>(item_id: ast::NodeId, items: rbml::Doc<'a>) -> rbml::Doc<'a> {\n     match maybe_find_item(item_id, items) {\n        None => fail!(\"lookup_item: id not found: {}\", item_id),\n        Some(d) => d\n     }\n }\n \n-// Looks up an item in the given metadata and returns an ebml doc pointing\n+// Looks up an item in the given metadata and returns an rbml doc pointing\n // to the item data.\n-fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> ebml::Doc<'a> {\n-    let items = reader::get_doc(ebml::Doc::new(data), tag_items);\n+fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> rbml::Doc<'a> {\n+    let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n     find_item(item_id, items)\n }\n \n@@ -127,7 +127,7 @@ enum Family {\n     InheritedField         // N\n }\n \n-fn item_family(item: ebml::Doc) -> Family {\n+fn item_family(item: rbml::Doc) -> Family {\n     let fam = reader::get_doc(item, tag_items_data_item_family);\n     match reader::doc_as_u8(fam) as char {\n       'c' => ImmStatic,\n@@ -152,7 +152,7 @@ fn item_family(item: ebml::Doc) -> Family {\n     }\n }\n \n-fn item_visibility(item: ebml::Doc) -> ast::Visibility {\n+fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n     match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n         None => ast::Public,\n         Some(visibility_doc) => {\n@@ -165,7 +165,7 @@ fn item_visibility(item: ebml::Doc) -> ast::Visibility {\n     }\n }\n \n-fn item_method_sort(item: ebml::Doc) -> char {\n+fn item_method_sort(item: rbml::Doc) -> char {\n     let mut ret = 'r';\n     reader::tagged_docs(item, tag_item_trait_method_sort, |doc| {\n         ret = doc.as_str_slice().as_bytes()[0] as char;\n@@ -174,11 +174,11 @@ fn item_method_sort(item: ebml::Doc) -> char {\n     ret\n }\n \n-fn item_symbol(item: ebml::Doc) -> String {\n+fn item_symbol(item: rbml::Doc) -> String {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str().to_string()\n }\n \n-fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n+fn item_parent_item(d: rbml::Doc) -> Option<ast::DefId> {\n     let mut ret = None;\n     reader::tagged_docs(d, tag_items_data_parent_item, |did| {\n         ret = Some(reader::with_doc_data(did, parse_def_id));\n@@ -188,60 +188,60 @@ fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n }\n \n fn item_reqd_and_translated_parent_item(cnum: ast::CrateNum,\n-                                        d: ebml::Doc) -> ast::DefId {\n+                                        d: rbml::Doc) -> ast::DefId {\n     let trait_did = item_parent_item(d).expect(\"item without parent\");\n     ast::DefId { krate: cnum, node: trait_did.node }\n }\n \n-fn item_def_id(d: ebml::Doc, cdata: Cmd) -> ast::DefId {\n+fn item_def_id(d: rbml::Doc, cdata: Cmd) -> ast::DefId {\n     let tagdoc = reader::get_doc(d, tag_def_id);\n     return translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n }\n \n-fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n+fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     reader::maybe_get_doc(d, tag_item_method_provided_source).map(|doc| {\n         translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n     })\n }\n \n-fn each_reexport(d: ebml::Doc, f: |ebml::Doc| -> bool) -> bool {\n+fn each_reexport(d: rbml::Doc, f: |rbml::Doc| -> bool) -> bool {\n     reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n-fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n+fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n         reader::with_doc_data(val_doc, |data| u64::parse_bytes(data, 10u))\n     })\n }\n \n-fn doc_type(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n+fn doc_type(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n-fn doc_method_fty(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n+fn doc_method_fty(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n     parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n-pub fn item_type(_item_id: ast::DefId, item: ebml::Doc,\n+pub fn item_type(_item_id: ast::DefId, item: rbml::Doc,\n                  tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn doc_trait_ref(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n-fn item_trait_ref(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn item_trait_ref(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_ty_param_defs(item: ebml::Doc,\n+fn item_ty_param_defs(item: rbml::Doc,\n                       tcx: &ty::ctxt,\n                       cdata: Cmd,\n                       tag: uint)\n@@ -257,7 +257,7 @@ fn item_ty_param_defs(item: ebml::Doc,\n     bounds\n }\n \n-fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n+fn item_region_param_defs(item_doc: rbml::Doc, cdata: Cmd)\n                           -> subst::VecPerParamSpace<ty::RegionParameterDef>\n {\n     let mut v = subst::VecPerParamSpace::empty();\n@@ -285,7 +285,7 @@ fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n     v\n }\n \n-fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n+fn enum_variant_ids(item: rbml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n     let mut ids: Vec<ast::DefId> = Vec::new();\n     let v = tag_items_data_item_variant;\n     reader::tagged_docs(item, v, |p| {\n@@ -296,7 +296,7 @@ fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n     return ids;\n }\n \n-fn item_path(item_doc: ebml::Doc) -> Vec<ast_map::PathElem> {\n+fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n@@ -319,7 +319,7 @@ fn item_path(item_doc: ebml::Doc) -> Vec<ast_map::PathElem> {\n     result\n }\n \n-fn item_name(intr: &IdentInterner, item: ebml::Doc) -> ast::Ident {\n+fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Ident {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n     match intr.find_equiv(&string) {\n@@ -328,7 +328,7 @@ fn item_name(intr: &IdentInterner, item: ebml::Doc) -> ast::Ident {\n     }\n }\n \n-fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n+fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n@@ -463,7 +463,7 @@ pub enum DefLike {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n-    let root = ebml::Doc::new(cdata.data());\n+    let root = rbml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n@@ -480,7 +480,7 @@ pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Rc<crate_metadata>;\n \n fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                cdata: Cmd,\n-                               item_doc: ebml::Doc,\n+                               item_doc: rbml::Doc,\n                                get_crate_data: GetCrateDataCb,\n                                callback: |DefLike,\n                                           ast::Ident,\n@@ -503,7 +503,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n             None => cdata\n         };\n \n-        let other_crates_items = reader::get_doc(ebml::Doc::new(crate_data.data()), tag_items);\n+        let other_crates_items = reader::get_doc(rbml::Doc::new(crate_data.data()), tag_items);\n \n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n@@ -531,7 +531,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                 |inherent_impl_def_id_doc| {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n                                                cdata);\n-        let items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_items);\n+        let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n         match maybe_find_item(inherent_impl_def_id.node, items) {\n             None => {}\n             Some(inherent_impl_doc) => {\n@@ -596,7 +596,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n             None => cdata\n         };\n \n-        let other_crates_items = reader::get_doc(ebml::Doc::new(crate_data.data()), tag_items);\n+        let other_crates_items = reader::get_doc(rbml::Doc::new(crate_data.data()), tag_items);\n \n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n@@ -623,7 +623,7 @@ pub fn each_child_of_item(intr: Rc<IdentInterner>,\n                           get_crate_data: GetCrateDataCb,\n                           callback: |DefLike, ast::Ident, ast::Visibility|) {\n     // Find the item.\n-    let root_doc = ebml::Doc::new(cdata.data());\n+    let root_doc = rbml::Doc::new(cdata.data());\n     let items = reader::get_doc(root_doc, tag_items);\n     let item_doc = match maybe_find_item(id, items) {\n         None => return,\n@@ -644,7 +644,7 @@ pub fn each_top_level_item_of_crate(intr: Rc<IdentInterner>,\n                                     callback: |DefLike,\n                                                ast::Ident,\n                                                ast::Visibility|) {\n-    let root_doc = ebml::Doc::new(cdata.data());\n+    let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n@@ -663,7 +663,7 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n pub type DecodeInlinedItem<'a> = |cdata: Cmd,\n                                   tcx: &ty::ctxt,\n                                   path: Vec<ast_map::PathElem>,\n-                                  par_doc: ebml::Doc|: 'a\n+                                  par_doc: rbml::Doc|: 'a\n                                   -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n \n pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n@@ -693,7 +693,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n                      tcx: &ty::ctxt) -> Vec<Rc<ty::VariantInfo>> {\n     let data = cdata.data();\n-    let items = reader::get_doc(ebml::Doc::new(data), tag_items);\n+    let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n     let item = find_item(id, items);\n     let mut disr_val = 0;\n     enum_variant_ids(item, cdata).iter().map(|did| {\n@@ -725,7 +725,7 @@ pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n     }).collect()\n }\n \n-fn get_explicit_self(item: ebml::Doc) -> ty::ExplicitSelfCategory {\n+fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n     fn get_mutability(ch: u8) -> ast::Mutability {\n         match ch as char {\n             'i' => ast::MutImmutable,\n@@ -965,7 +965,7 @@ pub fn get_item_attrs(cdata: Cmd,\n }\n \n pub fn get_struct_field_attrs(cdata: Cmd) -> HashMap<ast::NodeId, Vec<ast::Attribute>> {\n-    let data = ebml::Doc::new(cdata.data());\n+    let data = rbml::Doc::new(cdata.data());\n     let fields = reader::get_doc(data, tag_struct_fields);\n     let mut map = HashMap::new();\n     reader::tagged_docs(fields, tag_struct_field, |field| {\n@@ -1023,7 +1023,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     result\n }\n \n-fn get_meta_items(md: ebml::Doc) -> Vec<Gc<ast::MetaItem>> {\n+fn get_meta_items(md: rbml::Doc) -> Vec<Gc<ast::MetaItem>> {\n     let mut items: Vec<Gc<ast::MetaItem>> = Vec::new();\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -1051,7 +1051,7 @@ fn get_meta_items(md: ebml::Doc) -> Vec<Gc<ast::MetaItem>> {\n     return items;\n }\n \n-fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n+fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n     let mut attrs: Vec<ast::Attribute> = Vec::new();\n     match reader::maybe_get_doc(md, tag_attributes) {\n       Some(attrs_d) => {\n@@ -1082,7 +1082,7 @@ fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n     return attrs;\n }\n \n-fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n+fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n                          out: &mut io::Writer) -> io::IoResult<()> {\n     try!(write!(out, \"=Crate Attributes ({})=\\n\", *hash));\n \n@@ -1095,7 +1095,7 @@ fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n }\n \n pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n-    get_attributes(ebml::Doc::new(data))\n+    get_attributes(rbml::Doc::new(data))\n }\n \n #[deriving(Clone)]\n@@ -1107,10 +1107,10 @@ pub struct CrateDep {\n \n pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     let mut deps: Vec<CrateDep> = Vec::new();\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::Doc, tag_: uint) -> String {\n+    fn docstr(doc: rbml::Doc, tag_: uint) -> String {\n         let d = reader::get_doc(doc, tag_);\n         d.as_str_slice().to_string()\n     }\n@@ -1138,27 +1138,27 @@ fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n }\n \n pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_hash).map(|doc| {\n         Svh::new(doc.as_str_slice())\n     })\n }\n \n pub fn get_crate_hash(data: &[u8]) -> Svh {\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n     Svh::new(hashdoc.as_str_slice())\n }\n \n pub fn maybe_get_crate_name(data: &[u8]) -> Option<String> {\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_crate_name).map(|doc| {\n         doc.as_str_slice().to_string()\n     })\n }\n \n pub fn get_crate_triple(data: &[u8]) -> Option<String> {\n-    let cratedoc = ebml::Doc::new(data);\n+    let cratedoc = rbml::Doc::new(data);\n     let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n     triple_doc.map(|s| s.as_str().to_string())\n }\n@@ -1169,7 +1169,7 @@ pub fn get_crate_name(data: &[u8]) -> String {\n \n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n-    let md = ebml::Doc::new(bytes);\n+    let md = rbml::Doc::new(bytes);\n     try!(list_crate_attributes(md, &hash, out));\n     list_crate_deps(bytes, out)\n }\n@@ -1196,7 +1196,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n }\n \n pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n-    let impls_doc = reader::get_doc(ebml::Doc::new(cdata.data()), tag_impls);\n+    let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n     let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n         true\n@@ -1252,7 +1252,7 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n \n pub fn get_native_libraries(cdata: Cmd)\n                             -> Vec<(cstore::NativeLibaryKind, String)> {\n-    let libraries = reader::get_doc(ebml::Doc::new(cdata.data()),\n+    let libraries = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                     tag_native_libraries);\n     let mut result = Vec::new();\n     reader::tagged_docs(libraries, tag_native_libraries_lib, |lib_doc| {\n@@ -1268,12 +1268,12 @@ pub fn get_native_libraries(cdata: Cmd)\n }\n \n pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n-    reader::maybe_get_doc(ebml::Doc::new(data), tag_plugin_registrar_fn)\n+    reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n         .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n }\n \n pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n-    let macros = reader::get_doc(ebml::Doc::new(data),\n+    let macros = reader::get_doc(rbml::Doc::new(data),\n                                  tag_exported_macros);\n     let mut result = Vec::new();\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n@@ -1286,7 +1286,7 @@ pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n pub fn get_dylib_dependency_formats(cdata: Cmd)\n     -> Vec<(ast::CrateNum, cstore::LinkagePreference)>\n {\n-    let formats = reader::get_doc(ebml::Doc::new(cdata.data()),\n+    let formats = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                   tag_dylib_dependency_formats);\n     let mut result = Vec::new();\n \n@@ -1312,7 +1312,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n pub fn get_missing_lang_items(cdata: Cmd)\n     -> Vec<lang_items::LangItem>\n {\n-    let items = reader::get_doc(ebml::Doc::new(cdata.data()), tag_lang_items);\n+    let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_lang_items);\n     let mut result = Vec::new();\n     reader::tagged_docs(items, tag_lang_items_missing, |missing_doc| {\n         let item: lang_items::LangItem =\n@@ -1340,7 +1340,7 @@ pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n \n pub fn get_reachable_extern_fns(cdata: Cmd) -> Vec<ast::DefId> {\n     let mut ret = Vec::new();\n-    let items = reader::get_doc(ebml::Doc::new(cdata.data()),\n+    let items = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                 tag_reachable_extern_fns);\n     reader::tagged_docs(items, tag_reachable_extern_fn_id, |doc| {\n         ret.push(ast::DefId {"}, {"sha": "40da534bfabaf70beef74d573ebadde6c129f591", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 611, "deletions": 611, "changes": 1222, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -52,7 +52,7 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax;\n-use writer = serialize::ebml::writer;\n+use rbml::writer;\n \n /// A borrowed version of ast::InlinedItem.\n pub enum InlinedItemRef<'a> {\n@@ -64,7 +64,7 @@ pub enum InlinedItemRef<'a> {\n pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n \n pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n-                                  ebml_w: &mut Encoder,\n+                                  rbml_w: &mut Encoder,\n                                   ii: InlinedItemRef|: 'a;\n \n pub struct EncodeParams<'a> {\n@@ -92,16 +92,16 @@ pub struct EncodeContext<'a> {\n     pub reachable: &'a NodeSet,\n }\n \n-fn encode_name(ebml_w: &mut Encoder, name: Name) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, token::get_name(name).get());\n+fn encode_name(rbml_w: &mut Encoder, name: Name) {\n+    rbml_w.wr_tagged_str(tag_paths_data_name, token::get_name(name).get());\n }\n \n-fn encode_impl_type_basename(ebml_w: &mut Encoder, name: Ident) {\n-    ebml_w.wr_tagged_str(tag_item_impl_type_basename, token::get_ident(name).get());\n+fn encode_impl_type_basename(rbml_w: &mut Encoder, name: Ident) {\n+    rbml_w.wr_tagged_str(tag_item_impl_type_basename, token::get_ident(name).get());\n }\n \n-pub fn encode_def_id(ebml_w: &mut Encoder, id: DefId) {\n-    ebml_w.wr_tagged_str(tag_def_id, def_to_string(id).as_slice());\n+pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n+    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id).as_slice());\n }\n \n #[deriving(Clone)]\n@@ -110,7 +110,7 @@ struct entry<T> {\n     pos: u64\n }\n \n-fn encode_trait_ref(ebml_w: &mut Encoder,\n+fn encode_trait_ref(rbml_w: &mut Encoder,\n                     ecx: &EncodeContext,\n                     trait_ref: &ty::TraitRef,\n                     tag: uint) {\n@@ -121,31 +121,31 @@ fn encode_trait_ref(ebml_w: &mut Encoder,\n         abbrevs: &ecx.type_abbrevs\n     };\n \n-    ebml_w.start_tag(tag);\n-    tyencode::enc_trait_ref(ebml_w.writer, ty_str_ctxt, trait_ref);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag);\n+    tyencode::enc_trait_ref(rbml_w.writer, ty_str_ctxt, trait_ref);\n+    rbml_w.end_tag();\n }\n \n-fn encode_impl_vtables(ebml_w: &mut Encoder,\n+fn encode_impl_vtables(rbml_w: &mut Encoder,\n                        ecx: &EncodeContext,\n                        vtables: &typeck::vtable_res) {\n-    ebml_w.start_tag(tag_item_impl_vtables);\n-    astencode::encode_vtable_res(ecx, ebml_w, vtables);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_item_impl_vtables);\n+    astencode::encode_vtable_res(ecx, rbml_w, vtables);\n+    rbml_w.end_tag();\n }\n \n // Item info table encoding\n-fn encode_family(ebml_w: &mut Encoder, c: char) {\n-    ebml_w.start_tag(tag_items_data_item_family);\n-    ebml_w.writer.write(&[c as u8]);\n-    ebml_w.end_tag();\n+fn encode_family(rbml_w: &mut Encoder, c: char) {\n+    rbml_w.start_tag(tag_items_data_item_family);\n+    rbml_w.writer.write(&[c as u8]);\n+    rbml_w.end_tag();\n }\n \n pub fn def_to_string(did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.node)\n }\n \n-fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n+fn encode_ty_type_param_defs(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext,\n                              params: &VecPerParamSpace<ty::TypeParameterDef>,\n                              tag: uint) {\n@@ -156,162 +156,162 @@ fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n         abbrevs: &ecx.type_abbrevs\n     };\n     for param in params.iter() {\n-        ebml_w.start_tag(tag);\n-        tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag);\n+        tyencode::enc_type_param_def(rbml_w.writer, ty_str_ctxt, param);\n+        rbml_w.end_tag();\n     }\n }\n \n-fn encode_region_param_defs(ebml_w: &mut Encoder,\n+fn encode_region_param_defs(rbml_w: &mut Encoder,\n                             params: &VecPerParamSpace<ty::RegionParameterDef>) {\n     for param in params.iter() {\n-        ebml_w.start_tag(tag_region_param_def);\n+        rbml_w.start_tag(tag_region_param_def);\n \n-        ebml_w.start_tag(tag_region_param_def_ident);\n-        encode_name(ebml_w, param.name);\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_region_param_def_ident);\n+        encode_name(rbml_w, param.name);\n+        rbml_w.end_tag();\n \n-        ebml_w.wr_tagged_str(tag_region_param_def_def_id,\n+        rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n                              def_to_string(param.def_id).as_slice());\n \n-        ebml_w.wr_tagged_u64(tag_region_param_def_space,\n+        rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n \n-        ebml_w.wr_tagged_u64(tag_region_param_def_index,\n+        rbml_w.wr_tagged_u64(tag_region_param_def_index,\n                              param.index as u64);\n \n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n }\n \n-fn encode_item_variances(ebml_w: &mut Encoder,\n+fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: ast::NodeId) {\n     let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n-    ebml_w.start_tag(tag_item_variances);\n-    v.encode(ebml_w);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_item_variances);\n+    v.encode(rbml_w);\n+    rbml_w.end_tag();\n }\n \n-fn encode_bounds_and_type(ebml_w: &mut Encoder,\n+fn encode_bounds_and_type(rbml_w: &mut Encoder,\n                           ecx: &EncodeContext,\n                           pty: &ty::Polytype) {\n-    encode_ty_type_param_defs(ebml_w, ecx, &pty.generics.types,\n+    encode_ty_type_param_defs(rbml_w, ecx, &pty.generics.types,\n                               tag_items_data_item_ty_param_bounds);\n-    encode_region_param_defs(ebml_w, &pty.generics.regions);\n-    encode_type(ecx, ebml_w, pty.ty);\n+    encode_region_param_defs(rbml_w, &pty.generics.regions);\n+    encode_type(ecx, rbml_w, pty.ty);\n }\n \n-fn encode_variant_id(ebml_w: &mut Encoder, vid: DefId) {\n-    ebml_w.start_tag(tag_items_data_item_variant);\n+fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n+    rbml_w.start_tag(tag_items_data_item_variant);\n     let s = def_to_string(vid);\n-    ebml_w.writer.write(s.as_bytes());\n-    ebml_w.end_tag();\n+    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.end_tag();\n }\n \n pub fn write_closure_type(ecx: &EncodeContext,\n-                          ebml_w: &mut Encoder,\n+                          rbml_w: &mut Encoder,\n                           closure_type: &ty::ClosureTy) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_closure_ty(ebml_w.writer, ty_str_ctxt, closure_type);\n+    tyencode::enc_closure_ty(rbml_w.writer, ty_str_ctxt, closure_type);\n }\n \n pub fn write_type(ecx: &EncodeContext,\n-                  ebml_w: &mut Encoder,\n+                  rbml_w: &mut Encoder,\n                   typ: ty::t) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n+    tyencode::enc_ty(rbml_w.writer, ty_str_ctxt, typ);\n }\n \n fn encode_type(ecx: &EncodeContext,\n-               ebml_w: &mut Encoder,\n+               rbml_w: &mut Encoder,\n                typ: ty::t) {\n-    ebml_w.start_tag(tag_items_data_item_type);\n-    write_type(ecx, ebml_w, typ);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_items_data_item_type);\n+    write_type(ecx, rbml_w, typ);\n+    rbml_w.end_tag();\n }\n \n fn encode_method_fty(ecx: &EncodeContext,\n-                     ebml_w: &mut Encoder,\n+                     rbml_w: &mut Encoder,\n                      typ: &ty::BareFnTy) {\n-    ebml_w.start_tag(tag_item_method_fty);\n+    rbml_w.start_tag(tag_item_method_fty);\n \n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n+    tyencode::enc_bare_fn_ty(rbml_w.writer, ty_str_ctxt, typ);\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_symbol(ecx: &EncodeContext,\n-                 ebml_w: &mut Encoder,\n+                 rbml_w: &mut Encoder,\n                  id: NodeId) {\n-    ebml_w.start_tag(tag_items_data_item_symbol);\n+    rbml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.borrow().find(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={:?}, str={})\", id, *x);\n-            ebml_w.writer.write(x.as_bytes());\n+            rbml_w.writer.write(x.as_bytes());\n         }\n         None => {\n             ecx.diag.handler().bug(\n                 format!(\"encode_symbol: id not found {}\", id).as_slice());\n         }\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_disr_val(_: &EncodeContext,\n-                   ebml_w: &mut Encoder,\n+                   rbml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n-    ebml_w.start_tag(tag_disr_val);\n+    rbml_w.start_tag(tag_disr_val);\n     let s = disr_val.to_string();\n-    ebml_w.writer.write(s.as_bytes());\n-    ebml_w.end_tag();\n+    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: &mut Encoder, id: DefId) {\n-    ebml_w.start_tag(tag_items_data_parent_item);\n+fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n+    rbml_w.start_tag(tag_items_data_parent_item);\n     let s = def_to_string(id);\n-    ebml_w.writer.write(s.as_bytes());\n-    ebml_w.end_tag();\n+    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_struct_fields(ebml_w: &mut Encoder,\n+fn encode_struct_fields(rbml_w: &mut Encoder,\n                         fields: &[ty::field_ty],\n                         origin: DefId) {\n     for f in fields.iter() {\n         if f.name == special_idents::unnamed_field.name {\n-            ebml_w.start_tag(tag_item_unnamed_field);\n+            rbml_w.start_tag(tag_item_unnamed_field);\n         } else {\n-            ebml_w.start_tag(tag_item_field);\n-            encode_name(ebml_w, f.name);\n+            rbml_w.start_tag(tag_item_field);\n+            encode_name(rbml_w, f.name);\n         }\n-        encode_struct_field_family(ebml_w, f.vis);\n-        encode_def_id(ebml_w, f.id);\n-        ebml_w.start_tag(tag_item_field_origin);\n+        encode_struct_field_family(rbml_w, f.vis);\n+        encode_def_id(rbml_w, f.id);\n+        rbml_w.start_tag(tag_item_field_origin);\n         let s = def_to_string(origin);\n-        ebml_w.writer.write(s.as_bytes());\n-        ebml_w.end_tag();\n-        ebml_w.end_tag();\n+        rbml_w.writer.write(s.as_bytes());\n+        rbml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n }\n \n fn encode_enum_variant_info(ecx: &EncodeContext,\n-                            ebml_w: &mut Encoder,\n+                            rbml_w: &mut Encoder,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n                             index: &mut Vec<entry<i64>>) {\n@@ -325,82 +325,82 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n             val: variant.node.id as i64,\n-            pos: ebml_w.writer.tell().unwrap(),\n+            pos: rbml_w.writer.tell().unwrap(),\n         });\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n         match variant.node.kind {\n-            ast::TupleVariantKind(_) => encode_family(ebml_w, 'v'),\n-            ast::StructVariantKind(_) => encode_family(ebml_w, 'V')\n+            ast::TupleVariantKind(_) => encode_family(rbml_w, 'v'),\n+            ast::StructVariantKind(_) => encode_family(rbml_w, 'V')\n         }\n-        encode_name(ebml_w, variant.node.name.name);\n-        encode_parent_item(ebml_w, local_def(id));\n-        encode_visibility(ebml_w, variant.node.vis);\n-        encode_attributes(ebml_w, variant.node.attrs.as_slice());\n+        encode_name(rbml_w, variant.node.name.name);\n+        encode_parent_item(rbml_w, local_def(id));\n+        encode_visibility(rbml_w, variant.node.vis);\n+        encode_attributes(rbml_w, variant.node.attrs.as_slice());\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n-        encode_stability(ebml_w, stab);\n+        encode_stability(rbml_w, stab);\n \n         match variant.node.kind {\n             ast::TupleVariantKind(_) => {},\n             ast::StructVariantKind(_) => {\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n-                                                 ebml_w,\n+                                                 rbml_w,\n                                                  fields.as_slice(),\n                                                  index);\n-                encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n-                encode_index(ebml_w, idx, write_i64);\n+                encode_struct_fields(rbml_w, fields.as_slice(), def_id);\n+                encode_index(rbml_w, idx, write_i64);\n             }\n         }\n         if vi.get(i).disr_val != disr_val {\n-            encode_disr_val(ecx, ebml_w, vi.get(i).disr_val);\n+            encode_disr_val(ecx, rbml_w, vi.get(i).disr_val);\n             disr_val = vi.get(i).disr_val;\n         }\n-        encode_bounds_and_type(ebml_w, ecx,\n+        encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx, def_id));\n \n-        ecx.tcx.map.with_path(variant.node.id, |path| encode_path(ebml_w, path));\n-        ebml_w.end_tag();\n+        ecx.tcx.map.with_path(variant.node.id, |path| encode_path(rbml_w, path));\n+        rbml_w.end_tag();\n         disr_val += 1;\n         i += 1;\n     }\n }\n \n-fn encode_path<PI: Iterator<PathElem> + Clone>(ebml_w: &mut Encoder,\n+fn encode_path<PI: Iterator<PathElem> + Clone>(rbml_w: &mut Encoder,\n                                                mut path: PI) {\n-    ebml_w.start_tag(tag_path);\n-    ebml_w.wr_tagged_u32(tag_path_len, path.clone().count() as u32);\n+    rbml_w.start_tag(tag_path);\n+    rbml_w.wr_tagged_u32(tag_path_len, path.clone().count() as u32);\n     for pe in path {\n         let tag = match pe {\n             ast_map::PathMod(_) => tag_path_elem_mod,\n             ast_map::PathName(_) => tag_path_elem_name\n         };\n-        ebml_w.wr_tagged_str(tag, token::get_name(pe.name()).get());\n+        rbml_w.wr_tagged_str(tag, token::get_name(pe.name()).get());\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_reexported_static_method(ebml_w: &mut Encoder,\n+fn encode_reexported_static_method(rbml_w: &mut Encoder,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n                                    method_ident: Ident) {\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, token::get_ident(method_ident));\n-    ebml_w.start_tag(tag_items_data_item_reexport);\n-    ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    ebml_w.wr_str(def_to_string(method_def_id).as_slice());\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(format!(\"{}::{}\",\n+    rbml_w.start_tag(tag_items_data_item_reexport);\n+    rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n+    rbml_w.wr_str(def_to_string(method_def_id).as_slice());\n+    rbml_w.end_tag();\n+    rbml_w.start_tag(tag_items_data_item_reexport_name);\n+    rbml_w.wr_str(format!(\"{}::{}\",\n                           exp.name,\n                           token::get_ident(method_ident)).as_slice());\n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n-                                         ebml_w: &mut Encoder,\n+                                         rbml_w: &mut Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n     let impl_methods = ecx.tcx.impl_methods.borrow();\n@@ -410,7 +410,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                 for &method_did in impl_methods.get(base_impl_did).iter() {\n                     let m = ty::method(ecx.tcx, method_did);\n                     if m.explicit_self == ty::StaticExplicitSelfCategory {\n-                        encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n+                        encode_reexported_static_method(rbml_w, exp, m.def_id, m.ident);\n                     }\n                 }\n             }\n@@ -422,14 +422,14 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n }\n \n fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n-                                          ebml_w: &mut Encoder,\n+                                          rbml_w: &mut Encoder,\n                                           exp: &middle::resolve::Export2)\n                                           -> bool {\n     match ecx.tcx.trait_methods_cache.borrow().find(&exp.def_id) {\n         Some(methods) => {\n             for m in methods.iter() {\n                 if m.explicit_self == ty::StaticExplicitSelfCategory {\n-                    encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n+                    encode_reexported_static_method(rbml_w, exp, m.def_id, m.ident);\n                 }\n             }\n \n@@ -440,7 +440,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n }\n \n fn encode_reexported_static_methods(ecx: &EncodeContext,\n-                                    ebml_w: &mut Encoder,\n+                                    rbml_w: &mut Encoder,\n                                     mod_path: PathElems,\n                                     exp: &middle::resolve::Export2) {\n     match ecx.tcx.map.find(exp.def_id.node) {\n@@ -469,8 +469,8 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n             // but not yet for Foo.\n             //\n             if path_differs || original_name.get() != exp.name.as_slice() {\n-                if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n-                    if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n+                if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n+                    if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n                         debug!(\"(encode reexported static methods) {} \\\n                                  [trait]\",\n                                 original_name);\n@@ -520,7 +520,7 @@ fn each_auxiliary_node_id(item: Gc<Item>, callback: |NodeId| -> bool) -> bool {\n }\n \n fn encode_reexports(ecx: &EncodeContext,\n-                    ebml_w: &mut Encoder,\n+                    rbml_w: &mut Encoder,\n                     id: NodeId,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n@@ -534,15 +534,15 @@ fn encode_reexports(ecx: &EncodeContext,\n                        exp.def_id.krate,\n                        exp.def_id.node,\n                        id);\n-                ebml_w.start_tag(tag_items_data_item_reexport);\n-                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                ebml_w.wr_str(def_to_string(exp.def_id).as_slice());\n-                ebml_w.end_tag();\n-                ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(exp.name.as_slice());\n-                ebml_w.end_tag();\n-                ebml_w.end_tag();\n-                encode_reexported_static_methods(ecx, ebml_w, path.clone(), exp);\n+                rbml_w.start_tag(tag_items_data_item_reexport);\n+                rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n+                rbml_w.wr_str(def_to_string(exp.def_id).as_slice());\n+                rbml_w.end_tag();\n+                rbml_w.start_tag(tag_items_data_item_reexport_name);\n+                rbml_w.wr_str(exp.name.as_slice());\n+                rbml_w.end_tag();\n+                rbml_w.end_tag();\n+                encode_reexported_static_methods(ecx, rbml_w, path.clone(), exp);\n             }\n         }\n         None => {\n@@ -553,30 +553,30 @@ fn encode_reexports(ecx: &EncodeContext,\n }\n \n fn encode_info_for_mod(ecx: &EncodeContext,\n-                       ebml_w: &mut Encoder,\n+                       rbml_w: &mut Encoder,\n                        md: &Mod,\n                        attrs: &[Attribute],\n                        id: NodeId,\n                        path: PathElems,\n                        name: Ident,\n                        vis: Visibility) {\n-    ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(id));\n-    encode_family(ebml_w, 'm');\n-    encode_name(ebml_w, name.name);\n+    rbml_w.start_tag(tag_items_data_item);\n+    encode_def_id(rbml_w, local_def(id));\n+    encode_family(rbml_w, 'm');\n+    encode_name(rbml_w, name.name);\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n     for item in md.items.iter() {\n-        ebml_w.start_tag(tag_mod_child);\n-        ebml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_mod_child);\n+        rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n+        rbml_w.end_tag();\n \n         each_auxiliary_node_id(*item, |auxiliary_node_id| {\n-            ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_string(local_def(\n+            rbml_w.start_tag(tag_mod_child);\n+            rbml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());\n-            ebml_w.end_tag();\n+            rbml_w.end_tag();\n             true\n         });\n \n@@ -588,100 +588,100 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                         token::get_ident(ident),\n                         did, ecx.tcx.map.node_to_string(did));\n \n-                ebml_w.start_tag(tag_mod_impl);\n-                ebml_w.wr_str(def_to_string(local_def(did)).as_slice());\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_mod_impl);\n+                rbml_w.wr_str(def_to_string(local_def(did)).as_slice());\n+                rbml_w.end_tag();\n             }\n             _ => {}\n         }\n     }\n \n-    encode_path(ebml_w, path.clone());\n-    encode_visibility(ebml_w, vis);\n+    encode_path(rbml_w, path.clone());\n+    encode_visibility(rbml_w, vis);\n \n     let stab = stability::lookup(ecx.tcx, ast_util::local_def(id));\n-    encode_stability(ebml_w, stab);\n+    encode_stability(rbml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-        encode_reexports(ecx, ebml_w, id, path);\n+        encode_reexports(ecx, rbml_w, id, path);\n     }\n-    encode_attributes(ebml_w, attrs);\n+    encode_attributes(rbml_w, attrs);\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_struct_field_family(ebml_w: &mut Encoder,\n+fn encode_struct_field_family(rbml_w: &mut Encoder,\n                               visibility: Visibility) {\n-    encode_family(ebml_w, match visibility {\n+    encode_family(rbml_w, match visibility {\n         Public => 'g',\n         Inherited => 'N'\n     });\n }\n \n-fn encode_visibility(ebml_w: &mut Encoder, visibility: Visibility) {\n-    ebml_w.start_tag(tag_items_data_item_visibility);\n+fn encode_visibility(rbml_w: &mut Encoder, visibility: Visibility) {\n+    rbml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n         Public => 'y',\n         Inherited => 'i',\n     };\n-    ebml_w.wr_str(ch.to_string().as_slice());\n-    ebml_w.end_tag();\n+    rbml_w.wr_str(ch.to_string().as_slice());\n+    rbml_w.end_tag();\n }\n \n-fn encode_explicit_self(ebml_w: &mut Encoder,\n+fn encode_explicit_self(rbml_w: &mut Encoder,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n-    ebml_w.start_tag(tag_item_trait_method_explicit_self);\n+    rbml_w.start_tag(tag_item_trait_method_explicit_self);\n \n     // Encode the base self type.\n     match *explicit_self {\n         ty::StaticExplicitSelfCategory => {\n-            ebml_w.writer.write(&[ 's' as u8 ]);\n+            rbml_w.writer.write(&[ 's' as u8 ]);\n         }\n         ty::ByValueExplicitSelfCategory => {\n-            ebml_w.writer.write(&[ 'v' as u8 ]);\n+            rbml_w.writer.write(&[ 'v' as u8 ]);\n         }\n         ty::ByBoxExplicitSelfCategory => {\n-            ebml_w.writer.write(&[ '~' as u8 ]);\n+            rbml_w.writer.write(&[ '~' as u8 ]);\n         }\n         ty::ByReferenceExplicitSelfCategory(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n-            ebml_w.writer.write(&['&' as u8]);\n-            encode_mutability(ebml_w, m);\n+            rbml_w.writer.write(&['&' as u8]);\n+            encode_mutability(rbml_w, m);\n         }\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n \n-    fn encode_mutability(ebml_w: &mut Encoder,\n+    fn encode_mutability(rbml_w: &mut Encoder,\n                          m: ast::Mutability) {\n         match m {\n-            MutImmutable => { ebml_w.writer.write(&[ 'i' as u8 ]); }\n-            MutMutable => { ebml_w.writer.write(&[ 'm' as u8 ]); }\n+            MutImmutable => { rbml_w.writer.write(&[ 'i' as u8 ]); }\n+            MutMutable => { rbml_w.writer.write(&[ 'm' as u8 ]); }\n         }\n     }\n }\n \n-fn encode_method_sort(ebml_w: &mut Encoder, sort: char) {\n-    ebml_w.start_tag(tag_item_trait_method_sort);\n-    ebml_w.writer.write(&[ sort as u8 ]);\n-    ebml_w.end_tag();\n+fn encode_method_sort(rbml_w: &mut Encoder, sort: char) {\n+    rbml_w.start_tag(tag_item_trait_method_sort);\n+    rbml_w.writer.write(&[ sort as u8 ]);\n+    rbml_w.end_tag();\n }\n \n-fn encode_provided_source(ebml_w: &mut Encoder,\n+fn encode_provided_source(rbml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n     for source in source_opt.iter() {\n-        ebml_w.start_tag(tag_item_method_provided_source);\n+        rbml_w.start_tag(tag_item_method_provided_source);\n         let s = def_to_string(*source);\n-        ebml_w.writer.write(s.as_bytes());\n-        ebml_w.end_tag();\n+        rbml_w.writer.write(s.as_bytes());\n+        rbml_w.end_tag();\n     }\n }\n \n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n-                          ebml_w: &mut Encoder,\n+                          rbml_w: &mut Encoder,\n                           fields: &[ty::field_ty],\n                           global_index: &mut Vec<entry<i64>>)\n                           -> Vec<entry<i64>> {\n@@ -695,86 +695,86 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         let nm = field.name;\n         let id = field.id.node;\n \n-        index.push(entry {val: id as i64, pos: ebml_w.writer.tell().unwrap()});\n+        index.push(entry {val: id as i64, pos: rbml_w.writer.tell().unwrap()});\n         global_index.push(entry {\n             val: id as i64,\n-            pos: ebml_w.writer.tell().unwrap(),\n+            pos: rbml_w.writer.tell().unwrap(),\n         });\n-        ebml_w.start_tag(tag_items_data_item);\n+        rbml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n                token::get_name(nm), id);\n-        encode_struct_field_family(ebml_w, field.vis);\n-        encode_name(ebml_w, nm);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n-        encode_def_id(ebml_w, local_def(id));\n+        encode_struct_field_family(rbml_w, field.vis);\n+        encode_name(rbml_w, nm);\n+        encode_type(ecx, rbml_w, node_id_to_type(tcx, id));\n+        encode_def_id(rbml_w, local_def(id));\n \n         let stab = stability::lookup(ecx.tcx, field.id);\n-        encode_stability(ebml_w, stab);\n+        encode_stability(rbml_w, stab);\n \n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n     index\n }\n \n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n-                               ebml_w: &mut Encoder,\n+                               rbml_w: &mut Encoder,\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n                                index: &mut Vec<entry<i64>>,\n                                struct_id: NodeId) {\n     index.push(entry {\n         val: ctor_id as i64,\n-        pos: ebml_w.writer.tell().unwrap(),\n+        pos: rbml_w.writer.tell().unwrap(),\n     });\n \n-    ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(ctor_id));\n-    encode_family(ebml_w, 'f');\n-    encode_bounds_and_type(ebml_w, ecx,\n+    rbml_w.start_tag(tag_items_data_item);\n+    encode_def_id(rbml_w, local_def(ctor_id));\n+    encode_family(rbml_w, 'f');\n+    encode_bounds_and_type(rbml_w, ecx,\n                            &lookup_item_type(ecx.tcx, local_def(ctor_id)));\n-    encode_name(ebml_w, name.name);\n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, ctor_id));\n-    ecx.tcx.map.with_path(ctor_id, |path| encode_path(ebml_w, path));\n-    encode_parent_item(ebml_w, local_def(struct_id));\n+    encode_name(rbml_w, name.name);\n+    encode_type(ecx, rbml_w, node_id_to_type(ecx.tcx, ctor_id));\n+    ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n+    encode_parent_item(rbml_w, local_def(struct_id));\n \n     if ecx.item_symbols.borrow().contains_key(&ctor_id) {\n-        encode_symbol(ecx, ebml_w, ctor_id);\n+        encode_symbol(ecx, rbml_w, ctor_id);\n     }\n \n     let stab = stability::lookup(ecx.tcx, ast_util::local_def(ctor_id));\n-    encode_stability(ebml_w, stab);\n+    encode_stability(rbml_w, stab);\n \n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n     // the tuple struct definition, but without this there is no way for them to tell that\n     // they actually have a ctor rather than a normal function\n-    ebml_w.start_tag(tag_items_data_item_is_tuple_struct_ctor);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_items_data_item_is_tuple_struct_ctor);\n+    rbml_w.end_tag();\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_method_ty_fields(ecx: &EncodeContext,\n-                           ebml_w: &mut Encoder,\n+                           rbml_w: &mut Encoder,\n                            method_ty: &ty::Method) {\n-    encode_def_id(ebml_w, method_ty.def_id);\n-    encode_name(ebml_w, method_ty.ident.name);\n-    encode_ty_type_param_defs(ebml_w, ecx, &method_ty.generics.types,\n+    encode_def_id(rbml_w, method_ty.def_id);\n+    encode_name(rbml_w, method_ty.ident.name);\n+    encode_ty_type_param_defs(rbml_w, ecx, &method_ty.generics.types,\n                               tag_item_method_tps);\n-    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n-    encode_visibility(ebml_w, method_ty.vis);\n-    encode_explicit_self(ebml_w, &method_ty.explicit_self);\n+    encode_method_fty(ecx, rbml_w, &method_ty.fty);\n+    encode_visibility(rbml_w, method_ty.vis);\n+    encode_explicit_self(rbml_w, &method_ty.explicit_self);\n     let fn_style = method_ty.fty.fn_style;\n     match method_ty.explicit_self {\n         ty::StaticExplicitSelfCategory => {\n-            encode_family(ebml_w, fn_style_static_method_family(fn_style));\n+            encode_family(rbml_w, fn_style_static_method_family(fn_style));\n         }\n-        _ => encode_family(ebml_w, style_fn_family(fn_style))\n+        _ => encode_family(rbml_w, style_fn_family(fn_style))\n     }\n-    encode_provided_source(ebml_w, method_ty.provided_source);\n+    encode_provided_source(rbml_w, method_ty.provided_source);\n }\n \n fn encode_info_for_method(ecx: &EncodeContext,\n-                          ebml_w: &mut Encoder,\n+                          rbml_w: &mut Encoder,\n                           m: &ty::Method,\n                           impl_path: PathElems,\n                           is_default_impl: bool,\n@@ -783,65 +783,65 @@ fn encode_info_for_method(ecx: &EncodeContext,\n \n     debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            token::get_ident(m.ident));\n-    ebml_w.start_tag(tag_items_data_item);\n+    rbml_w.start_tag(tag_items_data_item);\n \n-    encode_method_ty_fields(ecx, ebml_w, m);\n-    encode_parent_item(ebml_w, local_def(parent_id));\n+    encode_method_ty_fields(ecx, rbml_w, m);\n+    encode_parent_item(rbml_w, local_def(parent_id));\n \n     let stab = stability::lookup(ecx.tcx, m.def_id);\n-    encode_stability(ebml_w, stab);\n+    encode_stability(rbml_w, stab);\n \n     // The type for methods gets encoded twice, which is unfortunate.\n     let pty = lookup_item_type(ecx.tcx, m.def_id);\n-    encode_bounds_and_type(ebml_w, ecx, &pty);\n+    encode_bounds_and_type(rbml_w, ecx, &pty);\n \n     let elem = ast_map::PathName(m.ident.name);\n-    encode_path(ebml_w, impl_path.chain(Some(elem).move_iter()));\n+    encode_path(rbml_w, impl_path.chain(Some(elem).move_iter()));\n     match ast_method_opt {\n         Some(ast_method) => {\n-            encode_attributes(ebml_w, ast_method.attrs.as_slice())\n+            encode_attributes(rbml_w, ast_method.attrs.as_slice())\n         }\n         None => ()\n     }\n \n     for &ast_method in ast_method_opt.iter() {\n         let any_types = !pty.generics.types.is_empty();\n         if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n-            encode_inlined_item(ecx, ebml_w,\n+            encode_inlined_item(ecx, rbml_w,\n                                 IIMethodRef(local_def(parent_id), false,\n                                             &*ast_method));\n         } else {\n-            encode_symbol(ecx, ebml_w, m.def_id.node);\n+            encode_symbol(ecx, rbml_w, m.def_id.node);\n         }\n-        encode_method_argument_names(ebml_w, &*ast_method.pe_fn_decl());\n+        encode_method_argument_names(rbml_w, &*ast_method.pe_fn_decl());\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_method_argument_names(ebml_w: &mut Encoder,\n+fn encode_method_argument_names(rbml_w: &mut Encoder,\n                                 decl: &ast::FnDecl) {\n-    ebml_w.start_tag(tag_method_argument_names);\n+    rbml_w.start_tag(tag_method_argument_names);\n     for arg in decl.inputs.iter() {\n-        ebml_w.start_tag(tag_method_argument_name);\n+        rbml_w.start_tag(tag_method_argument_name);\n         match arg.pat.node {\n             ast::PatIdent(_, ref path1, _) => {\n                 let name = token::get_ident(path1.node);\n-                ebml_w.writer.write(name.get().as_bytes());\n+                rbml_w.writer.write(name.get().as_bytes());\n             }\n             _ => {}\n         }\n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_inlined_item(ecx: &EncodeContext,\n-                       ebml_w: &mut Encoder,\n+                       rbml_w: &mut Encoder,\n                        ii: InlinedItemRef) {\n     let mut eii = ecx.encode_inlined_item.borrow_mut();\n     let eii: &mut EncodeInlinedItem = &mut *eii;\n-    (*eii)(ecx, ebml_w, ii)\n+    (*eii)(ecx, rbml_w, ii)\n }\n \n fn style_fn_family(s: FnStyle) -> char {\n@@ -869,57 +869,57 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n \n // Encodes the inherent implementations of a structure, enumeration, or trait.\n fn encode_inherent_implementations(ecx: &EncodeContext,\n-                                   ebml_w: &mut Encoder,\n+                                   rbml_w: &mut Encoder,\n                                    def_id: DefId) {\n     match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n         None => {}\n         Some(implementations) => {\n             for &impl_def_id in implementations.borrow().iter() {\n-                ebml_w.start_tag(tag_items_data_item_inherent_impl);\n-                encode_def_id(ebml_w, impl_def_id);\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_items_data_item_inherent_impl);\n+                encode_def_id(rbml_w, impl_def_id);\n+                rbml_w.end_tag();\n             }\n         }\n     }\n }\n \n // Encodes the implementations of a trait defined in this crate.\n fn encode_extension_implementations(ecx: &EncodeContext,\n-                                    ebml_w: &mut Encoder,\n+                                    rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n     match ecx.tcx.trait_impls.borrow().find(&trait_def_id) {\n         None => {}\n         Some(implementations) => {\n             for &impl_def_id in implementations.borrow().iter() {\n-                ebml_w.start_tag(tag_items_data_item_extension_impl);\n-                encode_def_id(ebml_w, impl_def_id);\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_items_data_item_extension_impl);\n+                encode_def_id(rbml_w, impl_def_id);\n+                rbml_w.end_tag();\n             }\n         }\n     }\n }\n \n-fn encode_stability(ebml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {\n+fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {\n     stab_opt.map(|stab| {\n-        ebml_w.start_tag(tag_items_data_item_stability);\n-        stab.encode(ebml_w).unwrap();\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_items_data_item_stability);\n+        stab.encode(rbml_w).unwrap();\n+        rbml_w.end_tag();\n     });\n }\n \n fn encode_info_for_item(ecx: &EncodeContext,\n-                        ebml_w: &mut Encoder,\n+                        rbml_w: &mut Encoder,\n                         item: &Item,\n                         index: &mut Vec<entry<i64>>,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &Item, ebml_w: &Encoder,\n+    fn add_to_index(item: &Item, rbml_w: &Encoder,\n                     index: &mut Vec<entry<i64>>) {\n         index.push(entry {\n             val: item.id as i64,\n-            pos: ebml_w.writer.tell().unwrap(),\n+            pos: rbml_w.writer.tell().unwrap(),\n         });\n     }\n \n@@ -931,52 +931,52 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n     match item.node {\n       ItemStatic(_, m, _) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n         if m == ast::MutMutable {\n-            encode_family(ebml_w, 'b');\n+            encode_family(rbml_w, 'b');\n         } else {\n-            encode_family(ebml_w, 'c');\n+            encode_family(rbml_w, 'c');\n         }\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_symbol(ecx, ebml_w, item.id);\n-        encode_name(ebml_w, item.ident.name);\n-        encode_path(ebml_w, path);\n+        encode_type(ecx, rbml_w, node_id_to_type(tcx, item.id));\n+        encode_symbol(ecx, rbml_w, item.id);\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n \n         let inlineable = !ecx.non_inlineable_statics.borrow().contains(&item.id);\n \n         if inlineable {\n-            encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n       }\n       ItemFn(ref decl, fn_style, _, ref generics, _) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, style_fn_family(fn_style));\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, style_fn_family(fn_style));\n         let tps_len = generics.ty_params.len();\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ebml_w, item.ident.name);\n-        encode_path(ebml_w, path);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n         if tps_len > 0u || should_inline(item.attrs.as_slice()) {\n-            encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         } else {\n-            encode_symbol(ecx, ebml_w, item.id);\n+            encode_symbol(ecx, rbml_w, item.id);\n         }\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        encode_method_argument_names(ebml_w, &**decl);\n-        ebml_w.end_tag();\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        encode_method_argument_names(rbml_w, &**decl);\n+        rbml_w.end_tag();\n       }\n       ItemMod(ref m) => {\n-        add_to_index(item, ebml_w, index);\n+        add_to_index(item, rbml_w, index);\n         encode_info_for_mod(ecx,\n-                            ebml_w,\n+                            rbml_w,\n                             m,\n                             item.attrs.as_slice(),\n                             item.id,\n@@ -985,60 +985,60 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             item.vis);\n       }\n       ItemForeignMod(ref fm) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'n');\n-        encode_name(ebml_w, item.ident.name);\n-        encode_path(ebml_w, path);\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'n');\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n \n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n-            ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_string(local_def(foreign_item.id)).as_slice());\n-            ebml_w.end_tag();\n+            rbml_w.start_tag(tag_mod_child);\n+            rbml_w.wr_str(def_to_string(local_def(foreign_item.id)).as_slice());\n+            rbml_w.end_tag();\n         }\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n       }\n       ItemTy(..) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'y');\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ebml_w, item.ident.name);\n-        encode_path(ebml_w, path);\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'y');\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n       }\n       ItemEnum(ref enum_definition, _) => {\n-        add_to_index(item, ebml_w, index);\n-\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 't');\n-        encode_item_variances(ebml_w, ecx, item.id);\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n+        add_to_index(item, rbml_w, index);\n+\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 't');\n+        encode_item_variances(rbml_w, ecx, item.id);\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n         for v in (*enum_definition).variants.iter() {\n-            encode_variant_id(ebml_w, local_def(v.node.id));\n+            encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n-        encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n-        encode_path(ebml_w, path);\n+        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+        encode_path(rbml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n-        encode_inherent_implementations(ecx, ebml_w, def_id);\n+        encode_inherent_implementations(ecx, rbml_w, def_id);\n \n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n \n         encode_enum_variant_info(ecx,\n-                                 ebml_w,\n+                                 rbml_w,\n                                  item.id,\n                                  (*enum_definition).variants.as_slice(),\n                                  index);\n@@ -1051,44 +1051,44 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            the index, and the index needs to be in the item for the\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n-                                         ebml_w,\n+                                         rbml_w,\n                                          fields.as_slice(),\n                                          index);\n \n         /* Index the class*/\n-        add_to_index(item, ebml_w, index);\n+        add_to_index(item, rbml_w, index);\n \n         /* Now, make an item for the class itself */\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'S');\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-\n-        encode_item_variances(ebml_w, ecx, item.id);\n-        encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n-        encode_path(ebml_w, path.clone());\n-        encode_stability(ebml_w, stab);\n-        encode_visibility(ebml_w, vis);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'S');\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+\n+        encode_item_variances(rbml_w, ecx, item.id);\n+        encode_name(rbml_w, item.ident.name);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_path(rbml_w, path.clone());\n+        encode_stability(rbml_w, stab);\n+        encode_visibility(rbml_w, vis);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n+        encode_struct_fields(rbml_w, fields.as_slice(), def_id);\n \n-        encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n \n         // Encode inherent implementations for this structure.\n-        encode_inherent_implementations(ecx, ebml_w, def_id);\n+        encode_inherent_implementations(ecx, rbml_w, def_id);\n \n         /* Each class has its own index -- encode it */\n-        encode_index(ebml_w, idx, write_i64);\n-        ebml_w.end_tag();\n+        encode_index(rbml_w, idx, write_i64);\n+        rbml_w.end_tag();\n \n         // If this is a tuple-like struct, encode the type of the constructor.\n         match struct_def.ctor_id {\n             Some(ctor_id) => {\n-                encode_info_for_struct_ctor(ecx, ebml_w, item.ident,\n+                encode_info_for_struct_ctor(ecx, rbml_w, item.ident,\n                                             ctor_id, index, def_id.node);\n             }\n             None => {}\n@@ -1100,38 +1100,38 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let impl_methods = tcx.impl_methods.borrow();\n         let methods = impl_methods.get(&def_id);\n \n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'i');\n-        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'i');\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n         match ty.node {\n             ast::TyPath(ref path, ref bounds, _) if path.segments\n                                                         .len() == 1 => {\n                 let ident = path.segments.last().unwrap().identifier;\n                 assert!(bounds.is_none());\n-                encode_impl_type_basename(ebml_w, ident);\n+                encode_impl_type_basename(rbml_w, ident);\n             }\n             _ => {}\n         }\n         for &method_def_id in methods.iter() {\n-            ebml_w.start_tag(tag_item_impl_method);\n+            rbml_w.start_tag(tag_item_impl_method);\n             let s = def_to_string(method_def_id);\n-            ebml_w.writer.write(s.as_bytes());\n-            ebml_w.end_tag();\n+            rbml_w.writer.write(s.as_bytes());\n+            rbml_w.end_tag();\n         }\n         for ast_trait_ref in opt_trait.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, &*trait_ref, tag_item_trait_ref);\n+            encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n             let impl_vtables = ty::lookup_impl_vtables(tcx, def_id);\n-            encode_impl_vtables(ebml_w, ecx, &impl_vtables);\n+            encode_impl_vtables(rbml_w, ecx, &impl_vtables);\n         }\n-        encode_path(ebml_w, path.clone());\n-        encode_stability(ebml_w, stab);\n-        ebml_w.end_tag();\n+        encode_path(rbml_w, path.clone());\n+        encode_stability(rbml_w, stab);\n+        rbml_w.end_tag();\n \n         // Iterate down the methods, emitting them. We rely on the\n         // assumption that all of the actually implemented methods\n@@ -1145,10 +1145,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             index.push(entry {\n                 val: method_def_id.node as i64,\n-                pos: ebml_w.writer.tell().unwrap(),\n+                pos: rbml_w.writer.tell().unwrap(),\n             });\n             encode_info_for_method(ecx,\n-                                   ebml_w,\n+                                   rbml_w,\n                                    &*ty::method(tcx, method_def_id),\n                                    path.clone(),\n                                    false,\n@@ -1157,43 +1157,43 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n       }\n       ItemTrait(_, _, ref super_traits, ref ms) => {\n-        add_to_index(item, ebml_w, index);\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, def_id);\n-        encode_family(ebml_w, 'I');\n-        encode_item_variances(ebml_w, ecx, item.id);\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'I');\n+        encode_item_variances(rbml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n-        encode_ty_type_param_defs(ebml_w, ecx,\n+        encode_ty_type_param_defs(rbml_w, ecx,\n                                   &trait_def.generics.types,\n                                   tag_items_data_item_ty_param_bounds);\n-        encode_region_param_defs(ebml_w, &trait_def.generics.regions);\n-        encode_trait_ref(ebml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n-        encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs.as_slice());\n-        encode_visibility(ebml_w, vis);\n-        encode_stability(ebml_w, stab);\n+        encode_region_param_defs(rbml_w, &trait_def.generics.regions);\n+        encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n+        encode_name(rbml_w, item.ident.name);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n         for &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n-            ebml_w.start_tag(tag_item_trait_method);\n-            encode_def_id(ebml_w, method_def_id);\n-            ebml_w.end_tag();\n+            rbml_w.start_tag(tag_item_trait_method);\n+            encode_def_id(rbml_w, method_def_id);\n+            rbml_w.end_tag();\n \n-            ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_string(method_def_id).as_slice());\n-            ebml_w.end_tag();\n+            rbml_w.start_tag(tag_mod_child);\n+            rbml_w.wr_str(def_to_string(method_def_id).as_slice());\n+            rbml_w.end_tag();\n         }\n-        encode_path(ebml_w, path.clone());\n+        encode_path(rbml_w, path.clone());\n         // FIXME(#8559): This should use the tcx's supertrait cache instead of\n         // reading the AST's list, because the former has already filtered out\n         // the builtin-kinds-as-supertraits. See corresponding fixme in decoder.\n         for ast_trait_ref in super_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, &*trait_ref, tag_item_super_trait_ref);\n+            encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_super_trait_ref);\n         }\n \n         // Encode the implementations of this trait.\n-        encode_extension_implementations(ecx, ebml_w, def_id);\n+        encode_extension_implementations(ecx, rbml_w, def_id);\n \n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n \n         // Now output the method info for each method.\n         let r = ty::trait_method_def_ids(tcx, def_id);\n@@ -1204,65 +1204,65 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             index.push(entry {\n                 val: method_def_id.node as i64,\n-                pos: ebml_w.writer.tell().unwrap(),\n+                pos: rbml_w.writer.tell().unwrap(),\n             });\n \n-            ebml_w.start_tag(tag_items_data_item);\n+            rbml_w.start_tag(tag_items_data_item);\n \n-            encode_method_ty_fields(ecx, ebml_w, &*method_ty);\n-            encode_parent_item(ebml_w, def_id);\n+            encode_method_ty_fields(ecx, rbml_w, &*method_ty);\n+            encode_parent_item(rbml_w, def_id);\n \n             let stab = stability::lookup(tcx, method_def_id);\n-            encode_stability(ebml_w, stab);\n+            encode_stability(rbml_w, stab);\n \n             let elem = ast_map::PathName(method_ty.ident.name);\n-            encode_path(ebml_w, path.clone().chain(Some(elem).move_iter()));\n+            encode_path(rbml_w, path.clone().chain(Some(elem).move_iter()));\n \n             match method_ty.explicit_self {\n                 ty::StaticExplicitSelfCategory => {\n-                    encode_family(ebml_w,\n+                    encode_family(rbml_w,\n                                   fn_style_static_method_family(\n                                       method_ty.fty.fn_style));\n \n                     let pty = ty::lookup_item_type(tcx, method_def_id);\n-                    encode_bounds_and_type(ebml_w, ecx, &pty);\n+                    encode_bounds_and_type(rbml_w, ecx, &pty);\n                 }\n \n                 _ => {\n-                    encode_family(ebml_w,\n+                    encode_family(rbml_w,\n                                   style_fn_family(\n                                       method_ty.fty.fn_style));\n                 }\n             }\n \n             match ms.get(i) {\n                 &Required(ref tm) => {\n-                    encode_attributes(ebml_w, tm.attrs.as_slice());\n-                    encode_method_sort(ebml_w, 'r');\n-                    encode_method_argument_names(ebml_w, &*tm.decl);\n+                    encode_attributes(rbml_w, tm.attrs.as_slice());\n+                    encode_method_sort(rbml_w, 'r');\n+                    encode_method_argument_names(rbml_w, &*tm.decl);\n                 }\n \n                 &Provided(m) => {\n-                    encode_attributes(ebml_w, m.attrs.as_slice());\n+                    encode_attributes(rbml_w, m.attrs.as_slice());\n                     // If this is a static method, we've already encoded\n                     // this.\n                     if method_ty.explicit_self != ty::StaticExplicitSelfCategory {\n                         // FIXME: I feel like there is something funny going on.\n                         let pty = ty::lookup_item_type(tcx, method_def_id);\n-                        encode_bounds_and_type(ebml_w, ecx, &pty);\n+                        encode_bounds_and_type(rbml_w, ecx, &pty);\n                     }\n-                    encode_method_sort(ebml_w, 'p');\n-                    encode_inlined_item(ecx, ebml_w,\n+                    encode_method_sort(rbml_w, 'p');\n+                    encode_inlined_item(ecx, rbml_w,\n                                         IIMethodRef(def_id, true, &*m));\n-                    encode_method_argument_names(ebml_w, &*m.pe_fn_decl());\n+                    encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                 }\n             }\n \n-            ebml_w.end_tag();\n+            rbml_w.end_tag();\n         }\n \n         // Encode inherent implementations for this trait.\n-        encode_inherent_implementations(ecx, ebml_w, def_id);\n+        encode_inherent_implementations(ecx, rbml_w, def_id);\n       }\n       ItemMac(..) => {\n         // macros are encoded separately\n@@ -1271,61 +1271,61 @@ fn encode_info_for_item(ecx: &EncodeContext,\n }\n \n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n-                                ebml_w: &mut Encoder,\n+                                rbml_w: &mut Encoder,\n                                 nitem: &ForeignItem,\n                                 index: &mut Vec<entry<i64>>,\n                                 path: PathElems,\n                                 abi: abi::Abi) {\n     index.push(entry {\n         val: nitem.id as i64,\n-        pos: ebml_w.writer.tell().unwrap(),\n+        pos: rbml_w.writer.tell().unwrap(),\n     });\n \n-    ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(nitem.id));\n+    rbml_w.start_tag(tag_items_data_item);\n+    encode_def_id(rbml_w, local_def(nitem.id));\n     match nitem.node {\n       ForeignItemFn(..) => {\n-        encode_family(ebml_w, style_fn_family(NormalFn));\n-        encode_bounds_and_type(ebml_w, ecx,\n+        encode_family(rbml_w, style_fn_family(NormalFn));\n+        encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n-        encode_name(ebml_w, nitem.ident.name);\n+        encode_name(rbml_w, nitem.ident.name);\n         if abi == abi::RustIntrinsic {\n-            encode_inlined_item(ecx, ebml_w, IIForeignRef(nitem));\n+            encode_inlined_item(ecx, rbml_w, IIForeignRef(nitem));\n         } else {\n-            encode_symbol(ecx, ebml_w, nitem.id);\n+            encode_symbol(ecx, rbml_w, nitem.id);\n         }\n       }\n       ForeignItemStatic(_, mutbl) => {\n         if mutbl {\n-            encode_family(ebml_w, 'b');\n+            encode_family(rbml_w, 'b');\n         } else {\n-            encode_family(ebml_w, 'c');\n+            encode_family(rbml_w, 'c');\n         }\n-        encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n-        encode_symbol(ecx, ebml_w, nitem.id);\n-        encode_name(ebml_w, nitem.ident.name);\n+        encode_type(ecx, rbml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        encode_symbol(ecx, rbml_w, nitem.id);\n+        encode_name(rbml_w, nitem.ident.name);\n       }\n     }\n-    encode_path(ebml_w, path);\n-    ebml_w.end_tag();\n+    encode_path(rbml_w, path);\n+    rbml_w.end_tag();\n }\n \n fn my_visit_expr(_e: &Expr) { }\n \n fn my_visit_item(i: &Item,\n-                 ebml_w: &mut Encoder,\n+                 rbml_w: &mut Encoder,\n                  ecx_ptr: *const int,\n                  index: &mut Vec<entry<i64>>) {\n-    let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n+    let mut rbml_w = unsafe { rbml_w.unsafe_clone() };\n     // See above\n     let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n     ecx.tcx.map.with_path(i.id, |path| {\n-        encode_info_for_item(ecx, &mut ebml_w, i, index, path, i.vis);\n+        encode_info_for_item(ecx, &mut rbml_w, i, index, path, i.vis);\n     });\n }\n \n fn my_visit_foreign_item(ni: &ForeignItem,\n-                         ebml_w: &mut Encoder,\n+                         rbml_w: &mut Encoder,\n                          ecx_ptr:*const int,\n                          index: &mut Vec<entry<i64>>) {\n     // See above\n@@ -1334,19 +1334,19 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n             ecx.tcx.map.path_to_string(ni.id),\n             token::get_ident(ni.ident));\n \n-    let mut ebml_w = unsafe {\n-        ebml_w.unsafe_clone()\n+    let mut rbml_w = unsafe {\n+        rbml_w.unsafe_clone()\n     };\n     let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n     ecx.tcx.map.with_path(ni.id, |path| {\n-        encode_info_for_foreign_item(ecx, &mut ebml_w,\n+        encode_info_for_foreign_item(ecx, &mut rbml_w,\n                                      ni, index,\n                                      path, abi);\n     });\n }\n \n struct EncodeVisitor<'a,'b> {\n-    ebml_w_for_visit_item: &'a mut Encoder<'b>,\n+    rbml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx_ptr:*const int,\n     index: &'a mut Vec<entry<i64>>,\n }\n@@ -1359,31 +1359,31 @@ impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n     fn visit_item(&mut self, i: &Item, _: ()) {\n         visit::walk_item(self, i, ());\n         my_visit_item(i,\n-                      self.ebml_w_for_visit_item,\n+                      self.rbml_w_for_visit_item,\n                       self.ecx_ptr,\n                       self.index);\n     }\n     fn visit_foreign_item(&mut self, ni: &ForeignItem, _: ()) {\n         visit::walk_foreign_item(self, ni, ());\n         my_visit_foreign_item(ni,\n-                              self.ebml_w_for_visit_item,\n+                              self.rbml_w_for_visit_item,\n                               self.ecx_ptr,\n                               self.index);\n     }\n }\n \n fn encode_info_for_items(ecx: &EncodeContext,\n-                         ebml_w: &mut Encoder,\n+                         rbml_w: &mut Encoder,\n                          krate: &Crate)\n                          -> Vec<entry<i64>> {\n     let mut index = Vec::new();\n-    ebml_w.start_tag(tag_items_data);\n+    rbml_w.start_tag(tag_items_data);\n     index.push(entry {\n         val: CRATE_NODE_ID as i64,\n-        pos: ebml_w.writer.tell().unwrap(),\n+        pos: rbml_w.writer.tell().unwrap(),\n     });\n     encode_info_for_mod(ecx,\n-                        ebml_w,\n+                        rbml_w,\n                         &krate.module,\n                         &[],\n                         CRATE_NODE_ID,\n@@ -1396,51 +1396,51 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n         ecx_ptr: ecx_ptr,\n-        ebml_w_for_visit_item: &mut *ebml_w,\n+        rbml_w_for_visit_item: &mut *rbml_w,\n     }, krate, ());\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n     index\n }\n \n \n // Path and definition ID indexing\n \n-fn encode_index<T: Hash>(ebml_w: &mut Encoder, index: Vec<entry<T>>,\n+fn encode_index<T: Hash>(rbml_w: &mut Encoder, index: Vec<entry<T>>,\n                          write_fn: |&mut SeekableMemWriter, &T|) {\n     let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n     for elt in index.move_iter() {\n         let h = hash::hash(&elt.val) as uint;\n         buckets.get_mut(h % 256).push(elt);\n     }\n \n-    ebml_w.start_tag(tag_index);\n+    rbml_w.start_tag(tag_index);\n     let mut bucket_locs = Vec::new();\n-    ebml_w.start_tag(tag_index_buckets);\n+    rbml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n-        bucket_locs.push(ebml_w.writer.tell().unwrap());\n-        ebml_w.start_tag(tag_index_buckets_bucket);\n+        bucket_locs.push(rbml_w.writer.tell().unwrap());\n+        rbml_w.start_tag(tag_index_buckets_bucket);\n         for elt in bucket.iter() {\n-            ebml_w.start_tag(tag_index_buckets_bucket_elt);\n+            rbml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             {\n-                let wr: &mut SeekableMemWriter = ebml_w.writer;\n+                let wr: &mut SeekableMemWriter = rbml_w.writer;\n                 wr.write_be_u32(elt.pos as u32);\n             }\n-            write_fn(ebml_w.writer, &elt.val);\n-            ebml_w.end_tag();\n+            write_fn(rbml_w.writer, &elt.val);\n+            rbml_w.end_tag();\n         }\n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_index_table);\n+    rbml_w.end_tag();\n+    rbml_w.start_tag(tag_index_table);\n     for pos in bucket_locs.iter() {\n         assert!(*pos < 0xffff_ffff);\n-        let wr: &mut SeekableMemWriter = ebml_w.writer;\n+        let wr: &mut SeekableMemWriter = rbml_w.writer;\n         wr.write_be_u32(*pos as u32);\n     }\n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n@@ -1449,55 +1449,55 @@ fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n     wr.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: &mut Encoder, mi: Gc<MetaItem>) {\n+fn encode_meta_item(rbml_w: &mut Encoder, mi: Gc<MetaItem>) {\n     match mi.node {\n       MetaWord(ref name) => {\n-        ebml_w.start_tag(tag_meta_item_word);\n-        ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(name.get().as_bytes());\n-        ebml_w.end_tag();\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_meta_item_word);\n+        rbml_w.start_tag(tag_meta_item_name);\n+        rbml_w.writer.write(name.get().as_bytes());\n+        rbml_w.end_tag();\n+        rbml_w.end_tag();\n       }\n       MetaNameValue(ref name, ref value) => {\n         match value.node {\n           LitStr(ref value, _) => {\n-            ebml_w.start_tag(tag_meta_item_name_value);\n-            ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(name.get().as_bytes());\n-            ebml_w.end_tag();\n-            ebml_w.start_tag(tag_meta_item_value);\n-            ebml_w.writer.write(value.get().as_bytes());\n-            ebml_w.end_tag();\n-            ebml_w.end_tag();\n+            rbml_w.start_tag(tag_meta_item_name_value);\n+            rbml_w.start_tag(tag_meta_item_name);\n+            rbml_w.writer.write(name.get().as_bytes());\n+            rbml_w.end_tag();\n+            rbml_w.start_tag(tag_meta_item_value);\n+            rbml_w.writer.write(value.get().as_bytes());\n+            rbml_w.end_tag();\n+            rbml_w.end_tag();\n           }\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n       MetaList(ref name, ref items) => {\n-        ebml_w.start_tag(tag_meta_item_list);\n-        ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(name.get().as_bytes());\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_meta_item_list);\n+        rbml_w.start_tag(tag_meta_item_name);\n+        rbml_w.writer.write(name.get().as_bytes());\n+        rbml_w.end_tag();\n         for inner_item in items.iter() {\n-            encode_meta_item(ebml_w, *inner_item);\n+            encode_meta_item(rbml_w, *inner_item);\n         }\n-        ebml_w.end_tag();\n+        rbml_w.end_tag();\n       }\n     }\n }\n \n-fn encode_attributes(ebml_w: &mut Encoder, attrs: &[Attribute]) {\n-    ebml_w.start_tag(tag_attributes);\n+fn encode_attributes(rbml_w: &mut Encoder, attrs: &[Attribute]) {\n+    rbml_w.start_tag(tag_attributes);\n     for attr in attrs.iter() {\n-        ebml_w.start_tag(tag_attribute);\n-        ebml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n-        encode_meta_item(ebml_w, attr.node.value);\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_attribute);\n+        rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n+        encode_meta_item(rbml_w, attr.node.value);\n+        rbml_w.end_tag();\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_crate_deps(ebml_w: &mut Encoder, cstore: &cstore::CStore) {\n+fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<decoder::CrateDep> {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = Vec::new();\n@@ -1527,150 +1527,150 @@ fn encode_crate_deps(ebml_w: &mut Encoder, cstore: &cstore::CStore) {\n     // the assumption that they are numbered 1 to n.\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n-    ebml_w.start_tag(tag_crate_deps);\n+    rbml_w.start_tag(tag_crate_deps);\n     let r = get_ordered_deps(cstore);\n     for dep in r.iter() {\n-        encode_crate_dep(ebml_w, (*dep).clone());\n+        encode_crate_dep(rbml_w, (*dep).clone());\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_lang_items);\n+fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_lang_items);\n \n     for (i, def_id) in ecx.tcx.lang_items.items() {\n         for id in def_id.iter() {\n             if id.krate == LOCAL_CRATE {\n-                ebml_w.start_tag(tag_lang_items_item);\n+                rbml_w.start_tag(tag_lang_items_item);\n \n-                ebml_w.start_tag(tag_lang_items_item_id);\n+                rbml_w.start_tag(tag_lang_items_item_id);\n                 {\n-                    let wr: &mut SeekableMemWriter = ebml_w.writer;\n+                    let wr: &mut SeekableMemWriter = rbml_w.writer;\n                     wr.write_be_u32(i as u32);\n                 }\n-                ebml_w.end_tag();   // tag_lang_items_item_id\n+                rbml_w.end_tag();   // tag_lang_items_item_id\n \n-                ebml_w.start_tag(tag_lang_items_item_node_id);\n+                rbml_w.start_tag(tag_lang_items_item_node_id);\n                 {\n-                    let wr: &mut SeekableMemWriter = ebml_w.writer;\n+                    let wr: &mut SeekableMemWriter = rbml_w.writer;\n                     wr.write_be_u32(id.node as u32);\n                 }\n-                ebml_w.end_tag();   // tag_lang_items_item_node_id\n+                rbml_w.end_tag();   // tag_lang_items_item_node_id\n \n-                ebml_w.end_tag();   // tag_lang_items_item\n+                rbml_w.end_tag();   // tag_lang_items_item\n             }\n         }\n     }\n \n     for i in ecx.tcx.lang_items.missing.iter() {\n-        ebml_w.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n+        rbml_w.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n     }\n \n-    ebml_w.end_tag();   // tag_lang_items\n+    rbml_w.end_tag();   // tag_lang_items\n }\n \n-fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_native_libraries);\n+fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_native_libraries);\n \n     for &(ref lib, kind) in ecx.tcx.sess.cstore.get_used_libraries()\n                                .borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {\n-                ebml_w.start_tag(tag_native_libraries_lib);\n+                rbml_w.start_tag(tag_native_libraries_lib);\n \n-                ebml_w.start_tag(tag_native_libraries_kind);\n-                ebml_w.writer.write_be_u32(kind as u32);\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_native_libraries_kind);\n+                rbml_w.writer.write_be_u32(kind as u32);\n+                rbml_w.end_tag();\n \n-                ebml_w.start_tag(tag_native_libraries_name);\n-                ebml_w.writer.write(lib.as_bytes());\n-                ebml_w.end_tag();\n+                rbml_w.start_tag(tag_native_libraries_name);\n+                rbml_w.writer.write(lib.as_bytes());\n+                rbml_w.end_tag();\n \n-                ebml_w.end_tag();\n+                rbml_w.end_tag();\n             }\n         }\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_plugin_registrar_fn(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n+fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     match ecx.tcx.sess.plugin_registrar_fn.get() {\n-        Some(id) => { ebml_w.wr_tagged_u32(tag_plugin_registrar_fn, id); }\n+        Some(id) => { rbml_w.wr_tagged_u32(tag_plugin_registrar_fn, id); }\n         None => {}\n     }\n }\n \n /// Given a span, write the text of that span into the output stream\n /// as an exported macro\n fn encode_macro_def(ecx: &EncodeContext,\n-                    ebml_w: &mut Encoder,\n+                    rbml_w: &mut Encoder,\n                     span: &syntax::codemap::Span) {\n     let def = ecx.tcx.sess.codemap().span_to_snippet(*span)\n         .expect(\"Unable to find source for macro\");\n-    ebml_w.start_tag(tag_macro_def);\n-    ebml_w.wr_str(def.as_slice());\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_macro_def);\n+    rbml_w.wr_str(def.as_slice());\n+    rbml_w.end_tag();\n }\n \n /// Serialize the text of the exported macros\n fn encode_macro_defs(ecx: &EncodeContext,\n                      krate: &Crate,\n-                     ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_exported_macros);\n+                     rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_exported_macros);\n     for item in krate.exported_macros.iter() {\n-        encode_macro_def(ecx, ebml_w, &item.span);\n+        encode_macro_def(ecx, rbml_w, &item.span);\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_unboxed_closures<'a>(\n                            ecx: &'a EncodeContext,\n-                           ebml_w: &'a mut Encoder) {\n-    ebml_w.start_tag(tag_unboxed_closures);\n+                           rbml_w: &'a mut Encoder) {\n+    rbml_w.start_tag(tag_unboxed_closures);\n     for (unboxed_closure_id, unboxed_closure_type) in\n             ecx.tcx.unboxed_closure_types.borrow().iter() {\n         if unboxed_closure_id.krate != LOCAL_CRATE {\n             continue\n         }\n \n-        ebml_w.start_tag(tag_unboxed_closure);\n-        encode_def_id(ebml_w, *unboxed_closure_id);\n-        ebml_w.start_tag(tag_unboxed_closure_type);\n-        write_closure_type(ecx, ebml_w, unboxed_closure_type);\n-        ebml_w.end_tag();\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_unboxed_closure);\n+        encode_def_id(rbml_w, *unboxed_closure_id);\n+        rbml_w.start_tag(tag_unboxed_closure_type);\n+        write_closure_type(ecx, rbml_w, unboxed_closure_type);\n+        rbml_w.end_tag();\n+        rbml_w.end_tag();\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_struct_field_attrs(ebml_w: &mut Encoder, krate: &Crate) {\n+fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n     struct StructFieldVisitor<'a, 'b> {\n-        ebml_w: &'a mut Encoder<'b>,\n+        rbml_w: &'a mut Encoder<'b>,\n     }\n \n     impl<'a, 'b> Visitor<()> for StructFieldVisitor<'a, 'b> {\n         fn visit_struct_field(&mut self, field: &ast::StructField, _: ()) {\n-            self.ebml_w.start_tag(tag_struct_field);\n-            self.ebml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.ebml_w, field.node.attrs.as_slice());\n-            self.ebml_w.end_tag();\n+            self.rbml_w.start_tag(tag_struct_field);\n+            self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n+            encode_attributes(self.rbml_w, field.node.attrs.as_slice());\n+            self.rbml_w.end_tag();\n         }\n     }\n \n-    ebml_w.start_tag(tag_struct_fields);\n+    rbml_w.start_tag(tag_struct_fields);\n     visit::walk_crate(&mut StructFieldVisitor {\n-        ebml_w: ebml_w\n+        rbml_w: rbml_w\n     }, krate, ());\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n \n \n struct ImplVisitor<'a,'b,'c> {\n     ecx: &'a EncodeContext<'b>,\n-    ebml_w: &'a mut Encoder<'c>,\n+    rbml_w: &'a mut Encoder<'c>,\n }\n \n impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n@@ -1685,9 +1685,9 @@ impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n                 // or if the trait is not defined in this crate.\n                 if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n                         def_id.krate != LOCAL_CRATE {\n-                    self.ebml_w.start_tag(tag_impls_impl);\n-                    encode_def_id(self.ebml_w, local_def(item.id));\n-                    self.ebml_w.end_tag();\n+                    self.rbml_w.start_tag(tag_impls_impl);\n+                    encode_def_id(self.rbml_w, local_def(item.id));\n+                    self.rbml_w.end_tag();\n                 }\n             }\n             _ => {}\n@@ -1708,55 +1708,55 @@ impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n /// * Implementations of traits not defined in this crate.\n fn encode_impls<'a>(ecx: &'a EncodeContext,\n                     krate: &Crate,\n-                    ebml_w: &'a mut Encoder) {\n-    ebml_w.start_tag(tag_impls);\n+                    rbml_w: &'a mut Encoder) {\n+    rbml_w.start_tag(tag_impls);\n \n     {\n         let mut visitor = ImplVisitor {\n             ecx: ecx,\n-            ebml_w: ebml_w,\n+            rbml_w: rbml_w,\n         };\n         visit::walk_crate(&mut visitor, krate, ());\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_misc_info(ecx: &EncodeContext,\n                     krate: &Crate,\n-                    ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_misc_info);\n-    ebml_w.start_tag(tag_misc_info_crate_items);\n+                    rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_misc_info);\n+    rbml_w.start_tag(tag_misc_info_crate_items);\n     for &item in krate.module.items.iter() {\n-        ebml_w.start_tag(tag_mod_child);\n-        ebml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n-        ebml_w.end_tag();\n+        rbml_w.start_tag(tag_mod_child);\n+        rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n+        rbml_w.end_tag();\n \n         each_auxiliary_node_id(item, |auxiliary_node_id| {\n-            ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_string(local_def(\n+            rbml_w.start_tag(tag_mod_child);\n+            rbml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());\n-            ebml_w.end_tag();\n+            rbml_w.end_tag();\n             true\n         });\n     }\n \n     // Encode reexports for the root module.\n-    encode_reexports(ecx, ebml_w, 0, ast_map::Values([].iter()).chain(None));\n+    encode_reexports(ecx, rbml_w, 0, ast_map::Values([].iter()).chain(None));\n \n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_reachable_extern_fns(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n-    ebml_w.start_tag(tag_reachable_extern_fns);\n+fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_reachable_extern_fns);\n \n     for id in ecx.reachable.iter() {\n         match ecx.tcx.map.find(*id) {\n             Some(ast_map::NodeItem(i)) => {\n                 match i.node {\n                     ast::ItemFn(_, _, abi, _, _) if abi != abi::Rust => {\n-                        ebml_w.wr_tagged_u32(tag_reachable_extern_fn_id, *id);\n+                        rbml_w.wr_tagged_u32(tag_reachable_extern_fn_id, *id);\n                     }\n                     _ => {}\n                 }\n@@ -1765,41 +1765,41 @@ fn encode_reachable_extern_fns(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n         }\n     }\n \n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_crate_dep(ebml_w: &mut Encoder,\n+fn encode_crate_dep(rbml_w: &mut Encoder,\n                     dep: decoder::CrateDep) {\n-    ebml_w.start_tag(tag_crate_dep);\n-    ebml_w.start_tag(tag_crate_dep_crate_name);\n-    ebml_w.writer.write(dep.name.as_bytes());\n-    ebml_w.end_tag();\n-    ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(dep.hash.as_str().as_bytes());\n-    ebml_w.end_tag();\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(tag_crate_dep);\n+    rbml_w.start_tag(tag_crate_dep_crate_name);\n+    rbml_w.writer.write(dep.name.as_bytes());\n+    rbml_w.end_tag();\n+    rbml_w.start_tag(tag_crate_dep_hash);\n+    rbml_w.writer.write(dep.hash.as_str().as_bytes());\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: &mut Encoder, hash: &Svh) {\n-    ebml_w.start_tag(tag_crate_hash);\n-    ebml_w.writer.write(hash.as_str().as_bytes());\n-    ebml_w.end_tag();\n+fn encode_hash(rbml_w: &mut Encoder, hash: &Svh) {\n+    rbml_w.start_tag(tag_crate_hash);\n+    rbml_w.writer.write(hash.as_str().as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_crate_name(ebml_w: &mut Encoder, crate_name: &str) {\n-    ebml_w.start_tag(tag_crate_crate_name);\n-    ebml_w.writer.write(crate_name.as_bytes());\n-    ebml_w.end_tag();\n+fn encode_crate_name(rbml_w: &mut Encoder, crate_name: &str) {\n+    rbml_w.start_tag(tag_crate_crate_name);\n+    rbml_w.writer.write(crate_name.as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_crate_triple(ebml_w: &mut Encoder, triple: &str) {\n-    ebml_w.start_tag(tag_crate_triple);\n-    ebml_w.writer.write(triple.as_bytes());\n-    ebml_w.end_tag();\n+fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n+    rbml_w.start_tag(tag_crate_triple);\n+    rbml_w.writer.write(triple.as_bytes());\n+    rbml_w.end_tag();\n }\n \n-fn encode_dylib_dependency_formats(ebml_w: &mut Encoder, ecx: &EncodeContext) {\n-    ebml_w.start_tag(tag_dylib_dependency_formats);\n+fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n+    rbml_w.start_tag(tag_dylib_dependency_formats);\n     match ecx.tcx.dependency_formats.borrow().find(&config::CrateTypeDylib) {\n         Some(arr) => {\n             let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n@@ -1808,11 +1808,11 @@ fn encode_dylib_dependency_formats(ebml_w: &mut Encoder, ecx: &EncodeContext) {\n                     cstore::RequireStatic => \"s\",\n                 })).to_string())\n             }).collect::<Vec<String>>();\n-            ebml_w.writer.write(s.connect(\",\").as_bytes());\n+            rbml_w.writer.write(s.connect(\",\").as_bytes());\n         }\n         None => {}\n     }\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n // NB: Increment this as you change the metadata encoding version.\n@@ -1885,79 +1885,79 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate:\n         reachable: reachable,\n      };\n \n-    let mut ebml_w = writer::Encoder::new(wr);\n+    let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut ebml_w, ecx.link_meta.crate_name.as_slice());\n-    encode_crate_triple(&mut ebml_w,\n+    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name.as_slice());\n+    encode_crate_triple(&mut rbml_w,\n                         tcx.sess\n                            .targ_cfg\n                            .target_strs\n                            .target_triple\n                            .as_slice());\n-    encode_hash(&mut ebml_w, &ecx.link_meta.crate_hash);\n-    encode_dylib_dependency_formats(&mut ebml_w, &ecx);\n+    encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n+    encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n-    let mut i = ebml_w.writer.tell().unwrap();\n-    encode_attributes(&mut ebml_w, krate.attrs.as_slice());\n-    stats.attr_bytes = ebml_w.writer.tell().unwrap() - i;\n+    let mut i = rbml_w.writer.tell().unwrap();\n+    encode_attributes(&mut rbml_w, krate.attrs.as_slice());\n+    stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n-    i = ebml_w.writer.tell().unwrap();\n-    encode_crate_deps(&mut ebml_w, ecx.cstore);\n-    stats.dep_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_crate_deps(&mut rbml_w, ecx.cstore);\n+    stats.dep_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the language items.\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_lang_items(&ecx, &mut ebml_w);\n-    stats.lang_item_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_lang_items(&ecx, &mut rbml_w);\n+    stats.lang_item_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the native libraries used\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_native_libraries(&ecx, &mut ebml_w);\n-    stats.native_lib_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_native_libraries(&ecx, &mut rbml_w);\n+    stats.native_lib_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the plugin registrar function\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_plugin_registrar_fn(&ecx, &mut ebml_w);\n-    stats.plugin_registrar_fn_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_plugin_registrar_fn(&ecx, &mut rbml_w);\n+    stats.plugin_registrar_fn_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode macro definitions\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_macro_defs(&ecx, krate, &mut ebml_w);\n-    stats.macro_defs_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_macro_defs(&ecx, krate, &mut rbml_w);\n+    stats.macro_defs_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the types of all unboxed closures in this crate.\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_unboxed_closures(&ecx, &mut ebml_w);\n-    stats.unboxed_closure_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_unboxed_closures(&ecx, &mut rbml_w);\n+    stats.unboxed_closure_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_impls(&ecx, krate, &mut ebml_w);\n-    stats.impl_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_impls(&ecx, krate, &mut rbml_w);\n+    stats.impl_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode miscellaneous info.\n-    i = ebml_w.writer.tell().unwrap();\n-    encode_misc_info(&ecx, krate, &mut ebml_w);\n-    encode_reachable_extern_fns(&ecx, &mut ebml_w);\n-    stats.misc_bytes = ebml_w.writer.tell().unwrap() - i;\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_misc_info(&ecx, krate, &mut rbml_w);\n+    encode_reachable_extern_fns(&ecx, &mut rbml_w);\n+    stats.misc_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode and index the items.\n-    ebml_w.start_tag(tag_items);\n-    i = ebml_w.writer.tell().unwrap();\n-    let items_index = encode_info_for_items(&ecx, &mut ebml_w, krate);\n-    stats.item_bytes = ebml_w.writer.tell().unwrap() - i;\n+    rbml_w.start_tag(tag_items);\n+    i = rbml_w.writer.tell().unwrap();\n+    let items_index = encode_info_for_items(&ecx, &mut rbml_w, krate);\n+    stats.item_bytes = rbml_w.writer.tell().unwrap() - i;\n \n-    i = ebml_w.writer.tell().unwrap();\n-    encode_index(&mut ebml_w, items_index, write_i64);\n-    stats.index_bytes = ebml_w.writer.tell().unwrap() - i;\n-    ebml_w.end_tag();\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_index(&mut rbml_w, items_index, write_i64);\n+    stats.index_bytes = rbml_w.writer.tell().unwrap() - i;\n+    rbml_w.end_tag();\n \n-    encode_struct_field_attrs(&mut ebml_w, krate);\n+    encode_struct_field_attrs(&mut rbml_w, krate);\n \n-    stats.total_bytes = ebml_w.writer.tell().unwrap();\n+    stats.total_bytes = rbml_w.writer.tell().unwrap();\n \n     if tcx.sess.meta_stats() {\n-        for e in ebml_w.writer.get_ref().iter() {\n+        for e in rbml_w.writer.get_ref().iter() {\n             if *e == 0 {\n                 stats.zero_bytes += 1;\n             }"}, {"sha": "98111c7c4cfd4759ed40f01ac852cd60b301f3b8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 150, "deletions": 151, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -43,12 +43,11 @@ use std::io::Seek;\n use std::mem;\n use std::gc::GC;\n \n-use serialize::ebml::reader;\n-use serialize::ebml;\n+use rbml::{reader, writer};\n+use rbml;\n use serialize;\n use serialize::{Encoder, Encodable, EncoderHelpers, DecoderHelpers};\n use serialize::{Decoder, Decodable};\n-use writer = serialize::ebml::writer;\n \n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n@@ -79,7 +78,7 @@ pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n // Top-level methods.\n \n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n-                           ebml_w: &mut Encoder,\n+                           rbml_w: &mut Encoder,\n                            ii: e::InlinedItemRef) {\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n@@ -88,26 +87,26 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     };\n     debug!(\"> Encoding inlined item: {} ({})\",\n            ecx.tcx.map.path_to_string(id),\n-           ebml_w.writer.tell());\n+           rbml_w.writer.tell());\n \n     let ii = simplify_ast(ii);\n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n \n-    ebml_w.start_tag(c::tag_ast as uint);\n-    id_range.encode(ebml_w);\n-    encode_ast(ebml_w, ii);\n-    encode_side_tables_for_ii(ecx, ebml_w, &ii);\n-    ebml_w.end_tag();\n+    rbml_w.start_tag(c::tag_ast as uint);\n+    id_range.encode(rbml_w);\n+    encode_ast(rbml_w, ii);\n+    encode_side_tables_for_ii(ecx, rbml_w, &ii);\n+    rbml_w.end_tag();\n \n     debug!(\"< Encoded inlined fn: {} ({})\",\n            ecx.tcx.map.path_to_string(id),\n-           ebml_w.writer.tell());\n+           rbml_w.writer.tell());\n }\n \n pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n                            tcx: &ty::ctxt,\n                            path: Vec<ast_map::PathElem>,\n-                           par_doc: ebml::Doc)\n+                           par_doc: rbml::Doc)\n                            -> Result<ast::InlinedItem, Vec<ast_map::PathElem>> {\n     let dcx = &DecodeContext {\n         cdata: cdata,\n@@ -294,10 +293,10 @@ impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: &mut Encoder, item: ast::InlinedItem) {\n-    ebml_w.start_tag(c::tag_tree as uint);\n-    item.encode(ebml_w);\n-    ebml_w.end_tag();\n+fn encode_ast(rbml_w: &mut Encoder, item: ast::InlinedItem) {\n+    rbml_w.start_tag(c::tag_tree as uint);\n+    item.encode(rbml_w);\n+    rbml_w.end_tag();\n }\n \n struct NestedItemsDropper;\n@@ -353,7 +352,7 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n     }\n }\n \n-fn decode_ast(par_doc: ebml::Doc) -> ast::InlinedItem {\n+fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n@@ -401,7 +400,7 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> def::Def {\n+fn decode_def(xcx: &ExtendedDecodeContext, doc: rbml::Doc) -> def::Def {\n     let mut dsr = reader::Decoder::new(doc);\n     let def: def::Def = Decodable::decode(&mut dsr).unwrap();\n     def.tr(xcx)\n@@ -526,16 +525,16 @@ impl tr for ty::TraitStore {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: &mut Encoder, fv: &freevar_entry) {\n-    (*fv).encode(ebml_w).unwrap();\n+fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &freevar_entry) {\n+    (*fv).encode(rbml_w).unwrap();\n }\n \n-trait ebml_decoder_helper {\n+trait rbml_decoder_helper {\n     fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n                           -> freevar_entry;\n }\n \n-impl<'a> ebml_decoder_helper for reader::Decoder<'a> {\n+impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n     fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n                           -> freevar_entry {\n         let fv: freevar_entry = Decodable::decode(self).unwrap();\n@@ -561,21 +560,21 @@ trait read_method_callee_helper {\n }\n \n fn encode_method_callee(ecx: &e::EncodeContext,\n-                        ebml_w: &mut Encoder,\n+                        rbml_w: &mut Encoder,\n                         adjustment: typeck::ExprAdjustment,\n                         method: &MethodCallee) {\n-    ebml_w.emit_struct(\"MethodCallee\", 4, |ebml_w| {\n-        ebml_w.emit_struct_field(\"adjustment\", 0u, |ebml_w| {\n-            adjustment.encode(ebml_w)\n+    rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n+        rbml_w.emit_struct_field(\"adjustment\", 0u, |rbml_w| {\n+            adjustment.encode(rbml_w)\n         });\n-        ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n-            method.origin.encode(ebml_w)\n+        rbml_w.emit_struct_field(\"origin\", 1u, |rbml_w| {\n+            method.origin.encode(rbml_w)\n         });\n-        ebml_w.emit_struct_field(\"ty\", 2u, |ebml_w| {\n-            Ok(ebml_w.emit_ty(ecx, method.ty))\n+        rbml_w.emit_struct_field(\"ty\", 2u, |rbml_w| {\n+            Ok(rbml_w.emit_ty(ecx, method.ty))\n         });\n-        ebml_w.emit_struct_field(\"substs\", 3u, |ebml_w| {\n-            Ok(ebml_w.emit_substs(ecx, &method.substs))\n+        rbml_w.emit_struct_field(\"substs\", 3u, |rbml_w| {\n+            Ok(rbml_w.emit_substs(ecx, &method.substs))\n         })\n     }).unwrap();\n }\n@@ -636,81 +635,81 @@ impl tr for MethodOrigin {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n-                              ebml_w: &mut Encoder,\n+                              rbml_w: &mut Encoder,\n                               adjustment: typeck::ExprAdjustment,\n                               dr: &typeck::vtable_res) {\n-    ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n-        ebml_w.emit_struct_field(\"adjustment\", 0u, |ebml_w| {\n-            adjustment.encode(ebml_w)\n+    rbml_w.emit_struct(\"VtableWithKey\", 2, |rbml_w| {\n+        rbml_w.emit_struct_field(\"adjustment\", 0u, |rbml_w| {\n+            adjustment.encode(rbml_w)\n         });\n-        ebml_w.emit_struct_field(\"vtable_res\", 1u, |ebml_w| {\n-            Ok(encode_vtable_res(ecx, ebml_w, dr))\n+        rbml_w.emit_struct_field(\"vtable_res\", 1u, |rbml_w| {\n+            Ok(encode_vtable_res(ecx, rbml_w, dr))\n         })\n     }).unwrap()\n }\n \n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n-                         ebml_w: &mut Encoder,\n+                         rbml_w: &mut Encoder,\n                          dr: &typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones. perhaps we should fix this.\n     encode_vec_per_param_space(\n-        ebml_w, dr,\n-        |ebml_w, param_tables| encode_vtable_param_res(ecx, ebml_w,\n+        rbml_w, dr,\n+        |rbml_w, param_tables| encode_vtable_param_res(ecx, rbml_w,\n                                                        param_tables))\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n-                     ebml_w: &mut Encoder,\n+                     rbml_w: &mut Encoder,\n                      param_tables: &typeck::vtable_param_res) {\n-    ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n-        Ok(encode_vtable_origin(ecx, ebml_w, vtable_origin))\n+    rbml_w.emit_from_vec(param_tables.as_slice(), |rbml_w, vtable_origin| {\n+        Ok(encode_vtable_origin(ecx, rbml_w, vtable_origin))\n     }).unwrap()\n }\n \n \n pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n-                        ebml_w: &mut Encoder,\n+                        rbml_w: &mut Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n-    ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n+    rbml_w.emit_enum(\"vtable_origin\", |rbml_w| {\n         match *vtable_origin {\n           typeck::vtable_static(def_id, ref substs, ref vtable_res) => {\n-            ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |ebml_w| {\n-                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n-                    Ok(ebml_w.emit_def_id(def_id))\n+            rbml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |rbml_w| {\n+                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n+                    Ok(rbml_w.emit_def_id(def_id))\n                 });\n-                ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    Ok(ebml_w.emit_substs(ecx, substs))\n+                rbml_w.emit_enum_variant_arg(1u, |rbml_w| {\n+                    Ok(rbml_w.emit_substs(ecx, substs))\n                 });\n-                ebml_w.emit_enum_variant_arg(2u, |ebml_w| {\n-                    Ok(encode_vtable_res(ecx, ebml_w, vtable_res))\n+                rbml_w.emit_enum_variant_arg(2u, |rbml_w| {\n+                    Ok(encode_vtable_res(ecx, rbml_w, vtable_res))\n                 })\n             })\n           }\n           typeck::vtable_param(pn, bn) => {\n-            ebml_w.emit_enum_variant(\"vtable_param\", 1u, 3u, |ebml_w| {\n-                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n-                    pn.encode(ebml_w)\n+            rbml_w.emit_enum_variant(\"vtable_param\", 1u, 3u, |rbml_w| {\n+                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n+                    pn.encode(rbml_w)\n                 });\n-                ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    ebml_w.emit_uint(bn)\n+                rbml_w.emit_enum_variant_arg(1u, |rbml_w| {\n+                    rbml_w.emit_uint(bn)\n                 })\n             })\n           }\n           typeck::vtable_unboxed_closure(def_id) => {\n-              ebml_w.emit_enum_variant(\"vtable_unboxed_closure\",\n+              rbml_w.emit_enum_variant(\"vtable_unboxed_closure\",\n                                        2u,\n                                        1u,\n-                                       |ebml_w| {\n-                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n-                    Ok(ebml_w.emit_def_id(def_id))\n+                                       |rbml_w| {\n+                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n+                    Ok(rbml_w.emit_def_id(def_id))\n                 })\n               })\n           }\n           typeck::vtable_error => {\n-            ebml_w.emit_enum_variant(\"vtable_error\", 3u, 3u, |_ebml_w| {\n+            rbml_w.emit_enum_variant(\"vtable_error\", 3u, 3u, |_rbml_w| {\n                 Ok(())\n             })\n           }\n@@ -831,12 +830,12 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n // ___________________________________________________________________________\n //\n \n-fn encode_vec_per_param_space<T>(ebml_w: &mut Encoder,\n+fn encode_vec_per_param_space<T>(rbml_w: &mut Encoder,\n                                  v: &subst::VecPerParamSpace<T>,\n                                  f: |&mut Encoder, &T|) {\n     for &space in subst::ParamSpace::all().iter() {\n-        ebml_w.emit_from_vec(v.get_slice(space),\n-                             |ebml_w, n| Ok(f(ebml_w, n))).unwrap();\n+        rbml_w.emit_from_vec(v.get_slice(space),\n+                             |rbml_w, n| Ok(f(rbml_w, n))).unwrap();\n     }\n }\n \n@@ -858,7 +857,7 @@ impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n     }\n }\n \n-trait ebml_writer_helpers {\n+trait rbml_writer_helpers {\n     fn emit_closure_type(&mut self,\n                          ecx: &e::EncodeContext,\n                          closure_type: &ty::ClosureTy);\n@@ -874,7 +873,7 @@ trait ebml_writer_helpers {\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n }\n \n-impl<'a> ebml_writer_helpers for Encoder<'a> {\n+impl<'a> rbml_writer_helpers for Encoder<'a> {\n     fn emit_closure_type(&mut self,\n                          ecx: &e::EncodeContext,\n                          closure_type: &ty::ClosureTy) {\n@@ -980,34 +979,34 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n \n struct SideTableEncodingIdVisitor<'a,'b> {\n     ecx_ptr: *const libc::c_void,\n-    new_ebml_w: &'a mut Encoder<'b>,\n+    new_rbml_w: &'a mut Encoder<'b>,\n }\n \n impl<'a,'b> ast_util::IdVisitingOperation for\n         SideTableEncodingIdVisitor<'a,'b> {\n     fn visit_id(&self, id: ast::NodeId) {\n-        // Note: this will cause a copy of ebml_w, which is bad as\n+        // Note: this will cause a copy of rbml_w, which is bad as\n         // it is mutable. But I believe it's harmless since we generate\n         // balanced EBML.\n         //\n         // FIXME(pcwalton): Don't copy this way.\n-        let mut new_ebml_w = unsafe {\n-            self.new_ebml_w.unsafe_clone()\n+        let mut new_rbml_w = unsafe {\n+            self.new_rbml_w.unsafe_clone()\n         };\n         // See above\n         let ecx: &e::EncodeContext = unsafe {\n             mem::transmute(self.ecx_ptr)\n         };\n-        encode_side_tables_for_id(ecx, &mut new_ebml_w, id)\n+        encode_side_tables_for_id(ecx, &mut new_rbml_w, id)\n     }\n }\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n-                             ebml_w: &mut Encoder,\n+                             rbml_w: &mut Encoder,\n                              ii: &ast::InlinedItem) {\n-    ebml_w.start_tag(c::tag_table as uint);\n-    let mut new_ebml_w = unsafe {\n-        ebml_w.unsafe_clone()\n+    rbml_w.start_tag(c::tag_table as uint);\n+    let mut new_rbml_w = unsafe {\n+        rbml_w.unsafe_clone()\n     };\n \n     // Because the ast visitor uses @IdVisitingOperation, I can't pass in\n@@ -1017,88 +1016,88 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n         ecx_ptr: unsafe {\n             mem::transmute(ecx)\n         },\n-        new_ebml_w: &mut new_ebml_w,\n+        new_rbml_w: &mut new_rbml_w,\n     });\n-    ebml_w.end_tag();\n+    rbml_w.end_tag();\n }\n \n fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n-                             ebml_w: &mut Encoder,\n+                             rbml_w: &mut Encoder,\n                              id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n     for def in tcx.def_map.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_def, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| (*def).encode(ebml_w).unwrap());\n+        rbml_w.tag(c::tag_table_def, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| (*def).encode(rbml_w).unwrap());\n         })\n     }\n \n     for &ty in tcx.node_types.borrow().find(&(id as uint)).iter() {\n-        ebml_w.tag(c::tag_table_node_type, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_ty(ecx, *ty);\n+        rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_ty(ecx, *ty);\n             })\n         })\n     }\n \n     for &item_substs in tcx.item_substs.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_item_subst, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_substs(ecx, &item_substs.substs);\n+        rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_substs(ecx, &item_substs.substs);\n             })\n         })\n     }\n \n     for &fv in tcx.freevars.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_freevars, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n-                    Ok(encode_freevar_entry(ebml_w, fv_entry))\n+        rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_from_vec(fv.as_slice(), |rbml_w, fv_entry| {\n+                    Ok(encode_freevar_entry(rbml_w, fv_entry))\n                 });\n             })\n         })\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n     for &pty in tcx.tcache.borrow().find(&lid).iter() {\n-        ebml_w.tag(c::tag_table_tcache, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_polytype(ecx, pty.clone());\n+        rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_polytype(ecx, pty.clone());\n             })\n         })\n     }\n \n     for &type_param_def in tcx.ty_param_defs.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_param_defs, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_type_param_def(ecx, type_param_def)\n+        rbml_w.tag(c::tag_table_param_defs, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_type_param_def(ecx, type_param_def)\n             })\n         })\n     }\n \n     let method_call = MethodCall::expr(id);\n     for &method in tcx.method_map.borrow().find(&method_call).iter() {\n-        ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_method_callee(ecx, ebml_w, method_call.adjustment, method)\n+        rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n             })\n         })\n     }\n \n     for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-        ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_vtable_res_with_key(ecx, ebml_w, method_call.adjustment, dr);\n+        rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n             })\n         })\n     }\n@@ -1109,20 +1108,20 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                 for autoderef in range(0, adj.autoderefs) {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n                     for &method in tcx.method_map.borrow().find(&method_call).iter() {\n-                        ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n-                            ebml_w.id(id);\n-                            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                                encode_method_callee(ecx, ebml_w,\n+                        rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n+                            rbml_w.id(id);\n+                            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                                encode_method_callee(ecx, rbml_w,\n                                                      method_call.adjustment, method)\n                             })\n                         })\n                     }\n \n                     for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                        ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n-                            ebml_w.id(id);\n-                            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                                encode_vtable_res_with_key(ecx, ebml_w,\n+                        rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+                            rbml_w.id(id);\n+                            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                                encode_vtable_res_with_key(ecx, rbml_w,\n                                                            method_call.adjustment, dr);\n                             })\n                         })\n@@ -1132,30 +1131,30 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ty::AutoObject(..) => {\n                 let method_call = MethodCall::autoobject(id);\n                 for &method in tcx.method_map.borrow().find(&method_call).iter() {\n-                    ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n-                        ebml_w.id(id);\n-                        ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                            encode_method_callee(ecx, ebml_w, method_call.adjustment, method)\n+                    rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n+                        rbml_w.id(id);\n+                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                            encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n                         })\n                     })\n                 }\n \n                 for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                    ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n-                        ebml_w.id(id);\n-                        ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                            encode_vtable_res_with_key(ecx, ebml_w, method_call.adjustment, dr);\n+                    rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+                        rbml_w.id(id);\n+                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                            encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n                         })\n                     })\n                 }\n             }\n             _ => {}\n         }\n \n-        ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_auto_adjustment(ecx, adj);\n+        rbml_w.tag(c::tag_table_adjustments, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_auto_adjustment(ecx, adj);\n             })\n         })\n     }\n@@ -1164,10 +1163,10 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                                    .borrow()\n                                    .find(&ast_util::local_def(id))\n                                    .iter() {\n-        ebml_w.tag(c::tag_table_unboxed_closure_type, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_closure_type(ecx, *unboxed_closure_type)\n+        rbml_w.tag(c::tag_table_unboxed_closure_type, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_closure_type(ecx, *unboxed_closure_type)\n             })\n         })\n     }\n@@ -1178,14 +1177,14 @@ trait doc_decoder_helpers {\n     fn opt_child(&self, tag: c::astencode_tag) -> Option<Self>;\n }\n \n-impl<'a> doc_decoder_helpers for ebml::Doc<'a> {\n+impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n     fn as_int(&self) -> int { reader::doc_as_u64(*self) as int }\n-    fn opt_child(&self, tag: c::astencode_tag) -> Option<ebml::Doc<'a>> {\n+    fn opt_child(&self, tag: c::astencode_tag) -> Option<rbml::Doc<'a>> {\n         reader::maybe_get_doc(*self, tag as uint)\n     }\n }\n \n-trait ebml_decoder_decoder_helpers {\n+trait rbml_decoder_decoder_helpers {\n     fn read_ty(&mut self, xcx: &ExtendedDecodeContext) -> ty::t;\n     fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t>;\n     fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n@@ -1214,7 +1213,7 @@ trait ebml_decoder_decoder_helpers {\n                          -> subst::Substs;\n }\n \n-impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n+impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_noxcx(&mut self,\n                      tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t {\n         self.read_opaque(|_, doc| {\n@@ -1270,7 +1269,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n             Ok(ty)\n         }).unwrap();\n \n-        fn type_string(doc: ebml::Doc) -> String {\n+        fn type_string(doc: rbml::Doc) -> String {\n             let mut str = String::new();\n             for i in range(doc.start, doc.end) {\n                 str.push_char(doc.data[i] as char);\n@@ -1423,7 +1422,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n }\n \n fn decode_side_tables(xcx: &ExtendedDecodeContext,\n-                      ast_doc: ebml::Doc) {\n+                      ast_doc: rbml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n     reader::docs(tbl_doc, |tag, entry_doc| {\n@@ -1527,14 +1526,14 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: &mut Encoder, item: Gc<ast::Item>) {\n-    ebml_w.start_tag(c::tag_tree as uint);\n-    (*item).encode(ebml_w);\n-    ebml_w.end_tag();\n+fn encode_item_ast(rbml_w: &mut Encoder, item: Gc<ast::Item>) {\n+    rbml_w.start_tag(c::tag_tree as uint);\n+    (*item).encode(rbml_w);\n+    rbml_w.end_tag();\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: ebml::Doc) -> Gc<ast::Item> {\n+fn decode_item_ast(par_doc: rbml::Doc) -> Gc<ast::Item> {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder::new(chi_doc);\n     box(GC) Decodable::decode(&mut d).unwrap()\n@@ -1576,11 +1575,11 @@ fn roundtrip(in_item: Option<Gc<ast::Item>>) {\n     let in_item = in_item.unwrap();\n     let mut wr = SeekableMemWriter::new();\n     {\n-        let mut ebml_w = writer::Encoder::new(&mut wr);\n-        encode_item_ast(&mut ebml_w, in_item);\n+        let mut rbml_w = writer::Encoder::new(&mut wr);\n+        encode_item_ast(&mut rbml_w, in_item);\n     }\n-    let ebml_doc = ebml::Doc::new(wr.get_ref());\n-    let out_item = decode_item_ast(ebml_doc);\n+    let rbml_doc = rbml::Doc::new(wr.get_ref());\n+    let out_item = decode_item_ast(rbml_doc);\n \n     assert!(in_item == out_item);\n }"}, {"sha": "cbb337be838cb0c63745204f6a523f01c1e980e0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -2593,7 +2593,7 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     }\n \n     let encode_inlined_item: encoder::EncodeInlinedItem =\n-        |ecx, ebml_w, ii| astencode::encode_inlined_item(ecx, ebml_w, ii);\n+        |ecx, rbml_w, ii| astencode::encode_inlined_item(ecx, rbml_w, ii);\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);"}, {"sha": "5c35ad8523382cef363099662becabdac6c3a677", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -39,6 +39,5 @@ mod serialize;\n mod collection_impls;\n \n pub mod base64;\n-pub mod ebml;\n pub mod hex;\n pub mod json;"}, {"sha": "b03feb8fc224b050c2e822a23fcad972ad6bc618", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -10,33 +10,33 @@\n \n // ignore-test FIXME(#5121)\n \n-\n-extern crate time;\n+extern crate rbml;\n extern crate serialize;\n+extern crate time;\n \n // These tests used to be separate files, but I wanted to refactor all\n // the common code.\n \n use std::hashmap::{HashMap, HashSet};\n \n-use EBReader = serialize::ebml::reader;\n-use EBWriter = serialize::ebml::writer;\n+use EBReader = rbml::reader;\n+use EBWriter = rbml::writer;\n use std::cmp::Eq;\n use std::cmp;\n use std::io;\n use serialize::{Decodable, Encodable};\n \n-fn test_ebml<'a, 'b, A:\n+fn test_rbml<'a, 'b, A:\n     Eq +\n     Encodable<EBWriter::Encoder<'a>> +\n     Decodable<EBReader::Decoder<'b>>\n >(a1: &A) {\n     let mut wr = std::io::MemWriter::new();\n-    let mut ebml_w = EBwriter::Encoder::new(&mut wr);\n-    a1.encode(&mut ebml_w);\n+    let mut rbml_w = EBwriter::Encoder::new(&mut wr);\n+    a1.encode(&mut rbml_w);\n     let bytes = wr.get_ref();\n \n-    let d: serialize::ebml::Doc<'a> = EBDoc::new(bytes);\n+    let d: serialize::rbml::Doc<'a> = EBDoc::new(bytes);\n     let mut decoder: EBReader::Decoder<'a> = EBreader::Decoder::new(d);\n     let a2: A = Decodable::decode(&mut decoder);\n     assert!(*a1 == a2);\n@@ -133,40 +133,40 @@ enum CLike { A, B, C }\n \n pub fn main() {\n     let a = &Plus(@Minus(@Val(3u), @Val(10u)), @Plus(@Val(22u), @Val(5u)));\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &Spanned {lo: 0u, hi: 5u, node: 22u};\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &Point {x: 3u, y: 5u};\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &Top(22u);\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &Bottom(222u);\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &A;\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &B;\n-    test_ebml(a);\n+    test_rbml(a);\n \n     let a = &time::now();\n-    test_ebml(a);\n+    test_rbml(a);\n \n-    test_ebml(&1.0f32);\n-    test_ebml(&1.0f64);\n-    test_ebml(&'a');\n+    test_rbml(&1.0f32);\n+    test_rbml(&1.0f64);\n+    test_rbml(&'a');\n \n     let mut a = HashMap::new();\n-    test_ebml(&a);\n+    test_rbml(&a);\n     a.insert(1, 2);\n-    test_ebml(&a);\n+    test_rbml(&a);\n \n     let mut a = HashSet::new();\n-    test_ebml(&a);\n+    test_rbml(&a);\n     a.insert(1);\n-    test_ebml(&a);\n+    test_rbml(&a);\n }"}, {"sha": "573b57fb44a46d772b18a6ac031cbc43882c109d", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -16,15 +16,16 @@\n #![feature(struct_variant)]\n \n extern crate rand;\n+extern crate rbml;\n extern crate serialize;\n \n use std::io::MemWriter;\n use rand::{random, Rand};\n+use rbml;\n+use rbml::Doc;\n+use rbml::writer::Encoder;\n+use rbml::reader::Decoder;\n use serialize::{Encodable, Decodable};\n-use serialize::ebml;\n-use serialize::ebml::Doc;\n-use serialize::ebml::writer::Encoder;\n-use serialize::ebml::reader::Decoder;\n \n #[deriving(Encodable, Decodable, Eq, Rand)]\n struct A;\n@@ -61,7 +62,7 @@ fn roundtrip<'a, T: Rand + Eq + Encodable<Encoder<'a>> +\n     let mut w = MemWriter::new();\n     let mut e = Encoder::new(&mut w);\n     obj.encode(&mut e);\n-    let doc = ebml::Doc::new(@w.get_ref());\n+    let doc = rbml::Doc::new(@w.get_ref());\n     let mut dec = Decoder::new(doc);\n     let obj2 = Decodable::decode(&mut dec);\n     assert!(obj == obj2);"}, {"sha": "799cea865a331251eea5614231efd7bc5562d105", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dcbefe52d4c5877602a17270cf5a1b6882c232/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=e1dcbefe52d4c5877602a17270cf5a1b6882c232", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern crate rbml;\n extern crate serialize;\n \n use std::io;\n@@ -16,7 +17,7 @@ use std::slice;\n \n use serialize::{Encodable, Encoder};\n use serialize::json;\n-use serialize::ebml::writer;\n+use rbml::writer;\n \n static BUF_CAPACITY: uint = 128;\n \n@@ -144,7 +145,7 @@ struct Bar {\n \n enum WireProtocol {\n     JSON,\n-    EBML,\n+    RBML,\n     // ...\n }\n \n@@ -155,7 +156,7 @@ fn encode_json<'a,\n     let mut encoder = json::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n-fn encode_ebml<'a,\n+fn encode_rbml<'a,\n                T: Encodable<writer::Encoder<'a, SeekableMemWriter>,\n                             std::io::IoError>>(val: &T,\n                                                wr: &'a mut SeekableMemWriter) {\n@@ -169,6 +170,6 @@ pub fn main() {\n     let proto = JSON;\n     match proto {\n         JSON => encode_json(&target, &mut wr),\n-        EBML => encode_ebml(&target, &mut wr)\n+        RBML => encode_rbml(&target, &mut wr)\n     }\n }"}]}