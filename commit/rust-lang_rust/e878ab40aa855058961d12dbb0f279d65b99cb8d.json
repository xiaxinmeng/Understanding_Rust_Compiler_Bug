{"sha": "e878ab40aa855058961d12dbb0f279d65b99cb8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NzhhYjQwYWE4NTUwNTg5NjFkMTJkYmIwZjI3OWQ2NWI5OWNiOGQ=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-03-30T13:09:49Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-03-30T13:09:49Z"}, "message": "Merge pull request #790 from oli-obk/bool_opt\n\noptimize booleans", "tree": {"sha": "bc5cb489e7fa0ca1b83d02396748b6bafafd0131", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc5cb489e7fa0ca1b83d02396748b6bafafd0131"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e878ab40aa855058961d12dbb0f279d65b99cb8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e878ab40aa855058961d12dbb0f279d65b99cb8d", "html_url": "https://github.com/rust-lang/rust/commit/e878ab40aa855058961d12dbb0f279d65b99cb8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e878ab40aa855058961d12dbb0f279d65b99cb8d/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf95374486bccf7f665aa695ad669256f3bbc8e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf95374486bccf7f665aa695ad669256f3bbc8e2", "html_url": "https://github.com/rust-lang/rust/commit/cf95374486bccf7f665aa695ad669256f3bbc8e2"}, {"sha": "2917484130db16c4533f0e241dd89352ec3b2ba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2917484130db16c4533f0e241dd89352ec3b2ba6", "html_url": "https://github.com/rust-lang/rust/commit/2917484130db16c4533f0e241dd89352ec3b2ba6"}], "stats": {"total": 505, "additions": 500, "deletions": 5}, "files": [{"sha": "058dc012cfa5cbc61cbc0324fbf2386916f7d4fe", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e878ab40aa855058961d12dbb0f279d65b99cb8d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e878ab40aa855058961d12dbb0f279d65b99cb8d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=e878ab40aa855058961d12dbb0f279d65b99cb8d", "patch": "@@ -23,6 +23,7 @@ regex_macros = { version = \"0.1.33\", optional = true }\n semver = \"0.2.1\"\n toml = \"0.1\"\n unicode-normalization = \"0.1\"\n+quine-mc_cluskey = \"0.2.2\"\n \n [dev-dependencies]\n compiletest_rs = \"0.1.0\""}, {"sha": "e59012c81651c3f38436cdb0d5083eae9322943f", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878ab40aa855058961d12dbb0f279d65b99cb8d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/e878ab40aa855058961d12dbb0f279d65b99cb8d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=e878ab40aa855058961d12dbb0f279d65b99cb8d", "patch": "@@ -14,7 +14,7 @@ Table of contents:\n * [License](#license)\n \n ##Lints\n-There are 137 lints included in this crate:\n+There are 139 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -75,6 +75,7 @@ name\n [let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                                     | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n [let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                                     | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n [linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                                             | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n+[logic_bug](https://github.com/Manishearth/rust-clippy/wiki#logic_bug)                                               | warn    | checks for boolean expressions that contain terminals which can be eliminated\n [manual_swap](https://github.com/Manishearth/rust-clippy/wiki#manual_swap)                                           | warn    | manual swap\n [many_single_char_names](https://github.com/Manishearth/rust-clippy/wiki#many_single_char_names)                     | warn    | too many single character bindings\n [map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                               | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n@@ -97,6 +98,7 @@ name\n [new_without_default](https://github.com/Manishearth/rust-clippy/wiki#new_without_default)                           | warn    | `fn new() -> Self` method without `Default` implementation\n [no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                               | warn    | statements with no effect\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                               | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n+[nonminimal_bool](https://github.com/Manishearth/rust-clippy/wiki#nonminimal_bool)                                   | allow   | checks for boolean expressions that can be written more concisely\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)                 | warn    | nonsensical combination of options for opening a file\n [ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                               | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n [option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)                         | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`"}, {"sha": "877a45a355adea01cdbea2713704db87bb892b38", "filename": "src/booleans.rs", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/e878ab40aa855058961d12dbb0f279d65b99cb8d/src%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878ab40aa855058961d12dbb0f279d65b99cb8d/src%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbooleans.rs?ref=e878ab40aa855058961d12dbb0f279d65b99cb8d", "patch": "@@ -0,0 +1,362 @@\n+use rustc::lint::{LintArray, LateLintPass, LateContext, LintPass};\n+use rustc_front::hir::*;\n+use rustc_front::intravisit::*;\n+use syntax::ast::{LitKind, DUMMY_NODE_ID};\n+use syntax::codemap::{DUMMY_SP, dummy_spanned};\n+use utils::{span_lint_and_then, in_macro, snippet_opt, SpanlessEq};\n+\n+/// **What it does:** This lint checks for boolean expressions that can be written more concisely\n+///\n+/// **Why is this bad?** Readability of boolean expressions suffers from unnecesessary duplication\n+///\n+/// **Known problems:** Ignores short circuting behavior of `||` and `&&`. Ignores `|`, `&` and `^`.\n+///\n+/// **Example:** `if a && true` should be `if a` and `!(a == b)` should be `a != b`\n+declare_lint! {\n+    pub NONMINIMAL_BOOL, Allow,\n+    \"checks for boolean expressions that can be written more concisely\"\n+}\n+\n+/// **What it does:** This lint checks for boolean expressions that contain terminals that can be eliminated\n+///\n+/// **Why is this bad?** This is most likely a logic bug\n+///\n+/// **Known problems:** Ignores short circuiting behavior\n+///\n+/// **Example:** The `b` in `if a && b || a` is unnecessary because the expression is equivalent to `if a`\n+declare_lint! {\n+    pub LOGIC_BUG, Warn,\n+    \"checks for boolean expressions that contain terminals which can be eliminated\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct NonminimalBool;\n+\n+impl LintPass for NonminimalBool {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NONMINIMAL_BOOL, LOGIC_BUG)\n+    }\n+}\n+\n+impl LateLintPass for NonminimalBool {\n+    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+        NonminimalBoolVisitor(cx).visit_item(item)\n+    }\n+}\n+\n+struct NonminimalBoolVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n+\n+use quine_mc_cluskey::Bool;\n+struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n+    terminals: Vec<&'v Expr>,\n+    cx: &'a LateContext<'a, 'tcx>\n+}\n+\n+impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n+    fn extract(&mut self, op: BinOp_, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n+        for a in a {\n+            if let ExprBinary(binop, ref lhs, ref rhs) = a.node {\n+                if binop.node == op {\n+                    v = self.extract(op, &[lhs, rhs], v)?;\n+                    continue;\n+                }\n+            }\n+            v.push(self.run(a)?);\n+        }\n+        Ok(v)\n+    }\n+\n+    fn run(&mut self, e: &'v Expr) -> Result<Bool, String> {\n+        // prevent folding of `cfg!` macros and the like\n+        if !in_macro(self.cx, e.span) {\n+            match e.node {\n+                ExprUnary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+                ExprBinary(binop, ref lhs, ref rhs) => {\n+                    match binop.node {\n+                        BiOr => return Ok(Bool::Or(self.extract(BiOr, &[lhs, rhs], Vec::new())?)),\n+                        BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n+                        _ => {},\n+                    }\n+                },\n+                ExprLit(ref lit) => {\n+                    match lit.node {\n+                        LitKind::Bool(true) => return Ok(Bool::True),\n+                        LitKind::Bool(false) => return Ok(Bool::False),\n+                        _ => {},\n+                    }\n+                },\n+                _ => {},\n+            }\n+        }\n+        for (n, expr) in self.terminals.iter().enumerate() {\n+            if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e, expr) {\n+                #[allow(cast_possible_truncation)]\n+                return Ok(Bool::Term(n as u8));\n+            }\n+            let negated = match e.node {\n+                ExprBinary(binop, ref lhs, ref rhs) => {\n+                    let mk_expr = |op| Expr {\n+                        id: DUMMY_NODE_ID,\n+                        span: DUMMY_SP,\n+                        attrs: None,\n+                        node: ExprBinary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n+                    };\n+                    match binop.node {\n+                        BiEq => mk_expr(BiNe),\n+                        BiNe => mk_expr(BiEq),\n+                        BiGt => mk_expr(BiLe),\n+                        BiGe => mk_expr(BiLt),\n+                        BiLt => mk_expr(BiGe),\n+                        BiLe => mk_expr(BiGt),\n+                        _ => continue,\n+                    }\n+                },\n+                _ => continue,\n+            };\n+            if SpanlessEq::new(self.cx).ignore_fn().eq_expr(&negated, expr) {\n+                #[allow(cast_possible_truncation)]\n+                return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n+            }\n+        }\n+        let n = self.terminals.len();\n+        self.terminals.push(e);\n+        if n < 32 {\n+            #[allow(cast_possible_truncation)]\n+            Ok(Bool::Term(n as u8))\n+        } else {\n+            Err(\"too many literals\".to_owned())\n+        }\n+    }\n+}\n+\n+fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n+    fn recurse(brackets: bool, cx: &LateContext, suggestion: &Bool, terminals: &[&Expr], mut s: String) -> String {\n+        use quine_mc_cluskey::Bool::*;\n+        let snip = |e: &Expr| snippet_opt(cx, e.span).expect(\"don't try to improve booleans created by macros\");\n+        match *suggestion {\n+            True => {\n+                s.push_str(\"true\");\n+                s\n+            },\n+            False => {\n+                s.push_str(\"false\");\n+                s\n+            },\n+            Not(ref inner) => {\n+                match **inner {\n+                    And(_) | Or(_) => {\n+                        s.push('!');\n+                        recurse(true, cx, inner, terminals, s)\n+                    },\n+                    Term(n) => {\n+                        if let ExprBinary(binop, ref lhs, ref rhs) = terminals[n as usize].node {\n+                            let op = match binop.node {\n+                                BiEq => \" != \",\n+                                BiNe => \" == \",\n+                                BiLt => \" >= \",\n+                                BiGt => \" <= \",\n+                                BiLe => \" > \",\n+                                BiGe => \" < \",\n+                                _ => {\n+                                    s.push('!');\n+                                    return recurse(true, cx, inner, terminals, s)\n+                                },\n+                            };\n+                            s.push_str(&snip(lhs));\n+                            s.push_str(op);\n+                            s.push_str(&snip(rhs));\n+                            s\n+                        } else {\n+                            s.push('!');\n+                            recurse(false, cx, inner, terminals, s)\n+                        }\n+                    },\n+                    _ => {\n+                        s.push('!');\n+                        recurse(false, cx, inner, terminals, s)\n+                    },\n+                }\n+            },\n+            And(ref v) => {\n+                if brackets {\n+                    s.push('(');\n+                }\n+                if let Or(_) = v[0] {\n+                    s = recurse(true, cx, &v[0], terminals, s);\n+                } else {\n+                    s = recurse(false, cx, &v[0], terminals, s);\n+                }\n+                for inner in &v[1..] {\n+                    s.push_str(\" && \");\n+                    if let Or(_) = *inner {\n+                        s = recurse(true, cx, inner, terminals, s);\n+                    } else {\n+                        s = recurse(false, cx, inner, terminals, s);\n+                    }\n+                }\n+                if brackets {\n+                    s.push(')');\n+                }\n+                s\n+            },\n+            Or(ref v) => {\n+                if brackets {\n+                    s.push('(');\n+                }\n+                s = recurse(false, cx, &v[0], terminals, s);\n+                for inner in &v[1..] {\n+                    s.push_str(\" || \");\n+                    s = recurse(false, cx, inner, terminals, s);\n+                }\n+                if brackets {\n+                    s.push(')');\n+                }\n+                s\n+            },\n+            Term(n) => {\n+                if brackets {\n+                    if let ExprBinary(..) = terminals[n as usize].node {\n+                        s.push('(');\n+                    }\n+                }\n+                s.push_str(&snip(&terminals[n as usize]));\n+                if brackets {\n+                    if let ExprBinary(..) = terminals[n as usize].node {\n+                        s.push(')');\n+                    }\n+                }\n+                s\n+            }\n+        }\n+    }\n+    recurse(false, cx, suggestion, terminals, String::new())\n+}\n+\n+fn simple_negate(b: Bool) -> Bool {\n+    use quine_mc_cluskey::Bool::*;\n+    match b {\n+        True => False,\n+        False => True,\n+        t @ Term(_) => Not(Box::new(t)),\n+        And(mut v) => {\n+            for el in &mut v {\n+                *el = simple_negate(::std::mem::replace(el, True));\n+            }\n+            Or(v)\n+        },\n+        Or(mut v) => {\n+            for el in &mut v {\n+                *el = simple_negate(::std::mem::replace(el, True));\n+            }\n+            And(v)\n+        },\n+        Not(inner) => *inner,\n+    }\n+}\n+\n+#[derive(Default)]\n+struct Stats {\n+    terminals: [usize; 32],\n+    negations: usize,\n+    ops: usize,\n+}\n+\n+fn terminal_stats(b: &Bool) -> Stats {\n+    fn recurse(b: &Bool, stats: &mut Stats) {\n+        match *b {\n+            True | False => stats.ops += 1,\n+            Not(ref inner) => {\n+                match **inner {\n+                    And(_) | Or(_) => stats.ops += 1, // brackets are also operations\n+                    _ => stats.negations += 1,\n+                }\n+                recurse(inner, stats);\n+            },\n+            And(ref v) | Or(ref v) => {\n+                stats.ops += v.len() - 1;\n+                for inner in v {\n+                    recurse(inner, stats);\n+                }\n+            },\n+            Term(n) => stats.terminals[n as usize] += 1,\n+        }\n+    }\n+    use quine_mc_cluskey::Bool::*;\n+    let mut stats = Stats::default();\n+    recurse(b, &mut stats);\n+    stats\n+}\n+\n+impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n+    fn bool_expr(&self, e: &Expr) {\n+        let mut h2q = Hir2Qmm {\n+            terminals: Vec::new(),\n+            cx: self.0,\n+        };\n+        if let Ok(expr) = h2q.run(e) {\n+            let stats = terminal_stats(&expr);\n+            let mut simplified = expr.simplify();\n+            for simple in Bool::Not(Box::new(expr.clone())).simplify() {\n+                match simple {\n+                    Bool::Not(_) | Bool::True | Bool::False => {},\n+                    _ => simplified.push(Bool::Not(Box::new(simple.clone()))),\n+                }\n+                let simple_negated = simple_negate(simple);\n+                if simplified.iter().any(|s| *s == simple_negated) {\n+                    continue;\n+                }\n+                simplified.push(simple_negated);\n+            }\n+            let mut improvements = Vec::new();\n+            'simplified: for suggestion in &simplified {\n+                let simplified_stats = terminal_stats(&suggestion);\n+                let mut improvement = false;\n+                for i in 0..32 {\n+                    // ignore any \"simplifications\" that end up requiring a terminal more often than in the original expression\n+                    if stats.terminals[i] < simplified_stats.terminals[i] {\n+                        continue 'simplified;\n+                    }\n+                    if stats.terminals[i] != 0 && simplified_stats.terminals[i] == 0 {\n+                        span_lint_and_then(self.0, LOGIC_BUG, e.span, \"this boolean expression contains a logic bug\", |db| {\n+                            db.span_help(h2q.terminals[i].span, \"this expression can be optimized out by applying boolean operations to the outer expression\");\n+                            db.span_suggestion(e.span, \"it would look like the following\", suggest(self.0, suggestion, &h2q.terminals));\n+                        });\n+                        // don't also lint `NONMINIMAL_BOOL`\n+                        return;\n+                    }\n+                    // if the number of occurrences of a terminal decreases or any of the stats decreases while none increases\n+                    improvement |= (stats.terminals[i] > simplified_stats.terminals[i]) ||\n+                        (stats.negations > simplified_stats.negations && stats.ops == simplified_stats.ops) ||\n+                        (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n+                }\n+                if improvement {\n+                    improvements.push(suggestion);\n+                }\n+            }\n+            if !improvements.is_empty() {\n+                span_lint_and_then(self.0, NONMINIMAL_BOOL, e.span, \"this boolean expression can be simplified\", |db| {\n+                    for suggestion in &improvements {\n+                        db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.terminals));\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'v Expr) {\n+        if in_macro(self.0, e.span) { return }\n+        match e.node {\n+            ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n+            ExprUnary(UnNot, ref inner) => {\n+                if self.0.tcx.node_types()[&inner.id].is_bool() {\n+                    self.bool_expr(e);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            },\n+            _ => walk_expr(self, e),\n+        }\n+    }\n+}"}, {"sha": "2d12532fcfea00997db66f84cd4385ece2e65232", "filename": "src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e878ab40aa855058961d12dbb0f279d65b99cb8d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878ab40aa855058961d12dbb0f279d65b99cb8d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e878ab40aa855058961d12dbb0f279d65b99cb8d", "patch": "@@ -4,6 +4,8 @@\n #![feature(iter_arith)]\n #![feature(custom_attribute)]\n #![feature(slice_patterns)]\n+#![feature(question_mark)]\n+#![feature(stmt_expr_attributes)]\n #![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n \n // this only exists to allow the \"dogfood\" integration test to work\n@@ -35,6 +37,9 @@ extern crate semver;\n // for regex checking\n extern crate regex_syntax;\n \n+// for finding minimal boolean expressions\n+extern crate quine_mc_cluskey;\n+\n extern crate rustc_plugin;\n extern crate rustc_const_eval;\n use rustc_plugin::Registry;\n@@ -50,6 +55,7 @@ pub mod attrs;\n pub mod bit_mask;\n pub mod blacklisted_name;\n pub mod block_in_if_condition;\n+pub mod booleans;\n pub mod collapsible_if;\n pub mod copies;\n pub mod cyclomatic_complexity;\n@@ -149,6 +155,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     reg.register_late_lint_pass(box types::TypePass);\n+    reg.register_late_lint_pass(box booleans::NonminimalBool);\n     reg.register_late_lint_pass(box misc::TopLevelRefPass);\n     reg.register_late_lint_pass(box misc::CmpNan);\n     reg.register_late_lint_pass(box eq_op::EqOp);\n@@ -228,6 +235,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         array_indexing::INDEXING_SLICING,\n+        booleans::NONMINIMAL_BOOL,\n         enum_glob_use::ENUM_GLOB_USE,\n         matches::SINGLE_MATCH_ELSE,\n         methods::OPTION_UNWRAP_USED,\n@@ -260,6 +268,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         blacklisted_name::BLACKLISTED_NAME,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n+        booleans::LOGIC_BUG,\n         collapsible_if::COLLAPSIBLE_IF,\n         copies::IF_SAME_THEN_ELSE,\n         copies::IFS_SAME_COND,"}, {"sha": "87373c7a0ded2e535525c8427d9e1e1e7b2014eb", "filename": "src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878ab40aa855058961d12dbb0f279d65b99cb8d/src%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878ab40aa855058961d12dbb0f279d65b99cb8d/src%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnon_expressive_names.rs?ref=e878ab40aa855058961d12dbb0f279d65b99cb8d", "patch": "@@ -262,7 +262,7 @@ fn levenstein_not_1(a_name: &str, b_name: &str) -> bool {\n         }\n         if let Some(b2) = b_chars.next() {\n             // check if there's just one character inserted\n-            return !(a == b2 && a_chars.eq(b_chars));\n+            return a != b2 || a_chars.ne(b_chars);\n         } else {\n             // tuple\n             // ntuple"}, {"sha": "0659e26d0f27fe85d726bb14fa974cea482d5154", "filename": "src/utils/hir.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e878ab40aa855058961d12dbb0f279d65b99cb8d/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878ab40aa855058961d12dbb0f279d65b99cb8d/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=e878ab40aa855058961d12dbb0f279d65b99cb8d", "patch": "@@ -75,7 +75,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             }\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n             (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n-                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n+                swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr))\n             }\n             (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n@@ -197,6 +198,23 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n }\n \n+fn swap_binop<'a>(binop: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOp_, &'a Expr, &'a Expr)> {\n+    match binop {\n+        BiAdd |\n+        BiMul |\n+        BiBitXor |\n+        BiBitAnd |\n+        BiEq |\n+        BiNe |\n+        BiBitOr => Some((binop, rhs, lhs)),\n+        BiLt => Some((BiGt, rhs, lhs)),\n+        BiLe => Some((BiGe, rhs, lhs)),\n+        BiGe => Some((BiLe, rhs, lhs)),\n+        BiGt => Some((BiLt, rhs, lhs)),\n+        BiShl | BiShr | BiRem | BiSub | BiDiv | BiAnd | BiOr => None,\n+    }\n+}\n+\n /// Check if the two `Option`s are both `None` or some equal values as per `eq_fn`.\n fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n     where F: FnMut(&X, &X) -> bool"}, {"sha": "3d47fc74a113deb6e97e489db744496c7ef11182", "filename": "tests/compile-fail/block_in_if_condition.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e878ab40aa855058961d12dbb0f279d65b99cb8d/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878ab40aa855058961d12dbb0f279d65b99cb8d/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fblock_in_if_condition.rs?ref=e878ab40aa855058961d12dbb0f279d65b99cb8d", "patch": "@@ -4,6 +4,7 @@\n #![deny(block_in_if_condition_expr)]\n #![deny(block_in_if_condition_stmt)]\n #![allow(unused, let_and_return)]\n+#![warn(nonminimal_bool)]\n \n \n macro_rules! blocky {\n@@ -67,7 +68,7 @@ fn pred_test() {\n \n fn condition_is_normal() -> i32 {\n     let x = 3;\n-    if true && x == 3 {\n+    if true && x == 3 { //~ WARN this boolean expression can be simplified\n         6\n     } else {\n         10"}, {"sha": "aba55f0b8b486f3dc73edf5aae1075a6030e1016", "filename": "tests/compile-fail/booleans.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e878ab40aa855058961d12dbb0f279d65b99cb8d/tests%2Fcompile-fail%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878ab40aa855058961d12dbb0f279d65b99cb8d/tests%2Fcompile-fail%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbooleans.rs?ref=e878ab40aa855058961d12dbb0f279d65b99cb8d", "patch": "@@ -0,0 +1,87 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(nonminimal_bool, logic_bug)]\n+\n+#[allow(unused, many_single_char_names)]\n+fn main() {\n+    let a: bool = unimplemented!();\n+    let b: bool = unimplemented!();\n+    let c: bool = unimplemented!();\n+    let d: bool = unimplemented!();\n+    let e: bool = unimplemented!();\n+    let _ = a && b || a; //~ ERROR this boolean expression contains a logic bug\n+    //~| HELP for further information visit\n+    //~| HELP this expression can be optimized out\n+    //~| HELP it would look like the following\n+    //~| SUGGESTION let _ = a;\n+    let _ = !(a && b);\n+    let _ = !true; //~ ERROR this boolean expression can be simplified\n+    //~| HELP for further information visit\n+    //~| SUGGESTION let _ = false;\n+    let _ = !false; //~ ERROR this boolean expression can be simplified\n+    //~| HELP for further information visit\n+    //~| SUGGESTION let _ = true;\n+    let _ = !!a; //~ ERROR this boolean expression can be simplified\n+    //~| HELP for further information visit\n+    //~| SUGGESTION let _ = a;\n+\n+    let _ = false && a; //~ ERROR this boolean expression contains a logic bug\n+    //~| HELP for further information visit\n+    //~| HELP this expression can be optimized out\n+    //~| HELP it would look like the following\n+    //~| SUGGESTION let _ = false;\n+\n+    let _ = false || a; //~ ERROR this boolean expression can be simplified\n+    //~| HELP for further information visit\n+    //~| SUGGESTION let _ = a;\n+\n+    // don't lint on cfgs\n+    let _ = cfg!(you_shall_not_not_pass) && a;\n+\n+    let _ = a || !b || !c || !d || !e;\n+\n+    let _ = !(a && b || c);\n+\n+    let _ = !(!a && b); //~ ERROR this boolean expression can be simplified\n+    //~| HELP for further information visit\n+    //~| SUGGESTION let _ = !b || a;\n+}\n+\n+#[allow(unused, many_single_char_names)]\n+fn equality_stuff() {\n+    let a: i32 = unimplemented!();\n+    let b: i32 = unimplemented!();\n+    let c: i32 = unimplemented!();\n+    let d: i32 = unimplemented!();\n+    let e: i32 = unimplemented!();\n+    let _ = a == b && a != b; //~ ERROR this boolean expression contains a logic bug\n+    //~| HELP for further information visit\n+    //~| HELP this expression can be optimized out\n+    //~| HELP it would look like the following\n+    //~| SUGGESTION let _ = false;\n+    let _ = a == b && c == 5 && a == b; //~ ERROR this boolean expression can be simplified\n+    //~| HELP for further information visit\n+    //~| SUGGESTION let _ = a == b && c == 5;\n+    let _ = a == b && c == 5 && b == a; //~ ERROR this boolean expression can be simplified\n+    //~| HELP for further information visit\n+    //~| SUGGESTION let _ = a == b && c == 5;\n+    //~| HELP try\n+    //~| SUGGESTION let _ = !(c != 5 || a != b);\n+    let _ = a < b && a >= b; //~ ERROR this boolean expression contains a logic bug\n+    //~| HELP for further information visit\n+    //~| HELP this expression can be optimized out\n+    //~| HELP it would look like the following\n+    //~| SUGGESTION let _ = false;\n+    let _ = a > b && a <= b; //~ ERROR this boolean expression contains a logic bug\n+    //~| HELP for further information visit\n+    //~| HELP this expression can be optimized out\n+    //~| HELP it would look like the following\n+    //~| SUGGESTION let _ = false;\n+    let _ = a > b && a == b;\n+\n+    let _ = a != b || !(a != b || c == d); //~ ERROR this boolean expression can be simplified\n+    //~| HELP for further information visit\n+    //~| SUGGESTION let _ = c != d || a != b;\n+    //~| HELP try\n+    //~| SUGGESTION let _ = !(a == b && c == d);\n+}"}, {"sha": "443bbbaacd3670344e545b932334472bfd69dfca", "filename": "tests/compile-fail/eq_op.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e878ab40aa855058961d12dbb0f279d65b99cb8d/tests%2Fcompile-fail%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878ab40aa855058961d12dbb0f279d65b99cb8d/tests%2Fcompile-fail%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feq_op.rs?ref=e878ab40aa855058961d12dbb0f279d65b99cb8d", "patch": "@@ -3,7 +3,8 @@\n \n #[deny(eq_op)]\n #[allow(identity_op)]\n-#[allow(no_effect)]\n+#[allow(no_effect, unused_variables)]\n+#[deny(nonminimal_bool)]\n fn main() {\n     // simple values and comparisons\n     1 == 1; //~ERROR equal expressions\n@@ -38,7 +39,21 @@ fn main() {\n     1 - 1; //~ERROR equal expressions\n     1 / 1; //~ERROR equal expressions\n     true && true; //~ERROR equal expressions\n+    //~|ERROR this boolean expression can be simplified\n     true || true; //~ERROR equal expressions\n+    //~|ERROR this boolean expression can be simplified\n+\n+    let a: u32 = unimplemented!();\n+    let b: u32 = unimplemented!();\n+\n+    a == b && b == a; //~ERROR equal expressions\n+    //~|ERROR this boolean expression can be simplified\n+    a != b && b != a; //~ERROR equal expressions\n+    //~|ERROR this boolean expression can be simplified\n+    a < b && b > a; //~ERROR equal expressions\n+    //~|ERROR this boolean expression can be simplified\n+    a <= b && b >= a; //~ERROR equal expressions\n+    //~|ERROR this boolean expression can be simplified\n \n     let mut a = vec![1];\n     a == a; //~ERROR equal expressions"}]}