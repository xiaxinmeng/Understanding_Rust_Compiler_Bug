{"sha": "5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMTUwMGVjNzQ5M2YyZTgyMDIwZWVmZDE3YTlmMzg0YThhNDJmNGI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-18T13:40:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-18T13:40:45Z"}, "message": "Merge #6030\n\n6030: Small proc macro cleanup r=jonas-schievink a=jonas-schievink\n\ngit got really confused, but all I did in the first commit was unindent a few lines\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "72332355087da5fb9f518ae04a9fa73a4f93a70d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72332355087da5fb9f518ae04a9fa73a4f93a70d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfZLjdCRBK7hj4Ov3rIwAAdHIIAI1VQvyUaV2Qbu6c3unBRsgQ\nS8nXYUqPl3+2oNqZM0w8cGVVfDrTHhz6RVZ3GbJK+uaLHVY4et/EbLMcmVVS0K8J\ncWpY3so83QdzZ+JqIa1lTTvty82Be1vXrts/W7LHnJNtWqmHx6iJL6Pv0NoehJJj\n8OeeJz1i664BjYBz39f44TOm6xtSbvrVpZ0T5Y80vEx1Hvy8xZTqU1HxTzeurULc\n3o7p6JpaihzvDQvHLwDVyQKuxFTqkKAFM0+1JgtRYfyxZpXrLgGvRqvfKML30o1L\nutMSafy/YBdu/P7T4dw2WU3+g9oSDzNtabFe21wOzy+ZHR8Cy8G++zqGzM71SVg=\n=5gCs\n-----END PGP SIGNATURE-----\n", "payload": "tree 72332355087da5fb9f518ae04a9fa73a4f93a70d\nparent 086f1c4b3025b405fde077df3319551140136131\nparent 9dc0afe854380f17bbec9100187ef3d3aa397f28\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1600436445 +0000\ncommitter GitHub <noreply@github.com> 1600436445 +0000\n\nMerge #6030\n\n6030: Small proc macro cleanup r=jonas-schievink a=jonas-schievink\n\ngit got really confused, but all I did in the first commit was unindent a few lines\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "html_url": "https://github.com/rust-lang/rust/commit/5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "086f1c4b3025b405fde077df3319551140136131", "url": "https://api.github.com/repos/rust-lang/rust/commits/086f1c4b3025b405fde077df3319551140136131", "html_url": "https://github.com/rust-lang/rust/commit/086f1c4b3025b405fde077df3319551140136131"}, {"sha": "9dc0afe854380f17bbec9100187ef3d3aa397f28", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dc0afe854380f17bbec9100187ef3d3aa397f28", "html_url": "https://github.com/rust-lang/rust/commit/9dc0afe854380f17bbec9100187ef3d3aa397f28"}], "stats": {"total": 331, "additions": 165, "deletions": 166}, "files": [{"sha": "849c8f6d0987281e12fb7edf65fb62be9ae7abc3", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "patch": "@@ -908,12 +908,12 @@ impl MacroDef {\n \n     /// Indicate it is a proc-macro\n     pub fn is_proc_macro(&self) -> bool {\n-        matches!(self.id.kind, MacroDefKind::CustomDerive(_))\n+        matches!(self.id.kind, MacroDefKind::ProcMacro(_))\n     }\n \n     /// Indicate it is a derive macro\n     pub fn is_derive_macro(&self) -> bool {\n-        matches!(self.id.kind, MacroDefKind::CustomDerive(_) | MacroDefKind::BuiltInDerive(_))\n+        matches!(self.id.kind, MacroDefKind::ProcMacro(_) | MacroDefKind::BuiltInDerive(_))\n     }\n }\n "}, {"sha": "4c3993ff01b4647aabcc504a3bacd21723c9ea19", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 158, "deletions": 159, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "patch": "@@ -273,7 +273,7 @@ impl DefCollector<'_> {\n             let macro_id = MacroDefId {\n                 ast_id: None,\n                 krate: Some(krate),\n-                kind: MacroDefKind::CustomDerive(expander),\n+                kind: MacroDefKind::ProcMacro(expander),\n                 local_inner: false,\n             };\n \n@@ -874,184 +874,183 @@ impl ModCollector<'_, '_> {\n \n         for &item in items {\n             let attrs = self.item_tree.attrs(item.into());\n-            if self.is_cfg_enabled(attrs) {\n-                let module =\n-                    ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n-                let container = ContainerId::ModuleId(module);\n-\n-                let mut def = None;\n-                match item {\n-                    ModItem::Mod(m) => self.collect_module(&self.item_tree[m], attrs),\n-                    ModItem::Import(import_id) => {\n-                        self.def_collector.unresolved_imports.push(ImportDirective {\n-                            module_id: self.module_id,\n-                            import: Import::from_use(\n-                                &self.item_tree,\n-                                InFile::new(self.file_id, import_id),\n-                            ),\n-                            status: PartialResolvedImport::Unresolved,\n-                        })\n-                    }\n-                    ModItem::ExternCrate(import_id) => {\n-                        self.def_collector.unresolved_imports.push(ImportDirective {\n-                            module_id: self.module_id,\n-                            import: Import::from_extern_crate(\n-                                &self.item_tree,\n-                                InFile::new(self.file_id, import_id),\n-                            ),\n-                            status: PartialResolvedImport::Unresolved,\n-                        })\n-                    }\n-                    ModItem::MacroCall(mac) => self.collect_macro(&self.item_tree[mac]),\n-                    ModItem::Impl(imp) => {\n-                        let module = ModuleId {\n-                            krate: self.def_collector.def_map.krate,\n-                            local_id: self.module_id,\n-                        };\n-                        let container = ContainerId::ModuleId(module);\n-                        let impl_id = ImplLoc { container, id: ItemTreeId::new(self.file_id, imp) }\n-                            .intern(self.def_collector.db);\n-                        self.def_collector.def_map.modules[self.module_id]\n-                            .scope\n-                            .define_impl(impl_id)\n-                    }\n-                    ModItem::Function(id) => {\n-                        let func = &self.item_tree[id];\n-                        def = Some(DefData {\n-                            id: FunctionLoc {\n-                                container: container.into(),\n-                                id: ItemTreeId::new(self.file_id, id),\n-                            }\n-                            .intern(self.def_collector.db)\n-                            .into(),\n-                            name: &func.name,\n-                            visibility: &self.item_tree[func.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::Struct(id) => {\n-                        let it = &self.item_tree[id];\n-\n-                        // FIXME: check attrs to see if this is an attribute macro invocation;\n-                        // in which case we don't add the invocation, just a single attribute\n-                        // macro invocation\n-                        self.collect_derives(attrs, it.ast_id.upcast());\n-\n-                        def = Some(DefData {\n-                            id: StructLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: it.kind != StructDefKind::Record,\n-                        });\n-                    }\n-                    ModItem::Union(id) => {\n-                        let it = &self.item_tree[id];\n+            if !self.is_cfg_enabled(attrs) {\n+                continue;\n+            }\n+            let module =\n+                ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n+            let container = ContainerId::ModuleId(module);\n+\n+            let mut def = None;\n+            match item {\n+                ModItem::Mod(m) => self.collect_module(&self.item_tree[m], attrs),\n+                ModItem::Import(import_id) => {\n+                    self.def_collector.unresolved_imports.push(ImportDirective {\n+                        module_id: self.module_id,\n+                        import: Import::from_use(\n+                            &self.item_tree,\n+                            InFile::new(self.file_id, import_id),\n+                        ),\n+                        status: PartialResolvedImport::Unresolved,\n+                    })\n+                }\n+                ModItem::ExternCrate(import_id) => {\n+                    self.def_collector.unresolved_imports.push(ImportDirective {\n+                        module_id: self.module_id,\n+                        import: Import::from_extern_crate(\n+                            &self.item_tree,\n+                            InFile::new(self.file_id, import_id),\n+                        ),\n+                        status: PartialResolvedImport::Unresolved,\n+                    })\n+                }\n+                ModItem::MacroCall(mac) => self.collect_macro(&self.item_tree[mac]),\n+                ModItem::Impl(imp) => {\n+                    let module = ModuleId {\n+                        krate: self.def_collector.def_map.krate,\n+                        local_id: self.module_id,\n+                    };\n+                    let container = ContainerId::ModuleId(module);\n+                    let impl_id = ImplLoc { container, id: ItemTreeId::new(self.file_id, imp) }\n+                        .intern(self.def_collector.db);\n+                    self.def_collector.def_map.modules[self.module_id].scope.define_impl(impl_id)\n+                }\n+                ModItem::Function(id) => {\n+                    let func = &self.item_tree[id];\n+                    def = Some(DefData {\n+                        id: FunctionLoc {\n+                            container: container.into(),\n+                            id: ItemTreeId::new(self.file_id, id),\n+                        }\n+                        .intern(self.def_collector.db)\n+                        .into(),\n+                        name: &func.name,\n+                        visibility: &self.item_tree[func.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+                ModItem::Struct(id) => {\n+                    let it = &self.item_tree[id];\n \n-                        // FIXME: check attrs to see if this is an attribute macro invocation;\n-                        // in which case we don't add the invocation, just a single attribute\n-                        // macro invocation\n-                        self.collect_derives(attrs, it.ast_id.upcast());\n+                    // FIXME: check attrs to see if this is an attribute macro invocation;\n+                    // in which case we don't add the invocation, just a single attribute\n+                    // macro invocation\n+                    self.collect_derives(attrs, it.ast_id.upcast());\n \n-                        def = Some(DefData {\n-                            id: UnionLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::Enum(id) => {\n-                        let it = &self.item_tree[id];\n+                    def = Some(DefData {\n+                        id: StructLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: it.kind != StructDefKind::Record,\n+                    });\n+                }\n+                ModItem::Union(id) => {\n+                    let it = &self.item_tree[id];\n \n-                        // FIXME: check attrs to see if this is an attribute macro invocation;\n-                        // in which case we don't add the invocation, just a single attribute\n-                        // macro invocation\n-                        self.collect_derives(attrs, it.ast_id.upcast());\n+                    // FIXME: check attrs to see if this is an attribute macro invocation;\n+                    // in which case we don't add the invocation, just a single attribute\n+                    // macro invocation\n+                    self.collect_derives(attrs, it.ast_id.upcast());\n \n-                        def = Some(DefData {\n-                            id: EnumLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::Const(id) => {\n-                        let it = &self.item_tree[id];\n-\n-                        if let Some(name) = &it.name {\n-                            def = Some(DefData {\n-                                id: ConstLoc {\n-                                    container: container.into(),\n-                                    id: ItemTreeId::new(self.file_id, id),\n-                                }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                                name,\n-                                visibility: &self.item_tree[it.visibility],\n-                                has_constructor: false,\n-                            });\n-                        }\n-                    }\n-                    ModItem::Static(id) => {\n-                        let it = &self.item_tree[id];\n+                    def = Some(DefData {\n+                        id: UnionLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+                ModItem::Enum(id) => {\n+                    let it = &self.item_tree[id];\n \n-                        def = Some(DefData {\n-                            id: StaticLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::Trait(id) => {\n-                        let it = &self.item_tree[id];\n+                    // FIXME: check attrs to see if this is an attribute macro invocation;\n+                    // in which case we don't add the invocation, just a single attribute\n+                    // macro invocation\n+                    self.collect_derives(attrs, it.ast_id.upcast());\n \n-                        def = Some(DefData {\n-                            id: TraitLoc { container, id: ItemTreeId::new(self.file_id, id) }\n-                                .intern(self.def_collector.db)\n-                                .into(),\n-                            name: &it.name,\n-                            visibility: &self.item_tree[it.visibility],\n-                            has_constructor: false,\n-                        });\n-                    }\n-                    ModItem::TypeAlias(id) => {\n-                        let it = &self.item_tree[id];\n+                    def = Some(DefData {\n+                        id: EnumLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+                ModItem::Const(id) => {\n+                    let it = &self.item_tree[id];\n \n+                    if let Some(name) = &it.name {\n                         def = Some(DefData {\n-                            id: TypeAliasLoc {\n+                            id: ConstLoc {\n                                 container: container.into(),\n                                 id: ItemTreeId::new(self.file_id, id),\n                             }\n                             .intern(self.def_collector.db)\n                             .into(),\n-                            name: &it.name,\n+                            name,\n                             visibility: &self.item_tree[it.visibility],\n                             has_constructor: false,\n                         });\n                     }\n                 }\n+                ModItem::Static(id) => {\n+                    let it = &self.item_tree[id];\n \n-                if let Some(DefData { id, name, visibility, has_constructor }) = def {\n-                    self.def_collector.def_map.modules[self.module_id].scope.define_def(id);\n-                    let vis = self\n-                        .def_collector\n-                        .def_map\n-                        .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n-                        .unwrap_or(Visibility::Public);\n-                    self.def_collector.update(\n-                        self.module_id,\n-                        &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor))],\n-                        vis,\n-                        ImportType::Named,\n-                    )\n+                    def = Some(DefData {\n+                        id: StaticLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+                ModItem::Trait(id) => {\n+                    let it = &self.item_tree[id];\n+\n+                    def = Some(DefData {\n+                        id: TraitLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n                 }\n+                ModItem::TypeAlias(id) => {\n+                    let it = &self.item_tree[id];\n+\n+                    def = Some(DefData {\n+                        id: TypeAliasLoc {\n+                            container: container.into(),\n+                            id: ItemTreeId::new(self.file_id, id),\n+                        }\n+                        .intern(self.def_collector.db)\n+                        .into(),\n+                        name: &it.name,\n+                        visibility: &self.item_tree[it.visibility],\n+                        has_constructor: false,\n+                    });\n+                }\n+            }\n+\n+            if let Some(DefData { id, name, visibility, has_constructor }) = def {\n+                self.def_collector.def_map.modules[self.module_id].scope.define_def(id);\n+                let vis = self\n+                    .def_collector\n+                    .def_map\n+                    .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n+                    .unwrap_or(Visibility::Public);\n+                self.def_collector.update(\n+                    self.module_id,\n+                    &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor))],\n+                    vis,\n+                    ImportType::Named,\n+                )\n             }\n         }\n     }"}, {"sha": "b591130ca4fae83aa2f260deea99c8d2e0a1dd53", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "patch": "@@ -143,7 +143,7 @@ pub(crate) fn macro_def(\n             Some(Arc::new((TokenExpander::BuiltinDerive(expander), mbe::TokenMap::default())))\n         }\n         MacroDefKind::BuiltInEager(_) => None,\n-        MacroDefKind::CustomDerive(expander) => {\n+        MacroDefKind::ProcMacro(expander) => {\n             Some(Arc::new((TokenExpander::ProcMacro(expander), mbe::TokenMap::default())))\n         }\n     }\n@@ -249,7 +249,7 @@ pub(crate) fn expand_proc_macro(\n     };\n \n     let expander = match loc.def.kind {\n-        MacroDefKind::CustomDerive(expander) => expander,\n+        MacroDefKind::ProcMacro(expander) => expander,\n         _ => unreachable!(),\n     };\n "}, {"sha": "2f37d7189c9421fe658ad82ba898c71b1157f919", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "patch": "@@ -129,7 +129,7 @@ fn eager_macro_recur(\n             MacroDefKind::Declarative\n             | MacroDefKind::BuiltIn(_)\n             | MacroDefKind::BuiltInDerive(_)\n-            | MacroDefKind::CustomDerive(_) => {\n+            | MacroDefKind::ProcMacro(_) => {\n                 let expanded = lazy_expand(db, &def, curr.with_value(child.clone()), krate)?;\n                 // replace macro inside\n                 eager_macro_recur(db, expanded, krate, macro_resolver)?"}, {"sha": "d383b968da1704a48b1a2ec38745e24c5a62e3b1", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "patch": "@@ -33,7 +33,7 @@ impl Hygiene {\n                         MacroDefKind::BuiltIn(_) => (None, false),\n                         MacroDefKind::BuiltInDerive(_) => (None, false),\n                         MacroDefKind::BuiltInEager(_) => (None, false),\n-                        MacroDefKind::CustomDerive(_) => (None, false),\n+                        MacroDefKind::ProcMacro(_) => (None, false),\n                     }\n                 }\n                 MacroCallId::EagerMacro(_id) => (None, false),"}, {"sha": "17f1178ed7026cfe9fc5a3a60546910a81ef356e", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1500ec7493f2e82020eefd17a9f384a8a42f4b/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=5e1500ec7493f2e82020eefd17a9f384a8a42f4b", "patch": "@@ -246,7 +246,7 @@ pub enum MacroDefKind {\n     // FIXME: maybe just Builtin and rename BuiltinFnLikeExpander to BuiltinExpander\n     BuiltInDerive(BuiltinDeriveExpander),\n     BuiltInEager(EagerExpander),\n-    CustomDerive(ProcMacroExpander),\n+    ProcMacro(ProcMacroExpander),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}]}