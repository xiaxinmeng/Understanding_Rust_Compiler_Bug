{"sha": "7c4d8e94ba58713c65f125f721e0d95f7f66c035", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNGQ4ZTk0YmE1ODcxM2M2NWYxMjVmNzIxZTBkOTVmN2Y2NmMwMzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-02T07:31:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-02T07:31:41Z"}, "message": "auto merge of #15257 : erickt/rust/hashmap, r=alexcrichton\n\nWhile `HashMap::new` and `HashMap::with_capacity` were being initialized with a random `SipHasher`, it turns out that `HashMap::from_iter` was just using the default instance of `SipHasher`, which wasn't randomized. This closes that bug, and also inlines some important methods.", "tree": {"sha": "1b1f3b807219e7b014e5a1ef1e64da9575f2ca90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b1f3b807219e7b014e5a1ef1e64da9575f2ca90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c4d8e94ba58713c65f125f721e0d95f7f66c035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4d8e94ba58713c65f125f721e0d95f7f66c035", "html_url": "https://github.com/rust-lang/rust/commit/7c4d8e94ba58713c65f125f721e0d95f7f66c035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c4d8e94ba58713c65f125f721e0d95f7f66c035/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89259b34c04aff7052dd122552fac3070c830f4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/89259b34c04aff7052dd122552fac3070c830f4f", "html_url": "https://github.com/rust-lang/rust/commit/89259b34c04aff7052dd122552fac3070c830f4f"}, {"sha": "d90b71cff68ec3748b9f42063513773da57e01e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d90b71cff68ec3748b9f42063513773da57e01e2", "html_url": "https://github.com/rust-lang/rust/commit/d90b71cff68ec3748b9f42063513773da57e01e2"}], "stats": {"total": 137, "additions": 121, "deletions": 16}, "files": [{"sha": "7c01a0342edc71b30bbcaf89597f1bfc10240b4c", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7c4d8e94ba58713c65f125f721e0d95f7f66c035/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4d8e94ba58713c65f125f721e0d95f7f66c035/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=7c4d8e94ba58713c65f125f721e0d95f7f66c035", "patch": "@@ -16,15 +16,13 @@ use collections::{Collection, Mutable, Set, MutableSet, Map, MutableMap};\n use default::Default;\n use fmt::Show;\n use fmt;\n-use hash::{Hash, Hasher, sip};\n+use hash::{Hash, Hasher, RandomSipHasher};\n use iter::{Iterator, FilterMap, Chain, Repeat, Zip, Extendable};\n use iter::{range, range_inclusive, FromIterator};\n use iter;\n use mem::replace;\n use num;\n use option::{Some, None, Option};\n-use rand::Rng;\n-use rand;\n use result::{Ok, Err};\n \n mod table {\n@@ -733,7 +731,7 @@ impl DefaultResizePolicy {\n /// }\n /// ```\n #[deriving(Clone)]\n-pub struct HashMap<K, V, H = sip::SipHasher> {\n+pub struct HashMap<K, V, H = RandomSipHasher> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n     hasher: H,\n \n@@ -1033,18 +1031,17 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H>\n \n }\n \n-impl<K: Hash + Eq, V> HashMap<K, V, sip::SipHasher> {\n+impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// Create an empty HashMap.\n-    pub fn new() -> HashMap<K, V, sip::SipHasher> {\n+    #[inline]\n+    pub fn new() -> HashMap<K, V, RandomSipHasher> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty hash map with the given initial capacity.\n-    pub fn with_capacity(capacity: uint) -> HashMap<K, V, sip::SipHasher> {\n-        let mut r = rand::task_rng();\n-        let r0 = r.gen();\n-        let r1 = r.gen();\n-        let hasher = sip::SipHasher::new_with_keys(r0, r1);\n+    #[inline]\n+    pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n+        let hasher = RandomSipHasher::new();\n         HashMap::with_capacity_and_hasher(capacity, hasher)\n     }\n }\n@@ -1053,6 +1050,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Creates an empty hashmap which will use the given hasher to hash keys.\n     ///\n     /// The creates map has the default initial capacity.\n+    #[inline]\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n         HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1064,6 +1062,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// is designed to allow HashMaps to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n+    #[inline]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n         let cap = num::next_power_of_two(max(INITIAL_CAPACITY, capacity));\n         HashMap {\n@@ -1489,7 +1488,7 @@ pub type SetMoveItems<K> =\n /// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n /// requires that the elements implement the `Eq` and `Hash` traits.\n #[deriving(Clone)]\n-pub struct HashSet<T, H = sip::SipHasher> {\n+pub struct HashSet<T, H = RandomSipHasher> {\n     map: HashMap<T, (), H>\n }\n \n@@ -1529,15 +1528,17 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n \n-impl<T: Hash + Eq> HashSet<T, sip::SipHasher> {\n+impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// Create an empty HashSet\n-    pub fn new() -> HashSet<T, sip::SipHasher> {\n+    #[inline]\n+    pub fn new() -> HashSet<T, RandomSipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Create an empty HashSet with space for at least `n` elements in\n     /// the hash table.\n-    pub fn with_capacity(capacity: uint) -> HashSet<T, sip::SipHasher> {\n+    #[inline]\n+    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n }\n@@ -1547,6 +1548,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// keys.\n     ///\n     /// The hash set is also created with the default initial capacity.\n+    #[inline]\n     pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n         HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1558,6 +1560,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// is designed to allow `HashSet`s to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n+    #[inline]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> {\n         HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n     }"}, {"sha": "2cc7e70747a794403675e44d28ea6a4b0b8d829d", "filename": "src/libstd/hash.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7c4d8e94ba58713c65f125f721e0d95f7f66c035/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4d8e94ba58713c65f125f721e0d95f7f66c035/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=7c4d8e94ba58713c65f125f721e0d95f7f66c035", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Generic hashing support.\n+ *\n+ * This module provides a generic way to compute the hash of a value. The\n+ * simplest way to make a type hashable is to use `#[deriving(Hash)]`:\n+ *\n+ * # Example\n+ *\n+ * ```rust\n+ * use std::hash;\n+ * use std::hash::Hash;\n+ *\n+ * #[deriving(Hash)]\n+ * struct Person {\n+ *     id: uint,\n+ *     name: String,\n+ *     phone: u64,\n+ * }\n+ *\n+ * let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n+ * let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n+ *\n+ * assert!(hash::hash(&person1) != hash::hash(&person2));\n+ * ```\n+ *\n+ * If you need more control over how a value is hashed, you need to implement\n+ * the trait `Hash`:\n+ *\n+ * ```rust\n+ * use std::hash;\n+ * use std::hash::Hash;\n+ * use std::hash::sip::SipState;\n+ *\n+ * struct Person {\n+ *     id: uint,\n+ *     name: String,\n+ *     phone: u64,\n+ * }\n+ *\n+ * impl Hash for Person {\n+ *     fn hash(&self, state: &mut SipState) {\n+ *         self.id.hash(state);\n+ *         self.phone.hash(state);\n+ *     }\n+ * }\n+ *\n+ * let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n+ * let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n+ *\n+ * assert!(hash::hash(&person1) == hash::hash(&person2));\n+ * ```\n+ */\n+\n+pub use core_collections::hash::{Hash, Hasher, Writer, hash, sip};\n+\n+use default::Default;\n+use rand::Rng;\n+use rand;\n+\n+/// `RandomSipHasher` computes the SipHash algorithm from a stream of bytes\n+/// initialized with random keys.\n+#[deriving(Clone)]\n+pub struct RandomSipHasher {\n+    hasher: sip::SipHasher,\n+}\n+\n+impl RandomSipHasher {\n+    /// Construct a new `RandomSipHasher` that is initialized with random keys.\n+    #[inline]\n+    pub fn new() -> RandomSipHasher {\n+        let mut r = rand::task_rng();\n+        let r0 = r.gen();\n+        let r1 = r.gen();\n+        RandomSipHasher {\n+            hasher: sip::SipHasher::new_with_keys(r0, r1),\n+        }\n+    }\n+}\n+\n+impl Hasher<sip::SipState> for RandomSipHasher {\n+    #[inline]\n+    fn hash<T: Hash<sip::SipState>>(&self, value: &T) -> u64 {\n+        self.hasher.hash(value)\n+    }\n+}\n+\n+impl Default for RandomSipHasher {\n+    #[inline]\n+    fn default() -> RandomSipHasher {\n+        RandomSipHasher::new()\n+    }\n+}"}, {"sha": "06a1d069b6a72b25f9a75eae9c489a88b8545bd4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4d8e94ba58713c65f125f721e0d95f7f66c035/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4d8e94ba58713c65f125f721e0d95f7f66c035/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7c4d8e94ba58713c65f125f721e0d95f7f66c035", "patch": "@@ -167,7 +167,6 @@ pub use core::option;\n pub use alloc::owned;\n pub use alloc::rc;\n \n-pub use core_collections::hash;\n pub use core_collections::slice;\n pub use core_collections::str;\n pub use core_collections::string;\n@@ -237,6 +236,7 @@ pub mod to_str;\n /* Common data structures */\n \n pub mod collections;\n+pub mod hash;\n \n /* Tasks and communication */\n "}]}