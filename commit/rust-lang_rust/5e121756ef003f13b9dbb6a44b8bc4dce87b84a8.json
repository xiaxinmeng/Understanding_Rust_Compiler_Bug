{"sha": "5e121756ef003f13b9dbb6a44b8bc4dce87b84a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMTIxNzU2ZWYwMDNmMTNiOWRiYjZhNDRiOGJjNGRjZTg3Yjg0YTg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-24T16:14:05Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-26T21:34:21Z"}, "message": "resolve: Generalize `early_resolve_ident_in_lexical_scope` slightly\n\nFlatten `ModuleOrUniformRoot` variants", "tree": {"sha": "3e1d434a10fa8d1518d8366be6604f999ced5ada", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e1d434a10fa8d1518d8366be6604f999ced5ada"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8", "html_url": "https://github.com/rust-lang/rust/commit/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c06e69ee70bf1fec4630458d8e4417efcabe0424", "url": "https://api.github.com/repos/rust-lang/rust/commits/c06e69ee70bf1fec4630458d8e4417efcabe0424", "html_url": "https://github.com/rust-lang/rust/commit/c06e69ee70bf1fec4630458d8e4417efcabe0424"}], "stats": {"total": 160, "additions": 78, "deletions": 82}, "files": [{"sha": "bc0e8a56157e56294e75c9dbacf7e89f63685142", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5e121756ef003f13b9dbb6a44b8bc4dce87b84a8", "patch": "@@ -102,6 +102,12 @@ enum Weak {\n     No,\n }\n \n+enum ScopeSet {\n+    Import(Namespace),\n+    Macro(MacroKind),\n+    Module,\n+}\n+\n /// A free importable items suggested in case of resolution failure.\n struct ImportSuggestion {\n     path: Path,\n@@ -997,31 +1003,28 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n-\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-enum UniformRootKind {\n-    CurrentScope,\n-    ExternPrelude,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n enum ModuleOrUniformRoot<'a> {\n     /// Regular module.\n     Module(Module<'a>),\n \n-    /// This \"virtual module\" denotes either resolution in extern prelude\n-    /// for paths starting with `::` on 2018 edition or `extern::`,\n-    /// or resolution in current scope for single-segment imports.\n-    UniformRoot(UniformRootKind),\n+    /// Virtual module that denotes resolution in extern prelude.\n+    /// Used for paths starting with `::` on 2018 edition or `extern::`.\n+    ExternPrelude,\n+\n+    /// Virtual module that denotes resolution in current scope.\n+    /// Used only for resolving single-segment imports. The reason it exists is that import paths\n+    /// are always split into two parts, the first of which should be some kind of module.\n+    CurrentScope,\n }\n \n impl<'a> PartialEq for ModuleOrUniformRoot<'a> {\n     fn eq(&self, other: &Self) -> bool {\n         match (*self, *other) {\n             (ModuleOrUniformRoot::Module(lhs), ModuleOrUniformRoot::Module(rhs)) =>\n                 ptr::eq(lhs, rhs),\n-            (ModuleOrUniformRoot::UniformRoot(lhs), ModuleOrUniformRoot::UniformRoot(rhs)) =>\n-                lhs == rhs,\n+            (ModuleOrUniformRoot::ExternPrelude, ModuleOrUniformRoot::ExternPrelude) => true,\n+            (ModuleOrUniformRoot::CurrentScope, ModuleOrUniformRoot::CurrentScope) => true,\n             _ => false,\n         }\n     }\n@@ -1758,8 +1761,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 error_callback(self, span, ResolutionError::FailedToResolve(msg));\n                 Def::Err\n             }\n-            PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n-            PathResult::Indeterminate => unreachable!(),\n+            PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n                 error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n                 Def::Err\n@@ -2220,11 +2222,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     self.current_module = self.macro_def_scope(def);\n                 }\n             }\n-            ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude) => {\n+            ModuleOrUniformRoot::ExternPrelude => {\n                 ident.span = ident.span.modern();\n                 ident.span.adjust(Mark::root());\n             }\n-            ModuleOrUniformRoot::UniformRoot(UniformRootKind::CurrentScope) => {\n+            ModuleOrUniformRoot::CurrentScope => {\n                 // No adjustments\n             }\n         }\n@@ -3667,8 +3669,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 err_path_resolution()\n             }\n-            PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n-            PathResult::Failed(..) => return None,\n+            PathResult::Module(..) | PathResult::Failed(..) => return None,\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n@@ -3787,8 +3788,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     }\n                     if name == keywords::Extern.name() ||\n                        name == keywords::CrateRoot.name() && ident.span.rust_2018() {\n-                        module =\n-                            Some(ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude));\n+                        module = Some(ModuleOrUniformRoot::ExternPrelude);\n                         continue;\n                     }\n                     if name == keywords::CrateRoot.name() ||\n@@ -3821,9 +3821,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, None, record_used, path_span)\n             } else if opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.early_resolve_ident_in_lexical_scope(ident, ns, None, opt_ns.is_none(),\n-                                                          parent_scope, record_used, record_used,\n-                                                          path_span)\n+                let scopes = if opt_ns.is_none() { ScopeSet::Import(ns) } else { ScopeSet::Module };\n+                self.early_resolve_ident_in_lexical_scope(ident, scopes, parent_scope, record_used,\n+                                                          record_used, path_span)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n@@ -3912,8 +3912,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         PathResult::Module(match module {\n             Some(module) => module,\n-            None if path.is_empty() =>\n-                ModuleOrUniformRoot::UniformRoot(UniformRootKind::CurrentScope),\n+            None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n             _ => span_bug!(path_span, \"resolve_path: non-empty path `{:?}` has no module\", path),\n         })\n     }"}, {"sha": "5493913fd811d121f280af857d319aabcc1434f7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5e121756ef003f13b9dbb6a44b8bc4dce87b84a8", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, Resolver, ResolutionError, Segment, Weak};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n+use {CrateLint, Resolver, ResolutionError, ScopeSet, Weak};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n use {is_known_tool, resolve_error};\n use ModuleOrUniformRoot;\n-use Namespace::{self, *};\n+use Namespace::*;\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, DefIndex,\n@@ -502,7 +502,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             def\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0].ident, MacroNS, Some(kind), false, parent_scope, false, force, path_span\n+                path[0].ident, ScopeSet::Macro(kind), parent_scope, false, force, path_span\n             );\n             match binding {\n                 Ok(..) => {}\n@@ -527,9 +527,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n         orig_ident: Ident,\n-        ns: Namespace,\n-        macro_kind: Option<MacroKind>,\n-        is_import: bool,\n+        scope_set: ScopeSet,\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         force: bool,\n@@ -605,8 +603,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         assert!(force || !record_used); // `record_used` implies `force`\n-        assert!(macro_kind.is_none() || !is_import); // `is_import` implies no macro kind\n-        let rust_2015 = orig_ident.span.rust_2015();\n         let mut ident = orig_ident.modern();\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n@@ -628,6 +624,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<(&NameBinding, Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n+        let rust_2015 = orig_ident.span.rust_2015();\n+        let (ns, macro_kind, is_import) = match scope_set {\n+            ScopeSet::Import(ns) => (ns, None, true),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Module => (TypeNS, None, false),\n+        };\n         let mut where_to_resolve = match ns {\n             _ if is_import && rust_2015 => WhereToResolve::CrateRoot,\n             TypeNS | ValueNS => WhereToResolve::Module(parent_scope.module),\n@@ -1041,7 +1043,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let macro_resolutions =\n             mem::replace(&mut *module.single_segment_macro_resolutions.borrow_mut(), Vec::new());\n         for (ident, kind, parent_scope, initial_binding) in macro_resolutions {\n-            match self.early_resolve_ident_in_lexical_scope(ident, MacroNS, Some(kind), false,\n+            match self.early_resolve_ident_in_lexical_scope(ident, ScopeSet::Macro(kind),\n                                                             &parent_scope, true, true, ident.span) {\n                 Ok(binding) => {\n                     let initial_def = initial_binding.map(|initial_binding| {\n@@ -1067,7 +1069,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let builtin_attrs = mem::replace(&mut *module.builtin_attrs.borrow_mut(), Vec::new());\n         for (ident, parent_scope) in builtin_attrs {\n             let _ = self.early_resolve_ident_in_lexical_scope(\n-                ident, MacroNS, Some(MacroKind::Attr), false, &parent_scope, true, true, ident.span\n+                ident, ScopeSet::Macro(MacroKind::Attr), &parent_scope, true, true, ident.span\n             );\n         }\n     }"}, {"sha": "47bfadf932e56769e9348aa6afe8f018a4e70dca", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 40, "deletions": 45, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e121756ef003f13b9dbb6a44b8bc4dce87b84a8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5e121756ef003f13b9dbb6a44b8bc4dce87b84a8", "patch": "@@ -11,7 +11,7 @@\n use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, Module, ModuleOrUniformRoot, PerNS, UniformRootKind, Weak};\n+use {CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, Weak};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use {Resolver, Segment};\n@@ -162,45 +162,42 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n-            ModuleOrUniformRoot::UniformRoot(uniform_root_kind) => {\n+            ModuleOrUniformRoot::ExternPrelude => {\n                 assert!(!restricted_shadowing);\n-                match uniform_root_kind {\n-                    UniformRootKind::ExternPrelude => {\n-                        return if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n-                            Ok(binding)\n-                        } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n-                            // Macro-expanded `extern crate` items can add names to extern prelude.\n-                            Err((Undetermined, Weak::No))\n-                        } else {\n-                            Err((Determined, Weak::No))\n-                        }\n-                    }\n-                    UniformRootKind::CurrentScope => {\n-                        let parent_scope =\n-                            parent_scope.expect(\"no parent scope for a single-segment import\");\n-\n-                        if ns == TypeNS {\n-                            if ident.name == keywords::Crate.name() ||\n-                               ident.name == keywords::DollarCrate.name() {\n-                                let module = self.resolve_crate_root(ident);\n-                                let binding = (module, ty::Visibility::Public,\n-                                               module.span, Mark::root())\n-                                               .to_name_binding(self.arenas);\n-                                return Ok(binding);\n-                            } else if ident.name == keywords::Super.name() ||\n-                                      ident.name == keywords::SelfValue.name() {\n-                                // FIXME: Implement these with renaming requirements so that e.g.\n-                                // `use super;` doesn't work, but `use super as name;` does.\n-                                // Fall through here to get an error from `early_resolve_...`.\n-                            }\n-                        }\n-\n-                        let binding = self.early_resolve_ident_in_lexical_scope(\n-                            ident, ns, None, true, parent_scope, record_used, record_used, path_span\n-                        );\n-                        return binding.map_err(|determinacy| (determinacy, Weak::No));\n+                return if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n+                    Ok(binding)\n+                } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                    // Macro-expanded `extern crate` items can add names to extern prelude.\n+                    Err((Undetermined, Weak::No))\n+                } else {\n+                    Err((Determined, Weak::No))\n+                }\n+            }\n+            ModuleOrUniformRoot::CurrentScope => {\n+                assert!(!restricted_shadowing);\n+                let parent_scope =\n+                    parent_scope.expect(\"no parent scope for a single-segment import\");\n+\n+                if ns == TypeNS {\n+                    if ident.name == keywords::Crate.name() ||\n+                        ident.name == keywords::DollarCrate.name() {\n+                        let module = self.resolve_crate_root(ident);\n+                        let binding = (module, ty::Visibility::Public,\n+                                        module.span, Mark::root())\n+                                        .to_name_binding(self.arenas);\n+                        return Ok(binding);\n+                    } else if ident.name == keywords::Super.name() ||\n+                                ident.name == keywords::SelfValue.name() {\n+                        // FIXME: Implement these with renaming requirements so that e.g.\n+                        // `use super;` doesn't work, but `use super as name;` does.\n+                        // Fall through here to get an error from `early_resolve_...`.\n                     }\n                 }\n+\n+                let binding = self.early_resolve_ident_in_lexical_scope(\n+                    ident, ScopeSet::Import(ns), parent_scope, record_used, record_used, path_span\n+                );\n+                return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n         };\n \n@@ -333,7 +330,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             }\n             let module = match glob_import.imported_module.get() {\n                 Some(ModuleOrUniformRoot::Module(module)) => module,\n-                Some(ModuleOrUniformRoot::UniformRoot(_)) => continue,\n+                Some(_) => continue,\n                 None => return Err((Undetermined, Weak::Yes)),\n             };\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n@@ -966,9 +963,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n             return if all_ns_failed {\n                 let resolutions = match module {\n-                    ModuleOrUniformRoot::Module(module) =>\n-                        Some(module.resolutions.borrow()),\n-                    ModuleOrUniformRoot::UniformRoot(_) => None,\n+                    ModuleOrUniformRoot::Module(module) => Some(module.resolutions.borrow()),\n+                    _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n                 let names = resolutions.filter_map(|(&(ref i, _), resolution)| {\n@@ -1006,7 +1002,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                             format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n                         }\n                     }\n-                    ModuleOrUniformRoot::UniformRoot(_) => {\n+                    _ => {\n                         if !ident.is_path_segment_keyword() {\n                             format!(\"no `{}` external crate{}\", ident, lev_suggestion)\n                         } else {\n@@ -1107,9 +1103,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n         let module = match directive.imported_module.get().unwrap() {\n             ModuleOrUniformRoot::Module(module) => module,\n-            ModuleOrUniformRoot::UniformRoot(_) => {\n-                self.session.span_err(directive.span,\n-                    \"cannot glob-import all possible crates\");\n+            _ => {\n+                self.session.span_err(directive.span, \"cannot glob-import all possible crates\");\n                 return;\n             }\n         };"}]}