{"sha": "a5828ff7b0203ac378974c2d30ed94a14073895a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ODI4ZmY3YjAyMDNhYzM3ODk3NGMyZDMwZWQ5NGExNDA3Mzg5NWE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-18T12:36:10Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-18T12:36:10Z"}, "message": "Address huon's comments", "tree": {"sha": "113ad54c0920e9c57782099252a7fec5371ceb00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/113ad54c0920e9c57782099252a7fec5371ceb00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5828ff7b0203ac378974c2d30ed94a14073895a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5828ff7b0203ac378974c2d30ed94a14073895a", "html_url": "https://github.com/rust-lang/rust/commit/a5828ff7b0203ac378974c2d30ed94a14073895a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5828ff7b0203ac378974c2d30ed94a14073895a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13881df1b2a188b1505b50fde47dfdd8c95a99ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/13881df1b2a188b1505b50fde47dfdd8c95a99ee", "html_url": "https://github.com/rust-lang/rust/commit/13881df1b2a188b1505b50fde47dfdd8c95a99ee"}], "stats": {"total": 38, "additions": 21, "deletions": 17}, "files": [{"sha": "5c2757153521c3f024c9412fc8dd677e24f1d471", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a5828ff7b0203ac378974c2d30ed94a14073895a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5828ff7b0203ac378974c2d30ed94a14073895a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a5828ff7b0203ac378974c2d30ed94a14073895a", "patch": "@@ -541,7 +541,7 @@ pub struct Block {\n     /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n-    /// Unsafety of the block\n+    /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n     pub span: Span,\n }\n@@ -553,11 +553,12 @@ pub struct Pat {\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n /// A single field in a struct pattern\n ///\n-/// For patterns like `Foo {x, y, z}`, `pat` and `ident` point to the same identifier\n-/// and `is_shorthand` is true.\n+/// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n+/// are treated the same as` x: x, y: ref y, z: ref mut z`,\n+/// except is_shorthand is true\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FieldPat {\n     /// The identifier for the field\n     pub ident: Ident,\n@@ -601,15 +602,15 @@ pub enum Pat_ {\n     /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n     /// The `bool` is `true` in the presence of a `..`\n     PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n-    /// A tuple pattern (`a, b`)\n+    /// A tuple pattern `(a, b)`\n     PatTup(Vec<P<Pat>>),\n     /// A `box` pattern\n     PatBox(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`\n     PatRegion(P<Pat>, Mutability),\n     /// A literal\n     PatLit(P<Expr>),\n-    /// A range pattern, e.g. `[1...2]`\n+    /// A range pattern, e.g. `1...2`\n     PatRange(P<Expr>, P<Expr>),\n     /// [a, b, ..i, y, z] is represented as:\n     ///     PatVec(box [a, b], Some(i), box [y, z])\n@@ -817,28 +818,28 @@ pub enum Expr_ {\n     ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while loop, with an optional label\n-    /// `'label while expr { block }`\n+    /// `'label: while expr { block }`\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while-let loop, with an optional label\n-    /// `'label while let pat = expr { block }`\n+    /// `'label: while let pat = expr { block }`\n     /// This is desugared to a combination of `loop` and `match` expressions\n     ExprWhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A for loop, with an optional label\n-    /// `'label for pat in expr { block }`\n+    /// `'label: for pat in expr { block }`\n     /// This is desugared to a combination of `loop` and `match` expressions\n     ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n-    /// Conditionless loop (can be exited with break, cont, or ret)\n-    /// `'label loop { block }`\n+    /// Conditionless loop (can be exited with break, continue, or return)\n+    /// `'label: loop { block }`\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)\n     ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n-    /// A block\n+    /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n     /// An assignment (`a = foo()`)\n@@ -853,7 +854,7 @@ pub enum Expr_ {\n     ExprTupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n-    /// A range (`[1..2]`, `[1..]`, or `[..2]`)\n+    /// A range (`1..2`, `1..`, or `..2`)\n     ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or type\n@@ -877,12 +878,14 @@ pub enum Expr_ {\n     ExprMac(Mac),\n \n     /// A struct literal expression.\n-    /// For example, `Foo {x: 1, y: 2}`\n-    ExprStruct(Path, Vec<Field>, Option<P<Expr>> /* base */),\n+    /// For example, `Foo {x: 1, y: 2}`, or\n+    /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`\n+    ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n \n     /// A vector literal constructed from one repeated element.\n-    /// For example, `[u8; 5]`\n-    ExprRepeat(P<Expr> /* element */, P<Expr> /* count */),\n+    /// For example, `[1u8; 5]`. The first expression is the element\n+    /// to be repeated; the second is the number of times to repeat it\n+    ExprRepeat(P<Expr>, P<Expr>),\n \n     /// No-op: used solely so we can pretty-print faithfully\n     ExprParen(P<Expr>)\n@@ -1820,6 +1823,7 @@ pub enum ForeignItem_ {\n     /// A foreign function\n     ForeignItemFn(P<FnDecl>, Generics),\n     /// A foreign static item (`static ext: u8`), with optional mutability\n+    /// (the boolean is true when mutable)\n     ForeignItemStatic(P<Ty>, bool),\n }\n "}]}