{"sha": "56274be4b541599b0a1a02c710cc293659715345", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2Mjc0YmU0YjU0MTU5OWIwYTFhMDJjNzEwY2MyOTM2NTk3MTUzNDU=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-06-11T22:07:54Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-07-01T14:30:43Z"}, "message": "Added bfs for constraint paths from regions.", "tree": {"sha": "43154b41acb7f14ca08da4c0c5270d6cdf55f38e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43154b41acb7f14ca08da4c0c5270d6cdf55f38e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56274be4b541599b0a1a02c710cc293659715345", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAls45ZMACgkQAXYLT59T\n8VRTNw/9GU1W8DCQdwndRUuD6HVrfvEFecfzPlplc72JWjIcaeXx/buEdVbLscWN\nW9sgVTqAh00UErzJ6RSL77zuI+/6GtjA1tlAlAQGDzTiG6gpxOVboCWcF+KoTdSv\nvEIlOz/LgLwAHF2uQbV5/++Lr+Dj//8MpdA7rmnLw/iwShrzQ/3a+mfYbA4oT6o6\nhnD8bj260jV6pPUGivX3m0zn7IiRAvMIxqfHEIBe8lxVmQjKeXcsLWFeQ9GJNCpH\n05hmCJNILO+FncAATLXfYxB3NDl2e2JJ6OBMk855d9uhDkX9Jv+PHmQqmewTvGnU\nq5l0No6UY0i50DwbXPckc/FF4vYZQ2kzgi370t4FXs8eXne+MKoA/w4TFhwDfSBY\nKV0h4vUA+t4LnNChRzGUlEu7S/MI2Txzk4DeME4Hq0Es/up/c0eY67XeOj8GMX0P\nH8kj35PRInGSXobo9Vu9jE6O/6Nh+jVmSv8iCrUuuFMGjiiOhERburV8YezXZbnf\nXg6+BiP0udQctBIRO/SS6QwJErtyKciEo993eOw6OWZmfpPuQqYajHN53dQC+v8o\nD1RLbXeVQLDcOtxauN4qVebpRUG6WoXWw9l53QqX8dbylvVZPa09NsCSPlXgDDEW\nmK3XWff/qrUUW8L8TJBd6HWThRyhPuQrq0X5RnyYUoMd9xsapPE=\n=kR4H\n-----END PGP SIGNATURE-----", "payload": "tree 43154b41acb7f14ca08da4c0c5270d6cdf55f38e\nparent 9e2157fdcac358646d2ff2ca888d2a63df565239\nauthor David Wood <david@davidtw.co> 1528754874 +0100\ncommitter David Wood <david@davidtw.co> 1530455443 +0100\n\nAdded bfs for constraint paths from regions.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56274be4b541599b0a1a02c710cc293659715345", "html_url": "https://github.com/rust-lang/rust/commit/56274be4b541599b0a1a02c710cc293659715345", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56274be4b541599b0a1a02c710cc293659715345/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e2157fdcac358646d2ff2ca888d2a63df565239", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e2157fdcac358646d2ff2ca888d2a63df565239", "html_url": "https://github.com/rust-lang/rust/commit/9e2157fdcac358646d2ff2ca888d2a63df565239"}], "stats": {"total": 110, "additions": 109, "deletions": 1}, "files": [{"sha": "1fa530f5492ab688fd3b171e0d3282651ef5ff8a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 109, "deletions": 1, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/56274be4b541599b0a1a02c710cc293659715345/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56274be4b541599b0a1a02c710cc293659715345/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=56274be4b541599b0a1a02c710cc293659715345", "patch": "@@ -26,6 +26,7 @@ use rustc::mir::{\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::rc::Rc;\n use syntax_pos::Span;\n@@ -504,7 +505,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n-                if self.try_promote_type_test(infcx, mir, type_test, propagated_outlives_requirements) {\n+                if self.try_promote_type_test(infcx, mir, type_test,\n+                                              propagated_outlives_requirements) {\n                     continue;\n                 }\n             }\n@@ -963,6 +965,104 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    fn find_constraint_paths_from_region(\n+        &self,\n+        r0: RegionVid\n+    ) -> Vec<Vec<ConstraintIndex>> {\n+        let constraints = self.constraints.clone();\n+\n+        // Mapping of regions to the previous region and constraint index that led to it.\n+        let mut previous = FxHashMap();\n+        // Current region in traversal.\n+        let mut current = r0;\n+        // Regions yet to be visited.\n+        let mut next = vec! [ current ];\n+        // Regions that have been visited.\n+        let mut visited = FxHashSet();\n+        // Ends of paths.\n+        let mut end_regions: Vec<RegionVid> = Vec::new();\n+\n+        // When we've still got points to visit...\n+        while !next.is_empty() {\n+            // ...take the next point...\n+            debug!(\"find_constraint_paths_from_region: next={:?}\", next);\n+            current = next.pop().unwrap(); // Can unwrap here as we know the vector is not empty.\n+\n+            // ...find the edges containing it...\n+            let mut upcoming = Vec::new();\n+            for (index, constraint) in constraints.iter_enumerated() {\n+                if constraint.sub == current {\n+                    // ...add the regions that join us with to the path we've taken...\n+                    debug!(\"find_constraint_paths_from_region: index={:?} constraint={:?}\",\n+                           index, constraint);\n+                    let next_region = constraint.sup.clone();\n+\n+                    // ...unless we've visited it since this was added...\n+                    if visited.contains(&next_region) {\n+                        debug!(\"find_constraint_paths_from_region: skipping as visited\");\n+                        continue;\n+                    }\n+\n+                    previous.insert(next_region, (index, Some(current)));\n+                    upcoming.push(next_region);\n+                }\n+            }\n+\n+            if upcoming.is_empty() {\n+                // If we didn't find any edges then this is the end of a path...\n+                debug!(\"find_constraint_paths_from_region: new end region current={:?}\", current);\n+                end_regions.push(current);\n+            } else {\n+                // ...but, if we did find edges, then add these to the regions yet to visit...\n+                debug!(\"find_constraint_paths_from_region: extend next upcoming={:?}\", upcoming);\n+                next.extend(upcoming);\n+            }\n+\n+            // ...and don't visit it again.\n+            visited.insert(current.clone());\n+            debug!(\"find_constraint_paths_from_region: next={:?} visited={:?}\", next, visited);\n+        }\n+\n+        // Now we've visited each point, compute the final paths.\n+        let mut paths: Vec<Vec<ConstraintIndex>> = Vec::new();\n+        debug!(\"find_constraint_paths_from_region: end_regions={:?}\", end_regions);\n+        for end_region in end_regions {\n+            debug!(\"find_constraint_paths_from_region: end_region={:?}\", end_region);\n+\n+            // Get the constraint and region that led to this end point.\n+            // We can unwrap as we know if end_point was in the vector that it\n+            // must also be in our previous map.\n+            let (mut index, mut region) = previous.get(&end_region).unwrap();\n+            debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n+\n+            // Keep track of the indices.\n+            let mut path: Vec<ConstraintIndex> = vec![index];\n+\n+            while region.is_some() && region != Some(r0) {\n+                let p = previous.get(&region.unwrap()).unwrap();\n+                index = p.0;\n+                region = p.1;\n+\n+                debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n+                path.push(index);\n+            }\n+\n+            // Add to our paths.\n+            paths.push(path);\n+        }\n+\n+        debug!(\"find_constraint_paths_from_region: paths={:?}\", paths);\n+        paths\n+    }\n+\n+    fn constraint_is_interesting(&self, index: &ConstraintIndex) -> bool {\n+        self.constraints.get(*index).filter(|constraint| {\n+            debug!(\"constraint_is_interesting: locations={:?} constraint={:?}\",\n+                   constraint.locations, constraint);\n+            if let Locations::Interesting(_) = constraint.locations { true } else { false }\n+        }).is_some()\n+    }\n+\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -992,6 +1092,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n+        let constraints = self.find_constraint_paths_from_region(fr.clone());\n+        let path = constraints.iter().min_by_key(|p| p.len()).unwrap();\n+        debug!(\"report_error: path={:?}\", path);\n+        let path = path.iter()\n+            .filter(|index| self.constraint_is_interesting(index))\n+            .collect::<Vec<&ConstraintIndex>>();\n+        debug!(\"report_error: path={:?}\", path);\n+\n         let fr_string = match fr_name {\n             Some(r) => format!(\"free region `{}`\", r),\n             None => format!(\"free region `{:?}`\", fr),"}]}