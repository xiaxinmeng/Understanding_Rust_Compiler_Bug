{"sha": "db71987ee1198be60fef3e361ad1ce59a70cd7f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNzE5ODdlZTExOThiZTYwZmVmM2UzNjFhZDFjZTU5YTcwY2Q3Zjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-13T20:26:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-13T20:26:57Z"}, "message": "Auto merge of #33642 - xen0n:ergonomic-format-macro, r=alexcrichton\n\nErgonomic format_args!\n\nFixes #9456 (at last).\n\nNot a ground-up rewrite of the existing machinery, but more like an added intermediary layer between macro arguments and format placeholders. This is now implementing Rust RFC 1618!", "tree": {"sha": "6decc21f8f66747b91a95c21c6816fb2d9b4bac0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6decc21f8f66747b91a95c21c6816fb2d9b4bac0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db71987ee1198be60fef3e361ad1ce59a70cd7f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db71987ee1198be60fef3e361ad1ce59a70cd7f7", "html_url": "https://github.com/rust-lang/rust/commit/db71987ee1198be60fef3e361ad1ce59a70cd7f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db71987ee1198be60fef3e361ad1ce59a70cd7f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b7fb80e1c05bee176ea68d21e19a352a106c968", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7fb80e1c05bee176ea68d21e19a352a106c968", "html_url": "https://github.com/rust-lang/rust/commit/0b7fb80e1c05bee176ea68d21e19a352a106c968"}, {"sha": "51e54e57a45d7b956e3e3390db76ea2651f5d3b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/51e54e57a45d7b956e3e3390db76ea2651f5d3b3", "html_url": "https://github.com/rust-lang/rust/commit/51e54e57a45d7b956e3e3390db76ea2651f5d3b3"}], "stats": {"total": 520, "additions": 321, "deletions": 199}, "files": [{"sha": "e7d401f0929fe1910ec87bc256cbe1d3715d49e1", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=db71987ee1198be60fef3e361ad1ce59a70cd7f7", "patch": "@@ -80,8 +80,6 @@ pub struct FormatSpec<'a> {\n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, PartialEq)]\n pub enum Position<'a> {\n-    /// The argument will be in the next position. This is the default.\n-    ArgumentNext,\n     /// The argument is located at a specific index.\n     ArgumentIs(usize),\n     /// The argument has a name.\n@@ -127,8 +125,6 @@ pub enum Count<'a> {\n     CountIsName(&'a str),\n     /// The count is specified by the argument at the given index.\n     CountIsParam(usize),\n-    /// The count is specified by the next parameter.\n-    CountIsNextParam,\n     /// The count is implied and cannot be explicitly specified.\n     CountImplied,\n }\n@@ -144,6 +140,8 @@ pub struct Parser<'a> {\n     cur: iter::Peekable<str::CharIndices<'a>>,\n     /// Error messages accumulated during parsing\n     pub errors: Vec<string::String>,\n+    /// Current position of implicit positional argument pointer\n+    curarg: usize,\n }\n \n impl<'a> Iterator for Parser<'a> {\n@@ -186,6 +184,7 @@ impl<'a> Parser<'a> {\n             input: s,\n             cur: s.char_indices().peekable(),\n             errors: vec![],\n+            curarg: 0,\n         }\n     }\n \n@@ -259,21 +258,40 @@ impl<'a> Parser<'a> {\n     /// Parses an Argument structure, or what's contained within braces inside\n     /// the format string\n     fn argument(&mut self) -> Argument<'a> {\n+        let pos = self.position();\n+        let format = self.format();\n+\n+        // Resolve position after parsing format spec.\n+        let pos = match pos {\n+            Some(position) => position,\n+            None => {\n+                let i = self.curarg;\n+                self.curarg += 1;\n+                ArgumentIs(i)\n+            }\n+        };\n+\n         Argument {\n-            position: self.position(),\n-            format: self.format(),\n+            position: pos,\n+            format: format,\n         }\n     }\n \n     /// Parses a positional argument for a format. This could either be an\n     /// integer index of an argument, a named argument, or a blank string.\n-    fn position(&mut self) -> Position<'a> {\n+    /// Returns `Some(parsed_position)` if the position is not implicitly\n+    /// consuming a macro argument, `None` if it's the case.\n+    fn position(&mut self) -> Option<Position<'a>> {\n         if let Some(i) = self.integer() {\n-            ArgumentIs(i)\n+            Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => ArgumentNamed(self.word()),\n-                _ => ArgumentNext,\n+                Some(&(_, c)) if c.is_alphabetic() => Some(ArgumentNamed(self.word())),\n+\n+                // This is an `ArgumentNext`.\n+                // Record the fact and do the resolution after parsing the\n+                // format spec, to make things like `{:.*}` work.\n+                _ => None,\n             }\n         }\n     }\n@@ -340,7 +358,11 @@ impl<'a> Parser<'a> {\n         }\n         if self.consume('.') {\n             if self.consume('*') {\n-                spec.precision = CountIsNextParam;\n+                // Resolve `CountIsNextParam`.\n+                // We can do this immediately as `position` is resolved later.\n+                let i = self.curarg;\n+                self.curarg += 1;\n+                spec.precision = CountIsParam(i);\n             } else {\n                 spec.precision = self.count();\n             }\n@@ -487,7 +509,7 @@ mod tests {\n     fn format_nothing() {\n         same(\"{}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: fmtdflt(),\n                })]);\n     }\n@@ -565,7 +587,7 @@ mod tests {\n     fn format_counts() {\n         same(\"{:10s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -577,7 +599,7 @@ mod tests {\n                })]);\n         same(\"{:10$.10s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -589,19 +611,19 @@ mod tests {\n                })]);\n         same(\"{:.*s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(1),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n                        flags: 0,\n-                       precision: CountIsNextParam,\n+                       precision: CountIsParam(0),\n                        width: CountImplied,\n                        ty: \"s\",\n                    },\n                })]);\n         same(\"{:.10$s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -613,7 +635,7 @@ mod tests {\n                })]);\n         same(\"{:a$.b$s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -628,7 +650,7 @@ mod tests {\n     fn format_flags() {\n         same(\"{:-}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -640,7 +662,7 @@ mod tests {\n                })]);\n         same(\"{:+#}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,"}, {"sha": "fc1d2236f3feaa07c63c5e99e424500bc5704b53", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=db71987ee1198be60fef3e361ad1ce59a70cd7f7", "patch": "@@ -881,7 +881,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n-                        Position::ArgumentIs(_) | Position::ArgumentNext => {\n+                        Position::ArgumentIs(_) => {\n                             span_err!(ccx.tcx.sess, attr.span, E0231,\n                                                   \"only named substitution \\\n                                                    parameters are allowed\");"}, {"sha": "94bb78edaacdb617110784fc50dad9c8c8c0ac6b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 245, "deletions": 175, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=db71987ee1198be60fef3e361ad1ce59a70cd7f7", "patch": "@@ -24,11 +24,12 @@ use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n use std::collections::HashMap;\n+use std::collections::hash_map::Entry;\n \n #[derive(PartialEq)]\n enum ArgumentType {\n-    Known(String),\n-    Unsigned\n+    Placeholder(String),\n+    Count,\n }\n \n enum Position {\n@@ -44,17 +45,25 @@ struct Context<'a, 'b:'a> {\n     /// The span of the format string literal.\n     fmtsp: Span,\n \n-    /// Parsed argument expressions and the types that we've found so far for\n-    /// them.\n+    /// List of parsed argument expressions.\n+    /// Named expressions are resolved early, and are appended to the end of\n+    /// argument expressions.\n+    ///\n+    /// Example showing the various data structures in motion:\n+    ///\n+    /// * Original: `\"{foo:o} {:o} {foo:x} {0:x} {1:o} {:x} {1:x} {0:o}\"`\n+    /// * Implicit argument resolution: `\"{foo:o} {0:o} {foo:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n+    /// * Name resolution: `\"{2:o} {0:o} {2:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n+    /// * `arg_types` (in JSON): `[[0, 1, 0], [0, 1, 1], [0, 1]]`\n+    /// * `arg_unique_types` (in simplified JSON): `[[\"o\", \"x\"], [\"o\", \"x\"], [\"o\", \"x\"]]`\n+    /// * `names` (in JSON): `{\"foo\": 2}`\n     args: Vec<P<ast::Expr>>,\n-    arg_types: Vec<Option<ArgumentType>>,\n-    /// Parsed named expressions and the types that we've found for them so far.\n-    /// Note that we keep a side-array of the ordering of the named arguments\n-    /// found to be sure that we can translate them in the same order that they\n-    /// were declared in.\n-    names: HashMap<String, P<ast::Expr>>,\n-    name_types: HashMap<String, ArgumentType>,\n-    name_ordering: Vec<String>,\n+    /// Placeholder slot numbers indexed by argument.\n+    arg_types: Vec<Vec<usize>>,\n+    /// Unique format specs seen for each argument.\n+    arg_unique_types: Vec<Vec<ArgumentType>>,\n+    /// Map from named arguments to their resolved indices.\n+    names: HashMap<String, usize>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -66,10 +75,41 @@ struct Context<'a, 'b:'a> {\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n-    name_positions: HashMap<String, usize>,\n+    /// Mapping between positional argument references and indices into the\n+    /// final generated static argument array. We record the starting indices\n+    /// corresponding to each positional argument, and number of references\n+    /// consumed so far for each argument, to facilitate correct `Position`\n+    /// mapping in `trans_piece`. In effect this can be seen as a \"flattened\"\n+    /// version of `arg_unique_types`.\n+    ///\n+    /// Again with the example described above in docstring for `args`:\n+    ///\n+    /// * `arg_index_map` (in JSON): `[[0, 1, 0], [2, 3, 3], [4, 5]]`\n+    arg_index_map: Vec<Vec<usize>>,\n+\n+    /// Starting offset of count argument slots.\n+    count_args_index_offset: usize,\n \n-    /// Updated as arguments are consumed\n-    next_arg: usize,\n+    /// Count argument slots and tracking data structures.\n+    /// Count arguments are separately tracked for de-duplication in case\n+    /// multiple references are made to one argument. For example, in this\n+    /// format string:\n+    ///\n+    /// * Original: `\"{:.*} {:.foo$} {1:.*} {:.0$}\"`\n+    /// * Implicit argument resolution: `\"{1:.0$} {2:.foo$} {1:.3$} {4:.0$}\"`\n+    /// * Name resolution: `\"{1:.0$} {2:.5$} {1:.3$} {4:.0$}\"`\n+    /// * `count_positions` (in JSON): `{0: 0, 5: 1, 3: 2}`\n+    /// * `count_args`: `vec![Exact(0), Exact(5), Exact(3)]`\n+    count_args: Vec<Position>,\n+    /// Relative slot numbers for count arguments.\n+    count_positions: HashMap<usize, usize>,\n+    /// Number of count slots assigned.\n+    count_positions_count: usize,\n+\n+    /// Current position of the implicit positional arg pointer, as if it\n+    /// still existed in this phase of processing.\n+    /// Used only for `all_pieces_simple` tracking in `trans_piece`.\n+    curarg: usize,\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -78,15 +118,12 @@ struct Context<'a, 'b:'a> {\n ///\n /// If parsing succeeds, the return value is:\n /// ```ignore\n-/// Some((fmtstr, unnamed arguments, ordering of named arguments,\n-///       named arguments))\n+/// Some((fmtstr, parsed arguments, index map for named arguments))\n /// ```\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-              -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n-                         HashMap<String, P<ast::Expr>>)> {\n-    let mut args = Vec::new();\n-    let mut names = HashMap::<String, P<ast::Expr>>::new();\n-    let mut order = Vec::new();\n+              -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, HashMap<String, usize>)> {\n+    let mut args = Vec::<P<ast::Expr>>::new();\n+    let mut names = HashMap::<String, usize>::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -130,23 +167,50 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                 ecx.struct_span_err(e.span,\n                                     &format!(\"duplicate argument named `{}`\",\n                                              name))\n-                    .span_note(prev.span, \"previously here\")\n+                    .span_note(args[*prev].span, \"previously here\")\n                     .emit();\n                 continue;\n             }\n-            order.push(name.to_string());\n-            names.insert(name.to_string(), e);\n+\n+            // Resolve names into slots early.\n+            // Since all the positional args are already seen at this point\n+            // if the input is valid, we can simply append to the positional\n+            // args. And remember the names.\n+            let slot = args.len();\n+            names.insert(name.to_string(), slot);\n+            args.push(e);\n         } else {\n             args.push(panictry!(p.parse_expr()));\n         }\n     }\n-    Some((fmtstr, args, order, names))\n+    Some((fmtstr, args, names))\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n-    /// Verifies one piece of a parse string. All errors are not emitted as\n-    /// fatal so we can continue giving errors about this and possibly other\n-    /// format strings.\n+    fn resolve_name_inplace(&self, p: &mut parse::Piece) {\n+        // NOTE: the `unwrap_or` branch is needed in case of invalid format\n+        // arguments, e.g. `format_args!(\"{foo}\")`.\n+        let lookup = |s| *self.names.get(s).unwrap_or(&0);\n+\n+        match *p {\n+            parse::String(_) => {}\n+            parse::NextArgument(ref mut arg) => {\n+                if let parse::ArgumentNamed(s) = arg.position {\n+                    arg.position = parse::ArgumentIs(lookup(s));\n+                }\n+                if let parse::CountIsName(s) = arg.format.width {\n+                    arg.format.width = parse::CountIsParam(lookup(s));\n+                }\n+                if let parse::CountIsName(s) = arg.format.precision {\n+                    arg.format.precision = parse::CountIsParam(lookup(s));\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Verifies one piece of a parse string, and remembers it if valid.\n+    /// All errors are not emitted as fatal so we can continue giving errors\n+    /// about this and possibly other format strings.\n     fn verify_piece(&mut self, p: &parse::Piece) {\n         match *p {\n             parse::String(..) => {}\n@@ -159,16 +223,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // argument second, if it's an implicit positional parameter\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n-                    parse::ArgumentNext => {\n-                        let i = self.next_arg;\n-                        self.next_arg += 1;\n-                        Exact(i)\n-                    }\n                     parse::ArgumentIs(i) => Exact(i),\n                     parse::ArgumentNamed(s) => Named(s.to_string()),\n                 };\n \n-                let ty = Known(arg.format.ty.to_string());\n+                let ty = Placeholder(arg.format.ty.to_string());\n                 self.verify_arg_type(pos, ty);\n             }\n         }\n@@ -178,15 +237,10 @@ impl<'a, 'b> Context<'a, 'b> {\n         match c {\n             parse::CountImplied | parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n-                self.verify_arg_type(Exact(i), Unsigned);\n+                self.verify_arg_type(Exact(i), Count);\n             }\n             parse::CountIsName(s) => {\n-                self.verify_arg_type(Named(s.to_string()), Unsigned);\n-            }\n-            parse::CountIsNextParam => {\n-                let next_arg = self.next_arg;\n-                self.verify_arg_type(Exact(next_arg), Unsigned);\n-                self.next_arg += 1;\n+                self.verify_arg_type(Named(s.to_string()), Count);\n             }\n         }\n     }\n@@ -199,6 +253,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n+    /// Actually verifies and tracks a given format placeholder\n+    /// (a.k.a. argument).\n     fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n         match arg {\n             Exact(arg) => {\n@@ -209,84 +265,70 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.ecx.span_err(self.fmtsp, &msg[..]);\n                     return;\n                 }\n-                {\n-                    let arg_type = match self.arg_types[arg] {\n-                        None => None,\n-                        Some(ref x) => Some(x)\n-                    };\n-                    self.verify_same(self.args[arg].span, &ty, arg_type);\n-                }\n-                if self.arg_types[arg].is_none() {\n-                    self.arg_types[arg] = Some(ty);\n+                match ty {\n+                    Placeholder(_) => {\n+                        // record every (position, type) combination only once\n+                        let ref mut seen_ty = self.arg_unique_types[arg];\n+                        let i = match seen_ty.iter().position(|x| *x == ty) {\n+                            Some(i) => i,\n+                            None => {\n+                                let i = seen_ty.len();\n+                                seen_ty.push(ty);\n+                                i\n+                            }\n+                        };\n+                        self.arg_types[arg].push(i);\n+                    }\n+                    Count => {\n+                        match self.count_positions.entry(arg) {\n+                            Entry::Vacant(e) => {\n+                                let i = self.count_positions_count;\n+                                e.insert(i);\n+                                self.count_args.push(Exact(arg));\n+                                self.count_positions_count += 1;\n+                            }\n+                            Entry::Occupied(_) => {}\n+                        }\n+                    }\n                 }\n             }\n \n             Named(name) => {\n-                let span = match self.names.get(&name) {\n-                    Some(e) => e.span,\n+                let idx = match self.names.get(&name) {\n+                    Some(e) => *e,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n                         self.ecx.span_err(self.fmtsp, &msg[..]);\n                         return;\n                     }\n                 };\n-                self.verify_same(span, &ty, self.name_types.get(&name));\n-                if !self.name_types.contains_key(&name) {\n-                    self.name_types.insert(name.clone(), ty);\n-                }\n-                // Assign this named argument a slot in the arguments array if\n-                // it hasn't already been assigned a slot.\n-                if !self.name_positions.contains_key(&name) {\n-                    let slot = self.name_positions.len();\n-                    self.name_positions.insert(name, slot);\n-                }\n+                // Treat as positional arg.\n+                self.verify_arg_type(Exact(idx), ty)\n             }\n         }\n     }\n \n-    /// When we're keeping track of the types that are declared for certain\n-    /// arguments, we assume that `None` means we haven't seen this argument\n-    /// yet, `Some(None)` means that we've seen the argument, but no format was\n-    /// specified, and `Some(Some(x))` means that the argument was declared to\n-    /// have type `x`.\n-    ///\n-    /// Obviously `Some(Some(x)) != Some(Some(y))`, but we consider it true\n-    /// that: `Some(None) == Some(Some(x))`\n-    fn verify_same(&self,\n-                   sp: Span,\n-                   ty: &ArgumentType,\n-                   before: Option<&ArgumentType>) {\n-        let cur = match before {\n-            None => return,\n-            Some(t) => t,\n-        };\n-        if *ty == *cur {\n-            return\n-        }\n-        match (cur, ty) {\n-            (&Known(ref cur), &Known(ref ty)) => {\n-                self.ecx.span_err(sp,\n-                                  &format!(\"argument redeclared with type `{}` when \\\n-                                           it was previously `{}`\",\n-                                          *ty,\n-                                          *cur));\n-            }\n-            (&Known(ref cur), _) => {\n-                self.ecx.span_err(sp,\n-                                  &format!(\"argument used to format with `{}` was \\\n-                                           attempted to not be used for formatting\",\n-                                           *cur));\n-            }\n-            (_, &Known(ref ty)) => {\n-                self.ecx.span_err(sp,\n-                                  &format!(\"argument previously used as a format \\\n-                                           argument attempted to be used as `{}`\",\n-                                           *ty));\n-            }\n-            (_, _) => {\n-                self.ecx.span_err(sp, \"argument declared with multiple formats\");\n+    /// Builds the mapping between format placeholders and argument objects.\n+    fn build_index_map(&mut self) {\n+        // NOTE: Keep the ordering the same as `into_expr`'s expansion would do!\n+        let args_len = self.args.len();\n+        self.arg_index_map.reserve(args_len);\n+\n+        let mut sofar = 0usize;\n+\n+        // Map the arguments\n+        for i in 0..args_len {\n+            let ref arg_types = self.arg_types[i];\n+            let mut arg_offsets = Vec::with_capacity(arg_types.len());\n+            for offset in arg_types {\n+                arg_offsets.push(sofar + *offset);\n             }\n+            self.arg_index_map.push(arg_offsets);\n+            sofar += self.arg_unique_types[i].len();\n         }\n+\n+        // Record starting index for counts, which appear just after arguments\n+        self.count_args_index_offset = sofar;\n     }\n \n     fn rtpath(ecx: &ExtCtxt, s: &str) -> Vec<ast::Ident> {\n@@ -306,18 +348,18 @@ impl<'a, 'b> Context<'a, 'b> {\n         match c {\n             parse::CountIs(i) => count(\"Is\", Some(self.ecx.expr_usize(sp, i))),\n             parse::CountIsParam(i) => {\n-                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n-            }\n-            parse::CountImplied => count(\"Implied\", None),\n-            parse::CountIsNextParam => count(\"NextParam\", None),\n-            parse::CountIsName(n) => {\n-                let i = match self.name_positions.get(n) {\n+                // This needs mapping too, as `i` is referring to a macro\n+                // argument.\n+                let i = match self.count_positions.get(&i) {\n                     Some(&i) => i,\n                     None => 0, // error already emitted elsewhere\n                 };\n-                let i = i + self.args.len();\n+                let i = i + self.count_args_index_offset;\n                 count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n+            parse::CountImplied => count(\"Implied\", None),\n+            // should never be the case, names are already resolved\n+            parse::CountIsName(_) => panic!(\"should never happen\"),\n         }\n     }\n \n@@ -331,7 +373,10 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Translate a `parse::Piece` to a static `rt::Argument` or append\n     /// to the `literal` string.\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> Option<P<ast::Expr>> {\n+    fn trans_piece(&mut self,\n+                   piece: &parse::Piece,\n+                   arg_index_consumed: &mut Vec<usize>)\n+                   -> Option<P<ast::Expr>> {\n         let sp = self.macsp;\n         match *piece {\n             parse::String(s) => {\n@@ -355,25 +400,34 @@ impl<'a, 'b> Context<'a, 'b> {\n                         }\n                     };\n                     match arg.position {\n-                        // These two have a direct mapping\n-                        parse::ArgumentNext => pos(\"Next\", None),\n-                        parse::ArgumentIs(i) => pos(\"At\", Some(i)),\n-\n-                        // Named arguments are converted to positional arguments\n-                        // at the end of the list of arguments\n-                        parse::ArgumentNamed(n) => {\n-                            let i = match self.name_positions.get(n) {\n-                                Some(&i) => i,\n+                        parse::ArgumentIs(i) => {\n+                            // Map to index in final generated argument array\n+                            // in case of multiple types specified\n+                            let arg_idx = match arg_index_consumed.get_mut(i) {\n                                 None => 0, // error already emitted elsewhere\n+                                Some(offset) => {\n+                                    let arg_idx = self.arg_index_map[i][*offset];\n+                                    *offset += 1;\n+                                    arg_idx\n+                                }\n                             };\n-                            let i = i + self.args.len();\n-                            pos(\"At\", Some(i))\n+                            pos(\"At\", Some(arg_idx))\n                         }\n+\n+                        // should never be the case, because names are already\n+                        // resolved.\n+                        parse::ArgumentNamed(_) => panic!(\"should never happen\"),\n                     }\n                 };\n \n                 let simple_arg = parse::Argument {\n-                    position: parse::ArgumentNext,\n+                    position: {\n+                        // We don't have ArgumentNext any more, so we have to\n+                        // track the current argument ourselves.\n+                        let i = self.curarg;\n+                        self.curarg += 1;\n+                        parse::ArgumentIs(i)\n+                    },\n                     format: parse::FormatSpec {\n                         fill: arg.format.fill,\n                         align: parse::AlignUnknown,\n@@ -449,11 +503,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.expr_block(ecx.block(sp, vec![stmt, ecx.stmt_expr(ecx.expr_ident(sp, name))]))\n     }\n \n-    /// Actually builds the expression which the iformat! block will be expanded\n-    /// to\n+    /// Actually builds the expression which the format_args! block will be\n+    /// expanded to\n     fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n-        let mut names = vec![None; self.name_positions.len()];\n+        let mut counts = Vec::new();\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n@@ -470,6 +524,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                                            piece_ty,\n                                            self.str_pieces);\n \n+        // Before consuming the expressions, we have to remember spans for\n+        // count arguments as they are now generated separate from other\n+        // arguments, hence have no access to the `P<ast::Expr>`'s.\n+        let spans_pos: Vec<_> = self.args.iter().map(|e| e.span.clone()).collect();\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -479,38 +537,29 @@ impl<'a, 'b> Context<'a, 'b> {\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n-            let arg_ty = match self.arg_types[i].as_ref() {\n-                Some(ty) => ty,\n-                None => continue // error already generated\n-            };\n-\n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(DUMMY_SP, name));\n-            locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n-                                            self.ecx.expr_ident(e.span, name)));\n+            for ref arg_ty in self.arg_unique_types[i].iter() {\n+                locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n+                                                self.ecx.expr_ident(e.span, name)));\n+            }\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n-        for name in &self.name_ordering {\n-            let e = match self.names.remove(name) {\n-                Some(e) => e,\n-                None => continue\n+        for pos in self.count_args {\n+            let name = self.ecx.ident_of(&match pos {\n+                Exact(i) => format!(\"__arg{}\", i),\n+                _ => panic!(\"should never happen\"),\n+            });\n+            let span = match pos {\n+                Exact(i) => spans_pos[i],\n+                _ => panic!(\"should never happen\"),\n             };\n-            let arg_ty = match self.name_types.get(name) {\n-                Some(ty) => ty,\n-                None => continue\n-            };\n-\n-            let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n-                                                  *name));\n-            pats.push(self.ecx.pat_ident(DUMMY_SP, lname));\n-            names[*self.name_positions.get(name).unwrap()] =\n-                Some(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n-                                         self.ecx.expr_ident(e.span, lname)));\n-            heads.push(self.ecx.expr_addr_of(e.span, e));\n+            counts.push(Context::format_arg(self.ecx, self.macsp, span, &Count,\n+                                            self.ecx.expr_ident(span, name)));\n         }\n \n         // Now create a vector containing all the arguments\n-        let args = locals.into_iter().chain(names.into_iter().map(|a| a.unwrap()));\n+        let args = locals.into_iter().chain(counts.into_iter());\n \n         let args_array = self.ecx.expr_vec(self.fmtsp, args.collect());\n \n@@ -573,7 +622,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   ty: &ArgumentType, arg: P<ast::Expr>)\n                   -> P<ast::Expr> {\n         let trait_ = match *ty {\n-            Known(ref tyname) => {\n+            Placeholder(ref tyname) => {\n                 match &tyname[..] {\n                     \"\"  => \"Display\",\n                     \"?\" => \"Debug\",\n@@ -592,7 +641,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     }\n                 }\n             }\n-            Unsigned => {\n+            Count => {\n                 let path = ecx.std_path(&[\"fmt\", \"ArgumentV1\", \"from_usize\"]);\n                 return ecx.expr_call_global(macsp, path, vec![arg])\n             }\n@@ -610,9 +659,9 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n                                -> Box<base::MacResult+'cx> {\n \n     match parse_args(ecx, sp, tts) {\n-        Some((efmt, args, order, names)) => {\n+        Some((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt,\n-                                                      args, order, names))\n+                                                      args, names))\n         }\n         None => DummyResult::expr(sp)\n     }\n@@ -623,10 +672,12 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    name_ordering: Vec<String>,\n-                                    names: HashMap<String, P<ast::Expr>>)\n+                                    names: HashMap<String, usize>)\n                                     -> P<ast::Expr> {\n-    let arg_types: Vec<_> = (0..args.len()).map(|_| None).collect();\n+    // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n+    // `ArgumentType` does not derive `Clone`.\n+    let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n+    let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let macsp = ecx.call_site();\n     // Expand the format literal so that efmt.span will have a backtrace. This\n     // is essential for locating a bug when the format literal is generated in\n@@ -636,11 +687,14 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         ecx: ecx,\n         args: args,\n         arg_types: arg_types,\n+        arg_unique_types: arg_unique_types,\n         names: names,\n-        name_positions: HashMap::new(),\n-        name_types: HashMap::new(),\n-        name_ordering: name_ordering,\n-        next_arg: 0,\n+        curarg: 0,\n+        arg_index_map: Vec::new(),\n+        count_args: Vec::new(),\n+        count_positions: HashMap::new(),\n+        count_positions_count: 0,\n+        count_args_index_offset: 0,\n         literal: String::new(),\n         pieces: Vec::new(),\n         str_pieces: Vec::new(),\n@@ -656,21 +710,31 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     };\n \n     let mut parser = parse::Parser::new(&fmt);\n+    let mut pieces = vec![];\n \n     loop {\n         match parser.next() {\n-            Some(piece) => {\n+            Some(mut piece) => {\n                 if !parser.errors.is_empty() { break }\n                 cx.verify_piece(&piece);\n-                if let Some(piece) = cx.trans_piece(&piece) {\n-                    let s = cx.trans_literal_string();\n-                    cx.str_pieces.push(s);\n-                    cx.pieces.push(piece);\n-                }\n+                cx.resolve_name_inplace(&mut piece);\n+                pieces.push(piece);\n             }\n             None => break\n         }\n     }\n+\n+    cx.build_index_map();\n+\n+    let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n+    for piece in pieces {\n+        if let Some(piece) = cx.trans_piece(&piece, &mut arg_index_consumed) {\n+            let s = cx.trans_literal_string();\n+            cx.str_pieces.push(s);\n+            cx.pieces.push(piece);\n+        }\n+    }\n+\n     if !parser.errors.is_empty() {\n         cx.ecx.span_err(cx.fmtsp, &format!(\"invalid format string: {}\",\n                                           parser.errors.remove(0)));\n@@ -682,14 +746,20 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n \n     // Make sure that all arguments were used and all arguments have types.\n+    let num_pos_args = cx.args.len() - cx.names.len();\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n-        if ty.is_none() {\n-            cx.ecx.span_err(cx.args[i].span, \"argument never used\");\n-        }\n-    }\n-    for (name, e) in &cx.names {\n-        if !cx.name_types.contains_key(name) {\n-            cx.ecx.span_err(e.span, \"named argument never used\");\n+        if ty.len() == 0 {\n+            if cx.count_positions.contains_key(&i) {\n+                continue;\n+            }\n+            let msg = if i >= num_pos_args {\n+                // named argument\n+                \"named argument never used\"\n+            } else {\n+                // positional argument\n+                \"argument never used\"\n+            };\n+            cx.ecx.span_err(cx.args[i].span, msg);\n         }\n     }\n "}, {"sha": "272ad980feb467c767f36088f10da6881dd3dade", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=db71987ee1198be60fef3e361ad1ce59a70cd7f7", "patch": "@@ -23,9 +23,6 @@ fn main() {\n     format!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n     format!(\"\", foo=2);                //~ ERROR: named argument never used\n \n-    format!(\"{0:x} {0:X}\", 1);         //~ ERROR: redeclared with type `X`\n-    format!(\"{foo:x} {foo:X}\", foo=1); //~ ERROR: redeclared with type `X`\n-\n     format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n     format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n "}, {"sha": "0a69ccf47dd9f99959e154c3b12e949670a377c4", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db71987ee1198be60fef3e361ad1ce59a70cd7f7/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=db71987ee1198be60fef3e361ad1ce59a70cd7f7", "patch": "@@ -163,6 +163,24 @@ pub fn main() {\n     t!(format!(\"{:?}\", 0.0), \"0\");\n \n \n+    // Ergonomic format_args!\n+    t!(format!(\"{0:x} {0:X}\", 15), \"f F\");\n+    t!(format!(\"{0:x} {0:X} {}\", 15), \"f F 15\");\n+    // NOTE: For now the longer test cases must not be followed immediately by\n+    // >1 empty lines, or the pretty printer will break. Since no one wants to\n+    // touch the current pretty printer (#751), we have no choice but to work\n+    // around it. Some of the following test cases are also affected.\n+    t!(format!(\"{:x}{0:X}{a:x}{:X}{1:x}{a:X}\", 13, 14, a=15), \"dDfEeF\");\n+    t!(format!(\"{a:x} {a:X}\", a=15), \"f F\");\n+\n+    // And its edge cases\n+    t!(format!(\"{a:.0$} {b:.0$} {0:.0$}\\n{a:.c$} {b:.c$} {c:.c$}\",\n+               4, a=\"abcdefg\", b=\"hijklmn\", c=3),\n+               \"abcd hijk 4\\nabc hij 3\");\n+    t!(format!(\"{a:.*} {0} {:.*}\", 4, 3, \"efgh\", a=\"abcdef\"), \"abcd 4 efg\");\n+    t!(format!(\"{:.a$} {a} {a:#x}\", \"aaaaaa\", a=2), \"aa 2 0x2\");\n+\n+\n     // Test that pointers don't get truncated.\n     {\n         let val = usize::MAX;\n@@ -177,6 +195,7 @@ pub fn main() {\n     test_write();\n     test_print();\n     test_order();\n+    test_once();\n \n     // make sure that format! doesn't move out of local variables\n     let a: Box<_> = box 3;\n@@ -260,3 +279,17 @@ fn test_order() {\n                        foo(), foo(), foo(), a=foo(), b=foo(), c=foo()),\n                \"1 2 4 5 3 6\".to_string());\n }\n+\n+fn test_once() {\n+    // Make sure each argument are evaluted only once even though it may be\n+    // formatted multiple times\n+    fn foo() -> isize {\n+        static mut FOO: isize = 0;\n+        unsafe {\n+            FOO += 1;\n+            FOO\n+        }\n+    }\n+    assert_eq!(format!(\"{0} {0} {0} {a} {a} {a}\", foo(), a=foo()),\n+               \"1 1 1 2 2 2\".to_string());\n+}"}]}