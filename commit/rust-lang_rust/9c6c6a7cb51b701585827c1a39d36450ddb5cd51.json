{"sha": "9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNmM2YTdjYjUxYjcwMTU4NTgyN2MxYTM5ZDM2NDUwZGRiNWNkNTE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-22T05:32:48Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-22T05:32:48Z"}, "message": "Merge #988\n\n988: Consolidate Ty variants into a new variant Ty::Apply r=matklad a=flodiebold\n\nThis gets us a lot closer to Chalk. It also introduces a lot of boilerplate, though, especially when matching :/ A lot of this can probably be refactored to be nicer, though.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "c5e4c46da389accd0b03b3b285f5057265f65f65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5e4c46da389accd0b03b3b285f5057265f65f65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "html_url": "https://github.com/rust-lang/rust/commit/9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "51323a852a8979a71c21725b3b2771224132b85f", "url": "https://api.github.com/repos/rust-lang/rust/commits/51323a852a8979a71c21725b3b2771224132b85f", "html_url": "https://github.com/rust-lang/rust/commit/51323a852a8979a71c21725b3b2771224132b85f"}, {"sha": "1ee779d1f74f48d9f3098001c63108b794dbc0b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ee779d1f74f48d9f3098001c63108b794dbc0b5", "html_url": "https://github.com/rust-lang/rust/commit/1ee779d1f74f48d9f3098001c63108b794dbc0b5"}], "stats": {"total": 695, "additions": 377, "deletions": 318}, "files": [{"sha": "da67ab667b8ee179eb688574136c3e090e5d9365", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::Write;\n \n use hir::{\n-    AdtDef, Ty, FieldSource, source_binder,\n+    AdtDef, FieldSource, source_binder,\n     db::HirDatabase,\n };\n use ra_syntax::ast::{self, AstNode};\n@@ -26,14 +26,10 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n     let source_map = function.body_source_map(ctx.db);\n     let node_expr = source_map.node_expr(expr)?;\n     let match_expr_ty = infer_result[node_expr].clone();\n-    let enum_def = match match_expr_ty {\n-        Ty::Adt { def_id: AdtDef::Enum(e), .. } => e,\n-        Ty::Ref(adt, _) => match *adt {\n-            Ty::Adt { def_id: AdtDef::Enum(e), .. } => e,\n-            _ => return None,\n-        },\n-        _ => return None,\n-    };\n+    let enum_def = match_expr_ty.autoderef(ctx.db).find_map(|ty| match ty.as_adt() {\n+        Some((AdtDef::Enum(e), _)) => Some(e),\n+        _ => None,\n+    })?;\n     let enum_name = enum_def.name(ctx.db)?;\n     let db = ctx.db;\n "}, {"sha": "c7790dc725324d6b79cce118c7ada065fd965180", "filename": "crates/ra_assists/src/fill_struct_fields.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -1,6 +1,6 @@\n use std::fmt::Write;\n \n-use hir::{AdtDef, Ty, db::HirDatabase, source_binder::function_from_child_node};\n+use hir::{AdtDef, db::HirDatabase, source_binder::function_from_child_node};\n \n use ra_syntax::ast::{self, AstNode};\n \n@@ -60,8 +60,8 @@ where\n         let source_map = function.body_source_map(self.ctx.db);\n         let node_expr = source_map.node_expr(self.struct_lit.into())?;\n         let struct_lit_ty = infer_result[node_expr].clone();\n-        let struct_def = match struct_lit_ty {\n-            Ty::Adt { def_id: AdtDef::Struct(s), .. } => s,\n+        let struct_def = match struct_lit_ty.as_adt() {\n+            Some((AdtDef::Struct(s), _)) => s,\n             _ => return None,\n         };\n         self.struct_fields = struct_def"}, {"sha": "5926b5758bbc9d10709b895d83ac6a83b081cf36", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -53,7 +53,7 @@ pub use self::{\n     name::Name,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n     nameres::{PerNs, Namespace},\n-    ty::{Ty, Substs, display::HirDisplay},\n+    ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay},\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},\n     adt::AdtDef,"}, {"sha": "7d25ade47b7ab5ff25f08296046e9c1407504c02", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 150, "deletions": 111, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -20,11 +20,11 @@ pub(crate) use lower::{TypableDef, CallableDef, type_for_def, type_for_field, ca\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n use display::{HirDisplay, HirFormatter};\n \n-/// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n-///\n-/// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Ty {\n+/// A type constructor or type name: this might be something like the primitive\n+/// type `bool`, a struct like `Vec`, or things like function pointers or\n+/// tuples.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum TypeCtor {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n \n@@ -39,28 +39,23 @@ pub enum Ty {\n     Float(primitive::UncertainFloatTy),\n \n     /// Structures, enumerations and unions.\n-    Adt {\n-        /// The definition of the struct/enum.\n-        def_id: AdtDef,\n-        /// Substitutions for the generic parameters of the type.\n-        substs: Substs,\n-    },\n+    Adt(AdtDef),\n \n     /// The pointee of a string slice. Written as `str`.\n     Str,\n \n     /// The pointee of an array slice.  Written as `[T]`.\n-    Slice(Arc<Ty>),\n+    Slice,\n \n     /// An array with the given length. Written as `[T; n]`.\n-    Array(Arc<Ty>),\n+    Array,\n \n     /// A raw pointer. Written as `*mut T` or `*const T`\n-    RawPtr(Arc<Ty>, Mutability),\n+    RawPtr(Mutability),\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n-    Ref(Arc<Ty>, Mutability),\n+    Ref(Mutability),\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type, which is output (for a function\n@@ -74,12 +69,7 @@ pub enum Ty {\n     /// fn foo() -> i32 { 1 }\n     /// let bar = foo; // bar: fn() -> i32 {foo}\n     /// ```\n-    FnDef {\n-        /// The definition of the function / constructor.\n-        def: CallableDef,\n-        /// Substitutions for the generic parameters of the type\n-        substs: Substs,\n-    },\n+    FnDef(CallableDef),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n     ///\n@@ -89,13 +79,36 @@ pub enum Ty {\n     /// fn foo() -> i32 { 1 }\n     /// let bar: fn() -> i32 = foo;\n     /// ```\n-    FnPtr(FnSig),\n+    FnPtr,\n \n     /// The never type `!`.\n     Never,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    Tuple(Arc<[Ty]>),\n+    Tuple,\n+}\n+\n+/// A nominal type with (maybe 0) type parameters. This might be a primitive\n+/// type like `bool`, a struct, tuple, function pointer, reference or\n+/// several other things.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct ApplicationTy {\n+    pub ctor: TypeCtor,\n+    pub parameters: Substs,\n+}\n+\n+/// A type.\n+///\n+/// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n+/// the same thing (but in a different way).\n+///\n+/// This should be cheap to clone.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum Ty {\n+    /// A nominal type with (maybe 0) type parameters. This might be a primitive\n+    /// type like `bool`, a struct, tuple, function pointer, reference or\n+    /// several other things.\n+    Apply(ApplicationTy),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     Param {\n@@ -127,6 +140,18 @@ impl Substs {\n         Substs(Arc::new([]))\n     }\n \n+    pub fn single(ty: Ty) -> Substs {\n+        Substs(Arc::new([ty]))\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = &Ty> {\n+        self.0.iter()\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n     pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         // Without an Arc::make_mut_slice, we can't avoid the clone here:\n         let mut v: Vec<_> = self.0.iter().cloned().collect();\n@@ -135,9 +160,17 @@ impl Substs {\n         }\n         self.0 = v.into();\n     }\n+\n+    pub fn as_single(&self) -> &Ty {\n+        if self.0.len() != 1 {\n+            panic!(\"expected substs of len 1, got {:?}\", self);\n+        }\n+        &self.0[0]\n+    }\n }\n \n-/// A function signature.\n+/// A function signature as seen by type inference: Several parameter types and\n+/// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FnSig {\n     params_and_return: Arc<[Ty]>,\n@@ -148,6 +181,11 @@ impl FnSig {\n         params.push(ret);\n         FnSig { params_and_return: params.into() }\n     }\n+\n+    pub fn from_fn_ptr_substs(substs: &Substs) -> FnSig {\n+        FnSig { params_and_return: Arc::clone(&substs.0) }\n+    }\n+\n     pub fn params(&self) -> &[Ty] {\n         &self.params_and_return[0..self.params_and_return.len() - 1]\n     }\n@@ -167,80 +205,37 @@ impl FnSig {\n }\n \n impl Ty {\n+    pub fn simple(ctor: TypeCtor) -> Ty {\n+        Ty::Apply(ApplicationTy { ctor, parameters: Substs::empty() })\n+    }\n+    pub fn apply_one(ctor: TypeCtor, param: Ty) -> Ty {\n+        Ty::Apply(ApplicationTy { ctor, parameters: Substs::single(param) })\n+    }\n+    pub fn apply(ctor: TypeCtor, parameters: Substs) -> Ty {\n+        Ty::Apply(ApplicationTy { ctor, parameters })\n+    }\n     pub fn unit() -> Self {\n-        Ty::Tuple(Arc::new([]))\n+        Ty::apply(TypeCtor::Tuple, Substs::empty())\n     }\n \n     pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self {\n-            Ty::Slice(t) | Ty::Array(t) => t.walk(f),\n-            Ty::RawPtr(t, _) => t.walk(f),\n-            Ty::Ref(t, _) => t.walk(f),\n-            Ty::Tuple(ts) => {\n-                for t in ts.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::FnPtr(sig) => {\n-                for input in sig.params() {\n-                    input.walk(f);\n-                }\n-                sig.ret().walk(f);\n-            }\n-            Ty::FnDef { substs, .. } => {\n-                for t in substs.0.iter() {\n+            Ty::Apply(a_ty) => {\n+                for t in a_ty.parameters.iter() {\n                     t.walk(f);\n                 }\n             }\n-            Ty::Adt { substs, .. } => {\n-                for t in substs.0.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::Bool\n-            | Ty::Char\n-            | Ty::Int(_)\n-            | Ty::Float(_)\n-            | Ty::Str\n-            | Ty::Never\n-            | Ty::Param { .. }\n-            | Ty::Infer(_)\n-            | Ty::Unknown => {}\n+            Ty::Param { .. } | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n     }\n \n     fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         match self {\n-            Ty::Slice(t) | Ty::Array(t) => Arc::make_mut(t).walk_mut(f),\n-            Ty::RawPtr(t, _) => Arc::make_mut(t).walk_mut(f),\n-            Ty::Ref(t, _) => Arc::make_mut(t).walk_mut(f),\n-            Ty::Tuple(ts) => {\n-                // Without an Arc::make_mut_slice, we can't avoid the clone here:\n-                let mut v: Vec<_> = ts.iter().cloned().collect();\n-                for t in &mut v {\n-                    t.walk_mut(f);\n-                }\n-                *ts = v.into();\n-            }\n-            Ty::FnPtr(sig) => {\n-                sig.walk_mut(f);\n+            Ty::Apply(a_ty) => {\n+                a_ty.parameters.walk_mut(f);\n             }\n-            Ty::FnDef { substs, .. } => {\n-                substs.walk_mut(f);\n-            }\n-            Ty::Adt { substs, .. } => {\n-                substs.walk_mut(f);\n-            }\n-            Ty::Bool\n-            | Ty::Char\n-            | Ty::Int(_)\n-            | Ty::Float(_)\n-            | Ty::Str\n-            | Ty::Never\n-            | Ty::Param { .. }\n-            | Ty::Infer(_)\n-            | Ty::Unknown => {}\n+            Ty::Param { .. } | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n     }\n@@ -253,10 +248,38 @@ impl Ty {\n         self\n     }\n \n+    pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n+                Some((parameters.as_single(), *mutability))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_adt(&self) -> Option<(AdtDef, &Substs)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_def), parameters }) => {\n+                Some((*adt_def, parameters))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_tuple(&self) -> Option<&Substs> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple, parameters }) => Some(parameters),\n+            _ => None,\n+        }\n+    }\n+\n     fn builtin_deref(&self) -> Option<Ty> {\n         match self {\n-            Ty::Ref(t, _) => Some(Ty::clone(t)),\n-            Ty::RawPtr(t, _) => Some(Ty::clone(t)),\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Ref(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                TypeCtor::RawPtr(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                _ => None,\n+            },\n             _ => None,\n         }\n     }\n@@ -267,8 +290,10 @@ impl Ty {\n     /// `Option<u32>` afterwards.)\n     pub fn apply_substs(self, substs: Substs) -> Ty {\n         match self {\n-            Ty::Adt { def_id, .. } => Ty::Adt { def_id, substs },\n-            Ty::FnDef { def, .. } => Ty::FnDef { def, substs },\n+            Ty::Apply(ApplicationTy { ctor, parameters: previous_substs }) => {\n+                assert_eq!(previous_substs.len(), substs.len());\n+                Ty::Apply(ApplicationTy { ctor, parameters: substs })\n+            }\n             _ => self,\n         }\n     }\n@@ -293,7 +318,7 @@ impl Ty {\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n     fn substs(&self) -> Option<Substs> {\n         match self {\n-            Ty::Adt { substs, .. } | Ty::FnDef { substs, .. } => Some(substs.clone()),\n+            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n             _ => None,\n         }\n     }\n@@ -305,40 +330,45 @@ impl HirDisplay for &Ty {\n     }\n }\n \n-impl HirDisplay for Ty {\n+impl HirDisplay for ApplicationTy {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        match self {\n-            Ty::Bool => write!(f, \"bool\")?,\n-            Ty::Char => write!(f, \"char\")?,\n-            Ty::Int(t) => write!(f, \"{}\", t)?,\n-            Ty::Float(t) => write!(f, \"{}\", t)?,\n-            Ty::Str => write!(f, \"str\")?,\n-            Ty::Slice(t) | Ty::Array(t) => {\n+        match self.ctor {\n+            TypeCtor::Bool => write!(f, \"bool\")?,\n+            TypeCtor::Char => write!(f, \"char\")?,\n+            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Str => write!(f, \"str\")?,\n+            TypeCtor::Slice | TypeCtor::Array => {\n+                let t = self.parameters.as_single();\n                 write!(f, \"[{}]\", t.display(f.db))?;\n             }\n-            Ty::RawPtr(t, m) => {\n+            TypeCtor::RawPtr(m) => {\n+                let t = self.parameters.as_single();\n                 write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n             }\n-            Ty::Ref(t, m) => {\n+            TypeCtor::Ref(m) => {\n+                let t = self.parameters.as_single();\n                 write!(f, \"&{}{}\", m.as_keyword_for_ref(), t.display(f.db))?;\n             }\n-            Ty::Never => write!(f, \"!\")?,\n-            Ty::Tuple(ts) => {\n-                if ts.len() == 1 {\n-                    write!(f, \"({},)\", ts[0].display(f.db))?;\n+            TypeCtor::Never => write!(f, \"!\")?,\n+            TypeCtor::Tuple => {\n+                let ts = &self.parameters;\n+                if ts.0.len() == 1 {\n+                    write!(f, \"({},)\", ts.0[0].display(f.db))?;\n                 } else {\n                     write!(f, \"(\")?;\n-                    f.write_joined(&**ts, \", \")?;\n+                    f.write_joined(&*ts.0, \", \")?;\n                     write!(f, \")\")?;\n                 }\n             }\n-            Ty::FnPtr(sig) => {\n+            TypeCtor::FnPtr => {\n+                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n                 write!(f, \"fn(\")?;\n                 f.write_joined(sig.params(), \", \")?;\n                 write!(f, \") -> {}\", sig.ret().display(f.db))?;\n             }\n-            Ty::FnDef { def, substs, .. } => {\n-                let sig = f.db.callable_item_signature(*def);\n+            TypeCtor::FnDef(def) => {\n+                let sig = f.db.callable_item_signature(def);\n                 let name = match def {\n                     CallableDef::Function(ff) => ff.name(f.db),\n                     CallableDef::Struct(s) => s.name(f.db).unwrap_or_else(Name::missing),\n@@ -348,28 +378,37 @@ impl HirDisplay for Ty {\n                     CallableDef::Function(_) => write!(f, \"fn {}\", name)?,\n                     CallableDef::Struct(_) | CallableDef::EnumVariant(_) => write!(f, \"{}\", name)?,\n                 }\n-                if substs.0.len() > 0 {\n+                if self.parameters.0.len() > 0 {\n                     write!(f, \"<\")?;\n-                    f.write_joined(&*substs.0, \", \")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n                     write!(f, \">\")?;\n                 }\n                 write!(f, \"(\")?;\n                 f.write_joined(sig.params(), \", \")?;\n                 write!(f, \") -> {}\", sig.ret().display(f.db))?;\n             }\n-            Ty::Adt { def_id, substs, .. } => {\n+            TypeCtor::Adt(def_id) => {\n                 let name = match def_id {\n                     AdtDef::Struct(s) => s.name(f.db),\n                     AdtDef::Enum(e) => e.name(f.db),\n                 }\n                 .unwrap_or_else(Name::missing);\n                 write!(f, \"{}\", name)?;\n-                if substs.0.len() > 0 {\n+                if self.parameters.0.len() > 0 {\n                     write!(f, \"<\")?;\n-                    f.write_joined(&*substs.0, \", \")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n                     write!(f, \">\")?;\n                 }\n             }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        match self {\n+            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,"}, {"sha": "bf42befbb7dcb25802138cfae0a62feef906284d", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 147, "deletions": 117, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -38,7 +38,7 @@ use crate::{\n     resolve::{Resolver, Resolution},\n     nameres::Namespace\n };\n-use super::{Ty, TypableDef, Substs, primitive, op};\n+use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeCtor};\n \n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n@@ -237,29 +237,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         match (&*ty1, &*ty2) {\n             (Ty::Unknown, ..) => true,\n             (.., Ty::Unknown) => true,\n-            (Ty::Int(t1), Ty::Int(t2)) => match (t1, t2) {\n-                (primitive::UncertainIntTy::Unknown, _)\n-                | (_, primitive::UncertainIntTy::Unknown) => true,\n-                _ => t1 == t2,\n-            },\n-            (Ty::Float(t1), Ty::Float(t2)) => match (t1, t2) {\n-                (primitive::UncertainFloatTy::Unknown, _)\n-                | (_, primitive::UncertainFloatTy::Unknown) => true,\n-                _ => t1 == t2,\n-            },\n-            (Ty::Bool, _) | (Ty::Str, _) | (Ty::Never, _) | (Ty::Char, _) => ty1 == ty2,\n-            (\n-                Ty::Adt { def_id: def_id1, substs: substs1, .. },\n-                Ty::Adt { def_id: def_id2, substs: substs2, .. },\n-            ) if def_id1 == def_id2 => self.unify_substs(substs1, substs2, depth + 1),\n-            (Ty::Slice(t1), Ty::Slice(t2)) => self.unify_inner(t1, t2, depth + 1),\n-            (Ty::RawPtr(t1, m1), Ty::RawPtr(t2, m2)) if m1 == m2 => {\n-                self.unify_inner(t1, t2, depth + 1)\n-            }\n-            (Ty::Ref(t1, m1), Ty::Ref(t2, m2)) if m1 == m2 => self.unify_inner(t1, t2, depth + 1),\n-            (Ty::FnPtr(sig1), Ty::FnPtr(sig2)) if sig1 == sig2 => true,\n-            (Ty::Tuple(ts1), Ty::Tuple(ts2)) if ts1.len() == ts2.len() => {\n-                ts1.iter().zip(ts2.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth + 1))\n+            (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n+                self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n             }\n             (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n             | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n@@ -298,8 +277,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty {\n             Ty::Unknown => self.new_type_var(),\n-            Ty::Int(primitive::UncertainIntTy::Unknown) => self.new_integer_var(),\n-            Ty::Float(primitive::UncertainFloatTy::Unknown) => self.new_float_var(),\n+            Ty::Apply(ApplicationTy {\n+                ctor: TypeCtor::Int(primitive::UncertainIntTy::Unknown),\n+                ..\n+            }) => self.new_integer_var(),\n+            Ty::Apply(ApplicationTy {\n+                ctor: TypeCtor::Float(primitive::UncertainFloatTy::Unknown),\n+                ..\n+            }) => self.new_float_var(),\n             _ => ty,\n         }\n     }\n@@ -610,12 +595,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Missing => false,\n         };\n         if is_non_ref_pat {\n-            while let Ty::Ref(inner, mutability) = expected {\n+            while let Some((inner, mutability)) = expected.as_reference() {\n                 expected = inner;\n                 default_bm = match default_bm {\n-                    BindingMode::Move => BindingMode::Ref(*mutability),\n+                    BindingMode::Move => BindingMode::Ref(mutability),\n                     BindingMode::Ref(Mutability::Shared) => BindingMode::Ref(Mutability::Shared),\n-                    BindingMode::Ref(Mutability::Mut) => BindingMode::Ref(*mutability),\n+                    BindingMode::Ref(Mutability::Mut) => BindingMode::Ref(mutability),\n                 }\n             }\n         } else if let Pat::Ref { .. } = &body[pat] {\n@@ -631,8 +616,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         let ty = match &body[pat] {\n             Pat::Tuple(ref args) => {\n-                let expectations = match *expected {\n-                    Ty::Tuple(ref tuple_args) => &**tuple_args,\n+                let expectations = match expected.as_tuple() {\n+                    Some(parameters) => &*parameters.0,\n                     _ => &[],\n                 };\n                 let expectations_iter = expectations.iter().chain(repeat(&Ty::Unknown));\n@@ -644,20 +629,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     .collect::<Vec<_>>()\n                     .into();\n \n-                Ty::Tuple(inner_tys)\n+                Ty::apply(TypeCtor::Tuple, Substs(inner_tys))\n             }\n             Pat::Ref { pat, mutability } => {\n-                let expectation = match *expected {\n-                    Ty::Ref(ref sub_ty, exp_mut) => {\n+                let expectation = match expected.as_reference() {\n+                    Some((inner_ty, exp_mut)) => {\n                         if *mutability != exp_mut {\n                             // TODO: emit type error?\n                         }\n-                        &**sub_ty\n+                        inner_ty\n                     }\n                     _ => &Ty::Unknown,\n                 };\n                 let subty = self.infer_pat(*pat, expectation, default_bm);\n-                Ty::Ref(subty.into(), *mutability)\n+                Ty::apply_one(TypeCtor::Ref(*mutability), subty.into())\n             }\n             Pat::TupleStruct { path: ref p, args: ref subpats } => {\n                 self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm)\n@@ -684,7 +669,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let inner_ty = self.insert_type_vars_shallow(inner_ty);\n \n                 let bound_ty = match mode {\n-                    BindingMode::Ref(mutability) => Ty::Ref(inner_ty.clone().into(), mutability),\n+                    BindingMode::Ref(mutability) => {\n+                        Ty::apply_one(TypeCtor::Ref(mutability), inner_ty.clone().into())\n+                    }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n                 let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n@@ -738,7 +725,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Missing => Ty::Unknown,\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 let then_ty = self.infer_expr(*then_branch, expected);\n                 match else_branch {\n                     Some(else_branch) => {\n@@ -755,11 +742,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Loop { body } => {\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 // TODO handle break with value\n-                Ty::Never\n+                Ty::simple(TypeCtor::Never)\n             }\n             Expr::While { condition, body } => {\n                 // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n@@ -789,14 +776,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let (param_tys, ret_ty) = match &callee_ty {\n-                    Ty::FnPtr(sig) => (sig.params().to_vec(), sig.ret().clone()),\n-                    Ty::FnDef { substs, def, .. } => {\n-                        let sig = self.db.callable_item_signature(*def);\n-                        let ret_ty = sig.ret().clone().subst(&substs);\n-                        let param_tys =\n-                            sig.params().iter().map(|ty| ty.clone().subst(&substs)).collect();\n-                        (param_tys, ret_ty)\n-                    }\n+                    Ty::Apply(a_ty) => match a_ty.ctor {\n+                        TypeCtor::FnPtr => {\n+                            let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n+                            (sig.params().to_vec(), sig.ret().clone())\n+                        }\n+                        TypeCtor::FnDef(def) => {\n+                            let sig = self.db.callable_item_signature(def);\n+                            let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n+                            let param_tys = sig\n+                                .params()\n+                                .iter()\n+                                .map(|ty| ty.clone().subst(&a_ty.parameters))\n+                                .collect();\n+                            (param_tys, ret_ty)\n+                        }\n+                        _ => (Vec::new(), Ty::Unknown),\n+                    },\n                     _ => {\n                         // not callable\n                         // TODO report an error?\n@@ -821,37 +817,49 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             Some(func.generic_params(self.db)),\n                         )\n                     }\n-                    None => (Ty::Unknown, receiver_ty, None),\n+                    None => (receiver_ty, Ty::Unknown, None),\n                 };\n                 let substs = self.substs_for_method_call(def_generics, generic_args);\n                 let method_ty = method_ty.apply_substs(substs);\n                 let method_ty = self.insert_type_vars(method_ty);\n                 let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n-                    Ty::FnPtr(sig) => {\n-                        if !sig.params().is_empty() {\n-                            (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n-                        } else {\n-                            (Ty::Unknown, Vec::new(), sig.ret().clone())\n+                    Ty::Apply(a_ty) => match a_ty.ctor {\n+                        TypeCtor::FnPtr => {\n+                            let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n+                            if !sig.params().is_empty() {\n+                                (\n+                                    sig.params()[0].clone(),\n+                                    sig.params()[1..].to_vec(),\n+                                    sig.ret().clone(),\n+                                )\n+                            } else {\n+                                (Ty::Unknown, Vec::new(), sig.ret().clone())\n+                            }\n                         }\n-                    }\n-                    Ty::FnDef { substs, def, .. } => {\n-                        let sig = self.db.callable_item_signature(*def);\n-                        let ret_ty = sig.ret().clone().subst(&substs);\n-\n-                        if !sig.params().is_empty() {\n-                            let mut params_iter =\n-                                sig.params().iter().map(|ty| ty.clone().subst(&substs));\n-                            let receiver_ty = params_iter.next().unwrap();\n-                            (receiver_ty, params_iter.collect(), ret_ty)\n-                        } else {\n-                            (Ty::Unknown, Vec::new(), ret_ty)\n+                        TypeCtor::FnDef(def) => {\n+                            let sig = self.db.callable_item_signature(def);\n+                            let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n+\n+                            if !sig.params().is_empty() {\n+                                let mut params_iter = sig\n+                                    .params()\n+                                    .iter()\n+                                    .map(|ty| ty.clone().subst(&a_ty.parameters));\n+                                let receiver_ty = params_iter.next().unwrap();\n+                                (receiver_ty, params_iter.collect(), ret_ty)\n+                            } else {\n+                                (Ty::Unknown, Vec::new(), ret_ty)\n+                            }\n                         }\n-                    }\n+                        _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n+                    },\n                     _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n                 };\n                 // Apply autoref so the below unification works correctly\n-                let actual_receiver_ty = match expected_receiver_ty {\n-                    Ty::Ref(_, mutability) => Ty::Ref(Arc::new(derefed_receiver_ty), mutability),\n+                let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n+                    Some((_, mutability)) => {\n+                        Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty)\n+                    }\n                     _ => derefed_receiver_ty,\n                 };\n                 self.unify(&expected_receiver_ty, &actual_receiver_ty);\n@@ -875,7 +883,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let _pat_ty = self.infer_pat(pat, &input_ty, BindingMode::default());\n                     }\n                     if let Some(guard_expr) = arm.guard {\n-                        self.infer_expr(guard_expr, &Expectation::has_type(Ty::Bool));\n+                        self.infer_expr(\n+                            guard_expr,\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n+                        );\n                     }\n                     self.infer_expr(arm.expr, &expected);\n                 }\n@@ -887,19 +898,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n                 self.infer_path_expr(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n-            Expr::Continue => Ty::Never,\n+            Expr::Continue => Ty::simple(TypeCtor::Never),\n             Expr::Break { expr } => {\n                 if let Some(expr) = expr {\n                     // TODO handle break with value\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n-                Ty::Never\n+                Ty::simple(TypeCtor::Never)\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n                 }\n-                Ty::Never\n+                Ty::simple(TypeCtor::Never)\n             }\n             Expr::StructLit { path, fields, spread } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n@@ -921,16 +932,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let ty = receiver_ty\n                     .autoderef(self.db)\n                     .find_map(|derefed_ty| match derefed_ty {\n-                        Ty::Tuple(fields) => {\n-                            let i = name.to_string().parse::<usize>().ok();\n-                            i.and_then(|i| fields.get(i).cloned())\n-                        }\n-                        Ty::Adt { def_id: AdtDef::Struct(s), ref substs, .. } => {\n-                            s.field(self.db, name).map(|field| {\n-                                self.write_field_resolution(tgt_expr, field);\n-                                field.ty(self.db).subst(substs)\n-                            })\n-                        }\n+                        Ty::Apply(a_ty) => match a_ty.ctor {\n+                            TypeCtor::Tuple => {\n+                                let i = name.to_string().parse::<usize>().ok();\n+                                i.and_then(|i| a_ty.parameters.0.get(i).cloned())\n+                            }\n+                            TypeCtor::Adt(AdtDef::Struct(s)) => {\n+                                s.field(self.db, name).map(|field| {\n+                                    self.write_field_resolution(tgt_expr, field);\n+                                    field.ty(self.db).subst(&a_ty.parameters)\n+                                })\n+                            }\n+                            _ => None,\n+                        },\n                         _ => None,\n                     })\n                     .unwrap_or(Ty::Unknown);\n@@ -947,18 +961,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 cast_ty\n             }\n             Expr::Ref { expr, mutability } => {\n-                let expectation = if let Ty::Ref(ref subty, expected_mutability) = expected.ty {\n-                    if expected_mutability == Mutability::Mut && *mutability == Mutability::Shared {\n-                        // TODO: throw type error - expected mut reference but found shared ref,\n-                        // which cannot be coerced\n-                    }\n-                    Expectation::has_type((**subty).clone())\n-                } else {\n-                    Expectation::none()\n-                };\n+                let expectation =\n+                    if let Some((exp_inner, exp_mutability)) = &expected.ty.as_reference() {\n+                        if *exp_mutability == Mutability::Mut && *mutability == Mutability::Shared {\n+                            // TODO: throw type error - expected mut reference but found shared ref,\n+                            // which cannot be coerced\n+                        }\n+                        Expectation::has_type(Ty::clone(exp_inner))\n+                    } else {\n+                        Expectation::none()\n+                    };\n                 // TODO reference coercions etc.\n                 let inner_ty = self.infer_expr(*expr, &expectation);\n-                Ty::Ref(Arc::new(inner_ty), *mutability)\n+                Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n             Expr::UnaryOp { expr, op } => {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());\n@@ -972,19 +987,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         }\n                     }\n                     UnaryOp::Neg => {\n-                        match inner_ty {\n-                            Ty::Int(primitive::UncertainIntTy::Unknown)\n-                            | Ty::Int(primitive::UncertainIntTy::Signed(..))\n-                            | Ty::Infer(InferTy::IntVar(..))\n-                            | Ty::Infer(InferTy::FloatVar(..))\n-                            | Ty::Float(..) => inner_ty,\n+                        match &inner_ty {\n+                            Ty::Apply(a_ty) => match a_ty.ctor {\n+                                TypeCtor::Int(primitive::UncertainIntTy::Unknown)\n+                                | TypeCtor::Int(primitive::UncertainIntTy::Signed(..))\n+                                | TypeCtor::Float(..) => inner_ty,\n+                                _ => Ty::Unknown,\n+                            },\n+                            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => {\n+                                inner_ty\n+                            }\n                             // TODO: resolve ops::Neg trait\n                             _ => Ty::Unknown,\n                         }\n                     }\n                     UnaryOp::Not => {\n-                        match inner_ty {\n-                            Ty::Bool | Ty::Int(_) | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n+                        match &inner_ty {\n+                            Ty::Apply(a_ty) => match a_ty.ctor {\n+                                TypeCtor::Bool | TypeCtor::Int(_) => inner_ty,\n+                                _ => Ty::Unknown,\n+                            },\n+                            Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n                             // TODO: resolve ops::Not trait for inner_ty\n                             _ => Ty::Unknown,\n                         }\n@@ -995,7 +1018,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Some(op) => {\n                     let lhs_expectation = match op {\n                         BinaryOp::BooleanAnd | BinaryOp::BooleanOr => {\n-                            Expectation::has_type(Ty::Bool)\n+                            Expectation::has_type(Ty::simple(TypeCtor::Bool))\n                         }\n                         _ => Expectation::none(),\n                     };\n@@ -1016,33 +1039,40 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     ty_vec.push(self.infer_expr(*arg, &Expectation::none()));\n                 }\n \n-                Ty::Tuple(Arc::from(ty_vec))\n+                Ty::apply(TypeCtor::Tuple, Substs(ty_vec.into()))\n             }\n             Expr::Array { exprs } => {\n                 let elem_ty = match &expected.ty {\n-                    Ty::Slice(inner) | Ty::Array(inner) => Ty::clone(&inner),\n+                    Ty::Apply(a_ty) => match a_ty.ctor {\n+                        TypeCtor::Slice | TypeCtor::Array => {\n+                            Ty::clone(&a_ty.parameters.as_single())\n+                        }\n+                        _ => self.new_type_var(),\n+                    },\n                     _ => self.new_type_var(),\n                 };\n \n                 for expr in exprs.iter() {\n                     self.infer_expr(*expr, &Expectation::has_type(elem_ty.clone()));\n                 }\n \n-                Ty::Array(Arc::new(elem_ty))\n+                Ty::apply_one(TypeCtor::Array, elem_ty)\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => Ty::Bool,\n-                Literal::String(..) => Ty::Ref(Arc::new(Ty::Str), Mutability::Shared),\n+                Literal::Bool(..) => Ty::simple(TypeCtor::Bool),\n+                Literal::String(..) => {\n+                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), Ty::simple(TypeCtor::Str))\n+                }\n                 Literal::ByteString(..) => {\n-                    let byte_type = Arc::new(Ty::Int(primitive::UncertainIntTy::Unsigned(\n+                    let byte_type = Ty::simple(TypeCtor::Int(primitive::UncertainIntTy::Unsigned(\n                         primitive::UintTy::U8,\n                     )));\n-                    let slice_type = Arc::new(Ty::Slice(byte_type));\n-                    Ty::Ref(slice_type, Mutability::Shared)\n+                    let slice_type = Ty::apply_one(TypeCtor::Slice, byte_type);\n+                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n                 }\n-                Literal::Char(..) => Ty::Char,\n-                Literal::Int(_v, ty) => Ty::Int(*ty),\n-                Literal::Float(_v, ty) => Ty::Float(*ty),\n+                Literal::Char(..) => Ty::simple(TypeCtor::Char),\n+                Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int(*ty)),\n+                Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float(*ty)),\n             },\n         };\n         // use a new type variable if we got Ty::Unknown here\n@@ -1178,11 +1208,11 @@ impl InferTy {\n         match self {\n             InferTy::TypeVar(..) => Ty::Unknown,\n             InferTy::IntVar(..) => {\n-                Ty::Int(primitive::UncertainIntTy::Signed(primitive::IntTy::I32))\n-            }\n-            InferTy::FloatVar(..) => {\n-                Ty::Float(primitive::UncertainFloatTy::Known(primitive::FloatTy::F64))\n+                Ty::simple(TypeCtor::Int(primitive::UncertainIntTy::Signed(primitive::IntTy::I32)))\n             }\n+            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(\n+                primitive::UncertainFloatTy::Known(primitive::FloatTy::F64),\n+            )),\n         }\n     }\n }"}, {"sha": "72b1234bf97c50b97b0f83213e23f705a01aafe9", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -6,8 +6,6 @@\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n \n-use std::sync::Arc;\n-\n use crate::{\n     Function, Struct, StructField, Enum, EnumVariant, Path,\n     ModuleDef, TypeAlias,\n@@ -21,40 +19,40 @@ use crate::{\n     generics::GenericParams,\n     adt::VariantDef,\n };\n-use super::{Ty, primitive, FnSig, Substs};\n+use super::{Ty, primitive, FnSig, Substs, TypeCtor};\n \n impl Ty {\n     pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n         match type_ref {\n-            TypeRef::Never => Ty::Never,\n+            TypeRef::Never => Ty::simple(TypeCtor::Never),\n             TypeRef::Tuple(inner) => {\n                 let inner_tys =\n                     inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n-                Ty::Tuple(inner_tys.into())\n+                Ty::apply(TypeCtor::Tuple, Substs(inner_tys.into()))\n             }\n             TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n             TypeRef::RawPtr(inner, mutability) => {\n                 let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::RawPtr(Arc::new(inner_ty), *mutability)\n+                Ty::apply_one(TypeCtor::RawPtr(*mutability), inner_ty)\n             }\n             TypeRef::Array(inner) => {\n                 let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::Array(Arc::new(inner_ty))\n+                Ty::apply_one(TypeCtor::Array, inner_ty)\n             }\n             TypeRef::Slice(inner) => {\n                 let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::Slice(Arc::new(inner_ty))\n+                Ty::apply_one(TypeCtor::Slice, inner_ty)\n             }\n             TypeRef::Reference(inner, mutability) => {\n                 let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::Ref(Arc::new(inner_ty), *mutability)\n+                Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let inner_tys =\n                     params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n-                let sig = FnSig { params_and_return: inner_tys.into() };\n-                Ty::FnPtr(sig)\n+                let sig = Substs(inner_tys.into());\n+                Ty::apply(TypeCtor::FnPtr, sig)\n             }\n             TypeRef::Error => Ty::Unknown,\n         }\n@@ -64,14 +62,14 @@ impl Ty {\n         if let Some(name) = path.as_ident() {\n             // TODO handle primitive type names in resolver as well?\n             if let Some(int_ty) = primitive::UncertainIntTy::from_type_name(name) {\n-                return Ty::Int(int_ty);\n+                return Ty::simple(TypeCtor::Int(int_ty));\n             } else if let Some(float_ty) = primitive::UncertainFloatTy::from_type_name(name) {\n-                return Ty::Float(float_ty);\n+                return Ty::simple(TypeCtor::Float(float_ty));\n             } else if let Some(known) = name.as_known_name() {\n                 match known {\n-                    KnownName::Bool => return Ty::Bool,\n-                    KnownName::Char => return Ty::Char,\n-                    KnownName::Str => return Ty::Str,\n+                    KnownName::Bool => return Ty::simple(TypeCtor::Bool),\n+                    KnownName::Char => return Ty::simple(TypeCtor::Char),\n+                    KnownName::Str => return Ty::simple(TypeCtor::Str),\n                     _ => {}\n                 }\n             }\n@@ -247,7 +245,7 @@ fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     let generics = def.generic_params(db);\n     let substs = make_substs(&generics);\n-    Ty::FnDef { def: def.into(), substs }\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n /// Build the declared type of a const.\n@@ -289,7 +287,7 @@ fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n     }\n     let generics = def.generic_params(db);\n     let substs = make_substs(&generics);\n-    Ty::FnDef { def: def.into(), substs }\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> FnSig {\n@@ -317,7 +315,7 @@ fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) ->\n     }\n     let generics = def.parent_enum(db).generic_params(db);\n     let substs = make_substs(&generics);\n-    Ty::FnDef { def: def.into(), substs }\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n fn make_substs(generics: &GenericParams) -> Substs {\n@@ -333,12 +331,12 @@ fn make_substs(generics: &GenericParams) -> Substs {\n \n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::Adt { def_id: s.into(), substs: make_substs(&generics) }\n+    Ty::apply(TypeCtor::Adt(s.into()), make_substs(&generics))\n }\n \n fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::Adt { def_id: s.into(), substs: make_substs(&generics) }\n+    Ty::apply(TypeCtor::Adt(s.into()), make_substs(&generics))\n }\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {"}, {"sha": "ed75bfaee394e7b60818d548da978e8bc917c33d", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -10,15 +10,15 @@ use crate::{\n     HirDatabase, Module, Crate, Name, Function, Trait,\n     ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n-    ty::{AdtDef, Ty},\n+    ty::{Ty, TypeCtor},\n     nameres::CrateModuleId,\n \n };\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum TyFingerprint {\n-    Adt(AdtDef), // we'll also want to index impls for primitive types etc.\n+    Apply(TypeCtor),\n }\n \n impl TyFingerprint {\n@@ -27,7 +27,7 @@ impl TyFingerprint {\n     /// `impl &S`. Hence, this will return `None` for reference types and such.\n     fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n         match ty {\n-            Ty::Adt { def_id, .. } => Some(TyFingerprint::Adt(*def_id)),\n+            Ty::Apply(a_ty) => Some(TyFingerprint::Apply(a_ty.ctor)),\n             _ => None,\n         }\n     }\n@@ -111,7 +111,10 @@ impl CrateImplBlocks {\n \n fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n     match ty {\n-        Ty::Adt { def_id, .. } => def_id.krate(db),\n+        Ty::Apply(a_ty) => match a_ty.ctor {\n+            TypeCtor::Adt(def_id) => def_id.krate(db),\n+            _ => None,\n+        },\n         _ => None,\n     }\n }"}, {"sha": "235661a5d81b3792ff4252544cfc7e5fd4ac1c89", "filename": "crates/ra_hir/src/ty/op.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -1,5 +1,5 @@\n-use crate::expr::BinaryOp;\n-use super::{Ty, InferTy};\n+use crate::{ ty::ApplicationTy, expr::BinaryOp};\n+use super::{Ty, TypeCtor, InferTy};\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n     match op {\n@@ -10,7 +10,7 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n         | BinaryOp::LesserEqualTest\n         | BinaryOp::GreaterEqualTest\n         | BinaryOp::LesserTest\n-        | BinaryOp::GreaterTest => Ty::Bool,\n+        | BinaryOp::GreaterTest => Ty::simple(TypeCtor::Bool),\n         BinaryOp::Assignment\n         | BinaryOp::AddAssign\n         | BinaryOp::SubAssign\n@@ -32,10 +32,11 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n         | BinaryOp::BitwiseAnd\n         | BinaryOp::BitwiseOr\n         | BinaryOp::BitwiseXor => match rhs_ty {\n-            Ty::Int(..)\n-            | Ty::Float(..)\n-            | Ty::Infer(InferTy::IntVar(..))\n-            | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n+            Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n+                TypeCtor::Int(..) | TypeCtor::Float(..) => rhs_ty,\n+                _ => Ty::Unknown,\n+            },\n+            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::RangeRightOpen | BinaryOp::RangeRightClosed => Ty::Unknown,\n@@ -44,9 +45,17 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n \n pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => Ty::Bool,\n+        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => Ty::simple(TypeCtor::Bool),\n         BinaryOp::Assignment | BinaryOp::EqualityTest => match lhs_ty {\n-            Ty::Int(..) | Ty::Float(..) | Ty::Str | Ty::Char | Ty::Bool => lhs_ty,\n+            Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n+                TypeCtor::Int(..)\n+                | TypeCtor::Float(..)\n+                | TypeCtor::Str\n+                | TypeCtor::Char\n+                | TypeCtor::Bool => lhs_ty,\n+                _ => Ty::Unknown,\n+            },\n+            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::LesserEqualTest\n@@ -73,7 +82,11 @@ pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n         | BinaryOp::BitwiseAnd\n         | BinaryOp::BitwiseOr\n         | BinaryOp::BitwiseXor => match lhs_ty {\n-            Ty::Int(..) | Ty::Float(..) => lhs_ty,\n+            Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n+                TypeCtor::Int(..) | TypeCtor::Float(..) => lhs_ty,\n+                _ => Ty::Unknown,\n+            },\n+            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         _ => Ty::Unknown,"}, {"sha": "31d5374ba0872d5973f7480bbcec5160ecb7cb14", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Ty, AdtDef};\n+use hir::{Ty, AdtDef, TypeCtor};\n \n use crate::completion::{CompletionContext, Completions};\n \n@@ -24,23 +24,20 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     for receiver in receiver.autoderef(ctx.db) {\n         match receiver {\n-            Ty::Adt { def_id, ref substs, .. } => {\n-                match def_id {\n-                    AdtDef::Struct(s) => {\n-                        for field in s.fields(ctx.db) {\n-                            acc.add_field(ctx, field, substs);\n-                        }\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Adt(AdtDef::Struct(s)) => {\n+                    for field in s.fields(ctx.db) {\n+                        acc.add_field(ctx, field, &a_ty.parameters);\n                     }\n-\n-                    // TODO unions\n-                    AdtDef::Enum(_) => (),\n                 }\n-            }\n-            Ty::Tuple(fields) => {\n-                for (i, ty) in fields.iter().enumerate() {\n-                    acc.add_pos_field(ctx, i, ty);\n+                // TODO unions\n+                TypeCtor::Tuple => {\n+                    for (i, ty) in a_ty.parameters.iter().enumerate() {\n+                        acc.add_pos_field(ctx, i, ty);\n+                    }\n                 }\n-            }\n+                _ => {}\n+            },\n             _ => {}\n         };\n     }"}, {"sha": "b755262827686e6b82281b43a94225bc0f0a6f11", "filename": "crates/ra_ide_api/src/completion/complete_struct_literal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Ty, AdtDef};\n+use hir::AdtDef;\n \n use crate::completion::{CompletionContext, Completions};\n \n@@ -15,8 +15,8 @@ pub(super) fn complete_struct_literal(acc: &mut Completions, ctx: &CompletionCon\n         None => return,\n     };\n     let ty = infer_result[expr].clone();\n-    let (adt, substs) = match ty {\n-        Ty::Adt { def_id, ref substs, .. } => (def_id, substs),\n+    let (adt, substs) = match ty.as_adt() {\n+        Some(res) => res,\n         _ => return,\n     };\n     match adt {"}, {"sha": "f94487d94d5e7dd9e0ca111698eac5a310b8bdcf", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -87,14 +87,12 @@ pub(crate) fn reference_definition(\n \n             if let Some(expr) = struct_lit.and_then(|lit| source_map.node_expr(lit.into())) {\n                 let ty = infer_result[expr].clone();\n-                if let hir::Ty::Adt { def_id, .. } = ty {\n-                    if let hir::AdtDef::Struct(s) = def_id {\n-                        let hir_path = hir::Path::from_name_ref(name_ref);\n-                        let hir_name = hir_path.as_ident().unwrap();\n+                if let Some((hir::AdtDef::Struct(s), _)) = ty.as_adt() {\n+                    let hir_path = hir::Path::from_name_ref(name_ref);\n+                    let hir_name = hir_path.as_ident().unwrap();\n \n-                        if let Some(field) = s.field(db, hir_name) {\n-                            return Exact(NavigationTarget::from_field(db, field));\n-                        }\n+                    if let Some(field) = s.field(db, hir_name) {\n+                        return Exact(NavigationTarget::from_field(db, field));\n                     }\n                 }\n             }\n@@ -124,7 +122,7 @@ pub(crate) fn reference_definition(\n             Some(Resolution::SelfType(impl_block)) => {\n                 let ty = impl_block.target_ty(db);\n \n-                if let hir::Ty::Adt { def_id, .. } = ty {\n+                if let Some((def_id, _)) = ty.as_adt() {\n                     return Exact(NavigationTarget::from_adt_def(db, def_id));\n                 }\n             }"}, {"sha": "f6443580de68ce7331c604d8096c549fcad71454", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6c6a7cb51b701585827c1a39d36450ddb5cd51/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=9c6c6a7cb51b701585827c1a39d36450ddb5cd51", "patch": "@@ -517,23 +517,8 @@ The Some variant\n         assert_eq!(\"u32\", &type_name);\n     }\n \n-    // FIXME: improve type_of to make this work\n     #[test]\n-    fn test_type_of_for_expr_1() {\n-        let (analysis, range) = single_file_with_range(\n-            \"\n-            fn main() {\n-                let foo = <|>1 + foo_test<|>;\n-            }\n-            \",\n-        );\n-\n-        let type_name = analysis.type_of(range).unwrap().unwrap();\n-        assert_eq!(\"{unknown}\", &type_name);\n-    }\n-\n-    #[test]\n-    fn test_type_of_for_expr_2() {\n+    fn test_type_of_for_expr() {\n         let (analysis, range) = single_file_with_range(\n             \"\n             fn main() {"}]}