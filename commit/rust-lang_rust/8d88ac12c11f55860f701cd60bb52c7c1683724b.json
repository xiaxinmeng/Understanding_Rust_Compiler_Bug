{"sha": "8d88ac12c11f55860f701cd60bb52c7c1683724b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkODhhYzEyYzExZjU1ODYwZjcwMWNkNjBiYjUyYzdjMTY4MzcyNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T00:21:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T00:21:31Z"}, "message": "Merge pull request #20966 from Valloric/ownership-fix\n\nFixing integer usage in ownership doc\n\nReviewed-by: steveklabnik", "tree": {"sha": "0b44faaab93d2cb45ea18b8d54e414489d31a893", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b44faaab93d2cb45ea18b8d54e414489d31a893"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d88ac12c11f55860f701cd60bb52c7c1683724b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d88ac12c11f55860f701cd60bb52c7c1683724b", "html_url": "https://github.com/rust-lang/rust/commit/8d88ac12c11f55860f701cd60bb52c7c1683724b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d88ac12c11f55860f701cd60bb52c7c1683724b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c824c5b652e1f3570af3701295ae6b8611942ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c824c5b652e1f3570af3701295ae6b8611942ca", "html_url": "https://github.com/rust-lang/rust/commit/8c824c5b652e1f3570af3701295ae6b8611942ca"}, {"sha": "d355da6e6f30ab37bead7da5fc895de5b7047508", "url": "https://api.github.com/repos/rust-lang/rust/commits/d355da6e6f30ab37bead7da5fc895de5b7047508", "html_url": "https://github.com/rust-lang/rust/commit/d355da6e6f30ab37bead7da5fc895de5b7047508"}], "stats": {"total": 78, "additions": 39, "deletions": 39}, "files": [{"sha": "8e5a757e1bda7e34dd6b4026bceca9a7b7a91ab5", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8d88ac12c11f55860f701cd60bb52c7c1683724b/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d88ac12c11f55860f701cd60bb52c7c1683724b/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=8d88ac12c11f55860f701cd60bb52c7c1683724b", "patch": "@@ -83,13 +83,13 @@ Rust:\n ```rust\n # use std::boxed::Box;\n {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n }\n ```\n \n-The `Box::new` function creates a `Box<T>` (specifically `Box<int>` in this\n+The `Box::new` function creates a `Box<T>` (specifically `Box<i32>` in this\n case) by allocating a small segment of memory on the heap with enough space to\n-fit an `int`. But where in the code is the box deallocated? We said before that\n+fit an `i32`. But where in the code is the box deallocated? We said before that\n we must have a deallocation for each allocation. Rust handles this for you. It\n knows that our handle, `x`, is the owning reference to our box. Rust knows that\n `x` will go out of scope at the end of the block, and so it inserts a call to\n@@ -103,12 +103,12 @@ to a function? Let's look at some code:\n ```rust\n # use std::boxed::Box;\n fn main() {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     add_one(x);\n }\n \n-fn add_one(mut num: Box<int>) {\n+fn add_one(mut num: Box<i32>) {\n     *num += 1;\n }\n ```\n@@ -119,14 +119,14 @@ code, where we print out the value of `x`:\n ```{rust,ignore}\n # use std::boxed::Box;\n fn main() {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     add_one(x);\n \n     println!(\"{}\", x);\n }\n \n-fn add_one(mut num: Box<int>) {\n+fn add_one(mut num: Box<i32>) {\n     *num += 1;\n }\n ```\n@@ -153,14 +153,14 @@ box:\n ```rust\n # use std::boxed::Box;\n fn main() {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     let y = add_one(x);\n \n     println!(\"{}\", y);\n }\n \n-fn add_one(mut num: Box<int>) -> Box<int> {\n+fn add_one(mut num: Box<i32>) -> Box<i32> {\n     *num += 1;\n \n     num\n@@ -179,7 +179,7 @@ to something another handle owns. It's called *borrowing*, and it's done with\n Here's the current state of our `add_one` function:\n \n ```rust\n-fn add_one(mut num: Box<int>) -> Box<int> {\n+fn add_one(mut num: Box<i32>) -> Box<i32> {\n     *num += 1;\n \n     num\n@@ -199,12 +199,12 @@ period. This is also called *borrowing*. Here's a version of `add_one` which\n borrows its argument rather than taking ownership:\n \n ```rust\n-fn add_one(num: &mut int) {\n+fn add_one(num: &mut i32) {\n     *num += 1;\n }\n ```\n \n-This function borrows an `int` from its caller, and then increments it. When\n+This function borrows an `i32` from its caller, and then increments it. When\n the function is over, and `num` goes out of scope, the borrow is over.\n \n # Lifetimes\n@@ -225,10 +225,10 @@ To fix this, we have to make sure that step four never happens after step\n three. The ownership system in Rust does this through a concept called\n *lifetimes*, which describe the scope that a reference is valid for.\n \n-Let's look at that function which borrows an `int` again:\n+Let's look at that function which borrows an `i32` again:\n \n ```rust\n-fn add_one(num: &int) -> int {\n+fn add_one(num: &i32) -> i32 {\n     *num + 1\n }\n ```\n@@ -239,7 +239,7 @@ cover the others later. Without eliding the lifetimes, `add_one` looks like\n this:\n \n ```rust\n-fn add_one<'a>(num: &'a int) -> int {\n+fn add_one<'a>(num: &'a i32) -> i32 {\n     *num + 1\n }\n ```\n@@ -262,22 +262,22 @@ fn add_two<'a, 'b>(...)\n Then in our parameter list, we use the lifetimes we've named:\n \n ```{rust,ignore}\n-...(num: &'a int) -> ...\n+...(num: &'a i32) -> ...\n ```\n \n-If you compare `&int` to `&'a int`, they're the same, it's just that the\n-lifetime `'a` has snuck in between the `&` and the `int`. We read `&int` as \"a\n-reference to an int\" and `&'a int` as \"a reference to an int with the lifetime 'a.'\"\n+If you compare `&i32` to `&'a i32`, they're the same, it's just that the\n+lifetime `'a` has snuck in between the `&` and the `i32`. We read `&i32` as \"a\n+reference to an i32\" and `&'a i32` as \"a reference to an i32 with the lifetime 'a.'\"\n \n Why do lifetimes matter? Well, for example, here's some code:\n \n ```rust\n struct Foo<'a> {\n-    x: &'a int,\n+    x: &'a i32,\n }\n \n fn main() {\n-    let y = &5i; // this is the same as `let _y = 5; let y = &_y;\n+    let y = &5; // this is the same as `let _y = 5; let y = &_y;\n     let f = Foo { x: y };\n \n     println!(\"{}\", f.x);\n@@ -288,20 +288,20 @@ As you can see, `struct`s can also have lifetimes. In a similar way to functions\n \n ```{rust}\n struct Foo<'a> {\n-# x: &'a int,\n+# x: &'a i32,\n # }\n ```\n \n declares a lifetime, and\n \n ```rust\n # struct Foo<'a> {\n-x: &'a int,\n+x: &'a i32,\n # }\n ```\n \n uses it. So why do we need a lifetime here? We need to ensure that any reference\n-to a `Foo` cannot outlive the reference to an `int` it contains.\n+to a `Foo` cannot outlive the reference to an `i32` it contains.\n \n ## Thinking in scopes\n \n@@ -310,7 +310,7 @@ valid for. For example:\n \n ```rust\n fn main() {\n-    let y = &5i;    // -+ y goes into scope\n+    let y = &5;    // -+ y goes into scope\n                     //  |\n     // stuff        //  |\n                     //  |\n@@ -321,11 +321,11 @@ Adding in our `Foo`:\n \n ```rust\n struct Foo<'a> {\n-    x: &'a int,\n+    x: &'a i32,\n }\n \n fn main() {\n-    let y = &5i;          // -+ y goes into scope\n+    let y = &5;          // -+ y goes into scope\n     let f = Foo { x: y }; // -+ f goes into scope\n     // stuff              //  |\n                           //  |\n@@ -337,14 +337,14 @@ This code won't work:\n \n ```{rust,ignore}\n struct Foo<'a> {\n-    x: &'a int,\n+    x: &'a i32,\n }\n \n fn main() {\n     let x;                    // -+ x goes into scope\n                               //  |\n     {                         //  |\n-        let y = &5i;          // ---+ y goes into scope\n+        let y = &5;          // ---+ y goes into scope\n         let f = Foo { x: y }; // ---+ f goes into scope\n         x = &f.x;             //  | | error here\n     }                         // ---+ f and y go out of scope\n@@ -375,12 +375,12 @@ alive: they are baked into the data segment of the final binary. Another\n example are globals:\n \n ```rust\n-static FOO: int = 5i;\n-let x: &'static int = &FOO;\n+static FOO: i32 = 5;\n+let x: &'static i32 = &FOO;\n ```\n \n-This adds an `int` to the data segment of the binary, and FOO is a reference to\n-it.\n+This adds an `i32` to the data segment of the binary, and `FOO` is a reference\n+to it.\n \n # Shared Ownership\n \n@@ -395,7 +395,7 @@ struct Car {\n }\n \n struct Wheel {\n-    size: int,\n+    size: i32,\n     owner: Car,\n }\n \n@@ -431,7 +431,7 @@ struct Car {\n }\n \n struct Wheel {\n-    size: int,\n+    size: i32,\n     owner: Rc<Car>,\n }\n \n@@ -504,15 +504,15 @@ what the elided lifetimes are expand to:\n fn print(s: &str);                                      // elided\n fn print<'a>(s: &'a str);                               // expanded\n \n-fn debug(lvl: uint, s: &str);                           // elided\n-fn debug<'a>(lvl: uint, s: &'a str);                    // expanded\n+fn debug(lvl: u32, s: &str);                           // elided\n+fn debug<'a>(lvl: u32, s: &'a str);                    // expanded\n \n // In the preceeding example, `lvl` doesn't need a lifetime because it's not a\n // reference (`&`). Only things relating to references (such as a `struct`\n // which contains a reference) need lifetimes.\n \n-fn substr(s: &str, until: uint) -> &str;                // elided\n-fn substr<'a>(s: &'a str, until: uint) -> &'a str;      // expanded\n+fn substr(s: &str, until: u32) -> &str;                // elided\n+fn substr<'a>(s: &'a str, until: u32) -> &'a str;      // expanded\n \n fn get_str() -> &str;                                   // ILLEGAL, no inputs\n "}]}