{"sha": "eced501226bf8dc9f6d0a4cbe708da6166942fd9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZWQ1MDEyMjZiZjhkYzlmNmQwYTRjYmU3MDhkYTYxNjY5NDJmZDk=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-02-06T06:07:06Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-02-08T02:20:43Z"}, "message": "allow generating drop glue without the TyDesc\n\nReflection is now the only user of type descriptors. Uses of drop glue\nno longer cause a type descriptor to be generated.", "tree": {"sha": "07a72ca3c7c48b7f48caca29c3a8713a0d6d7658", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07a72ca3c7c48b7f48caca29c3a8713a0d6d7658"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eced501226bf8dc9f6d0a4cbe708da6166942fd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eced501226bf8dc9f6d0a4cbe708da6166942fd9", "html_url": "https://github.com/rust-lang/rust/commit/eced501226bf8dc9f6d0a4cbe708da6166942fd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eced501226bf8dc9f6d0a4cbe708da6166942fd9/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "url": "https://api.github.com/repos/rust-lang/rust/commits/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033", "html_url": "https://github.com/rust-lang/rust/commit/940d1ae2f3b1cba8cfd858ab3a54d6408b53b033"}], "stats": {"total": 486, "additions": 216, "deletions": 270}, "files": [{"sha": "856540989df55fbc470207b54cafccf902b0fac4", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=eced501226bf8dc9f6d0a4cbe708da6166942fd9", "patch": "@@ -214,8 +214,7 @@ impl Arena {\n     #[inline]\n     fn alloc_pod<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n         unsafe {\n-            let tydesc = get_tydesc::<T>();\n-            let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n+            let ptr = self.alloc_pod_inner(mem::size_of::<T>(), mem::min_align_of::<T>());\n             let ptr: *mut T = transmute(ptr);\n             intrinsics::move_val_init(&mut (*ptr), op());\n             return transmute(ptr);\n@@ -272,7 +271,7 @@ impl Arena {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n-                self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n+                self.alloc_nonpod_inner(mem::size_of::<T>(), mem::min_align_of::<T>());\n             let ty_ptr: *mut uint = transmute(ty_ptr);\n             let ptr: *mut T = transmute(ptr);\n             // Write in our tydesc along with a bit indicating that it"}, {"sha": "39e0ca176eb0b5b02e5c6e0d30cbf246b7dcb6c9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=eced501226bf8dc9f6d0a4cbe708da6166942fd9", "patch": "@@ -376,12 +376,8 @@ pub fn malloc_raw_dyn<'a>(\n         let llty = type_of(ccx, box_ptr_ty);\n         let llalign = C_uint(ccx, llalign_of_min(ccx, llty) as uint);\n \n-        // Get the tydesc for the body:\n-        let static_ti = get_tydesc(ccx, t);\n-        glue::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n-\n         // Allocate space:\n-        let drop_glue = static_ti.drop_glue.get().unwrap();\n+        let drop_glue = glue::get_drop_glue(ccx, t);\n         let r = callee::trans_lang_call(\n             bcx,\n             langcall,"}, {"sha": "7ee77e4c0d6f56db2748d18e326e696bfa171cea", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=eced501226bf8dc9f6d0a4cbe708da6166942fd9", "patch": "@@ -114,7 +114,6 @@ pub struct tydesc_info {\n     size: ValueRef,\n     align: ValueRef,\n     name: ValueRef,\n-    drop_glue: Cell<Option<ValueRef>>,\n     visit_glue: Cell<Option<ValueRef>>,\n }\n "}, {"sha": "95875a01401826a267b0851f9ed7805fe30b8c36", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 131, "deletions": 129, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=eced501226bf8dc9f6d0a4cbe708da6166942fd9", "patch": "@@ -36,83 +36,84 @@ use syntax::ast;\n use syntax::parse::token::InternedString;\n \n pub struct CrateContext {\n-     sess: session::Session,\n-     llmod: ModuleRef,\n-     llcx: ContextRef,\n-     metadata_llmod: ModuleRef,\n-     td: TargetData,\n-     tn: TypeNames,\n-     externs: RefCell<ExternMap>,\n-     intrinsics: HashMap<&'static str, ValueRef>,\n-     item_vals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n-     exp_map2: resolve::ExportMap2,\n-     reachable: @RefCell<HashSet<ast::NodeId>>,\n-     item_symbols: RefCell<HashMap<ast::NodeId, ~str>>,\n-     link_meta: LinkMeta,\n-     tydescs: RefCell<HashMap<ty::t, @tydesc_info>>,\n-     // Set when running emit_tydescs to enforce that no more tydescs are\n-     // created.\n-     finished_tydescs: Cell<bool>,\n-     // Track mapping of external ids to local items imported for inlining\n-     external: RefCell<HashMap<ast::DefId, Option<ast::NodeId>>>,\n-     // Backwards version of the `external` map (inlined items to where they\n-     // came from)\n-     external_srcs: RefCell<HashMap<ast::NodeId, ast::DefId>>,\n-     // A set of static items which cannot be inlined into other crates. This\n-     // will pevent in IIItem() structures from being encoded into the metadata\n-     // that is generated\n-     non_inlineable_statics: RefCell<HashSet<ast::NodeId>>,\n-     // Cache instances of monomorphized functions\n-     monomorphized: RefCell<HashMap<mono_id, ValueRef>>,\n-     monomorphizing: RefCell<HashMap<ast::DefId, uint>>,\n-     // Cache generated vtables\n-     vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n-     // Cache of constant strings,\n-     const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n+    sess: session::Session,\n+    llmod: ModuleRef,\n+    llcx: ContextRef,\n+    metadata_llmod: ModuleRef,\n+    td: TargetData,\n+    tn: TypeNames,\n+    externs: RefCell<ExternMap>,\n+    intrinsics: HashMap<&'static str, ValueRef>,\n+    item_vals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    exp_map2: resolve::ExportMap2,\n+    reachable: @RefCell<HashSet<ast::NodeId>>,\n+    item_symbols: RefCell<HashMap<ast::NodeId, ~str>>,\n+    link_meta: LinkMeta,\n+    drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n+    tydescs: RefCell<HashMap<ty::t, @tydesc_info>>,\n+    // Set when running emit_tydescs to enforce that no more tydescs are\n+    // created.\n+    finished_tydescs: Cell<bool>,\n+    // Track mapping of external ids to local items imported for inlining\n+    external: RefCell<HashMap<ast::DefId, Option<ast::NodeId>>>,\n+    // Backwards version of the `external` map (inlined items to where they\n+    // came from)\n+    external_srcs: RefCell<HashMap<ast::NodeId, ast::DefId>>,\n+    // A set of static items which cannot be inlined into other crates. This\n+    // will pevent in IIItem() structures from being encoded into the metadata\n+    // that is generated\n+    non_inlineable_statics: RefCell<HashSet<ast::NodeId>>,\n+    // Cache instances of monomorphized functions\n+    monomorphized: RefCell<HashMap<mono_id, ValueRef>>,\n+    monomorphizing: RefCell<HashMap<ast::DefId, uint>>,\n+    // Cache generated vtables\n+    vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n+    // Cache of constant strings,\n+    const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n-     // Reverse-direction for const ptrs cast from globals.\n-     // Key is an int, cast from a ValueRef holding a *T,\n-     // Val is a ValueRef holding a *[T].\n-     //\n-     // Needed because LLVM loses pointer->pointee association\n-     // when we ptrcast, and we have to ptrcast during translation\n-     // of a [T] const because we form a slice, a [*T,int] pair, not\n-     // a pointer to an LLVM array type.\n-     const_globals: RefCell<HashMap<int, ValueRef>>,\n+    // Reverse-direction for const ptrs cast from globals.\n+    // Key is an int, cast from a ValueRef holding a *T,\n+    // Val is a ValueRef holding a *[T].\n+    //\n+    // Needed because LLVM loses pointer->pointee association\n+    // when we ptrcast, and we have to ptrcast during translation\n+    // of a [T] const because we form a slice, a [*T,int] pair, not\n+    // a pointer to an LLVM array type.\n+    const_globals: RefCell<HashMap<int, ValueRef>>,\n \n-     // Cache of emitted const values\n-     const_values: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    // Cache of emitted const values\n+    const_values: RefCell<HashMap<ast::NodeId, ValueRef>>,\n \n-     // Cache of external const values\n-     extern_const_values: RefCell<HashMap<ast::DefId, ValueRef>>,\n+    // Cache of external const values\n+    extern_const_values: RefCell<HashMap<ast::DefId, ValueRef>>,\n \n-     impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n+    impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n \n-     // Cache of closure wrappers for bare fn's.\n-     closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n+    // Cache of closure wrappers for bare fn's.\n+    closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n \n-     module_data: RefCell<HashMap<~str, ValueRef>>,\n-     lltypes: RefCell<HashMap<ty::t, Type>>,\n-     llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n-     adt_reprs: RefCell<HashMap<ty::t, @adt::Repr>>,\n-     symbol_hasher: RefCell<Sha256>,\n-     type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n-     all_llvm_symbols: RefCell<HashSet<~str>>,\n-     tcx: ty::ctxt,\n-     maps: astencode::Maps,\n-     stats: @Stats,\n-     tydesc_type: Type,\n-     int_type: Type,\n-     opaque_vec_type: Type,\n-     builder: BuilderRef_res,\n-     crate_map: ValueRef,\n-     crate_map_name: ~str,\n-     // Set when at least one function uses GC. Needed so that\n-     // decl_gc_metadata knows whether to link to the module metadata, which\n-     // is not emitted by LLVM's GC pass when no functions use GC.\n-     uses_gc: bool,\n-     dbg_cx: Option<debuginfo::CrateDebugContext>,\n-     do_not_commit_warning_issued: Cell<bool>,\n+    module_data: RefCell<HashMap<~str, ValueRef>>,\n+    lltypes: RefCell<HashMap<ty::t, Type>>,\n+    llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n+    adt_reprs: RefCell<HashMap<ty::t, @adt::Repr>>,\n+    symbol_hasher: RefCell<Sha256>,\n+    type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n+    all_llvm_symbols: RefCell<HashSet<~str>>,\n+    tcx: ty::ctxt,\n+    maps: astencode::Maps,\n+    stats: @Stats,\n+    tydesc_type: Type,\n+    int_type: Type,\n+    opaque_vec_type: Type,\n+    builder: BuilderRef_res,\n+    crate_map: ValueRef,\n+    crate_map_name: ~str,\n+    // Set when at least one function uses GC. Needed so that\n+    // decl_gc_metadata knows whether to link to the module metadata, which\n+    // is not emitted by LLVM's GC pass when no functions use GC.\n+    uses_gc: bool,\n+    dbg_cx: Option<debuginfo::CrateDebugContext>,\n+    do_not_commit_warning_issued: Cell<bool>,\n }\n \n impl CrateContext {\n@@ -175,64 +176,65 @@ impl CrateContext {\n             }\n \n             CrateContext {\n-                  sess: sess,\n-                  llmod: llmod,\n-                  llcx: llcx,\n-                  metadata_llmod: metadata_llmod,\n-                  td: td,\n-                  tn: tn,\n-                  externs: RefCell::new(HashMap::new()),\n-                  intrinsics: intrinsics,\n-                  item_vals: RefCell::new(HashMap::new()),\n-                  exp_map2: emap2,\n-                  reachable: reachable,\n-                  item_symbols: RefCell::new(HashMap::new()),\n-                  link_meta: link_meta,\n-                  tydescs: RefCell::new(HashMap::new()),\n-                  finished_tydescs: Cell::new(false),\n-                  external: RefCell::new(HashMap::new()),\n-                  external_srcs: RefCell::new(HashMap::new()),\n-                  non_inlineable_statics: RefCell::new(HashSet::new()),\n-                  monomorphized: RefCell::new(HashMap::new()),\n-                  monomorphizing: RefCell::new(HashMap::new()),\n-                  vtables: RefCell::new(HashMap::new()),\n-                  const_cstr_cache: RefCell::new(HashMap::new()),\n-                  const_globals: RefCell::new(HashMap::new()),\n-                  const_values: RefCell::new(HashMap::new()),\n-                  extern_const_values: RefCell::new(HashMap::new()),\n-                  impl_method_cache: RefCell::new(HashMap::new()),\n-                  closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n-                  module_data: RefCell::new(HashMap::new()),\n-                  lltypes: RefCell::new(HashMap::new()),\n-                  llsizingtypes: RefCell::new(HashMap::new()),\n-                  adt_reprs: RefCell::new(HashMap::new()),\n-                  symbol_hasher: RefCell::new(symbol_hasher),\n-                  type_hashcodes: RefCell::new(HashMap::new()),\n-                  all_llvm_symbols: RefCell::new(HashSet::new()),\n-                  tcx: tcx,\n-                  maps: maps,\n-                  stats: @Stats {\n-                    n_static_tydescs: Cell::new(0u),\n-                    n_glues_created: Cell::new(0u),\n-                    n_null_glues: Cell::new(0u),\n-                    n_real_glues: Cell::new(0u),\n-                    n_fns: Cell::new(0u),\n-                    n_monos: Cell::new(0u),\n-                    n_inlines: Cell::new(0u),\n-                    n_closures: Cell::new(0u),\n-                    n_llvm_insns: Cell::new(0u),\n-                    llvm_insns: RefCell::new(HashMap::new()),\n-                    fn_stats: RefCell::new(~[]),\n-                  },\n-                  tydesc_type: tydesc_type,\n-                  int_type: int_type,\n-                  opaque_vec_type: opaque_vec_type,\n-                  builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                  crate_map: crate_map,\n-                  crate_map_name: crate_map_name,\n-                  uses_gc: false,\n-                  dbg_cx: dbg_cx,\n-                  do_not_commit_warning_issued: Cell::new(false),\n+                 sess: sess,\n+                 llmod: llmod,\n+                 llcx: llcx,\n+                 metadata_llmod: metadata_llmod,\n+                 td: td,\n+                 tn: tn,\n+                 externs: RefCell::new(HashMap::new()),\n+                 intrinsics: intrinsics,\n+                 item_vals: RefCell::new(HashMap::new()),\n+                 exp_map2: emap2,\n+                 reachable: reachable,\n+                 item_symbols: RefCell::new(HashMap::new()),\n+                 link_meta: link_meta,\n+                 drop_glues: RefCell::new(HashMap::new()),\n+                 tydescs: RefCell::new(HashMap::new()),\n+                 finished_tydescs: Cell::new(false),\n+                 external: RefCell::new(HashMap::new()),\n+                 external_srcs: RefCell::new(HashMap::new()),\n+                 non_inlineable_statics: RefCell::new(HashSet::new()),\n+                 monomorphized: RefCell::new(HashMap::new()),\n+                 monomorphizing: RefCell::new(HashMap::new()),\n+                 vtables: RefCell::new(HashMap::new()),\n+                 const_cstr_cache: RefCell::new(HashMap::new()),\n+                 const_globals: RefCell::new(HashMap::new()),\n+                 const_values: RefCell::new(HashMap::new()),\n+                 extern_const_values: RefCell::new(HashMap::new()),\n+                 impl_method_cache: RefCell::new(HashMap::new()),\n+                 closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n+                 module_data: RefCell::new(HashMap::new()),\n+                 lltypes: RefCell::new(HashMap::new()),\n+                 llsizingtypes: RefCell::new(HashMap::new()),\n+                 adt_reprs: RefCell::new(HashMap::new()),\n+                 symbol_hasher: RefCell::new(symbol_hasher),\n+                 type_hashcodes: RefCell::new(HashMap::new()),\n+                 all_llvm_symbols: RefCell::new(HashSet::new()),\n+                 tcx: tcx,\n+                 maps: maps,\n+                 stats: @Stats {\n+                   n_static_tydescs: Cell::new(0u),\n+                   n_glues_created: Cell::new(0u),\n+                   n_null_glues: Cell::new(0u),\n+                   n_real_glues: Cell::new(0u),\n+                   n_fns: Cell::new(0u),\n+                   n_monos: Cell::new(0u),\n+                   n_inlines: Cell::new(0u),\n+                   n_closures: Cell::new(0u),\n+                   n_llvm_insns: Cell::new(0u),\n+                   llvm_insns: RefCell::new(HashMap::new()),\n+                   fn_stats: RefCell::new(~[]),\n+                 },\n+                 tydesc_type: tydesc_type,\n+                 int_type: int_type,\n+                 opaque_vec_type: opaque_vec_type,\n+                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n+                 crate_map: crate_map,\n+                 crate_map_name: crate_map_name,\n+                 uses_gc: false,\n+                 dbg_cx: dbg_cx,\n+                 do_not_commit_warning_issued: Cell::new(false),\n             }\n         }\n     }"}, {"sha": "1b9605a172cb696032395732ef09707b0deb2113", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 74, "deletions": 120, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=eced501226bf8dc9f6d0a4cbe708da6166942fd9", "patch": "@@ -73,14 +73,49 @@ pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     }\n }\n \n-pub fn drop_ty<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n+    let tcx = ccx.tcx;\n+    if !ty::type_needs_drop(tcx, t) {\n+        return ty::mk_i8();\n+    }\n+    match ty::get(t).sty {\n+        ty::ty_box(typ) if !ty::type_needs_drop(tcx, typ) =>\n+            ty::mk_box(tcx, ty::mk_i8()),\n+\n+        ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ) => {\n+            let llty = sizing_type_of(ccx, typ);\n+            // Unique boxes do not allocate for zero-size types. The standard library may assume\n+            // that `free` is never called on the pointer returned for `~ZeroSizeType`.\n+            if llsize_of_alloc(ccx, llty) == 0 {\n+                ty::mk_i8()\n+            } else {\n+                ty::mk_uniq(tcx, ty::mk_i8())\n+            }\n+        }\n+\n+        ty::ty_vec(mt, ty::vstore_uniq) if !ty::type_needs_drop(tcx, mt.ty) =>\n+            ty::mk_uniq(tcx, ty::mk_i8()),\n+\n+        _ => t\n+    }\n+}\n+\n+pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                -> &'a Block<'a> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"drop_ty\");\n-    if ty::type_needs_drop(cx.tcx(), t) {\n-        return call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n+    let ccx = bcx.ccx();\n+    if ty::type_needs_drop(bcx.tcx(), t) {\n+        let glue = get_drop_glue(ccx, t);\n+        let glue_type = get_drop_glue_type(ccx, t);\n+        let ptr = if glue_type != t {\n+            PointerCast(bcx, v, type_of(ccx, glue_type).ptr_to())\n+        } else {\n+            v\n+        };\n+        Call(bcx, glue, [ptr], []);\n     }\n-    return cx;\n+    bcx\n }\n \n pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n@@ -91,95 +126,49 @@ pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     drop_ty(bcx, vp, t)\n }\n \n-pub fn lazily_emit_all_tydesc_glue(ccx: @CrateContext,\n-                                   static_ti: @tydesc_info) {\n-    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n-    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_visit_glue, static_ti);\n-}\n-\n-fn get_glue_type(ccx: &CrateContext, field: uint, t: ty::t) -> ty::t {\n-    let tcx = ccx.tcx;\n-    if field == abi::tydesc_field_drop_glue {\n-        if !ty::type_needs_drop(tcx, t) {\n-            return ty::mk_i8();\n-        }\n-        match ty::get(t).sty {\n-            ty::ty_box(typ) if !ty::type_needs_drop(tcx, typ) =>\n-                return ty::mk_box(tcx, ty::mk_i8()),\n-\n-            ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ) => {\n-                let llty = sizing_type_of(ccx, typ);\n-                // Unique boxes do not allocate for zero-size types. The standard library may assume\n-                // that `free` is never called on the pointer returned for `~ZeroSizeType`.\n-                if llsize_of_alloc(ccx, llty) == 0 {\n-                    return ty::mk_i8();\n-                } else {\n-                    return ty::mk_uniq(tcx, ty::mk_i8());\n-                }\n-            }\n-\n-            ty::ty_vec(mt, ty::vstore_uniq) if !ty::type_needs_drop(tcx, mt.ty) =>\n-                return ty::mk_uniq(tcx, ty::mk_i8()),\n-\n-            _ => {}\n+pub fn get_drop_glue(ccx: @CrateContext, t: ty::t) -> ValueRef {\n+    let t = get_drop_glue_type(ccx, t);\n+    {\n+        let drop_glues = ccx.drop_glues.borrow();\n+        match drop_glues.get().find(&t) {\n+            Some(&glue) => return glue,\n+            _ => { }\n         }\n     }\n \n-    t\n-}\n+    let llfnty = Type::glue_fn(type_of(ccx, t).ptr_to());\n+    let glue = declare_generic_glue(ccx, t, llfnty, \"drop\");\n \n-pub fn lazily_emit_tydesc_glue(ccx: @CrateContext, field: uint, ti: @tydesc_info) {\n-    let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n+    {\n+        let mut drop_glues = ccx.drop_glues.borrow_mut();\n+        drop_glues.get().insert(t, glue);\n+    }\n \n-    let simpl = get_glue_type(ccx, field, ti.ty);\n-    if simpl != ti.ty {\n-        let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n-        let simpl_ti = get_tydesc(ccx, simpl);\n-        lazily_emit_tydesc_glue(ccx, field, simpl_ti);\n+    make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n \n-        if field == abi::tydesc_field_drop_glue {\n-            ti.drop_glue.set(simpl_ti.drop_glue.get());\n-        } else if field == abi::tydesc_field_visit_glue {\n-            ti.visit_glue.set(simpl_ti.visit_glue.get());\n-        }\n+    glue\n+}\n \n-        return;\n-    }\n+pub fn lazily_emit_visit_glue(ccx: @CrateContext, ti: @tydesc_info) {\n+    let _icx = push_ctxt(\"lazily_emit_visit_glue\");\n \n     let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n \n-    if field == abi::tydesc_field_drop_glue {\n-        match ti.drop_glue.get() {\n-          Some(_) => (),\n-          None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue DROP {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n-            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"drop\");\n-            ti.drop_glue.set(Some(glue_fn));\n-            make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, \"drop\");\n-            debug!(\"--- lazily_emit_tydesc_glue DROP {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n-          }\n-        }\n-    } else if field == abi::tydesc_field_visit_glue {\n-        match ti.visit_glue.get() {\n-          Some(_) => (),\n-          None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+    match ti.visit_glue.get() {\n+        Some(_) => (),\n+        None => {\n+            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n-            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n-          }\n+            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx, ti.ty));\n         }\n     }\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n-                             field: uint, static_ti: Option<@tydesc_info>) {\n+pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n+                       static_ti: Option<@tydesc_info>) {\n     let _icx = push_ctxt(\"call_tydesc_glue_full\");\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n@@ -189,37 +178,23 @@ pub fn call_tydesc_glue_full(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n     let static_glue_fn = match static_ti {\n         None => None,\n         Some(sti) => {\n-            lazily_emit_tydesc_glue(ccx, field, sti);\n-            if field == abi::tydesc_field_drop_glue {\n-                sti.drop_glue.get()\n-            } else if field == abi::tydesc_field_visit_glue {\n-                sti.visit_glue.get()\n-            } else {\n-                None\n-            }\n+            lazily_emit_visit_glue(ccx, sti);\n+            sti.visit_glue.get()\n         }\n     };\n \n-    // When static type info is available, avoid casting parameter unless the\n-    // glue is using a simplified type, because the function already has the\n-    // right type. Otherwise cast to generic pointer.\n+    // When static type info is available, avoid casting to a generic pointer.\n     let llrawptr = if static_glue_fn.is_none() {\n         PointerCast(bcx, v, Type::i8p())\n     } else {\n-        let ty = static_ti.unwrap().ty;\n-        let simpl = get_glue_type(ccx, field, ty);\n-        if simpl != ty {\n-            PointerCast(bcx, v, type_of(ccx, simpl).ptr_to())\n-        } else {\n-            v\n-        }\n+        v\n     };\n \n     let llfn = {\n         match static_glue_fn {\n             None => {\n                 // Select out the glue function to call from the tydesc\n-                let llfnptr = GEPi(bcx, tydesc, [0u, field]);\n+                let llfnptr = GEPi(bcx, tydesc, [0u, abi::tydesc_field_visit_glue]);\n                 Load(bcx, llfnptr)\n             }\n             Some(sgf) => sgf\n@@ -229,15 +204,6 @@ pub fn call_tydesc_glue_full(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n     Call(bcx, llfn, [llrawptr], []);\n }\n \n-// See [Note-arg-mode]\n-fn call_tydesc_glue<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t, field: uint)\n-                    -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"call_tydesc_glue\");\n-    let ti = get_tydesc(cx.ccx(), t);\n-    call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n-    cx\n-}\n-\n fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                    -> &'a Block<'a> {\n     let _icx = push_ctxt(\"make_visit_glue\");\n@@ -462,7 +428,6 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n         size: llsize,\n         align: llalign,\n         name: ty_name,\n-        drop_glue: Cell::new(None),\n         visit_glue: Cell::new(None),\n     };\n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n@@ -514,7 +479,7 @@ fn make_generic_glue(ccx: @CrateContext,\n     llfn\n }\n \n-pub fn emit_tydescs(ccx: &CrateContext) {\n+pub fn emit_tydescs(ccx: @CrateContext) {\n     let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs.set(true);\n@@ -527,21 +492,10 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n         // before being put into the tydesc because we only have a singleton\n         // tydesc type. Then we'll recast each function to its real type when\n         // calling it.\n-        let drop_glue =\n-            match ti.drop_glue.get() {\n-              None => {\n-                  ccx.stats.n_null_glues.set(ccx.stats.n_null_glues.get() +\n-                                             1u);\n-                  C_null(glue_fn_ty)\n-              }\n-              Some(v) => {\n-                unsafe {\n-                    ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() +\n-                                               1);\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n-                }\n-              }\n-            };\n+        let drop_glue = unsafe {\n+            llvm::LLVMConstPointerCast(get_drop_glue(ccx, ti.ty), glue_fn_ty.to_ref())\n+        };\n+        ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() + 1);\n         let visit_glue =\n             match ti.visit_glue.get() {\n               None => {"}, {"sha": "234b8072decc3eeeeaca2cd5287ef42504c0258a", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=eced501226bf8dc9f6d0a4cbe708da6166942fd9", "patch": "@@ -11,7 +11,6 @@\n #[allow(non_uppercase_pattern_statics)];\n \n use arena::TypedArena;\n-use back::abi;\n use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n use lib::llvm::{ValueRef, Pointer, Array, Struct};\n use lib;\n@@ -326,7 +325,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         \"get_tydesc\" => {\n             let tp_ty = substs.tys[0];\n             let static_ti = get_tydesc(ccx, tp_ty);\n-            glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n+            glue::lazily_emit_visit_glue(ccx, static_ti);\n \n             // FIXME (#3730): ideally this shouldn't need a cast,\n             // but there's a circularity between translating rust types to llvm\n@@ -459,8 +458,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let td = get_param(decl, first_real_arg);\n             let visitor = get_param(decl, first_real_arg + 1u);\n             let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n-            glue::call_tydesc_glue_full(bcx, visitor, td,\n-                                        abi::tydesc_field_visit_glue, None);\n+            glue::call_visit_glue(bcx, visitor, td, None);\n             RetVoid(bcx);\n         }\n         \"morestack_addr\" => {"}, {"sha": "4a1ba7b22ac5432a3089b6489447c8523f0b0428", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=eced501226bf8dc9f6d0a4cbe708da6166942fd9", "patch": "@@ -479,11 +479,9 @@ pub fn get_vtable(bcx: &Block,\n         }\n     });\n \n-    // Generate a type descriptor for the vtable.\n-    let tydesc = get_tydesc(ccx, self_ty);\n-    glue::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, tydesc);\n-\n-    let vtable = make_vtable(ccx, tydesc, methods);\n+    // Generate a destructor for the vtable.\n+    let drop_glue = glue::get_drop_glue(ccx, self_ty);\n+    let vtable = make_vtable(ccx, drop_glue, methods);\n \n     let mut vtables = ccx.vtables.borrow_mut();\n     vtables.get().insert(hash_id, vtable);\n@@ -492,13 +490,13 @@ pub fn get_vtable(bcx: &Block,\n \n /// Helper function to declare and initialize the vtable.\n pub fn make_vtable(ccx: &CrateContext,\n-                   tydesc: &tydesc_info,\n+                   drop_glue: ValueRef,\n                    ptrs: &[ValueRef])\n                    -> ValueRef {\n     unsafe {\n         let _icx = push_ctxt(\"meth::make_vtable\");\n \n-        let mut components = ~[tydesc.drop_glue.get().unwrap()];\n+        let mut components = ~[drop_glue];\n         for &ptr in ptrs.iter() {\n             components.push(ptr)\n         }"}, {"sha": "8c2047a5fc56c2813d16c38054ad9e29818e3d1d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eced501226bf8dc9f6d0a4cbe708da6166942fd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=eced501226bf8dc9f6d0a4cbe708da6166942fd9", "patch": "@@ -81,7 +81,7 @@ impl<'a> Reflector<'a> {\n     pub fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n         let bcx = self.bcx;\n         let static_ti = get_tydesc(bcx.ccx(), t);\n-        glue::lazily_emit_all_tydesc_glue(bcx.ccx(), static_ti);\n+        glue::lazily_emit_visit_glue(bcx.ccx(), static_ti);\n         PointerCast(bcx, static_ti.tydesc, self.tydesc_ty.ptr_to())\n     }\n "}]}