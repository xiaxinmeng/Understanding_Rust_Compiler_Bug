{"sha": "29d7147dda7f7fbca1341a7cad2f67107db49863", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZDcxNDdkZGE3ZjdmYmNhMTM0MWE3Y2FkMmY2NzEwN2RiNDk4NjM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-11T20:30:35Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-23T07:19:25Z"}, "message": "Review fixes", "tree": {"sha": "56e8be758cf8922175f7fe118a56edc34cee51c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56e8be758cf8922175f7fe118a56edc34cee51c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29d7147dda7f7fbca1341a7cad2f67107db49863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29d7147dda7f7fbca1341a7cad2f67107db49863", "html_url": "https://github.com/rust-lang/rust/commit/29d7147dda7f7fbca1341a7cad2f67107db49863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29d7147dda7f7fbca1341a7cad2f67107db49863/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "950c2d813571ad98730a7f4b1b7c0b679315bd69", "url": "https://api.github.com/repos/rust-lang/rust/commits/950c2d813571ad98730a7f4b1b7c0b679315bd69", "html_url": "https://github.com/rust-lang/rust/commit/950c2d813571ad98730a7f4b1b7c0b679315bd69"}], "stats": {"total": 123, "additions": 86, "deletions": 37}, "files": [{"sha": "c7a20f243b0c199e82302214bc95c41d1406765c", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 86, "deletions": 37, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/29d7147dda7f7fbca1341a7cad2f67107db49863/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d7147dda7f7fbca1341a7cad2f67107db49863/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=29d7147dda7f7fbca1341a7cad2f67107db49863", "patch": "@@ -55,10 +55,9 @@ fn foo(x: Empty) {\n         // empty\n     }\n }\n-\n ```\n \n-but this won't:\n+However, this won't:\n \n ```\n fn foo(x: Option<String>) {\n@@ -71,7 +70,18 @@ fn foo(x: Option<String>) {\n \n E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n-match the input to a match expression. To match against NaN values, you should\n+match the input to a match expression. So, the following will not compile:\n+\n+```\n+const NAN: f32 = 0.0 / 0.0;\n+\n+match number {\n+    NAN => { /* ... */ },\n+    // ...\n+}\n+```\n+\n+To match against NaN values, you should\n instead use the `is_nan()` method in a guard, like so:\n \n ```\n@@ -429,22 +439,20 @@ match 5u32 {\n \"##,\n \n E0038: r####\"\n+Trait objects like `Box<Trait>` can only be constructed when certain\n+requirements are satisfied by the trait in question.\n \n-Trait objects like `Box<Trait>`, can only be constructed when certain\n-requirements are obeyed by the trait in question.\n-\n-Trait objects are a form of dynamic dispatch and use dynamically sized types.\n-So, for a given trait `Trait`, when `Trait` is treated as a type, as in\n-`Box<Trait>`, the inner type is \"unsized\". In such cases the boxed pointer is a\n-\"fat pointer\" and contains an extra pointer to a method table for dynamic\n-dispatch. This design mandates some restrictions on the types of traits that are\n-allowed to be used in trait objects, which are collectively termed as \"object\n-safety\" rules.\n+Trait objects are a form of dynamic dispatch and use a dynamically sized type\n+for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\n+type, as in `Box<Trait>`, the inner type is \"unsized\". In such cases the boxed\n+pointer is a \"fat pointer\" that contains an extra pointer to a table of methods\n+(among other things) for dynamic dispatch. This design mandates some\n+restrictions on the types of traits that are allowed to be used in trait\n+objects, which are collectively termed as \"object safety\" rules.\n \n Attempting to create a trait object for a non object-safe trait will trigger\n this error.\n \n-\n There are various rules:\n \n ### The trait cannot require `Self: Sized`\n@@ -463,7 +471,7 @@ trait Foo where Self: Sized {\n we cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n `Self` would not be `Sized`.\n \n-Generally `Self : Sized` is used to indicate that the trait should not be used\n+Generally, `Self : Sized` is used to indicate that the trait should not be used\n as a trait object. If the trait comes from your own crate, consider removing\n this restriction.\n \n@@ -475,6 +483,7 @@ This happens when a trait has a method like the following:\n trait Trait {\n     fn foo(&self) -> Self;\n }\n+\n impl Trait for String {\n     fn foo(&self) -> Self {\n         \"hi\".to_owned()\n@@ -488,8 +497,11 @@ impl Trait for u8 {\n }\n ```\n \n-In such a case, the compiler cannot predict the return type of `foo()` in a case\n-like the following:\n+(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\n+cause this problem)\n+\n+In such a case, the compiler cannot predict the return type of `foo()` in a\n+situation like the following:\n \n ```\n fn call_foo(x: Box<Trait>) {\n@@ -498,8 +510,10 @@ fn call_foo(x: Box<Trait>) {\n }\n ```\n \n-If the offending method isn't actually being called on the trait object, you can\n-add a `where Self: Sized` bound on the method:\n+If only some methods aren't object-safe, you can add a `where Self: Sized` bound\n+on them to mark them as explicitly unavailable to trait objects. The\n+functionality will still be available to all other implementers, including\n+`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`)\n \n ```\n trait Trait {\n@@ -508,10 +522,10 @@ trait Trait {\n }\n ```\n \n-Now, `foo()` can no longer be called on the trait object, but you will be\n-allowed to call other trait methods and construct the trait objects. With such a\n-bound, one can still call `foo()` on types implementing that trait that aren't\n-behind trait objects.\n+Now, `foo()` can no longer be called on a trait object, but you will now be\n+allowed to make a trait object, and that will be able to call any object-safe\n+methods\". With such a bound, one can still call `foo()` on types implementing\n+that trait that aren't behind trait objects.\n \n ### Method has generic type parameters\n \n@@ -535,10 +549,10 @@ impl Trait for u8 {\n // ...\n ```\n \n-at compile time a table of all implementations of `Trait`, containing pointers\n-to the implementation of `foo()` would be generated.\n+at compile time each implementation of `Trait` will produce a table containing\n+the various methods (and other items) related to the implementation.\n \n-This works fine, but when we the method gains generic parameters, we can have a\n+This works fine, but when the method gains generic parameters, we can have a\n problem.\n \n Usually, generic parameters get _monomorphized_. For example, if I have\n@@ -555,12 +569,14 @@ implementation on-demand. If you call `foo()` with a `bool` parameter, the\n compiler will only generate code for `foo::<bool>()`. When we have additional\n type parameters, the number of monomorphized implementations the compiler\n generates does not grow drastically, since the compiler will only generate an\n-implementation if the function is called with hard substitutions.\n+implementation if the function is called with unparametrized substitutions\n+(i.e., substitutions where none of the substituted types are themselves\n+parametrized).\n \n However, with trait objects we have to make a table containing _every object\n that implements the trait_. Now, if it has type parameters, we need to add\n-implementations for every type that implements the trait, bloating the table\n-quickly.\n+implementations for every type that implements the trait, and there could\n+theoretically be an infinite number of types.\n \n For example, with\n \n@@ -675,13 +691,46 @@ safe, so they are forbidden when specifying supertraits.\n \n There's no easy fix for this, generally code will need to be refactored so that\n you no longer need to derive from `Super<Self>`.\n-\n \"####,\n \n E0079: r##\"\n Enum variants which contain no data can be given a custom integer\n representation. This error indicates that the value provided is not an\n integer literal and is therefore invalid.\n+\n+For example, in the following code,\n+\n+```\n+enum Foo {\n+    Q = \"32\"\n+}\n+```\n+\n+we try to set the representation to a string.\n+\n+There's no general fix for this; if you can work with an integer\n+then just set it to one:\n+\n+```\n+enum Foo {\n+    Q = 32\n+}\n+```\n+\n+however if you actually wanted a mapping between variants\n+and non-integer objects, it may be preferable to use a method with\n+a match instead:\n+\n+```\n+enum Foo { Q }\n+impl Foo {\n+    fn get_str(&self) -> &'static str {\n+        match *self {\n+            Foo::Q => \"32\",\n+        }\n+    }\n+}\n+```\n \"##,\n \n E0080: r##\"\n@@ -704,33 +753,33 @@ https://doc.rust-lang.org/reference.html#ffi-attributes\n \"##,\n \n E0109: r##\"\n-You tried to give a type parameter to a type which doesn't need it. Erroneous\n-code example:\n+You tried to give a type parameter to a type which doesn't need it; for example:\n \n ```\n type X = u32<i32>; // error: type parameters are not allowed on this type\n ```\n \n Please check that you used the correct type and recheck its definition. Perhaps\n it doesn't need the type parameter.\n+\n Example:\n \n ```\n-type X = u32; // ok!\n+type X = u32; // this compiles\n ```\n \"##,\n \n E0110: r##\"\n-You tried to give a lifetime parameter to a type which doesn't need it.\n-Erroneous code example:\n+You tried to give a lifetime parameter to a type which doesn't need it; for\n+example:\n \n ```\n type X = u32<'static>; // error: lifetime parameters are not allowed on\n                        //        this type\n ```\n \n-Please check that you used the correct type and recheck its definition,\n-perhaps it doesn't need the lifetime parameter. Example:\n+Please check that the correct type was used and recheck its definition; perhaps\n+it doesn't need the lifetime parameter. Example:\n \n ```\n type X = u32; // ok!"}]}