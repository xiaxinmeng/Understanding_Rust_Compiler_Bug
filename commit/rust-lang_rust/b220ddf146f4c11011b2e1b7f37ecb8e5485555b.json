{"sha": "b220ddf146f4c11011b2e1b7f37ecb8e5485555b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMjBkZGYxNDZmNGMxMTAxMWIyZTFiN2YzN2VjYjhlNTQ4NTU1NWI=", "commit": {"author": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-09-02T21:30:40Z"}, "committer": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-09-02T21:30:40Z"}, "message": "unit-arg - pr remarks", "tree": {"sha": "5335cdbc2da9fbeb0e6bf47e33a15d85b3194f57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5335cdbc2da9fbeb0e6bf47e33a15d85b3194f57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b220ddf146f4c11011b2e1b7f37ecb8e5485555b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b220ddf146f4c11011b2e1b7f37ecb8e5485555b", "html_url": "https://github.com/rust-lang/rust/commit/b220ddf146f4c11011b2e1b7f37ecb8e5485555b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b220ddf146f4c11011b2e1b7f37ecb8e5485555b/comments", "author": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "html_url": "https://github.com/rust-lang/rust/commit/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8"}], "stats": {"total": 178, "additions": 103, "deletions": 75}, "files": [{"sha": "e83d491fac3b9aa45e86872894700baa422c0391", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b220ddf146f4c11011b2e1b7f37ecb8e5485555b/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b220ddf146f4c11011b2e1b7f37ecb8e5485555b/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=b220ddf146f4c11011b2e1b7f37ecb8e5485555b", "patch": "@@ -31,8 +31,8 @@ use crate::utils::paths;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_type_diagnostic_item,\n     last_path_segment, match_def_path, match_path, method_chain_args, multispan_sugg, numeric_literal::NumericLiteral,\n-    qpath_res, sext, snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, trim_multiline, unsext,\n+    qpath_res, reindent_multiline, sext, snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite,\n+    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -802,7 +802,45 @@ impl<'tcx> LateLintPass<'tcx> for UnitArg {\n     }\n }\n \n-#[allow(clippy::too_many_lines)]\n+fn fmt_stmts_and_call(\n+    cx: &LateContext<'_>,\n+    call_expr: &Expr<'_>,\n+    call_snippet: &str,\n+    args_snippets: &[impl AsRef<str>],\n+    non_empty_block_args_snippets: &[impl AsRef<str>],\n+) -> String {\n+    let call_expr_indent = indent_of(cx, call_expr.span).unwrap_or(0);\n+    let call_snippet_with_replacements = args_snippets\n+        .iter()\n+        .fold(call_snippet.to_owned(), |acc, arg| acc.replacen(arg.as_ref(), \"()\", 1));\n+\n+    let mut stmts_and_call = non_empty_block_args_snippets\n+        .iter()\n+        .map(|it| it.as_ref().to_owned())\n+        .collect::<Vec<_>>();\n+    stmts_and_call.push(call_snippet_with_replacements);\n+    stmts_and_call = stmts_and_call\n+        .into_iter()\n+        .map(|v| reindent_multiline(v.into(), true, Some(call_expr_indent)).into_owned())\n+        .collect();\n+\n+    let mut stmts_and_call_snippet = stmts_and_call.join(&format!(\"{}{}\", \";\\n\", \" \".repeat(call_expr_indent)));\n+    // expr is not in a block statement or result expression position, wrap in a block\n+    let parent_node = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(call_expr.hir_id));\n+    if !matches!(parent_node, Some(Node::Block(_))) && !matches!(parent_node, Some(Node::Stmt(_))) {\n+        let block_indent = call_expr_indent + 4;\n+        stmts_and_call_snippet =\n+            reindent_multiline(stmts_and_call_snippet.into(), true, Some(block_indent)).into_owned();\n+        stmts_and_call_snippet = format!(\n+            \"{{\\n{}{}\\n{}}}\",\n+            \" \".repeat(block_indent),\n+            &stmts_and_call_snippet,\n+            \" \".repeat(call_expr_indent)\n+        );\n+    }\n+    stmts_and_call_snippet\n+}\n+\n fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n     let (singular, plural) = if args_to_recover.len() > 1 {\n@@ -857,37 +895,15 @@ fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Exp\n                 .filter(|arg| !is_empty_block(arg))\n                 .filter_map(|arg| snippet_opt(cx, arg.span))\n                 .collect();\n-            let indent = indent_of(cx, expr.span).unwrap_or(0);\n-\n-            if let Some(expr_str) = snippet_opt(cx, expr.span) {\n-                let expr_with_replacements = arg_snippets\n-                    .iter()\n-                    .fold(expr_str, |acc, arg| acc.replacen(arg, \"()\", 1));\n-\n-                // expr is not in a block statement or result expression position, wrap in a block\n-                let parent_node = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(expr.hir_id));\n-                let wrap_in_block =\n-                    !matches!(parent_node, Some(Node::Block(_))) && !matches!(parent_node, Some(Node::Stmt(_)));\n-\n-                let stmts_indent = if wrap_in_block { indent + 4 } else { indent };\n-                let mut stmts_and_call = arg_snippets_without_empty_blocks.clone();\n-                stmts_and_call.push(expr_with_replacements);\n-                let mut stmts_and_call_str = stmts_and_call\n-                    .into_iter()\n-                    .enumerate()\n-                    .map(|(i, v)| {\n-                        let with_indent_prefix = if i > 0 { \" \".repeat(stmts_indent) + &v } else { v };\n-                        trim_multiline(with_indent_prefix.into(), true, Some(stmts_indent)).into_owned()\n-                    })\n-                    .collect::<Vec<String>>()\n-                    .join(\";\\n\");\n-\n-                if wrap_in_block {\n-                    stmts_and_call_str = \" \".repeat(stmts_indent) + &stmts_and_call_str;\n-                    stmts_and_call_str = format!(\"{{\\n{}\\n{}}}\", &stmts_and_call_str, \" \".repeat(indent));\n-                }\n \n-                let sugg = stmts_and_call_str;\n+            if let Some(call_snippet) = snippet_opt(cx, expr.span) {\n+                let sugg = fmt_stmts_and_call(\n+                    cx,\n+                    expr,\n+                    &call_snippet,\n+                    &arg_snippets,\n+                    &arg_snippets_without_empty_blocks,\n+                );\n \n                 if arg_snippets_without_empty_blocks.is_empty() {\n                     db.multipart_suggestion("}, {"sha": "f394b980127c411c5c9798d922d5b9d8accb7515", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 54, "deletions": 42, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b220ddf146f4c11011b2e1b7f37ecb8e5485555b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b220ddf146f4c11011b2e1b7f37ecb8e5485555b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=b220ddf146f4c11011b2e1b7f37ecb8e5485555b", "patch": "@@ -19,6 +19,7 @@ pub mod paths;\n pub mod ptr;\n pub mod sugg;\n pub mod usage;\n+\n pub use self::attrs::*;\n pub use self::diagnostics::*;\n pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n@@ -108,6 +109,7 @@ pub fn in_macro(span: Span) -> bool {\n         false\n     }\n }\n+\n // If the snippet is empty, it's an attribute that was inserted during macro\n // expansion and we want to ignore those, because they could come from external\n // sources that the user has no control over.\n@@ -571,7 +573,7 @@ pub fn snippet_block<'a, T: LintContext>(\n ) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n     let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n-    trim_multiline(snip, true, indent)\n+    reindent_multiline(snip, true, indent)\n }\n \n /// Same as `snippet_block`, but adapts the applicability level by the rules of\n@@ -585,7 +587,7 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n ) -> Cow<'a, str> {\n     let snip = snippet_with_applicability(cx, span, default, applicability);\n     let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n-    trim_multiline(snip, true, indent)\n+    reindent_multiline(snip, true, indent)\n }\n \n /// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n@@ -661,16 +663,16 @@ pub fn expr_block<'a, T: LintContext>(\n     }\n }\n \n-/// Trim indentation from a multiline string with possibility of ignoring the\n-/// first line.\n-pub fn trim_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n-    let s_space = trim_multiline_inner(s, ignore_first, indent, ' ');\n-    let s_tab = trim_multiline_inner(s_space, ignore_first, indent, '\\t');\n-    trim_multiline_inner(s_tab, ignore_first, indent, ' ')\n+/// Reindent a multiline string with possibility of ignoring the first line.\n+#[allow(clippy::needless_pass_by_value)]\n+pub fn reindent_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n+    let s_space = reindent_multiline_inner(&s, ignore_first, indent, ' ');\n+    let s_tab = reindent_multiline_inner(&s_space, ignore_first, indent, '\\t');\n+    reindent_multiline_inner(&s_tab, ignore_first, indent, ' ').into()\n }\n \n-fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>, ch: char) -> Cow<'_, str> {\n-    let mut x = s\n+fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>, ch: char) -> String {\n+    let x = s\n         .lines()\n         .skip(ignore_first as usize)\n         .filter_map(|l| {\n@@ -683,26 +685,20 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, indent: Option<usiz\n         })\n         .min()\n         .unwrap_or(0);\n-    if let Some(indent) = indent {\n-        x = x.saturating_sub(indent);\n-    }\n-    if x > 0 {\n-        Cow::Owned(\n-            s.lines()\n-                .enumerate()\n-                .map(|(i, l)| {\n-                    if (ignore_first && i == 0) || l.is_empty() {\n-                        l\n-                    } else {\n-                        l.split_at(x).1\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-                .join(\"\\n\"),\n-        )\n-    } else {\n-        s\n-    }\n+    let indent = indent.unwrap_or(0);\n+    s.lines()\n+        .enumerate()\n+        .map(|(i, l)| {\n+            if (ignore_first && i == 0) || l.is_empty() {\n+                l.to_owned()\n+            } else if x > indent {\n+                l.split_at(x - indent).1.to_owned()\n+            } else {\n+                \" \".repeat(indent - x) + l\n+            }\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\"\\n\")\n }\n \n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n@@ -1475,26 +1471,26 @@ macro_rules! unwrap_cargo_metadata {\n \n #[cfg(test)]\n mod test {\n-    use super::{trim_multiline, without_block_comments};\n+    use super::{reindent_multiline, without_block_comments};\n \n     #[test]\n-    fn test_trim_multiline_single_line() {\n-        assert_eq!(\"\", trim_multiline(\"\".into(), false, None));\n-        assert_eq!(\"...\", trim_multiline(\"...\".into(), false, None));\n-        assert_eq!(\"...\", trim_multiline(\"    ...\".into(), false, None));\n-        assert_eq!(\"...\", trim_multiline(\"\\t...\".into(), false, None));\n-        assert_eq!(\"...\", trim_multiline(\"\\t\\t...\".into(), false, None));\n+    fn test_reindent_multiline_single_line() {\n+        assert_eq!(\"\", reindent_multiline(\"\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"    ...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"\\t...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"\\t\\t...\".into(), false, None));\n     }\n \n     #[test]\n     #[rustfmt::skip]\n-    fn test_trim_multiline_block() {\n+    fn test_reindent_multiline_block() {\n         assert_eq!(\"\\\n     if x {\n         y\n     } else {\n         z\n-    }\", trim_multiline(\"    if x {\n+    }\", reindent_multiline(\"    if x {\n             y\n         } else {\n             z\n@@ -1504,7 +1500,7 @@ mod test {\n     \\ty\n     } else {\n     \\tz\n-    }\", trim_multiline(\"    if x {\n+    }\", reindent_multiline(\"    if x {\n         \\ty\n         } else {\n         \\tz\n@@ -1513,21 +1509,37 @@ mod test {\n \n     #[test]\n     #[rustfmt::skip]\n-    fn test_trim_multiline_empty_line() {\n+    fn test_reindent_multiline_empty_line() {\n         assert_eq!(\"\\\n     if x {\n         y\n \n     } else {\n         z\n-    }\", trim_multiline(\"    if x {\n+    }\", reindent_multiline(\"    if x {\n             y\n \n         } else {\n             z\n         }\".into(), false, None));\n     }\n \n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_reindent_multiline_lines_deeper() {\n+        assert_eq!(\"\\\n+        if x {\n+            y\n+        } else {\n+            z\n+        }\", reindent_multiline(\"\\\n+    if x {\n+        y\n+    } else {\n+        z\n+    }\".into(), true, Some(8)));\n+    }\n+\n     #[test]\n     fn test_without_block_comments_lines_without_block_comments() {\n         let result = without_block_comments(vec![\"/*\", \"\", \"*/\"]);"}]}