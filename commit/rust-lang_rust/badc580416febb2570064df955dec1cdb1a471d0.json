{"sha": "badc580416febb2570064df955dec1cdb1a471d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZGM1ODA0MTZmZWJiMjU3MDA2NGRmOTU1ZGVjMWNkYjFhNDcxZDA=", "commit": {"author": {"name": "Scott Lawrence", "email": "bytbox@gmail.com", "date": "2014-01-27T04:13:24Z"}, "committer": {"name": "Scott Lawrence", "email": "bytbox@gmail.com", "date": "2014-01-29T14:15:41Z"}, "message": "Removing do keyword from libextra", "tree": {"sha": "ad897bf32f573df9c276fe6010bba3b48872fd69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad897bf32f573df9c276fe6010bba3b48872fd69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/badc580416febb2570064df955dec1cdb1a471d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/badc580416febb2570064df955dec1cdb1a471d0", "html_url": "https://github.com/rust-lang/rust/commit/badc580416febb2570064df955dec1cdb1a471d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/badc580416febb2570064df955dec1cdb1a471d0/comments", "author": {"login": "bytbox", "id": 160033, "node_id": "MDQ6VXNlcjE2MDAzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/160033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bytbox", "html_url": "https://github.com/bytbox", "followers_url": "https://api.github.com/users/bytbox/followers", "following_url": "https://api.github.com/users/bytbox/following{/other_user}", "gists_url": "https://api.github.com/users/bytbox/gists{/gist_id}", "starred_url": "https://api.github.com/users/bytbox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bytbox/subscriptions", "organizations_url": "https://api.github.com/users/bytbox/orgs", "repos_url": "https://api.github.com/users/bytbox/repos", "events_url": "https://api.github.com/users/bytbox/events{/privacy}", "received_events_url": "https://api.github.com/users/bytbox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bytbox", "id": 160033, "node_id": "MDQ6VXNlcjE2MDAzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/160033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bytbox", "html_url": "https://github.com/bytbox", "followers_url": "https://api.github.com/users/bytbox/followers", "following_url": "https://api.github.com/users/bytbox/following{/other_user}", "gists_url": "https://api.github.com/users/bytbox/gists{/gist_id}", "starred_url": "https://api.github.com/users/bytbox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bytbox/subscriptions", "organizations_url": "https://api.github.com/users/bytbox/orgs", "repos_url": "https://api.github.com/users/bytbox/repos", "events_url": "https://api.github.com/users/bytbox/events{/privacy}", "received_events_url": "https://api.github.com/users/bytbox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d904179066b407c32ca247938560fcf8766e5ff3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d904179066b407c32ca247938560fcf8766e5ff3", "html_url": "https://github.com/rust-lang/rust/commit/d904179066b407c32ca247938560fcf8766e5ff3"}], "stats": {"total": 245, "additions": 122, "deletions": 123}, "files": [{"sha": "bf47e3bdf89ead32ff8547f7d549e3cac6576f13", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=badc580416febb2570064df955dec1cdb1a471d0", "patch": "@@ -28,12 +28,12 @@\n  *       let (port, chan) = Chan::new();\n  *       chan.send(shared_numbers.clone());\n  *\n- *       do spawn {\n+ *       spawn(proc() {\n  *           let shared_numbers = port.recv();\n  *           let local_numbers = shared_numbers.get();\n  *\n  *           // Work with the local numbers\n- *       }\n+ *       });\n  *   }\n  * ```\n  */\n@@ -567,12 +567,12 @@ mod tests {\n \n         let (p, c) = Chan::new();\n \n-        do task::spawn {\n+        task::spawn(proc() {\n             let arc_v: Arc<~[int]> = p.recv();\n \n             let v = arc_v.get().clone();\n             assert_eq!(v[3], 4);\n-        };\n+        });\n \n         c.send(arc_v.clone());\n \n@@ -587,14 +587,14 @@ mod tests {\n         let arc = ~MutexArc::new(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = Chan::new();\n-        do task::spawn {\n+        task::spawn(proc() {\n             // wait until parent gets in\n             p.recv();\n             arc2.access_cond(|state, cond| {\n                 *state = true;\n                 cond.signal();\n             })\n-        }\n+        });\n \n         arc.access_cond(|state, cond| {\n             c.send(());\n@@ -611,14 +611,14 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (p, c) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let _ = p.recv();\n             arc2.access_cond(|one, cond| {\n                 cond.signal();\n                 // Parent should fail when it wakes up.\n                 assert_eq!(*one, 0);\n             })\n-        }\n+        });\n \n         arc.access_cond(|one, cond| {\n             c.send(());\n@@ -632,11 +632,11 @@ mod tests {\n     fn test_mutex_arc_poison() {\n         let arc = ~MutexArc::new(1);\n         let arc2 = ~arc.clone();\n-        do task::try || {\n+        task::try(proc() {\n             arc2.access(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.access(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -649,13 +649,13 @@ mod tests {\n             // to underlaying data.\n             let arc = ~MutexArc::new(1);\n             let arc2 = ~MutexArc::new(*arc);\n-            do task::spawn || {\n+            task::spawn(proc() {\n                 (*arc2).unsafe_access(|mutex| {\n                     (*mutex).access(|one| {\n                         assert!(*one == 1);\n                     })\n                 })\n-            };\n+            });\n         }\n     }\n \n@@ -682,11 +682,11 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.write(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.read(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -696,11 +696,11 @@ mod tests {\n     fn test_rw_arc_poison_ww() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.write(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.write(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -709,13 +709,13 @@ mod tests {\n     fn test_rw_arc_poison_dw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.write_downgrade(|mut write_mode| {\n                 write_mode.write(|one| {\n                     assert_eq!(*one, 2);\n                 })\n             })\n-        };\n+        });\n         arc.write(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -724,11 +724,11 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.read(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.read(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -737,11 +737,11 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.read(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.write(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -750,14 +750,14 @@ mod tests {\n     fn test_rw_arc_no_poison_dr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.write_downgrade(|write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n                 read_mode.read(|one| {\n                     assert_eq!(*one, 2);\n                 })\n             })\n-        };\n+        });\n         arc.write(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -768,7 +768,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (p, c) = Chan::new();\n \n-        do task::spawn {\n+        task::spawn(proc() {\n             arc2.write(|num| {\n                 10.times(|| {\n                     let tmp = *num;\n@@ -778,19 +778,19 @@ mod tests {\n                 });\n                 c.send(());\n             })\n-        }\n+        });\n \n         // Readers try to catch the writer in the act\n         let mut children = ~[];\n         5.times(|| {\n             let arc3 = arc.clone();\n             let mut builder = task::task();\n             children.push(builder.future_result());\n-            do builder.spawn {\n+            builder.spawn(proc() {\n                 arc3.read(|num| {\n                     assert!(*num >= 0);\n                 })\n-            }\n+            });\n         });\n \n         // Wait for children to pass their asserts\n@@ -840,19 +840,19 @@ mod tests {\n             let ((rp1, rc1), (rp2, rc2)) = (Chan::new(), Chan::new());\n             reader_convos.push((rc1, rp2));\n             let arcn = arc.clone();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 arcn.read(|state| {\n                     assert_eq!(*state, 31337);\n                     rc2.send(());\n                 })\n-            }\n+            });\n         });\n \n         // Writer task\n         let arc2 = arc.clone();\n         let ((wp1, wc1), (wp2, wc2)) = (Chan::new(), Chan::new());\n-        do task::spawn || {\n+        task::spawn(proc() {\n             wp1.recv();\n             arc2.write_cond(|state, cond| {\n                 assert_eq!(*state, 0);\n@@ -867,7 +867,7 @@ mod tests {\n                 *state = 42;\n             });\n             wc2.send(());\n-        }\n+        });\n \n         // Downgrader (us)\n         arc.write_downgrade(|mut write_mode| {\n@@ -912,7 +912,7 @@ mod tests {\n \n         // writer task\n         let xw = x.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             xw.write_cond(|state, c| {\n                 wc.send(()); // tell downgrader it's ok to go\n                 c.wait();\n@@ -921,7 +921,7 @@ mod tests {\n                 // trying to receive the \"reader cloud lock hand-off\".\n                 *state = false;\n             })\n-        }\n+        });\n \n         wp.recv(); // wait for writer to get in\n \n@@ -934,10 +934,10 @@ mod tests {\n             // make a reader task to trigger the \"reader cloud lock\" handoff\n             let xr = x.clone();\n             let (rp, rc) = Chan::new();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 rc.send(());\n                 xr.read(|_state| { })\n-            }\n+            });\n             rp.recv(); // wait for reader task to exist\n \n             let read_mode = x.downgrade(write_mode);"}, {"sha": "69a1383e44da4b761e8fde107610d7efea2fa847", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=badc580416febb2570064df955dec1cdb1a471d0", "patch": "@@ -115,9 +115,9 @@ mod test {\n     pub fn basic_rendezvous_test() {\n         let (port, chan) = rendezvous();\n \n-        do spawn {\n+        spawn(proc() {\n             chan.send(\"abc\");\n-        }\n+        });\n \n         assert!(port.recv() == \"abc\");\n     }\n@@ -126,40 +126,40 @@ mod test {\n     fn recv_a_lot() {\n         // Rendezvous streams should be able to handle any number of messages being sent\n         let (port, chan) = rendezvous();\n-        do spawn {\n+        spawn(proc() {\n             10000.times(|| { chan.send(()) })\n-        }\n+        });\n         10000.times(|| { port.recv() })\n     }\n \n     #[test]\n     fn send_and_fail_and_try_recv() {\n         let (port, chan) = rendezvous();\n-        do spawn {\n+        spawn(proc() {\n             chan.duplex_stream.send(()); // Can't access this field outside this module\n             fail!()\n-        }\n+        });\n         port.recv()\n     }\n \n     #[test]\n     fn try_send_and_recv_then_fail_before_ack() {\n         let (port, chan) = rendezvous();\n-        do spawn {\n+        spawn(proc() {\n             port.duplex_stream.recv();\n             fail!()\n-        }\n+        });\n         chan.try_send(());\n     }\n \n     #[test]\n     #[should_fail]\n     fn send_and_recv_then_fail_before_ack() {\n         let (port, chan) = rendezvous();\n-        do spawn {\n+        spawn(proc() {\n             port.duplex_stream.recv();\n             fail!()\n-        }\n+        });\n         chan.send(());\n     }\n }"}, {"sha": "0706d4e5a687430c88190ab80155bb40e3e74763", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=badc580416febb2570064df955dec1cdb1a471d0", "patch": "@@ -971,10 +971,10 @@ mod tests {\n     #[test]\n     fn test_send() {\n         let n = list_from([1,2,3]);\n-        do spawn {\n+        spawn(proc() {\n             check_links(&n);\n             assert_eq!(~[&1,&2,&3], n.iter().collect::<~[&int]>());\n-        }\n+        });\n     }\n \n     #[test]"}, {"sha": "b9121290f33f4ba49abcf8d312192bf43d6a5e36", "filename": "src/libextra/future.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=badc580416febb2570064df955dec1cdb1a471d0", "patch": "@@ -18,7 +18,7 @@\n  * use extra::future::Future;\n  * # fn fib(n: uint) -> uint {42};\n  * # fn make_a_sandwich() {};\n- * let mut delayed_fib = do Future::spawn { fib(5000) };\n+ * let mut delayed_fib = Future::spawn(proc() { fib(5000) });\n  * make_a_sandwich();\n  * println!(\"fib(5000) = {}\", delayed_fib.get())\n  * ```\n@@ -112,9 +112,9 @@ impl<A:Send> Future<A> {\n          * waiting for the result to be received on the port.\n          */\n \n-        do Future::from_fn {\n+        Future::from_fn(proc() {\n             port.recv()\n-        }\n+        })\n     }\n \n     pub fn spawn(blk: proc() -> A) -> Future<A> {\n@@ -127,9 +127,9 @@ impl<A:Send> Future<A> {\n \n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             chan.send(blk());\n-        }\n+        });\n \n         Future::from_port(port)\n     }\n@@ -195,11 +195,11 @@ mod test {\n     #[test]\n     fn test_sendable_future() {\n         let expected = \"schlorf\";\n-        let f = do Future::spawn { expected };\n-        do task::spawn {\n+        let f = Future::spawn(proc() { expected });\n+        task::spawn(proc() {\n             let mut f = f;\n             let actual = f.get();\n             assert_eq!(actual, expected);\n-        }\n+        });\n     }\n }"}, {"sha": "d8c1cb51a118190983ce562408541f8ac8429404", "filename": "src/libextra/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=badc580416febb2570064df955dec1cdb1a471d0", "patch": "@@ -2201,7 +2201,7 @@ mod tests {\n     }\n     fn check_err<T: Decodable<Decoder>>(to_parse: &'static str, expected_error: &str) {\n         use std::task;\n-        let res = do task::try {\n+        let res = task::try(proc() {\n             // either fails in `decode` (which is what we want), or\n             // returns Some(error_message)/None if the string was\n             // invalid or valid JSON.\n@@ -2212,7 +2212,7 @@ mod tests {\n                     None\n                 }\n             }\n-        };\n+        });\n         match res {\n             Ok(Some(parse_error)) => fail!(\"`{}` is not valid json: {}\",\n                                            to_parse, parse_error),"}, {"sha": "3acaf8352564653a0e3481482c5afd471447a1fd", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 58, "deletions": 59, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=badc580416febb2570064df955dec1cdb1a471d0", "patch": "@@ -695,11 +695,11 @@ impl<'a> RWLockReadMode<'a> {\n ///     let c = barrier.clone();\n ///     // The same messages will be printed together.\n ///     // You will NOT see any interleaving.\n-///     do spawn {\n+///     spawn(proc() {\n ///         println!(\"before wait\");\n ///         c.wait();\n ///         println!(\"after wait\");\n-///     }\n+///     });\n /// });\n /// ```\n #[deriving(Clone)]\n@@ -778,11 +778,11 @@ mod tests {\n     fn test_sem_as_mutex() {\n         let s = Semaphore::new(1);\n         let s2 = s.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             s2.access(|| {\n                 5.times(|| { task::deschedule(); })\n             })\n-        }\n+        });\n         s.access(|| {\n             5.times(|| { task::deschedule(); })\n         })\n@@ -793,10 +793,10 @@ mod tests {\n         let (p, c) = Chan::new();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             s2.acquire();\n             c.send(());\n-        }\n+        });\n         5.times(|| { task::deschedule(); });\n         s.release();\n         let _ = p.recv();\n@@ -805,11 +805,11 @@ mod tests {\n         let (p, c) = Chan::new();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             5.times(|| { task::deschedule(); });\n             s2.release();\n             let _ = p.recv();\n-        }\n+        });\n         s.acquire();\n         c.send(());\n     }\n@@ -821,12 +821,12 @@ mod tests {\n         let s2 = s.clone();\n         let (p1,c1) = Chan::new();\n         let (p2,c2) = Chan::new();\n-        do task::spawn {\n+        task::spawn(proc() {\n             s2.access(|| {\n                 let _ = p2.recv();\n                 c1.send(());\n             })\n-        }\n+        });\n         s.access(|| {\n             c2.send(());\n             let _ = p1.recv();\n@@ -842,11 +842,11 @@ mod tests {\n         let mut child_data = Some((s2, c));\n         s.access(|| {\n             let (s2, c) = child_data.take_unwrap();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 c.send(());\n                 s2.access(|| { });\n                 c.send(());\n-            }\n+            });\n             let _ = p.recv(); // wait for child to come alive\n             5.times(|| { task::deschedule(); }); // let the child contend\n         });\n@@ -865,13 +865,12 @@ mod tests {\n         let mut sharedstate = ~0;\n         {\n             let ptr: *int = &*sharedstate;\n-            do task::spawn {\n+            task::spawn(proc() {\n                 let sharedstate: &mut int =\n                     unsafe { cast::transmute(ptr) };\n                 access_shared(sharedstate, &m2, 10);\n                 c.send(());\n-\n-            }\n+            });\n         }\n         {\n             access_shared(sharedstate, &m, 10);\n@@ -897,24 +896,24 @@ mod tests {\n         // Child wakes up parent\n         m.lock_cond(|cond| {\n             let m2 = m.clone();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 m2.lock_cond(|cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n                 })\n-            }\n+            });\n             cond.wait();\n         });\n         // Parent wakes up child\n         let (port,chan) = Chan::new();\n         let m3 = m.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             m3.lock_cond(|cond| {\n                 chan.send(());\n                 cond.wait();\n                 chan.send(());\n             })\n-        }\n+        });\n         let _ = port.recv(); // Wait until child gets in the mutex\n         m.lock_cond(|cond| {\n             let woken = cond.signal();\n@@ -931,13 +930,13 @@ mod tests {\n             let mi = m.clone();\n             let (port, chan) = Chan::new();\n             ports.push(port);\n-            do task::spawn {\n+            task::spawn(proc() {\n                 mi.lock_cond(|cond| {\n                     chan.send(());\n                     cond.wait();\n                     chan.send(());\n                 })\n-            }\n+            });\n         });\n \n         // wait until all children get in the mutex\n@@ -961,9 +960,9 @@ mod tests {\n     fn test_mutex_cond_no_waiter() {\n         let m = Mutex::new();\n         let m2 = m.clone();\n-        do task::try {\n+        task::try(proc() {\n             m.lock_cond(|_x| { })\n-        };\n+        });\n         m2.lock_cond(|cond| {\n             assert!(!cond.signal());\n         })\n@@ -974,11 +973,11 @@ mod tests {\n         let m = Mutex::new();\n         let m2 = m.clone();\n \n-        let result: result::Result<(), ~Any> = do task::try {\n+        let result: result::Result<(), ~Any> = task::try(proc() {\n             m2.lock(|| {\n                 fail!();\n             })\n-        };\n+        });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         m.lock(|| { })\n@@ -991,18 +990,18 @@ mod tests {\n         let m = Mutex::new();\n         let m2 = m.clone();\n \n-        let result: result::Result<(), ~Any> = do task::try {\n+        let result: result::Result<(), ~Any> = task::try(proc() {\n             let (p, c) = Chan::new();\n-            do task::spawn { // linked\n+            task::spawn(proc() { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::deschedule();\n                 fail!();\n-            }\n+            });\n             m2.lock_cond(|cond| {\n                 c.send(()); // tell sibling go ahead\n                 cond.wait(); // block forever\n             })\n-        };\n+        });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         m.lock_cond(|cond| {\n@@ -1019,14 +1018,14 @@ mod tests {\n         let m2 = m.clone();\n         let (p, c) = Chan::new();\n \n-        let result: result::Result<(), ~Any> = do task::try {\n+        let result: result::Result<(), ~Any> = task::try(proc() {\n             let mut sibling_convos = ~[];\n             2.times(|| {\n                 let (p, c) = Chan::new();\n                 sibling_convos.push(p);\n                 let mi = m2.clone();\n                 // spawn sibling task\n-                do task::spawn { // linked\n+                task::spawn(proc() { // linked\n                     mi.lock_cond(|cond| {\n                         c.send(()); // tell sibling to go ahead\n                         (|| {\n@@ -1037,15 +1036,15 @@ mod tests {\n                             error!(\"task unwinding and done sending\");\n                         })\n                     })\n-                }\n+                });\n             });\n             for p in sibling_convos.mut_iter() {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             m2.lock(|| { });\n             c.send(sibling_convos); // let parent wait on all children\n             fail!();\n-        };\n+        });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         let mut r = p.recv();\n@@ -1061,52 +1060,52 @@ mod tests {\n         let m = Mutex::new();\n         m.lock_cond(|cond| {\n             let m2 = m.clone();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 m2.lock_cond(|cond| {\n                     cond.signal_on(0);\n                 })\n-            }\n+            });\n             cond.wait();\n         })\n     }\n     #[test]\n     #[ignore(reason = \"linked failure?\")]\n     fn test_mutex_different_conds() {\n-        let result = do task::try {\n+        let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(2);\n             let m2 = m.clone();\n             let (p, c) = Chan::new();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 m2.lock_cond(|cond| {\n                     c.send(());\n                     cond.wait_on(1);\n                 })\n-            }\n+            });\n             let _ = p.recv();\n             m.lock_cond(|cond| {\n                 if !cond.signal_on(0) {\n                     fail!(); // success; punt sibling awake.\n                 }\n             })\n-        };\n+        });\n         assert!(result.is_err());\n     }\n     #[test]\n     fn test_mutex_no_condvars() {\n-        let result = do task::try {\n+        let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n             m.lock_cond(|cond| { cond.wait(); })\n-        };\n+        });\n         assert!(result.is_err());\n-        let result = do task::try {\n+        let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n             m.lock_cond(|cond| { cond.signal(); })\n-        };\n+        });\n         assert!(result.is_err());\n-        let result = do task::try {\n+        let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n             m.lock_cond(|cond| { cond.broadcast(); })\n-        };\n+        });\n         assert!(result.is_err());\n     }\n     /************************************************************************\n@@ -1141,12 +1140,12 @@ mod tests {\n         let mut sharedstate = ~0;\n         {\n             let ptr: *int = &*sharedstate;\n-            do task::spawn {\n+            task::spawn(proc() {\n                 let sharedstate: &mut int =\n                     unsafe { cast::transmute(ptr) };\n                 access_shared(sharedstate, &x2, mode1, 10);\n                 c.send(());\n-            }\n+            });\n         }\n         {\n             access_shared(sharedstate, x, mode2, 10);\n@@ -1189,7 +1188,7 @@ mod tests {\n         let x2 = x.clone();\n         let (p1, c1) = Chan::new();\n         let (p2, c2) = Chan::new();\n-        do task::spawn {\n+        task::spawn(proc() {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n             }\n@@ -1200,7 +1199,7 @@ mod tests {\n                 let _ = p2.recv();\n                 c1.send(());\n             })\n-        }\n+        });\n         if make_mode2_go_first {\n             let _ = p1.recv(); // child sends to us once it locks, or ...\n         }\n@@ -1244,24 +1243,24 @@ mod tests {\n         // Child wakes up parent\n         x.write_cond(|cond| {\n             let x2 = x.clone();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 x2.write_cond(|cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n                 })\n-            }\n+            });\n             cond.wait();\n         });\n         // Parent wakes up child\n         let (port, chan) = Chan::new();\n         let x3 = x.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             x3.write_cond(|cond| {\n                 chan.send(());\n                 cond.wait();\n                 chan.send(());\n             })\n-        }\n+        });\n         let _ = port.recv(); // Wait until child gets in the rwlock\n         x.read(|| { }); // Must be able to get in as a reader in the meantime\n         x.write_cond(|cond| { // Or as another writer\n@@ -1292,13 +1291,13 @@ mod tests {\n             let xi = x.clone();\n             let (port, chan) = Chan::new();\n             ports.push(port);\n-            do task::spawn {\n+            task::spawn(proc() {\n                 lock_cond(&xi, dg1, |cond| {\n                     chan.send(());\n                     cond.wait();\n                     chan.send(());\n                 })\n-            }\n+            });\n         });\n \n         // wait until all children get in the mutex\n@@ -1327,11 +1326,11 @@ mod tests {\n         let x = RWLock::new();\n         let x2 = x.clone();\n \n-        let result: result::Result<(), ~Any> = do task::try || {\n+        let result: result::Result<(), ~Any> = task::try(proc() {\n             lock_rwlock_in_mode(&x2, mode1, || {\n                 fail!();\n             })\n-        };\n+        });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         lock_rwlock_in_mode(&x, mode2, || { })\n@@ -1392,10 +1391,10 @@ mod tests {\n         9.times(|| {\n             let c = barrier.clone();\n             let chan = chan.clone();\n-            do spawn {\n+            spawn(proc() {\n                 c.wait();\n                 chan.send(true);\n-            }\n+            });\n         });\n \n         // At this point, all spawned tasks should be blocked,"}, {"sha": "cd04cddba4a6937a864d7a0c4b64cdfe29e5be8d", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=badc580416febb2570064df955dec1cdb1a471d0", "patch": "@@ -873,7 +873,7 @@ pub fn run_test(force_ignore: bool,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n                       testfn: proc()) {\n-        do spawn {\n+        spawn(proc() {\n             let mut task = task::task();\n             task.name(match desc.name {\n                 DynTestName(ref name) => SendStrOwned(name.clone()),\n@@ -885,7 +885,7 @@ pub fn run_test(force_ignore: bool,\n             let task_result = result_future.recv();\n             let test_result = calc_result(&desc, task_result.is_ok());\n             monitor_ch.send((desc.clone(), test_result));\n-        }\n+        });\n     }\n \n     match testfn {"}, {"sha": "70bbe02d32f1769839b08021c8a3706d45d93033", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/badc580416febb2570064df955dec1cdb1a471d0/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=badc580416febb2570064df955dec1cdb1a471d0", "patch": "@@ -414,14 +414,14 @@ impl<'a> Prep<'a> {\n                 let blk = bo.take_unwrap();\n \n                 // FIXME: What happens if the task fails?\n-                do spawn {\n+                spawn(proc() {\n                     let mut exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n                         discovered_outputs: WorkMap::new(),\n                     };\n                     let v = blk(&mut exe);\n                     chan.send((exe, v));\n-                }\n+                });\n                 Work::from_task(self, port)\n             }\n         }\n@@ -495,7 +495,7 @@ fn test() {\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n-        do prep.exec |_exe| {\n+        prep.exec(proc(_exe) {\n             let out = make_path(~\"foo.o\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             run::process_status(\"gcc\", [pth.as_str().unwrap().to_owned(),\n@@ -507,7 +507,7 @@ fn test() {\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n             out.as_str().unwrap().to_owned()\n-        }\n+        })\n     });\n \n     println!(\"{}\", s);"}]}