{"sha": "b3517cdee7ba611dae3111370b3f5a815a5b4369", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNTE3Y2RlZTdiYTYxMWRhZTMxMTEzNzBiM2Y1YTgxNWE1YjQzNjk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-18T18:33:05Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-18T19:03:04Z"}, "message": "review comments", "tree": {"sha": "8fc9d0f0cdd94f98a08ff7c25b3eddb4d6a410bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fc9d0f0cdd94f98a08ff7c25b3eddb4d6a410bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3517cdee7ba611dae3111370b3f5a815a5b4369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3517cdee7ba611dae3111370b3f5a815a5b4369", "html_url": "https://github.com/rust-lang/rust/commit/b3517cdee7ba611dae3111370b3f5a815a5b4369", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3517cdee7ba611dae3111370b3f5a815a5b4369/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f8f70624b99460481af25764b9e02d2c67b42c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8f70624b99460481af25764b9e02d2c67b42c5", "html_url": "https://github.com/rust-lang/rust/commit/6f8f70624b99460481af25764b9e02d2c67b42c5"}], "stats": {"total": 108, "additions": 60, "deletions": 48}, "files": [{"sha": "f2607b23527a1d2d743eadde441badf0ee8720ff", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3517cdee7ba611dae3111370b3f5a815a5b4369/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3517cdee7ba611dae3111370b3f5a815a5b4369/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b3517cdee7ba611dae3111370b3f5a815a5b4369", "patch": "@@ -1197,10 +1197,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         if let Some((expected, found)) = expected_found {\n-            let expected_label = exp_found.map(|ef| ef.expected.prefix_string())\n-                .unwrap_or(\"type\".into());\n-            let found_label = exp_found.map(|ef| ef.found.prefix_string())\n-                .unwrap_or(\"type\".into());\n+            let expected_label = exp_found.map_or(\"type\".into(), |ef| ef.expected.prefix_string());\n+            let found_label = exp_found.map_or(\"type\".into(), |ef| ef.found.prefix_string());\n             match (&terr, expected == found) {\n                 (TypeError::Sorts(values), extra) => {\n                     let sort_string = |ty: Ty<'tcx>| match (extra, &ty.kind) {"}, {"sha": "95bdce2d22252e11983e09b3647ffd69bc0518fc", "filename": "src/librustc/ty/diagnostics.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b3517cdee7ba611dae3111370b3f5a815a5b4369/src%2Flibrustc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3517cdee7ba611dae3111370b3f5a815a5b4369/src%2Flibrustc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fdiagnostics.rs?ref=b3517cdee7ba611dae3111370b3f5a815a5b4369", "patch": "@@ -0,0 +1,56 @@\n+//! Diagnostics related methods for `TyS`.\n+\n+use crate::ty::TyS;\n+use crate::ty::TyKind::*;\n+use crate::ty::sty::InferTy;\n+\n+impl<'tcx> TyS<'tcx> {\n+    /// Similar to `TyS::is_primitive`, but also considers inferred numeric values to be primitive.\n+    pub fn is_primitive_ty(&self) -> bool {\n+        match self.kind {\n+            Bool | Char | Str | Int(_) | Uint(_) | Float(_) |\n+            Infer(InferTy::IntVar(_)) | Infer(InferTy::FloatVar(_)) |\n+            Infer(InferTy::FreshIntTy(_)) | Infer(InferTy::FreshFloatTy(_)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Whether the type is succinctly representable as a type instead of just refered to with a\n+    /// description in error messages. This is used in the main error message.\n+    pub fn is_simple_ty(&self) -> bool {\n+        match self.kind {\n+            Bool | Char | Str | Int(_) | Uint(_) | Float(_) |\n+            Infer(InferTy::IntVar(_)) | Infer(InferTy::FloatVar(_)) |\n+            Infer(InferTy::FreshIntTy(_)) | Infer(InferTy::FreshFloatTy(_)) => true,\n+            Ref(_, x, _) | Array(x, _) | Slice(x) => x.peel_refs().is_simple_ty(),\n+            Tuple(tys) if tys.is_empty() => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Whether the type is succinctly representable as a type instead of just refered to with a\n+    /// description in error messages. This is used in the primary span label. Beyond what\n+    /// `is_simple_ty` includes, it also accepts ADTs with no type arguments and references to\n+    /// ADTs with no type arguments.\n+    pub fn is_simple_text(&self) -> bool {\n+        match self.kind {\n+            Adt(_, substs) => substs.types().next().is_none(),\n+            Ref(_, ty, _) => ty.is_simple_text(),\n+            _ => self.is_simple_ty(),\n+        }\n+    }\n+\n+    /// Whether the type can be safely suggested during error recovery.\n+    pub fn is_suggestable(&self) -> bool {\n+        match self.kind {\n+            Opaque(..) |\n+            FnDef(..) |\n+            FnPtr(..) |\n+            Dynamic(..) |\n+            Closure(..) |\n+            Infer(..) |\n+            Projection(..) => false,\n+            _ => true,\n+        }\n+    }\n+}"}, {"sha": "280a5a157e9345c1bfa697a030b57312f0a9454a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b3517cdee7ba611dae3111370b3f5a815a5b4369/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3517cdee7ba611dae3111370b3f5a815a5b4369/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b3517cdee7ba611dae3111370b3f5a815a5b4369", "patch": "@@ -71,6 +71,7 @@ pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TyKind::*;\n+pub use crate::ty::diagnostics::*;\n \n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n@@ -122,6 +123,7 @@ mod instance;\n mod structural_impls;\n mod structural_match;\n mod sty;\n+mod diagnostics;\n \n // Data types\n \n@@ -552,50 +554,6 @@ impl<'tcx> Hash for TyS<'tcx> {\n     }\n }\n \n-impl<'tcx> TyS<'tcx> {\n-    pub fn is_primitive_ty(&self) -> bool {\n-        match self.kind {\n-            Bool | Char | Str | Int(_) | Uint(_) | Float(_) |\n-            Infer(InferTy::IntVar(_)) | Infer(InferTy::FloatVar(_)) |\n-            Infer(InferTy::FreshIntTy(_)) | Infer(InferTy::FreshFloatTy(_)) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_simple_ty(&self) -> bool {\n-        match self.kind {\n-            Bool | Char | Str | Int(_) | Uint(_) | Float(_) |\n-            Infer(InferTy::IntVar(_)) | Infer(InferTy::FloatVar(_)) |\n-            Infer(InferTy::FreshIntTy(_)) | Infer(InferTy::FreshFloatTy(_)) => true,\n-            Ref(_, x, _) | Array(x, _) | Slice(x) => x.peel_refs().is_simple_ty(),\n-            Tuple(tys) if tys.is_empty() => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_simple_text(&self) -> bool {\n-        match self.kind {\n-            Adt(_, substs) => substs.types().next().is_none(),\n-            Ref(_, ty, _) => ty.is_simple_text(),\n-            _ if self.is_simple_ty() => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_suggestable(&self) -> bool {\n-        match self.kind {\n-            Opaque(..) |\n-            FnDef(..) |\n-            FnPtr(..) |\n-            Dynamic(..) |\n-            Closure(..) |\n-            Infer(..) |\n-            Projection(..) => false,\n-            _ => true,\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ty::TyS {"}]}