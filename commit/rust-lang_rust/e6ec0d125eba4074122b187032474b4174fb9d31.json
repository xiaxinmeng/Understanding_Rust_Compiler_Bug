{"sha": "e6ec0d125eba4074122b187032474b4174fb9d31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZWMwZDEyNWViYTQwNzQxMjJiMTg3MDMyNDc0YjQxNzRmYjlkMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-10T15:24:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-10T15:24:59Z"}, "message": "Auto merge of #68835 - CAD97:sound-range-inclusive, r=Mark-Simulacrum\n\nRemove problematic specialization from RangeInclusive\n\nFixes #67194 using the approach [outlined by Mark-Simulacrum](https://github.com/rust-lang/rust/issues/67194#issuecomment-581669549).\n\n> I believe the property we want is that if `PartialEq(&self, &other) == true`, then `self.next() == other.next()`. It is true that this is satisfied by removing the specialization and always doing `is_empty.unwrap_or_default()`; the \"wrong\" behavior there arises from calling `next()` having an effect on initially empty ranges, as we should be in `is_empty = true` but are not (yet) there. It might be possible to detect that the current state is always empty (i.e., `start > end`) and then not fill in the empty slot. I think this might solve the problem without regressing tests; however, this could have performance implications.\n\n> That approach essentially states that we only use the `is_empty` slot for cases where `start <= end`. That means that `Idx: !Step` and `start > end` would both behave the same, and correctly -- we do not need the boolean if we're not ever going to emit any values from the iterator.\n\nThis is implemented here by replacing the `is_empty: Option<bool>` slot with an `exhausted: bool` slot. This flag is\n\n- `false` upon construction,\n- `false` when iteration has not yielded an element -- importantly, this means it is always `false` for an iterator empty by construction,\n- `false` when iteration has yielded an element and the iterator is not exhausted, and\n- only `true` when iteration has been used to exhaust the iterator.\n\nFor completeness, this also adds a note to the `Debug` representation to note when the range is exhausted.", "tree": {"sha": "6068680ebdd11e46ff0e16cf29872db95469f4a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6068680ebdd11e46ff0e16cf29872db95469f4a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6ec0d125eba4074122b187032474b4174fb9d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ec0d125eba4074122b187032474b4174fb9d31", "html_url": "https://github.com/rust-lang/rust/commit/e6ec0d125eba4074122b187032474b4174fb9d31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6ec0d125eba4074122b187032474b4174fb9d31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d1241f5158ffd66730e094d8f199ed654ed52ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1241f5158ffd66730e094d8f199ed654ed52ae", "html_url": "https://github.com/rust-lang/rust/commit/4d1241f5158ffd66730e094d8f199ed654ed52ae"}, {"sha": "136008c15bbd2f9517dab54b87cddf2023df38a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/136008c15bbd2f9517dab54b87cddf2023df38a3", "html_url": "https://github.com/rust-lang/rust/commit/136008c15bbd2f9517dab54b87cddf2023df38a3"}], "stats": {"total": 113, "additions": 44, "deletions": 69}, "files": [{"sha": "28fbd00f36b33558e8f05ccf06632f9d299cf8fb", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e6ec0d125eba4074122b187032474b4174fb9d31/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ec0d125eba4074122b187032474b4174fb9d31/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=e6ec0d125eba4074122b187032474b4174fb9d31", "patch": "@@ -341,16 +341,15 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n         let is_iterating = self.start < self.end;\n-        self.is_empty = Some(!is_iterating);\n         Some(if is_iterating {\n             let n = self.start.add_one();\n             mem::replace(&mut self.start, n)\n         } else {\n+            self.exhausted = true;\n             self.start.clone()\n         })\n     }\n@@ -369,8 +368,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n \n@@ -379,21 +377,20 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n             match plus_n.partial_cmp(&self.end) {\n                 Some(Less) => {\n-                    self.is_empty = Some(false);\n                     self.start = plus_n.add_one();\n                     return Some(plus_n);\n                 }\n                 Some(Equal) => {\n-                    self.is_empty = Some(true);\n                     self.start = plus_n.clone();\n+                    self.exhausted = true;\n                     return Some(plus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n         self.start = self.end.clone();\n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n         None\n     }\n \n@@ -404,8 +401,6 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Ok = B>,\n     {\n-        self.compute_is_empty();\n-\n         if self.is_empty() {\n             return Try::from_ok(init);\n         }\n@@ -418,7 +413,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n             accum = f(accum, n)?;\n         }\n \n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n \n         if self.start == self.end {\n             accum = f(accum, self.start.clone())?;\n@@ -447,24 +442,22 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n         let is_iterating = self.start < self.end;\n-        self.is_empty = Some(!is_iterating);\n         Some(if is_iterating {\n             let n = self.end.sub_one();\n             mem::replace(&mut self.end, n)\n         } else {\n+            self.exhausted = true;\n             self.end.clone()\n         })\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n \n@@ -473,21 +466,20 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n \n             match minus_n.partial_cmp(&self.start) {\n                 Some(Greater) => {\n-                    self.is_empty = Some(false);\n                     self.end = minus_n.sub_one();\n                     return Some(minus_n);\n                 }\n                 Some(Equal) => {\n-                    self.is_empty = Some(true);\n                     self.end = minus_n.clone();\n+                    self.exhausted = true;\n                     return Some(minus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n         self.end = self.start.clone();\n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n         None\n     }\n \n@@ -498,8 +490,6 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Ok = B>,\n     {\n-        self.compute_is_empty();\n-\n         if self.is_empty() {\n             return Try::from_ok(init);\n         }\n@@ -512,7 +502,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             accum = f(accum, n)?;\n         }\n \n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n \n         if self.start == self.end {\n             accum = f(accum, self.start.clone())?;"}, {"sha": "8ffad82b69d7c688816b15d7157586701f9ede7b", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e6ec0d125eba4074122b187032474b4174fb9d31/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ec0d125eba4074122b187032474b4174fb9d31/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=e6ec0d125eba4074122b187032474b4174fb9d31", "patch": "@@ -340,24 +340,21 @@ pub struct RangeInclusive<Idx> {\n     // support that mode.\n     pub(crate) start: Idx,\n     pub(crate) end: Idx,\n-    pub(crate) is_empty: Option<bool>,\n+\n     // This field is:\n-    //  - `None` when next() or next_back() was never called\n-    //  - `Some(false)` when `start < end`\n-    //  - `Some(true)` when `end < start`\n-    //  - `Some(false)` when `start == end` and the range hasn't yet completed iteration\n-    //  - `Some(true)` when `start == end` and the range has completed iteration\n-    // The field cannot be a simple `bool` because the `..=` constructor can\n-    // accept non-PartialOrd types, also we want the constructor to be const.\n+    //  - `false` upon construction\n+    //  - `false` when iteration has yielded an element and the iterator is not exhausted\n+    //  - `true` when iteration has been used to exhaust the iterator\n+    //\n+    // This is required to support PartialEq and Hash without a PartialOrd bound or specialization.\n+    pub(crate) exhausted: bool,\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n-        self.start == other.start\n-            && self.end == other.end\n-            && self.is_exhausted() == other.is_exhausted()\n+        self.start == other.start && self.end == other.end && self.exhausted == other.exhausted\n     }\n }\n \n@@ -369,8 +366,7 @@ impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.start.hash(state);\n         self.end.hash(state);\n-        // Ideally we would hash `is_exhausted` here as well, but there's no\n-        // way for us to call it.\n+        self.exhausted.hash(state);\n     }\n }\n \n@@ -389,7 +385,7 @@ impl<Idx> RangeInclusive<Idx> {\n     #[rustc_promotable]\n     #[rustc_const_stable(feature = \"const_range_new\", since = \"1.32.0\")]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self { start, end, is_empty: None }\n+        Self { start, end, exhausted: false }\n     }\n \n     /// Returns the lower bound of the range (inclusive).\n@@ -465,18 +461,13 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n         self.start.fmt(fmt)?;\n         write!(fmt, \"..=\")?;\n         self.end.fmt(fmt)?;\n+        if self.exhausted {\n+            write!(fmt, \" (exhausted)\")?;\n+        }\n         Ok(())\n     }\n }\n \n-impl<Idx: PartialEq<Idx>> RangeInclusive<Idx> {\n-    // Returns true if this is a range that started non-empty, and was iterated\n-    // to exhaustion.\n-    fn is_exhausted(&self) -> bool {\n-        Some(true) == self.is_empty && self.start == self.end\n-    }\n-}\n-\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -544,15 +535,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n-        self.is_empty.unwrap_or_else(|| !(self.start <= self.end))\n-    }\n-\n-    // If this range's `is_empty` is field is unknown (`None`), update it to be a concrete value.\n-    #[inline]\n-    pub(crate) fn compute_is_empty(&mut self) {\n-        if self.is_empty.is_none() {\n-            self.is_empty = Some(!(self.start <= self.end));\n-        }\n+        self.exhausted || !(self.start <= self.end)\n     }\n }\n "}, {"sha": "e9b05e648b442776de8cae7d6fb77e537b2f104d", "filename": "src/test/codegen/issue-45222.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e6ec0d125eba4074122b187032474b4174fb9d31/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ec0d125eba4074122b187032474b4174fb9d31/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-45222.rs?ref=e6ec0d125eba4074122b187032474b4174fb9d31", "patch": "@@ -25,28 +25,30 @@ pub fn check_foo2() -> u64 {\n }\n \n // Simplified example of #45222\n-\n-fn triangle_inc(n: u64) -> u64 {\n-    let mut count = 0;\n-    for j in 0 ..= n {\n-        count += j;\n-    }\n-    count\n-}\n-\n-// CHECK-LABEL: @check_triangle_inc\n-#[no_mangle]\n-pub fn check_triangle_inc() -> u64 {\n-    // CHECK: ret i64 5000050000\n-    triangle_inc(100000)\n-}\n+//\n+// Temporarily disabled in #68835 to fix a soundness hole.\n+//\n+// fn triangle_inc(n: u64) -> u64 {\n+//     let mut count = 0;\n+//     for j in 0 ..= n {\n+//         count += j;\n+//     }\n+//     count\n+// }\n+//\n+// // COMMENTEDCHECK-LABEL: @check_triangle_inc\n+// #[no_mangle]\n+// pub fn check_triangle_inc() -> u64 {\n+//     // COMMENTEDCHECK: ret i64 5000050000\n+//     triangle_inc(100000)\n+// }\n \n // Demo in #48012\n \n fn foo3r(n: u64) -> u64 {\n     let mut count = 0;\n     (0..n).for_each(|_| {\n-        (0 ..= n).rev().for_each(|j| {\n+        (0..=n).rev().for_each(|j| {\n             count += j;\n         })\n     });"}]}