{"sha": "b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "node_id": "C_kwDOAAsO6NoAKGI0NDE5N2FiYjBiM2ZmZTQ5MDg4OTJlMWUwOGFiMWNkNzIxZmYzYjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-05T16:21:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-05T16:21:40Z"}, "message": "Auto merge of #101261 - TaKO8Ki:separate-receiver-from-arguments-in-hir, r=cjgillot\n\nSeparate the receiver from arguments in HIR\n\nRelated to #100232\n\ncc `@cjgillot`", "tree": {"sha": "b6fb0e22306ad314d139ff05bfc3137c2cc7265a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6fb0e22306ad314d139ff05bfc3137c2cc7265a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "html_url": "https://github.com/rust-lang/rust/commit/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dc703fd6e3aaaf343828cc7dd1aec192d24c628", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dc703fd6e3aaaf343828cc7dd1aec192d24c628", "html_url": "https://github.com/rust-lang/rust/commit/2dc703fd6e3aaaf343828cc7dd1aec192d24c628"}, {"sha": "9cde34e1807208493b3975c155e0c5389820a8ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cde34e1807208493b3975c155e0c5389820a8ce", "html_url": "https://github.com/rust-lang/rust/commit/9cde34e1807208493b3975c155e0c5389820a8ce"}], "stats": {"total": 1535, "additions": 815, "deletions": 720}, "files": [{"sha": "9de7962bee3c78e737588255b134893f705095ae", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -68,10 +68,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ParenthesizedGenericArgs::Err,\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     ));\n-                    let args = self.arena.alloc_from_iter(\n-                        [&*receiver].into_iter().chain(args.iter()).map(|x| self.lower_expr_mut(x)),\n-                    );\n-                    hir::ExprKind::MethodCall(hir_seg, args, self.lower_span(span))\n+                    let receiver = self.lower_expr(receiver);\n+                    let args =\n+                        self.arena.alloc_from_iter(args.iter().map(|x| self.lower_expr_mut(x)));\n+                    hir::ExprKind::MethodCall(hir_seg, receiver, args, self.lower_span(span))\n                 }\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                     let binop = self.lower_binop(binop);"}, {"sha": "60b01e6f8680797076878b1ed19424d1ebce6853", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -711,8 +711,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                         self.suggested = true;\n-                    } else if let hir::ExprKind::MethodCall(_path, args @ [_, ..], sp) = expr.kind\n-                        && let hir::ExprKind::Index(val, index) = args[0].kind\n+                    } else if let hir::ExprKind::MethodCall(_path, receiver, _, sp) = expr.kind\n+                        && let hir::ExprKind::Index(val, index) = receiver.kind\n                         && expr.span == self.assign_span\n                     {\n                         // val[index].path(args..);\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     \".get_mut(\".to_string(),\n                                 ),\n                                 (\n-                                    index.span.shrink_to_hi().with_hi(args[0].span.hi()),\n+                                    index.span.shrink_to_hi().with_hi(receiver.span.hi()),\n                                     \").map(|val| val\".to_string(),\n                                 ),\n                                 (sp.shrink_to_hi(), \")\".to_string()),\n@@ -911,11 +911,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                                         [\n                                                             Expr {\n                                                                 kind:\n-                                                                    MethodCall(\n-                                                                        path_segment,\n-                                                                        _args,\n-                                                                        span,\n-                                                                    ),\n+                                                                    MethodCall(path_segment, _, _, span),\n                                                                 hir_id,\n                                                                 ..\n                                                             },"}, {"sha": "9615025fa5767b43e86e57b57ba9ca2c977cad46", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -900,14 +900,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut closure_span = None::<rustc_span::Span>;\n         match expr.kind {\n             hir::ExprKind::MethodCall(.., args, _) => {\n-                // only the first closre parameter of the method. args[0] is MethodCall PathSegment\n-                for i in 1..args.len() {\n+                for arg in args {\n                     if let hir::ExprKind::Closure(hir::Closure {\n                         capture_clause: hir::CaptureBy::Ref,\n                         ..\n-                    }) = args[i].kind\n+                    }) = arg.kind\n                     {\n-                        closure_span = Some(args[i].span.shrink_to_lo());\n+                        closure_span = Some(arg.span.shrink_to_lo());\n                         break;\n                     }\n                 }"}, {"sha": "9535ccfe8b69df210ab04d9923f3c665afc2211e", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -1876,19 +1876,19 @@ pub enum ExprKind<'hir> {\n     ///\n     /// The `PathSegment` represents the method name and its generic arguments\n     /// (within the angle brackets).\n-    /// The first element of the `&[Expr]` is the expression that evaluates\n+    /// The `&Expr` is the expression that evaluates\n     /// to the object on which the method is being called on (the receiver),\n-    /// and the remaining elements are the rest of the arguments.\n+    /// and the `&[Expr]` is the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d], span)`.\n+    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, x, [a, b, c, d], span)`.\n     /// The final `Span` represents the span of the function and arguments\n     /// (e.g. `foo::<Bar, Baz>(a, b, c, d)` in `x.foo::<Bar, Baz>(a, b, c, d)`\n     ///\n     /// To resolve the called method to a `DefId`, call [`type_dependent_def_id`] with\n     /// the `hir_id` of the `MethodCall` node itself.\n     ///\n     /// [`type_dependent_def_id`]: ../../rustc_middle/ty/struct.TypeckResults.html#method.type_dependent_def_id\n-    MethodCall(&'hir PathSegment<'hir>, &'hir [Expr<'hir>], Span),\n+    MethodCall(&'hir PathSegment<'hir>, &'hir Expr<'hir>, &'hir [Expr<'hir>], Span),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(&'hir [Expr<'hir>]),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n@@ -3492,8 +3492,8 @@ mod size_asserts {\n     // These are in alphabetical order, which is easy to maintain.\n     static_assert_size!(Block<'_>, 48);\n     static_assert_size!(Body<'_>, 32);\n-    static_assert_size!(Expr<'_>, 56);\n-    static_assert_size!(ExprKind<'_>, 40);\n+    static_assert_size!(Expr<'_>, 64);\n+    static_assert_size!(ExprKind<'_>, 48);\n     static_assert_size!(FnDecl<'_>, 40);\n     static_assert_size!(ForeignItem<'_>, 72);\n     static_assert_size!(ForeignItemKind<'_>, 40);"}, {"sha": "20ec788463ac011e9938b6a4f0372125091afe1d", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -1094,8 +1094,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(ref segment, arguments, _) => {\n+        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n             visitor.visit_path_segment(expression.span, segment);\n+            visitor.visit_expr(receiver);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n         ExprKind::Binary(_, ref left_expression, ref right_expression) => {"}, {"sha": "36a6f2065768eaa497491594d96871249ba49856", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -1181,9 +1181,14 @@ impl<'a> State<'a> {\n         self.print_call_post(args)\n     }\n \n-    fn print_expr_method_call(&mut self, segment: &hir::PathSegment<'_>, args: &[hir::Expr<'_>]) {\n-        let base_args = &args[1..];\n-        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n+    fn print_expr_method_call(\n+        &mut self,\n+        segment: &hir::PathSegment<'_>,\n+        receiver: &hir::Expr<'_>,\n+        args: &[hir::Expr<'_>],\n+    ) {\n+        let base_args = args;\n+        self.print_expr_maybe_paren(&receiver, parser::PREC_POSTFIX);\n         self.word(\".\");\n         self.print_ident(segment.ident);\n \n@@ -1394,8 +1399,8 @@ impl<'a> State<'a> {\n             hir::ExprKind::Call(func, args) => {\n                 self.print_expr_call(func, args);\n             }\n-            hir::ExprKind::MethodCall(segment, args, _) => {\n-                self.print_expr_method_call(segment, args);\n+            hir::ExprKind::MethodCall(segment, receiver, args, _) => {\n+                self.print_expr_method_call(segment, receiver, args);\n             }\n             hir::ExprKind::Binary(op, lhs, rhs) => {\n                 self.print_expr_binary(op, lhs, rhs);\n@@ -2393,9 +2398,9 @@ fn contains_exterior_struct_lit(value: &hir::Expr<'_>) -> bool {\n             contains_exterior_struct_lit(x)\n         }\n \n-        hir::ExprKind::MethodCall(.., exprs, _) => {\n+        hir::ExprKind::MethodCall(_, receiver, ..) => {\n             // `X { y: 1 }.bar(...)`\n-            contains_exterior_struct_lit(&exprs[0])\n+            contains_exterior_struct_lit(receiver)\n         }\n \n         _ => false,"}, {"sha": "232b9b11455db3612c44d68dd557ad6885b9a45e", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -901,7 +901,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::MethodCall(segment, _, _) => {\n+            hir::ExprKind::MethodCall(segment, ..) => {\n                 if let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id) {\n                     let generics = tcx.generics_of(def_id);\n                     let insertable: Option<_> = try {\n@@ -1132,7 +1132,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n                 let generic_args = &generics.own_substs_no_defaults(tcx, substs)\n                     [generics.own_counts().lifetimes..];\n                 let span = match expr.kind {\n-                    ExprKind::MethodCall(path, _, _) => path.ident.span,\n+                    ExprKind::MethodCall(path, ..) => path.ident.span,\n                     _ => expr.span,\n                 };\n \n@@ -1181,20 +1181,20 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n             })\n             .any(|generics| generics.has_impl_trait())\n         };\n-        if let ExprKind::MethodCall(path, args, span) = expr.kind\n+        if let ExprKind::MethodCall(path, receiver, args, span) = expr.kind\n             && let Some(substs) = self.node_substs_opt(expr.hir_id)\n             && substs.iter().any(|arg| self.generic_arg_contains_target(arg))\n             && let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id)\n             && self.infcx.tcx.trait_of_item(def_id).is_some()\n             && !has_impl_trait(def_id)\n         {\n             let successor =\n-                args.get(1).map_or_else(|| (\")\", span.hi()), |arg| (\", \", arg.span.lo()));\n+                args.get(0).map_or_else(|| (\")\", span.hi()), |arg| (\", \", arg.span.lo()));\n             let substs = self.infcx.resolve_vars_if_possible(substs);\n             self.update_infer_source(InferSource {\n                 span: path.ident.span,\n                 kind: InferSourceKind::FullyQualifiedMethodCall {\n-                    receiver: args.first().unwrap(),\n+                    receiver,\n                     successor,\n                     substs,\n                     def_id,"}, {"sha": "b97f8acb37f8442d7152d0e12f01fe9fac4db493", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n         }\n \n         // We only care about method call expressions.\n-        if let hir::ExprKind::MethodCall(call, args, _) = &expr.kind {\n+        if let hir::ExprKind::MethodCall(call, receiver_arg, ..) = &expr.kind {\n             if call.ident.name != sym::into_iter {\n                 return;\n             }\n@@ -75,7 +75,6 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n             };\n \n             // As this is a method call expression, we have at least one argument.\n-            let receiver_arg = &args[0];\n             let receiver_ty = cx.typeck_results().expr_ty(receiver_arg);\n             let adjustments = cx.typeck_results().expr_adjustments(receiver_arg);\n "}, {"sha": "7d62d5ac98d6ec2e8b87ed9b1c521a847d977504", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -2412,13 +2412,13 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         _ => {}\n                     }\n                 }\n-            } else if let hir::ExprKind::MethodCall(_, ref args, _) = expr.kind {\n+            } else if let hir::ExprKind::MethodCall(_, receiver, ..) = expr.kind {\n                 // Find problematic calls to `MaybeUninit::assume_init`.\n                 let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n                 if cx.tcx.is_diagnostic_item(sym::assume_init, def_id) {\n                     // This is a call to *some* method named `assume_init`.\n                     // See if the `self` parameter is one of the dangerous constructors.\n-                    if let hir::ExprKind::Call(ref path_expr, _) = args[0].kind {\n+                    if let hir::ExprKind::Call(ref path_expr, _) = receiver.kind {\n                         if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                             let def_id = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n                             match cx.tcx.get_diagnostic_name(def_id) {"}, {"sha": "dd1fc5916dbff71edd2550d5aacaaa3b6bec2049", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -51,7 +51,7 @@ fn typeck_results_of_method_fn<'tcx>(\n     expr: &Expr<'_>,\n ) -> Option<(Span, DefId, ty::subst::SubstsRef<'tcx>)> {\n     match expr.kind {\n-        ExprKind::MethodCall(segment, _, _)\n+        ExprKind::MethodCall(segment, ..)\n             if let Some(def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) =>\n         {\n             Some((segment.ident.span, def_id, cx.typeck_results().node_substs(expr.hir_id)))"}, {"sha": "5f7f03480c043b07e58815012b35ff2b8418705c", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -44,9 +44,13 @@ fn in_macro(span: Span) -> bool {\n \n fn first_method_call<'tcx>(\n     expr: &'tcx Expr<'tcx>,\n-) -> Option<(&'tcx PathSegment<'tcx>, &'tcx [Expr<'tcx>])> {\n-    if let ExprKind::MethodCall(path, args, _) = &expr.kind {\n-        if args.iter().any(|e| e.span.from_expansion()) { None } else { Some((path, *args)) }\n+) -> Option<(&'tcx PathSegment<'tcx>, &'tcx Expr<'tcx>)> {\n+    if let ExprKind::MethodCall(path, receiver, args, ..) = &expr.kind {\n+        if args.iter().any(|e| e.span.from_expansion()) || receiver.span.from_expansion() {\n+            None\n+        } else {\n+            Some((path, *receiver))\n+        }\n     } else {\n         None\n     }\n@@ -59,15 +63,13 @@ impl<'tcx> LateLintPass<'tcx> for TemporaryCStringAsPtr {\n         }\n \n         match first_method_call(expr) {\n-            Some((path, args)) if path.ident.name == sym::as_ptr => {\n-                let unwrap_arg = &args[0];\n+            Some((path, unwrap_arg)) if path.ident.name == sym::as_ptr => {\n                 let as_ptr_span = path.ident.span;\n                 match first_method_call(unwrap_arg) {\n-                    Some((path, args))\n+                    Some((path, receiver))\n                         if path.ident.name == sym::unwrap || path.ident.name == sym::expect =>\n                     {\n-                        let source_arg = &args[0];\n-                        lint_cstring_as_ptr(cx, as_ptr_span, source_arg, unwrap_arg);\n+                        lint_cstring_as_ptr(cx, as_ptr_span, receiver, unwrap_arg);\n                     }\n                     _ => return,\n                 }"}, {"sha": "d1449496d331578be434f7053145359d05767316", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -41,7 +41,7 @@ declare_lint_pass!(NoopMethodCall => [NOOP_METHOD_CALL]);\n impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // We only care about method calls.\n-        let ExprKind::MethodCall(call, elements, _) = &expr.kind else {\n+        let ExprKind::MethodCall(call, receiver, ..) = &expr.kind else {\n             return\n         };\n         // We only care about method calls corresponding to the `Clone`, `Deref` and `Borrow`\n@@ -81,7 +81,6 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n         ) {\n             return;\n         }\n-        let receiver = &elements[0];\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);\n         let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n         if receiver_ty != expr_ty {"}, {"sha": "9736b5557036c8093ca966819030b1ebb544bafc", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -1458,7 +1458,7 @@ impl InvalidAtomicOrdering {\n             sym::AtomicI64,\n             sym::AtomicI128,\n         ];\n-        if let ExprKind::MethodCall(ref method_path, args, _) = &expr.kind\n+        if let ExprKind::MethodCall(ref method_path, _, args, _) = &expr.kind\n             && recognized_names.contains(&method_path.ident.name)\n             && let Some(m_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id)\n             && let Some(impl_did) = cx.tcx.impl_of_method(m_def_id)\n@@ -1494,8 +1494,8 @@ impl InvalidAtomicOrdering {\n     fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store])\n             && let Some((ordering_arg, invalid_ordering)) = match method {\n-                sym::load => Some((&args[1], sym::Release)),\n-                sym::store => Some((&args[2], sym::Acquire)),\n+                sym::load => Some((&args[0], sym::Release)),\n+                sym::store => Some((&args[1], sym::Acquire)),\n                 _ => None,\n             }\n             && let Some(ordering) = Self::match_ordering(cx, ordering_arg)\n@@ -1536,8 +1536,8 @@ impl InvalidAtomicOrdering {\n             else {return };\n \n         let fail_order_arg = match method {\n-            sym::fetch_update => &args[2],\n-            sym::compare_exchange | sym::compare_exchange_weak => &args[4],\n+            sym::fetch_update => &args[1],\n+            sym::compare_exchange | sym::compare_exchange_weak => &args[3],\n             _ => return,\n         };\n "}, {"sha": "d059877f8e71fcb481258efc1c8aa5698835479c", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -261,15 +261,19 @@ impl<'tcx> Cx<'tcx> {\n \n         let kind = match expr.kind {\n             // Here comes the interesting stuff:\n-            hir::ExprKind::MethodCall(segment, ref args, fn_span) => {\n+            hir::ExprKind::MethodCall(segment, receiver, ref args, fn_span) => {\n                 // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n                 let expr = self.method_callee(expr, segment.ident.span, None);\n                 // When we apply adjustments to the receiver, use the span of\n                 // the overall method call for better diagnostics. args[0]\n                 // is guaranteed to exist, since a method call always has a receiver.\n-                let old_adjustment_span = self.adjustment_span.replace((args[0].hir_id, expr_span));\n+                let old_adjustment_span =\n+                    self.adjustment_span.replace((receiver.hir_id, expr_span));\n                 info!(\"Using method span: {:?}\", expr.span);\n-                let args = self.mirror_exprs(args);\n+                let args = std::iter::once(receiver)\n+                    .chain(args.iter())\n+                    .map(|expr| self.mirror_expr(expr))\n+                    .collect();\n                 self.adjustment_span = old_adjustment_span;\n                 ExprKind::Call {\n                     ty: expr.ty,"}, {"sha": "6a4cd79cde7128080ac4ce97922e65562aff3783", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -1039,9 +1039,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 self.propagate_through_expr(&f, succ)\n             }\n \n-            hir::ExprKind::MethodCall(.., ref args, _) => {\n+            hir::ExprKind::MethodCall(.., receiver, ref args, _) => {\n                 let succ = self.check_is_ty_uninhabited(expr, succ);\n-                self.propagate_through_exprs(args, succ)\n+                let succ = self.propagate_through_exprs(args, succ);\n+                self.propagate_through_expr(receiver, succ)\n             }\n \n             hir::ExprKind::Tup(ref exprs) => self.propagate_through_exprs(exprs, succ),"}, {"sha": "6658892881d4b9bbf365734f6d83a9e938890c2c", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -803,6 +803,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         &mut self,\n         ex: &'tcx hir::Expr<'tcx>,\n         seg: &'tcx hir::PathSegment<'tcx>,\n+        receiver: &'tcx hir::Expr<'tcx>,\n         args: &'tcx [hir::Expr<'tcx>],\n     ) {\n         debug!(\"process_method_call {:?} {:?}\", ex, ex.span);\n@@ -823,6 +824,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         // walk receiver and args\n+        self.visit_expr(receiver);\n         walk_list!(self, visit_expr, args);\n     }\n \n@@ -1343,7 +1345,9 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 let res = self.save_ctxt.get_path_res(hir_expr.hir_id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *rest)\n             }\n-            hir::ExprKind::MethodCall(ref seg, args, _) => self.process_method_call(ex, seg, args),\n+            hir::ExprKind::MethodCall(ref seg, receiver, args, _) => {\n+                self.process_method_call(ex, seg, receiver, args)\n+            }\n             hir::ExprKind::Field(ref sub_ex, _) => {\n                 self.visit_expr(&sub_ex);\n "}, {"sha": "d078252ebd4e2fadf6b9ce12eb9ac305706c7c61", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -590,15 +590,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let closure_params_len = closure_fn_decl.inputs.len();\n         let (\n             Some(Node::Expr(hir::Expr {\n-                kind: hir::ExprKind::MethodCall(method_path, method_expr, _),\n+                kind: hir::ExprKind::MethodCall(method_path, receiver, ..),\n                 ..\n             })),\n             1,\n         ) = (hir, closure_params_len) else {\n             return None;\n         };\n \n-        let self_ty = self.typeck_results.borrow().expr_ty(&method_expr[0]);\n+        let self_ty = self.typeck_results.borrow().expr_ty(receiver);\n         let name = method_path.ident.name;\n         let is_as_ref_able = match self_ty.peel_refs().kind() {\n             ty::Adt(def, _) => {\n@@ -767,22 +767,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n                     let mut sugg_sp = sp;\n-                    if let hir::ExprKind::MethodCall(ref segment, ref args, _) = expr.kind {\n+                    if let hir::ExprKind::MethodCall(ref segment, receiver, args, _) = expr.kind {\n                         let clone_trait =\n                             self.tcx.require_lang_item(LangItem::Clone, Some(segment.ident.span));\n-                        if let ([arg], Some(true), sym::clone) = (\n-                            &args[..],\n-                            self.typeck_results.borrow().type_dependent_def_id(expr.hir_id).map(\n+                        if args.is_empty()\n+                            && self.typeck_results.borrow().type_dependent_def_id(expr.hir_id).map(\n                                 |did| {\n                                     let ai = self.tcx.associated_item(did);\n                                     ai.trait_container(self.tcx) == Some(clone_trait)\n                                 },\n-                            ),\n-                            segment.ident.name,\n-                        ) {\n+                            ) == Some(true)\n+                            && segment.ident.name == sym::clone\n+                        {\n                             // If this expression had a clone call when suggesting borrowing\n                             // we want to suggest removing it because it'd now be unnecessary.\n-                            sugg_sp = arg.span;\n+                            sugg_sp = receiver.span;\n                         }\n                     }\n                     if let Ok(src) = sm.span_to_snippet(sugg_sp) {"}, {"sha": "e4141647d7d2df66fd8b99a8e83ce89a68def8f9", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -324,8 +324,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ExprKind::Block(body, _) => self.check_block_with_expected(&body, expected),\n             ExprKind::Call(callee, args) => self.check_call(expr, &callee, args, expected),\n-            ExprKind::MethodCall(segment, args, _) => {\n-                self.check_method_call(expr, segment, args, expected)\n+            ExprKind::MethodCall(segment, receiver, args, _) => {\n+                self.check_method_call(expr, segment, receiver, args, expected)\n             }\n             ExprKind::Cast(e, t) => self.check_expr_cast(e, t, expr),\n             ExprKind::Type(e, t) => {\n@@ -1195,13 +1195,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         segment: &hir::PathSegment<'_>,\n+        rcvr: &'tcx hir::Expr<'tcx>,\n         args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        let rcvr = &args[0];\n         let rcvr_t = self.check_expr(&rcvr);\n         // no need to check for bot/err -- callee does that\n-        let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n+        let rcvr_t = self.structurally_resolved_type(rcvr.span, rcvr_t);\n         let span = segment.ident.span;\n \n         let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr, args) {\n@@ -1218,9 +1218,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         rcvr_t,\n                         segment.ident,\n-                        SelfSource::MethodCall(&args[0]),\n+                        SelfSource::MethodCall(rcvr),\n                         error,\n-                        Some(args),\n+                        Some((rcvr, args)),\n                     ) {\n                         err.emit();\n                     }\n@@ -1230,14 +1230,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Call the generic checker.\n-        self.check_method_argument_types(\n-            span,\n-            expr,\n-            method,\n-            &args[1..],\n-            DontTupleArguments,\n-            expected,\n-        )\n+        self.check_method_argument_types(span, expr, method, &args, DontTupleArguments, expected)\n     }\n \n     fn check_expr_cast("}, {"sha": "c59638f5d6f9f77a6a98c0c4b6103342a0cad91b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -987,7 +987,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if found != self.tcx.types.unit {\n             return;\n         }\n-        if let ExprKind::MethodCall(path_segment, [rcvr, ..], _) = expr.kind {\n+        if let ExprKind::MethodCall(path_segment, rcvr, ..) = expr.kind {\n             if self\n                 .typeck_results\n                 .borrow()"}, {"sha": "9157b83330dd6ba54a4016cbb02c6c7f68ccd683", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -478,7 +478,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             hir::ExprKind::Call(hir::Expr { span, .. }, _) => (call_span, *span, None, false),\n-            hir::ExprKind::MethodCall(path_segment, _, span) => {\n+            hir::ExprKind::MethodCall(path_segment, _, _, span) => {\n                 let ident_span = path_segment.ident.span;\n                 let ident_span = if let Some(args) = path_segment.args {\n                     ident_span.with_hi(args.span_ext.hi())\n@@ -530,13 +530,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect();\n         let callee_expr = match &call_expr.peel_blocks().kind {\n             hir::ExprKind::Call(callee, _) => Some(*callee),\n-            hir::ExprKind::MethodCall(_, callee, _) => {\n+            hir::ExprKind::MethodCall(_, receiver, ..) => {\n                 if let Some((DefKind::AssocFn, def_id)) =\n                     self.typeck_results.borrow().type_dependent_def(call_expr.hir_id)\n                     && let Some(assoc) = tcx.opt_associated_item(def_id)\n                     && assoc.fn_has_self_parameter\n                 {\n-                    Some(&callee[0])\n+                    Some(*receiver)\n                 } else {\n                     None\n                 }\n@@ -1805,6 +1805,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 param,\n                                 *call_hir_id,\n                                 callee.span,\n+                                None,\n                                 args,\n                             )\n                         {\n@@ -1823,7 +1824,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::MethodCall(segment, args, ..) => {\n+            hir::ExprKind::MethodCall(segment, receiver, args, ..) => {\n                 for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n                     .into_iter()\n                     .flatten()\n@@ -1834,6 +1835,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         param,\n                         hir_id,\n                         segment.ident.span,\n+                        Some(receiver),\n                         args,\n                     ) {\n                         return true;\n@@ -1901,7 +1903,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         param_to_point_at: ty::GenericArg<'tcx>,\n         call_hir_id: hir::HirId,\n         callee_span: Span,\n-        args: &[hir::Expr<'tcx>],\n+        receiver: Option<&'tcx hir::Expr<'tcx>>,\n+        args: &'tcx [hir::Expr<'tcx>],\n     ) -> bool {\n         let sig = self.tcx.fn_sig(def_id).skip_binder();\n         let args_referencing_param: Vec<_> = sig\n@@ -1910,9 +1913,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .enumerate()\n             .filter(|(_, ty)| find_param_in_ty(**ty, param_to_point_at))\n             .collect();\n-\n         // If there's one field that references the given generic, great!\n-        if let [(idx, _)] = args_referencing_param.as_slice() && let Some(arg) = args.get(*idx) {\n+        if let [(idx, _)] = args_referencing_param.as_slice()\n+            && let Some(arg) = receiver\n+                .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n             error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n             error.obligation.cause.map_code(|parent_code| {\n                 ObligationCauseCode::FunctionArgumentObligation {"}, {"sha": "3d9677ecf75c7f8934206dcdb92e55ca91337359", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -1049,7 +1049,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found_ty: Ty<'tcx>,\n         expr: &hir::Expr<'_>,\n     ) {\n-        let hir::ExprKind::MethodCall(segment, &[ref callee_expr], _) = expr.kind else { return; };\n+        let hir::ExprKind::MethodCall(segment, callee_expr, &[], _) = expr.kind else { return; };\n         let Some(clone_trait_did) = self.tcx.lang_items().clone_trait() else { return; };\n         let ty::Ref(_, pointee_ty, _) = found_ty.kind() else { return };\n         let results = self.typeck_results.borrow();"}, {"sha": "016f4056bd90302ad9aeb4553a9802d878c5e5b0", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -434,7 +434,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n \n                 self.handle_uninhabited_return(expr);\n             }\n-            ExprKind::MethodCall(_, exprs, _) => {\n+            ExprKind::MethodCall(_, receiver, exprs, _) => {\n+                self.visit_expr(receiver);\n                 for expr in exprs {\n                     self.visit_expr(expr);\n                 }"}, {"sha": "392695cca6849fd09ad026dce49981875915c645", "filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -160,7 +160,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if precise {\n                         let args = args\n                             .iter()\n-                            .skip(1)\n                             .map(|arg| {\n                                 let span = arg.span.find_ancestor_inside(sp).unwrap_or_default();\n                                 format!("}, {"sha": "124ac5c24fa5cef0ae58199d2318a92a98b12446", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         item_name: Ident,\n         source: SelfSource<'tcx>,\n         error: MethodError<'tcx>,\n-        args: Option<&'tcx [hir::Expr<'tcx>]>,\n+        args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n     ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n@@ -998,7 +998,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         rcvr_ty,\n                         item_name,\n-                        args.map(|args| args.len()),\n+                        args.map(|(_, args)| args.len() + 1),\n                         source,\n                         out_of_scope_traits,\n                         &unsatisfied_predicates,\n@@ -2310,7 +2310,7 @@ pub fn all_traits(tcx: TyCtxt<'_>) -> Vec<TraitInfo> {\n \n fn print_disambiguation_help<'tcx>(\n     item_name: Ident,\n-    args: Option<&'tcx [hir::Expr<'tcx>]>,\n+    args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n     err: &mut Diagnostic,\n     trait_name: String,\n     rcvr_ty: Ty<'_>,\n@@ -2322,15 +2322,16 @@ fn print_disambiguation_help<'tcx>(\n     fn_has_self_parameter: bool,\n ) {\n     let mut applicability = Applicability::MachineApplicable;\n-    let (span, sugg) = if let (ty::AssocKind::Fn, Some(args)) = (kind, args) {\n+    let (span, sugg) = if let (ty::AssocKind::Fn, Some((receiver, args))) = (kind, args) {\n         let args = format!(\n             \"({}{})\",\n             if rcvr_ty.is_region_ptr() {\n                 if rcvr_ty.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n             } else {\n                 \"\"\n             },\n-            args.iter()\n+            std::iter::once(receiver)\n+                .chain(args.iter())\n                 .map(|arg| source_map.span_to_snippet(arg.span).unwrap_or_else(|_| {\n                     applicability = Applicability::HasPlaceholders;\n                     \"_\".to_owned()"}, {"sha": "f483342b445f60471f3c643dea136efd0b696cfa", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -233,8 +233,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_exprs(args);\n             }\n \n-            hir::ExprKind::MethodCall(.., args, _) => {\n+            hir::ExprKind::MethodCall(.., receiver, args, _) => {\n                 // callee.m(args)\n+                self.consume_expr(receiver);\n                 self.consume_exprs(args);\n             }\n "}, {"sha": "cddb0ce2346ad7a56f16ab714bdba9bcf9fd0944", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -755,13 +755,13 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         num_assoc_fn_excess_args: usize,\n         num_trait_generics_except_self: usize,\n     ) {\n-        if let hir::ExprKind::MethodCall(_, args, _) = expr.kind {\n-            assert_eq!(args.len(), 1);\n+        if let hir::ExprKind::MethodCall(_, receiver, args, ..) = expr.kind {\n+            assert_eq!(args.len(), 0);\n             if num_assoc_fn_excess_args == num_trait_generics_except_self {\n                 if let Some(gen_args) = self.gen_args.span_ext()\n                 && let Ok(gen_args) = self.tcx.sess.source_map().span_to_snippet(gen_args)\n-                && let Ok(args) = self.tcx.sess.source_map().span_to_snippet(args[0].span) {\n-                    let sugg = format!(\"{}::{}::{}({})\", self.tcx.item_name(trait_), gen_args, self.tcx.item_name(self.def_id), args);\n+                && let Ok(receiver) = self.tcx.sess.source_map().span_to_snippet(receiver.span) {\n+                    let sugg = format!(\"{}::{}::{}({})\", self.tcx.item_name(trait_), gen_args, self.tcx.item_name(self.def_id), receiver);\n                     err.span_suggestion(expr.span, msg, sugg, Applicability::MaybeIncorrect);\n                 }\n             }"}, {"sha": "4ac60b10c92ef08a2fab4f648ae7271043f3d04b", "filename": "library/portable-simd/crates/std_float/src/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/library%2Fportable-simd%2Fcrates%2Fstd_float%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/library%2Fportable-simd%2Fcrates%2Fstd_float%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fstd_float%2Fsrc%2Flib.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -1,9 +1,5 @@\n #![cfg_attr(feature = \"as_crate\", no_std)] // We are std!\n-#![cfg_attr(\n-    feature = \"as_crate\",\n-    feature(platform_intrinsics),\n-    feature(portable_simd)\n-)]\n+#![cfg_attr(feature = \"as_crate\", feature(platform_intrinsics), feature(portable_simd))]\n #[cfg(not(feature = \"as_crate\"))]\n use core::simd;\n #[cfg(feature = \"as_crate\")]"}, {"sha": "ca86ac89e8583a7b16a3b52c4e34a7438c94901d", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -159,7 +159,7 @@ where\n                     return;\n                 }\n             }\n-            hir::ExprKind::MethodCall(path, _, call_span) => {\n+            hir::ExprKind::MethodCall(path, _, _, call_span) => {\n                 let types = tcx.typeck(ex.hir_id.owner);\n                 let Some(def_id) = types.type_dependent_def_id(ex.hir_id) else {\n                     trace!(\"type_dependent_def_id({}) = None\", ex.hir_id);"}, {"sha": "0a736f7be834e6da66083c655a68db6dd3999ac2", "filename": "src/test/ui/stats/hir-stats.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -121,15 +121,15 @@ hir-stats ----------------------------------------------------------------\n hir-stats ForeignItemRef            24 ( 0.2%)             1            24\n hir-stats Mod                       32 ( 0.3%)             1            32\n hir-stats ExprField                 40 ( 0.4%)             1            40\n-hir-stats TraitItemRef              56 ( 0.6%)             2            28\n+hir-stats TraitItemRef              56 ( 0.5%)             2            28\n hir-stats Param                     64 ( 0.6%)             2            32\n hir-stats Local                     64 ( 0.6%)             1            64\n hir-stats InlineAsm                 72 ( 0.7%)             1            72\n hir-stats ImplItemRef               72 ( 0.7%)             2            36\n-hir-stats FieldDef                  96 ( 1.0%)             2            48\n-hir-stats Arm                       96 ( 1.0%)             2            48\n-hir-stats Body                      96 ( 1.0%)             3            32\n-hir-stats Stmt                      96 ( 1.0%)             3            32\n+hir-stats FieldDef                  96 ( 0.9%)             2            48\n+hir-stats Arm                       96 ( 0.9%)             2            48\n+hir-stats Body                      96 ( 0.9%)             3            32\n+hir-stats Stmt                      96 ( 0.9%)             3            32\n hir-stats - Local                     32 ( 0.3%)             1\n hir-stats - Semi                      32 ( 0.3%)             1\n hir-stats - Expr                      32 ( 0.3%)             1\n@@ -144,34 +144,34 @@ hir-stats GenericBound             192 ( 1.9%)             4            48\n hir-stats - Trait                    192 ( 1.9%)             4\n hir-stats WherePredicate           216 ( 2.1%)             3            72\n hir-stats - BoundPredicate           216 ( 2.1%)             3\n-hir-stats Block                    288 ( 2.9%)             6            48\n-hir-stats GenericParam             400 ( 4.0%)             5            80\n-hir-stats Pat                      440 ( 4.4%)             5            88\n+hir-stats Block                    288 ( 2.8%)             6            48\n+hir-stats GenericParam             400 ( 3.9%)             5            80\n+hir-stats Pat                      440 ( 4.3%)             5            88\n hir-stats - Wild                      88 ( 0.9%)             1\n hir-stats - Struct                    88 ( 0.9%)             1\n hir-stats - Binding                  264 ( 2.6%)             3\n hir-stats Generics                 560 ( 5.5%)            10            56\n-hir-stats Expr                     672 ( 6.7%)            12            56\n-hir-stats - Path                      56 ( 0.6%)             1\n-hir-stats - Struct                    56 ( 0.6%)             1\n-hir-stats - Match                     56 ( 0.6%)             1\n-hir-stats - InlineAsm                 56 ( 0.6%)             1\n-hir-stats - Lit                      112 ( 1.1%)             2\n-hir-stats - Block                    336 ( 3.3%)             6\n-hir-stats Item                     960 ( 9.5%)            12            80\n+hir-stats Expr                     768 ( 7.5%)            12            64\n+hir-stats - Path                      64 ( 0.6%)             1\n+hir-stats - Struct                    64 ( 0.6%)             1\n+hir-stats - Match                     64 ( 0.6%)             1\n+hir-stats - InlineAsm                 64 ( 0.6%)             1\n+hir-stats - Lit                      128 ( 1.3%)             2\n+hir-stats - Block                    384 ( 3.8%)             6\n+hir-stats Item                     960 ( 9.4%)            12            80\n hir-stats - Trait                     80 ( 0.8%)             1\n hir-stats - Enum                      80 ( 0.8%)             1\n hir-stats - ExternCrate               80 ( 0.8%)             1\n hir-stats - ForeignMod                80 ( 0.8%)             1\n hir-stats - Impl                      80 ( 0.8%)             1\n hir-stats - Fn                       160 ( 1.6%)             2\n-hir-stats - Use                      400 ( 4.0%)             5\n-hir-stats Ty                     1_080 (10.7%)            15            72\n+hir-stats - Use                      400 ( 3.9%)             5\n+hir-stats Ty                     1_080 (10.6%)            15            72\n hir-stats - Ptr                       72 ( 0.7%)             1\n hir-stats - Rptr                      72 ( 0.7%)             1\n-hir-stats - Path                     936 ( 9.3%)            13\n-hir-stats Path                   1_536 (15.2%)            32            48\n-hir-stats PathSegment            2_240 (22.2%)            40            56\n+hir-stats - Path                     936 ( 9.2%)            13\n+hir-stats Path                   1_536 (15.1%)            32            48\n+hir-stats PathSegment            2_240 (22.0%)            40            56\n hir-stats ----------------------------------------------------------------\n-hir-stats Total                 10_104\n+hir-stats Total                 10_200\n hir-stats"}, {"sha": "2bc275ceff0be50cad4cabffd08cbe40e1751958", "filename": "src/tools/clippy/book/src/development/common_tools_writing_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -66,7 +66,7 @@ Starting with an `expr`, you can check whether it is calling a specific method\n impl<'tcx> LateLintPass<'tcx> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         // Check our expr is calling a method\n-        if let hir::ExprKind::MethodCall(path, _, [_self_arg, ..]) = &expr.kind\n+        if let hir::ExprKind::MethodCall(path, _, _self_arg, ..) = &expr.kind\n             // Check the name of this method is `some_method`\n             && path.ident.name == sym!(some_method)\n             // Optionally, check the type of the self argument."}, {"sha": "7cd198ace86c0e3ff3f3edf4c9b44dc862b68429", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_result_states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_result_states.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_result_states.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_result_states.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnResultStates {\n             && matches!(cx.tcx.get_diagnostic_name(macro_call.def_id), Some(sym::assert_macro))\n             && let Some((condition, panic_expn)) = find_assert_args(cx, e, macro_call.expn)\n             && matches!(panic_expn, PanicExpn::Empty)\n-            && let ExprKind::MethodCall(method_segment, [recv], _) = condition.kind\n+            && let ExprKind::MethodCall(method_segment, recv, [], _) = condition.kind\n             && let result_type_with_refs = cx.typeck_results().expr_ty(recv)\n             && let result_type = result_type_with_refs.peel_refs()\n             && is_type_diagnostic_item(cx, result_type, sym::Result)"}, {"sha": "d9e2c9c8578f711f2a4f3c2a6185edbfafecefb8", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n             // do not lint if the closure is called using an iterator (see #1141)\n             if_chain! {\n                 if let Some(parent) = get_parent_expr(self.cx, expr);\n-                if let ExprKind::MethodCall(_, [self_arg, ..], _) = &parent.kind;\n+                if let ExprKind::MethodCall(_, self_arg, ..) = &parent.kind;\n                 let caller = self.cx.typeck_results().expr_ty(self_arg);\n                 if let Some(iter_id) = self.cx.tcx.get_diagnostic_item(sym::Iterator);\n                 if implements_trait(self.cx, caller, iter_id, &[]);\n@@ -117,7 +117,8 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                             );\n                         }\n                     } else {\n-                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n+                        let span =\n+                            block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n                         if span.from_expansion() || expr.span.from_expansion() {\n                             return;\n                         }"}, {"sha": "656d639f0efd9838c272c92d6aa0e5d2e3fa7179", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -270,8 +270,8 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n                 ))\n             })\n         },\n-        ExprKind::MethodCall(path, args, _) if args.len() == 1 => {\n-            let type_of_receiver = cx.typeck_results().expr_ty(&args[0]);\n+        ExprKind::MethodCall(path, receiver, [], _) => {\n+            let type_of_receiver = cx.typeck_results().expr_ty(receiver);\n             if !is_type_diagnostic_item(cx, type_of_receiver, sym::Option)\n                 && !is_type_diagnostic_item(cx, type_of_receiver, sym::Result)\n             {\n@@ -285,7 +285,7 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n                     let path: &str = path.ident.name.as_str();\n                     a == path\n                 })\n-                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snippet_opt(cx, args[0].span)?, neg_method)))\n+                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snippet_opt(cx, receiver.span)?, neg_method)))\n         },\n         _ => None,\n     }"}, {"sha": "3f1edabe6c5040621bb2903b0df2e2ea07843270", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_abs_to_unsigned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -20,7 +20,7 @@ pub(super) fn check(\n     if meets_msrv(msrv, msrvs::UNSIGNED_ABS)\n         && let ty::Int(from) = cast_from.kind()\n         && let ty::Uint(to) = cast_to.kind()\n-        && let ExprKind::MethodCall(method_path, args, _) = cast_expr.kind\n+        && let ExprKind::MethodCall(method_path, receiver, ..) = cast_expr.kind\n         && method_path.ident.name.as_str() == \"abs\"\n     {\n         let span = if from.bit_width() == to.bit_width() {\n@@ -37,7 +37,7 @@ pub(super) fn check(\n             span,\n             &format!(\"casting the result of `{cast_from}::abs()` to {cast_to}\"),\n             \"replace with\",\n-            format!(\"{}.unsigned_abs()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n+            format!(\"{}.unsigned_abs()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             Applicability::MachineApplicable,\n         );\n     }"}, {"sha": "406547a4454e6a1abeb91b894a599f36c9109191", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -44,7 +44,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n                 .saturating_sub(constant_int(cx, right).map_or(0, |s| u64::try_from(s).expect(\"shift too high\"))),\n             _ => nbits,\n         },\n-        ExprKind::MethodCall(method, [left, right], _) => {\n+        ExprKind::MethodCall(method, left, [right], _) => {\n             if signed {\n                 return nbits;\n             }\n@@ -55,7 +55,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n             };\n             apply_reductions(cx, nbits, left, signed).min(max_bits.unwrap_or(u64::max_value()))\n         },\n-        ExprKind::MethodCall(method, [_, lo, hi], _) => {\n+        ExprKind::MethodCall(method, _, [lo, hi], _) => {\n             if method.ident.as_str() == \"clamp\" {\n                 //FIXME: make this a diagnostic item\n                 if let (Some(lo_bits), Some(hi_bits)) = (get_constant_bits(cx, lo), get_constant_bits(cx, hi)) {\n@@ -64,7 +64,7 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n             }\n             nbits\n         },\n-        ExprKind::MethodCall(method, [_value], _) => {\n+        ExprKind::MethodCall(method, _value, [], _) => {\n             if method.ident.name.as_str() == \"signum\" {\n                 0 // do not lint if cast comes from a `signum` function\n             } else {"}, {"sha": "da7b12f67266a31898f5fcec7484eb11f6e8f865", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             cx.typeck_results().expr_ty(expr),\n         );\n         lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-    } else if let ExprKind::MethodCall(method_path, [self_arg, ..], _) = &expr.kind {\n+    } else if let ExprKind::MethodCall(method_path, self_arg, ..) = &expr.kind {\n         if method_path.ident.name == sym!(cast)\n             && let Some(generic_args) = method_path.args\n             && let [GenericArg::Type(cast_to)] = generic_args.args\n@@ -64,7 +64,7 @@ fn is_used_as_unaligned(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n         return false;\n     };\n     match parent.kind {\n-        ExprKind::MethodCall(name, [self_arg, ..], _) if self_arg.hir_id == e.hir_id => {\n+        ExprKind::MethodCall(name, self_arg, ..) if self_arg.hir_id == e.hir_id => {\n             if matches!(name.ident.as_str(), \"read_unaligned\" | \"write_unaligned\")\n                 && let Some(def_id) = cx.typeck_results().type_dependent_def_id(parent.hir_id)\n                 && let Some(def_id) = cx.tcx.impl_of_method(def_id)"}, {"sha": "5b59350be042c9ee173a398e36c403a81c86e01a", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -41,14 +41,14 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             }\n \n             // Don't lint for the result of methods that always return non-negative values.\n-            if let ExprKind::MethodCall(path, _, _) = cast_op.kind {\n+            if let ExprKind::MethodCall(path, ..) = cast_op.kind {\n                 let mut method_name = path.ident.name.as_str();\n                 let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n \n                 if_chain! {\n                     if method_name == \"unwrap\";\n                     if let Some(arglist) = method_chain_args(cast_op, &[\"unwrap\"]);\n-                    if let ExprKind::MethodCall(inner_path, _, _) = &arglist[0][0].kind;\n+                    if let ExprKind::MethodCall(inner_path, ..) = &arglist[0].0.kind;\n                     then {\n                         method_name = inner_path.ident.name.as_str();\n                     }"}, {"sha": "64c5de5104206c73ee9eecb29dced83d11cbf658", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -69,10 +69,7 @@ struct NumericFallbackVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'tcx>) -> Self {\n-        Self {\n-            ty_bounds: vec![TyBound::Nothing],\n-            cx,\n-        }\n+        Self { ty_bounds: vec![TyBound::Nothing], cx }\n     }\n \n     /// Check whether a passed literal has potential to cause fallback or not.\n@@ -129,19 +126,21 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                     }\n                     return;\n                 }\n-            },\n+            }\n \n-            ExprKind::MethodCall(_, args, _) => {\n+            ExprKind::MethodCall(_, receiver, args, _) => {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n-                    for (expr, bound) in iter::zip(*args, fn_sig.inputs()) {\n+                    for (expr, bound) in\n+                        iter::zip(std::iter::once(*receiver).chain(args.iter()), fn_sig.inputs())\n+                    {\n                         self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n                     return;\n                 }\n-            },\n+            }\n \n             ExprKind::Struct(_, fields, base) => {\n                 let ty = self.cx.typeck_results().expr_ty(expr);\n@@ -176,15 +175,15 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                         return;\n                     }\n                 }\n-            },\n+            }\n \n             ExprKind::Lit(lit) => {\n                 let ty = self.cx.typeck_results().expr_ty(expr);\n                 self.check_lit(lit, ty, expr.hir_id);\n                 return;\n-            },\n+            }\n \n-            _ => {},\n+            _ => {}\n         }\n \n         walk_expr(self, expr);\n@@ -198,7 +197,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 } else {\n                     self.ty_bounds.push(TyBound::Nothing);\n                 }\n-            },\n+            }\n \n             _ => self.ty_bounds.push(TyBound::Nothing),\n         }"}, {"sha": "6ee9e2e9754ced7799883f31b43fb3c23e92d9e5", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -581,7 +581,7 @@ fn try_parse_ref_op<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) -> Option<(RefOp, &'tcx Expr<'tcx>)> {\n     let (def_id, arg) = match expr.kind {\n-        ExprKind::MethodCall(_, [arg], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n+        ExprKind::MethodCall(_, arg, [], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(path),\n@@ -796,58 +796,59 @@ fn walk_parents<'tcx>(\n                             },\n                         })\n                     }),\n-                ExprKind::MethodCall(_, args, _) => {\n+                ExprKind::MethodCall(_, receiver, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n-                    args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n-                        if i == 0 {\n-                            // Check for calls to trait methods where the trait is implemented on a reference.\n-                            // Two cases need to be handled:\n-                            // * `self` methods on `&T` will never have auto-borrow\n-                            // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n-                            //   priority.\n-                            if e.hir_id != child_id {\n-                                Position::ReborrowStable(precedence)\n-                            } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n-                                && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n-                                && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n-                                && let subs = match cx\n-                                    .typeck_results()\n-                                    .node_substs_opt(parent.hir_id)\n-                                    .and_then(|subs| subs.get(1..))\n-                                {\n-                                    Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n-                                    None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n-                                } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n-                                    // Trait methods taking `&self`\n-                                    sub_ty\n-                                } else {\n-                                    // Trait methods taking `self`\n-                                    arg_ty\n-                                } && impl_ty.is_ref()\n-                                && cx.tcx.infer_ctxt().enter(|infcx|\n-                                    infcx\n-                                        .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n-                                        .must_apply_modulo_regions()\n-                                )\n+                    if receiver.hir_id == child_id {\n+                        // Check for calls to trait methods where the trait is implemented on a reference.\n+                        // Two cases need to be handled:\n+                        // * `self` methods on `&T` will never have auto-borrow\n+                        // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n+                        //   priority.\n+                        if e.hir_id != child_id {\n+                            return Some(Position::ReborrowStable(precedence))\n+                        } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n+                            && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n+                            && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n+                            && let subs = match cx\n+                                .typeck_results()\n+                                .node_substs_opt(parent.hir_id)\n+                                .and_then(|subs| subs.get(1..))\n                             {\n-                                Position::MethodReceiverRefImpl\n+                                Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n+                                None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n+                            } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n+                                // Trait methods taking `&self`\n+                                sub_ty\n                             } else {\n-                                Position::MethodReceiver\n-                            }\n+                                // Trait methods taking `self`\n+                                arg_ty\n+                            } && impl_ty.is_ref()\n+                            && cx.tcx.infer_ctxt().enter(|infcx|\n+                                infcx\n+                                    .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                    .must_apply_modulo_regions()\n+                            )\n+                        {\n+                            return Some(Position::MethodReceiverRefImpl)\n                         } else {\n-                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n+                            return Some(Position::MethodReceiver)\n+                        }\n+                    }\n+                    args.iter()\n+                        .position(|arg| arg.hir_id == child_id)\n+                        .map(|i| {\n+                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n                             if let ty::Param(param_ty) = ty.kind() {\n-                                needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                                needless_borrow_impl_arg_position(cx, parent, i + 1, *param_ty, e, precedence, msrv)\n                             } else {\n                                 ty_auto_deref_stability(\n                                     cx,\n-                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n+                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i + 1)),\n                                     precedence,\n                                 )\n                                 .position_for_arg()\n                             }\n-                        }\n-                    })\n+                        })\n                 },\n                 ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n                 ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),"}, {"sha": "512872cedc1ea04d6f45be24bb378f77fa7372cf", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -828,7 +828,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n \n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.cx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.cx, receiver_ty, sym::Result)\n             {"}, {"sha": "e70df3f53c75de24d99388251cc906c4b444987c", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -245,8 +245,8 @@ fn try_parse_contains<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Optio\n     match expr.kind {\n         ExprKind::MethodCall(\n             _,\n+            map,\n             [\n-                map,\n                 Expr {\n                     kind: ExprKind::AddrOf(_, _, key),\n                     span: key_span,\n@@ -280,7 +280,7 @@ struct InsertExpr<'tcx> {\n     value: &'tcx Expr<'tcx>,\n }\n fn try_parse_insert<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<InsertExpr<'tcx>> {\n-    if let ExprKind::MethodCall(_, [map, key, value], _) = expr.kind {\n+    if let ExprKind::MethodCall(_, map, [key, value], _) = expr.kind {\n         let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n         if match_def_path(cx, id, &paths::BTREEMAP_INSERT) || match_def_path(cx, id, &paths::HASHMAP_INSERT) {\n             Some(InsertExpr { map, key, value })"}, {"sha": "1342a4697b991664122c18fe8071fda8054fa81c", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n             if !is_adjusted(cx, &body.value);\n             if let ExprKind::Call(callee, args) = body.value.kind;\n             if let ExprKind::Path(_) = callee.kind;\n-            if check_inputs(cx, body.params, args);\n+            if check_inputs(cx, body.params, None, args);\n             let callee_ty = cx.typeck_results().expr_ty_adjusted(callee);\n             let call_ty = cx.typeck_results().type_dependent_def_id(body.value.hir_id)\n                 .map_or(callee_ty, |id| cx.tcx.type_of(id));\n@@ -146,8 +146,8 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n \n         if_chain!(\n             if !is_adjusted(cx, &body.value);\n-            if let ExprKind::MethodCall(path, args, _) = body.value.kind;\n-            if check_inputs(cx, body.params, args);\n+            if let ExprKind::MethodCall(path, receiver, args, _) = body.value.kind;\n+            if check_inputs(cx, body.params, Some(receiver), args);\n             let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n             let substs = cx.typeck_results().node_substs(body.value.hir_id);\n             let call_ty = cx.tcx.bound_type_of(method_def_id).subst(cx.tcx, substs);\n@@ -167,12 +167,17 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n     }\n }\n \n-fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_>]) -> bool {\n-    if params.len() != call_args.len() {\n+fn check_inputs(\n+    cx: &LateContext<'_>,\n+    params: &[Param<'_>],\n+    receiver: Option<&Expr<'_>>,\n+    call_args: &[Expr<'_>],\n+) -> bool {\n+    if receiver.map_or(params.len() != call_args.len(), |_| params.len() != call_args.len() + 1) {\n         return false;\n     }\n     let binding_modes = cx.typeck_results().pat_binding_modes();\n-    std::iter::zip(params, call_args).all(|(param, arg)| {\n+    let check_inputs = |param: &Param<'_>, arg| {\n         match param.pat.kind {\n             PatKind::Binding(_, id, ..) if path_to_local_id(arg, id) => {},\n             _ => return false,\n@@ -200,7 +205,9 @@ fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_\n             },\n             _ => false,\n         }\n-    })\n+    };\n+    std::iter::zip(params, receiver.into_iter().chain(call_args.iter()))\n+        .all(|(param, arg)| check_inputs(param, arg))\n }\n \n fn check_sig<'tcx>(cx: &LateContext<'tcx>, closure_ty: Ty<'tcx>, call_ty: Ty<'tcx>) -> bool {"}, {"sha": "9c76f63f5f7556afa0960a52a96858e3cf9a9a78", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -45,10 +45,10 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, [write_call], _) = expr.kind;\n+            if let ExprKind::MethodCall(unwrap_fun, write_call, [], _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n-            if let ExprKind::MethodCall(write_fun, [write_recv, write_arg], _) = look_in_block(cx, &write_call.kind);\n+            if let ExprKind::MethodCall(write_fun, write_recv, [write_arg], _) = look_in_block(cx, &write_call.kind);\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {"}, {"sha": "790eea63f58c49e048e58caf039c5e4360765a61", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -84,7 +84,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+                let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n                 if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                     || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n                 {"}, {"sha": "728db41d600438e39803cc21dee554a1e0879820", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -164,30 +164,30 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n     suggestion.maybe_par()\n }\n \n-fn check_log_base(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some(method) = get_specialized_log_method(cx, &args[1]) {\n+fn check_log_base(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some(method) = get_specialized_log_method(cx, &args[0]) {\n         span_lint_and_sugg(\n             cx,\n             SUBOPTIMAL_FLOPS,\n             expr.span,\n             \"logarithm for bases 2, 10 and e can be computed more accurately\",\n             \"consider using\",\n-            format!(\"{}.{}()\", Sugg::hir(cx, &args[0], \"..\").maybe_par(), method),\n+            format!(\"{}.{}()\", Sugg::hir(cx, receiver, \"..\").maybe_par(), method),\n             Applicability::MachineApplicable,\n         );\n     }\n }\n \n // TODO: Lint expressions of the form `(x + y).ln()` where y > 1 and\n // suggest usage of `(x + (y - 1)).ln_1p()` instead\n-fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>) {\n     if let ExprKind::Binary(\n         Spanned {\n             node: BinOpKind::Add, ..\n         },\n         lhs,\n         rhs,\n-    ) = &args[0].kind\n+    ) = receiver.kind\n     {\n         let recv = match (\n             constant(cx, cx.typeck_results(), lhs),\n@@ -235,9 +235,9 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n     }\n }\n \n-fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), receiver) {\n         let method = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n             \"exp\"\n         } else if F32(2.0) == value || F64(2.0) == value {\n@@ -252,32 +252,32 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n             expr.span,\n             \"exponent for bases 2 and e can be computed more accurately\",\n             \"consider using\",\n-            format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[1]), method),\n+            format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[0]), method),\n             Applicability::MachineApplicable,\n         );\n     }\n \n     // Check argument\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n         let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n             (\n                 SUBOPTIMAL_FLOPS,\n                 \"square-root of a number can be computed more efficiently and accurately\",\n-                format!(\"{}.sqrt()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n+                format!(\"{}.sqrt()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             )\n         } else if F32(1.0 / 3.0) == value || F64(1.0 / 3.0) == value {\n             (\n                 IMPRECISE_FLOPS,\n                 \"cube-root of a number can be computed more accurately\",\n-                format!(\"{}.cbrt()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n+                format!(\"{}.cbrt()\", Sugg::hir(cx, receiver, \"..\").maybe_par()),\n             )\n         } else if let Some(exponent) = get_integer_from_float_constant(&value) {\n             (\n                 SUBOPTIMAL_FLOPS,\n                 \"exponentiation with integer powers can be computed more efficiently\",\n                 format!(\n                     \"{}.powi({})\",\n-                    Sugg::hir(cx, &args[0], \"..\").maybe_par(),\n+                    Sugg::hir(cx, receiver, \"..\").maybe_par(),\n                     numeric_literal::format(&exponent.to_string(), None, false)\n                 ),\n             )\n@@ -297,13 +297,14 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n }\n \n-fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n         if value == Int(2) {\n             if let Some(parent) = get_parent_expr(cx, expr) {\n                 if let Some(grandparent) = get_parent_expr(cx, parent) {\n-                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, args, _) = grandparent.kind {\n-                        if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, receiver, ..) = grandparent.kind\n+                    {\n+                        if method_name.as_str() == \"sqrt\" && detect_hypot(cx, receiver).is_some() {\n                             return;\n                         }\n                     }\n@@ -327,8 +328,8 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                         \"consider using\",\n                         format!(\n                             \"{}.mul_add({}, {})\",\n-                            Sugg::hir(cx, &args[0], \"..\").maybe_par(),\n-                            Sugg::hir(cx, &args[0], \"..\"),\n+                            Sugg::hir(cx, receiver, \"..\").maybe_par(),\n+                            Sugg::hir(cx, receiver, \"..\"),\n                             Sugg::hir(cx, other_addend, \"..\"),\n                         ),\n                         Applicability::MachineApplicable,\n@@ -339,14 +340,14 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n }\n \n-fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n+fn detect_hypot(cx: &LateContext<'_>, receiver: &Expr<'_>) -> Option<String> {\n     if let ExprKind::Binary(\n         Spanned {\n             node: BinOpKind::Add, ..\n         },\n         add_lhs,\n         add_rhs,\n-    ) = args[0].kind\n+    ) = receiver.kind\n     {\n         // check if expression of the form x * x + y * y\n         if_chain! {\n@@ -363,12 +364,12 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         if_chain! {\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: lmethod_name, .. },\n-                [largs_0, largs_1, ..],\n+                largs_0, [largs_1, ..],\n                 _\n             ) = &add_lhs.kind;\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: rmethod_name, .. },\n-                [rargs_0, rargs_1, ..],\n+                rargs_0, [rargs_1, ..],\n                 _\n             ) = &add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n@@ -384,8 +385,8 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n     None\n }\n \n-fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some(message) = detect_hypot(cx, args) {\n+fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>) {\n+    if let Some(message) = detect_hypot(cx, receiver) {\n         span_lint_and_sugg(\n             cx,\n             IMPRECISE_FLOPS,\n@@ -406,7 +407,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n         if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n-        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &lhs.kind;\n+        if let ExprKind::MethodCall(path, self_arg, ..) = &lhs.kind;\n         if cx.typeck_results().expr_ty(self_arg).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n@@ -450,8 +451,8 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     ) = &expr.kind\n     {\n         if let Some(parent) = get_parent_expr(cx, expr) {\n-            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, args, _) = parent.kind {\n-                if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, receiver, ..) = parent.kind {\n+                if method_name.as_str() == \"sqrt\" && detect_hypot(cx, receiver).is_some() {\n                     return;\n                 }\n             }\n@@ -586,14 +587,14 @@ fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, args_a, _) = expr_a.kind;\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, args_b, _) = expr_b.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, args_a, _) = expr_a.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, args_b, _) = expr_b.kind;\n         then {\n             return method_name_a.as_str() == method_name_b.as_str() &&\n                 args_a.len() == args_b.len() &&\n                 (\n                     [\"ln\", \"log2\", \"log10\"].contains(&method_name_a.as_str()) ||\n-                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && eq_expr_value(cx, &args_a[1], &args_b[1])\n+                    method_name_a.as_str() == \"log\" && args_a.len() == 1 && eq_expr_value(cx, &args_a[0], &args_b[0])\n                 );\n         }\n     }\n@@ -612,8 +613,8 @@ fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             rhs,\n         ) = &expr.kind;\n         if are_same_base_logs(cx, lhs, rhs);\n-        if let ExprKind::MethodCall(_, [largs_self, ..], _) = &lhs.kind;\n-        if let ExprKind::MethodCall(_, [rargs_self, ..], _) = &rhs.kind;\n+        if let ExprKind::MethodCall(_, largs_self, ..) = &lhs.kind;\n+        if let ExprKind::MethodCall(_, rargs_self, ..) = &rhs.kind;\n         then {\n             span_lint_and_sugg(\n                 cx,\n@@ -711,16 +712,16 @@ impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n             return;\n         }\n \n-        if let ExprKind::MethodCall(path, args, _) = &expr.kind {\n-            let recv_ty = cx.typeck_results().expr_ty(&args[0]);\n+        if let ExprKind::MethodCall(path, receiver, args, _) = &expr.kind {\n+            let recv_ty = cx.typeck_results().expr_ty(receiver);\n \n             if recv_ty.is_floating_point() {\n                 match path.ident.name.as_str() {\n-                    \"ln\" => check_ln1p(cx, expr, args),\n-                    \"log\" => check_log_base(cx, expr, args),\n-                    \"powf\" => check_powf(cx, expr, args),\n-                    \"powi\" => check_powi(cx, expr, args),\n-                    \"sqrt\" => check_hypot(cx, expr, args),\n+                    \"ln\" => check_ln1p(cx, expr, receiver),\n+                    \"log\" => check_log_base(cx, expr, receiver, args),\n+                    \"powf\" => check_powf(cx, expr, receiver, args),\n+                    \"powi\" => check_powi(cx, expr, receiver, args),\n+                    \"sqrt\" => check_hypot(cx, expr, receiver),\n                     _ => {},\n                 }\n             }"}, {"sha": "2a55c48cf7731abb590b4d392d4512d90453e4fc", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -99,7 +99,12 @@ fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n     }\n }\n \n-fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &Expr<'_>) {\n+fn check_format_in_format_args(\n+    cx: &LateContext<'_>,\n+    call_site: Span,\n+    name: Symbol,\n+    arg: &Expr<'_>,\n+) {\n     let expn_data = arg.span.ctxt().outer_expn_data();\n     if expn_data.call_site.from_expansion() {\n         return;\n@@ -126,7 +131,7 @@ fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symb\n fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Expr<'_>) {\n     if_chain! {\n         if !value.span.from_expansion();\n-        if let ExprKind::MethodCall(_, [receiver], _) = value.kind;\n+        if let ExprKind::MethodCall(_, receiver, [], _) = value.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(value.hir_id);\n         if is_diag_trait_item(cx, method_def_id, sym::ToString);\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);\n@@ -177,10 +182,7 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n \n // Returns true if `hir_id` is referred to by multiple format params\n fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n-    args.params()\n-        .filter(|param| param.value.hir_id == hir_id)\n-        .at_most_one()\n-        .is_err()\n+    args.params().filter(|param| param.value.hir_id == hir_id).at_most_one().is_err()\n }\n \n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n@@ -190,11 +192,7 @@ where\n     let mut n_total = 0;\n     let mut n_needed = 0;\n     loop {\n-        if let Some(Adjustment {\n-            kind: Adjust::Deref(overloaded_deref),\n-            target,\n-        }) = iter.next()\n-        {\n+        if let Some(Adjustment { kind: Adjust::Deref(overloaded_deref), target }) = iter.next() {\n             n_total += 1;\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;"}, {"sha": "b628fd9f758143fa537dae4112d95a032696d5fb", "filename": "src/tools/clippy/clippy_lints/src/format_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_impl.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for FormatImpl {\n fn check_to_string_in_display(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         // Get the hir_id of the object we are calling the method on\n-        if let ExprKind::MethodCall(path, [ref self_arg, ..], _) = expr.kind;\n+        if let ExprKind::MethodCall(path, self_arg, ..) = expr.kind;\n         // Is the method to_string() ?\n         if path.ident.name == sym::to_string;\n         // Is the method a part of the ToString trait? (i.e. not to_string() implemented"}, {"sha": "9b9f1872bfc1d2cf5b42a86253b05ccb2db63927", "filename": "src/tools/clippy/clippy_lints/src/format_push_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_push_string.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -54,7 +54,7 @@ fn is_format(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n impl<'tcx> LateLintPass<'tcx> for FormatPushString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let arg = match expr.kind {\n-            ExprKind::MethodCall(_, [_, arg], _) => {\n+            ExprKind::MethodCall(_, _, [arg], _) => {\n                 if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) &&\n                 match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n                     arg"}, {"sha": "a17b23f5edc8609074d202d7f85d974be80d84dc", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n             return;\n         }\n         match expr.kind {\n-            Call(_, args) | MethodCall(_, args, _) => {\n+            Call(_, args) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n                     if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n@@ -230,6 +230,24 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                     tys.clear();\n                 }\n             },\n+            MethodCall(_, receiver, args, _) => {\n+                let mut tys = DefIdSet::default();\n+                for arg in std::iter::once(receiver).chain(args.iter()) {\n+                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                        && is_mutable_ty(\n+                            self.cx,\n+                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n+                            arg.span,\n+                            &mut tys,\n+                        )\n+                        && is_mutated_static(arg)\n+                    {\n+                        self.mutates_static = true;\n+                        return;\n+                    }\n+                    tys.clear();\n+                }\n+            },\n             Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n                 self.mutates_static |= is_mutated_static(target);\n             },"}, {"sha": "3bbfa52e810392c98cadd63e7cea7e32dd30ec3e", "filename": "src/tools/clippy/clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -88,11 +88,12 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, args, _) => {\n+            hir::ExprKind::MethodCall(_, receiver, args, _) => {\n                 let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n                 if type_is_unsafe_function(self.cx, base_type) {\n+                    self.check_arg(receiver);\n                     for arg in args {\n                         self.check_arg(arg);\n                     }"}, {"sha": "9ea8c494cfcdab4a0fd71e5dbe80433fd4e2f8b1", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -129,7 +129,7 @@ impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n \n fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+        if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n         if path.ident.as_str() == \"lock\";\n         let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n         if is_type_diagnostic_item(cx, ty, sym::Mutex);"}, {"sha": "d55a8e1ead17d11eb02f135c361010dca7fb9a2c", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for InfiniteIter {\n             MaybeInfinite => (MAYBE_INFINITE_ITER, \"possible infinite iteration detected\"),\n             Finite => {\n                 return;\n-            },\n+            }\n         };\n         span_lint(cx, lint, expr.span, msg);\n     }\n@@ -123,43 +123,43 @@ use self::Heuristic::{All, Always, Any, First};\n /// is an upper bound, e.g., some methods can return a possibly\n /// infinite iterator at worst, e.g., `take_while`.\n const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n-    (\"zip\", 2, All, Infinite),\n-    (\"chain\", 2, Any, Infinite),\n-    (\"cycle\", 1, Always, Infinite),\n-    (\"map\", 2, First, Infinite),\n-    (\"by_ref\", 1, First, Infinite),\n-    (\"cloned\", 1, First, Infinite),\n-    (\"rev\", 1, First, Infinite),\n-    (\"inspect\", 1, First, Infinite),\n-    (\"enumerate\", 1, First, Infinite),\n-    (\"peekable\", 2, First, Infinite),\n-    (\"fuse\", 1, First, Infinite),\n-    (\"skip\", 2, First, Infinite),\n-    (\"skip_while\", 1, First, Infinite),\n-    (\"filter\", 2, First, Infinite),\n-    (\"filter_map\", 2, First, Infinite),\n-    (\"flat_map\", 2, First, Infinite),\n-    (\"unzip\", 1, First, Infinite),\n-    (\"take_while\", 2, First, MaybeInfinite),\n-    (\"scan\", 3, First, MaybeInfinite),\n+    (\"zip\", 1, All, Infinite),\n+    (\"chain\", 1, Any, Infinite),\n+    (\"cycle\", 0, Always, Infinite),\n+    (\"map\", 1, First, Infinite),\n+    (\"by_ref\", 0, First, Infinite),\n+    (\"cloned\", 0, First, Infinite),\n+    (\"rev\", 0, First, Infinite),\n+    (\"inspect\", 0, First, Infinite),\n+    (\"enumerate\", 0, First, Infinite),\n+    (\"peekable\", 1, First, Infinite),\n+    (\"fuse\", 0, First, Infinite),\n+    (\"skip\", 1, First, Infinite),\n+    (\"skip_while\", 0, First, Infinite),\n+    (\"filter\", 1, First, Infinite),\n+    (\"filter_map\", 1, First, Infinite),\n+    (\"flat_map\", 1, First, Infinite),\n+    (\"unzip\", 0, First, Infinite),\n+    (\"take_while\", 1, First, MaybeInfinite),\n+    (\"scan\", 2, First, MaybeInfinite),\n ];\n \n fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(method, args, _) => {\n+        ExprKind::MethodCall(method, receiver, args, _) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return (match heuristic {\n                         Always => Infinite,\n-                        First => is_infinite(cx, &args[0]),\n-                        Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n-                        All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n+                        First => is_infinite(cx, receiver),\n+                        Any => is_infinite(cx, receiver).or(is_infinite(cx, &args[0])),\n+                        All => is_infinite(cx, receiver).and(is_infinite(cx, &args[0])),\n                     })\n                     .and(cap);\n                 }\n             }\n-            if method.ident.name == sym!(flat_map) && args.len() == 2 {\n-                if let ExprKind::Closure(&Closure { body, .. }) = args[1].kind {\n+            if method.ident.name == sym!(flat_map) && args.len() == 1 {\n+                if let ExprKind::Closure(&Closure { body, .. }) = args[0].kind {\n                     let body = cx.tcx.hir().body(body);\n                     return is_infinite(cx, &body.value);\n                 }\n@@ -179,29 +179,29 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n /// the names and argument lengths of methods that *may* exhaust their\n /// iterators\n const POSSIBLY_COMPLETING_METHODS: [(&str, usize); 6] = [\n-    (\"find\", 2),\n-    (\"rfind\", 2),\n-    (\"position\", 2),\n-    (\"rposition\", 2),\n-    (\"any\", 2),\n-    (\"all\", 2),\n+    (\"find\", 1),\n+    (\"rfind\", 1),\n+    (\"position\", 1),\n+    (\"rposition\", 1),\n+    (\"any\", 1),\n+    (\"all\", 1),\n ];\n \n /// the names and argument lengths of methods that *always* exhaust\n /// their iterators\n const COMPLETING_METHODS: [(&str, usize); 12] = [\n-    (\"count\", 1),\n-    (\"fold\", 3),\n-    (\"for_each\", 2),\n-    (\"partition\", 2),\n-    (\"max\", 1),\n-    (\"max_by\", 2),\n-    (\"max_by_key\", 2),\n-    (\"min\", 1),\n-    (\"min_by\", 2),\n-    (\"min_by_key\", 2),\n-    (\"sum\", 1),\n-    (\"product\", 1),\n+    (\"count\", 0),\n+    (\"fold\", 2),\n+    (\"for_each\", 1),\n+    (\"partition\", 1),\n+    (\"max\", 0),\n+    (\"max_by\", 1),\n+    (\"max_by_key\", 1),\n+    (\"min\", 0),\n+    (\"min_by\", 1),\n+    (\"min_by_key\", 1),\n+    (\"sum\", 0),\n+    (\"product\", 0),\n ];\n \n /// the paths of types that are known to be infinitely allocating\n@@ -218,34 +218,32 @@ const INFINITE_COLLECTORS: &[Symbol] = &[\n \n fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(method, args, _) => {\n+        ExprKind::MethodCall(method, receiver, args, _) => {\n             for &(name, len) in &COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n-                    return is_infinite(cx, &args[0]);\n+                    return is_infinite(cx, receiver);\n                 }\n             }\n             for &(name, len) in &POSSIBLY_COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n-                    return MaybeInfinite.and(is_infinite(cx, &args[0]));\n+                    return MaybeInfinite.and(is_infinite(cx, receiver));\n                 }\n             }\n-            if method.ident.name == sym!(last) && args.len() == 1 {\n-                let not_double_ended = cx\n-                    .tcx\n-                    .get_diagnostic_item(sym::DoubleEndedIterator)\n-                    .map_or(false, |id| {\n-                        !implements_trait(cx, cx.typeck_results().expr_ty(&args[0]), id, &[])\n+            if method.ident.name == sym!(last) && args.is_empty() {\n+                let not_double_ended =\n+                    cx.tcx.get_diagnostic_item(sym::DoubleEndedIterator).map_or(false, |id| {\n+                        !implements_trait(cx, cx.typeck_results().expr_ty(receiver), id, &[])\n                     });\n                 if not_double_ended {\n-                    return is_infinite(cx, &args[0]);\n+                    return is_infinite(cx, receiver);\n                 }\n             } else if method.ident.name == sym!(collect) {\n                 let ty = cx.typeck_results().expr_ty(expr);\n                 if INFINITE_COLLECTORS\n                     .iter()\n                     .any(|diag_item| is_type_diagnostic_item(cx, ty, *diag_item))\n                 {\n-                    return is_infinite(cx, &args[0]);\n+                    return is_infinite(cx, receiver);\n                 }\n             }\n         },"}, {"sha": "3cbdaff407b04383f07bf24c84dfb71d52bed93d", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -370,15 +370,15 @@ fn check_for_is_empty<'tcx>(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(method_path, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n+    if let (&ExprKind::MethodCall(method_path, receiver, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {\n                 return;\n             }\n         }\n \n-        check_len(cx, span, method_path.ident.name, args, &lit.node, op, compare_to);\n+        check_len(cx, span, method_path.ident.name, receiver, args, &lit.node, op, compare_to);\n     } else {\n         check_empty_expr(cx, span, method, lit, op);\n     }\n@@ -388,6 +388,7 @@ fn check_len(\n     cx: &LateContext<'_>,\n     span: Span,\n     method_name: Symbol,\n+    receiver: &Expr<'_>,\n     args: &[Expr<'_>],\n     lit: &LitKind,\n     op: &str,\n@@ -399,7 +400,7 @@ fn check_len(\n             return;\n         }\n \n-        if method_name == sym::len && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        if method_name == sym::len && args.is_empty() && has_is_empty(cx, receiver) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n@@ -410,7 +411,7 @@ fn check_len(\n                 format!(\n                     \"{}{}.is_empty()\",\n                     op,\n-                    snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability)\n+                    snippet_with_applicability(cx, receiver.span, \"_\", &mut applicability)\n                 ),\n                 applicability,\n             );"}, {"sha": "3fc569af89ecb4f386ba4a5b973494b4e31b9279", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -119,7 +119,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n \n     let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n         if_chain! {\n-            if let ExprKind::MethodCall(method, [recv], _) = end.kind;\n+            if let ExprKind::MethodCall(method, recv, [], _) = end.kind;\n             if method.ident.name == sym::len;\n             if path_to_local(recv) == path_to_local(base);\n             then {\n@@ -341,7 +341,7 @@ fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Opti\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, [arg], _) = expr.kind;\n+        if let ExprKind::MethodCall(method, arg, [], _) = expr.kind;\n         if method.ident.name == sym::clone;\n         then { arg } else { expr }\n     }"}, {"sha": "8412875b11b7ecbfae00e57166f5712f5a61307c", "filename": "src/tools/clippy/clippy_lints/src/loops/missing_spin_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -33,7 +33,7 @@ fn unpack_cond<'tcx>(cond: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, body: &'tcx Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Block(Block { stmts: [], expr: None, ..}, _) = body.kind;\n-        if let ExprKind::MethodCall(method, [callee, ..], _) = unpack_cond(cond).kind;\n+        if let ExprKind::MethodCall(method, callee, ..) = unpack_cond(cond).kind;\n         if [sym::load, sym::compare_exchange, sym::compare_exchange_weak].contains(&method.ident.name);\n         if let ty::Adt(def, _substs) = cx.typeck_results().expr_ty(callee).kind();\n         if cx.tcx.is_diagnostic_item(sym::AtomicBool, def.did());"}, {"sha": "74f3bda9f43efb0fe0749d4e069640cc634bba4e", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -742,7 +742,7 @@ fn check_for_loop<'tcx>(\n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n \n-    if let ExprKind::MethodCall(method, [self_arg], _) = arg.kind {\n+    if let ExprKind::MethodCall(method, self_arg, [], _) = arg.kind {\n         let method_name = method.ident.as_str();\n         // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n         match method_name {"}, {"sha": "6e6faa79adc9e7df8e2d43df4efc1fe3e086bbcd", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -25,11 +25,11 @@ pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n }\n fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, args, _) = expr.kind;\n-        if let ExprKind::MethodCall(chain_method, _, _) = args[0].kind;\n-        if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n+        if let ExprKind::MethodCall(method, receiver, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(chain_method, ..) = receiver.kind;\n+        if chain_method.ident.name == sym!(collect) && is_trait_method(cx, receiver, sym::Iterator);\n         then {\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(receiver);\n             let mut applicability = Applicability::MaybeIncorrect;\n             let is_empty_sugg = \"next().is_none()\".to_string();\n             let method_name = method.ident.name.as_str();\n@@ -41,7 +41,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n                     \"len\" => \"count()\".to_string(),\n                     \"is_empty\" => is_empty_sugg,\n                     \"contains\" => {\n-                        let contains_arg = snippet_with_applicability(cx, args[1].span, \"??\", &mut applicability);\n+                        let contains_arg = snippet_with_applicability(cx, args[0].span, \"??\", &mut applicability);\n                         let (arg, pred) = contains_arg\n                             .strip_prefix('&')\n                             .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n@@ -80,7 +80,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                 if let StmtKind::Local(local) = stmt.kind;\n                 if let PatKind::Binding(_, id, ..) = local.pat.kind;\n                 if let Some(init_expr) = local.init;\n-                if let ExprKind::MethodCall(method_name, &[ref iter_source], ..) = init_expr.kind;\n+                if let ExprKind::MethodCall(method_name, iter_source, [], ..) = init_expr.kind;\n                 if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n                 let ty = cx.typeck_results().expr_ty(init_expr);\n                 if is_type_diagnostic_item(cx, ty, sym::Vec) ||\n@@ -203,7 +203,7 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n-        if let ExprKind::MethodCall(method_name, [recv, args @ ..], _) = &expr.kind {\n+        if let ExprKind::MethodCall(method_name, recv, [args @ ..], _) = &expr.kind {\n             if method_name.ident.name == sym!(collect) && is_trait_method(self.cx, expr, sym::Iterator) {\n                 self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(recv));\n                 self.visit_expr(recv);"}, {"sha": "ffcf83e4605e2d3cbb84986e80fadbbc7b21a5da", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -188,7 +188,7 @@ pub(super) fn check<'tcx>(\n \n fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, [recv], _) = expr.kind;\n+        if let ExprKind::MethodCall(method, recv, [], _) = expr.kind;\n         if method.ident.name == sym::len;\n         if let ExprKind::Path(QPath::Resolved(_, path)) = recv.kind;\n         if path.segments.len() == 1;\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // a range index op\n-            if let ExprKind::MethodCall(meth, [args_0, args_1, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(meth, args_0, [args_1, ..], _) = &expr.kind;\n             if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(args_1, args_0, expr);\n@@ -356,9 +356,12 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.visit_expr(expr);\n                 }\n             },\n-            ExprKind::MethodCall(_, args, _) => {\n+            ExprKind::MethodCall(_, receiver, args, _) => {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n-                for (ty, expr) in iter::zip(self.cx.tcx.fn_sig(def_id).inputs().skip_binder(), args) {\n+                for (ty, expr) in iter::zip(\n+                    self.cx.tcx.fn_sig(def_id).inputs().skip_binder(),\n+                    std::iter::once(receiver).chain(args.iter()),\n+                ) {\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {"}, {"sha": "116e589cad6f3495d87ccccbf1fdf9e238b9c1da", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -120,8 +120,9 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Repeat(e, _)\n         | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n         ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, main_loop_id),\n-        ExprKind::Array(es) | ExprKind::MethodCall(_, es, _) | ExprKind::Tup(es) => {\n-            never_loop_expr_all(&mut es.iter(), main_loop_id)\n+        ExprKind::Array(es) | ExprKind::Tup(es) => never_loop_expr_all(&mut es.iter(), main_loop_id),\n+        ExprKind::MethodCall(_, receiver, es, _) => {\n+            never_loop_expr_all(&mut std::iter::once(receiver).chain(es.iter()), main_loop_id)\n         },\n         ExprKind::Struct(_, fields, base) => {\n             let fields = never_loop_expr_all(&mut fields.iter().map(|f| f.expr), main_loop_id);"}, {"sha": "23f47091f77f91f953af18f036f9c3ad4e130ea9", "filename": "src/tools/clippy/clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -180,10 +180,9 @@ fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&\n     if_chain! {\n             // Extract method being called\n             if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n-            if let ExprKind::MethodCall(path, args, _) = &semi_stmt.kind;\n+            if let ExprKind::MethodCall(path, self_expr, args, _) = &semi_stmt.kind;\n             // Figure out the parameters for the method call\n-            if let Some(self_expr) = args.get(0);\n-            if let Some(pushed_item) = args.get(1);\n+            if let Some(pushed_item) = args.get(0);\n             // Check that the method being called is push() on a Vec\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::Vec);\n             if path.ident.name.as_str() == \"push\";"}, {"sha": "f4b47808dfaa362b8b7f9ce3d6625d87d07d8a48", "filename": "src/tools/clippy/clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -35,32 +35,29 @@ pub(super) fn check<'tcx>(\n         ) => (arg, \"&mut \"),\n         ExprKind::MethodCall(\n             method,\n-            [\n-                Expr {\n-                    kind: ExprKind::Array([arg]),\n-                    ..\n-                },\n-            ],\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+            [],\n             _,\n         ) if method.ident.name == rustc_span::sym::iter => (arg, \"&\"),\n         ExprKind::MethodCall(\n             method,\n-            [\n-                Expr {\n-                    kind: ExprKind::Array([arg]),\n-                    ..\n-                },\n-            ],\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+            [],\n             _,\n         ) if method.ident.name.as_str() == \"iter_mut\" => (arg, \"&mut \"),\n         ExprKind::MethodCall(\n             method,\n-            [\n-                Expr {\n-                    kind: ExprKind::Array([arg]),\n-                    ..\n-                },\n-            ],\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+            [],\n             _,\n         ) if method.ident.name == rustc_span::sym::into_iter => (arg, \"\"),\n         // Only check for arrays edition 2021 or later, as this case will trigger a compiler error otherwise."}, {"sha": "735d704a43cee343dcdb0ea76dea3a02566e6815", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -11,7 +11,14 @@ use rustc_lint::LateContext;\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n     let (init, has_trailing_exprs) = match (loop_block.stmts, loop_block.expr) {\n         ([stmt, stmts @ ..], expr) => {\n-            if let StmtKind::Local(&Local { init: Some(e), els: None, .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n+            if let StmtKind::Local(&Local {\n+                init: Some(e),\n+                els: None,\n+                ..\n+            })\n+            | StmtKind::Semi(e)\n+            | StmtKind::Expr(e) = stmt.kind\n+            {\n                 (e, !stmts.is_empty() || expr.is_some())\n             } else {\n                 return;"}, {"sha": "2c54033f8597502c6fb8db8c276f6f91d450377c", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Res::Def(_, pat_did) = pat_path.res;\n         if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n         // check for call to `Iterator::next`\n-        if let ExprKind::MethodCall(method_name, [iter_expr], _) = let_expr.kind;\n+        if let ExprKind::MethodCall(method_name, iter_expr, [], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;\n         if is_trait_method(cx, let_expr, sym::Iterator);\n         if let Some(iter_expr_struct) = try_parse_iter_expr(cx, iter_expr);"}, {"sha": "6655c92b1da8da05a2f2f983bbe9fd8e28eaf439", "filename": "src/tools/clippy/clippy_lints/src/manual_bits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_bits.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -134,7 +134,7 @@ fn create_sugg(cx: &LateContext<'_>, expr: &Expr<'_>, base_sugg: String) -> Stri\n fn is_ty_conversion(expr: &Expr<'_>) -> bool {\n     if let ExprKind::Cast(..) = expr.kind {\n         true\n-    } else if let ExprKind::MethodCall(path, [_], _) = expr.kind\n+    } else if let ExprKind::MethodCall(path, _, [], _) = expr.kind\n         && path.ident.name == rustc_span::sym::try_into\n     {\n         // This is only called for `usize` which implements `TryInto`. Therefore,"}, {"sha": "f28c37d3dca7e0d9d49417fe4c832197d70229cb", "filename": "src/tools/clippy/clippy_lints/src/manual_retain.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -66,9 +66,9 @@ impl<'tcx> LateLintPass<'tcx> for ManualRetain {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if let Some(parent_expr) = get_parent_expr(cx, expr)\n             && let Assign(left_expr, collect_expr, _) = &parent_expr.kind\n-            && let hir::ExprKind::MethodCall(seg, _, _) = &collect_expr.kind\n+            && let hir::ExprKind::MethodCall(seg, ..) = &collect_expr.kind\n             && seg.args.is_none()\n-            && let hir::ExprKind::MethodCall(_, [target_expr], _) = &collect_expr.kind\n+            && let hir::ExprKind::MethodCall(_, target_expr, [], _) = &collect_expr.kind\n             && let Some(collect_def_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id)\n             && match_def_path(cx, collect_def_id, &paths::CORE_ITER_COLLECT) {\n             check_into_iter(cx, parent_expr, left_expr, target_expr, self.msrv);\n@@ -87,10 +87,10 @@ fn check_into_iter(\n     target_expr: &hir::Expr<'_>,\n     msrv: Option<RustcVersion>,\n ) {\n-    if let hir::ExprKind::MethodCall(_, [into_iter_expr, _], _) = &target_expr.kind\n+    if let hir::ExprKind::MethodCall(_, into_iter_expr, [_], _) = &target_expr.kind\n         && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n-        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &into_iter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &into_iter_expr.kind\n         && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n         && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n         && match_acceptable_type(cx, left_expr, msrv)\n@@ -106,14 +106,14 @@ fn check_iter(\n     target_expr: &hir::Expr<'_>,\n     msrv: Option<RustcVersion>,\n ) {\n-    if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+    if let hir::ExprKind::MethodCall(_, filter_expr, [], _) = &target_expr.kind\n         && let Some(copied_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n         && (match_def_path(cx, copied_def_id, &paths::CORE_ITER_COPIED)\n             || match_def_path(cx, copied_def_id, &paths::CORE_ITER_CLONED))\n-        && let hir::ExprKind::MethodCall(_, [iter_expr, _], _) = &filter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, iter_expr, [_], _) = &filter_expr.kind\n         && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n-        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &iter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &iter_expr.kind\n         && let Some(iter_expr_def_id) = cx.typeck_results().type_dependent_def_id(iter_expr.hir_id)\n         && match_acceptable_def_path(cx, iter_expr_def_id)\n         && match_acceptable_type(cx, left_expr, msrv)\n@@ -130,13 +130,13 @@ fn check_to_owned(\n     msrv: Option<RustcVersion>,\n ) {\n     if meets_msrv(msrv,  msrvs::STRING_RETAIN)\n-        && let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+        && let hir::ExprKind::MethodCall(_, filter_expr, [], _) = &target_expr.kind\n         && let Some(to_owned_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n         && match_def_path(cx, to_owned_def_id, &paths::TO_OWNED_METHOD)\n-        && let hir::ExprKind::MethodCall(_, [chars_expr, _], _) = &filter_expr.kind\n+        && let hir::ExprKind::MethodCall(_, chars_expr, [_], _) = &filter_expr.kind\n         && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n-        && let hir::ExprKind::MethodCall(_, [str_expr], _) = &chars_expr.kind\n+        && let hir::ExprKind::MethodCall(_, str_expr, [], _) = &chars_expr.kind\n         && let Some(chars_expr_def_id) = cx.typeck_results().type_dependent_def_id(chars_expr.hir_id)\n         && match_def_path(cx, chars_expr_def_id, &paths::STR_CHARS)\n         && let ty = cx.typeck_results().expr_ty(str_expr).peel_refs()\n@@ -147,7 +147,7 @@ fn check_to_owned(\n }\n \n fn suggest(cx: &LateContext<'_>, parent_expr: &hir::Expr<'_>, left_expr: &hir::Expr<'_>, filter_expr: &hir::Expr<'_>) {\n-    if let hir::ExprKind::MethodCall(_, [_, closure], _) = filter_expr.kind\n+    if let hir::ExprKind::MethodCall(_, _, [closure], _) = filter_expr.kind\n         && let hir::ExprKind::Closure(&hir::Closure { body, ..}) = closure.kind\n         && let filter_body = cx.tcx.hir().body(body)\n         && let [filter_params] = filter_body.params"}, {"sha": "6acfb2ae3471c3b3a4f3840b609d490af95e0cfe", "filename": "src/tools/clippy/clippy_lints/src/manual_string_new.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_string_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_string_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_string_new.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -55,8 +55,8 @@ impl LateLintPass<'_> for ManualStringNew {\n             ExprKind::Call(func, args) => {\n                 parse_call(cx, expr.span, func, args);\n             },\n-            ExprKind::MethodCall(path_segment, args, _) => {\n-                parse_method_call(cx, expr.span, path_segment, args);\n+            ExprKind::MethodCall(path_segment, receiver, ..) => {\n+                parse_method_call(cx, expr.span, path_segment, receiver);\n             },\n             _ => (),\n         }\n@@ -88,14 +88,9 @@ fn warn_then_suggest(cx: &LateContext<'_>, span: Span) {\n }\n \n /// Tries to parse an expression as a method call, emitting the warning if necessary.\n-fn parse_method_call(cx: &LateContext<'_>, span: Span, path_segment: &PathSegment<'_>, args: &[Expr<'_>]) {\n-    if args.is_empty() {\n-        // When parsing TryFrom::try_from(...).expect(...), we will have more than 1 arg.\n-        return;\n-    }\n-\n+fn parse_method_call(cx: &LateContext<'_>, span: Span, path_segment: &PathSegment<'_>, receiver: &Expr<'_>) {\n     let ident = path_segment.ident.as_str();\n-    let method_arg_kind = &args[0].kind;\n+    let method_arg_kind = &receiver.kind;\n     if [\"to_string\", \"to_owned\", \"into\"].contains(&ident) && is_expr_kind_empty_str(method_arg_kind) {\n         warn_then_suggest(cx, span);\n     } else if let ExprKind::Call(func, args) = method_arg_kind {"}, {"sha": "7941c8c9c7e39bc4c2f941d765f19904569c7bbd", "filename": "src/tools/clippy/clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n \n         if_chain! {\n             if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n-            if let ExprKind::MethodCall(_, [target_arg, pattern], _) = cond.kind;\n+            if let ExprKind::MethodCall(_, target_arg, [pattern], _) = cond.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n             if let ExprKind::Path(target_path) = &target_arg.kind;\n             then {\n@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n // Returns `Some(arg)` if `expr` matches `arg.len()` and `None` otherwise.\n fn len_arg<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(_, [arg], _) = expr.kind;\n+        if let ExprKind::MethodCall(_, arg, [], _) = expr.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, method_def_id, &paths::STR_LEN);\n         then {"}, {"sha": "33d744815299f040f56a967423b248e65eb6ea5c", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -200,8 +200,13 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     )\n }\n \n-fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n-    let var_arg = &map_args[0];\n+fn lint_map_unit_fn(\n+    cx: &LateContext<'_>,\n+    stmt: &hir::Stmt<'_>,\n+    expr: &hir::Expr<'_>,\n+    map_args: (&hir::Expr<'_>, &[hir::Expr<'_>]),\n+) {\n+    let var_arg = &map_args.0;\n \n     let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym::Option) {\n         (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n@@ -210,7 +215,7 @@ fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr\n     } else {\n         return;\n     };\n-    let fn_arg = &map_args[1];\n+    let fn_arg = &map_args.1[0];\n \n     if is_unit_function(cx, fn_arg) {\n         let mut applicability = Applicability::MachineApplicable;"}, {"sha": "8588ab1ed8db781d159aa74363f4eddbf8642562", "filename": "src/tools/clippy/clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n             };\n \n         if_chain! {\n-            if let ExprKind::MethodCall(ok_path, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let ExprKind::MethodCall(ok_path, result_types_0, ..) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n             if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() method use std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(result_types_0), sym::Result);"}, {"sha": "1e80b6cf2d838ecf4d6c64d8fcb353ed214b0d0e", "filename": "src/tools/clippy/clippy_lints/src/matches/match_str_case_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -48,7 +48,7 @@ struct MatchExprVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for MatchExprVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n         match ex.kind {\n-            ExprKind::MethodCall(segment, [receiver], _) if self.case_altered(segment.ident.as_str(), receiver) => {},\n+            ExprKind::MethodCall(segment, receiver, [], _) if self.case_altered(segment.ident.as_str(), receiver) => {},\n             _ => walk_expr(self, ex),\n         }\n     }"}, {"sha": "f7443471e31dda274d656766223512c64de39ccb", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -120,7 +120,7 @@ fn find_sugg_for_if_let<'tcx>(\n     // check that `while_let_on_iterator` lint does not trigger\n     if_chain! {\n         if keyword == \"while\";\n-        if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n+        if let ExprKind::MethodCall(method_path, ..) = let_expr.kind;\n         if method_path.ident.name == sym::next;\n         if is_trait_method(cx, let_expr, sym::Iterator);\n         then {"}, {"sha": "86a9df034979be06feb7484f112acf00b2f9529a", "filename": "src/tools/clippy/clippy_lints/src/matches/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n         self.is_chain_end = false;\n \n         match ex.kind {\n-            ExprKind::MethodCall(_, [ref expr, ..], _) => {\n+            ExprKind::MethodCall(_, expr, ..) => {\n                 self.visit_expr(expr);\n             }\n             ExprKind::Binary(_, left, right) => {\n@@ -331,8 +331,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n             ExprKind::Index(..) |\n             ExprKind::Ret(..) |\n             ExprKind::Repeat(..) |\n-            ExprKind::Yield(..) |\n-            ExprKind::MethodCall(..) => walk_expr(self, ex),\n+            ExprKind::Yield(..) => walk_expr(self, ex),\n             ExprKind::AddrOf(_, _, _) |\n             ExprKind::Block(_, _) |\n             ExprKind::Break(_, _) |"}, {"sha": "fef90f6eba49525eb5c0f827aee1e823d97808df", "filename": "src/tools/clippy/clippy_lints/src/methods/bytecount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -42,11 +42,11 @@ pub(super) fn check<'tcx>(\n         if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n         if !is_local_used(cx, needle, arg_id);\n         then {\n-            let haystack = if let ExprKind::MethodCall(path, args, _) =\n+            let haystack = if let ExprKind::MethodCall(path, receiver, [], _) =\n                     filter_recv.kind {\n                 let p = path.ident.name;\n-                if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n-                    &args[0]\n+                if p == sym::iter || p == sym!(iter_mut) {\n+                    receiver\n                 } else {\n                     filter_recv\n                 }"}, {"sha": "51aec21527a7116e8d253911e12611ba829af055", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check(\n         if Some(id) == cx.tcx.lang_items().option_some_variant();\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n+            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0].0).peel_refs();\n \n             if *self_ty.kind() != ty::Str {\n                 return false;\n@@ -37,7 +37,7 @@ pub(super) fn check(\n                 \"like this\",\n                 format!(\"{}{}.{}({})\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0].0.span, \"..\", &mut applicability),\n                         suggest,\n                         snippet_with_applicability(cx, arg_char.span, \"..\", &mut applicability)),\n                 applicability,"}, {"sha": "b85bfec2b12ba33de410c2902678864a1fdc0f50", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_cmp_with_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n                 \"like this\",\n                 format!(\"{}{}.{}('{}')\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, args[0].0.span, \"..\", &mut applicability),\n                         suggest,\n                         c.escape_default()),\n                 applicability,"}, {"sha": "25a9e6dafea151e427ee385c26ce27643baa9921", "filename": "src/tools/clippy/clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -14,11 +14,14 @@ use super::CLONE_ON_COPY;\n \n /// Checks for the `CLONE_ON_COPY` lint.\n #[allow(clippy::too_many_lines)]\n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol, args: &[Expr<'_>]) {\n-    let arg = match args {\n-        [arg] if method_name == sym::clone => arg,\n-        _ => return,\n-    };\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &Expr<'_>,\n+    args: &[Expr<'_>],\n+) {\n+    let arg = if method_name == sym::clone && args.is_empty() { receiver } else { return };\n     if cx\n         .typeck_results()\n         .type_dependent_def_id(expr.hir_id)\n@@ -81,7 +84,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol,\n                 // &*x is a nop, &x.clone() is not\n                 ExprKind::AddrOf(..) => return,\n                 // (*x).func() is useless, x.clone().func() can work in case func borrows self\n-                ExprKind::MethodCall(_, [self_arg, ..], _)\n+                ExprKind::MethodCall(_, self_arg, ..)\n                     if expr.hir_id == self_arg.hir_id && ty != cx.typeck_results().expr_ty_adjusted(expr) =>\n                 {\n                     return;\n@@ -91,7 +94,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol,\n                     hir_callee.kind,\n                     ExprKind::Path(QPath::LangItem(rustc_hir::LangItem::TryTraitBranch, _, _))\n                 ),\n-                ExprKind::MethodCall(_, [self_arg, ..], _) if expr.hir_id == self_arg.hir_id => true,\n+                ExprKind::MethodCall(_, self_arg, ..) if expr.hir_id == self_arg.hir_id => true,\n                 ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n                 | ExprKind::Field(..)\n                 | ExprKind::Index(..) => true,"}, {"sha": "f82ca8912006180b5b853dd57f8af0538c423976", "filename": "src/tools/clippy/clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -10,12 +10,17 @@ use rustc_span::symbol::{sym, Symbol};\n \n use super::CLONE_ON_REF_PTR;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n-    if !(args.len() == 1 && method_name == sym::clone) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &hir::Expr<'_>,\n+    args: &[hir::Expr<'_>],\n+) {\n+    if !(args.is_empty() && method_name == sym::clone) {\n         return;\n     }\n-    let arg = &args[0];\n-    let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n+    let obj_ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n \n     if let ty::Adt(_, subst) = obj_ty.kind() {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n@@ -28,7 +33,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Sym\n             return;\n         };\n \n-        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n+        let snippet = snippet_with_macro_callsite(cx, receiver.span, \"..\");\n \n         span_lint_and_sugg(\n             cx,"}, {"sha": "501646863fe156c4fab56cc8452f2e23cf7e65f9", "filename": "src/tools/clippy/clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(\n         // If the parent node's `to` argument is the same as the `to` argument\n         // of the last replace call in the current chain, don't lint as it was already linted\n         if let Some(parent) = get_parent_expr(cx, expr)\n-            && let Some((\"replace\", [_, current_from, current_to], _)) = method_call(parent)\n+            && let Some((\"replace\", _, [current_from, current_to], _)) = method_call(parent)\n             && eq_expr_value(cx, to, current_to)\n             && from_kind == cx.typeck_results().expr_ty(current_from).peel_refs().kind()\n         {\n@@ -48,7 +48,7 @@ fn collect_replace_calls<'tcx>(\n     let mut from_args = VecDeque::new();\n \n     let _: Option<()> = for_each_expr(expr, |e| {\n-        if let Some((\"replace\", [_, from, to], _)) = method_call(e) {\n+        if let Some((\"replace\", _, [from, to], _)) = method_call(e) {\n             if eq_expr_value(cx, to_arg, to) && cx.typeck_results().expr_ty(from).peel_refs().is_char() {\n                 methods.push_front(e);\n                 from_args.push_front(from);\n@@ -78,7 +78,7 @@ fn check_consecutive_replace_calls<'tcx>(\n         .collect();\n     let app = Applicability::MachineApplicable;\n     let earliest_replace_call = replace_methods.methods.front().unwrap();\n-    if let Some((_, [..], span_lo)) = method_call(earliest_replace_call) {\n+    if let Some((_, _, [..], span_lo)) = method_call(earliest_replace_call) {\n         span_lint_and_sugg(\n             cx,\n             COLLAPSIBLE_STR_REPLACE,"}, {"sha": "bd846d71d4668ed29288ea248849193432903462", "filename": "src/tools/clippy/clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -19,6 +19,7 @@ pub(super) fn check<'tcx>(\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     name: &str,\n+    receiver: &'tcx hir::Expr<'tcx>,\n     args: &'tcx [hir::Expr<'tcx>],\n ) {\n     // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n@@ -28,16 +29,13 @@ pub(super) fn check<'tcx>(\n         loop {\n             arg_root = match &arg_root.kind {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n-                hir::ExprKind::MethodCall(method_name, call_args, _) => {\n-                    if call_args.len() == 1\n-                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym::as_ref)\n-                        && {\n-                            let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n-                            let base_type = arg_type.peel_refs();\n-                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::String)\n-                        }\n-                    {\n-                        &call_args[0]\n+                hir::ExprKind::MethodCall(method_name, receiver, [], ..) => {\n+                    if (method_name.ident.name == sym::as_str || method_name.ident.name == sym::as_ref) && {\n+                        let arg_type = cx.typeck_results().expr_ty(receiver);\n+                        let base_type = arg_type.peel_refs();\n+                        *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::String)\n+                    } {\n+                        receiver\n                     } else {\n                         break;\n                     }\n@@ -114,11 +112,11 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n-    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].kind) {\n+    if args.len() != 1 || name != \"expect\" || !is_call(&args[0].kind) {\n         return;\n     }\n \n-    let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let receiver_type = cx.typeck_results().expr_ty_adjusted(receiver);\n     let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym::Option) {\n         \"||\"\n     } else if is_type_diagnostic_item(cx, receiver_type, sym::Result) {\n@@ -127,7 +125,7 @@ pub(super) fn check<'tcx>(\n         return;\n     };\n \n-    let arg_root = get_arg_root(cx, &args[1]);\n+    let arg_root = get_arg_root(cx, &args[0]);\n \n     let span_replace_word = method_span.with_hi(expr.span.hi());\n "}, {"sha": "37b28463527cc5c3bcfe01233a19770ed0f6fe76", "filename": "src/tools/clippy/clippy_lints/src/methods/extend_with_drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n     if_chain! {\n         if is_type_diagnostic_item(cx, ty, sym::Vec);\n         //check source object\n-        if let ExprKind::MethodCall(src_method, [drain_vec, drain_arg], _) = &arg.kind;\n+        if let ExprKind::MethodCall(src_method, drain_vec, [drain_arg], _) = &arg.kind;\n         if src_method.ident.as_str() == \"drain\";\n         let src_ty = cx.typeck_results().expr_ty(drain_vec);\n         //check if actual src type is mutable for code suggestion"}, {"sha": "9dc839afc6256e8c9b89d8d51d3e8fd1c74f9543", "filename": "src/tools/clippy/clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -28,11 +28,11 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n             let closure_expr = peel_blocks(&body.value);\n             let arg_id = body.params[0].pat.hir_id;\n             match closure_expr.kind {\n-                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, args, _) => {\n+                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, receiver, ..) => {\n                     if_chain! {\n                     if ident.name == method_name;\n-                    if let hir::ExprKind::Path(path) = &args[0].kind;\n-                    if let Res::Local(ref local) = cx.qpath_res(path, args[0].hir_id);\n+                    if let hir::ExprKind::Path(path) = &receiver.kind;\n+                    if let Res::Local(ref local) = cx.qpath_res(path, receiver.hir_id);\n                     then {\n                         return arg_id == *local\n                     }\n@@ -106,7 +106,7 @@ pub(super) fn check<'tcx>(\n             };\n             // closure ends with is_some() or is_ok()\n             if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n-            if let ExprKind::MethodCall(path, [filter_arg], _) = filter_body.value.kind;\n+            if let ExprKind::MethodCall(path, filter_arg, [], _) = filter_body.value.kind;\n             if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).peel_refs().ty_adt_def();\n             if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did()) {\n                 Some(false)\n@@ -123,13 +123,13 @@ pub(super) fn check<'tcx>(\n             if let [map_param] = map_body.params;\n             if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n             // closure ends with expect() or unwrap()\n-            if let ExprKind::MethodCall(seg, [map_arg, ..], _) = map_body.value.kind;\n+            if let ExprKind::MethodCall(seg, map_arg, ..) = map_body.value.kind;\n             if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n \n             // .filter(..).map(|y| f(y).copied().unwrap())\n             //                     ~~~~\n             let map_arg_peeled = match map_arg.kind {\n-                ExprKind::MethodCall(method, [original_arg], _) if acceptable_methods(method) => {\n+                ExprKind::MethodCall(method, original_arg, [], _) if acceptable_methods(method) => {\n                     original_arg\n                 },\n                 _ => map_arg,"}, {"sha": "02aada87202c26cd2afb3d744e0f304850c7d1c1", "filename": "src/tools/clippy/clippy_lints/src/methods/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n     ) = arg.kind\n \n         // LHS of subtraction is \"x.len()\"\n-        && let ExprKind::MethodCall(lhs_path, [lhs_recv], _) = &lhs.kind\n+        && let ExprKind::MethodCall(lhs_path, lhs_recv, [], _) = &lhs.kind\n         && lhs_path.ident.name == sym::len\n \n         // RHS of subtraction is 1"}, {"sha": "e1c9b5248a8a4f912c434a6f1a8886d9e59b7dcd", "filename": "src/tools/clippy/clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -12,13 +12,19 @@ use rustc_span::symbol::{sym, Symbol};\n use super::INEFFICIENT_TO_STRING;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n-pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n+pub fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &hir::Expr<'_>,\n+    args: &[hir::Expr<'_>],\n+) {\n     if_chain! {\n-        if args.len() == 1 && method_name == sym::to_string;\n+        if args.is_empty() && method_name == sym::to_string;\n         if let Some(to_string_meth_did) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);\n         if let Some(substs) = cx.typeck_results().node_substs_opt(expr.hir_id);\n-        let arg_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+        let arg_ty = cx.typeck_results().expr_ty_adjusted(receiver);\n         let self_ty = substs.type_at(0);\n         let (deref_self_ty, deref_count) = walk_ptrs_ty_depth(self_ty);\n         if deref_count >= 1;\n@@ -35,7 +41,7 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n                         self_ty, deref_self_ty\n                     ));\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let arg_snippet = snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability);\n+                    let arg_snippet = snippet_with_applicability(cx, receiver.span, \"..\", &mut applicability);\n                     diag.span_suggestion(\n                         expr.span,\n                         \"try dereferencing the receiver\","}, {"sha": "11e76841e9f054425257442a1e2f7e825d7f21d1", "filename": "src/tools/clippy/clippy_lints/src/methods/into_iter_on_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -16,9 +16,9 @@ pub(super) fn check(\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     method_name: Symbol,\n-    args: &[hir::Expr<'_>],\n+    receiver: &hir::Expr<'_>,\n ) {\n-    let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let self_ty = cx.typeck_results().expr_ty_adjusted(receiver);\n     if_chain! {\n         if let ty::Ref(..) = self_ty.kind();\n         if method_name == sym::into_iter;"}, {"sha": "a669cbbbcc602c77c4fc59c6bad177892751111f", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_with_drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -35,7 +35,7 @@ fn is_full_range(cx: &LateContext<'_>, container: &Expr<'_>, range: Range<'_>) -\n         && range.end.map_or(true, |e| {\n             if range.limits == RangeLimits::HalfOpen\n                 && let ExprKind::Path(QPath::Resolved(None, container_path)) = container.kind\n-                && let ExprKind::MethodCall(name, [self_arg], _) = e.kind\n+                && let ExprKind::MethodCall(name, self_arg, [], _) = e.kind\n                 && name.ident.name == sym::len\n                 && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n             {"}, {"sha": "e04bb1c50792f4674f9c9bfd8512369c0f8703c1", "filename": "src/tools/clippy/clippy_lints/src/methods/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -48,7 +48,7 @@ pub(super) fn check<'tcx>(\n                                 }\n                             }\n                         },\n-                        hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n+                        hir::ExprKind::MethodCall(method, obj, [], _) => if_chain! {\n                             if ident_eq(name, obj) && method.ident.name == sym::clone;\n                             if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n                             if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);"}, {"sha": "fc9ba15d82a40e4e00f59c35ef8c378c43e28847", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -3161,11 +3161,13 @@ impl_lint_pass!(Methods => [\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n-fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx str, &'tcx [hir::Expr<'tcx>], Span)> {\n-    if let ExprKind::MethodCall(path, args, _) = recv.kind {\n-        if !args.iter().any(|e| e.span.from_expansion()) {\n+fn method_call<'tcx>(\n+    recv: &'tcx hir::Expr<'tcx>,\n+) -> Option<(&'tcx str, &'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>], Span)> {\n+    if let ExprKind::MethodCall(path, receiver, args, _) = recv.kind {\n+        if !args.iter().any(|e| e.span.from_expansion()) && !receiver.span.from_expansion() {\n             let name = path.ident.name.as_str();\n-            return Some((name, args, path.ident.span));\n+            return Some((name, receiver, args, path.ident.span));\n         }\n     }\n     None\n@@ -3183,17 +3185,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             hir::ExprKind::Call(func, args) => {\n                 from_iter_instead_of_collect::check(cx, expr, args, func);\n             },\n-            hir::ExprKind::MethodCall(method_call, args, _) => {\n+            hir::ExprKind::MethodCall(method_call, receiver, args, _) => {\n                 let method_span = method_call.ident.span;\n-                or_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), args);\n-                expect_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), args);\n-                clone_on_copy::check(cx, expr, method_call.ident.name, args);\n-                clone_on_ref_ptr::check(cx, expr, method_call.ident.name, args);\n-                inefficient_to_string::check(cx, expr, method_call.ident.name, args);\n-                single_char_add_str::check(cx, expr, args);\n-                into_iter_on_ref::check(cx, expr, method_span, method_call.ident.name, args);\n-                single_char_pattern::check(cx, expr, method_call.ident.name, args);\n-                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args, self.msrv);\n+                or_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), receiver, args);\n+                expect_fun_call::check(cx, expr, method_span, method_call.ident.as_str(), receiver, args);\n+                clone_on_copy::check(cx, expr, method_call.ident.name, receiver, args);\n+                clone_on_ref_ptr::check(cx, expr, method_call.ident.name, receiver, args);\n+                inefficient_to_string::check(cx, expr, method_call.ident.name, receiver, args);\n+                single_char_add_str::check(cx, expr, receiver, args);\n+                into_iter_on_ref::check(cx, expr, method_span, method_call.ident.name, receiver);\n+                single_char_pattern::check(cx, expr, method_call.ident.name, receiver, args);\n+                unnecessary_to_owned::check(cx, expr, method_call.ident.name, receiver, args, self.msrv);\n             },\n             hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {\n@@ -3379,7 +3381,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n impl Methods {\n     #[allow(clippy::too_many_lines)]\n     fn check_methods<'tcx>(&self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((name, [recv, args @ ..], span)) = method_call(expr) {\n+        if let Some((name, recv, args, span)) = method_call(expr) {\n             match (name, args) {\n                 (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                     zst_offset::check(cx, expr, recv);\n@@ -3399,40 +3401,40 @@ impl Methods {\n                 (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n                 (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, self.msrv),\n                 (\"collect\", []) => match method_call(recv) {\n-                    Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n+                    Some((name @ (\"cloned\" | \"copied\"), recv2, [], _)) => {\n                         iter_cloned_collect::check(cx, name, expr, recv2);\n                     },\n-                    Some((\"map\", [m_recv, m_arg], _)) => {\n+                    Some((\"map\", m_recv, [m_arg], _)) => {\n                         map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n                     },\n-                    Some((\"take\", [take_self_arg, take_arg], _)) => {\n+                    Some((\"take\", take_self_arg, [take_arg], _)) => {\n                         if meets_msrv(self.msrv, msrvs::STR_REPEAT) {\n                             manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n                         }\n                     },\n                     _ => {},\n                 },\n                 (\"count\", []) if is_trait_method(cx, expr, sym::Iterator) => match method_call(recv) {\n-                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n-                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n+                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n+                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), recv2, [], _)) => {\n                         iter_count::check(cx, expr, recv2, name2);\n                     },\n-                    Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n-                    Some((\"filter\", [recv2, arg], _)) => bytecount::check(cx, expr, recv2, arg),\n-                    Some((\"bytes\", [recv2], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n+                    Some((\"map\", _, [arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    Some((\"filter\", recv2, [arg], _)) => bytecount::check(cx, expr, recv2, arg),\n+                    Some((\"bytes\", recv2, [], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n                     _ => {},\n                 },\n                 (\"drain\", [arg]) => {\n                     iter_with_drain::check(cx, expr, recv, span, arg);\n                 },\n                 (\"ends_with\", [arg]) => {\n-                    if let ExprKind::MethodCall(_, _, span) = expr.kind {\n+                    if let ExprKind::MethodCall(.., span) = expr.kind {\n                         case_sensitive_file_extension_comparisons::check(cx, expr, span, recv, arg);\n                     }\n                 },\n                 (\"expect\", [_]) => match method_call(recv) {\n-                    Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n-                    Some((\"err\", [recv], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n+                    Some((\"ok\", recv, [], _)) => ok_expect::check(cx, expr, recv),\n+                    Some((\"err\", recv, [], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n                     _ => expect_used::check(cx, expr, recv, false, self.allow_expect_in_tests),\n                 },\n                 (\"expect_err\", [_]) => expect_used::check(cx, expr, recv, true, self.allow_expect_in_tests),\n@@ -3452,13 +3454,13 @@ impl Methods {\n                     flat_map_option::check(cx, expr, arg, span);\n                 },\n                 (\"flatten\", []) => match method_call(recv) {\n-                    Some((\"map\", [recv, map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n-                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n+                    Some((\"map\", recv, [map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n+                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n                     _ => {},\n                 },\n                 (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n                 (\"for_each\", [_]) => {\n-                    if let Some((\"inspect\", [_, _], span2)) = method_call(recv) {\n+                    if let Some((\"inspect\", _, [_], span2)) = method_call(recv) {\n                         inspect_for_each::check(cx, expr, span2);\n                     }\n                 },\n@@ -3478,12 +3480,12 @@ impl Methods {\n                     iter_on_single_or_empty_collections::check(cx, expr, name, recv);\n                 },\n                 (\"join\", [join_arg]) => {\n-                    if let Some((\"collect\", _, span)) = method_call(recv) {\n+                    if let Some((\"collect\", _, _, span)) = method_call(recv) {\n                         unnecessary_join::check(cx, expr, recv, join_arg, span);\n                     }\n                 },\n                 (\"last\", []) | (\"skip\", [_]) => {\n-                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3498,7 +3500,7 @@ impl Methods {\n                     } else {\n                         map_err_ignore::check(cx, expr, m_arg);\n                     }\n-                    if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n+                    if let Some((name, recv2, args, span2)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n                             (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, self.msrv),\n@@ -3518,7 +3520,7 @@ impl Methods {\n                     manual_ok_or::check(cx, expr, recv, def, map);\n                 },\n                 (\"next\", []) => {\n-                    if let Some((name2, [recv2, args2 @ ..], _)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _)) = method_call(recv) {\n                         match (name2, args2) {\n                             (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n                             (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n@@ -3531,10 +3533,10 @@ impl Methods {\n                     }\n                 },\n                 (\"nth\", [n_arg]) => match method_call(recv) {\n-                    Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n-                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n-                    Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n-                    Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n+                    Some((\"bytes\", recv2, [], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n+                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n+                    Some((\"iter\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n+                    Some((\"iter_mut\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n                     _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n                 },\n                 (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n@@ -3591,7 +3593,7 @@ impl Methods {\n                 },\n                 (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n                 (\"take\", [_arg]) => {\n-                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3614,13 +3616,13 @@ impl Methods {\n                 },\n                 (\"unwrap\", []) => {\n                     match method_call(recv) {\n-                        Some((\"get\", [recv, get_arg], _)) => {\n+                        Some((\"get\", recv, [get_arg], _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, false);\n                         },\n-                        Some((\"get_mut\", [recv, get_arg], _)) => {\n+                        Some((\"get_mut\", recv, [get_arg], _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, true);\n                         },\n-                        Some((\"or\", [recv, or_arg], or_span)) => {\n+                        Some((\"or\", recv, [or_arg], or_span)) => {\n                             or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n                         },\n                         _ => {},\n@@ -3629,27 +3631,27 @@ impl Methods {\n                 },\n                 (\"unwrap_err\", []) => unwrap_used::check(cx, expr, recv, true, self.allow_unwrap_in_tests),\n                 (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n-                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n+                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), lhs, [rhs], _)) => {\n                         manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                     },\n-                    Some((\"map\", [m_recv, m_arg], span)) => {\n+                    Some((\"map\", m_recv, [m_arg], span)) => {\n                         option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n                     },\n-                    Some((\"then_some\", [t_recv, t_arg], _)) => {\n+                    Some((\"then_some\", t_recv, [t_arg], _)) => {\n                         obfuscated_if_else::check(cx, expr, t_recv, t_arg, u_arg);\n                     },\n                     _ => {},\n                 },\n                 (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n-                    Some((\"map\", [recv, map_arg], _))\n+                    Some((\"map\", recv, [map_arg], _))\n                         if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, self.msrv) => {},\n                     _ => {\n                         unwrap_or_else_default::check(cx, expr, recv, u_arg);\n                         unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n                     },\n                 },\n                 (\"zip\", [arg]) => {\n-                    if let ExprKind::MethodCall(name, [iter_recv], _) = recv.kind\n+                    if let ExprKind::MethodCall(name, iter_recv, [], _) = recv.kind\n                         && name.ident.name == sym::iter\n                     {\n                         range_zip_with_len::check(cx, expr, iter_recv, arg);\n@@ -3662,7 +3664,7 @@ impl Methods {\n }\n \n fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n-    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call(recv) {\n+    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), f_recv, [arg], span)) = method_call(recv) {\n         search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span);\n     }\n }"}, {"sha": "903fa306f935a8e6b005c7c67e6323b6ad706a27", "filename": "src/tools/clippy/clippy_lints/src/methods/open_options.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -36,12 +36,12 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprKind::MethodCall(path, arguments, _) = argument.kind {\n-        let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n+    if let ExprKind::MethodCall(path, receiver, arguments, _) = argument.kind {\n+        let obj_ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n-        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n-            let argument_option = match arguments[1].kind {\n+        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 1 {\n+            let argument_option = match arguments[0].kind {\n                 ExprKind::Lit(ref span) => {\n                     if let Spanned {\n                         node: LitKind::Bool(lit),\n@@ -77,7 +77,7 @@ fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec\n                 _ => (),\n             }\n \n-            get_open_options(cx, &arguments[0], options);\n+            get_open_options(cx, receiver, options);\n         }\n     }\n }"}, {"sha": "81c67b4ca6a59d0816908e88e600eeff66e13e38", "filename": "src/tools/clippy/clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -56,13 +56,12 @@ pub(super) fn check<'tcx>(\n             let closure_expr = peel_blocks(&closure_body.value);\n \n             match &closure_expr.kind {\n-                hir::ExprKind::MethodCall(_, args, _) => {\n+                hir::ExprKind::MethodCall(_, receiver, [], _) => {\n                     if_chain! {\n-                        if args.len() == 1;\n-                        if path_to_local_id(&args[0], closure_body.params[0].pat.hir_id);\n+                        if path_to_local_id(receiver, closure_body.params[0].pat.hir_id);\n                         let adj = cx\n                             .typeck_results()\n-                            .expr_adjustments(&args[0])\n+                            .expr_adjustments(receiver)\n                             .iter()\n                             .map(|x| &x.kind)\n                             .collect::<Box<[_]>>();"}, {"sha": "76876d8662936846bb7766db36547df3903900a5", "filename": "src/tools/clippy/clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -20,6 +20,7 @@ pub(super) fn check<'tcx>(\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     name: &str,\n+    receiver: &'tcx hir::Expr<'_>,\n     args: &'tcx [hir::Expr<'_>],\n ) {\n     /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n@@ -144,7 +145,7 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n-    if let [self_arg, arg] = args {\n+    if let [arg] = args {\n         let inner_arg = if let hir::ExprKind::Block(\n             hir::Block {\n                 stmts: [],\n@@ -163,11 +164,11 @@ pub(super) fn check<'tcx>(\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, arg, or_has_args, expr.span, method_span) {\n                     let fun_span = if or_has_args { None } else { Some(fun.span) };\n-                    check_general_case(cx, name, method_span, self_arg, arg, expr.span, fun_span);\n+                    check_general_case(cx, name, method_span, receiver, arg, expr.span, fun_span);\n                 }\n             },\n             hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n-                check_general_case(cx, name, method_span, self_arg, arg, expr.span, None);\n+                check_general_case(cx, name, method_span, receiver, arg, expr.span, None);\n             },\n             _ => (),\n         }"}, {"sha": "867a3b4023770e6e162bc2227960022866d10cc5", "filename": "src/tools/clippy/clippy_lints/src/methods/range_zip_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -16,7 +16,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'\n         if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n         if is_integer_const(cx, start, 0);\n         // `.len()` call\n-        if let ExprKind::MethodCall(len_path, [len_recv], _) = end.kind;\n+        if let ExprKind::MethodCall(len_path, len_recv, [], _) = end.kind;\n         if len_path.ident.name == sym::len;\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = recv.kind;"}, {"sha": "81450fd8c6c3c565faa9350ef60f2b868e181e03", "filename": "src/tools/clippy/clippy_lints/src/methods/single_char_add_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -3,12 +3,12 @@ use clippy_utils::{match_def_path, paths};\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n         if match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n-            single_char_push_string::check(cx, expr, args);\n+            single_char_push_string::check(cx, expr, receiver, args);\n         } else if match_def_path(cx, fn_def_id, &paths::INSERT_STR) {\n-            single_char_insert_string::check(cx, expr, args);\n+            single_char_insert_string::check(cx, expr, receiver, args);\n         }\n     }\n }"}, {"sha": "18b6b5be175d14f34ecb22093fc49d354482ce53", "filename": "src/tools/clippy/clippy_lints/src/methods/single_char_insert_string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -8,12 +8,12 @@ use rustc_lint::LateContext;\n use super::SINGLE_CHAR_ADD_STR;\n \n /// lint for length-1 `str`s as argument for `insert_str`\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n-    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[2], &mut applicability) {\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n         let base_string_snippet =\n-            snippet_with_applicability(cx, args[0].span.source_callsite(), \"_\", &mut applicability);\n-        let pos_arg = snippet_with_applicability(cx, args[1].span, \"..\", &mut applicability);\n+            snippet_with_applicability(cx, receiver.span.source_callsite(), \"_\", &mut applicability);\n+        let pos_arg = snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability);\n         let sugg = format!(\"{}.insert({}, {})\", base_string_snippet, pos_arg, extension_string);\n         span_lint_and_sugg(\n             cx,"}, {"sha": "4221c52d5cd79a57924fa2b8af6ed4caaf3b8c4a", "filename": "src/tools/clippy/clippy_lints/src/methods/single_char_pattern.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -10,37 +10,43 @@ use rustc_span::symbol::Symbol;\n use super::SINGLE_CHAR_PATTERN;\n \n const PATTERN_METHODS: [(&str, usize); 24] = [\n-    (\"contains\", 1),\n-    (\"starts_with\", 1),\n-    (\"ends_with\", 1),\n-    (\"find\", 1),\n-    (\"rfind\", 1),\n-    (\"split\", 1),\n-    (\"split_inclusive\", 1),\n-    (\"rsplit\", 1),\n-    (\"split_terminator\", 1),\n-    (\"rsplit_terminator\", 1),\n-    (\"splitn\", 2),\n-    (\"rsplitn\", 2),\n-    (\"split_once\", 1),\n-    (\"rsplit_once\", 1),\n-    (\"matches\", 1),\n-    (\"rmatches\", 1),\n-    (\"match_indices\", 1),\n-    (\"rmatch_indices\", 1),\n-    (\"strip_prefix\", 1),\n-    (\"strip_suffix\", 1),\n-    (\"trim_start_matches\", 1),\n-    (\"trim_end_matches\", 1),\n-    (\"replace\", 1),\n-    (\"replacen\", 1),\n+    (\"contains\", 0),\n+    (\"starts_with\", 0),\n+    (\"ends_with\", 0),\n+    (\"find\", 0),\n+    (\"rfind\", 0),\n+    (\"split\", 0),\n+    (\"split_inclusive\", 0),\n+    (\"rsplit\", 0),\n+    (\"split_terminator\", 0),\n+    (\"rsplit_terminator\", 0),\n+    (\"splitn\", 1),\n+    (\"rsplitn\", 1),\n+    (\"split_once\", 0),\n+    (\"rsplit_once\", 0),\n+    (\"matches\", 0),\n+    (\"rmatches\", 0),\n+    (\"match_indices\", 0),\n+    (\"rmatch_indices\", 0),\n+    (\"strip_prefix\", 0),\n+    (\"strip_suffix\", 0),\n+    (\"trim_start_matches\", 0),\n+    (\"trim_end_matches\", 0),\n+    (\"replace\", 0),\n+    (\"replacen\", 0),\n ];\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-pub(super) fn check(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    _expr: &hir::Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &hir::Expr<'_>,\n+    args: &[hir::Expr<'_>],\n+) {\n     for &(method, pos) in &PATTERN_METHODS {\n         if_chain! {\n-            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(&args[0]).kind();\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(receiver).kind();\n             if *ty.kind() == ty::Str;\n             if method_name.as_str() == method && args.len() > pos;\n             let arg = &args[pos];"}, {"sha": "9ea6751956abb2c42b1492e917c64eaa36a8617c", "filename": "src/tools/clippy/clippy_lints/src/methods/single_char_push_string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -8,11 +8,11 @@ use rustc_lint::LateContext;\n use super::SINGLE_CHAR_ADD_STR;\n \n /// lint for length-1 `str`s as argument for `push_str`\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, receiver: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n-    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[0], &mut applicability) {\n         let base_string_snippet =\n-            snippet_with_applicability(cx, args[0].span.source_callsite(), \"..\", &mut applicability);\n+            snippet_with_applicability(cx, receiver.span.source_callsite(), \"..\", &mut applicability);\n         let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n         span_lint_and_sugg(\n             cx,"}, {"sha": "8f2f4752514718d2ff8eacb8c650d051b5f7b3ce", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -292,7 +292,7 @@ fn parse_iter_usage<'tcx>(\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n-            let (name, args) = if let ExprKind::MethodCall(name, [_, args @ ..], _) = e.kind {\n+            let (name, args) = if let ExprKind::MethodCall(name, _, [args @ ..], _) = e.kind {\n                 (name, args)\n             } else {\n                 return None;\n@@ -327,7 +327,7 @@ fn parse_iter_usage<'tcx>(\n                         } else {\n                             if_chain! {\n                                 if let Some((_, Node::Expr(next_expr))) = iter.next();\n-                                if let ExprKind::MethodCall(next_name, [_], _) = next_expr.kind;\n+                                if let ExprKind::MethodCall(next_name, _, [], _) = next_expr.kind;\n                                 if next_name.ident.name == sym::next;\n                                 if next_expr.span.ctxt() == ctxt;\n                                 if let Some(next_id) = cx.typeck_results().type_dependent_def_id(next_expr.hir_id);\n@@ -367,7 +367,7 @@ fn parse_iter_usage<'tcx>(\n                 }\n             },\n             _ if e.span.ctxt() != ctxt => (None, span),\n-            ExprKind::MethodCall(name, [_], _)\n+            ExprKind::MethodCall(name, _, [], _)\n                 if name.ident.name == sym::unwrap\n                     && cx\n                         .typeck_results()"}, {"sha": "143dcee350521075ee0acd3acd3459107fa02708", "filename": "src/tools/clippy/clippy_lints/src/methods/string_extend_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -16,7 +16,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         return;\n     }\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n-        let target = &arglists[0][0];\n+        let target = &arglists[0].0;\n         let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n         let ref_str = if *self_ty.kind() == ty::Str {\n             \"\""}, {"sha": "95138c0e25b034a088447c327bda976b0a15b3e4", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -43,7 +43,7 @@ pub fn check_for_loop_iter(\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n             let snippet = if_chain! {\n-                if let ExprKind::MethodCall(maybe_iter_method_name, [collection], _) = receiver.kind;\n+                if let ExprKind::MethodCall(maybe_iter_method_name, collection, [], _) = receiver.kind;\n                 if maybe_iter_method_name.ident.name == sym::iter;\n \n                 if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);"}, {"sha": "a187a8d6016f871325c2d58ca803d19add8ca842", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -54,7 +54,7 @@ pub(super) fn check<'tcx>(\n                 // This is a duplicate of what's happening in clippy_lints::methods::method_call,\n                 // which isn't ideal, We want to get the method call span,\n                 // but prefer to avoid changing the signature of the function itself.\n-                if let hir::ExprKind::MethodCall(_, _, span) = expr.kind {\n+                if let hir::ExprKind::MethodCall(.., span) = expr.kind {\n                     span_lint_and_then(cx, UNNECESSARY_LAZY_EVALUATIONS, expr.span, msg, |diag| {\n                         diag.span_suggestion(\n                             span,"}, {"sha": "6f25acca1de6123e1a08586d8edd57f17fe192d8", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_sort_by.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -50,9 +50,13 @@ fn mirrored_exprs(a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n-        (ExprKind::MethodCall(left_segment, left_args, _), ExprKind::MethodCall(right_segment, right_args, _)) => {\n+        (\n+            ExprKind::MethodCall(left_segment, left_receiver, left_args, _),\n+            ExprKind::MethodCall(right_segment, right_receiver, right_args, _),\n+        ) => {\n             left_segment.ident == right_segment.ident\n                 && iter::zip(*left_args, *right_args).all(|(left, right)| mirrored_exprs(left, a_ident, right, b_ident))\n+                && mirrored_exprs(left_receiver, a_ident, right_receiver, b_ident)\n         },\n         // Two tuples with mirrored contents\n         (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => {\n@@ -125,7 +129,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Exp\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n-        if let ExprKind::MethodCall(method_path, [left_expr, right_expr], _) = closure_body.value.kind;\n+        if let ExprKind::MethodCall(method_path, left_expr, [right_expr], _) = closure_body.value.kind;\n         if method_path.ident.name == sym::cmp;\n         if is_trait_method(cx, &closure_body.value, sym::Ord);\n         then {"}, {"sha": "9dceb9af2f2234b09673affa472dce6887b57bdf", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -24,12 +24,13 @@ pub fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n     method_name: Symbol,\n-    args: &'tcx [Expr<'tcx>],\n+    receiver: &'tcx Expr<'_>,\n+    args: &'tcx [Expr<'_>],\n     msrv: Option<RustcVersion>,\n ) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-        if let [receiver] = args;\n+        if args.is_empty();\n         then {\n             if is_cloned_or_copied(cx, method_name, method_def_id) {\n                 unnecessary_iter_cloned::check(cx, expr, method_name, receiver);\n@@ -245,9 +246,14 @@ fn check_other_call_arg<'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some((maybe_call, maybe_arg)) = skip_addr_of_ancestors(cx, expr);\n-        if let Some((callee_def_id, call_substs, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n+        if let Some((callee_def_id, call_substs, call_receiver, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n         let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n-        if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n+        let index = if let Some(call_receiver) = call_receiver {\n+            std::iter::once(call_receiver).chain(call_args.iter()).position(|arg| arg.hir_id == maybe_arg.hir_id)\n+        } else {\n+            call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id)\n+        };\n+        if let Some(i) = index;\n         if let Some(input) = fn_sig.inputs().get(i);\n         let (input, n_refs) = peel_mid_ty_refs(*input);\n         if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n@@ -342,22 +348,22 @@ fn skip_addr_of_ancestors<'tcx>(\n fn get_callee_substs_and_args<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n-) -> Option<(DefId, SubstsRef<'tcx>, &'tcx [Expr<'tcx>])> {\n+) -> Option<(DefId, SubstsRef<'tcx>, Option<&'tcx Expr<'tcx>>, &'tcx [Expr<'tcx>])> {\n     if_chain! {\n         if let ExprKind::Call(callee, args) = expr.kind;\n         let callee_ty = cx.typeck_results().expr_ty(callee);\n         if let ty::FnDef(callee_def_id, _) = callee_ty.kind();\n         then {\n             let substs = cx.typeck_results().node_substs(callee.hir_id);\n-            return Some((*callee_def_id, substs, args));\n+            return Some((*callee_def_id, substs, None, args));\n         }\n     }\n     if_chain! {\n-        if let ExprKind::MethodCall(_, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(_, receiver, args, _) = expr.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         then {\n             let substs = cx.typeck_results().node_substs(expr.hir_id);\n-            return Some((method_def_id, substs, args));\n+            return Some((method_def_id, substs, Some(receiver), args));\n         }\n     }\n     None"}, {"sha": "ae6b165fdc36650d8517e9d2b1f450a934ecc0b3", "filename": "src/tools/clippy/clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -28,7 +28,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n         }\n     }\n \n-    if let hir::ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind {\n+    if let hir::ExprKind::MethodCall(path, self_arg, ..) = &expr.kind {\n         if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(self_arg)) {\n             Some(self_arg)\n         } else {\n@@ -139,9 +139,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n                         self.addr_of_exprs.push(parent);\n                         return;\n                     },\n-                    ExprKind::MethodCall(_, args, _) => {\n+                    ExprKind::MethodCall(.., args, _) => {\n                         if_chain! {\n-                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n+                            if args.iter().all(|arg| !self.is_binding(arg));\n                             if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n                             let method_ty = self.cx.tcx.type_of(method_def_id);\n                             let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();"}, {"sha": "44b21e7b080d22c6aa8c8654ceb76b226ccba6d2", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -75,23 +75,22 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n                     .qpath_res(qpath, path.hir_id)\n                     .opt_def_id()\n                     .and_then(|def_id| match cx.tcx.get_diagnostic_name(def_id) {\n-                        Some(sym::cmp_min) => fetch_const(cx, args, MinMax::Min),\n-                        Some(sym::cmp_max) => fetch_const(cx, args, MinMax::Max),\n+                        Some(sym::cmp_min) => fetch_const(cx, None, args, MinMax::Min),\n+                        Some(sym::cmp_max) => fetch_const(cx, None, args, MinMax::Max),\n                         _ => None,\n                     })\n             } else {\n                 None\n             }\n         },\n-        ExprKind::MethodCall(path, args, _) => {\n+        ExprKind::MethodCall(path, receiver, args @ [_], _) => {\n             if_chain! {\n-                if let [obj, _] = args;\n-                if cx.typeck_results().expr_ty(obj).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);\n+                if cx.typeck_results().expr_ty(receiver).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);\n                 then {\n                     if path.ident.name == sym!(max) {\n-                        fetch_const(cx, args, MinMax::Max)\n+                        fetch_const(cx, Some(receiver), args, MinMax::Max)\n                     } else if path.ident.name == sym!(min) {\n-                        fetch_const(cx, args, MinMax::Min)\n+                        fetch_const(cx, Some(receiver), args, MinMax::Min)\n                     } else {\n                         None\n                     }\n@@ -104,16 +103,24 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n     }\n }\n \n-fn fetch_const<'a>(cx: &LateContext<'_>, args: &'a [Expr<'a>], m: MinMax) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n-    if args.len() != 2 {\n+fn fetch_const<'a>(\n+    cx: &LateContext<'_>,\n+    receiver: Option<&'a Expr<'a>>,\n+    args: &'a [Expr<'a>],\n+    m: MinMax,\n+) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n+    let mut args = receiver.into_iter().chain(args.into_iter());\n+    let arg0 = args.next()?;\n+    let arg1 = args.next()?;\n+    if args.next().is_some() {\n         return None;\n     }\n-    constant_simple(cx, cx.typeck_results(), &args[0]).map_or_else(\n-        || constant_simple(cx, cx.typeck_results(), &args[1]).map(|c| (m, c, &args[0])),\n+    constant_simple(cx, cx.typeck_results(), arg0).map_or_else(\n+        || constant_simple(cx, cx.typeck_results(), arg1).map(|c| (m, c, arg0)),\n         |c| {\n-            if constant_simple(cx, cx.typeck_results(), &args[1]).is_none() {\n+            if constant_simple(cx, cx.typeck_results(), arg1).is_none() {\n                 // otherwise ignore\n-                Some((m, c, &args[1]))\n+                Some((m, c, arg1))\n             } else {\n                 None\n             }"}, {"sha": "82dc03ef5c5bce3c264c505ef9ff5b5075a115b4", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -43,18 +43,24 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                 if let ExprKind::Path(ref path) = fn_expr.kind {\n                     check_arguments(\n                         cx,\n-                        arguments,\n+                        arguments.iter().collect(),\n                         cx.typeck_results().expr_ty(fn_expr),\n                         &rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false)),\n                         \"function\",\n                     );\n                 }\n             },\n-            ExprKind::MethodCall(path, arguments, _) => {\n+            ExprKind::MethodCall(path, receiver, arguments, _) => {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.bound_type_of(def_id).subst(cx.tcx, substs);\n-                check_arguments(cx, arguments, method_type, path.ident.as_str(), \"method\");\n+                check_arguments(\n+                    cx,\n+                    std::iter::once(receiver).chain(arguments.iter()).collect(),\n+                    method_type,\n+                    path.ident.as_str(),\n+                    \"method\",\n+                );\n             },\n             _ => (),\n         }\n@@ -63,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n \n fn check_arguments<'tcx>(\n     cx: &LateContext<'tcx>,\n-    arguments: &[Expr<'_>],\n+    arguments: Vec<&Expr<'_>>,\n     type_definition: Ty<'tcx>,\n     name: &str,\n     fn_kind: &str,"}, {"sha": "f8cc3fbb3cdfaeacdcc0332fb432c05586d767eb", "filename": "src/tools/clippy/clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -56,12 +56,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessForEach {\n \n         if_chain! {\n             // Check the method name is `for_each`.\n-            if let ExprKind::MethodCall(method_name, [for_each_recv, for_each_arg], _) = expr.kind;\n+            if let ExprKind::MethodCall(method_name, for_each_recv, [for_each_arg], _) = expr.kind;\n             if method_name.ident.name == Symbol::intern(\"for_each\");\n             // Check `for_each` is an associated function of `Iterator`.\n             if is_trait_method(cx, expr, sym::Iterator);\n             // Checks the receiver of `for_each` is also a method call.\n-            if let ExprKind::MethodCall(_, [iter_recv], _) = for_each_recv.kind;\n+            if let ExprKind::MethodCall(_, iter_recv, [], _) = for_each_recv.kind;\n             // Skip the lint if the call chain is too long. e.g. `v.field.iter().for_each()` or\n             // `v.foo().iter().for_each()` must be skipped.\n             if matches!("}, {"sha": "25fb4f0f4cff199ed2aa961faad136b0e533e1d0", "filename": "src/tools/clippy/clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -43,7 +43,7 @@ declare_lint_pass!(NonOctalUnixPermissions => [NON_OCTAL_UNIX_PERMISSIONS]);\n impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         match &expr.kind {\n-            ExprKind::MethodCall(path, [func, param], _) => {\n+            ExprKind::MethodCall(path, func, [param], _) => {\n                 let obj_ty = cx.typeck_results().expr_ty(func).peel_refs();\n \n                 if_chain! {"}, {"sha": "17d5fa2152bbffe438f627e0d41103f9c063df95", "filename": "src/tools/clippy/clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -304,13 +304,13 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n                             }\n                             return;\n                         },\n-                        ExprKind::MethodCall(_, args, _)\n+                        ExprKind::MethodCall(_, receiver, args, _)\n                             if typeck.type_dependent_def_id(parent.hir_id).map_or(false, |id| {\n                                 id == param.fn_id\n                                     && has_matching_substs(param.fn_kind, typeck.node_substs(parent.hir_id))\n                             }) =>\n                         {\n-                            if let Some(idx) = args.iter().position(|arg| arg.hir_id == child_id) {\n+                            if let Some(idx) = std::iter::once(receiver).chain(args.iter()).position(|arg| arg.hir_id == child_id) {\n                                 param.uses.push(Usage::new(span, idx));\n                             }\n                             return;"}, {"sha": "638a514ff9b361f7e33e3bc02d86f25e3214688f", "filename": "src/tools/clippy/clippy_lints/src/operators/cmp_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -38,7 +38,7 @@ fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'t\n fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n     let typeck = cx.typeck_results();\n     let (arg, arg_span) = match expr.kind {\n-        ExprKind::MethodCall(.., [arg], _)\n+        ExprKind::MethodCall(_, arg, [], _)\n             if typeck\n                 .type_dependent_def_id(expr.hir_id)\n                 .and_then(|id| cx.tcx.trait_of_item(id))"}, {"sha": "827a2b26709350dc1ad9ceb3f678cca5ab26a82d", "filename": "src/tools/clippy/clippy_lints/src/operators/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -17,7 +17,7 @@ pub(crate) fn check<'tcx>(\n     right: &'tcx Expr<'_>,\n ) {\n     if op == BinOpKind::Div\n-        && let ExprKind::MethodCall(method_path, [self_arg], _) = left.kind\n+        && let ExprKind::MethodCall(method_path, self_arg, [], _) = left.kind\n         && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_arg).peel_refs(), sym::Duration)\n         && let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right)\n     {"}, {"sha": "97ddcdb24799d12ac2a73d9202a2b724b6249fb4", "filename": "src/tools/clippy/clippy_lints/src/operators/float_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -113,7 +113,7 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n \n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, self_arg, ..) = expr.kind;\n         if sym!(signum) == method_name.ident.name;\n         // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n         // the method call)"}, {"sha": "63c9faf0396fd3d8ffdd6a610113147827b552df", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -591,8 +591,11 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                             set_skip_flag();\n                         }\n                     },\n-                    ExprKind::MethodCall(name, expr_args @ [self_arg, ..], _) => {\n-                        let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n+                    ExprKind::MethodCall(name, self_arg, expr_args, _) => {\n+                        let i = std::iter::once(self_arg)\n+                            .chain(expr_args.iter())\n+                            .position(|arg| arg.hir_id == child_id)\n+                            .unwrap_or(0);\n                         if i == 0 {\n                             // Check if the method can be renamed.\n                             let name = name.ident.as_str();"}, {"sha": "4dc65da3ea1fd9fd8227823a0ce416c6c573a466", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -93,7 +93,7 @@ fn expr_as_ptr_offset_call<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n-    if let ExprKind::MethodCall(path_segment, [arg_0, arg_1, ..], _) = &expr.kind {\n+    if let ExprKind::MethodCall(path_segment, arg_0, [arg_1, ..], _) = &expr.kind {\n         if is_expr_ty_raw_ptr(cx, arg_0) {\n             if path_segment.ident.name == sym::offset {\n                 return Some((arg_0, arg_1, Method::Offset));"}, {"sha": "6fddbd419bcd83eb48d0a32c04214dfdf5edf345", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -86,7 +86,7 @@ fn check_is_none_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Ex\n     if_chain! {\n         if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n         if !is_else_clause(cx.tcx, expr);\n-        if let ExprKind::MethodCall(segment, [caller, ..], _) = &cond.kind;\n+        if let ExprKind::MethodCall(segment, caller, ..) = &cond.kind;\n         let caller_ty = cx.typeck_results().expr_ty(caller);\n         let if_block = IfBlockType::IfIs(caller, caller_ty, segment.ident.name, then, r#else);\n         if is_early_return(sym::Option, cx, &if_block) || is_early_return(sym::Result, cx, &if_block);"}, {"sha": "94dec191103c587d02a2bc8501cfc0ac02cc0bb1", "filename": "src/tools/clippy/clippy_lints/src/read_zero_byte_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fread_zero_byte_vec.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for ReadZeroByteVec {\n                 // finds use of `_.read(&mut v)`\n                 let mut read_found = false;\n                 let mut visitor = expr_visitor_no_bodies(|expr| {\n-                    if let ExprKind::MethodCall(path, [_self, arg], _) = expr.kind\n+                    if let ExprKind::MethodCall(path, _self, [arg], _) = expr.kind\n                         && let PathSegment { ident: read_or_read_exact, .. } = *path\n                         && matches!(read_or_read_exact.as_str(), \"read\" | \"read_exact\")\n                         && let ExprKind::AddrOf(_, hir::Mutability::Mut, inner) = arg.kind"}, {"sha": "ac4e29e9dfdfa0f5d5c95b93b2b6883284aeb757", "filename": "src/tools/clippy/clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -108,7 +108,7 @@ fn get_pointee_ty_and_count_expr<'tcx>(\n     };\n     if_chain! {\n         // Find calls to copy_{from,to}{,_nonoverlapping} and write_bytes methods\n-        if let ExprKind::MethodCall(method_path, [ptr_self, .., count], _) = expr.kind;\n+        if let ExprKind::MethodCall(method_path, ptr_self, [.., count], _) = expr.kind;\n         let method_ident = method_path.ident.as_str();\n         if METHODS.iter().any(|m| *m == method_ident);\n "}, {"sha": "b35782184670320ebbdb796bc5eaf2464f4eb66a", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(path, [self_arg, extend_arg], _) = expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, [extend_arg], _) = expr.kind;\n             if path_to_local_id(self_arg, self.vec_alloc.local_id);\n             if path.ident.name == sym!(extend);\n             if self.is_repeat_take(extend_arg);\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Checks if the given expression is resizing a vector with 0\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if self.initialization_found\n-            && let ExprKind::MethodCall(path, [self_arg, len_arg, fill_arg], _) = expr.kind\n+            && let ExprKind::MethodCall(path, self_arg, [len_arg, fill_arg], _) = expr.kind\n             && path_to_local_id(self_arg, self.vec_alloc.local_id)\n             && path.ident.name == sym!(resize)\n             // Check that is filled with 0\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n                 // Check that len expression is equals to `with_capacity` expression\n                 if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n                     self.slow_expression = Some(InitializationType::Resize(expr));\n-                } else if let ExprKind::MethodCall(path, _, _) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n+                } else if let ExprKind::MethodCall(path, ..) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n                     self.slow_expression = Some(InitializationType::Resize(expr));\n                 }\n             }\n@@ -233,15 +233,15 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if give expression is `repeat(0).take(...)`\n     fn is_repeat_take(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::MethodCall(take_path, [recv, len_arg, ..], _) = expr.kind;\n+            if let ExprKind::MethodCall(take_path, recv, [len_arg, ..], _) = expr.kind;\n             if take_path.ident.name == sym!(take);\n             // Check that take is applied to `repeat(0)`\n             if self.is_repeat_zero(recv);\n             then {\n                 // Check that len expression is equals to `with_capacity` expression\n                 if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n                     return true;\n-                } else if let ExprKind::MethodCall(path, _, _) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n+                } else if let ExprKind::MethodCall(path, ..) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n                     return true;\n                 }\n             }"}, {"sha": "662d399ca538a6918a07b3a69d14996ca1febc6d", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -262,15 +262,15 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n             let (method_names, expressions, _) = method_calls(left, 1);\n             if method_names.len() == 1;\n             if expressions.len() == 1;\n-            if expressions[0].len() == 1;\n+            if expressions[0].1.is_empty();\n             if method_names[0] == sym!(as_bytes);\n \n             // Check for slicer\n             if let ExprKind::Struct(QPath::LangItem(LangItem::Range, ..), _, _) = right.kind;\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let string_expression = &expressions[0][0];\n+                let string_expression = &expressions[0].0;\n \n                 let snippet_app = snippet_with_applicability(\n                     cx,\n@@ -291,12 +291,12 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, args, _) = &e.kind;\n+            if let ExprKind::MethodCall(path, receiver, ..) = &e.kind;\n             if path.ident.name == sym!(as_bytes);\n-            if let ExprKind::Lit(lit) = &args[0].kind;\n+            if let ExprKind::Lit(lit) = &receiver.kind;\n             if let LitKind::Str(lit_content, _) = &lit.node;\n             then {\n-                let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);\n+                let callsite = snippet(cx, receiver.span.source_callsite(), r#\"\"foo\"\"#);\n                 let mut applicability = Applicability::MachineApplicable;\n                 if callsite.starts_with(\"include_str!\") {\n                     span_lint_and_sugg(\n@@ -305,7 +305,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                         e.span,\n                         \"calling `as_bytes()` on `include_str!(..)`\",\n                         \"consider using `include_bytes!(..)` instead\",\n-                        snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability).replacen(\n+                        snippet_with_applicability(cx, receiver.span, r#\"\"foo\"\"#, &mut applicability).replacen(\n                             \"include_str\",\n                             \"include_bytes\",\n                             1,\n@@ -314,7 +314,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                     );\n                 } else if lit_content.as_str().is_ascii()\n                     && lit_content.as_str().len() <= MAX_LENGTH_BYTE_STRING_LIT\n-                    && !args[0].span.from_expansion()\n+                    && !receiver.span.from_expansion()\n                 {\n                     span_lint_and_sugg(\n                         cx,\n@@ -324,7 +324,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n                         \"consider using a byte string literal instead\",\n                         format!(\n                             \"b{}\",\n-                            snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability)\n+                            snippet_with_applicability(cx, receiver.span, r#\"\"foo\"\"#, &mut applicability)\n                         ),\n                         applicability,\n                     );\n@@ -333,9 +333,9 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, [recv], _) = &e.kind;\n+            if let ExprKind::MethodCall(path, recv, [], _) = &e.kind;\n             if path.ident.name == sym!(into_bytes);\n-            if let ExprKind::MethodCall(path, [recv], _) = &recv.kind;\n+            if let ExprKind::MethodCall(path, recv, [], _) = &recv.kind;\n             if matches!(path.ident.name.as_str(), \"to_owned\" | \"to_string\");\n             if let ExprKind::Lit(lit) = &recv.kind;\n             if let LitKind::Str(lit_content, _) = &lit.node;\n@@ -393,7 +393,7 @@ declare_lint_pass!(StrToString => [STR_TO_STRING]);\n impl<'tcx> LateLintPass<'tcx> for StrToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n             if path.ident.name == sym::to_string;\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, ty, ..) = ty.kind();\n@@ -443,7 +443,7 @@ declare_lint_pass!(StringToString => [STRING_TO_STRING]);\n impl<'tcx> LateLintPass<'tcx> for StringToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n             if path.ident.name == sym::to_string;\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if is_type_diagnostic_item(cx, ty, sym::String);\n@@ -487,11 +487,11 @@ impl<'tcx> LateLintPass<'tcx> for TrimSplitWhitespace {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         let tyckres = cx.typeck_results();\n         if_chain! {\n-            if let ExprKind::MethodCall(path, [split_recv], split_ws_span) = expr.kind;\n+            if let ExprKind::MethodCall(path, split_recv, [], split_ws_span) = expr.kind;\n             if path.ident.name == sym!(split_whitespace);\n             if let Some(split_ws_def_id) = tyckres.type_dependent_def_id(expr.hir_id);\n             if cx.tcx.is_diagnostic_item(sym::str_split_whitespace, split_ws_def_id);\n-            if let ExprKind::MethodCall(path, [_trim_recv], trim_span) = split_recv.kind;\n+            if let ExprKind::MethodCall(path, _trim_recv, [], trim_span) = split_recv.kind;\n             if let trim_fn_name @ (\"trim\" | \"trim_start\" | \"trim_end\") = path.ident.name.as_str();\n             if let Some(trim_def_id) = tyckres.type_dependent_def_id(split_recv.hir_id);\n             if is_one_of_trim_diagnostic_items(cx, trim_def_id);"}, {"sha": "78403d9fdb7e6f17a81b1f4069105878369d0e9b", "filename": "src/tools/clippy/clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for StrlenOnCStrings {\n             if let ExprKind::Path(path) = &func.kind;\n             if let Some(did) = cx.qpath_res(path, func.hir_id).opt_def_id();\n             if match_libc_symbol(cx, did, \"strlen\");\n-            if let ExprKind::MethodCall(path, [self_arg], _) = recv.kind;\n+            if let ExprKind::MethodCall(path, self_arg, [], _) = recv.kind;\n             if !recv.span.from_expansion();\n             if path.ident.name == sym::as_ptr;\n             then {"}, {"sha": "651201f34ed28d46471e08ff6b2a9610679d2ad9", "filename": "src/tools/clippy/clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -39,27 +39,25 @@ declare_lint_pass!(ToDigitIsSome => [TO_DIGIT_IS_SOME]);\n impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::MethodCall(is_some_path, is_some_args, _) = &expr.kind;\n+            if let hir::ExprKind::MethodCall(is_some_path, to_digit_expr, [], _) = &expr.kind;\n             if is_some_path.ident.name.as_str() == \"is_some\";\n-            if let [to_digit_expr] = &**is_some_args;\n             then {\n                 let match_result = match &to_digit_expr.kind {\n-                    hir::ExprKind::MethodCall(to_digits_path, to_digit_args, _) => {\n+                    hir::ExprKind::MethodCall(to_digits_path, char_arg, [radix_arg], _) => {\n                         if_chain! {\n-                            if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";\n                             let char_arg_ty = cx.typeck_results().expr_ty_adjusted(char_arg);\n                             if *char_arg_ty.kind() == ty::Char;\n                             then {\n-                                Some((true, char_arg, radix_arg))\n+                                Some((true, *char_arg, radix_arg))\n                             } else {\n                                 None\n                             }\n                         }\n                     }\n                     hir::ExprKind::Call(to_digits_call, to_digit_args) => {\n                         if_chain! {\n-                            if let [char_arg, radix_arg] = &**to_digit_args;\n+                            if let [char_arg, radix_arg] = *to_digit_args;\n                             if let hir::ExprKind::Path(to_digits_path) = &to_digits_call.kind;\n                             if let to_digits_call_res = cx.qpath_res(to_digits_path, to_digits_call.hir_id);\n                             if let Some(to_digits_def_id) = to_digits_call_res.opt_def_id();"}, {"sha": "3f99bd3f31567c43592b9e2301557857096f65e7", "filename": "src/tools/clippy/clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -177,7 +177,7 @@ fn extract_init_or_reserve_target<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt\n                     });\n                 }\n             },\n-            ExprKind::MethodCall(path, [self_expr, _], _) if is_reserve(cx, path, self_expr) => {\n+            ExprKind::MethodCall(path, self_expr, [_], _) if is_reserve(cx, path, self_expr) => {\n                 return Some(TargetVec {\n                     location: VecLocation::Expr(self_expr),\n                     init_kind: None,\n@@ -211,7 +211,7 @@ fn extract_set_len_self<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Opt\n         }\n     });\n     match expr.kind {\n-        ExprKind::MethodCall(path, [self_expr, _], _) => {\n+        ExprKind::MethodCall(path, self_expr, [_], _) => {\n             let self_type = cx.typeck_results().expr_ty(self_expr).peel_refs();\n             if is_type_diagnostic_item(cx, self_type, sym::Vec) && path.ident.name.as_str() == \"set_len\" {\n                 Some((self_expr, expr.span))"}, {"sha": "851eef7b332417658b090489fa968aa0850923f4", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -144,8 +144,9 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n \n impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::MethodCall(_, args, _) = expr.kind {\n+        if let ExprKind::MethodCall(_, receiver, args, _) = expr.kind {\n             let arg_indices = get_args_to_check(cx, expr);\n+            let args = std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>();\n             for (i, trait_name) in arg_indices {\n                 if i < args.len() {\n                     match check_arg(cx, &args[i]) {"}, {"sha": "35824b03170afb87e139373715ad3b1caca492e5", "filename": "src/tools/clippy/clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -128,7 +128,7 @@ fn needs_inferred_result_ty(\n     locals_to_check: &mut Vec<HirId>,\n     seen_locals: &mut HirIdSet,\n ) -> bool {\n-    let (id, args) = match e.kind {\n+    let (id, receiver, args) = match e.kind {\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(ref path),\n@@ -137,11 +137,11 @@ fn needs_inferred_result_ty(\n             },\n             args,\n         ) => match cx.qpath_res(path, *hir_id) {\n-            Res::Def(DefKind::AssocFn | DefKind::Fn, id) => (id, args),\n+            Res::Def(DefKind::AssocFn | DefKind::Fn, id) => (id, None, args),\n             _ => return false,\n         },\n-        ExprKind::MethodCall(_, args, _) => match cx.typeck_results().type_dependent_def_id(e.hir_id) {\n-            Some(id) => (id, args),\n+        ExprKind::MethodCall(_, receiver, args, _) => match cx.typeck_results().type_dependent_def_id(e.hir_id) {\n+            Some(id) => (id, Some(receiver), args),\n             None => return false,\n         },\n         ExprKind::Path(QPath::Resolved(None, path)) => {\n@@ -156,6 +156,11 @@ fn needs_inferred_result_ty(\n     };\n     let sig = cx.tcx.fn_sig(id).skip_binder();\n     if let ty::Param(output_ty) = *sig.output().kind() {\n+        let args: Vec<&Expr<'_>> = if let Some(receiver) = receiver {\n+            std::iter::once(receiver).chain(args.iter()).collect()\n+        } else {\n+            args.iter().collect()\n+        };\n         sig.inputs().iter().zip(args).all(|(&ty, arg)| {\n             !ty.is_param(output_ty.index) || each_value_source_needs_inference(cx, arg, locals_to_check, seen_locals)\n         })"}, {"sha": "7ffb53dcf455f371e313cade841426bdeae0fd92", "filename": "src/tools/clippy/clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -30,26 +30,27 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         }\n     }\n \n-    match expr.kind {\n-        ExprKind::Call(_, args) | ExprKind::MethodCall(_, args, _) => {\n-            let args_to_recover = args\n-                .iter()\n-                .filter(|arg| {\n-                    if cx.typeck_results().expr_ty(arg).is_unit() && !utils::is_unit_literal(arg) {\n-                        !matches!(\n-                            &arg.kind,\n-                            ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n-                        )\n-                    } else {\n-                        false\n-                    }\n-                })\n-                .collect::<Vec<_>>();\n-            if !args_to_recover.is_empty() && !is_from_proc_macro(cx, expr) {\n-                lint_unit_args(cx, expr, &args_to_recover);\n+    let args: Vec<_> = match expr.kind {\n+        ExprKind::Call(_, args) => args.iter().collect(),\n+        ExprKind::MethodCall(_, receiver, args, _) => std::iter::once(receiver).chain(args.iter()).collect(),\n+        _ => return,\n+    };\n+\n+    let args_to_recover = args\n+        .into_iter()\n+        .filter(|arg| {\n+            if cx.typeck_results().expr_ty(arg).is_unit() && !utils::is_unit_literal(arg) {\n+                !matches!(\n+                    &arg.kind,\n+                    ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n+                )\n+            } else {\n+                false\n             }\n-        },\n-        _ => (),\n+        })\n+        .collect::<Vec<_>>();\n+    if !args_to_recover.is_empty() && !is_from_proc_macro(cx, expr) {\n+        lint_unit_args(cx, expr, &args_to_recover.as_slice());\n     }\n }\n "}, {"sha": "b38d71784fcfc74475b7f07042267479929aabe8", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n                     check_map_error(cx, res, expr);\n                 }\n             },\n-            hir::ExprKind::MethodCall(path, [ref arg_0, ..], _) => match path.ident.as_str() {\n+            hir::ExprKind::MethodCall(path, arg_0, ..) => match path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_map_error(cx, arg_0, expr);\n                 },\n@@ -94,9 +94,9 @@ fn try_remove_await<'a>(expr: &'a hir::Expr<'a>) -> Option<&hir::Expr<'a>> {\n \n fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     let mut call = call;\n-    while let hir::ExprKind::MethodCall(path, args, _) = call.kind {\n+    while let hir::ExprKind::MethodCall(path, receiver, ..) = call.kind {\n         if matches!(path.ident.as_str(), \"or\" | \"or_else\" | \"ok\") {\n-            call = &args[0];\n+            call = receiver;\n         } else {\n             break;\n         }\n@@ -110,7 +110,7 @@ fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<\n }\n \n fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>, is_await: bool) {\n-    if let hir::ExprKind::MethodCall(path, _, _) = call.kind {\n+    if let hir::ExprKind::MethodCall(path, ..) = call.kind {\n         let symbol = path.ident.as_str();\n         let read_trait = if is_await {\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)"}, {"sha": "cfc181e435b9c9da1068a6d642a16d4d9f789b71", "filename": "src/tools/clippy/clippy_lints/src/unused_peekable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -149,7 +149,8 @@ impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n                                     ident: method_name_ident,\n                                     ..\n                                 },\n-                                [self_arg, remaining_args @ ..],\n+                                self_arg,\n+                                remaining_args,\n                                 _,\n                             ) => {\n                                 let method_name = method_name_ident.name.as_str();"}, {"sha": "9092156be150a30634c382add42dd2fcc6a5e1e1", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -154,13 +154,13 @@ fn collect_unwrap_info<'tcx>(\n         return collect_unwrap_info(cx, if_expr, expr, branch, !invert, false);\n     } else {\n         if_chain! {\n-            if let ExprKind::MethodCall(method_name, args, _) = &expr.kind;\n-            if let Some(local_id) = path_to_local(&args[0]);\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            if let ExprKind::MethodCall(method_name, receiver, args, _) = &expr.kind;\n+            if let Some(local_id) = path_to_local(receiver);\n+            let ty = cx.typeck_results().expr_ty(receiver);\n             let name = method_name.ident.as_str();\n             if is_relevant_option_call(cx, ty, name) || is_relevant_result_call(cx, ty, name);\n             then {\n-                assert!(args.len() == 1);\n+                assert!(args.len() == 0);\n                 let unwrappable = match name {\n                     \"is_some\" | \"is_ok\" => true,\n                     \"is_err\" | \"is_none\" => false,\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(method_name, [self_arg, ..], _) = expr.kind;\n+                if let ExprKind::MethodCall(method_name, self_arg, ..) = expr.kind;\n                 if let Some(id) = path_to_local(self_arg);\n                 if [sym::unwrap, sym::expect, sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = [sym::unwrap, sym::expect].contains(&method_name.ident.name);"}, {"sha": "b3ca15f7648bc082bdb8ea71694d65631c9c6200", "filename": "src/tools/clippy/clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         // check for `expect`\n         if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n             {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n \n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n             {"}, {"sha": "f1b6463ad0f7c62a375aa8cfad9f7a086729cf19", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 }\n             },\n \n-            ExprKind::MethodCall(name, .., [recv, ..], _) => {\n+            ExprKind::MethodCall(name, recv, ..) => {\n                 if is_trait_method(cx, e, sym::Into) && name.ident.as_str() == \"into\" {\n                     let a = cx.typeck_results().expr_ty(e);\n                     let b = cx.typeck_results().expr_ty(recv);"}, {"sha": "fec4ee93e7bce47573743a006cd5f0661ad8ccd8", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -402,10 +402,11 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 self.expr(func);\n                 self.slice(args, |e| self.expr(e));\n             },\n-            ExprKind::MethodCall(method_name, args, _) => {\n-                bind!(self, method_name, args);\n-                kind!(\"MethodCall({method_name}, {args}, _)\");\n+            ExprKind::MethodCall(method_name, receiver, args, _) => {\n+                bind!(self, method_name, receiver, args);\n+                kind!(\"MethodCall({method_name}, {receiver}, {args}, _)\");\n                 self.ident(field!(method_name.ident));\n+                self.expr(receiver);\n                 self.slice(args, |e| self.expr(e));\n             },\n             ExprKind::Tup(elements) => {"}, {"sha": "ae1c11ef83c31cab317d5702cdacd8082c4100d2", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -687,7 +687,7 @@ impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n             if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n             let args = arg_lists[1];\n             if args.len() == 1;\n-            let self_arg = &args[0];\n+            let self_arg = &args.0;\n             let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n             if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n             then {"}, {"sha": "542c6a37d567bb09e9bad4433bcaaae15abf79b0", "filename": "src/tools/clippy/clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -100,7 +100,7 @@ impl VecPushSearcher {\n                         || get_parent_expr(cx, last_place)\n                             .map_or(false, |e| matches!(e.kind, ExprKind::AddrOf(_, Mutability::Mut, _)));\n                 },\n-                ExprKind::MethodCall(_, [recv, ..], _)\n+                ExprKind::MethodCall(_, recv, ..)\n                     if recv.hir_id == e.hir_id\n                         && adjusted_mut == Mutability::Mut\n                         && !adjusted_ty.peel_refs().is_slice() =>\n@@ -201,7 +201,7 @@ impl<'tcx> LateLintPass<'tcx> for VecInitThenPush {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let Some(searcher) = self.searcher.take() {\n             if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = stmt.kind\n-                && let ExprKind::MethodCall(name, [self_arg, _], _) = expr.kind\n+                && let ExprKind::MethodCall(name, self_arg, [_], _) = expr.kind\n                 && path_to_local_id(self_arg, searcher.local_id)\n                 && name.ident.as_str() == \"push\"\n             {"}, {"sha": "e8d2d579f097e5451a870788145360c3e7510c40", "filename": "src/tools/clippy/clippy_utils/src/check_proc_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcheck_proc_macro.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -118,9 +118,9 @@ fn expr_search_pat(tcx: TyCtxt<'_>, e: &Expr<'_>) -> (Pat, Pat) {\n         ExprKind::Unary(UnOp::Neg, e) => (Pat::Str(\"-\"), expr_search_pat(tcx, e).1),\n         ExprKind::Lit(ref lit) => lit_search_pat(&lit.node),\n         ExprKind::Array(_) | ExprKind::Repeat(..) => (Pat::Str(\"[\"), Pat::Str(\"]\")),\n-        ExprKind::Call(e, []) | ExprKind::MethodCall(_, [e], _) => (expr_search_pat(tcx, e).0, Pat::Str(\"(\")),\n+        ExprKind::Call(e, []) | ExprKind::MethodCall(_, e, [], _) => (expr_search_pat(tcx, e).0, Pat::Str(\"(\")),\n         ExprKind::Call(first, [.., last])\n-        | ExprKind::MethodCall(_, [first, .., last], _)\n+        | ExprKind::MethodCall(_, first, [.., last], _)\n         | ExprKind::Binary(_, first, last)\n         | ExprKind::Tup([first, .., last])\n         | ExprKind::Assign(first, last, _)"}, {"sha": "ad95369b9ef707091919fa59ea167a906c35e14e", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -155,13 +155,7 @@ where\n     });\n }\n \n-pub fn span_lint_hir(\n-    cx: &LateContext<'_>,\n-    lint: &'static Lint,\n-    hir_id: HirId,\n-    sp: Span,\n-    msg: &str,\n-) {\n+pub fn span_lint_hir(cx: &LateContext<'_>, lint: &'static Lint, hir_id: HirId, sp: Span, msg: &str) {\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |diag| {\n         let mut diag = diag.build(msg);\n         docs_link(&mut diag, lint);"}, {"sha": "124a00d817847ae7a827a6c8694e0a9e1d888e83", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -45,12 +45,7 @@ impl ops::BitOrAssign for EagernessSuggestion {\n }\n \n /// Determine the eagerness of the given function call.\n-fn fn_eagerness<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    fn_id: DefId,\n-    name: Symbol,\n-    args: &'tcx [Expr<'_>],\n-) -> EagernessSuggestion {\n+fn fn_eagerness<'tcx>(cx: &LateContext<'tcx>, fn_id: DefId, name: Symbol, have_one_arg: bool) -> EagernessSuggestion {\n     use EagernessSuggestion::{Eager, Lazy, NoChange};\n     let name = name.as_str();\n \n@@ -59,7 +54,7 @@ fn fn_eagerness<'tcx>(\n         None => return Lazy,\n     };\n \n-    if (name.starts_with(\"as_\") || name == \"len\" || name == \"is_empty\") && args.len() == 1 {\n+    if (name.starts_with(\"as_\") || name == \"len\" || name == \"is_empty\") && have_one_arg {\n         if matches!(\n             cx.tcx.crate_name(fn_id.krate),\n             sym::std | sym::core | sym::alloc | sym::proc_macro\n@@ -127,10 +122,11 @@ fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessS\n                     },\n                     Res::Def(_, id) => match path {\n                         QPath::Resolved(_, p) => {\n-                            self.eagerness |= fn_eagerness(self.cx, id, p.segments.last().unwrap().ident.name, args);\n+                            self.eagerness |=\n+                                fn_eagerness(self.cx, id, p.segments.last().unwrap().ident.name, !args.is_empty());\n                         },\n                         QPath::TypeRelative(_, name) => {\n-                            self.eagerness |= fn_eagerness(self.cx, id, name.ident.name, args);\n+                            self.eagerness |= fn_eagerness(self.cx, id, name.ident.name, !args.is_empty());\n                         },\n                         QPath::LangItem(..) => self.eagerness = Lazy,\n                     },\n@@ -141,12 +137,12 @@ fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessS\n                     self.eagerness |= NoChange;\n                     return;\n                 },\n-                ExprKind::MethodCall(name, args, _) => {\n+                ExprKind::MethodCall(name, ..) => {\n                     self.eagerness |= self\n                         .cx\n                         .typeck_results()\n                         .type_dependent_def_id(e.hir_id)\n-                        .map_or(Lazy, |id| fn_eagerness(self.cx, id, name.ident.name, args));\n+                        .map_or(Lazy, |id| fn_eagerness(self.cx, id, name.ident.name, true));\n                 },\n                 ExprKind::Index(_, e) => {\n                     let ty = self.cx.typeck_results().expr_ty_adjusted(e);"}, {"sha": "6cb6544df4bc1ff553ffb3a39755abf7103ac930", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -282,8 +282,14 @@ impl HirEqInterExpr<'_, '_, '_> {\n                             && self.eq_expr(l.body, r.body)\n                     })\n             },\n-            (&ExprKind::MethodCall(l_path, l_args, _), &ExprKind::MethodCall(r_path, r_args, _)) => {\n-                self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n+            (\n+                &ExprKind::MethodCall(l_path, l_receiver, l_args, _),\n+                &ExprKind::MethodCall(r_path, r_receiver, r_args, _),\n+            ) => {\n+                self.inner.allow_side_effects\n+                    && self.eq_path_segment(l_path, r_path)\n+                    && self.eq_expr(l_receiver, r_receiver)\n+                    && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(le, ll), &ExprKind::Repeat(re, rl)) => {\n                 self.eq_expr(le, re) && self.eq_array_length(ll, rl)\n@@ -743,8 +749,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprKind::MethodCall(path, args, ref _fn_span) => {\n+            ExprKind::MethodCall(path, receiver, args, ref _fn_span) => {\n                 self.hash_name(path.ident.name);\n+                self.hash_expr(receiver);\n                 self.hash_exprs(args);\n             },\n             ExprKind::ConstBlock(ref l_id) => {"}, {"sha": "ed1f8af989fe18e5b112c9ed9a5dcc0d9ac7c939", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -1036,21 +1036,21 @@ pub fn can_move_expr_to_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'\n pub fn method_calls<'tcx>(\n     expr: &'tcx Expr<'tcx>,\n     max_depth: usize,\n-) -> (Vec<Symbol>, Vec<&'tcx [Expr<'tcx>]>, Vec<Span>) {\n+) -> (Vec<Symbol>, Vec<(&'tcx Expr<'tcx>, &'tcx [Expr<'tcx>])>, Vec<Span>) {\n     let mut method_names = Vec::with_capacity(max_depth);\n     let mut arg_lists = Vec::with_capacity(max_depth);\n     let mut spans = Vec::with_capacity(max_depth);\n \n     let mut current = expr;\n     for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, args, _) = &current.kind {\n-            if args.iter().any(|e| e.span.from_expansion()) {\n+        if let ExprKind::MethodCall(path, receiver, args, _) = &current.kind {\n+            if receiver.span.from_expansion() || args.iter().any(|e| e.span.from_expansion()) {\n                 break;\n             }\n             method_names.push(path.ident.name);\n-            arg_lists.push(&**args);\n+            arg_lists.push((*receiver, &**args));\n             spans.push(path.ident.span);\n-            current = &args[0];\n+            current = receiver;\n         } else {\n             break;\n         }\n@@ -1065,18 +1065,18 @@ pub fn method_calls<'tcx>(\n /// `method_chain_args(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n /// containing the `Expr`s for\n /// `.bar()` and `.baz()`\n-pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<&'a [Expr<'a>]>> {\n+pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<(&'a Expr<'a>, &'a [Expr<'a>])>> {\n     let mut current = expr;\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprKind::MethodCall(path, args, _) = current.kind {\n+        if let ExprKind::MethodCall(path, receiver, args, _) = current.kind {\n             if path.ident.name.as_str() == *method_name {\n-                if args.iter().any(|e| e.span.from_expansion()) {\n+                if receiver.span.from_expansion() || args.iter().any(|e| e.span.from_expansion()) {\n                     return None;\n                 }\n-                matched.push(args); // build up `matched` backwards\n-                current = &args[0]; // go to parent expression\n+                matched.push((receiver, args)); // build up `matched` backwards\n+                current = receiver; // go to parent expression\n             } else {\n                 return None;\n             }\n@@ -1239,8 +1239,10 @@ pub fn get_enclosing_loop_or_multi_call_closure<'tcx>(\n                                     ty_is_fn_once_param(cx.tcx, ty.skip_binder(), predicates).then_some(())\n                                 })\n                             },\n-                            ExprKind::MethodCall(_, args, _) => {\n-                                let i = args.iter().position(|arg| arg.hir_id == id)?;\n+                            ExprKind::MethodCall(_, receiver, args, _) => {\n+                                let i = std::iter::once(receiver)\n+                                    .chain(args.iter())\n+                                    .position(|arg| arg.hir_id == id)?;\n                                 let id = cx.typeck_results().type_dependent_def_id(e.hir_id)?;\n                                 let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n                                 ty_is_fn_once_param(cx.tcx, ty, cx.tcx.param_env(id).caller_bounds()).then_some(())"}, {"sha": "0226f74906b5152b66a678c960200fcd844564da", "filename": "src/tools/clippy/clippy_utils/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -36,7 +36,7 @@ fn extract_clone_suggestions<'tcx>(\n         if abort {\n             return false;\n         }\n-        if let ExprKind::MethodCall(seg, [recv], _) = expr.kind {\n+        if let ExprKind::MethodCall(seg, recv, [], _) = expr.kind {\n             if path_to_local_id(recv, id) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     abort = true;"}, {"sha": "cca71bbf76e2877196898bec350b5435dbcbeaf5", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -373,12 +373,14 @@ fn binop_to_string(op: AssocOp, lhs: &str, rhs: &str) -> String {\n         | AssocOp::LessEqual\n         | AssocOp::NotEqual\n         | AssocOp::Greater\n-        | AssocOp::GreaterEqual => format!(\n-            \"{} {} {}\",\n-            lhs,\n-            op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n-            rhs\n-        ),\n+        | AssocOp::GreaterEqual => {\n+            format!(\n+                \"{} {} {}\",\n+                lhs,\n+                op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n+                rhs\n+            )\n+        },\n         AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n         AssocOp::AssignOp(op) => {\n             format!(\"{} {}= {}\", lhs, token_kind_to_string(&token::BinOp(op)), rhs)\n@@ -868,15 +870,15 @@ impl<'tcx> DerefDelegate<'_, 'tcx> {\n     /// indicates whether the function from `parent_expr` takes its args by double reference\n     fn func_takes_arg_by_double_ref(&self, parent_expr: &'tcx hir::Expr<'_>, cmt_hir_id: HirId) -> bool {\n         let ty = match parent_expr.kind {\n-            ExprKind::MethodCall(_, call_args, _) => {\n+            ExprKind::MethodCall(_, receiver, call_args, _) => {\n                 if let Some(sig) = self\n                     .cx\n                     .typeck_results()\n                     .type_dependent_def_id(parent_expr.hir_id)\n                     .map(|did| self.cx.tcx.fn_sig(did).skip_binder())\n                 {\n-                    call_args\n-                        .iter()\n+                    std::iter::once(receiver)\n+                        .chain(call_args.iter())\n                         .position(|arg| arg.hir_id == cmt_hir_id)\n                         .map(|i| sig.inputs()[i])\n                 } else {\n@@ -933,14 +935,14 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                     match &parent_expr.kind {\n                         // given expression is the self argument and will be handled completely by the compiler\n                         // i.e.: `|x| x.is_something()`\n-                        ExprKind::MethodCall(_, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n+                        ExprKind::MethodCall(_, self_expr, ..) if self_expr.hir_id == cmt.hir_id => {\n                             let _ = write!(self.suggestion_start, \"{}{}\", start_snip, ident_str_with_proj);\n                             self.next_pos = span.hi();\n                             return;\n                         },\n                         // item is used in a call\n                         // i.e.: `Call`: `|x| please(x)` or `MethodCall`: `|x| [1, 2, 3].contains(x)`\n-                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, [_, call_args @ ..], _) => {\n+                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, _, [call_args @ ..], _) => {\n                             let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n                             let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n "}, {"sha": "6a62002a4d12e3274f14773f79c9ac41b3524aec", "filename": "src/tools/clippy/clippy_utils/src/visitors.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -620,7 +620,13 @@ pub fn for_each_unconsumed_temporary<'tcx, B>(\n                     helper(typeck, true, arg, f)?;\n                 }\n             },\n-            ExprKind::MethodCall(_, args, _) | ExprKind::Tup(args) | ExprKind::Array(args) => {\n+            ExprKind::MethodCall(_, receiver, args, _) => {\n+                helper(typeck, true, receiver, f)?;\n+                for arg in args {\n+                    helper(typeck, true, arg, f)?;\n+                }\n+            },\n+            ExprKind::Tup(args) | ExprKind::Array(args) => {\n                 for arg in args {\n                     helper(typeck, true, arg, f)?;\n                 }"}, {"sha": "b5bbc9e213c6e928330105b81cd6b0e7fb17fd45", "filename": "src/tools/clippy/tests/ui/author/struct.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fstruct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fstruct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fstruct.stdout?ref=b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "patch": "@@ -53,11 +53,11 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let ExprKind::MethodCall(method_name, args, _) = expr.kind;\n+    if let ExprKind::MethodCall(method_name, receiver, args, _) = expr.kind;\n     if method_name.ident.as_str() == \"test\";\n-    if args.len() == 1;\n-    if let ExprKind::Path(ref qpath) = args[0].kind;\n+    if let ExprKind::Path(ref qpath) = receiver.kind;\n     if match_qpath(qpath, &[\"test_method_call\"]);\n+    if args.is_empty();\n     then {\n         // report your lint here\n     }"}]}