{"sha": "ec5847a698bc3d64bd419a872d3c60e100999406", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNTg0N2E2OThiYzNkNjRiZDQxOWE4NzJkM2M2MGUxMDA5OTk0MDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-22T20:36:28Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "rewrite return type probing to use the \"probe by name\" path\n\nWe now do two phases. First, we gather up the list of candidates with\nsuitable return types and extract their names. Then we filter those to\nsee which are applicable and we return that.\n\nIt might be nice to do the \"filter by return type\" as a second step,\nbut this is ok for now.", "tree": {"sha": "b40dbc378f1f2eaa0dd5874c25b45f3edfd61c62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b40dbc378f1f2eaa0dd5874c25b45f3edfd61c62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec5847a698bc3d64bd419a872d3c60e100999406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5847a698bc3d64bd419a872d3c60e100999406", "html_url": "https://github.com/rust-lang/rust/commit/ec5847a698bc3d64bd419a872d3c60e100999406", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec5847a698bc3d64bd419a872d3c60e100999406/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "579e52692f1c88f5970386508b5e40e2f5f9645a", "url": "https://api.github.com/repos/rust-lang/rust/commits/579e52692f1c88f5970386508b5e40e2f5f9645a", "html_url": "https://github.com/rust-lang/rust/commit/579e52692f1c88f5970386508b5e40e2f5f9645a"}], "stats": {"total": 121, "additions": 63, "deletions": 58}, "files": [{"sha": "4704193da0c4da8f6a18e1f5853d2d35794515f3", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ec5847a698bc3d64bd419a872d3c60e100999406/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5847a698bc3d64bd419a872d3c60e100999406/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=ec5847a698bc3d64bd419a872d3c60e100999406", "patch": "@@ -19,8 +19,6 @@ use syntax_pos::{self, Span};\n use rustc::hir;\n use rustc::ty::{self, ImplOrTraitItem};\n \n-use std::rc::Rc;\n-\n use super::method::probe;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -138,26 +136,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mode = probe::Mode::MethodCall;\n             let suggestions = if let Some(s) = self.check_ref(expr, checked_ty, expected) {\n                 Some(s)\n-            } else if let Ok(methods) = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n-                                                                   mode,\n-                                                                   expected,\n-                                                                   checked_ty,\n-                                                                   ast::DUMMY_NODE_ID) {\n-                let suggestions: Vec<_> =\n-                    methods.iter()\n-                           .map(|ref x| {\n-                                Rc::new(x.item.clone())\n-                            })\n-                           .collect();\n+            } else {\n+                let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n+                                                             mode,\n+                                                             expected,\n+                                                             checked_ty,\n+                                                             ast::DUMMY_NODE_ID);\n                 if suggestions.len() > 0 {\n                     Some(format!(\"here are some functions which \\\n                                   might fulfill your needs:\\n - {}\",\n                                  self.get_best_match(&suggestions)))\n                 } else {\n                     None\n                 }\n-            } else {\n-                None\n             };\n             let mut err = self.report_mismatched_types(origin, expected, expr_ty, e);\n             if let Some(suggestions) = suggestions {\n@@ -181,16 +172,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 })\n     }\n \n-    fn display_suggested_methods(&self, methods: &[Rc<ImplOrTraitItem<'tcx>>]) -> String {\n+    fn display_suggested_methods(&self, methods: &[ImplOrTraitItem<'tcx>]) -> String {\n         methods.iter()\n                .take(5)\n                .map(|method| self.format_method_suggestion(&*method))\n                .collect::<Vec<String>>()\n                .join(\"\\n - \")\n     }\n \n-    fn get_best_match(&self, methods: &[Rc<ImplOrTraitItem<'tcx>>]) -> String {\n-        let no_argument_methods: Vec<Rc<ImplOrTraitItem<'tcx>>> =\n+    fn get_best_match(&self, methods: &[ImplOrTraitItem<'tcx>]) -> String {\n+        let no_argument_methods: Vec<_> =\n             methods.iter()\n                    .filter(|ref x| self.has_not_input_arg(&*x))\n                    .map(|x| x.clone())"}, {"sha": "0711390afbe34e54580a09fb17efa967ddad096c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 54, "deletions": 40, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ec5847a698bc3d64bd419a872d3c60e100999406/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5847a698bc3d64bd419a872d3c60e100999406/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ec5847a698bc3d64bd419a872d3c60e100999406", "patch": "@@ -150,19 +150,36 @@ pub enum Mode {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+    /// This is used to offer suggestions to users. It returns methods\n+    /// that could have been called which have the desired return\n+    /// type. Some effort is made to rule out methods that, if called,\n+    /// would result in an error (basically, the same criteria we\n+    /// would use to decide if a method is a plausible fit for\n+    /// ambiguity purposes).\n     pub fn probe_for_return_type(&self,\n                                  span: Span,\n                                  mode: Mode,\n                                  return_type: Ty<'tcx>,\n                                  self_ty: Ty<'tcx>,\n                                  scope_expr_id: ast::NodeId)\n-                                 -> PickResult<'tcx> {\n+                                 -> Vec<ty::ImplOrTraitItem<'tcx>> {\n         debug!(\"probe(self_ty={:?}, return_type={}, scope_expr_id={})\",\n                self_ty,\n                return_type,\n                scope_expr_id);\n-        self.probe_op(span, mode, LookingFor::ReturnType(return_type), self_ty, scope_expr_id,\n-                      |probe_cx| probe_cx.pick())\n+        let method_names =\n+            self.probe_op(span, mode, LookingFor::ReturnType(return_type), self_ty, scope_expr_id,\n+                          |probe_cx| Ok(probe_cx.candidate_method_names()))\n+                .unwrap_or(vec![]);\n+        method_names\n+            .iter()\n+            .flat_map(|&method_name| {\n+                match self.probe_for_name(span, mode, method_name, self_ty, scope_expr_id) {\n+                    Ok(picks) => picks.into_iter().map(move |pick| pick.item).collect(),\n+                    Err(_) => vec![],\n+                }\n+            })\n+            .collect()\n     }\n \n     pub fn probe_for_name(&self,\n@@ -184,15 +201,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       |probe_cx| probe_cx.pick())\n     }\n \n-    fn probe_op<'a,OP,R>(&'a self,\n-                         span: Span,\n-                         mode: Mode,\n-                         looking_for: LookingFor<'tcx>,\n-                         self_ty: Ty<'tcx>,\n-                         scope_expr_id: ast::NodeId,\n-                         op: OP)\n-                         -> R\n-        where OP: FnOnce(&mut ProbeContext<'a, 'gcx, 'tcx>) -> R\n+    fn probe_op<OP,R>(&'a self,\n+                      span: Span,\n+                      mode: Mode,\n+                      looking_for: LookingFor<'tcx>,\n+                      self_ty: Ty<'tcx>,\n+                      scope_expr_id: ast::NodeId,\n+                      op: OP)\n+                      -> Result<R, MethodError<'tcx>>\n+        where OP: FnOnce(ProbeContext<'a, 'gcx, 'tcx>) -> Result<R, MethodError<'tcx>>\n     {\n         // FIXME(#18741) -- right now, creating the steps involves evaluating the\n         // `*` operator, which registers obligations that then escape into\n@@ -249,7 +266,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   steps, opt_simplified_steps);\n             probe_cx.assemble_inherent_candidates();\n             probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n-            op(&mut probe_cx)\n+            op(probe_cx)\n         })\n     }\n \n@@ -894,10 +911,30 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn candidate_method_names(&self) -> Vec<ast::Name> {\n+        let mut set = FnvHashSet();\n+        let mut names: Vec<_> =\n+            self.inherent_candidates\n+                .iter()\n+                .chain(&self.extension_candidates)\n+                .map(|candidate| candidate.item.name())\n+                .filter(|&name| set.insert(name))\n+                .collect();\n+\n+        // sort them by the name so we have a stable result\n+        names.sort_by_key(|n| n.as_str());\n+        names\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // THE ACTUAL SEARCH\n \n     fn pick(mut self) -> PickResult<'tcx> {\n+        assert!(match self.looking_for {\n+            LookingFor::MethodName(_) => true,\n+            LookingFor::ReturnType(_) => false,\n+        });\n+\n         if let Some(ret) = self.pick_core() {\n             return ret;\n         }\n@@ -959,33 +996,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n         let steps = self.steps.clone();\n \n-        match self.looking_for {\n-            LookingFor::MethodName(_) => {\n-                // find the first step that works\n-                steps.iter()\n-                     .filter_map(|step| self.pick_step(step))\n-                     .next()\n-            }\n-            LookingFor::ReturnType(_) => {\n-                // Normally, we stop at the first step where we find a positive match.\n-                // But when we are scanning for methods with a suitable return type,\n-                // these methods have distinct names and hence may not shadow one another\n-                // (also, this is just for hints, so precision is less important).\n-                let mut ret = Vec::new();\n-\n-                for step in steps.iter() {\n-                    match self.pick_step(step) {\n-                        Some(Ok(mut elems)) => ret.append(&mut elems),\n-                        _ => {}\n-                    }\n-                }\n-                if ret.len() < 1 {\n-                    None\n-                } else {\n-                    Some(Ok(ret))\n-                }\n-            }\n-        }\n+        // find the first step that works\n+        steps.iter()\n+             .filter_map(|step| self.pick_step(step))\n+             .next()\n     }\n \n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {"}]}