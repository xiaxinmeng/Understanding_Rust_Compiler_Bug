{"sha": "6343edfa11c80ffed02de7e059178d4c1637ecdb", "node_id": "C_kwDOAAsO6NoAKDYzNDNlZGZhMTFjODBmZmVkMDJkZTdlMDU5MTc4ZDRjMTYzN2VjZGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-01T03:26:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-01T03:26:11Z"}, "message": "Auto merge of #94469 - Dylan-DPC:rollup-2tcq6s5, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #91545 (Generalize \"remove `&`\"  and \"add `*`\" suggestions to more than one deref)\n - #93385 (Rustdoc ty consistency fixes)\n - #93926 (Lint against more useless `#[must_use]` attributes)\n - #94094 (use BOOL for TCP_NODELAY setsockopt value on Windows)\n - #94384 (Add Atomic*::from_mut_slice)\n - #94448 (5 - Make more use of `let_chains`)\n - #94452 (Sync portable-simd for bitmasks &c.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "eb2515ec14032b2fc5a3613af3d9daa4fb56f7c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb2515ec14032b2fc5a3613af3d9daa4fb56f7c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6343edfa11c80ffed02de7e059178d4c1637ecdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6343edfa11c80ffed02de7e059178d4c1637ecdb", "html_url": "https://github.com/rust-lang/rust/commit/6343edfa11c80ffed02de7e059178d4c1637ecdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6343edfa11c80ffed02de7e059178d4c1637ecdb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d6f527530f4ba974d922269267fe89050188789", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6f527530f4ba974d922269267fe89050188789", "html_url": "https://github.com/rust-lang/rust/commit/8d6f527530f4ba974d922269267fe89050188789"}, {"sha": "4001d98019c050c22f80ab61b7c62e2cc7c633a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4001d98019c050c22f80ab61b7c62e2cc7c633a0", "html_url": "https://github.com/rust-lang/rust/commit/4001d98019c050c22f80ab61b7c62e2cc7c633a0"}], "stats": {"total": 1870, "additions": 1402, "deletions": 468}, "files": [{"sha": "f29683e5e1d236d451b2e34d12f925ac80cd6cd3", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -587,7 +587,6 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n         // next call to `it.next()` retrieves the next character.\n         while let Some(c) = it.next() {\n             if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n-                #[must_use]\n                 let mut eat_argument = || -> Option<String> {\n                     let mut result = String::new();\n                     // Format specifiers look like"}, {"sha": "d94ad7ba71a9c63a19560b02cde7e77b2a0d1409", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -1111,24 +1111,55 @@ impl CheckAttrVisitor<'_> {\n     }\n \n     /// Warns against some misuses of `#[must_use]`\n-    fn check_must_use(&self, hir_id: HirId, attr: &Attribute, span: Span, _target: Target) -> bool {\n+    fn check_must_use(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         let node = self.tcx.hir().get(hir_id);\n-        if let Some(fn_node) = node.fn_kind() {\n-            if let rustc_hir::IsAsync::Async = fn_node.asyncness() {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\n-                        \"`must_use` attribute on `async` functions \\\n-                              applies to the anonymous `Future` returned by the \\\n-                              function, not the value within\",\n-                    )\n-                    .span_label(\n-                        span,\n-                        \"this attribute does nothing, the `Future`s \\\n-                                returned by async functions are already `must_use`\",\n-                    )\n-                    .emit();\n-                });\n-            }\n+        if let Some(kind) = node.fn_kind() && let rustc_hir::IsAsync::Async = kind.asyncness() {\n+            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                lint.build(\n+                    \"`must_use` attribute on `async` functions \\\n+                    applies to the anonymous `Future` returned by the \\\n+                    function, not the value within\",\n+                )\n+                .span_label(\n+                    span,\n+                    \"this attribute does nothing, the `Future`s \\\n+                    returned by async functions are already `must_use`\",\n+                )\n+                .emit();\n+            });\n+        }\n+\n+        if !matches!(\n+            target,\n+            Target::Fn\n+                | Target::Enum\n+                | Target::Struct\n+                | Target::Union\n+                | Target::Method(_)\n+                | Target::ForeignFn\n+                // `impl Trait` in return position can trip\n+                // `unused_must_use` if `Trait` is marked as\n+                // `#[must_use]`\n+                | Target::Trait\n+        ) {\n+            let article = match target {\n+                Target::ExternCrate\n+                | Target::OpaqueTy\n+                | Target::Enum\n+                | Target::Impl\n+                | Target::Expression\n+                | Target::Arm\n+                | Target::AssocConst\n+                | Target::AssocTy => \"an\",\n+                _ => \"a\",\n+            };\n+\n+            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                lint.build(&format!(\n+                    \"`#[must_use]` has no effect when applied to {article} {target}\"\n+                ))\n+                .emit();\n+            });\n         }\n \n         // For now, its always valid"}, {"sha": "e438b521a952b8ccc8b38aac9a1e7b61b2a51891", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -683,34 +683,33 @@ impl<'tcx> DeadVisitor<'tcx> {\n                 let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n                 let mut err = lint.build(&format!(\"{} is never {}: `{}`\", descr, participle, name));\n                 let hir = self.tcx.hir();\n-                if let Some(encl_scope) = hir.get_enclosing_scope(id) {\n-                    if let Some(encl_def_id) = hir.opt_local_def_id(encl_scope) {\n-                        if let Some(ign_traits) = self.ignored_derived_traits.get(&encl_def_id) {\n-                            let traits_str = ign_traits\n-                                .iter()\n-                                .map(|(trait_id, _)| format!(\"`{}`\", self.tcx.item_name(*trait_id)))\n-                                .collect::<Vec<_>>()\n-                                .join(\" and \");\n-                            let plural_s = pluralize!(ign_traits.len());\n-                            let article = if ign_traits.len() > 1 { \"\" } else { \"a \" };\n-                            let is_are = if ign_traits.len() > 1 { \"these are\" } else { \"this is\" };\n-                            let msg = format!(\n-                                \"`{}` has {}derived impl{} for the trait{} {}, but {} \\\n-                                 intentionally ignored during dead code analysis\",\n-                                self.tcx.item_name(encl_def_id.to_def_id()),\n-                                article,\n-                                plural_s,\n-                                plural_s,\n-                                traits_str,\n-                                is_are\n-                            );\n-                            let multispan = ign_traits\n-                                .iter()\n-                                .map(|(_, impl_id)| self.tcx.def_span(*impl_id))\n-                                .collect::<Vec<_>>();\n-                            err.span_note(multispan, &msg);\n-                        }\n-                    }\n+                if let Some(encl_scope) = hir.get_enclosing_scope(id)\n+                    && let Some(encl_def_id) = hir.opt_local_def_id(encl_scope)\n+                    && let Some(ign_traits) = self.ignored_derived_traits.get(&encl_def_id)\n+                {\n+                    let traits_str = ign_traits\n+                        .iter()\n+                        .map(|(trait_id, _)| format!(\"`{}`\", self.tcx.item_name(*trait_id)))\n+                        .collect::<Vec<_>>()\n+                        .join(\" and \");\n+                    let plural_s = pluralize!(ign_traits.len());\n+                    let article = if ign_traits.len() > 1 { \"\" } else { \"a \" };\n+                    let is_are = if ign_traits.len() > 1 { \"these are\" } else { \"this is\" };\n+                    let msg = format!(\n+                        \"`{}` has {}derived impl{} for the trait{} {}, but {} \\\n+                        intentionally ignored during dead code analysis\",\n+                        self.tcx.item_name(encl_def_id.to_def_id()),\n+                        article,\n+                        plural_s,\n+                        plural_s,\n+                        traits_str,\n+                        is_are\n+                    );\n+                    let multispan = ign_traits\n+                        .iter()\n+                        .map(|(_, impl_id)| self.tcx.def_span(*impl_id))\n+                        .collect::<Vec<_>>();\n+                    err.span_note(multispan, &msg);\n                 }\n                 err.emit();\n             });"}, {"sha": "71d49d8b7ea9ca442179f0c7f0a6c47d88c1fabf", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -4,16 +4,17 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(iter_intersperse)]\n #![feature(let_else)]\n+#![feature(let_chains)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(nll)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate rustc_middle;"}, {"sha": "ea99a90e937c39a9a292bd1d08c85900e79a2ed3", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -332,12 +332,11 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n         let def_id = local_def_id.to_def_id();\n \n         // Don't run unused pass for #[derive()]\n-        if let Some(parent) = self.tcx.parent(def_id) {\n-            if let DefKind::Impl = self.tcx.def_kind(parent.expect_local()) {\n-                if self.tcx.has_attr(parent, sym::automatically_derived) {\n-                    return;\n-                }\n-            }\n+        if let Some(parent) = self.tcx.parent(def_id)\n+            && let DefKind::Impl = self.tcx.def_kind(parent.expect_local())\n+            && self.tcx.has_attr(parent, sym::automatically_derived)\n+        {\n+            return;\n         }\n \n         // Don't run unused pass for #[naked]"}, {"sha": "b520e5d04eab98650b09844bc56e0df77bb4302e", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -94,24 +94,22 @@ impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n             _ => None,\n         };\n \n-        if let Some(res) = res {\n-            if let Some(def_id) = res.opt_def_id().and_then(|def_id| def_id.as_local()) {\n-                if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n-                    self.worklist.push(def_id);\n-                } else {\n-                    match res {\n-                        // If this path leads to a constant, then we need to\n-                        // recurse into the constant to continue finding\n-                        // items that are reachable.\n-                        Res::Def(DefKind::Const | DefKind::AssocConst, _) => {\n-                            self.worklist.push(def_id);\n-                        }\n+        if let Some(res) = res && let Some(def_id) = res.opt_def_id().and_then(|el| el.as_local()) {\n+            if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n+                self.worklist.push(def_id);\n+            } else {\n+                match res {\n+                    // If this path leads to a constant, then we need to\n+                    // recurse into the constant to continue finding\n+                    // items that are reachable.\n+                    Res::Def(DefKind::Const | DefKind::AssocConst, _) => {\n+                        self.worklist.push(def_id);\n+                    }\n \n-                        // If this wasn't a static, then the destination is\n-                        // surely reachable.\n-                        _ => {\n-                            self.reachable_symbols.insert(def_id);\n-                        }\n+                    // If this wasn't a static, then the destination is\n+                    // surely reachable.\n+                    _ => {\n+                        self.reachable_symbols.insert(def_id);\n                     }\n                 }\n             }"}, {"sha": "e164eff75502e340599173b19de029992b9d955c", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 92, "deletions": 58, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -566,7 +566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n-    ) -> Option<(Span, &'static str, String, Applicability, bool /* verbose */)> {\n+    ) -> Option<(Span, String, String, Applicability, bool /* verbose */)> {\n         let sess = self.sess();\n         let sp = expr.span;\n \n@@ -594,7 +594,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let pos = sp.lo() + BytePos(1);\n                                 return Some((\n                                     sp.with_hi(pos),\n-                                    \"consider removing the leading `b`\",\n+                                    \"consider removing the leading `b`\".to_string(),\n                                     String::new(),\n                                     Applicability::MachineApplicable,\n                                     true,\n@@ -608,7 +608,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     {\n                                 return Some((\n                                     sp.shrink_to_lo(),\n-                                    \"consider adding a leading `b`\",\n+                                    \"consider adding a leading `b`\".to_string(),\n                                     \"b\".to_string(),\n                                     Applicability::MachineApplicable,\n                                     true,\n@@ -668,7 +668,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(sugg) = self.can_use_as_ref(expr) {\n                             return Some((\n                                 sugg.0,\n-                                sugg.1,\n+                                sugg.1.to_string(),\n                                 sugg.2,\n                                 Applicability::MachineApplicable,\n                                 false,\n@@ -696,7 +696,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     return Some((\n                                         left_expr.span.shrink_to_lo(),\n                                         \"consider dereferencing here to assign to the mutable \\\n-                                         borrowed piece of memory\",\n+                                         borrowed piece of memory\"\n+                                            .to_string(),\n                                         \"*\".to_string(),\n                                         Applicability::MachineApplicable,\n                                         true,\n@@ -708,14 +709,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         return Some(match mutability {\n                             hir::Mutability::Mut => (\n                                 sp,\n-                                \"consider mutably borrowing here\",\n+                                \"consider mutably borrowing here\".to_string(),\n                                 format!(\"{}&mut {}\", prefix, sugg_expr),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n-                                \"consider borrowing here\",\n+                                \"consider borrowing here\".to_string(),\n                                 format!(\"{}&{}\", prefix, sugg_expr),\n                                 Applicability::MachineApplicable,\n                                 false,\n@@ -744,7 +745,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if sm.span_to_snippet(call_span).is_ok() {\n                             return Some((\n                                 sp.with_hi(call_span.lo()),\n-                                \"consider removing the borrow\",\n+                                \"consider removing the borrow\".to_string(),\n                                 String::new(),\n                                 Applicability::MachineApplicable,\n                                 true,\n@@ -757,7 +758,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if sm.span_to_snippet(expr.span).is_ok() {\n                         return Some((\n                             sp.with_hi(expr.span.lo()),\n-                            \"consider removing the borrow\",\n+                            \"consider removing the borrow\".to_string(),\n                             String::new(),\n                             Applicability::MachineApplicable,\n                             true,\n@@ -823,7 +824,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             } {\n                                 return Some((\n                                     span,\n-                                    \"consider dereferencing\",\n+                                    \"consider dereferencing\".to_string(),\n                                     src,\n                                     applicability,\n                                     true,\n@@ -834,60 +835,93 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             _ if sp == expr.span => {\n-                if let Some(steps) = self.deref_steps(checked_ty, expected) {\n-                    let expr = expr.peel_blocks();\n+                if let Some(mut steps) = self.deref_steps(checked_ty, expected) {\n+                    let mut expr = expr.peel_blocks();\n+                    let mut prefix_span = expr.span.shrink_to_lo();\n+                    let mut remove = String::new();\n \n-                    if steps == 1 {\n+                    // Try peeling off any existing `&` and `&mut` to reach our target type\n+                    while steps > 0 {\n                         if let hir::ExprKind::AddrOf(_, mutbl, inner) = expr.kind {\n                             // If the expression has `&`, removing it would fix the error\n-                            let prefix_span = expr.span.with_hi(inner.span.lo());\n-                            let message = match mutbl {\n-                                hir::Mutability::Not => \"consider removing the `&`\",\n-                                hir::Mutability::Mut => \"consider removing the `&mut`\",\n+                            prefix_span = prefix_span.with_hi(inner.span.lo());\n+                            expr = inner;\n+                            remove += match mutbl {\n+                                hir::Mutability::Not => \"&\",\n+                                hir::Mutability::Mut => \"&mut \",\n                             };\n-                            let suggestion = String::new();\n-                            return Some((\n-                                prefix_span,\n-                                message,\n-                                suggestion,\n-                                Applicability::MachineApplicable,\n-                                false,\n-                            ));\n+                            steps -= 1;\n+                        } else {\n+                            break;\n                         }\n-\n-                        // For this suggestion to make sense, the type would need to be `Copy`,\n-                        // or we have to be moving out of a `Box<T>`\n-                        if self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp)\n-                            || checked_ty.is_box()\n-                        {\n-                            let message = if checked_ty.is_box() {\n-                                \"consider unboxing the value\"\n-                            } else if checked_ty.is_region_ptr() {\n-                                \"consider dereferencing the borrow\"\n-                            } else {\n-                                \"consider dereferencing the type\"\n-                            };\n-                            let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                                Some(ident) => format!(\"{}: \", ident),\n-                                None => String::new(),\n-                            };\n-                            let (span, suggestion) = if self.is_else_if_block(expr) {\n-                                // Don't suggest nonsense like `else *if`\n-                                return None;\n-                            } else if let Some(expr) = self.maybe_get_block_expr(expr) {\n-                                // prefix should be empty here..\n-                                (expr.span.shrink_to_lo(), \"*\".to_string())\n+                    }\n+                    // If we've reached our target type with just removing `&`, then just print now.\n+                    if steps == 0 {\n+                        return Some((\n+                            prefix_span,\n+                            format!(\"consider removing the `{}`\", remove.trim()),\n+                            String::new(),\n+                            // Do not remove `&&` to get to bool, because it might be something like\n+                            // { a } && b, which we have a separate fixup suggestion that is more\n+                            // likely correct...\n+                            if remove.trim() == \"&&\" && expected == self.tcx.types.bool {\n+                                Applicability::MaybeIncorrect\n                             } else {\n-                                (expr.span.shrink_to_lo(), format!(\"{}*\", prefix))\n-                            };\n-                            return Some((\n-                                span,\n-                                message,\n-                                suggestion,\n-                                Applicability::MachineApplicable,\n-                                true,\n-                            ));\n-                        }\n+                                Applicability::MachineApplicable\n+                            },\n+                            true,\n+                        ));\n+                    }\n+\n+                    // For this suggestion to make sense, the type would need to be `Copy`,\n+                    // or we have to be moving out of a `Box<T>`\n+                    if self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp)\n+                        // FIXME(compiler-errors): We can actually do this if the checked_ty is\n+                        // `steps` layers of boxes, not just one, but this is easier and most likely.\n+                        || (checked_ty.is_box() && steps == 1)\n+                    {\n+                        let deref_kind = if checked_ty.is_box() {\n+                            \"unboxing the value\"\n+                        } else if checked_ty.is_region_ptr() {\n+                            \"dereferencing the borrow\"\n+                        } else {\n+                            \"dereferencing the type\"\n+                        };\n+\n+                        // Suggest removing `&` if we have removed any, otherwise suggest just\n+                        // dereferencing the remaining number of steps.\n+                        let message = if remove.is_empty() {\n+                            format!(\"consider {}\", deref_kind)\n+                        } else {\n+                            format!(\n+                                \"consider removing the `{}` and {} instead\",\n+                                remove.trim(),\n+                                deref_kind\n+                            )\n+                        };\n+\n+                        let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                            Some(ident) => format!(\"{}: \", ident),\n+                            None => String::new(),\n+                        };\n+\n+                        let (span, suggestion) = if self.is_else_if_block(expr) {\n+                            // Don't suggest nonsense like `else *if`\n+                            return None;\n+                        } else if let Some(expr) = self.maybe_get_block_expr(expr) {\n+                            // prefix should be empty here..\n+                            (expr.span.shrink_to_lo(), \"*\".to_string())\n+                        } else {\n+                            (prefix_span, format!(\"{}{}\", prefix, \"*\".repeat(steps)))\n+                        };\n+\n+                        return Some((\n+                            span,\n+                            message,\n+                            suggestion,\n+                            Applicability::MachineApplicable,\n+                            true,\n+                        ));\n                     }\n                 }\n             }"}, {"sha": "523602d5b1888dbcc3b2756fdbee760724c95adc", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -218,9 +218,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.check_ref(expr, found, expected)\n         {\n             if verbose {\n-                err.span_suggestion_verbose(sp, msg, suggestion, applicability);\n+                err.span_suggestion_verbose(sp, &msg, suggestion, applicability);\n             } else {\n-                err.span_suggestion(sp, msg, suggestion, applicability);\n+                err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n         } else if let (ty::FnDef(def_id, ..), true) =\n             (&found.kind(), self.suggest_fn_call(err, expr, expected, found))"}, {"sha": "2b8bbe1924450a41a8f20d01e3018631f6da3aae", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -340,6 +340,32 @@ impl AtomicBool {\n         unsafe { &mut *(v as *mut bool as *mut Self) }\n     }\n \n+    /// Get atomic access to a `&mut [bool]` slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_mut, scoped_threads)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let mut some_bools = [false; 10];\n+    /// let a = &*AtomicBool::from_mut_slice(&mut some_bools);\n+    /// std::thread::scope(|s| {\n+    ///     for i in 0..a.len() {\n+    ///         s.spawn(move |_| a[i].store(true, Ordering::Relaxed));\n+    ///     }\n+    /// });\n+    /// assert_eq!(some_bools, [true; 10]);\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic_equal_alignment = \"8\")]\n+    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+    pub fn from_mut_slice(v: &mut [bool]) -> &mut [Self] {\n+        // SAFETY: the mutable reference guarantees unique ownership, and\n+        // alignment of both `bool` and `Self` is 1.\n+        unsafe { &mut *(v as *mut [bool] as *mut [Self]) }\n+    }\n+\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -945,6 +971,42 @@ impl<T> AtomicPtr<T> {\n         unsafe { &mut *(v as *mut *mut T as *mut Self) }\n     }\n \n+    /// Get atomic access to a slice of pointers.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_mut, scoped_threads)]\n+    /// use std::ptr::null_mut;\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let mut some_ptrs = [null_mut::<String>(); 10];\n+    /// let a = &*AtomicPtr::from_mut_slice(&mut some_ptrs);\n+    /// std::thread::scope(|s| {\n+    ///     for i in 0..a.len() {\n+    ///         s.spawn(move |_| {\n+    ///             let name = Box::new(format!(\"thread{i}\"));\n+    ///             a[i].store(Box::into_raw(name), Ordering::Relaxed);\n+    ///         });\n+    ///     }\n+    /// });\n+    /// for p in some_ptrs {\n+    ///     assert!(!p.is_null());\n+    ///     let name = unsafe { Box::from_raw(p) };\n+    ///     println!(\"Hello, {name}!\");\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[cfg(target_has_atomic_equal_alignment = \"ptr\")]\n+    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+    pub fn from_mut_slice(v: &mut [*mut T]) -> &mut [Self] {\n+        // SAFETY:\n+        //  - the mutable reference guarantees unique ownership.\n+        //  - the alignment of `*mut T` and `Self` is the same on all platforms\n+        //    supported by rust, as verified above.\n+        unsafe { &mut *(v as *mut [*mut T] as *mut [Self]) }\n+    }\n+\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -1459,6 +1521,38 @@ macro_rules! atomic_int {\n                 unsafe { &mut *(v as *mut $int_type as *mut Self) }\n             }\n \n+            #[doc = concat!(\"Get atomic access to a `&mut [\", stringify!($int_type), \"]` slice.\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// #![feature(atomic_from_mut, scoped_threads)]\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            /// let mut some_ints = [0; 10];\n+            #[doc = concat!(\"let a = &*\", stringify!($atomic_type), \"::from_mut_slice(&mut some_ints);\")]\n+            /// std::thread::scope(|s| {\n+            ///     for i in 0..a.len() {\n+            ///         s.spawn(move |_| a[i].store(i as _, Ordering::Relaxed));\n+            ///     }\n+            /// });\n+            /// for (i, n) in some_ints.into_iter().enumerate() {\n+            ///     assert_eq!(i, n as usize);\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[$cfg_align]\n+            #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+            pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {\n+                use crate::mem::align_of;\n+                let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n+                // SAFETY:\n+                //  - the mutable reference guarantees unique ownership.\n+                //  - the alignment of `$int_type` and `Self` is the\n+                //    same, as promised by $cfg_align and verified above.\n+                unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }\n+            }\n+\n             /// Consumes the atomic and returns the contained value.\n             ///\n             /// This is safe because passing `self` by value guarantees that no other threads are"}, {"sha": "c515dad4deabd455396d7d17ed4a30859ce1252b", "filename": "library/portable-simd/crates/core_simd/examples/spectral_norm.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -0,0 +1,77 @@\n+#![feature(portable_simd)]\n+\n+use core_simd::simd::*;\n+\n+fn a(i: usize, j: usize) -> f64 {\n+    ((i + j) * (i + j + 1) / 2 + i + 1) as f64\n+}\n+\n+fn mult_av(v: &[f64], out: &mut [f64]) {\n+    assert!(v.len() == out.len());\n+    assert!(v.len() % 2 == 0);\n+\n+    for (i, out) in out.iter_mut().enumerate() {\n+        let mut sum = f64x2::splat(0.0);\n+\n+        let mut j = 0;\n+        while j < v.len() {\n+            let b = f64x2::from_slice(&v[j..]);\n+            let a = f64x2::from_array([a(i, j), a(i, j + 1)]);\n+            sum += b / a;\n+            j += 2\n+        }\n+        *out = sum.horizontal_sum();\n+    }\n+}\n+\n+fn mult_atv(v: &[f64], out: &mut [f64]) {\n+    assert!(v.len() == out.len());\n+    assert!(v.len() % 2 == 0);\n+\n+    for (i, out) in out.iter_mut().enumerate() {\n+        let mut sum = f64x2::splat(0.0);\n+\n+        let mut j = 0;\n+        while j < v.len() {\n+            let b = f64x2::from_slice(&v[j..]);\n+            let a = f64x2::from_array([a(j, i), a(j + 1, i)]);\n+            sum += b / a;\n+            j += 2\n+        }\n+        *out = sum.horizontal_sum();\n+    }\n+}\n+\n+fn mult_atav(v: &[f64], out: &mut [f64], tmp: &mut [f64]) {\n+    mult_av(v, tmp);\n+    mult_atv(tmp, out);\n+}\n+\n+pub fn spectral_norm(n: usize) -> f64 {\n+    assert!(n % 2 == 0, \"only even lengths are accepted\");\n+\n+    let mut u = vec![1.0; n];\n+    let mut v = u.clone();\n+    let mut tmp = u.clone();\n+\n+    for _ in 0..10 {\n+        mult_atav(&u, &mut v, &mut tmp);\n+        mult_atav(&v, &mut u, &mut tmp);\n+    }\n+    (dot(&u, &v) / dot(&v, &v)).sqrt()\n+}\n+\n+fn dot(x: &[f64], y: &[f64]) -> f64 {\n+    // This is auto-vectorized:\n+    x.iter().zip(y).map(|(&x, &y)| x * y).sum()\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test() {\n+    assert_eq!(&format!(\"{:.9}\", spectral_norm(100)), \"1.274219991\");\n+}\n+\n+fn main() {\n+    // Empty main to make cargo happy\n+}"}, {"sha": "d024cf4ddbe30b04211e4460e2e0d831a1b6746d", "filename": "library/portable-simd/crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -10,13 +10,17 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n     }\n \n     /// Test if each lane is not equal to the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n     }\n }\n@@ -30,27 +34,35 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n     }\n \n     /// Test if each lane is greater than the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n     }\n \n     /// Test if each lane is less than or equal to the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n     }\n \n     /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n     }\n }"}, {"sha": "4c68d11e8932aaf2f2febb9e0410ff96dba42bc8", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -2,31 +2,55 @@\n //! crate.\n //!\n //! The LLVM assembly language is documented here: <https://llvm.org/docs/LangRef.html>\n+//!\n+//! A quick glossary of jargon that may appear in this module, mostly paraphrasing LLVM's LangRef:\n+//! - poison: \"undefined behavior as a value\". specifically, it is like uninit memory (such as padding bytes). it is \"safe\" to create poison, BUT\n+//!   poison MUST NOT be observed from safe code, as operations on poison return poison, like NaN. unlike NaN, which has defined comparisons,\n+//!   poison is neither true nor false, and LLVM may also convert it to undef (at which point it is both). so, it can't be conditioned on, either.\n+//! - undef: \"a value that is every value\". functionally like poison, insofar as Rust is concerned. poison may become this. note:\n+//!   this means that division by poison or undef is like division by zero, which means it inflicts...\n+//! - \"UB\": poison and undef cover most of what people call \"UB\". \"UB\" means this operation immediately invalidates the program:\n+//!   LLVM is allowed to lower it to `ud2` or other opcodes that may cause an illegal instruction exception, and this is the \"good end\".\n+//!   The \"bad end\" is that LLVM may reverse time to the moment control flow diverged on a path towards undefined behavior,\n+//!   and destroy the other branch, potentially deleting safe code and violating Rust's `unsafe` contract.\n+//!\n+//! Note that according to LLVM, vectors are not arrays, but they are equivalent when stored to and loaded from memory.\n+//!\n+//! Unless stated otherwise, all intrinsics for binary operations require SIMD vectors of equal types and lengths.\n \n /// These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n-/// simply lowered to the matching LLVM instructions by the compiler.  The associated instruction\n-/// is documented alongside each intrinsic.\n+/// mostly lowered to the matching LLVM instructions by the compiler in a fairly straightforward manner.\n+/// The associated LLVM instruction or intrinsic is documented alongside each Rust intrinsic function.\n extern \"platform-intrinsic\" {\n     /// add/fadd\n     pub(crate) fn simd_add<T>(x: T, y: T) -> T;\n \n     /// sub/fsub\n-    pub(crate) fn simd_sub<T>(x: T, y: T) -> T;\n+    pub(crate) fn simd_sub<T>(lhs: T, rhs: T) -> T;\n \n     /// mul/fmul\n     pub(crate) fn simd_mul<T>(x: T, y: T) -> T;\n \n     /// udiv/sdiv/fdiv\n-    pub(crate) fn simd_div<T>(x: T, y: T) -> T;\n+    /// ints and uints: {s,u}div incur UB if division by zero occurs.\n+    /// ints: sdiv is UB for int::MIN / -1.\n+    /// floats: fdiv is never UB, but may create NaNs or infinities.\n+    pub(crate) fn simd_div<T>(lhs: T, rhs: T) -> T;\n \n     /// urem/srem/frem\n-    pub(crate) fn simd_rem<T>(x: T, y: T) -> T;\n+    /// ints and uints: {s,u}rem incur UB if division by zero occurs.\n+    /// ints: srem is UB for int::MIN / -1.\n+    /// floats: frem is equivalent to libm::fmod in the \"default\" floating point environment, sans errno.\n+    pub(crate) fn simd_rem<T>(lhs: T, rhs: T) -> T;\n \n     /// shl\n-    pub(crate) fn simd_shl<T>(x: T, y: T) -> T;\n+    /// for (u)ints. poison if rhs >= lhs::BITS\n+    pub(crate) fn simd_shl<T>(lhs: T, rhs: T) -> T;\n \n-    /// lshr/ashr\n-    pub(crate) fn simd_shr<T>(x: T, y: T) -> T;\n+    /// ints: ashr\n+    /// uints: lshr\n+    /// poison if rhs >= lhs::BITS\n+    pub(crate) fn simd_shr<T>(lhs: T, rhs: T) -> T;\n \n     /// and\n     pub(crate) fn simd_and<T>(x: T, y: T) -> T;\n@@ -38,12 +62,18 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n \n     /// fptoui/fptosi/uitofp/sitofp\n+    /// casting floats to integers is truncating, so it is safe to convert values like e.g. 1.5\n+    /// but the truncated value must fit in the target type or the result is poison.\n+    /// use `simd_as` instead for a cast that performs a saturating conversion.\n     pub(crate) fn simd_cast<T, U>(x: T) -> U;\n     /// follows Rust's `T as U` semantics, including saturating float casts\n     /// which amounts to the same as `simd_cast` for many cases\n     pub(crate) fn simd_as<T, U>(x: T) -> U;\n \n     /// neg/fneg\n+    /// ints: ultimately becomes a call to cg_ssa's BuilderMethods::neg. cg_llvm equates this to `simd_sub(Simd::splat(0), x)`.\n+    /// floats: LLVM's fneg, which changes the floating point sign bit. Some arches have instructions for it.\n+    /// Rust panics for Neg::neg(int::MIN) due to overflow, but it is not UB in LLVM without `nsw`.\n     pub(crate) fn simd_neg<T>(x: T) -> T;\n \n     /// fabs\n@@ -53,6 +83,7 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_fmin<T>(x: T, y: T) -> T;\n     pub(crate) fn simd_fmax<T>(x: T, y: T) -> T;\n \n+    // these return Simd<int, N> with the same BITS size as the inputs\n     pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;\n@@ -61,19 +92,31 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_ge<T, U>(x: T, y: T) -> U;\n \n     // shufflevector\n+    // idx: LLVM calls it a \"shuffle mask vector constant\", a vector of i32s\n     pub(crate) fn simd_shuffle<T, U, V>(x: T, y: T, idx: U) -> V;\n \n+    /// llvm.masked.gather\n+    /// like a loop of pointer reads\n+    /// val: vector of values to select if a lane is masked\n+    /// ptr: vector of pointers to read from\n+    /// mask: a \"wide\" mask of integers, selects as if simd_select(mask, read(ptr), val)\n+    /// note, the LLVM intrinsic accepts a mask vector of <N x i1>\n+    /// FIXME: review this if/when we fix up our mask story in general?\n     pub(crate) fn simd_gather<T, U, V>(val: T, ptr: U, mask: V) -> T;\n+    /// llvm.masked.scatter\n+    /// like gather, but more spicy, as it writes instead of reads\n     pub(crate) fn simd_scatter<T, U, V>(val: T, ptr: U, mask: V);\n \n     // {s,u}add.sat\n     pub(crate) fn simd_saturating_add<T>(x: T, y: T) -> T;\n \n     // {s,u}sub.sat\n-    pub(crate) fn simd_saturating_sub<T>(x: T, y: T) -> T;\n+    pub(crate) fn simd_saturating_sub<T>(lhs: T, rhs: T) -> T;\n \n     // reductions\n+    // llvm.vector.reduce.{add,fadd}\n     pub(crate) fn simd_reduce_add_ordered<T, U>(x: T, y: U) -> U;\n+    // llvm.vector.reduce.{mul,fmul}\n     pub(crate) fn simd_reduce_mul_ordered<T, U>(x: T, y: U) -> U;\n     #[allow(unused)]\n     pub(crate) fn simd_reduce_all<T>(x: T) -> bool;\n@@ -90,7 +133,10 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_bitmask<T, U>(x: T) -> U;\n \n     // select\n-    pub(crate) fn simd_select<M, T>(m: M, a: T, b: T) -> T;\n+    // first argument is a vector of integers, -1 (all bits 1) is \"true\"\n+    // logically equivalent to (yes & m) | (no & (m^-1),\n+    // but you can use it on floats.\n+    pub(crate) fn simd_select<M, T>(m: M, yes: T, no: T) -> T;\n     #[allow(unused)]\n-    pub(crate) fn simd_select_bitmask<M, T>(m: M, a: T, b: T) -> T;\n+    pub(crate) fn simd_select_bitmask<M, T>(m: M, yes: T, no: T) -> T;\n }"}, {"sha": "91ae34c05e095884169824f1f0b0ab461e1d6c7d", "filename": "library/portable-simd/crates/core_simd/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -1,7 +1,9 @@\n #![cfg_attr(not(feature = \"std\"), no_std)]\n #![feature(\n     const_fn_trait_bound,\n+    convert_float_to_int,\n     decl_macro,\n+    intra_doc_pointers,\n     platform_intrinsics,\n     repr_simd,\n     simd_ffi,"}, {"sha": "e1cd793045046b1963e3613802290cbd5f8ad1b8", "filename": "library/portable-simd/crates/core_simd/src/masks.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -12,8 +12,10 @@\n )]\n mod mask_impl;\n \n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+mod to_bitmask;\n+pub use to_bitmask::ToBitMask;\n+\n+use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SupportedLaneCount};\n use core::cmp::Ordering;\n use core::{fmt, mem};\n \n@@ -42,6 +44,9 @@ mod sealed {\n use sealed::Sealed;\n \n /// Marker trait for types that may be used as SIMD mask elements.\n+///\n+/// # Safety\n+/// Type must be a signed integer.\n pub unsafe trait MaskElement: SimdElement + Sealed {}\n \n macro_rules! impl_element {\n@@ -149,6 +154,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n+        // Safety: the caller must confirm this invariant\n         unsafe { Self(mask_impl::Mask::from_int_unchecked(value)) }\n     }\n \n@@ -161,6 +167,7 @@ where\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_int(value: Simd<T, LANES>) -> Self {\n         assert!(T::valid(value), \"all values must be either 0 or -1\",);\n+        // Safety: the validity has been checked\n         unsafe { Self::from_int_unchecked(value) }\n     }\n \n@@ -179,6 +186,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+        // Safety: the caller must confirm this invariant\n         unsafe { self.0.test_unchecked(lane) }\n     }\n \n@@ -190,6 +198,7 @@ where\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn test(&self, lane: usize) -> bool {\n         assert!(lane < LANES, \"lane index out of range\");\n+        // Safety: the lane index has been checked\n         unsafe { self.test_unchecked(lane) }\n     }\n \n@@ -199,6 +208,7 @@ where\n     /// `lane` must be less than `LANES`.\n     #[inline]\n     pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+        // Safety: the caller must confirm this invariant\n         unsafe {\n             self.0.set_unchecked(lane, value);\n         }\n@@ -211,27 +221,12 @@ where\n     #[inline]\n     pub fn set(&mut self, lane: usize, value: bool) {\n         assert!(lane < LANES, \"lane index out of range\");\n+        // Safety: the lane index has been checked\n         unsafe {\n             self.set_unchecked(lane, value);\n         }\n     }\n \n-    /// Convert this mask to a bitmask, with one bit set per lane.\n-    #[cfg(feature = \"generic_const_exprs\")]\n-    #[inline]\n-    #[must_use = \"method returns a new array and does not mutate the original value\"]\n-    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n-        self.0.to_bitmask()\n-    }\n-\n-    /// Convert a bitmask to a mask.\n-    #[cfg(feature = \"generic_const_exprs\")]\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-        Self(mask_impl::Mask::from_bitmask(bitmask))\n-    }\n-\n     /// Returns true if any lane is set, or false otherwise.\n     #[inline]\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]"}, {"sha": "ec4dd357ee98c5b4660e3173053679d30dceecce", "filename": "library/portable-simd/crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -1,7 +1,7 @@\n #![allow(unused_imports)]\n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n use core::marker::PhantomData;\n \n /// A mask where each lane is represented by a single bit.\n@@ -115,20 +115,22 @@ where\n         unsafe { Self(intrinsics::simd_bitmask(value), PhantomData) }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new array and does not mutate the original value\"]\n-    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n-        // Safety: these are the same type and we are laundering the generic\n+    pub fn to_bitmask_integer<U>(self) -> U\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: these are the same types\n         unsafe { core::mem::transmute_copy(&self.0) }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-        // Safety: these are the same type and we are laundering the generic\n-        Self(unsafe { core::mem::transmute_copy(&bitmask) }, PhantomData)\n+    pub fn from_bitmask_integer<U>(bitmask: U) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: these are the same types\n+        unsafe { Self(core::mem::transmute_copy(&bitmask), PhantomData) }\n     }\n \n     #[inline]\n@@ -137,6 +139,7 @@ where\n     where\n         U: MaskElement,\n     {\n+        // Safety: bitmask layout does not depend on the element width\n         unsafe { core::mem::transmute_copy(&self) }\n     }\n "}, {"sha": "8bbdf637de84defcc23f1e3a8afc07d0eb2538a7", "filename": "library/portable-simd/crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -2,7 +2,7 @@\n \n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n \n #[repr(transparent)]\n pub struct Mask<T, const LANES: usize>(Simd<T, LANES>)\n@@ -66,6 +66,23 @@ where\n     }\n }\n \n+// Used for bitmask bit order workaround\n+pub(crate) trait ReverseBits {\n+    fn reverse_bits(self) -> Self;\n+}\n+\n+macro_rules! impl_reverse_bits {\n+    { $($int:ty),* } => {\n+        $(\n+        impl ReverseBits for $int {\n+            fn reverse_bits(self) -> Self { <$int>::reverse_bits(self) }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_reverse_bits! { u8, u16, u32, u64 }\n+\n impl<T, const LANES: usize> Mask<T, LANES>\n where\n     T: MaskElement,\n@@ -106,44 +123,40 @@ where\n     where\n         U: MaskElement,\n     {\n+        // Safety: masks are simply integer vectors of 0 and -1, and we can cast the element type.\n         unsafe { Mask(intrinsics::simd_cast(self.0)) }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new array and does not mutate the original value\"]\n-    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n-        unsafe {\n-            let mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN] =\n-                intrinsics::simd_bitmask(self.0);\n-\n-            // There is a bug where LLVM appears to implement this operation with the wrong\n-            // bit order.\n-            // TODO fix this in a better way\n-            if cfg!(target_endian = \"big\") {\n-                for x in bitmask.as_mut() {\n-                    *x = x.reverse_bits();\n-                }\n-            }\n+    pub(crate) fn to_bitmask_integer<U: ReverseBits>(self) -> U\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: U is required to be the appropriate bitmask type\n+        let bitmask: U = unsafe { intrinsics::simd_bitmask(self.0) };\n \n+        // LLVM assumes bit order should match endianness\n+        if cfg!(target_endian = \"big\") {\n+            bitmask.reverse_bits()\n+        } else {\n             bitmask\n         }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn from_bitmask(mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-        unsafe {\n-            // There is a bug where LLVM appears to implement this operation with the wrong\n-            // bit order.\n-            // TODO fix this in a better way\n-            if cfg!(target_endian = \"big\") {\n-                for x in bitmask.as_mut() {\n-                    *x = x.reverse_bits();\n-                }\n-            }\n+    pub(crate) fn from_bitmask_integer<U: ReverseBits>(bitmask: U) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // LLVM assumes bit order should match endianness\n+        let bitmask = if cfg!(target_endian = \"big\") {\n+            bitmask.reverse_bits()\n+        } else {\n+            bitmask\n+        };\n \n+        // Safety: U is required to be the appropriate bitmask type\n+        unsafe {\n             Self::from_int_unchecked(intrinsics::simd_select_bitmask(\n                 bitmask,\n                 Self::splat(true).to_int(),\n@@ -155,12 +168,14 @@ where\n     #[inline]\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn any(self) -> bool {\n+        // Safety: use `self` as an integer vector\n         unsafe { intrinsics::simd_reduce_any(self.to_int()) }\n     }\n \n     #[inline]\n     #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn all(self) -> bool {\n+        // Safety: use `self` as an integer vector\n         unsafe { intrinsics::simd_reduce_all(self.to_int()) }\n     }\n }\n@@ -184,6 +199,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: Self) -> Self {\n+        // Safety: `self` is an integer vector\n         unsafe { Self(intrinsics::simd_and(self.0, rhs.0)) }\n     }\n }\n@@ -197,6 +213,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: Self) -> Self {\n+        // Safety: `self` is an integer vector\n         unsafe { Self(intrinsics::simd_or(self.0, rhs.0)) }\n     }\n }\n@@ -210,6 +227,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: Self) -> Self {\n+        // Safety: `self` is an integer vector\n         unsafe { Self(intrinsics::simd_xor(self.0, rhs.0)) }\n     }\n }"}, {"sha": "1c2037764c1e45af1960550df93cc290af05eaee", "filename": "library/portable-simd/crates/core_simd/src/masks/to_bitmask.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -0,0 +1,57 @@\n+use super::{mask_impl, Mask, MaskElement};\n+use crate::simd::{LaneCount, SupportedLaneCount};\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+pub use sealed::Sealed;\n+\n+impl<T, const LANES: usize> Sealed for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+/// Converts masks to and from integer bitmasks.\n+///\n+/// Each bit of the bitmask corresponds to a mask lane, starting with the LSB.\n+///\n+/// # Safety\n+/// This trait is `unsafe` and sealed, since the `BitMask` type must match the number of lanes in\n+/// the mask.\n+pub unsafe trait ToBitMask: Sealed {\n+    /// The integer bitmask type.\n+    type BitMask;\n+\n+    /// Converts a mask to a bitmask.\n+    fn to_bitmask(self) -> Self::BitMask;\n+\n+    /// Converts a bitmask to a mask.\n+    fn from_bitmask(bitmask: Self::BitMask) -> Self;\n+}\n+\n+macro_rules! impl_integer_intrinsic {\n+    { $(unsafe impl ToBitMask<BitMask=$int:ty> for Mask<_, $lanes:literal>)* } => {\n+        $(\n+        unsafe impl<T: MaskElement> ToBitMask for Mask<T, $lanes> {\n+            type BitMask = $int;\n+\n+            fn to_bitmask(self) -> $int {\n+                self.0.to_bitmask_integer()\n+            }\n+\n+            fn from_bitmask(bitmask: $int) -> Self {\n+                Self(mask_impl::Mask::from_bitmask_integer(bitmask))\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_integer_intrinsic! {\n+    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 8>\n+    unsafe impl ToBitMask<BitMask=u16> for Mask<_, 16>\n+    unsafe impl ToBitMask<BitMask=u32> for Mask<_, 32>\n+    unsafe impl ToBitMask<BitMask=u64> for Mask<_, 64>\n+}"}, {"sha": "0b4e40983af53e8a54eb11d902850aef0fb53fb1", "filename": "library/portable-simd/crates/core_simd/src/math.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -22,6 +22,7 @@ macro_rules! impl_uint_arith {\n             /// ```\n             #[inline]\n             pub fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_add(self, second) }\n             }\n \n@@ -41,6 +42,7 @@ macro_rules! impl_uint_arith {\n             /// assert_eq!(sat, Simd::splat(0));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_sub(self, second) }\n             }\n         })+\n@@ -68,6 +70,7 @@ macro_rules! impl_int_arith {\n             /// ```\n             #[inline]\n             pub fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_add(self, second) }\n             }\n \n@@ -87,6 +90,7 @@ macro_rules! impl_int_arith {\n             /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_sub(self, second) }\n             }\n "}, {"sha": "1b35b3e717a3259591b84c1d15bd1fdff24a40d8", "filename": "library/portable-simd/crates/core_simd/src/ops.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -57,29 +57,40 @@ macro_rules! wrap_bitshift {\n     };\n }\n \n-// Division by zero is poison, according to LLVM.\n-// So is dividing the MIN value of a signed integer by -1,\n-// since that would return MAX + 1.\n-// FIXME: Rust allows <SInt>::MIN / -1,\n-// so we should probably figure out how to make that safe.\n+/// SAFETY: This macro must only be used to impl Div or Rem and given the matching intrinsic.\n+/// It guards against LLVM's UB conditions for integer div or rem using masks and selects,\n+/// thus guaranteeing a Rust value returns instead.\n+///\n+/// |                  | LLVM | Rust\n+/// | :--------------: | :--- | :----------\n+/// | N {/,%} 0        | UB   | panic!()\n+/// | <$int>::MIN / -1 | UB   | <$int>::MIN\n+/// | <$int>::MIN % -1 | UB   | 0\n+///\n macro_rules! int_divrem_guard {\n     (   $lhs:ident,\n         $rhs:ident,\n         {   const PANIC_ZERO: &'static str = $zero:literal;\n-            const PANIC_OVERFLOW: &'static str = $overflow:literal;\n             $simd_call:ident\n         },\n         $int:ident ) => {\n         if $rhs.lanes_eq(Simd::splat(0)).any() {\n             panic!($zero);\n-        } else if <$int>::MIN != 0\n-            && ($lhs.lanes_eq(Simd::splat(<$int>::MIN))\n-                // type inference can break here, so cut an SInt to size\n-                & $rhs.lanes_eq(Simd::splat(-1i64 as _))).any()\n-        {\n-            panic!($overflow);\n         } else {\n-            unsafe { $crate::simd::intrinsics::$simd_call($lhs, $rhs) }\n+            // Prevent otherwise-UB overflow on the MIN / -1 case.\n+            let rhs = if <$int>::MIN != 0 {\n+                // This should, at worst, optimize to a few branchless logical ops\n+                // Ideally, this entire conditional should evaporate\n+                // Fire LLVM and implement those manually if it doesn't get the hint\n+                ($lhs.lanes_eq(Simd::splat(<$int>::MIN))\n+                // type inference can break here, so cut an SInt to size\n+                & $rhs.lanes_eq(Simd::splat(-1i64 as _)))\n+                .select(Simd::splat(1), $rhs)\n+            } else {\n+                // Nice base case to make it easy to const-fold away the other branch.\n+                $rhs\n+            };\n+            unsafe { $crate::simd::intrinsics::$simd_call($lhs, rhs) }\n         }\n     };\n }\n@@ -183,15 +194,13 @@ for_base_ops! {\n     impl Div::div {\n         int_divrem_guard {\n             const PANIC_ZERO: &'static str = \"attempt to divide by zero\";\n-            const PANIC_OVERFLOW: &'static str = \"attempt to divide with overflow\";\n             simd_div\n         }\n     }\n \n     impl Rem::rem {\n         int_divrem_guard {\n             const PANIC_ZERO: &'static str = \"attempt to calculate the remainder with a divisor of zero\";\n-            const PANIC_OVERFLOW: &'static str = \"attempt to calculate the remainder with overflow\";\n             simd_rem\n         }\n     }"}, {"sha": "e1cd743e44247d55c4c9f49f6f004a60d981a7cb", "filename": "library/portable-simd/crates/core_simd/src/reduction.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -14,24 +14,28 @@ macro_rules! impl_integer_reductions {\n             /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n             pub fn horizontal_sum(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_add_ordered(self, 0) }\n             }\n \n             /// Horizontal wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n             #[inline]\n             pub fn horizontal_product(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_mul_ordered(self, 1) }\n             }\n \n             /// Horizontal maximum.  Returns the maximum lane in the vector.\n             #[inline]\n             pub fn horizontal_max(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n             /// Horizontal minimum.  Returns the minimum lane in the vector.\n             #[inline]\n             pub fn horizontal_min(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_min(self) }\n             }\n         }\n@@ -63,6 +67,7 @@ macro_rules! impl_float_reductions {\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().sum()\n                 } else {\n+                    // Safety: `self` is a float vector\n                     unsafe { simd_reduce_add_ordered(self, 0.) }\n                 }\n             }\n@@ -74,6 +79,7 @@ macro_rules! impl_float_reductions {\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().product()\n                 } else {\n+                    // Safety: `self` is a float vector\n                     unsafe { simd_reduce_mul_ordered(self, 1.) }\n                 }\n             }\n@@ -84,6 +90,7 @@ macro_rules! impl_float_reductions {\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n             pub fn horizontal_max(self) -> $scalar {\n+                // Safety: `self` is a float vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n@@ -93,6 +100,7 @@ macro_rules! impl_float_reductions {\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n             pub fn horizontal_min(self) -> $scalar {\n+                // Safety: `self` is a float vector\n                 unsafe { simd_reduce_min(self) }\n             }\n         }"}, {"sha": "556bc2cc1feee8a114253cdb99d464a5438b3bba", "filename": "library/portable-simd/crates/core_simd/src/round.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -1,9 +1,10 @@\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use core::convert::FloatToInt;\n \n macro_rules! implement {\n     {\n-        $type:ty, $int_type:ty\n+        $type:ty\n     } => {\n         impl<const LANES: usize> Simd<$type, LANES>\n         where\n@@ -18,20 +19,22 @@ macro_rules! implement {\n             /// * Not be NaN\n             /// * Not be infinite\n             /// * Be representable in the return type, after truncating off its fractional part\n+            ///\n+            /// If these requirements are infeasible or costly, consider using the safe function [cast],\n+            /// which saturates on conversion.\n+            ///\n+            /// [cast]: Simd::cast\n             #[inline]\n-            pub unsafe fn to_int_unchecked(self) -> Simd<$int_type, LANES> {\n+            pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n+            where\n+                $type: FloatToInt<I>,\n+                I: SimdElement,\n+            {\n                 unsafe { intrinsics::simd_cast(self) }\n             }\n-\n-            /// Creates a floating-point vector from an integer vector.  Rounds values that are\n-            /// not exactly representable.\n-            #[inline]\n-            pub fn round_from_int(value: Simd<$int_type, LANES>) -> Self {\n-                unsafe { intrinsics::simd_cast(value) }\n-            }\n         }\n     }\n }\n \n-implement! { f32, i32 }\n-implement! { f64, i64 }\n+implement! { f32 }\n+implement! { f64 }"}, {"sha": "3acf07260e12b058ec3bb1532c24d1d77cfac312", "filename": "library/portable-simd/crates/core_simd/src/select.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -11,6 +11,7 @@ where\n     /// For each lane in the mask, choose the corresponding lane from `true_values` if\n     /// that lane mask is true, and `false_values` if that lane mask is false.\n     ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n@@ -31,6 +32,8 @@ where\n     where\n         U: SimdElement<Mask = T>,\n     {\n+        // Safety: The mask has been cast to a vector of integers,\n+        // and the operands to select between are vectors of the same type and length.\n         unsafe { intrinsics::simd_select(self.to_int(), true_values, false_values) }\n     }\n \n@@ -39,6 +42,7 @@ where\n     /// For each lane in the mask, choose the corresponding lane from `true_values` if\n     /// that lane mask is true, and `false_values` if that lane mask is false.\n     ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::Mask;"}, {"sha": "08b2add11667a77e94444459bb37c06effa67e33", "filename": "library/portable-simd/crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -95,6 +95,7 @@ pub trait Swizzle<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n         LaneCount<INPUT_LANES>: SupportedLaneCount,\n         LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n     {\n+        // Safety: `vector` is a vector, and `INDEX_IMPL` is a const array of u32.\n         unsafe { intrinsics::simd_shuffle(vector, vector, Self::INDEX_IMPL) }\n     }\n }\n@@ -119,6 +120,7 @@ pub trait Swizzle2<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n         LaneCount<INPUT_LANES>: SupportedLaneCount,\n         LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n     {\n+        // Safety: `first` and `second` are vectors, and `INDEX_IMPL` is a const array of u32.\n         unsafe { intrinsics::simd_shuffle(first, second, Self::INDEX_IMPL) }\n     }\n }"}, {"sha": "b36b1a347b226866431060589d157a5d6bfee197", "filename": "library/portable-simd/crates/core_simd/src/to_bytes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fto_bytes.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -8,12 +8,14 @@ macro_rules! impl_to_bytes {\n             /// Return the memory representation of this integer as a byte array in native byte\n             /// order.\n             pub fn to_ne_bytes(self) -> crate::simd::Simd<u8, {{ $size * LANES }}> {\n+                // Safety: transmuting between vectors is safe\n                 unsafe { core::mem::transmute_copy(&self) }\n             }\n \n             /// Create a native endian integer value from its memory representation as a byte array\n             /// in native endianness.\n             pub fn from_ne_bytes(bytes: crate::simd::Simd<u8, {{ $size * LANES }}>) -> Self {\n+                // Safety: transmuting between vectors is safe\n                 unsafe { core::mem::transmute_copy(&bytes) }\n             }\n         }"}, {"sha": "3ccaf54b2a3e0d709f7745b611f64126923231e9", "filename": "library/portable-simd/crates/core_simd/src/vector.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -12,7 +12,79 @@ pub(crate) mod ptr;\n use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n \n-/// A SIMD vector of `LANES` elements of type `T`.\n+/// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n+///\n+/// Two vectors of the same type and length will, by convention, support the operators (+, *, etc.) that `T` does.\n+/// These take the lanes at each index on the left-hand side and right-hand side, perform the operation,\n+/// and return the result in the same lane in a vector of equal size. For a given operator, this is equivalent to zipping\n+/// the two arrays together and mapping the operator over each lane.\n+///\n+/// ```rust\n+/// # #![feature(array_zip, portable_simd)]\n+/// # use core::simd::{Simd};\n+/// let a0: [i32; 4] = [-2, 0, 2, 4];\n+/// let a1 = [10, 9, 8, 7];\n+/// let zm_add = a0.zip(a1).map(|(lhs, rhs)| lhs + rhs);\n+/// let zm_mul = a0.zip(a1).map(|(lhs, rhs)| lhs * rhs);\n+///\n+/// // `Simd<T, N>` implements `From<[T; N]>\n+/// let (v0, v1) = (Simd::from(a0), Simd::from(a1));\n+/// // Which means arrays implement `Into<Simd<T, N>>`.\n+/// assert_eq!(v0 + v1, zm_add.into());\n+/// assert_eq!(v0 * v1, zm_mul.into());\n+/// ```\n+///\n+/// `Simd` with integers has the quirk that these operations are also inherently wrapping, as if `T` was [`Wrapping<T>`].\n+/// Thus, `Simd` does not implement `wrapping_add`, because that is the default behavior.\n+/// This means there is no warning on overflows, even in \"debug\" builds.\n+/// For most applications where `Simd` is appropriate, it is \"not a bug\" to wrap,\n+/// and even \"debug builds\" are unlikely to tolerate the loss of performance.\n+/// You may want to consider using explicitly checked arithmetic if such is required.\n+/// Division by zero still causes a panic, so you may want to consider using floating point numbers if that is unacceptable.\n+///\n+/// [`Wrapping<T>`]: core::num::Wrapping\n+///\n+/// # Layout\n+/// `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), but with a greater alignment.\n+/// `[T; N]` is aligned to `T`, but `Simd<T, N>` will have an alignment based on both `T` and `N`.\n+/// It is thus sound to [`transmute`] `Simd<T, N>` to `[T; N]`, and will typically optimize to zero cost,\n+/// but the reverse transmutation is more likely to require a copy the compiler cannot simply elide.\n+///\n+/// # ABI \"Features\"\n+/// Due to Rust's safety guarantees, `Simd<T, N>` is currently passed to and from functions via memory, not SIMD registers,\n+/// except as an optimization. `#[inline]` hints are recommended on functions that accept `Simd<T, N>` or return it.\n+/// The need for this may be corrected in the future.\n+///\n+/// # Safe SIMD with Unsafe Rust\n+///\n+/// Operations with `Simd` are typically safe, but there are many reasons to want to combine SIMD with `unsafe` code.\n+/// Care must be taken to respect differences between `Simd` and other types it may be transformed into or derived from.\n+/// In particular, the layout of `Simd<T, N>` may be similar to `[T; N]`, and may allow some transmutations,\n+/// but references to `[T; N]` are not interchangeable with those to `Simd<T, N>`.\n+/// Thus, when using `unsafe` Rust to read and write `Simd<T, N>` through [raw pointers], it is a good idea to first try with\n+/// [`read_unaligned`] and [`write_unaligned`]. This is because:\n+/// - [`read`] and [`write`] require full alignment (in this case, `Simd<T, N>`'s alignment)\n+/// - the likely source for reading or destination for writing `Simd<T, N>` is [`[T]`](slice) and similar types, aligned to `T`\n+/// - combining these actions would violate the `unsafe` contract and explode the program into a puff of **undefined behavior**\n+/// - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned if it sees the optimization\n+/// - most contemporary processors suffer no performance penalty for \"unaligned\" reads and writes that are aligned at runtime\n+///\n+/// By imposing less obligations, unaligned functions are less likely to make the program unsound,\n+/// and may be just as fast as stricter alternatives.\n+/// When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for converting `[T]` to `[Simd<T, N>]`,\n+/// and allows soundly operating on an aligned SIMD body, but it may cost more time when handling the scalar head and tail.\n+/// If these are not sufficient, then it is most ideal to design data structures to be already aligned\n+/// to the `Simd<T, N>` you wish to use before using `unsafe` Rust to read or write.\n+/// More conventional ways to compensate for these facts, like materializing `Simd` to or from an array first,\n+/// are handled by safe methods like [`Simd::from_array`] and [`Simd::from_slice`].\n+///\n+/// [`transmute`]: core::mem::transmute\n+/// [raw pointers]: pointer\n+/// [`read_unaligned`]: pointer::read_unaligned\n+/// [`write_unaligned`]: pointer::write_unaligned\n+/// [`read`]: pointer::read\n+/// [`write`]: pointer::write\n+/// [as_simd]: slice::as_simd\n #[repr(simd)]\n pub struct Simd<T, const LANES: usize>([T; LANES])\n where\n@@ -98,6 +170,7 @@ where\n     #[must_use]\n     #[inline]\n     pub fn cast<U: SimdElement>(self) -> Simd<U, LANES> {\n+        // Safety: The input argument is a vector of a known SIMD type.\n         unsafe { intrinsics::simd_as(self) }\n     }\n \n@@ -171,7 +244,7 @@ where\n         or: Self,\n     ) -> Self {\n         let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n-        // SAFETY: We have masked-off out-of-bounds lanes.\n+        // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n     }\n \n@@ -212,7 +285,7 @@ where\n         let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n-        // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n+        // Safety: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n         unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n     }\n \n@@ -264,7 +337,7 @@ where\n         idxs: Simd<usize, LANES>,\n     ) {\n         let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n-        // SAFETY: We have masked-off out-of-bounds lanes.\n+        // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n     }\n \n@@ -303,7 +376,7 @@ where\n         enable: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n     ) {\n-        // SAFETY: This block works with *mut T derived from &mut 'a [T],\n+        // Safety: This block works with *mut T derived from &mut 'a [T],\n         // which means it is delicate in Rust's borrowing model, circa 2021:\n         // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n         // Even though this block is largely safe methods, it must be exactly this way\n@@ -483,7 +556,9 @@ mod sealed {\n use sealed::Sealed;\n \n /// Marker trait for types that may be used as SIMD vector elements.\n-/// SAFETY: This trait, when implemented, asserts the compiler can monomorphize\n+///\n+/// # Safety\n+/// This trait, when implemented, asserts the compiler can monomorphize\n /// `#[repr(simd)]` structs with the marked type as an element.\n /// Strictly, it is valid to impl if the vector will not be miscompiled.\n /// Practically, it is user-unfriendly to impl it if the vector won't compile,"}, {"sha": "417d255c28d63b26db02107d73a650d2566aebf2", "filename": "library/portable-simd/crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -21,6 +21,8 @@ where\n     #[inline]\n     #[must_use]\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        // Safety: converting pointers to usize and vice-versa is safe\n+        // (even if using that pointer is not)\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n@@ -47,6 +49,8 @@ where\n     #[inline]\n     #[must_use]\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        // Safety: converting pointers to usize and vice-versa is safe\n+        // (even if using that pointer is not)\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })"}, {"sha": "9fb70218c954374b71caa1a34e8c76871d48963f", "filename": "library/portable-simd/crates/core_simd/src/vendor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -9,6 +9,8 @@ macro_rules! from_transmute {\n         impl core::convert::From<$from> for $to {\n             #[inline]\n             fn from(value: $from) -> $to {\n+                // Safety: transmuting between vectors is safe, but the caller of this macro\n+                // checks the invariants\n                 unsafe { core::mem::transmute(value) }\n             }\n         }"}, {"sha": "3aec36ca7b7468b89f9a23401c85bbfd7a7b6151", "filename": "library/portable-simd/crates/core_simd/tests/masks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -68,16 +68,16 @@ macro_rules! test_mask_api {\n                 assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n             }\n \n-            #[cfg(feature = \"generic_const_exprs\")]\n             #[test]\n             fn roundtrip_bitmask_conversion() {\n+                use core_simd::ToBitMask;\n                 let values = [\n                     true, false, false, true, false, false, true, false,\n                     true, true, false, false, false, false, false, true,\n                 ];\n                 let mask = core_simd::Mask::<$type, 16>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n-                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n+                assert_eq!(bitmask, 0b1000001101001001);\n                 assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n             }\n         }"}, {"sha": "50f7a4ca170db983187a26dfc251a9aafacb91b0", "filename": "library/portable-simd/crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -210,15 +210,21 @@ macro_rules! impl_signed_tests {\n                     )\n                 }\n \n-            }\n+                fn div_min_may_overflow<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(Scalar::MIN);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    assert_eq!(a / b, a);\n+                }\n \n-            test_helpers::test_lanes_panic! {\n-                fn div_min_overflow_panics<const LANES: usize>() {\n+                fn rem_min_may_overflow<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(Scalar::MIN);\n                     let b = Vector::<LANES>::splat(-1);\n-                    let _ = a / b;\n+                    assert_eq!(a % b, Vector::<LANES>::splat(0));\n                 }\n \n+            }\n+\n+            test_helpers::test_lanes_panic! {\n                 fn div_by_all_zeros_panics<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(42);\n                     let b = Vector::<LANES>::splat(0);\n@@ -232,12 +238,6 @@ macro_rules! impl_signed_tests {\n                     let _ = a / b;\n                 }\n \n-                fn rem_min_overflow_panic<const LANES: usize>() {\n-                    let a = Vector::<LANES>::splat(Scalar::MIN);\n-                    let b = Vector::<LANES>::splat(-1);\n-                    let _ = a % b;\n-                }\n-\n                 fn rem_zero_panic<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(42);\n                     let b = Vector::<LANES>::splat(0);"}, {"sha": "537323292376043cf4794f66d6f982e607c5697d", "filename": "library/portable-simd/crates/core_simd/tests/round.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -53,14 +53,6 @@ macro_rules! float_rounding_test {\n             }\n \n             test_helpers::test_lanes! {\n-                fn from_int<const LANES: usize>() {\n-                    test_helpers::test_unary_elementwise(\n-                        &Vector::<LANES>::round_from_int,\n-                        &|x| x as Scalar,\n-                        &|_| true,\n-                    )\n-                }\n-\n                 fn to_int_unchecked<const LANES: usize>() {\n                     // The maximum integer that can be represented by the equivalently sized float has\n                     // all of the mantissa digits set to 1, pushed up to the MSB.\n@@ -72,11 +64,11 @@ macro_rules! float_rounding_test {\n                     runner.run(\n                         &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n                         |x| {\n-                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked().to_array() };\n+                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked::<IntScalar>().to_array() };\n                             let result_2 = {\n-                                let mut result = [0; LANES];\n+                                let mut result: [IntScalar; LANES] = [0; LANES];\n                                 for (i, o) in x.iter().zip(result.iter_mut()) {\n-                                    *o = unsafe { i.to_int_unchecked() };\n+                                    *o = unsafe { i.to_int_unchecked::<IntScalar>() };\n                                 }\n                                 result\n                             };"}, {"sha": "5de12313784883f774036c52a7011bf64edf3e31", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -407,11 +407,11 @@ impl Socket {\n     }\n \n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n-        net::setsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY, nodelay as c::BYTE)\n+        net::setsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY, nodelay as c::BOOL)\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n-        let raw: c::BYTE = net::getsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY)?;\n+        let raw: c::BOOL = net::getsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY)?;\n         Ok(raw != 0)\n     }\n "}, {"sha": "3b7cdd55a081c3149114346fe835416b832ed5e6", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -58,21 +58,36 @@ cfg_if::cfg_if! {\n // sockaddr and misc bindings\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int, payload: T) -> io::Result<()> {\n+pub fn setsockopt<T>(\n+    sock: &Socket,\n+    level: c_int,\n+    option_name: c_int,\n+    option_value: T,\n+) -> io::Result<()> {\n     unsafe {\n-        let payload = &payload as *const T as *const c_void;\n-        cvt(c::setsockopt(sock.as_raw(), opt, val, payload, mem::size_of::<T>() as c::socklen_t))?;\n+        cvt(c::setsockopt(\n+            sock.as_raw(),\n+            level,\n+            option_name,\n+            &option_value as *const T as *const _,\n+            mem::size_of::<T>() as c::socklen_t,\n+        ))?;\n         Ok(())\n     }\n }\n \n-pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int, val: c_int) -> io::Result<T> {\n+pub fn getsockopt<T: Copy>(sock: &Socket, level: c_int, option_name: c_int) -> io::Result<T> {\n     unsafe {\n-        let mut slot: T = mem::zeroed();\n-        let mut len = mem::size_of::<T>() as c::socklen_t;\n-        cvt(c::getsockopt(sock.as_raw(), opt, val, &mut slot as *mut _ as *mut _, &mut len))?;\n-        assert_eq!(len as usize, mem::size_of::<T>());\n-        Ok(slot)\n+        let mut option_value: T = mem::zeroed();\n+        let mut option_len = mem::size_of::<T>() as c::socklen_t;\n+        cvt(c::getsockopt(\n+            sock.as_raw(),\n+            level,\n+            option_name,\n+            &mut option_value as *mut T as *mut _,\n+            &mut option_len,\n+        ))?;\n+        Ok(option_value)\n     }\n }\n "}, {"sha": "6f4b87750ff858d1c6cba411e1bc64ddfc3b2332", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -101,27 +101,6 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n \n                     cx.generated_synthetics.insert((ty, trait_def_id));\n \n-                    let hir_imp = impl_def_id.as_local()\n-                        .map(|local| cx.tcx.hir().expect_item(local))\n-                        .and_then(|item| if let hir::ItemKind::Impl(i) = &item.kind {\n-                            Some(i)\n-                        } else {\n-                            None\n-                        });\n-\n-                    let items = match hir_imp {\n-                        Some(imp) => imp\n-                            .items\n-                            .iter()\n-                            .map(|ii| cx.tcx.hir().impl_item(ii.id).clean(cx))\n-                            .collect::<Vec<_>>(),\n-                        None => cx.tcx\n-                            .associated_items(impl_def_id)\n-                            .in_definition_order()\n-                            .map(|x| x.clean(cx))\n-                            .collect::<Vec<_>>(),\n-                    };\n-\n                     impls.push(Item {\n                         name: None,\n                         attrs: Default::default(),\n@@ -138,7 +117,11 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             // the post-inference `trait_ref`, as it's more accurate.\n                             trait_: Some(trait_ref.clean(cx)),\n                             for_: ty.clean(cx),\n-                            items,\n+                            items: cx.tcx\n+                                .associated_items(impl_def_id)\n+                                .in_definition_order()\n+                                .map(|x| x.clean(cx))\n+                                .collect::<Vec<_>>(),\n                             polarity: ty::ImplPolarity::Positive,\n                             kind: ImplKind::Blanket(box trait_ref.self_ty().clean(cx)),\n                         }),"}, {"sha": "3ae1df51695b7f1d28b0163e9289b81d83ee3402", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -228,7 +228,7 @@ fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Functi\n     let (generics, decl) = clean::enter_impl_trait(cx, |cx| {\n         // NOTE: generics need to be cleaned before the decl!\n         let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n-        let decl = clean_fn_decl_from_did_and_sig(cx, did, sig);\n+        let decl = clean_fn_decl_from_did_and_sig(cx, Some(did), sig);\n         (generics, decl)\n     });\n     clean::Function {"}, {"sha": "8fad625973fb814f7bf5fe14fc8b38c4a623f4e2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -891,13 +891,20 @@ fn clean_fn_decl_with_args(\n \n fn clean_fn_decl_from_did_and_sig(\n     cx: &mut DocContext<'_>,\n-    did: DefId,\n+    did: Option<DefId>,\n     sig: ty::PolyFnSig<'_>,\n ) -> FnDecl {\n-    let mut names = if did.is_local() { &[] } else { cx.tcx.fn_arg_names(did) }.iter();\n+    let mut names = did.map_or(&[] as &[_], |did| cx.tcx.fn_arg_names(did)).iter();\n+\n+    // We assume all empty tuples are default return type. This theoretically can discard `-> ()`,\n+    // but shouldn't change any code meaning.\n+    let output = match sig.skip_binder().output().clean(cx) {\n+        Type::Tuple(inner) if inner.len() == 0 => DefaultReturn,\n+        ty => Return(ty),\n+    };\n \n     FnDecl {\n-        output: Return(sig.skip_binder().output().clean(cx)),\n+        output,\n         c_variadic: sig.skip_binder().c_variadic,\n         inputs: Arguments {\n             values: sig\n@@ -1031,20 +1038,18 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 }\n             };\n \n-            let what_rustc_thinks =\n+            let mut what_rustc_thinks =\n                 Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx);\n-            let parent_item = cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(self.hir_id()));\n-            if let hir::ItemKind::Impl(impl_) = &parent_item.kind {\n-                if impl_.of_trait.is_some() {\n-                    // Trait impl items always inherit the impl's visibility --\n-                    // we don't want to show `pub`.\n-                    Item { visibility: Inherited, ..what_rustc_thinks }\n-                } else {\n-                    what_rustc_thinks\n-                }\n-            } else {\n-                panic!(\"found impl item with non-impl parent {:?}\", parent_item);\n+\n+            let impl_ref = cx.tcx.parent(local_did).and_then(|did| cx.tcx.impl_trait_ref(did));\n+\n+            // Trait impl items always inherit the impl's visibility --\n+            // we don't want to show `pub`.\n+            if impl_ref.is_some() {\n+                what_rustc_thinks.visibility = Inherited;\n             }\n+\n+            what_rustc_thinks\n         })\n     }\n }\n@@ -1069,7 +1074,7 @@ impl Clean<Item> for ty::AssocItem {\n                     tcx.explicit_predicates_of(self.def_id),\n                 );\n                 let sig = tcx.fn_sig(self.def_id);\n-                let mut decl = clean_fn_decl_from_did_and_sig(cx, self.def_id, sig);\n+                let mut decl = clean_fn_decl_from_did_and_sig(cx, Some(self.def_id), sig);\n \n                 if self.fn_has_self_parameter {\n                     let self_ty = match self.container {\n@@ -1199,7 +1204,18 @@ impl Clean<Item> for ty::AssocItem {\n             }\n         };\n \n-        Item::from_def_id_and_parts(self.def_id, Some(self.name), kind, cx)\n+        let mut what_rustc_thinks =\n+            Item::from_def_id_and_parts(self.def_id, Some(self.name), kind, cx);\n+\n+        let impl_ref = tcx.parent(self.def_id).and_then(|did| tcx.impl_trait_ref(did));\n+\n+        // Trait impl items always inherit the impl's visibility --\n+        // we don't want to show `pub`.\n+        if impl_ref.is_some() {\n+            what_rustc_thinks.visibility = Visibility::Inherited;\n+        }\n+\n+        what_rustc_thinks\n     }\n }\n \n@@ -1478,8 +1494,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 let ty = cx.tcx.lift(*self).expect(\"FnPtr lift failed\");\n                 let sig = ty.fn_sig(cx.tcx);\n-                let def_id = DefId::local(CRATE_DEF_INDEX);\n-                let decl = clean_fn_decl_from_did_and_sig(cx, def_id, sig);\n+                let decl = clean_fn_decl_from_did_and_sig(cx, None, sig);\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n                     generic_params: Vec::new(),"}, {"sha": "b0e295178c8a561224d53ff603c49a5e60e88791", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -71,6 +71,7 @@\n //~^^ WARN this was previously accepted by the compiler\n // see issue-43106-gating-of-rustc_deprecated.rs\n #![must_use]\n+//~^ WARN `#[must_use]` has no effect\n // see issue-43106-gating-of-stable.rs\n // see issue-43106-gating-of-unstable.rs\n // see issue-43106-gating-of-deprecated.rs\n@@ -597,17 +598,17 @@ mod deprecated {\n     #[deprecated] impl super::StructForDeprecated { }\n }\n \n-#[must_use]\n+#[must_use] //~ WARN `#[must_use]` has no effect\n mod must_use {\n-    mod inner { #![must_use] }\n+    mod inner { #![must_use] } //~ WARN `#[must_use]` has no effect\n \n     #[must_use] fn f() { }\n \n     #[must_use] struct S;\n \n-    #[must_use] type T = S;\n+    #[must_use] type T = S; //~ WARN `#[must_use]` has no effect\n \n-    #[must_use] impl S { }\n+    #[must_use] impl S { } //~ WARN `#[must_use]` has no effect\n }\n \n #[windows_subsystem = \"windows\"]"}, {"sha": "2431957e5391dd7a6ee31902bdb83896e09b5097", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs.stderr", "status": "modified", "additions": 188, "deletions": 158, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -29,179 +29,179 @@ LL | #![deny(x5100)]\n    |         ^^^^^\n \n warning: unknown lint: `x5400`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:105:8\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:106:8\n    |\n LL | #[warn(x5400)]\n    |        ^^^^^\n \n warning: unknown lint: `x5400`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:108:25\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:109:25\n    |\n LL |     mod inner { #![warn(x5400)] }\n    |                         ^^^^^\n \n warning: unknown lint: `x5400`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:111:12\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:112:12\n    |\n LL |     #[warn(x5400)] fn f() { }\n    |            ^^^^^\n \n warning: unknown lint: `x5400`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:114:12\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:115:12\n    |\n LL |     #[warn(x5400)] struct S;\n    |            ^^^^^\n \n warning: unknown lint: `x5400`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:117:12\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:118:12\n    |\n LL |     #[warn(x5400)] type T = S;\n    |            ^^^^^\n \n warning: unknown lint: `x5400`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:120:12\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:121:12\n    |\n LL |     #[warn(x5400)] impl S { }\n    |            ^^^^^\n \n warning: unknown lint: `x5300`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:124:9\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:125:9\n    |\n LL | #[allow(x5300)]\n    |         ^^^^^\n \n warning: unknown lint: `x5300`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:127:26\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:128:26\n    |\n LL |     mod inner { #![allow(x5300)] }\n    |                          ^^^^^\n \n warning: unknown lint: `x5300`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:130:13\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:131:13\n    |\n LL |     #[allow(x5300)] fn f() { }\n    |             ^^^^^\n \n warning: unknown lint: `x5300`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:133:13\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:134:13\n    |\n LL |     #[allow(x5300)] struct S;\n    |             ^^^^^\n \n warning: unknown lint: `x5300`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:136:13\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:137:13\n    |\n LL |     #[allow(x5300)] type T = S;\n    |             ^^^^^\n \n warning: unknown lint: `x5300`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:139:13\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:140:13\n    |\n LL |     #[allow(x5300)] impl S { }\n    |             ^^^^^\n \n warning: unknown lint: `x5200`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:143:10\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:144:10\n    |\n LL | #[forbid(x5200)]\n    |          ^^^^^\n \n warning: unknown lint: `x5200`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:146:27\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:147:27\n    |\n LL |     mod inner { #![forbid(x5200)] }\n    |                           ^^^^^\n \n warning: unknown lint: `x5200`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:149:14\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:150:14\n    |\n LL |     #[forbid(x5200)] fn f() { }\n    |              ^^^^^\n \n warning: unknown lint: `x5200`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:152:14\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:153:14\n    |\n LL |     #[forbid(x5200)] struct S;\n    |              ^^^^^\n \n warning: unknown lint: `x5200`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:155:14\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:156:14\n    |\n LL |     #[forbid(x5200)] type T = S;\n    |              ^^^^^\n \n warning: unknown lint: `x5200`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:158:14\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:159:14\n    |\n LL |     #[forbid(x5200)] impl S { }\n    |              ^^^^^\n \n warning: unknown lint: `x5100`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:162:8\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:163:8\n    |\n LL | #[deny(x5100)]\n    |        ^^^^^\n \n warning: unknown lint: `x5100`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:165:25\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:166:25\n    |\n LL |     mod inner { #![deny(x5100)] }\n    |                         ^^^^^\n \n warning: unknown lint: `x5100`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:168:12\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:169:12\n    |\n LL |     #[deny(x5100)] fn f() { }\n    |            ^^^^^\n \n warning: unknown lint: `x5100`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:171:12\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:172:12\n    |\n LL |     #[deny(x5100)] struct S;\n    |            ^^^^^\n \n warning: unknown lint: `x5100`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:174:12\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:175:12\n    |\n LL |     #[deny(x5100)] type T = S;\n    |            ^^^^^\n \n warning: unknown lint: `x5100`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:177:12\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:178:12\n    |\n LL |     #[deny(x5100)] impl S { }\n    |            ^^^^^\n \n warning: `#[macro_escape]` is a deprecated synonym for `#[macro_use]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:400:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:401:17\n    |\n LL |     mod inner { #![macro_escape] }\n    |                 ^^^^^^^^^^^^^^^^\n    |\n    = help: try an outer attribute: `#[macro_use]`\n \n warning: `#[macro_escape]` is a deprecated synonym for `#[macro_use]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:397:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:398:1\n    |\n LL | #[macro_escape]\n    | ^^^^^^^^^^^^^^^\n \n warning: use of deprecated attribute `crate_id`: no longer used.\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:84:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:85:1\n    |\n LL | #![crate_id = \"10\"]\n    | ^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n    = note: `#[warn(deprecated)]` on by default\n \n warning: use of deprecated attribute `no_start`: no longer used.\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:94:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:95:1\n    |\n LL | #![no_start]\n    | ^^^^^^^^^^^^ help: remove this attribute\n \n warning: `#[macro_export]` only has an effect on macro definitions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:198:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:199:1\n    |\n LL | #[macro_export]\n    | ^^^^^^^^^^^^^^^\n@@ -213,13 +213,13 @@ LL | #![warn(unused_attributes, unknown_lints)]\n    |         ^^^^^^^^^^^^^^^^^\n \n warning: `#[automatically_derived]` only has an effect on items\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:266:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:267:1\n    |\n LL | #[automatically_derived]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: attribute should be applied to a free function, impl method or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:284:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:285:1\n    |\n LL |   #[no_mangle]\n    |   ^^^^^^^^^^^^\n@@ -236,31 +236,31 @@ LL | | }\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: `#[should_panic]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:324:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:325:1\n    |\n LL | #[should_panic]\n    | ^^^^^^^^^^^^^^^\n \n warning: `#[ignore]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:342:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:343:1\n    |\n LL | #[ignore]\n    | ^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:377:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:378:1\n    |\n LL | #[reexport_test_harness_main = \"2900\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:417:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:418:1\n    |\n LL | #[no_std]\n    | ^^^^^^^^^\n \n warning: attribute should be applied to a function\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:453:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:454:1\n    |\n LL |   #[cold]\n    |   ^^^^^^^\n@@ -277,7 +277,7 @@ LL | | }\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a foreign function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:482:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:483:1\n    |\n LL |   #[link_name = \"1900\"]\n    |   ^^^^^^^^^^^^^^^^^^^^^\n@@ -294,7 +294,7 @@ LL | | }\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:521:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:522:1\n    |\n LL |   #[link_section = \"1800\"]\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -311,7 +311,7 @@ LL | | }\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to an `extern` block\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:553:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:554:1\n    |\n LL |   #[link()]\n    |   ^^^^^^^^^\n@@ -327,50 +327,56 @@ LL | | }\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n+warning: `#[must_use]` has no effect when applied to a module\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:601:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:613:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:614:1\n    |\n LL | #[windows_subsystem = \"windows\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:634:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:635:1\n    |\n LL | #[crate_name = \"0900\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:653:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:654:1\n    |\n LL | #[crate_type = \"0800\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:672:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:673:1\n    |\n LL | #[feature(x0600)]\n    | ^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:692:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:693:1\n    |\n LL | #[no_main]\n    | ^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:711:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:712:1\n    |\n LL | #[no_builtins]\n    | ^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:730:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:731:1\n    |\n LL | #[recursion_limit=\"0200\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:749:1\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:750:1\n    |\n LL | #[type_length_limit=\"0100\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -425,346 +431,352 @@ LL | #![link_section = \"1800\"]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n+warning: `#[must_use]` has no effect when applied to a module\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:73:1\n+   |\n+LL | #![must_use]\n+   | ^^^^^^^^^^^^\n+\n warning: `#[macro_use]` only has an effect on `extern crate` and modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:185:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:186:5\n    |\n LL |     #[macro_use] fn f() { }\n    |     ^^^^^^^^^^^^\n \n warning: `#[macro_use]` only has an effect on `extern crate` and modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:188:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:189:5\n    |\n LL |     #[macro_use] struct S;\n    |     ^^^^^^^^^^^^\n \n warning: `#[macro_use]` only has an effect on `extern crate` and modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:191:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:192:5\n    |\n LL |     #[macro_use] type T = S;\n    |     ^^^^^^^^^^^^\n \n warning: `#[macro_use]` only has an effect on `extern crate` and modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:194:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:195:5\n    |\n LL |     #[macro_use] impl S { }\n    |     ^^^^^^^^^^^^\n \n warning: `#[macro_export]` only has an effect on macro definitions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:201:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:202:17\n    |\n LL |     mod inner { #![macro_export] }\n    |                 ^^^^^^^^^^^^^^^^\n \n warning: `#[macro_export]` only has an effect on macro definitions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:204:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:205:5\n    |\n LL |     #[macro_export] fn f() { }\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[macro_export]` only has an effect on macro definitions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:207:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:208:5\n    |\n LL |     #[macro_export] struct S;\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[macro_export]` only has an effect on macro definitions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:210:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:211:5\n    |\n LL |     #[macro_export] type T = S;\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[macro_export]` only has an effect on macro definitions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:213:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:214:5\n    |\n LL |     #[macro_export] impl S { }\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[path]` only has an effect on modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:253:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:254:5\n    |\n LL |     #[path = \"3800\"] fn f() { }\n    |     ^^^^^^^^^^^^^^^^\n \n warning: `#[path]` only has an effect on modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:256:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:257:5\n    |\n LL |     #[path = \"3800\"]  struct S;\n    |     ^^^^^^^^^^^^^^^^\n \n warning: `#[path]` only has an effect on modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:259:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:260:5\n    |\n LL |     #[path = \"3800\"] type T = S;\n    |     ^^^^^^^^^^^^^^^^\n \n warning: `#[path]` only has an effect on modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:262:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:263:5\n    |\n LL |     #[path = \"3800\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^\n \n warning: `#[automatically_derived]` only has an effect on items\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:269:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:270:17\n    |\n LL |     mod inner { #![automatically_derived] }\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: `#[automatically_derived]` only has an effect on items\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:272:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:273:5\n    |\n LL |     #[automatically_derived] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: `#[automatically_derived]` only has an effect on items\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:275:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:276:5\n    |\n LL |     #[automatically_derived] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: `#[automatically_derived]` only has an effect on items\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:278:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:279:5\n    |\n LL |     #[automatically_derived] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: attribute should be applied to a free function, impl method or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:289:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:290:17\n    |\n LL |     mod inner { #![no_mangle] }\n    |     ------------^^^^^^^^^^^^^-- not a free function, impl method or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a free function, impl method or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:296:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:297:5\n    |\n LL |     #[no_mangle] struct S;\n    |     ^^^^^^^^^^^^ --------- not a free function, impl method or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a free function, impl method or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:301:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:302:5\n    |\n LL |     #[no_mangle] type T = S;\n    |     ^^^^^^^^^^^^ ----------- not a free function, impl method or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a free function, impl method or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:306:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:307:5\n    |\n LL |     #[no_mangle] impl S { }\n    |     ^^^^^^^^^^^^ ---------- not a free function, impl method or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a free function, impl method or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:312:9\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:313:9\n    |\n LL |         #[no_mangle] fn foo();\n    |         ^^^^^^^^^^^^ --------- not a free function, impl method or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a free function, impl method or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:317:9\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:318:9\n    |\n LL |         #[no_mangle] fn bar() {}\n    |         ^^^^^^^^^^^^ ----------- not a free function, impl method or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: `#[should_panic]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:327:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:328:17\n    |\n LL |     mod inner { #![should_panic] }\n    |                 ^^^^^^^^^^^^^^^^\n \n warning: `#[should_panic]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:332:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:333:5\n    |\n LL |     #[should_panic] struct S;\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[should_panic]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:335:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:336:5\n    |\n LL |     #[should_panic] type T = S;\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[should_panic]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:338:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:339:5\n    |\n LL |     #[should_panic] impl S { }\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[ignore]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:345:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:346:17\n    |\n LL |     mod inner { #![ignore] }\n    |                 ^^^^^^^^^^\n \n warning: `#[ignore]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:350:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:351:5\n    |\n LL |     #[ignore] struct S;\n    |     ^^^^^^^^^\n \n warning: `#[ignore]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:353:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:354:5\n    |\n LL |     #[ignore] type T = S;\n    |     ^^^^^^^^^\n \n warning: `#[ignore]` only has an effect on functions\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:356:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:357:5\n    |\n LL |     #[ignore] impl S { }\n    |     ^^^^^^^^^\n \n warning: `#[no_implicit_prelude]` only has an effect on modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:364:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:365:5\n    |\n LL |     #[no_implicit_prelude] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: `#[no_implicit_prelude]` only has an effect on modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:367:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:368:5\n    |\n LL |     #[no_implicit_prelude] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: `#[no_implicit_prelude]` only has an effect on modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:370:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:371:5\n    |\n LL |     #[no_implicit_prelude] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: `#[no_implicit_prelude]` only has an effect on modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:373:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:374:5\n    |\n LL |     #[no_implicit_prelude] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:380:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:381:17\n    |\n LL |     mod inner { #![reexport_test_harness_main=\"2900\"] }\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:383:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:384:5\n    |\n LL |     #[reexport_test_harness_main = \"2900\"] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:386:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:387:5\n    |\n LL |     #[reexport_test_harness_main = \"2900\"] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:389:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:390:5\n    |\n LL |     #[reexport_test_harness_main = \"2900\"] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:392:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:393:5\n    |\n LL |     #[reexport_test_harness_main = \"2900\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: `#[macro_escape]` only has an effect on `extern crate` and modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:404:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:405:5\n    |\n LL |     #[macro_escape] fn f() { }\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[macro_escape]` only has an effect on `extern crate` and modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:407:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:408:5\n    |\n LL |     #[macro_escape] struct S;\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[macro_escape]` only has an effect on `extern crate` and modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:410:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:411:5\n    |\n LL |     #[macro_escape] type T = S;\n    |     ^^^^^^^^^^^^^^^\n \n warning: `#[macro_escape]` only has an effect on `extern crate` and modules\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:413:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:414:5\n    |\n LL |     #[macro_escape] impl S { }\n    |     ^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:420:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:421:17\n    |\n LL |     mod inner { #![no_std] }\n    |                 ^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:423:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:424:5\n    |\n LL |     #[no_std] fn f() { }\n    |     ^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:426:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:427:5\n    |\n LL |     #[no_std] struct S;\n    |     ^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:429:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:430:5\n    |\n LL |     #[no_std] type T = S;\n    |     ^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:432:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:433:5\n    |\n LL |     #[no_std] impl S { }\n    |     ^^^^^^^^^\n \n warning: attribute should be applied to a function\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:459:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:460:17\n    |\n LL |     mod inner { #![cold] }\n    |     ------------^^^^^^^^-- not a function\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a function\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:466:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:467:5\n    |\n LL |     #[cold] struct S;\n    |     ^^^^^^^ --------- not a function\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a function\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:471:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:472:5\n    |\n LL |     #[cold] type T = S;\n    |     ^^^^^^^ ----------- not a function\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a function\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:476:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:477:5\n    |\n LL |     #[cold] impl S { }\n    |     ^^^^^^^ ---------- not a function\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a foreign function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:488:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:489:5\n    |\n LL |     #[link_name = \"1900\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^\n@@ -774,370 +786,388 @@ LL |     extern \"C\" { }\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n help: try `#[link(name = \"1900\")]` instead\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:488:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:489:5\n    |\n LL |     #[link_name = \"1900\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n warning: attribute should be applied to a foreign function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:495:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:496:17\n    |\n LL |     mod inner { #![link_name=\"1900\"] }\n    |     ------------^^^^^^^^^^^^^^^^^^^^-- not a foreign function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a foreign function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:500:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:501:5\n    |\n LL |     #[link_name = \"1900\"] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^^^^^ ---------- not a foreign function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a foreign function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:505:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:506:5\n    |\n LL |     #[link_name = \"1900\"] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^ --------- not a foreign function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a foreign function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:510:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:511:5\n    |\n LL |     #[link_name = \"1900\"] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^ ----------- not a foreign function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a foreign function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:515:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:516:5\n    |\n LL |     #[link_name = \"1900\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^ ---------- not a foreign function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:527:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:528:17\n    |\n LL |     mod inner { #![link_section=\"1800\"] }\n    |     ------------^^^^^^^^^^^^^^^^^^^^^^^-- not a function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:534:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:535:5\n    |\n LL |     #[link_section = \"1800\"] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ --------- not a function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:539:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:540:5\n    |\n LL |     #[link_section = \"1800\"] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ ----------- not a function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a function or static\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:544:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:545:5\n    |\n LL |     #[link_section = \"1800\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ ---------- not a function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to an `extern` block\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:559:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:560:17\n    |\n LL |     mod inner { #![link()] }\n    |     ------------^^^^^^^^^^-- not an `extern` block\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to an `extern` block\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:564:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:565:5\n    |\n LL |     #[link()] fn f() { }\n    |     ^^^^^^^^^ ---------- not an `extern` block\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to an `extern` block\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:569:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:570:5\n    |\n LL |     #[link()] struct S;\n    |     ^^^^^^^^^ --------- not an `extern` block\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to an `extern` block\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:574:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:575:5\n    |\n LL |     #[link()] type T = S;\n    |     ^^^^^^^^^ ----------- not an `extern` block\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to an `extern` block\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:579:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:580:5\n    |\n LL |     #[link()] impl S { }\n    |     ^^^^^^^^^ ---------- not an `extern` block\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n+warning: `#[must_use]` has no effect when applied to a module\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:603:17\n+   |\n+LL |     mod inner { #![must_use] }\n+   |                 ^^^^^^^^^^^^\n+\n+warning: `#[must_use]` has no effect when applied to a type alias\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:609:5\n+   |\n+LL |     #[must_use] type T = S;\n+   |     ^^^^^^^^^^^\n+\n+warning: `#[must_use]` has no effect when applied to an item\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:611:5\n+   |\n+LL |     #[must_use] impl S { }\n+   |     ^^^^^^^^^^^\n+\n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:616:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:617:17\n    |\n LL |     mod inner { #![windows_subsystem=\"windows\"] }\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:619:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:620:5\n    |\n LL |     #[windows_subsystem = \"windows\"] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:622:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:623:5\n    |\n LL |     #[windows_subsystem = \"windows\"] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:625:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:626:5\n    |\n LL |     #[windows_subsystem = \"windows\"] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:628:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:629:5\n    |\n LL |     #[windows_subsystem = \"windows\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:637:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:638:17\n    |\n LL |     mod inner { #![crate_name=\"0900\"] }\n    |                 ^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:640:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:641:5\n    |\n LL |     #[crate_name = \"0900\"] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:643:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:644:5\n    |\n LL |     #[crate_name = \"0900\"] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:646:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:647:5\n    |\n LL |     #[crate_name = \"0900\"] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:649:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:650:5\n    |\n LL |     #[crate_name = \"0900\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:656:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:657:17\n    |\n LL |     mod inner { #![crate_type=\"0800\"] }\n    |                 ^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:659:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:660:5\n    |\n LL |     #[crate_type = \"0800\"] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:662:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:663:5\n    |\n LL |     #[crate_type = \"0800\"] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:665:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:666:5\n    |\n LL |     #[crate_type = \"0800\"] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:668:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:669:5\n    |\n LL |     #[crate_type = \"0800\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:675:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:676:17\n    |\n LL |     mod inner { #![feature(x0600)] }\n    |                 ^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:678:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:679:5\n    |\n LL |     #[feature(x0600)] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:681:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:682:5\n    |\n LL |     #[feature(x0600)] struct S;\n    |     ^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:684:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:685:5\n    |\n LL |     #[feature(x0600)] type T = S;\n    |     ^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:687:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:688:5\n    |\n LL |     #[feature(x0600)] impl S { }\n    |     ^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:695:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:696:17\n    |\n LL |     mod inner { #![no_main] }\n    |                 ^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:698:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:699:5\n    |\n LL |     #[no_main] fn f() { }\n    |     ^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:701:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:702:5\n    |\n LL |     #[no_main] struct S;\n    |     ^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:704:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:705:5\n    |\n LL |     #[no_main] type T = S;\n    |     ^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:707:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:708:5\n    |\n LL |     #[no_main] impl S { }\n    |     ^^^^^^^^^^\n \n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:714:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:715:17\n    |\n LL |     mod inner { #![no_builtins] }\n    |                 ^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:717:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:718:5\n    |\n LL |     #[no_builtins] fn f() { }\n    |     ^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:720:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:721:5\n    |\n LL |     #[no_builtins] struct S;\n    |     ^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:723:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:724:5\n    |\n LL |     #[no_builtins] type T = S;\n    |     ^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:726:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:727:5\n    |\n LL |     #[no_builtins] impl S { }\n    |     ^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:733:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:734:17\n    |\n LL |     mod inner { #![recursion_limit=\"0200\"] }\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:736:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:737:5\n    |\n LL |     #[recursion_limit=\"0200\"] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:739:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:740:5\n    |\n LL |     #[recursion_limit=\"0200\"] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:742:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:743:5\n    |\n LL |     #[recursion_limit=\"0200\"] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:745:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:746:5\n    |\n LL |     #[recursion_limit=\"0200\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be in the root module\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:752:17\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:753:17\n    |\n LL |     mod inner { #![type_length_limit=\"0100\"] }\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:755:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:756:5\n    |\n LL |     #[type_length_limit=\"0100\"] fn f() { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:758:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:759:5\n    |\n LL |     #[type_length_limit=\"0100\"] struct S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:761:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:762:5\n    |\n LL |     #[type_length_limit=\"0100\"] type T = S;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:764:5\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:765:5\n    |\n LL |     #[type_length_limit=\"0100\"] impl S { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: the feature `rust1` has been stable since 1.0.0 and no longer requires an attribute to enable\n-  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:90:12\n+  --> $DIR/issue-43106-gating-of-builtin-attrs.rs:91:12\n    |\n LL | #![feature(rust1)]\n    |            ^^^^^\n    |\n    = note: `#[warn(stable_features)]` on by default\n \n-warning: 167 warnings emitted\n+warning: 172 warnings emitted\n "}, {"sha": "1c4abb9491e00740c22324828d5de81fd442f9ff", "filename": "src/test/ui/lint/unused/unused_attributes-must_use.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -0,0 +1,125 @@\n+#![allow(dead_code, path_statements)]\n+#![deny(unused_attributes, unused_must_use)]\n+#![feature(asm_experimental_arch, stmt_expr_attributes, trait_alias)]\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+extern crate std as std2;\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+mod test_mod {}\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+use std::arch::global_asm;\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+const CONST: usize = 4;\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+#[no_mangle]\n+static STATIC: usize = 4;\n+\n+#[must_use]\n+struct X;\n+\n+#[must_use]\n+enum Y {\n+    Z,\n+}\n+\n+#[must_use]\n+union U {\n+    unit: (),\n+}\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+impl U {\n+    #[must_use]\n+    fn method() -> i32 {\n+        4\n+    }\n+}\n+\n+#[must_use]\n+#[no_mangle]\n+fn foo() -> i64 {\n+    4\n+}\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+extern \"Rust\" {\n+    #[link_name = \"STATIC\"]\n+    #[must_use] //~ ERROR `#[must_use]` has no effect\n+    static FOREIGN_STATIC: usize;\n+\n+    #[link_name = \"foo\"]\n+    #[must_use]\n+    fn foreign_foo() -> i64;\n+}\n+\n+#[must_use] //~ ERROR unused attribute\n+global_asm!(\"\");\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+type UseMe = ();\n+\n+fn qux<#[must_use] T>(_: T) {} //~ ERROR `#[must_use]` has no effect\n+\n+#[must_use]\n+trait Use {\n+    #[must_use] //~ ERROR `#[must_use]` has no effect\n+    const ASSOC_CONST: usize = 4;\n+    #[must_use] //~ ERROR `#[must_use]` has no effect\n+    type AssocTy;\n+\n+    #[must_use]\n+    fn get_four(&self) -> usize {\n+        4\n+    }\n+}\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+impl Use for () {\n+    type AssocTy = ();\n+}\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+trait Alias = Use;\n+\n+#[must_use] //~ ERROR `#[must_use]` has no effect\n+macro_rules! cool_macro {\n+    () => {\n+        4\n+    };\n+}\n+\n+fn main() {\n+    #[must_use] //~ ERROR `#[must_use]` has no effect\n+    let x = || {};\n+    x();\n+\n+    let x = #[must_use] //~ ERROR `#[must_use]` has no effect\n+    || {};\n+    x();\n+\n+    X; //~ ERROR that must be used\n+    Y::Z; //~ ERROR that must be used\n+    U { unit: () }; //~ ERROR that must be used\n+    U::method(); //~ ERROR that must be used\n+    foo(); //~ ERROR that must be used\n+\n+    unsafe {\n+        foreign_foo(); //~ ERROR that must be used\n+    };\n+\n+    CONST;\n+    STATIC;\n+    unsafe { FOREIGN_STATIC };\n+    cool_macro!();\n+    qux(4);\n+    ().get_four(); //~ ERROR that must be used\n+\n+    match Some(4) {\n+        #[must_use] //~ ERROR `#[must_use]` has no effect\n+        Some(res) => res,\n+        None => 0,\n+    };\n+}"}, {"sha": "27269580e52e2bd479cdf33c0d267eb60b165a64", "filename": "src/test/ui/lint/unused/unused_attributes-must_use.stderr", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -0,0 +1,175 @@\n+error: unused attribute `must_use`\n+  --> $DIR/unused_attributes-must_use.rs:58:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_attributes-must_use.rs:2:9\n+   |\n+LL | #![deny(unused_attributes, unused_must_use)]\n+   |         ^^^^^^^^^^^^^^^^^\n+note: the built-in attribute `must_use` will be ignored, since it's applied to the macro invocation `global_asm`\n+  --> $DIR/unused_attributes-must_use.rs:59:1\n+   |\n+LL | global_asm!(\"\");\n+   | ^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to an extern crate\n+  --> $DIR/unused_attributes-must_use.rs:5:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a module\n+  --> $DIR/unused_attributes-must_use.rs:8:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a use\n+  --> $DIR/unused_attributes-must_use.rs:11:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a constant item\n+  --> $DIR/unused_attributes-must_use.rs:14:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a static item\n+  --> $DIR/unused_attributes-must_use.rs:16:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to an item\n+  --> $DIR/unused_attributes-must_use.rs:33:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a foreign module\n+  --> $DIR/unused_attributes-must_use.rs:47:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a type alias\n+  --> $DIR/unused_attributes-must_use.rs:61:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a type parameter\n+  --> $DIR/unused_attributes-must_use.rs:64:8\n+   |\n+LL | fn qux<#[must_use] T>(_: T) {}\n+   |        ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to an item\n+  --> $DIR/unused_attributes-must_use.rs:79:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a trait alias\n+  --> $DIR/unused_attributes-must_use.rs:84:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a macro def\n+  --> $DIR/unused_attributes-must_use.rs:87:1\n+   |\n+LL | #[must_use]\n+   | ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a statement\n+  --> $DIR/unused_attributes-must_use.rs:95:5\n+   |\n+LL |     #[must_use]\n+   |     ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a closure\n+  --> $DIR/unused_attributes-must_use.rs:99:13\n+   |\n+LL |     let x = #[must_use]\n+   |             ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to an match arm\n+  --> $DIR/unused_attributes-must_use.rs:121:9\n+   |\n+LL |         #[must_use]\n+   |         ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to an associated const\n+  --> $DIR/unused_attributes-must_use.rs:68:5\n+   |\n+LL |     #[must_use]\n+   |     ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to an associated type\n+  --> $DIR/unused_attributes-must_use.rs:70:5\n+   |\n+LL |     #[must_use]\n+   |     ^^^^^^^^^^^\n+\n+error: `#[must_use]` has no effect when applied to a foreign static item\n+  --> $DIR/unused_attributes-must_use.rs:50:5\n+   |\n+LL |     #[must_use]\n+   |     ^^^^^^^^^^^\n+\n+error: unused `X` that must be used\n+  --> $DIR/unused_attributes-must_use.rs:103:5\n+   |\n+LL |     X;\n+   |     ^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_attributes-must_use.rs:2:28\n+   |\n+LL | #![deny(unused_attributes, unused_must_use)]\n+   |                            ^^^^^^^^^^^^^^^\n+\n+error: unused `Y` that must be used\n+  --> $DIR/unused_attributes-must_use.rs:104:5\n+   |\n+LL |     Y::Z;\n+   |     ^^^^^\n+\n+error: unused `U` that must be used\n+  --> $DIR/unused_attributes-must_use.rs:105:5\n+   |\n+LL |     U { unit: () };\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: unused return value of `U::method` that must be used\n+  --> $DIR/unused_attributes-must_use.rs:106:5\n+   |\n+LL |     U::method();\n+   |     ^^^^^^^^^^^^\n+\n+error: unused return value of `foo` that must be used\n+  --> $DIR/unused_attributes-must_use.rs:107:5\n+   |\n+LL |     foo();\n+   |     ^^^^^^\n+\n+error: unused return value of `foreign_foo` that must be used\n+  --> $DIR/unused_attributes-must_use.rs:110:9\n+   |\n+LL |         foreign_foo();\n+   |         ^^^^^^^^^^^^^^\n+\n+error: unused return value of `Use::get_four` that must be used\n+  --> $DIR/unused_attributes-must_use.rs:118:5\n+   |\n+LL |     ().get_four();\n+   |     ^^^^^^^^^^^^^^\n+\n+error: aborting due to 26 previous errors\n+"}, {"sha": "b7516babc1330ad252556b890a496b6e48cd1bcb", "filename": "src/test/ui/parser/expr-as-stmt-2.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -36,6 +36,11 @@ LL | /     &&\n LL | |     if let Some(y) = a { true } else { false }\n    | |______________________________________________^ expected `bool`, found `&&bool`\n    |\n+help: consider removing the `&&`\n+   |\n+LL -     &&\n+LL +     if let Some(y) = a { true } else { false }\n+   | \n help: parentheses are required to parse this as an expression\n    |\n LL |     (if let Some(x) = a { true } else { false })"}, {"sha": "e63da52c8fe1d6480054a2c76b68850e26db302e", "filename": "src/test/ui/parser/expr-as-stmt.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -170,6 +170,11 @@ LL | fn revenge_from_mars() -> bool {\n LL |     { true } && { true }\n    |              ^^^^^^^^^^^ expected `bool`, found `&&bool`\n    |\n+help: consider removing the `&&`\n+   |\n+LL -     { true } && { true }\n+LL +     { true } { true }\n+   | \n help: parentheses are required to parse this as an expression\n    |\n LL |     ({ true }) && { true }"}, {"sha": "897de54a7bf8cde5dbbc205c5026e8d3699200f1", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -676,6 +676,12 @@ error[E0308]: mismatched types\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |                                            ^^^^^^^ expected `bool`, found `&&bool`\n+   |\n+help: consider removing the `&&`\n+   |\n+LL -     if let Range { start: true, end } = t..&&false {}\n+LL +     if let Range { start: true, end } = t..false {}\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:83:8\n@@ -866,6 +872,12 @@ error[E0308]: mismatched types\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |                                               ^^^^^^^ expected `bool`, found `&&bool`\n+   |\n+help: consider removing the `&&`\n+   |\n+LL -     while let Range { start: true, end } = t..&&false {}\n+LL +     while let Range { start: true, end } = t..false {}\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:147:11"}, {"sha": "3dc4771fefb0727d3b2c05938321a696c74a0617", "filename": "src/test/ui/typeck/deref-multi.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.rs?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -0,0 +1,26 @@\n+fn a(x: &&i32) -> i32 {\n+    x\n+    //~^ ERROR mismatched types\n+}\n+\n+fn a2(x: &&&&&i32) -> i32 {\n+    x\n+    //~^ ERROR mismatched types\n+}\n+\n+fn b(x: &i32) -> i32 {\n+    &x\n+    //~^ ERROR mismatched types\n+}\n+\n+fn c(x: Box<i32>) -> i32 {\n+    &x\n+    //~^ ERROR mismatched types\n+}\n+\n+fn d(x: std::sync::Mutex<&i32>) -> i32 {\n+    x.lock().unwrap()\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "bd6575c73d244f749380af0abe7be33553536aa5", "filename": "src/test/ui/typeck/deref-multi.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6343edfa11c80ffed02de7e059178d4c1637ecdb/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fderef-multi.stderr?ref=6343edfa11c80ffed02de7e059178d4c1637ecdb", "patch": "@@ -0,0 +1,72 @@\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:2:5\n+   |\n+LL | fn a(x: &&i32) -> i32 {\n+   |                   --- expected `i32` because of return type\n+LL |     x\n+   |     ^ expected `i32`, found `&&i32`\n+   |\n+help: consider dereferencing the borrow\n+   |\n+LL |     **x\n+   |     ++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:7:5\n+   |\n+LL | fn a2(x: &&&&&i32) -> i32 {\n+   |                       --- expected `i32` because of return type\n+LL |     x\n+   |     ^ expected `i32`, found `&&&&&i32`\n+   |\n+help: consider dereferencing the borrow\n+   |\n+LL |     *****x\n+   |     +++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:12:5\n+   |\n+LL | fn b(x: &i32) -> i32 {\n+   |                  --- expected `i32` because of return type\n+LL |     &x\n+   |     ^^ expected `i32`, found `&&i32`\n+   |\n+help: consider removing the `&` and dereferencing the borrow instead\n+   |\n+LL |     *x\n+   |     ~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:17:5\n+   |\n+LL | fn c(x: Box<i32>) -> i32 {\n+   |                      --- expected `i32` because of return type\n+LL |     &x\n+   |     ^^ expected `i32`, found `&Box<i32>`\n+   |\n+   = note:   expected type `i32`\n+           found reference `&Box<i32>`\n+help: consider removing the `&` and dereferencing the borrow instead\n+   |\n+LL |     *x\n+   |     ~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-multi.rs:22:5\n+   |\n+LL | fn d(x: std::sync::Mutex<&i32>) -> i32 {\n+   |                                    --- expected `i32` because of return type\n+LL |     x.lock().unwrap()\n+   |     ^^^^^^^^^^^^^^^^^ expected `i32`, found struct `MutexGuard`\n+   |\n+   = note: expected type `i32`\n+            found struct `MutexGuard<'_, &i32>`\n+help: consider dereferencing the type\n+   |\n+LL |     **x.lock().unwrap()\n+   |     ++\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}