{"sha": "0c74911f87c12f0680e21e49a8f9c0c85affac78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNzQ5MTFmODdjMTJmMDY4MGUyMWU0OWE4ZjljMGM4NWFmZmFjNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-05T07:51:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-05T07:51:48Z"}, "message": "auto merge of #14568 : erickt/rust/slice-update, r=alexcrichton\n\nThis PR adds two features to make it possible to transform an `Iterator<u8>` into a `Reader`. The first patch adds a method to mutable slices that allows it to be updated with an `Iterator<T>` without paying for the bounds cost. The second adds a Iterator adaptor, `IterReader`, to provide that `Reader` interface.\r\n\r\nI had two questions. First, are these named the right things? Second, should `IterReader` instead wrap an `Iterator<Result<u8, E>>`? This would allow you to `IterReader::new(rdr.bytes())`, which could be useful if you want to apply some iterator transformations on a reader while still exporting the Reader interface, but I'd expect there'd be a lot of overhead annotating each byte with an error result.", "tree": {"sha": "4589ae45e62f8e981e35c500f1c842225343b3e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4589ae45e62f8e981e35c500f1c842225343b3e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c74911f87c12f0680e21e49a8f9c0c85affac78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c74911f87c12f0680e21e49a8f9c0c85affac78", "html_url": "https://github.com/rust-lang/rust/commit/0c74911f87c12f0680e21e49a8f9c0c85affac78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c74911f87c12f0680e21e49a8f9c0c85affac78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "073c8f10fc40b07596fd1018a2002db8e6d5222a", "url": "https://api.github.com/repos/rust-lang/rust/commits/073c8f10fc40b07596fd1018a2002db8e6d5222a", "html_url": "https://github.com/rust-lang/rust/commit/073c8f10fc40b07596fd1018a2002db8e6d5222a"}, {"sha": "30a8bcbe3df484f7fa9f2523f429490c97af0382", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a8bcbe3df484f7fa9f2523f429490c97af0382", "html_url": "https://github.com/rust-lang/rust/commit/30a8bcbe3df484f7fa9f2523f429490c97af0382"}], "stats": {"total": 49, "additions": 49, "deletions": 0}, "files": [{"sha": "59c42f111d0faed566ec0bb5b9c85b0f9a423565", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0c74911f87c12f0680e21e49a8f9c0c85affac78/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c74911f87c12f0680e21e49a8f9c0c85affac78/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=0c74911f87c12f0680e21e49a8f9c0c85affac78", "patch": "@@ -229,6 +229,36 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n     }\n }\n \n+/// A `Reader` which converts an `Iterator<u8>` into a `Reader`.\n+pub struct IterReader<T> {\n+    iter: T,\n+}\n+\n+impl<T: Iterator<u8>> IterReader<T> {\n+    /// Create a new `IterReader` which will read from the specified `Iterator`.\n+    pub fn new(iter: T) -> IterReader<T> {\n+        IterReader {\n+            iter: iter,\n+        }\n+    }\n+}\n+\n+impl<T: Iterator<u8>> Reader for IterReader<T> {\n+    #[inline]\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        let mut len = 0;\n+        for (slot, elt) in buf.mut_iter().zip(self.iter.by_ref()) {\n+            *slot = elt;\n+            len += 1;\n+        }\n+        if len == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else {\n+            Ok(len)\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use io::{MemReader, MemWriter, BufReader};\n@@ -366,4 +396,23 @@ mod test {\n             assert_eq!(r.read_line(), Ok(\"23456789\\n\".to_str()));\n         }\n     }\n+\n+    #[test]\n+    fn test_iter_reader() {\n+        let mut r = IterReader::new(range(0u8, 8));\n+        let mut buf = [0, 0, 0];\n+        let len = r.read(buf).unwrap();\n+        assert_eq!(len, 3);\n+        assert!(buf == [0, 1, 2]);\n+\n+        let len = r.read(buf).unwrap();\n+        assert_eq!(len, 3);\n+        assert!(buf == [3, 4, 5]);\n+\n+        let len = r.read(buf).unwrap();\n+        assert_eq!(len, 2);\n+        assert!(buf == [6, 7, 5]);\n+\n+        assert_eq!(r.read(buf).unwrap_err().kind, io::EndOfFile);\n+    }\n }"}]}