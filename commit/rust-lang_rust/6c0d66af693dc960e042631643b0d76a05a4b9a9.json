{"sha": "6c0d66af693dc960e042631643b0d76a05a4b9a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMGQ2NmFmNjkzZGM5NjBlMDQyNjMxNjQzYjBkNzZhMDVhNGI5YTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-17T10:20:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-17T10:20:13Z"}, "message": "Auto merge of #35236 - nrc:rustdoc-redirects, r=@alexcrichton\n\nrustdoc: redirect URLs\n\ncc #35020 which does this properly\n\nr? @alexcrichton", "tree": {"sha": "278bdc5c2947b3dd4ae6670056741aa653a5c716", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/278bdc5c2947b3dd4ae6670056741aa653a5c716"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c0d66af693dc960e042631643b0d76a05a4b9a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c0d66af693dc960e042631643b0d76a05a4b9a9", "html_url": "https://github.com/rust-lang/rust/commit/6c0d66af693dc960e042631643b0d76a05a4b9a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c0d66af693dc960e042631643b0d76a05a4b9a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6d05904697d89099b55da3331155392f1db9c00", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d05904697d89099b55da3331155392f1db9c00", "html_url": "https://github.com/rust-lang/rust/commit/d6d05904697d89099b55da3331155392f1db9c00"}, {"sha": "879637f7b000c34f1c2aa6aa48d7c5bedcb55e0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/879637f7b000c34f1c2aa6aa48d7c5bedcb55e0b", "html_url": "https://github.com/rust-lang/rust/commit/879637f7b000c34f1c2aa6aa48d7c5bedcb55e0b"}], "stats": {"total": 406, "additions": 270, "deletions": 136}, "files": [{"sha": "f8b852074dd2b1a3180107e1c8523de9cb7eb6db", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -326,7 +326,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n             url.push_str(\"/index.html\");\n         }\n         _ => {\n-            url.push_str(shortty.to_static_str());\n+            url.push_str(shortty.css_class());\n             url.push_str(\".\");\n             url.push_str(fqp.last().unwrap());\n             url.push_str(\".html\");"}, {"sha": "6b462a76f04ed4a7dc03a31622b1ea02cf0d68eb", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -42,6 +42,14 @@ pub enum ItemType {\n     AssociatedConst = 18,\n }\n \n+\n+#[derive(Copy, Eq, PartialEq, Clone)]\n+pub enum NameSpace {\n+    Type,\n+    Value,\n+    Macro,\n+}\n+\n impl ItemType {\n     pub fn from_item(item: &clean::Item) -> ItemType {\n         let inner = match item.inner {\n@@ -90,7 +98,7 @@ impl ItemType {\n         }\n     }\n \n-    pub fn to_static_str(&self) -> &'static str {\n+    pub fn css_class(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\",\n             ItemType::ExternCrate     => \"externcrate\",\n@@ -113,9 +121,55 @@ impl ItemType {\n             ItemType::AssociatedConst => \"associatedconstant\",\n         }\n     }\n+\n+    pub fn name_space(&self) -> NameSpace {\n+        match *self {\n+            ItemType::Struct |\n+            ItemType::Enum |\n+            ItemType::Module |\n+            ItemType::Typedef |\n+            ItemType::Trait |\n+            ItemType::Primitive |\n+            ItemType::AssociatedType => NameSpace::Type,\n+\n+            ItemType::ExternCrate |\n+            ItemType::Import |\n+            ItemType::Function |\n+            ItemType::Static |\n+            ItemType::Impl |\n+            ItemType::TyMethod |\n+            ItemType::Method |\n+            ItemType::StructField |\n+            ItemType::Variant |\n+            ItemType::Constant |\n+            ItemType::AssociatedConst => NameSpace::Value,\n+\n+            ItemType::Macro => NameSpace::Macro,\n+        }\n+    }\n }\n \n impl fmt::Display for ItemType {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.css_class().fmt(f)\n+    }\n+}\n+\n+pub const NAMESPACE_TYPE: &'static str = \"t\";\n+pub const NAMESPACE_VALUE: &'static str = \"v\";\n+pub const NAMESPACE_MACRO: &'static str = \"m\";\n+\n+impl NameSpace {\n+    pub fn to_static_str(&self) -> &'static str {\n+        match *self {\n+            NameSpace::Type => NAMESPACE_TYPE,\n+            NameSpace::Value => NAMESPACE_VALUE,\n+            NameSpace::Macro => NAMESPACE_MACRO,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for NameSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.to_static_str().fmt(f)\n     }"}, {"sha": "151e138efefbf0a3a09595d0c4fa13f9441fb6a8", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -24,7 +24,7 @@ pub struct Layout {\n \n pub struct Page<'a> {\n     pub title: &'a str,\n-    pub ty: &'a str,\n+    pub css_class: &'a str,\n     pub root_path: &'a str,\n     pub description: &'a str,\n     pub keywords: &'a str,\n@@ -80,7 +80,7 @@ r##\"<!DOCTYPE html>\n         </form>\n     </nav>\n \n-    <section id='main' class=\"content {ty}\">{content}</section>\n+    <section id='main' class=\"content {css_class}\">{content}</section>\n     <section id='search' class=\"content hidden\"></section>\n \n     <section class=\"footer\"></section>\n@@ -152,7 +152,7 @@ r##\"<!DOCTYPE html>\n     },\n     content   = *t,\n     root_path = page.root_path,\n-    ty        = page.ty,\n+    css_class = page.css_class,\n     logo      = if layout.logo.is_empty() {\n         \"\".to_string()\n     } else {"}, {"sha": "d654429146d83738d9a39888cbe785f0592c84d0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 185, "deletions": 129, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -41,7 +41,7 @@ use std::collections::{BTreeMap, HashMap, HashSet};\n use std::default::Default;\n use std::error;\n use std::fmt::{self, Display, Formatter};\n-use std::fs::{self, File};\n+use std::fs::{self, File, OpenOptions};\n use std::io::prelude::*;\n use std::io::{self, BufWriter, BufReader};\n use std::iter::repeat;\n@@ -587,7 +587,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for &(did, ref item) in orphan_methods {\n         if let Some(&(ref fqp, _)) = paths.get(&did) {\n             search_index.push(IndexItem {\n-                ty: shortty(item),\n+                ty: item_type(item),\n                 name: item.name.clone().unwrap(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n                 desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -714,10 +714,10 @@ fn write_shared(cx: &Context,\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n                 if !line.starts_with(key) {\n-                    continue\n+                    continue;\n                 }\n                 if line.starts_with(&format!(r#\"{}[\"{}\"]\"#, key, krate)) {\n-                    continue\n+                    continue;\n                 }\n                 ret.push(line.to_string());\n             }\n@@ -761,7 +761,7 @@ fn write_shared(cx: &Context,\n             try_err!(mkdir(&mydst), &mydst);\n         }\n         mydst.push(&format!(\"{}.{}.js\",\n-                            remote_item_type.to_static_str(),\n+                            remote_item_type.css_class(),\n                             remote_path[remote_path.len() - 1]));\n         let all_implementors = try_err!(collect(&mydst, &krate.name,\n                                                 \"implementors\"),\n@@ -832,7 +832,7 @@ fn mkdir(path: &Path) -> io::Result<()> {\n }\n \n /// Returns a documentation-level item type from the item.\n-fn shortty(item: &clean::Item) -> ItemType {\n+fn item_type(item: &clean::Item) -> ItemType {\n     ItemType::from_item(item)\n }\n \n@@ -952,7 +952,7 @@ impl<'a> SourceCollector<'a> {\n         let mut fname = p.file_name().expect(\"source has no filename\")\n                          .to_os_string();\n         fname.push(\".html\");\n-        cur.push(&fname[..]);\n+        cur.push(&fname);\n         href.push_str(&fname.to_string_lossy());\n \n         let mut w = BufWriter::new(File::create(&cur)?);\n@@ -961,7 +961,7 @@ impl<'a> SourceCollector<'a> {\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n         let page = layout::Page {\n             title: &title,\n-            ty: \"source\",\n+            css_class: \"source\",\n             root_path: &root_path,\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n@@ -1080,7 +1080,7 @@ impl DocFolder for Cache {\n                     // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n                         self.search_index.push(IndexItem {\n-                            ty: shortty(&item),\n+                            ty: item_type(&item),\n                             name: s.to_string(),\n                             path: path.join(\"::\").to_string(),\n                             desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -1126,7 +1126,7 @@ impl DocFolder for Cache {\n                     self.access_levels.is_public(item.def_id)\n                 {\n                     self.paths.insert(item.def_id,\n-                                      (self.stack.clone(), shortty(&item)));\n+                                      (self.stack.clone(), item_type(&item)));\n                 }\n             }\n             // link variants to their parent enum because pages aren't emitted\n@@ -1139,7 +1139,7 @@ impl DocFolder for Cache {\n \n             clean::PrimitiveItem(..) if item.visibility.is_some() => {\n                 self.paths.insert(item.def_id, (self.stack.clone(),\n-                                                shortty(&item)));\n+                                                item_type(&item)));\n             }\n \n             _ => {}\n@@ -1283,74 +1283,77 @@ impl Context {\n         Ok(())\n     }\n \n-    /// Non-parallelized version of rendering an item. This will take the input\n-    /// item, render its contents, and then invoke the specified closure with\n-    /// all sub-items which need to be rendered.\n-    ///\n-    /// The rendering driver uses this closure to queue up more work.\n-    fn item<F>(&mut self, item: clean::Item, mut f: F) -> Result<(), Error> where\n-        F: FnMut(&mut Context, clean::Item),\n-    {\n-        fn render(writer: &mut io::Write, cx: &Context, it: &clean::Item,\n-                  pushname: bool) -> io::Result<()> {\n-            // A little unfortunate that this is done like this, but it sure\n-            // does make formatting *a lot* nicer.\n-            CURRENT_LOCATION_KEY.with(|slot| {\n-                *slot.borrow_mut() = cx.current.clone();\n-            });\n+    fn render_item(&self,\n+                   writer: &mut io::Write,\n+                   it: &clean::Item,\n+                   pushname: bool)\n+                   -> io::Result<()> {\n+        // A little unfortunate that this is done like this, but it sure\n+        // does make formatting *a lot* nicer.\n+        CURRENT_LOCATION_KEY.with(|slot| {\n+            *slot.borrow_mut() = self.current.clone();\n+        });\n \n-            let mut title = if it.is_primitive() {\n-                // No need to include the namespace for primitive types\n-                String::new()\n-            } else {\n-                cx.current.join(\"::\")\n-            };\n-            if pushname {\n-                if !title.is_empty() {\n-                    title.push_str(\"::\");\n-                }\n-                title.push_str(it.name.as_ref().unwrap());\n+        let mut title = if it.is_primitive() {\n+            // No need to include the namespace for primitive types\n+            String::new()\n+        } else {\n+            self.current.join(\"::\")\n+        };\n+        if pushname {\n+            if !title.is_empty() {\n+                title.push_str(\"::\");\n             }\n-            title.push_str(\" - Rust\");\n-            let tyname = shortty(it).to_static_str();\n-            let desc = if it.is_crate() {\n-                format!(\"API documentation for the Rust `{}` crate.\",\n-                        cx.shared.layout.krate)\n-            } else {\n-                format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                        it.name.as_ref().unwrap(), tyname, cx.shared.layout.krate)\n-            };\n-            let keywords = make_item_keywords(it);\n-            let page = layout::Page {\n-                ty: tyname,\n-                root_path: &cx.root_path,\n-                title: &title,\n-                description: &desc,\n-                keywords: &keywords,\n-            };\n+            title.push_str(it.name.as_ref().unwrap());\n+        }\n+        title.push_str(\" - Rust\");\n+        let tyname = item_type(it).css_class();\n+        let desc = if it.is_crate() {\n+            format!(\"API documentation for the Rust `{}` crate.\",\n+                    self.shared.layout.krate)\n+        } else {\n+            format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n+                    it.name.as_ref().unwrap(), tyname, self.shared.layout.krate)\n+        };\n+        let keywords = make_item_keywords(it);\n+        let page = layout::Page {\n+            css_class: tyname,\n+            root_path: &self.root_path,\n+            title: &title,\n+            description: &desc,\n+            keywords: &keywords,\n+        };\n \n-            reset_ids(true);\n+        reset_ids(true);\n \n-            if !cx.render_redirect_pages {\n-                layout::render(writer, &cx.shared.layout, &page,\n-                               &Sidebar{ cx: cx, item: it },\n-                               &Item{ cx: cx, item: it },\n-                               cx.shared.css_file_extension.is_some())?;\n-            } else {\n-                let mut url = repeat(\"../\").take(cx.current.len())\n-                                           .collect::<String>();\n-                if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n-                    for name in &names[..names.len() - 1] {\n-                        url.push_str(name);\n-                        url.push_str(\"/\");\n-                    }\n-                    url.push_str(&item_path(ty, names.last().unwrap()));\n-                    layout::redirect(writer, &url)?;\n+        if !self.render_redirect_pages {\n+            layout::render(writer, &self.shared.layout, &page,\n+                           &Sidebar{ cx: self, item: it },\n+                           &Item{ cx: self, item: it },\n+                           self.shared.css_file_extension.is_some())?;\n+        } else {\n+            let mut url = repeat(\"../\").take(self.current.len())\n+                                       .collect::<String>();\n+            if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n+                for name in &names[..names.len() - 1] {\n+                    url.push_str(name);\n+                    url.push_str(\"/\");\n                 }\n+                url.push_str(&item_path(ty, names.last().unwrap()));\n+                layout::redirect(writer, &url)?;\n             }\n-            Ok(())\n         }\n+        Ok(())\n+    }\n \n+    /// Non-parallelized version of rendering an item. This will take the input\n+    /// item, render its contents, and then invoke the specified closure with\n+    /// all sub-items which need to be rendered.\n+    ///\n+    /// The rendering driver uses this closure to queue up more work.\n+    fn item<F>(&mut self, item: clean::Item, mut f: F) -> Result<(), Error> where\n+        F: FnMut(&mut Context, clean::Item),\n+    {\n         // Stripped modules survive the rustdoc passes (i.e. `strip-private`)\n         // if they contain impls for public types. These modules can also\n         // contain items such as publicly reexported structures.\n@@ -1371,7 +1374,7 @@ impl Context {\n                 let item = item.take().unwrap();\n \n                 let mut buf = Vec::new();\n-                render(&mut buf, this, &item, false).unwrap();\n+                this.render_item(&mut buf, &item, false).unwrap();\n                 // buf will be empty if the module is stripped and there is no redirect for it\n                 if !buf.is_empty() {\n                     let joint_dst = this.dst.join(\"index.html\");\n@@ -1386,7 +1389,7 @@ impl Context {\n                     _ => unreachable!()\n                 };\n \n-                // render sidebar-items.js used throughout this module\n+                // Render sidebar-items.js used throughout this module.\n                 if !this.render_redirect_pages {\n                     let items = this.build_sidebar_items(&m);\n                     let js_dst = this.dst.join(\"sidebar-items.js\");\n@@ -1398,23 +1401,34 @@ impl Context {\n                 for item in m.items {\n                     f(this,item);\n                 }\n+\n                 Ok(())\n-            })\n+            })?;\n         } else if item.name.is_some() {\n             let mut buf = Vec::new();\n-            render(&mut buf, self, &item, true).unwrap();\n+            self.render_item(&mut buf, &item, true).unwrap();\n             // buf will be empty if the item is stripped and there is no redirect for it\n             if !buf.is_empty() {\n-                let joint_dst = self.dst.join(&item_path(shortty(&item),\n-                                                         item.name.as_ref().unwrap()));\n+                let name = item.name.as_ref().unwrap();\n+                let item_type = item_type(&item);\n+                let file_name = &item_path(item_type, name);\n+                let joint_dst = self.dst.join(file_name);\n                 try_err!(fs::create_dir_all(&self.dst), &self.dst);\n                 let mut dst = try_err!(File::create(&joint_dst), &joint_dst);\n                 try_err!(dst.write_all(&buf), &joint_dst);\n+\n+                // Redirect from a sane URL using the namespace to Rustdoc's\n+                // URL for the page.\n+                let redir_name = format!(\"{}.{}.html\", name, item_type.name_space());\n+                let redir_dst = self.dst.join(redir_name);\n+                if let Ok(mut redirect_out) = OpenOptions::new().create_new(true)\n+                                                                .write(true)\n+                                                                .open(&redir_dst) {\n+                    try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n+                }\n             }\n-            Ok(())\n-        } else {\n-            Ok(())\n         }\n+        Ok(())\n     }\n \n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n@@ -1423,7 +1437,7 @@ impl Context {\n         for item in &m.items {\n             if self.maybe_ignore_item(item) { continue }\n \n-            let short = shortty(item).to_static_str();\n+            let short = item_type(item).css_class();\n             let myname = match item.name {\n                 None => continue,\n                 Some(ref s) => s.to_string(),\n@@ -1531,7 +1545,7 @@ impl<'a> Item<'a> {\n             }\n             Some(format!(\"{path}{file}?gotosrc={goto}\",\n                          path = path,\n-                         file = item_path(shortty(self.item), external_path.last().unwrap()),\n+                         file = item_path(item_type(self.item), external_path.last().unwrap()),\n                          goto = self.item.def_id.index.as_usize()))\n         }\n     }\n@@ -1566,7 +1580,7 @@ impl<'a> fmt::Display for Item<'a> {\n             }\n         }\n         write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-               shortty(self.item), self.item.name.as_ref().unwrap())?;\n+               item_type(self.item), self.item.name.as_ref().unwrap())?;\n \n         write!(fmt, \"</span>\")?; // in-band\n         write!(fmt, \"<span class='out-of-band'>\")?;\n@@ -1622,7 +1636,7 @@ impl<'a> fmt::Display for Item<'a> {\n fn item_path(ty: ItemType, name: &str) -> String {\n     match ty {\n         ItemType::Module => format!(\"{}/index.html\", name),\n-        _ => format!(\"{}.{}.html\", ty.to_static_str(), name),\n+        _ => format!(\"{}.{}.html\", ty.css_class(), name),\n     }\n }\n \n@@ -1714,8 +1728,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     }\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: usize, idx2: usize) -> Ordering {\n-        let ty1 = shortty(i1);\n-        let ty2 = shortty(i2);\n+        let ty1 = item_type(i1);\n+        let ty2 = item_type(i2);\n         if ty1 != ty2 {\n             return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n         }\n@@ -1739,7 +1753,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             continue;\n         }\n \n-        let myty = Some(shortty(myitem));\n+        let myty = Some(item_type(myitem));\n         if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n             // Put `extern crate` and `use` re-exports in the same section.\n             curty = myty;\n@@ -1825,9 +1839,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n                        docs = shorter(Some(&Markdown(doc_value).to_string())),\n-                       class = shortty(myitem),\n+                       class = item_type(myitem),\n                        stab = myitem.stability_class(),\n-                       href = item_path(shortty(myitem), myitem.name.as_ref().unwrap()),\n+                       href = item_path(item_type(myitem), myitem.name.as_ref().unwrap()),\n                        title = full_path(cx, myitem))?;\n             }\n         }\n@@ -2022,14 +2036,18 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item, t: &clean::Item)\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n-        let id = derive_id(format!(\"{}.{}\", shortty(m), name));\n-        write!(w, \"<h3 id='{id}' class='method stab {stab}'><code>\",\n+        let item_type = item_type(m);\n+        let id = derive_id(format!(\"{}.{}\", item_type, name));\n+        let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+        write!(w, \"<h3 id='{id}' class='method stab {stab}'>\\\n+                   <span id='{ns_id}' class='invisible'><code>\",\n                id = id,\n-               stab = m.stability_class())?;\n+               stab = m.stability_class(),\n+               ns_id = ns_id)?;\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)))?;\n         write!(w, \"</code>\")?;\n         render_stability_since(w, m, t)?;\n-        write!(w, \"</h3>\")?;\n+        write!(w, \"</span></h3>\")?;\n         document(w, cx, m)?;\n         Ok(())\n     }\n@@ -2104,7 +2122,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                let (ref path, _) = cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n-           ty = shortty(it).to_static_str(),\n+           ty = item_type(it).css_class(),\n            name = *it.name.as_ref().unwrap())?;\n     Ok(())\n }\n@@ -2113,7 +2131,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n     use html::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n-    let ty = match shortty(it) {\n+    let ty = match item_type(it) {\n         Typedef | AssociatedType => AssociatedType,\n         s@_ => s,\n     };\n@@ -2191,7 +2209,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n               link: AssocItemLink)\n               -> fmt::Result {\n         let name = meth.name.as_ref().unwrap();\n-        let anchor = format!(\"#{}.{}\", shortty(meth), name);\n+        let anchor = format!(\"#{}.{}\", item_type(meth), name);\n         let href = match link {\n             AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n             AssocItemLink::Anchor(None) => anchor,\n@@ -2268,9 +2286,19 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         if fields.peek().is_some() {\n             write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n             for (field, ty) in fields {\n-                write!(w, \"<span id='{shortty}.{name}' class='{shortty}'><code>{name}: {ty}</code>\n-                           </span><span class='stab {stab}'></span>\",\n-                       shortty = ItemType::StructField,\n+                let id = derive_id(format!(\"{}.{}\",\n+                                           ItemType::StructField,\n+                                           field.name.as_ref().unwrap()));\n+                let ns_id = derive_id(format!(\"{}.{}\",\n+                                              field.name.as_ref().unwrap(),\n+                                              ItemType::StructField.name_space()));\n+                write!(w, \"<span id='{id}' class='{item_type}'>\n+                           <span id='{ns_id}' class='invisible'>\n+                           <code>{name}: {ty}</code>\n+                           </span></span><span class='stab {stab}'></span>\",\n+                       item_type = ItemType::StructField,\n+                       id = id,\n+                       ns_id = ns_id,\n                        stab = field.stability_class(),\n                        name = field.name.as_ref().unwrap(),\n                        ty = ty)?;\n@@ -2339,8 +2367,16 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     if !e.variants.is_empty() {\n         write!(w, \"<h2 class='variants'>Variants</h2>\\n\")?;\n         for variant in &e.variants {\n-            write!(w, \"<span id='{shortty}.{name}' class='variant'><code>{name}\",\n-                   shortty = ItemType::Variant,\n+            let id = derive_id(format!(\"{}.{}\",\n+                                       ItemType::Variant,\n+                                       variant.name.as_ref().unwrap()));\n+            let ns_id = derive_id(format!(\"{}.{}\",\n+                                          variant.name.as_ref().unwrap(),\n+                                          ItemType::Variant.name_space()));\n+            write!(w, \"<span id='{id}' class='variant'>\\\n+                       <span id='{ns_id}' class='invisible'><code>{name}\",\n+                   id = id,\n+                   ns_id = ns_id,\n                    name = variant.name.as_ref().unwrap())?;\n             if let clean::VariantItem(ref var) = variant.inner {\n                 if let clean::TupleVariant(ref tys) = var.kind {\n@@ -2354,7 +2390,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     write!(w, \")\")?;\n                 }\n             }\n-            write!(w, \"</code></span>\")?;\n+            write!(w, \"</code></span></span>\")?;\n             document(w, cx, variant)?;\n \n             use clean::{Variant, StructVariant};\n@@ -2364,10 +2400,20 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 for field in &s.fields {\n                     use clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = field.inner {\n+                        let id = derive_id(format!(\"variant.{}.field.{}\",\n+                                                   variant.name.as_ref().unwrap(),\n+                                                   field.name.as_ref().unwrap()));\n+                        let ns_id = derive_id(format!(\"{}.{}.{}.{}\",\n+                                                      variant.name.as_ref().unwrap(),\n+                                                      ItemType::Variant.name_space(),\n+                                                      field.name.as_ref().unwrap(),\n+                                                      ItemType::StructField.name_space()));\n                         write!(w, \"<tr><td \\\n-                                   id='variant.{v}.field.{f}'>\\\n-                                   <code>{f}:&nbsp;{t}</code></td><td>\",\n-                               v = variant.name.as_ref().unwrap(),\n+                                   id='{id}'>\\\n+                                   <span id='{ns_id}' class='invisible'>\\\n+                                   <code>{f}:&nbsp;{t}</code></span></td><td>\",\n+                               id = id,\n+                               ns_id = ns_id,\n                                f = field.name.as_ref().unwrap(),\n                                t = *ty)?;\n                         document(w, cx, field)?;\n@@ -2584,11 +2630,11 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n     }\n \n-    fn doctraititem(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n-                    link: AssocItemLink, render_static: bool,\n-                    is_default_item: bool, outer_version: Option<&str>,\n-                    trait_: Option<&clean::Trait>) -> fmt::Result {\n-        let shortty = shortty(item);\n+    fn doc_impl_item(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n+                     link: AssocItemLink, render_static: bool,\n+                     is_default_item: bool, outer_version: Option<&str>,\n+                     trait_: Option<&clean::Trait>) -> fmt::Result {\n+        let item_type = item_type(item);\n         let name = item.name.as_ref().unwrap();\n \n         let is_static = match item.inner {\n@@ -2601,38 +2647,48 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 // Only render when the method is not static or we allow static methods\n                 if !is_static || render_static {\n-                    let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                    write!(w, \"<h4 id='{}' class='{}'>\", id, shortty)?;\n+                    let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                    let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                    write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                    write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n                     write!(w, \"<code>\")?;\n                     render_assoc_item(w, item, link.anchor(&id))?;\n                     write!(w, \"</code>\")?;\n                     render_stability_since_raw(w, item.stable_since(), outer_version)?;\n-                    write!(w, \"</h4>\\n\")?;\n+                    write!(w, \"</span></h4>\\n\")?;\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::ConstantItem(ref c) => {\n-                let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, &c.type_, Some(&c.expr), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::StrippedItem(..) => return Ok(()),\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n@@ -2671,8 +2727,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n     write!(w, \"<div class='impl-items'>\")?;\n     for trait_item in &i.inner_impl().items {\n-        doctraititem(w, cx, trait_item, link, render_header,\n-                     false, outer_version, trait_)?;\n+        doc_impl_item(w, cx, trait_item, link, render_header,\n+                      false, outer_version, trait_)?;\n     }\n \n     fn render_default_items(w: &mut fmt::Formatter,\n@@ -2689,8 +2745,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             let did = i.trait_.as_ref().unwrap().def_id().unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.provided_trait_methods);\n \n-            doctraititem(w, cx, trait_item, assoc_link, render_static, true,\n-                         outer_version, None)?;\n+            doc_impl_item(w, cx, trait_item, assoc_link, render_static, true,\n+                          outer_version, None)?;\n         }\n         Ok(())\n     }\n@@ -2749,7 +2805,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                    relpath: '{path}'\\\n                 }};</script>\",\n                name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-               ty = shortty(it).to_static_str(),\n+               ty = item_type(it).css_class(),\n                path = relpath)?;\n         if parentlen == 0 {\n             // there is no sidebar-items.js beyond the crate root path"}, {"sha": "c97cacd10c3814f74109324409d2e825bb61a2ee", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -284,14 +284,20 @@ h3.impl > .out-of-band {\n     font-size: 21px;\n }\n \n-h4 > code, h3 > code {\n+h4 > code, h3 > code, invisible > code {\n     position: inherit;\n }\n \n .in-band, code {\n     z-index: 5;\n }\n \n+.invisible {\n+    background: rgba(0, 0, 0, 0);\n+    width: 100%;\n+    display: inline-block;\n+}\n+\n .content .in-band {\n     margin: 0px;\n     padding: 0px;\n@@ -660,6 +666,7 @@ span.since {\n \n :target > code {\n    background: #FDFFD3;\n+   opacity: 1;\n }\n \n /* Media Queries */"}, {"sha": "c64fb1b67f3d74dd130d9fc0589515f22fba0ed8", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -26,7 +26,7 @@ h1.fqn {\n h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n     border-bottom-color: #DDDDDD;\n }\n-.in-band, code {\n+.in-band {\n     background-color: white;\n }\n "}, {"sha": "e5485c356c2924867e2bbd0a8843b7e2bff8fe80", "filename": "src/test/rustdoc/assoc-types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fassoc-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fassoc-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-types.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -13,7 +13,9 @@\n // @has assoc_types/trait.Index.html\n pub trait Index<I: ?Sized> {\n     // @has - '//*[@id=\"associatedtype.Output\"]//code' 'type Output: ?Sized'\n+    // @has - '//*[@id=\"Output.t\"]//code' 'type Output: ?Sized'\n     type Output: ?Sized;\n+    // @has - '//*[@id=\"index.v\"]//code' 'fn index'\n     // @has - '//*[@id=\"tymethod.index\"]//code' \\\n     //      \"fn index<'a>(&'a self, index: I) -> &'a Self::Output\"\n     fn index<'a>(&'a self, index: I) -> &'a Self::Output;"}, {"sha": "15f7528b4ba21c234936a1f099d24f5129401c9f", "filename": "src/test/rustdoc/issue-19190.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19190.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -23,6 +23,9 @@ impl Deref for Bar {\n     fn deref(&self) -> &Foo { loop {} }\n }\n \n+// @has issue_19190/Bar.t.html\n // @has issue_19190/struct.Bar.html\n+// @has - '//*[@id=\"foo.v\"]' 'fn foo(&self)'\n // @has - '//*[@id=\"method.foo\"]' 'fn foo(&self)'\n+// @!has - '//*[@id=\"static_foo.v\"]' 'fn static_foo()'\n // @!has - '//*[@id=\"method.static_foo\"]' 'fn static_foo()'"}, {"sha": "8c5bda7584c9f8bd54666ad7e436ffd9d005df29", "filename": "src/test/rustdoc/issue-21092.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fissue-21092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fissue-21092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-21092.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -13,6 +13,7 @@\n \n extern crate issue_21092;\n \n+// @has issue_21092/Bar.t.html\n // @has issue_21092/struct.Bar.html\n // @has - '//*[@id=\"associatedtype.Bar\"]' 'type Bar = i32'\n pub use issue_21092::{Foo, Bar};"}, {"sha": "0b6a8104661afa88186ef752e39e22f42e676068", "filename": "src/test/rustdoc/issue-25001.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-25001.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -19,14 +19,17 @@ pub trait Bar {\n \n impl Foo<u8> {\n     // @has - '//*[@id=\"method.pass\"]//code' 'fn pass()'\n+    // @has - '//*[@id=\"pass.v\"]//code' 'fn pass()'\n     pub fn pass() {}\n }\n impl Foo<u16> {\n     // @has - '//*[@id=\"method.pass-1\"]//code' 'fn pass() -> usize'\n+    // @has - '//*[@id=\"pass.v-1\"]//code' 'fn pass() -> usize'\n     pub fn pass() -> usize { 42 }\n }\n impl Foo<u32> {\n     // @has - '//*[@id=\"method.pass-2\"]//code' 'fn pass() -> isize'\n+    // @has - '//*[@id=\"pass.v-2\"]//code' 'fn pass() -> isize'\n     pub fn pass() -> isize { 42 }\n }\n "}, {"sha": "e946e2423167acb101a38f45b79ad9ba7864e714", "filename": "src/test/rustdoc/src-links.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fsrc-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fsrc-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsrc-links.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -24,11 +24,13 @@ pub mod bar {\n     // @has foo/bar/baz/index.html '//a/@href' '../../../src/foo/src-links.rs.html'\n     pub mod baz {\n         /// Dox\n+        // @has foo/bar/baz/baz.v.html\n         // @has foo/bar/baz/fn.baz.html '//a/@href' '../../../src/foo/src-links.rs.html'\n         pub fn baz() { }\n     }\n \n     /// Dox\n+    // @has foo/bar/Foobar.t.html\n     // @has foo/bar/trait.Foobar.html '//a/@href' '../../src/foo/src-links.rs.html'\n     pub trait Foobar { fn dummy(&self) { } }\n "}, {"sha": "c0bfe3ffe3cf9ee576832eb096b878b0351bd47f", "filename": "src/test/rustdoc/structfields.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fstructfields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c0d66af693dc960e042631643b0d76a05a4b9a9/src%2Ftest%2Frustdoc%2Fstructfields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstructfields.rs?ref=6c0d66af693dc960e042631643b0d76a05a4b9a9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// @has structfields/Foo.t.html\n+// @has - struct.Foo.html\n // @has structfields/struct.Foo.html\n pub struct Foo {\n     // @has - //pre \"pub a: ()\"\n@@ -22,13 +24,17 @@ pub struct Foo {\n     pub d: usize,\n }\n \n+// @has structfields/Bar.t.html\n+// @has - struct.Bar.html\n // @has structfields/struct.Bar.html\n pub struct Bar {\n     // @has - //pre \"pub a: ()\"\n     pub a: (),\n     // @!has - //pre \"// some fields omitted\"\n }\n \n+// @has structfields/Qux.t.html\n+// @has - enum.Qux.html\n // @has structfields/enum.Qux.html\n pub enum Qux {\n     Quz {"}]}