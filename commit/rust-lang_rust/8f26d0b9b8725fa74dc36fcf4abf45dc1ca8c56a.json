{"sha": "8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMjZkMGI5Yjg3MjVmYTc0ZGMzNmZjZjRhYmY0NWRjMWNhOGM1NmE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-01T05:30:21Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-01T15:53:54Z"}, "message": "syntax: expand impl_pretty_name to handle more cases.\n\nThe resulting symbol names aren't very pretty at all:\n\n    trait Trait { fn method(&self); }\n    impl<'a> Trait for ~[(&'a int, fn())] { fn method(&self) {} }\n\ngives\n\n    Trait$$UP$$VEC$$TUP_2$$BP$int$$FN$$::method::...hash...::v0.0\n\nHowever, at least it contain some reference to the Self type, unlike\n`Trait$__extensions__::method:...`, which is what the symbol name used\nto be for anything other than `impl Trait for foo::bar::Baz` (which\nbecame, and still becomes, `Trait$Baz::method`).", "tree": {"sha": "d10ee55a699bed56fb8cf05aefe1c5a3e8b7a822", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d10ee55a699bed56fb8cf05aefe1c5a3e8b7a822"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a", "html_url": "https://github.com/rust-lang/rust/commit/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09a561ac9caaf4acfc170cac92efe6bb5a991a11", "url": "https://api.github.com/repos/rust-lang/rust/commits/09a561ac9caaf4acfc170cac92efe6bb5a991a11", "html_url": "https://github.com/rust-lang/rust/commit/09a561ac9caaf4acfc170cac92efe6bb5a991a11"}], "stats": {"total": 83, "additions": 64, "deletions": 19}, "files": [{"sha": "5312805366a4c49e2ba3cfc3af1a25cdfab30b9c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a", "patch": "@@ -1140,7 +1140,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let impl_vtables = ty::lookup_impl_vtables(tcx, def_id);\n             encode_impl_vtables(ebml_w, ecx, &impl_vtables);\n         }\n-        let elt = ast_map::impl_pretty_name(opt_trait, ty, item.ident);\n+        let elt = ast_map::impl_pretty_name(opt_trait, ty);\n         encode_path(ecx, ebml_w, path, elt);\n         ebml_w.end_tag();\n "}, {"sha": "817cf24eec688fb4f0209f981cdf831a3467e51a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 61, "deletions": 16, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a", "patch": "@@ -82,26 +82,71 @@ pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n     }\n }\n \n-pub fn impl_pretty_name(trait_ref: &Option<trait_ref>,\n-                        ty: &Ty, default: Ident) -> path_elt {\n-    let itr = get_ident_interner();\n-    let ty_ident = match ty.node {\n-        ty_path(ref path, _, _) => path.segments.last().identifier,\n-        _ => default\n+/// write a \"pretty\" version of `ty` to `out`. This is designed so\n+/// that symbols of `impl`'d methods give some hint of where they came\n+/// from, even if it's hard to read (previously they would all just be\n+/// listed as `__extensions__::method_name::hash`, with no indication\n+/// of the type).\n+// XXX: these dollar signs and the names in general are actually a\n+//      relic of $ being one of the very few valid symbol names on\n+//      unix. These kinds of details shouldn't be exposed way up here\n+//      in the ast.\n+fn pretty_ty(ty: &Ty, itr: @ident_interner, out: &mut ~str) {\n+    let (prefix, subty) = match ty.node {\n+        ty_uniq(ty) => (\"$UP$\", &*ty),\n+        ty_box(mt { ty, .. }) => (\"$SP$\", &*ty),\n+        ty_ptr(mt { ty, mutbl }) => (if mutbl == MutMutable {\"$RPmut$\"} else {\"$RP$\"},\n+                                     &*ty),\n+        ty_rptr(_, mt { ty, mutbl }) => (if mutbl == MutMutable {\"$BPmut$\"} else {\"$BP$\"},\n+                                      &*ty),\n+\n+        ty_vec(ty) => (\"$VEC$\", &*ty),\n+        ty_fixed_length_vec(ty, _) => (\"$FIXEDVEC$\", &*ty),\n+\n+        // these can't be represented as <prefix><contained ty>, so\n+        // need custom handling.\n+        ty_nil => { out.push_str(\"$NIL$\"); return }\n+        ty_path(ref path, _, _) => {\n+                        out.push_str(itr.get(path.segments.last().identifier.name));\n+                        return\n+                    }\n+        ty_tup(ref tys) => {\n+            out.push_str(format!(\"$TUP_{}$\", tys.len()));\n+            for subty in tys.iter() {\n+                pretty_ty(*subty, itr, out);\n+                out.push_char('$');\n+            }\n+            return\n+        }\n+\n+        // meh, better than nothing.\n+        ty_bot => { out.push_str(\"$BOT$\"); return }\n+        ty_closure(..) => { out.push_str(\"$CLOSURE$\"); return }\n+        ty_bare_fn(..) => { out.push_str(\"$FN$\"); return }\n+        ty_typeof(..) => { out.push_str(\"$TYPEOF$\"); return }\n+        ty_infer(..) => { out.push_str(\"$INFER$\"); return }\n+\n     };\n+\n+    out.push_str(prefix);\n+    pretty_ty(subty, itr, out);\n+}\n+\n+pub fn impl_pretty_name(trait_ref: &Option<trait_ref>, ty: &Ty) -> path_elt {\n+    let itr = get_ident_interner();\n+\n     let hash = (trait_ref, ty).hash();\n+    let mut pretty;\n     match *trait_ref {\n-        None => path_pretty_name(ty_ident, hash),\n+        None => pretty = ~\"\",\n         Some(ref trait_ref) => {\n-            // XXX: this dollar sign is actually a relic of being one of the\n-            //      very few valid symbol names on unix. These kinds of\n-            //      details shouldn't be exposed way up here in the ast.\n-            let s = format!(\"{}${}\",\n-                         itr.get(trait_ref.path.segments.last().identifier.name),\n-                         itr.get(ty_ident.name));\n-            path_pretty_name(Ident::new(itr.gensym(s)), hash)\n+            pretty = itr.get(trait_ref.path.segments.last().identifier.name).to_owned();\n+            pretty.push_char('$');\n         }\n-    }\n+    };\n+    pretty_ty(ty, itr, &mut pretty);\n+\n+    path_pretty_name(Ident::new(itr.gensym(pretty)), hash)\n }\n \n #[deriving(Clone)]\n@@ -265,7 +310,7 @@ impl Visitor<()> for Ctx {\n                 // Right now the ident on impls is __extensions__ which isn't\n                 // very pretty when debugging, so attempt to select a better\n                 // name to use.\n-                let elt = impl_pretty_name(maybe_trait, ty, i.ident);\n+                let elt = impl_pretty_name(maybe_trait, ty);\n \n                 let impl_did = ast_util::local_def(i.id);\n                 for m in ms.iter() {"}, {"sha": "c758a173f3875a924f03570ac7a4e448fe92b172", "filename": "src/test/compile-fail/ambig_impl_unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs?ref=8f26d0b9b8725fa74dc36fcf4abf45dc1ca8c56a", "patch": "@@ -13,11 +13,11 @@ trait foo {\n }\n \n impl foo for ~[uint] {\n-    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `foo$__extensions__::foo`\n+    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `foo$$UP$$VEC$uint::foo`\n }\n \n impl foo for ~[int] {\n-    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `foo$__extensions__::foo`\n+    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `foo$$UP$$VEC$int::foo`\n }\n \n fn main() {"}]}