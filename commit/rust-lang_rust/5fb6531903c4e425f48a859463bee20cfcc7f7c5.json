{"sha": "5fb6531903c4e425f48a859463bee20cfcc7f7c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYjY1MzE5MDNjNGU0MjVmNDhhODU5NDYzYmVlMjBjZmNjN2Y3YzU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-11-23T23:11:20Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-11-24T02:11:41Z"}, "message": "rustfmt: libflate, libfmt_macros, libgetopts, libgraphviz, liblog, librand", "tree": {"sha": "e8e48cc9f8f2cfe14906aeefc7afc4537b088ad1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8e48cc9f8f2cfe14906aeefc7afc4537b088ad1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fb6531903c4e425f48a859463bee20cfcc7f7c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb6531903c4e425f48a859463bee20cfcc7f7c5", "html_url": "https://github.com/rust-lang/rust/commit/5fb6531903c4e425f48a859463bee20cfcc7f7c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fb6531903c4e425f48a859463bee20cfcc7f7c5/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2", "html_url": "https://github.com/rust-lang/rust/commit/0dfd875b6efa68ed67988a2f9856fc3bbdc91ce2"}], "stats": {"total": 981, "additions": 503, "deletions": 478}, "files": [{"sha": "c5f0800e71fbb34450614123f6a3fd9303b91531", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -82,7 +82,7 @@ impl Drop for Bytes {\n }\n \n #[link(name = \"miniz\", kind = \"static\")]\n-extern {\n+extern \"C\" {\n     /// Raw miniz compression function.\n     fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n                                   src_buf_len: size_t,"}, {"sha": "2cd046dc38ab19f60674f6d5e4bb1aed054b0313", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -187,7 +187,7 @@ impl<'a> Parser<'a> {\n         Parser {\n             input: s,\n             cur: s.char_indices().peekable(),\n-            errors: vec!(),\n+            errors: vec![],\n         }\n     }\n \n@@ -236,7 +236,7 @@ impl<'a> Parser<'a> {\n             if c.is_whitespace() {\n                 self.cur.next();\n             } else {\n-                break\n+                break;\n             }\n         }\n     }\n@@ -274,9 +274,7 @@ impl<'a> Parser<'a> {\n             ArgumentIs(i)\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => {\n-                    ArgumentNamed(self.word())\n-                }\n+                Some(&(_, c)) if c.is_alphabetic() => ArgumentNamed(self.word()),\n                 _ => ArgumentNext,\n             }\n         }\n@@ -294,7 +292,7 @@ impl<'a> Parser<'a> {\n             ty: &self.input[..0],\n         };\n         if !self.consume(':') {\n-            return spec\n+            return spec;\n         }\n \n         // fill character\n@@ -419,7 +417,7 @@ impl<'a> Parser<'a> {\n                 found = true;\n                 self.cur.next();\n             } else {\n-                break\n+                break;\n             }\n         }\n         if found {\n@@ -447,7 +445,7 @@ mod tests {\n             precision: CountImplied,\n             width: CountImplied,\n             ty: \"\",\n-        }\n+        };\n     }\n \n     fn musterr(s: &str) {"}, {"sha": "c744121f84369114c49aa6bd15100e98ac20caaf", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 449, "deletions": 426, "changes": 875, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -98,7 +98,9 @@\n #![feature(str_char)]\n #![cfg_attr(test, feature(rustc_private))]\n \n-#[cfg(test)] #[macro_use] extern crate log;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate log;\n \n use self::Name::*;\n use self::HasArg::*;\n@@ -174,7 +176,7 @@ pub struct OptGroup {\n     /// Whether option has an argument\n     pub hasarg: HasArg,\n     /// How often it can occur\n-    pub occur: Occur\n+    pub occur: Occur,\n }\n \n /// Describes whether an option is given at all or has a value.\n@@ -239,7 +241,7 @@ impl Name {\n     fn to_string(&self) -> String {\n         match *self {\n             Short(ch) => ch.to_string(),\n-            Long(ref s) => s.to_owned()\n+            Long(ref s) => s.to_owned(),\n         }\n     }\n }\n@@ -257,33 +259,37 @@ impl OptGroup {\n         } = (*self).clone();\n \n         match (short_name.len(), long_name.len()) {\n-            (0,0) => panic!(\"this long-format option was given no name\"),\n-            (0,_) => Opt {\n-                name: Long((long_name)),\n-                hasarg: hasarg,\n-                occur: occur,\n-                aliases: Vec::new()\n-            },\n-            (1,0) => Opt {\n-                name: Short(short_name.char_at(0)),\n-                hasarg: hasarg,\n-                occur: occur,\n-                aliases: Vec::new()\n-            },\n-            (1,_) => Opt {\n-                name: Long((long_name)),\n-                hasarg: hasarg,\n-                occur: occur,\n-                aliases: vec!(\n-                    Opt {\n-                        name: Short(short_name.char_at(0)),\n-                        hasarg: hasarg,\n-                        occur:  occur,\n-                        aliases: Vec::new()\n-                    }\n-                )\n-            },\n-            (_,_) => panic!(\"something is wrong with the long-form opt\")\n+            (0, 0) => panic!(\"this long-format option was given no name\"),\n+            (0, _) => {\n+                Opt {\n+                    name: Long((long_name)),\n+                    hasarg: hasarg,\n+                    occur: occur,\n+                    aliases: Vec::new(),\n+                }\n+            }\n+            (1, 0) => {\n+                Opt {\n+                    name: Short(short_name.char_at(0)),\n+                    hasarg: hasarg,\n+                    occur: occur,\n+                    aliases: Vec::new(),\n+                }\n+            }\n+            (1, _) => {\n+                Opt {\n+                    name: Long((long_name)),\n+                    hasarg: hasarg,\n+                    occur: occur,\n+                    aliases: vec![Opt {\n+                                      name: Short(short_name.char_at(0)),\n+                                      hasarg: hasarg,\n+                                      occur: occur,\n+                                      aliases: Vec::new(),\n+                                  }],\n+                }\n+            }\n+            (_, _) => panic!(\"something is wrong with the long-form opt\"),\n         }\n     }\n }\n@@ -292,7 +298,7 @@ impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n         match find_opt(&self.opts[..], Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n-            None => panic!(\"No option '{}' defined\", nm)\n+            None => panic!(\"No option '{}' defined\", nm),\n         }\n     }\n \n@@ -331,7 +337,7 @@ impl Matches {\n         for nm in names {\n             match self.opt_val(&nm[..]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n-                _ => ()\n+                _ => (),\n             }\n         }\n         None\n@@ -347,7 +353,7 @@ impl Matches {\n         for v in &r {\n             match *v {\n                 Val(ref s) => acc.push((*s).clone()),\n-                _ => ()\n+                _ => (),\n             }\n         }\n         acc\n@@ -361,7 +367,7 @@ impl Matches {\n         }\n         match vals[0] {\n             Val(ref s) => Some((*s).clone()),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n@@ -378,11 +384,10 @@ impl Matches {\n         } else {\n             match vals[0] {\n                 Val(ref s) => Some((*s).clone()),\n-                _ => Some(def.to_owned())\n+                _ => Some(def.to_owned()),\n             }\n         }\n     }\n-\n }\n \n fn is_arg(arg: &str) -> bool {\n@@ -393,7 +398,7 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<usize> {\n     // Search main options.\n     let pos = opts.iter().position(|opt| opt.name == nm);\n     if pos.is_some() {\n-        return pos\n+        return pos;\n     }\n \n     // Search in aliases.\n@@ -422,7 +427,7 @@ pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Req\n+        occur: Req,\n     }\n }\n \n@@ -442,7 +447,7 @@ pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Optional\n+        occur: Optional,\n     }\n }\n \n@@ -460,7 +465,7 @@ pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n         hint: \"\".to_owned(),\n         desc: desc.to_owned(),\n         hasarg: No,\n-        occur: Optional\n+        occur: Optional,\n     }\n }\n \n@@ -479,7 +484,7 @@ pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n         hint: \"\".to_owned(),\n         desc: desc.to_owned(),\n         hasarg: No,\n-        occur: Multi\n+        occur: Multi,\n     }\n }\n \n@@ -499,7 +504,7 @@ pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) ->\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: Maybe,\n-        occur: Optional\n+        occur: Optional,\n     }\n }\n \n@@ -520,7 +525,7 @@ pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> Op\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Multi\n+        occur: Multi,\n     }\n }\n \n@@ -530,7 +535,8 @@ pub fn opt(short_name: &str,\n            desc: &str,\n            hint: &str,\n            hasarg: HasArg,\n-           occur: Occur) -> OptGroup {\n+           occur: Occur)\n+           -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n@@ -539,28 +545,18 @@ pub fn opt(short_name: &str,\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: hasarg,\n-        occur: occur\n+        occur: occur,\n     }\n }\n \n impl fmt::Display for Fail {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ArgumentMissing(ref nm) => {\n-                write!(f, \"Argument to option '{}' missing.\", *nm)\n-            }\n-            UnrecognizedOption(ref nm) => {\n-                write!(f, \"Unrecognized option: '{}'.\", *nm)\n-            }\n-            OptionMissing(ref nm) => {\n-                write!(f, \"Required option '{}' missing.\", *nm)\n-            }\n-            OptionDuplicated(ref nm) => {\n-                write!(f, \"Option '{}' given more than once.\", *nm)\n-            }\n-            UnexpectedArgument(ref nm) => {\n-                write!(f, \"Option '{}' does not take an argument.\", *nm)\n-            }\n+            ArgumentMissing(ref nm) => write!(f, \"Argument to option '{}' missing.\", *nm),\n+            UnrecognizedOption(ref nm) => write!(f, \"Unrecognized option: '{}'.\", *nm),\n+            OptionMissing(ref nm) => write!(f, \"Required option '{}' missing.\", *nm),\n+            OptionDuplicated(ref nm) => write!(f, \"Option '{}' given more than once.\", *nm),\n+            UnexpectedArgument(ref nm) => write!(f, \"Option '{}' does not take an argument.\", *nm),\n         }\n     }\n }\n@@ -577,7 +573,9 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n     let n_opts = opts.len();\n \n-    fn f(_x: usize) -> Vec<Optval> { Vec::new() }\n+    fn f(_x: usize) -> Vec<Optval> {\n+        Vec::new()\n+    }\n \n     let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n@@ -590,7 +588,10 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n-            while j < l { free.push(args[j].clone()); j += 1; }\n+            while j < l {\n+                free.push(args[j].clone());\n+                j += 1;\n+            }\n             break;\n         } else {\n             let mut names;\n@@ -599,10 +600,9 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 let tail = &cur[2..curlen];\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n-                    names = vec!(Long(tail.to_owned()));\n+                    names = vec![Long(tail.to_owned())];\n                 } else {\n-                    names =\n-                        vec!(Long(tail_eq[0].to_owned()));\n+                    names = vec![Long(tail_eq[0].to_owned())];\n                     i_arg = Some(tail_eq[1].to_owned());\n                 }\n             } else {\n@@ -612,23 +612,22 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     let ch = cur.char_at(j);\n                     let opt = Short(ch);\n \n-                    /* In a series of potential options (eg. -aheJ), if we\n-                       see one which takes an argument, we assume all\n-                       subsequent characters make up the argument. This\n-                       allows options such as -L/usr/local/lib/foo to be\n-                       interpreted correctly\n-                    */\n+                    // In a series of potential options (eg. -aheJ), if we\n+                    // see one which takes an argument, we assume all\n+                    // subsequent characters make up the argument. This\n+                    // allows options such as -L/usr/local/lib/foo to be\n+                    // interpreted correctly\n \n                     let opt_id = match find_opt(&opts, opt.clone()) {\n-                      Some(id) => id,\n-                      None => return Err(UnrecognizedOption(opt.to_string()))\n+                        Some(id) => id,\n+                        None => return Err(UnrecognizedOption(opt.to_string())),\n                     };\n \n                     names.push(opt);\n \n                     let arg_follows = match opts[opt_id].hasarg {\n                         Yes | Maybe => true,\n-                        No => false\n+                        No => false,\n                     };\n \n                     let next = j + ch.len_utf8();\n@@ -644,44 +643,42 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             for nm in &names {\n                 name_pos += 1;\n                 let optid = match find_opt(&opts, (*nm).clone()) {\n-                  Some(id) => id,\n-                  None => return Err(UnrecognizedOption(nm.to_string()))\n+                    Some(id) => id,\n+                    None => return Err(UnrecognizedOption(nm.to_string())),\n                 };\n                 match opts[optid].hasarg {\n-                  No => {\n-                    if name_pos == names.len() && !i_arg.is_none() {\n-                        return Err(UnexpectedArgument(nm.to_string()));\n-                    }\n-                    let v = &mut vals[optid];\n-                    v.push(Given);\n-                  }\n-                  Maybe => {\n-                    if !i_arg.is_none() {\n-                        let v = &mut vals[optid];\n-                        v.push(Val((i_arg.clone())\n-                            .unwrap()));\n-                    } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(&args[i + 1][..]) {\n+                    No => {\n+                        if name_pos == names.len() && !i_arg.is_none() {\n+                            return Err(UnexpectedArgument(nm.to_string()));\n+                        }\n                         let v = &mut vals[optid];\n                         v.push(Given);\n-                    } else {\n-                        i += 1;\n-                        let v = &mut vals[optid];\n-                        v.push(Val(args[i].clone()));\n                     }\n-                  }\n-                  Yes => {\n-                    if !i_arg.is_none() {\n-                        let v = &mut vals[optid];\n-                        v.push(Val(i_arg.clone().unwrap()));\n-                    } else if i + 1 == l {\n-                        return Err(ArgumentMissing(nm.to_string()));\n-                    } else {\n-                        i += 1;\n-                        let v = &mut vals[optid];\n-                        v.push(Val(args[i].clone()));\n+                    Maybe => {\n+                        if !i_arg.is_none() {\n+                            let v = &mut vals[optid];\n+                            v.push(Val((i_arg.clone()).unwrap()));\n+                        } else if name_pos < names.len() || i + 1 == l || is_arg(&args[i + 1][..]) {\n+                            let v = &mut vals[optid];\n+                            v.push(Given);\n+                        } else {\n+                            i += 1;\n+                            let v = &mut vals[optid];\n+                            v.push(Val(args[i].clone()));\n+                        }\n+                    }\n+                    Yes => {\n+                        if !i_arg.is_none() {\n+                            let v = &mut vals[optid];\n+                            v.push(Val(i_arg.clone().unwrap()));\n+                        } else if i + 1 == l {\n+                            return Err(ArgumentMissing(nm.to_string()));\n+                        } else {\n+                            i += 1;\n+                            let v = &mut vals[optid];\n+                            v.push(Val(args[i].clone()));\n+                        }\n                     }\n-                  }\n                 }\n             }\n         }\n@@ -700,7 +697,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     Ok(Matches {\n         opts: opts,\n         vals: vals,\n-        free: free\n+        free: free,\n     })\n }\n \n@@ -783,7 +780,8 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n         row\n     });\n \n-    format!(\"{}\\n\\nOptions:\\n{}\\n\", brief,\n+    format!(\"{}\\n\\nOptions:\\n{}\\n\",\n+            brief,\n             rows.collect::<Vec<String>>().join(\"\\n\"))\n }\n \n@@ -836,19 +834,19 @@ pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n \n #[derive(Copy, Clone)]\n enum SplitWithinState {\n-    A,  // leading whitespace, initial state\n-    B,  // words\n-    C,  // internal and trailing whitespace\n+    A, // leading whitespace, initial state\n+    B, // words\n+    C, // internal and trailing whitespace\n }\n #[derive(Copy, Clone)]\n enum Whitespace {\n     Ws, // current char is whitespace\n-    Cr  // current char is not whitespace\n+    Cr, // current char is not whitespace\n }\n #[derive(Copy, Clone)]\n enum LengthLimit {\n     UnderLim, // current char makes current substring still fit in limit\n-    OverLim   // current char makes current substring no longer fit in limit\n+    OverLim, // current char makes current substring no longer fit in limit\n }\n \n \n@@ -863,8 +861,8 @@ enum LengthLimit {\n ///\n /// Panics during iteration if the string contains a non-whitespace\n /// sequence longer than the limit.\n-fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n-    F: FnMut(&str) -> bool\n+fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool\n+    where F: FnMut(&str) -> bool\n {\n     // Just for fun, let's write this as a state machine:\n \n@@ -883,18 +881,31 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n     }\n \n     let mut machine = |cont: &mut bool, (i, c): (usize, char)| -> bool {\n-        let whitespace = if c.is_whitespace() { Ws }       else { Cr };\n-        let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n+        let whitespace = if c.is_whitespace() {\n+            Ws\n+        } else {\n+            Cr\n+        };\n+        let limit = if (i - slice_start + 1) <= lim {\n+            UnderLim\n+        } else {\n+            OverLim\n+        };\n \n         state = match (state, whitespace, limit) {\n-            (A, Ws, _)        => { A }\n-            (A, Cr, _)        => { slice_start = i; last_start = i; B }\n-\n-            (B, Cr, UnderLim) => { B }\n-            (B, Cr, OverLim)  if (i - last_start + 1) > lim\n-                            => panic!(\"word starting with {} longer than limit!\",\n-                                      &ss[last_start..i + 1]),\n-            (B, Cr, OverLim)  => {\n+            (A, Ws, _) => A,\n+            (A, Cr, _) => {\n+                slice_start = i;\n+                last_start = i;\n+                B\n+            }\n+\n+            (B, Cr, UnderLim) => B,\n+            (B, Cr, OverLim) if (i - last_start + 1) > lim => {\n+                panic!(\"word starting with {} longer than limit!\",\n+                       &ss[last_start..i + 1])\n+            }\n+            (B, Cr, OverLim) => {\n                 *cont = it(&ss[slice_start..last_end]);\n                 slice_start = last_start;\n                 B\n@@ -903,7 +914,7 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n                 last_end = i;\n                 C\n             }\n-            (B, Ws, OverLim)  => {\n+            (B, Ws, OverLim) => {\n                 last_end = i;\n                 *cont = it(&ss[slice_start..last_end]);\n                 A\n@@ -913,20 +924,18 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n                 last_start = i;\n                 B\n             }\n-            (C, Cr, OverLim)  => {\n+            (C, Cr, OverLim) => {\n                 *cont = it(&ss[slice_start..last_end]);\n                 slice_start = i;\n                 last_start = i;\n                 last_end = i;\n                 B\n             }\n-            (C, Ws, OverLim)  => {\n+            (C, Ws, OverLim) => {\n                 *cont = it(&ss[slice_start..last_end]);\n                 A\n             }\n-            (C, Ws, UnderLim) => {\n-                C\n-            }\n+            (C, Ws, UnderLim) => C,\n         };\n \n         *cont\n@@ -935,7 +944,11 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n     ss.char_indices().all(|x| machine(&mut cont, x));\n \n     // Let the automaton 'run out' by supplying trailing whitespace\n-    while cont && match state { B | C => true, A => false } {\n+    while cont &&\n+          match state {\n+        B | C => true,\n+        A => false,\n+    } {\n         machine(&mut cont, (fake_i, ' '));\n         fake_i += 1;\n     }\n@@ -946,19 +959,21 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n fn test_split_within() {\n     fn t(s: &str, i: usize, u: &[String]) {\n         let mut v = Vec::new();\n-        each_split_within(s, i, |s| { v.push(s.to_string()); true });\n-        assert!(v.iter().zip(u).all(|(a,b)| a == b));\n+        each_split_within(s, i, |s| {\n+            v.push(s.to_string());\n+            true\n+        });\n+        assert!(v.iter().zip(u).all(|(a, b)| a == b));\n     }\n     t(\"\", 0, &[]);\n     t(\"\", 15, &[]);\n     t(\"hello\", 15, &[\"hello\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15, &[\n-        \"Mary had a\".to_string(),\n-        \"little lamb\".to_string(),\n-        \"Little lamb\".to_string()\n-    ]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::usize::MAX,\n-        &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n+      15,\n+      &[\"Mary had a\".to_string(), \"little lamb\".to_string(), \"Little lamb\".to_string()]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n+      ::std::usize::MAX,\n+      &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n }\n \n #[cfg(test)]\n@@ -972,442 +987,446 @@ mod tests {\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt() {\n-        let long_args = vec!(\"--test=20\".to_string());\n-        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test=20\".to_string()];\n+        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!(m.opt_present(\"t\"));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => { panic!(\"test_reqopt failed (long arg)\"); }\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!(m.opt_present(\"t\"));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => {\n+                panic!(\"test_reqopt failed (long arg)\");\n+            }\n         }\n-        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Ok(ref m) => {\n-            assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => { panic!(\"test_reqopt failed (short arg)\"); }\n+            Ok(ref m) => {\n+                assert!((m.opt_present(\"test\")));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => {\n+                panic!(\"test_reqopt failed (short arg)\");\n+            }\n         }\n     }\n \n     #[test]\n     fn test_reqopt_missing() {\n-        let args = vec!(\"blah\".to_string());\n-        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"blah\".to_string()];\n+        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(OptionMissing(_)) => {},\n-          _ => panic!()\n+            Err(OptionMissing(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_reqopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_string());\n-        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test\".to_string()];\n+        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string());\n+        let short_args = vec![\"-t\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_reqopt_multi() {\n-        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n-        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n+        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(OptionDuplicated(_)) => {},\n-          _ => panic!()\n+            Err(OptionDuplicated(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     // Tests for optopt\n     #[test]\n     fn test_optopt() {\n-        let long_args = vec!(\"--test=20\".to_string());\n-        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test=20\".to_string()];\n+        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Ok(ref m) => {\n-            assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!((m.opt_present(\"test\")));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optopt_missing() {\n-        let args = vec!(\"blah\".to_string());\n-        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"blah\".to_string()];\n+        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(!m.opt_present(\"test\"));\n-            assert!(!m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(!m.opt_present(\"test\"));\n+                assert!(!m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_string());\n-        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test\".to_string()];\n+        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string());\n+        let short_args = vec![\"-t\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optopt_multi() {\n-        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n-        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n+        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(OptionDuplicated(_)) => {},\n-          _ => panic!()\n+            Err(OptionDuplicated(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     // Tests for optflag\n     #[test]\n     fn test_optflag() {\n-        let long_args = vec!(\"--test\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let long_args = vec![\"--test\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(m.opt_present(\"test\"));\n-            assert!(m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert!(m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string());\n+        let short_args = vec![\"-t\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Ok(ref m) => {\n-            assert!(m.opt_present(\"test\"));\n-            assert!(m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert!(m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflag_missing() {\n-        let args = vec!(\"blah\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let args = vec![\"blah\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(!m.opt_present(\"test\"));\n-            assert!(!m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(!m.opt_present(\"test\"));\n+                assert!(!m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflag_long_arg() {\n-        let args = vec!(\"--test=20\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let args = vec![\"--test=20\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(UnexpectedArgument(_)) => {},\n-          _ => panic!()\n+            Err(UnexpectedArgument(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflag_multi() {\n-        let args = vec!(\"--test\".to_string(), \"-t\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let args = vec![\"--test\".to_string(), \"-t\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(OptionDuplicated(_)) => {},\n-          _ => panic!()\n+            Err(OptionDuplicated(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflag_short_arg() {\n-        let args = vec!(\"-t\".to_string(), \"20\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let args = vec![\"-t\".to_string(), \"20\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            // The next variable after the flag is just a free argument\n+            Ok(ref m) => {\n+                // The next variable after the flag is just a free argument\n \n-            assert!(m.free[0] == \"20\");\n-          }\n-          _ => panic!()\n+                assert!(m.free[0] == \"20\");\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     // Tests for optflagmulti\n     #[test]\n     fn test_optflagmulti_short1() {\n-        let args = vec!(\"-v\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"-v\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"v\"), 1);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"v\"), 1);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_short2a() {\n-        let args = vec!(\"-v\".to_string(), \"-v\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"-v\".to_string(), \"-v\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"v\"), 2);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"v\"), 2);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_short2b() {\n-        let args = vec!(\"-vv\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"-vv\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"v\"), 2);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"v\"), 2);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_long1() {\n-        let args = vec!(\"--verbose\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"--verbose\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"verbose\"), 1);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"verbose\"), 1);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_long2() {\n-        let args = vec!(\"--verbose\".to_string(), \"--verbose\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"--verbose\".to_string(), \"--verbose\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"verbose\"), 2);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"verbose\"), 2);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_mix() {\n-        let args = vec!(\"--verbose\".to_string(), \"-v\".to_string(),\n-                        \"-vv\".to_string(), \"verbose\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"--verbose\".to_string(),\n+                        \"-v\".to_string(),\n+                        \"-vv\".to_string(),\n+                        \"verbose\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"verbose\"), 4);\n-            assert_eq!(m.opt_count(\"v\"), 4);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"verbose\"), 4);\n+                assert_eq!(m.opt_count(\"v\"), 4);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     // Tests for optmulti\n     #[test]\n     fn test_optmulti() {\n-        let long_args = vec!(\"--test=20\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test=20\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!((m.opt_present(\"test\")));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Ok(ref m) => {\n-            assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!((m.opt_present(\"test\")));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optmulti_missing() {\n-        let args = vec!(\"blah\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"blah\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(!m.opt_present(\"test\"));\n-            assert!(!m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(!m.opt_present(\"test\"));\n+                assert!(!m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optmulti_no_arg() {\n-        let long_args = vec!(\"--test\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string());\n+        let short_args = vec![\"-t\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optmulti_multi() {\n-        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-              assert!(m.opt_present(\"test\"));\n-              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-              assert!(m.opt_present(\"t\"));\n-              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-              let pair = m.opt_strs(\"test\");\n-              assert!(pair[0] == \"20\");\n-              assert!(pair[1] == \"30\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!(m.opt_present(\"t\"));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+                let pair = m.opt_strs(\"test\");\n+                assert!(pair[0] == \"20\");\n+                assert!(pair[1] == \"30\");\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_unrecognized_option() {\n-        let long_args = vec!(\"--untest\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--untest\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Err(UnrecognizedOption(_)) => {},\n-          _ => panic!()\n+            Err(UnrecognizedOption(_)) => {}\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-u\".to_string());\n+        let short_args = vec![\"-u\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Err(UnrecognizedOption(_)) => {},\n-          _ => panic!()\n+            Err(UnrecognizedOption(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_combined() {\n-        let args =\n-            vec!(\"prog\".to_string(),\n-                 \"free1\".to_string(),\n-                 \"-s\".to_string(),\n-                 \"20\".to_string(),\n-                 \"free2\".to_string(),\n-                 \"--flag\".to_string(),\n-                 \"--long=30\".to_string(),\n-                 \"-f\".to_string(),\n-                 \"-m\".to_string(),\n-                 \"40\".to_string(),\n-                 \"-m\".to_string(),\n-                 \"50\".to_string(),\n-                 \"-n\".to_string(),\n-                 \"-A B\".to_string(),\n-                 \"-n\".to_string(),\n-                 \"-60 70\".to_string());\n-        let opts =\n-            vec!(optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n-              optflag(\"\", \"flag\", \"a flag\"),\n-              reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n-              optflag(\"f\", \"\", \"another flag\"),\n-              optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n-              optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n-              optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\"));\n+        let args = vec![\"prog\".to_string(),\n+                        \"free1\".to_string(),\n+                        \"-s\".to_string(),\n+                        \"20\".to_string(),\n+                        \"free2\".to_string(),\n+                        \"--flag\".to_string(),\n+                        \"--long=30\".to_string(),\n+                        \"-f\".to_string(),\n+                        \"-m\".to_string(),\n+                        \"40\".to_string(),\n+                        \"-m\".to_string(),\n+                        \"50\".to_string(),\n+                        \"-n\".to_string(),\n+                        \"-A B\".to_string(),\n+                        \"-n\".to_string(),\n+                        \"-60 70\".to_string()];\n+        let opts = vec![optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n+                        optflag(\"\", \"flag\", \"a flag\"),\n+                        reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n+                        optflag(\"f\", \"\", \"another flag\"),\n+                        optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n+                        optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n+                        optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(m.free[0] == \"prog\");\n-            assert!(m.free[1] == \"free1\");\n-            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n-            assert!(m.free[2] == \"free2\");\n-            assert!((m.opt_present(\"flag\")));\n-            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n-            assert!((m.opt_present(\"f\")));\n-            let pair = m.opt_strs(\"m\");\n-            assert!(pair[0] == \"40\");\n-            assert!(pair[1] == \"50\");\n-            let pair = m.opt_strs(\"n\");\n-            assert!(pair[0] == \"-A B\");\n-            assert!(pair[1] == \"-60 70\");\n-            assert!((!m.opt_present(\"notpresent\")));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.free[0] == \"prog\");\n+                assert!(m.free[1] == \"free1\");\n+                assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n+                assert!(m.free[2] == \"free2\");\n+                assert!((m.opt_present(\"flag\")));\n+                assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n+                assert!((m.opt_present(\"f\")));\n+                let pair = m.opt_strs(\"m\");\n+                assert!(pair[0] == \"40\");\n+                assert!(pair[1] == \"50\");\n+                let pair = m.opt_strs(\"n\");\n+                assert!(pair[0] == \"-A B\");\n+                assert!(pair[1] == \"-60 70\");\n+                assert!((!m.opt_present(\"notpresent\")));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_multi() {\n-        let opts = vec!(optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n-                     optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n-                     optopt(\"f\", \"\", \"flag\", \"FLAG\"));\n+        let opts = vec![optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n+                        optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n+                        optopt(\"f\", \"\", \"flag\", \"FLAG\")];\n \n-        let args_single = vec!(\"-e\".to_string(), \"foo\".to_string());\n+        let args_single = vec![\"-e\".to_string(), \"foo\".to_string()];\n         let matches_single = &match getopts(&args_single, &opts) {\n-          result::Result::Ok(m) => m,\n-          result::Result::Err(_) => panic!()\n+            result::Result::Ok(m) => m,\n+            result::Result::Err(_) => panic!(),\n         };\n         assert!(matches_single.opts_present(&[\"e\".to_string()]));\n         assert!(matches_single.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n@@ -1422,11 +1441,13 @@ mod tests {\n         assert_eq!(matches_single.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n                    \"foo\");\n \n-        let args_both = vec!(\"-e\".to_string(), \"foo\".to_string(), \"--encrypt\".to_string(),\n-                             \"foo\".to_string());\n+        let args_both = vec![\"-e\".to_string(),\n+                             \"foo\".to_string(),\n+                             \"--encrypt\".to_string(),\n+                             \"foo\".to_string()];\n         let matches_both = &match getopts(&args_both, &opts) {\n-          result::Result::Ok(m) => m,\n-          result::Result::Err(_) => panic!()\n+            result::Result::Ok(m) => m,\n+            result::Result::Err(_) => panic!(),\n         };\n         assert!(matches_both.opts_present(&[\"e\".to_string()]));\n         assert!(matches_both.opts_present(&[\"encrypt\".to_string()]));\n@@ -1437,7 +1458,8 @@ mod tests {\n         assert!(!matches_both.opts_present(&[]));\n \n         assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(), \"foo\");\n+        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(),\n+                   \"foo\");\n         assert_eq!(matches_both.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n                    \"foo\");\n         assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n@@ -1446,12 +1468,12 @@ mod tests {\n \n     #[test]\n     fn test_nospace() {\n-        let args = vec!(\"-Lfoo\".to_string(), \"-M.\".to_string());\n-        let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                     optmulti(\"M\", \"\", \"something\", \"MMMM\"));\n+        let args = vec![\"-Lfoo\".to_string(), \"-M.\".to_string()];\n+        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n+                        optmulti(\"M\", \"\", \"something\", \"MMMM\")];\n         let matches = &match getopts(&args, &opts) {\n-          result::Result::Ok(m) => m,\n-          result::Result::Err(_) => panic!()\n+            result::Result::Ok(m) => m,\n+            result::Result::Err(_) => panic!(),\n         };\n         assert!(matches.opts_present(&[\"L\".to_string()]));\n         assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\");\n@@ -1462,12 +1484,12 @@ mod tests {\n \n     #[test]\n     fn test_nospace_conflict() {\n-        let args = vec!(\"-vvLverbose\".to_string(), \"-v\".to_string() );\n-        let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                     optflagmulti(\"v\", \"verbose\", \"Verbose\"));\n+        let args = vec![\"-vvLverbose\".to_string(), \"-v\".to_string()];\n+        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n+                        optflagmulti(\"v\", \"verbose\", \"Verbose\")];\n         let matches = &match getopts(&args, &opts) {\n-          result::Result::Ok(m) => m,\n-          result::Result::Err(e) => panic!( \"{}\", e )\n+            result::Result::Ok(m) => m,\n+            result::Result::Err(e) => panic!(\"{}\", e),\n         };\n         assert!(matches.opts_present(&[\"L\".to_string()]));\n         assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\");\n@@ -1483,21 +1505,22 @@ mod tests {\n             occur: Occur::Req,\n             aliases: Vec::new(),\n         };\n-        short.aliases = vec!(Opt { name: Name::Short('b'),\n-                                hasarg: HasArg::Yes,\n-                                occur: Occur::Req,\n-                                aliases: Vec::new() });\n+        short.aliases = vec![Opt {\n+                                 name: Name::Short('b'),\n+                                 hasarg: HasArg::Yes,\n+                                 occur: Occur::Req,\n+                                 aliases: Vec::new(),\n+                             }];\n         let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert!(verbose.long_to_short() == short);\n     }\n \n     #[test]\n     fn test_aliases_long_and_short() {\n-        let opts = vec!(\n-            optflagmulti(\"a\", \"apple\", \"Desc\"));\n+        let opts = vec![optflagmulti(\"a\", \"apple\", \"Desc\")];\n \n-        let args = vec!(\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string());\n+        let args = vec![\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string()];\n \n         let matches = getopts(&args, &opts).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n@@ -1506,13 +1529,11 @@ mod tests {\n \n     #[test]\n     fn test_usage() {\n-        let optgroups = vec!(\n-            reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            optopt(\"a\", \"012345678901234567890123456789\",\n-                             \"Desc\", \"VAL\"),\n-            optflag(\"k\", \"kiwi\", \"Desc\"),\n-            optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n+        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n+                             optflag(\"k\", \"kiwi\", \"Desc\"),\n+                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n \n         let expected =\n \"Usage: fruits\n@@ -1538,11 +1559,13 @@ Options:\n         // indentation should be 24 spaces\n         // lines wrap after 78: or rather descriptions wrap after 54\n \n-        let optgroups = vec!(\n-            optflag(\"k\", \"kiwi\",\n-                \"This is a long description which won't be wrapped..+..\"), // 54\n-            optflag(\"a\", \"apple\",\n-                \"This is a long description which _will_ be wrapped..+..\"));\n+        let optgroups = vec![optflag(\"k\",\n+                                     \"kiwi\",\n+                                     // 54\n+                                     \"This is a long description which won't be wrapped..+..\"),\n+                             optflag(\"a\",\n+                                     \"apple\",\n+                                     \"This is a long description which _will_ be wrapped..+..\")];\n \n         let expected =\n \"Usage: fruits\n@@ -1562,12 +1585,14 @@ Options:\n \n     #[test]\n     fn test_usage_description_multibyte_handling() {\n-        let optgroups = vec!(\n-            optflag(\"k\", \"k\\u{2013}w\\u{2013}\",\n-                \"The word kiwi is normally spelled with two i's\"),\n-            optflag(\"a\", \"apple\",\n-                \"This \\u{201C}description\\u{201D} has some characters that could \\\n-confuse the line wrapping; an apple costs 0.51\u20ac in some parts of Europe.\"));\n+        let optgroups = vec![optflag(\"k\",\n+                                     \"k\\u{2013}w\\u{2013}\",\n+                                     \"The word kiwi is normally spelled with two i's\"),\n+                             optflag(\"a\",\n+                                     \"apple\",\n+                                     \"This \\u{201C}description\\u{201D} has some characters that \\\n+                                      could confuse the line wrapping; an apple costs 0.51\u20ac in \\\n+                                      some parts of Europe.\")];\n \n         let expected =\n \"Usage: fruits\n@@ -1588,13 +1613,11 @@ Options:\n \n     #[test]\n     fn test_short_usage() {\n-        let optgroups = vec!(\n-            reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            optopt(\"a\", \"012345678901234567890123456789\",\n-                     \"Desc\", \"VAL\"),\n-            optflag(\"k\", \"kiwi\", \"Desc\"),\n-            optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n+        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n+                             optflag(\"k\", \"kiwi\", \"Desc\"),\n+                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n \n         let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_string();\n         let generated_usage = short_usage(\"fruits\", &optgroups);"}, {"sha": "14a8d78c0b264d0b468a3ca53774d60fa453faa3", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -416,10 +416,10 @@ impl<'a> Id<'a> {\n                 _ => return Err(()),\n             }\n             if !chars.all(is_constituent) {\n-                return Err(())\n+                return Err(());\n             }\n         }\n-        return Ok(Id{ name: name });\n+        return Ok(Id { name: name });\n \n         fn is_letter_or_underscore(c: char) -> bool {\n             in_range('a', c, 'z') || in_range('A', c, 'Z') || c == '_'\n@@ -496,11 +496,10 @@ pub trait Labeller<'a,N,E> {\n /// Escape tags in such a way that it is suitable for inclusion in a\n /// Graphviz HTML label.\n pub fn escape_html(s: &str) -> String {\n-    s\n-        .replace(\"&\", \"&amp;\")\n-        .replace(\"\\\"\", \"&quot;\")\n-        .replace(\"<\", \"&lt;\")\n-        .replace(\">\", \"&gt;\")\n+    s.replace(\"&\", \"&amp;\")\n+     .replace(\"\\\"\", \"&quot;\")\n+     .replace(\"<\", \"&lt;\")\n+     .replace(\">\", \"&gt;\")\n }\n \n impl<'a> LabelText<'a> {\n@@ -523,9 +522,11 @@ impl<'a> LabelText<'a> {\n             // not escaping \\\\, since Graphviz escString needs to\n             // interpret backslashes; see EscStr above.\n             '\\\\' => f(c),\n-            _ => for c in c.escape_default() {\n-                f(c)\n-            },\n+            _ => {\n+                for c in c.escape_default() {\n+                    f(c)\n+                }\n+            }\n         }\n     }\n     fn escape_str(s: &str) -> String {\n@@ -553,11 +554,13 @@ impl<'a> LabelText<'a> {\n     fn pre_escaped_content(self) -> Cow<'a, str> {\n         match self {\n             EscStr(s) => s,\n-            LabelStr(s) => if s.contains('\\\\') {\n-                (&*s).escape_default().into_cow()\n-            } else {\n-                s\n-            },\n+            LabelStr(s) => {\n+                if s.contains('\\\\') {\n+                    (&*s).escape_default().into_cow()\n+                } else {\n+                    s\n+                }\n+            }\n             HtmlStr(s) => s,\n         }\n     }\n@@ -738,7 +741,12 @@ mod tests {\n     }\n \n     fn edge(from: usize, to: usize, label: &'static str, style: Style) -> Edge {\n-        Edge { from: from, to: to, label: label, style: style }\n+        Edge {\n+            from: from,\n+            to: to,\n+            label: label,\n+            style: style,\n+        }\n     }\n \n     struct LabelledGraph {\n@@ -1009,7 +1017,7 @@ r#\"digraph single_cyclic_node {\n \n     #[test]\n     fn hasse_diagram() {\n-        let labels = AllNodesLabelled(vec!(\"{x,y}\", \"{x}\", \"{y}\", \"{}\"));\n+        let labels = AllNodesLabelled(vec![\"{x,y}\", \"{x}\", \"{y}\", \"{}\"]);\n         let r = test_input(LabelledGraph::new(\"hasse_diagram\",\n                                               labels,\n                                               vec![edge(0, 1, \"\", Style::None),\n@@ -1033,7 +1041,7 @@ r#\"digraph hasse_diagram {\n \n     #[test]\n     fn left_aligned_text() {\n-        let labels = AllNodesLabelled(vec!(\n+        let labels = AllNodesLabelled(vec![\n             \"if test {\\\n            \\\\l    branch1\\\n            \\\\l} else {\\\n@@ -1043,7 +1051,7 @@ r#\"digraph hasse_diagram {\n            \\\\l\",\n             \"branch1\",\n             \"branch2\",\n-            \"afterward\"));\n+            \"afterward\"]);\n \n         let mut writer = Vec::new();\n "}, {"sha": "18163703e88ba8516abd69d669412c1b17791dce", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -49,7 +49,7 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n     if let Some(m) = mods {\n         for s in m.split(',') {\n             if s.is_empty() {\n-                continue\n+                continue;\n             }\n             let mut parts = s.split('=');\n             let (log_level, name) = match (parts.next(),\n@@ -69,13 +69,13 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n                         Some(num) => (num, Some(part0)),\n                         _ => {\n                             println!(\"warning: invalid logging spec '{}', ignoring it\", part1);\n-                            continue\n+                            continue;\n                         }\n                     }\n                 }\n                 _ => {\n                     println!(\"warning: invalid logging spec '{}', ignoring it\", s);\n-                    continue\n+                    continue;\n                 }\n             };\n             dirs.push(LogDirective {"}, {"sha": "850c5511dd57d49b12e8d1fa4bda1d86b266f497", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -296,7 +296,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n             n => {\n                 let filter = mem::transmute::<_, &String>(n);\n                 if !args.to_string().contains(filter) {\n-                    return\n+                    return;\n                 }\n             }\n         }\n@@ -375,7 +375,7 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     // check being expanded manually in the logging macro, this function checks\n     // the log level again.\n     if level > unsafe { LOG_LEVEL } {\n-        return false\n+        return false;\n     }\n \n     // This assertion should never get tripped unless we're in an at_exit\n@@ -393,9 +393,7 @@ fn enabled(level: u32, module: &str, iter: slice::Iter<directive::LogDirective>)\n     for directive in iter.rev() {\n         match directive.name {\n             Some(ref name) if !module.starts_with(&name[..]) => {}\n-            Some(..) | None => {\n-                return level <= directive.level\n-            }\n+            Some(..) | None => return level <= directive.level,\n         }\n     }\n     level <= DEFAULT_LOG_LEVEL"}, {"sha": "e2c157f98a6a4d2b11ed1e5fc9fe90ab1c9ec9bc", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -12,8 +12,8 @@\n \n use {Rng, SeedableRng, Rand};\n \n-const KEY_WORDS    : usize =  8; // 8 words for the 256-bit key\n-const STATE_WORDS  : usize = 16;\n+const KEY_WORDS: usize = 8; // 8 words for the 256-bit key\n+const STATE_WORDS: usize = 16;\n const CHACHA_ROUNDS: usize = 20; // Cryptographically secure from 8 upwards as of this writing\n \n /// A random number generator that uses the ChaCha20 algorithm [1].\n@@ -77,7 +77,6 @@ fn core(output: &mut [u32; STATE_WORDS], input: &[u32; STATE_WORDS]) {\n }\n \n impl ChaChaRng {\n-\n     /// Create an ChaCha random number generator using the default\n     /// fixed key of 8 zero words.\n     pub fn new_unseeded() -> ChaChaRng {\n@@ -173,7 +172,6 @@ impl Rng for ChaChaRng {\n }\n \n impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n-\n     fn reseed(&mut self, seed: &'a [u32]) {\n         // reset state\n         self.init(&[0; KEY_WORDS]);"}, {"sha": "8cd7ac06f991bda5fc35f645fd7f8f68730d883d", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -89,7 +89,7 @@ impl Gamma {\n \n         let repr = match shape {\n             1.0 => One(Exp::new(1.0 / scale)),\n-            0.0 ... 1.0 => Small(GammaSmallShape::new_raw(shape, scale)),\n+            0.0...1.0 => Small(GammaSmallShape::new_raw(shape, scale)),\n             _ => Large(GammaLargeShape::new_raw(shape, scale)),\n         };\n         Gamma { repr: repr }\n@@ -153,7 +153,8 @@ impl IndependentSample<f64> for GammaLargeShape {\n         loop {\n             let StandardNormal(x) = rng.gen::<StandardNormal>();\n             let v_cbrt = 1.0 + self.c * x;\n-            if v_cbrt <= 0.0 { // a^3 <= 0 iff a <= 0\n+            if v_cbrt <= 0.0 {\n+                // a^3 <= 0 iff a <= 0\n                 continue;\n             }\n "}, {"sha": "a54c8df2352ac363b6ac519d350bb651cf2ed0b2", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -118,8 +118,10 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         for item in &mut *items {\n             running_total = match running_total.checked_add(item.weight) {\n                 Some(n) => n,\n-                None => panic!(\"WeightedChoice::new called with a total weight larger than a \\\n-                                usize can contain\"),\n+                None => {\n+                    panic!(\"WeightedChoice::new called with a total weight larger than a usize \\\n+                            can contain\")\n+                }\n             };\n \n             item.weight = running_total;\n@@ -199,7 +201,6 @@ mod ziggurat_tables;\n /// * `pdf`: the probability density function\n /// * `zero_case`: manual sampling from the tail when we chose the\n ///    bottom box (i.e. i == 0)\n-\n // the perf improvement (25-50%) is definitely worth the extra code\n // size from force-inlining.\n #[inline(always)]"}, {"sha": "1f56a82eba86eea72dfe576f32a2fe42254a4b41", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -54,7 +54,6 @@ static EMPTY: IsaacRng = IsaacRng {\n };\n \n impl IsaacRng {\n-\n     /// Create an ISAAC random number generator using the default\n     /// fixed seed.\n     pub fn new_unseeded() -> IsaacRng {\n@@ -403,7 +402,7 @@ impl Isaac64Rng {\n         // abbreviations\n         let mut a = self.a;\n         let mut b = self.b + self.c;\n-        const MIDPOINT: usize =  RAND_SIZE_64 / 2;\n+        const MIDPOINT: usize = RAND_SIZE_64 / 2;\n         const MP_VEC: [(usize, usize); 2] = [(0, MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind {\n             ($x:expr) => {"}, {"sha": "247dcd03b5d7abbd04ffe3f1ea76168bebcc9d12", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -306,10 +306,9 @@ impl<'a, R: Rng> Iterator for AsciiGenerator<'a, R> {\n     type Item = char;\n \n     fn next(&mut self) -> Option<char> {\n-        const GEN_ASCII_STR_CHARSET: &'static [u8] =\n-            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-              abcdefghijklmnopqrstuvwxyz\\\n-              0123456789\";\n+        const GEN_ASCII_STR_CHARSET: &'static [u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+                                                       abcdefghijklmnopqrstuvwxyz\\\n+                                                       0123456789\";\n         Some(*self.rng.choose(GEN_ASCII_STR_CHARSET).unwrap() as char)\n     }\n }"}, {"sha": "34b7f37a6788f98f2023edc20898809d454ed2c0", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb6531903c4e425f48a859463bee20cfcc7f7c5/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=5fb6531903c4e425f48a859463bee20cfcc7f7c5", "patch": "@@ -202,7 +202,7 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n \n-impl<T:Rand> Rand for Option<T> {\n+impl<T: Rand> Rand for Option<T> {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n         if rng.gen() {"}]}