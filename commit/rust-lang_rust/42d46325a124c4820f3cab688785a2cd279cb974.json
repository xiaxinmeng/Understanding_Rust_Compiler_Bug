{"sha": "42d46325a124c4820f3cab688785a2cd279cb974", "node_id": "C_kwDOAAsO6NoAKDQyZDQ2MzI1YTEyNGM0ODIwZjNjYWI2ODg3ODVhMmNkMjc5Y2I5NzQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-08T20:41:19Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-08T20:50:00Z"}, "message": "Add MacroId to hir_def in attempt to unify Macros with ModuleDefId", "tree": {"sha": "75ca64c259c9025afc12da22bbc2b6d1ec9eb93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75ca64c259c9025afc12da22bbc2b6d1ec9eb93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42d46325a124c4820f3cab688785a2cd279cb974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42d46325a124c4820f3cab688785a2cd279cb974", "html_url": "https://github.com/rust-lang/rust/commit/42d46325a124c4820f3cab688785a2cd279cb974", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42d46325a124c4820f3cab688785a2cd279cb974/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d425c5b5345a20c27bd13ca48ce08a64445c8657", "url": "https://api.github.com/repos/rust-lang/rust/commits/d425c5b5345a20c27bd13ca48ce08a64445c8657", "html_url": "https://github.com/rust-lang/rust/commit/d425c5b5345a20c27bd13ca48ce08a64445c8657"}], "stats": {"total": 601, "additions": 386, "deletions": 215}, "files": [{"sha": "71375fe4a6e51d4ee9157d1dfac396f457db180a", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -13,7 +13,7 @@ use drop_bomb::DropBomb;\n use either::Either;\n use hir_expand::{\n     ast_id_map::AstIdMap, hygiene::Hygiene, AstId, ExpandError, ExpandResult, HirFileId, InFile,\n-    MacroCallId, MacroDefId,\n+    MacroCallId,\n };\n use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n@@ -26,10 +26,11 @@ use crate::{\n     db::DefDatabase,\n     expr::{Expr, ExprId, Label, LabelId, Pat, PatId},\n     item_scope::BuiltinShadowMode,\n+    macro_id_to_def_id,\n     nameres::DefMap,\n     path::{ModPath, Path},\n     src::HasSource,\n-    AsMacroCall, BlockId, DefWithBodyId, HasModule, LocalModuleId, Lookup, ModuleId,\n+    AsMacroCall, BlockId, DefWithBodyId, HasModule, LocalModuleId, Lookup, MacroId, ModuleId,\n     UnresolvedMacro,\n };\n \n@@ -105,7 +106,7 @@ impl Expander {\n         let macro_call = InFile::new(self.current_file_id, &macro_call);\n \n         let resolver =\n-            |path: ModPath| -> Option<MacroDefId> { self.resolve_path_as_macro(db, &path) };\n+            |path| self.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n \n         let mut err = None;\n         let call_id =\n@@ -208,7 +209,7 @@ impl Expander {\n         Path::from_src(path, &ctx)\n     }\n \n-    fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n+    fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n         self.def_map.resolve_path(db, self.module, path, BuiltinShadowMode::Other).0.take_macros()\n     }\n "}, {"sha": "e04d26fbab354a4b42b3ea4d64ecc23d3346c61b", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -14,8 +14,8 @@ use crate::{\n     item_scope::ItemScope,\n     keys,\n     src::{HasChildSource, HasSource},\n-    AdtId, AssocItemId, DefWithBodyId, EnumId, EnumVariantId, FieldId, ImplId, Lookup, ModuleDefId,\n-    ModuleId, TraitId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumId, EnumVariantId, FieldId, ImplId, Lookup, MacroId,\n+    ModuleDefId, ModuleId, TraitId, VariantId,\n };\n \n pub trait ChildBySource {\n@@ -97,17 +97,6 @@ impl ChildBySource for ItemScope {\n                 res[keys::CONST].insert(loc.source(db).value, konst);\n             }\n         });\n-        self.macros().for_each(|(_, makro)| {\n-            let ast_id = makro.ast_id();\n-            if ast_id.either(|it| it.file_id, |it| it.file_id) == file_id {\n-                let src = match ast_id {\n-                    Either::Left(ast_id) => ast_id.to_node(db.upcast()),\n-                    // FIXME: Do we need to add proc-macros into a PROCMACRO dynmap here?\n-                    Either::Right(_fn) => return,\n-                };\n-                res[keys::MACRO].insert(src, makro);\n-            }\n-        });\n         self.attr_macro_invocs().filter(|(id, _)| id.file_id == file_id).for_each(\n             |(ast_id, call_id)| {\n                 res[keys::ATTR_MACRO_CALL].insert(ast_id.to_node(db.upcast()), call_id);\n@@ -151,6 +140,11 @@ impl ChildBySource for ItemScope {\n                     AdtId::UnionId(id) => insert!(map[keys::UNION].insert(id)),\n                     AdtId::EnumId(id) => insert!(map[keys::ENUM].insert(id)),\n                 },\n+                ModuleDefId::MacroId(id) => match id {\n+                    MacroId::Macro2Id(id) => insert!(map[keys::MACRO2].insert(id)),\n+                    MacroId::MacroRulesId(id) => insert!(map[keys::MACRO_RULES].insert(id)),\n+                    MacroId::ProcMacroId(id) => insert!(map[keys::PROC_MACRO].insert(id)),\n+                },\n                 _ => (),\n             }\n         }"}, {"sha": "830ef776923e6b484207c57eac0a70bb309e4790", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -21,8 +21,9 @@ use crate::{\n     visibility::{self, Visibility},\n     AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n     ExternBlockLoc, FunctionId, FunctionLoc, GenericDefId, ImplId, ImplLoc, LocalEnumVariantId,\n-    LocalFieldId, StaticId, StaticLoc, StructId, StructLoc, TraitId, TraitLoc, TypeAliasId,\n-    TypeAliasLoc, UnionId, UnionLoc, VariantId,\n+    LocalFieldId, Macro2Id, Macro2Loc, MacroRulesId, MacroRulesLoc, ProcMacroId, ProcMacroLoc,\n+    StaticId, StaticLoc, StructId, StructLoc, TraitId, TraitLoc, TypeAliasId, TypeAliasLoc,\n+    UnionId, UnionLoc, VariantId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -49,6 +50,12 @@ pub trait InternDatabase: SourceDatabase {\n     fn intern_extern_block(&self, loc: ExternBlockLoc) -> ExternBlockId;\n     #[salsa::interned]\n     fn intern_block(&self, loc: BlockLoc) -> BlockId;\n+    #[salsa::interned]\n+    fn intern_macro2(&self, loc: Macro2Loc) -> Macro2Id;\n+    #[salsa::interned]\n+    fn intern_proc_macro(&self, loc: ProcMacroLoc) -> ProcMacroId;\n+    #[salsa::interned]\n+    fn intern_macro_rules(&self, loc: MacroRulesLoc) -> MacroRulesId;\n }\n \n #[salsa::query_group(DefDatabaseStorage)]"}, {"sha": "e1e5ded52a6ddea45c15531184db32c169ef6c3b", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -98,6 +98,7 @@ impl PrefixKind {\n     }\n }\n \n+/// Attempts to find a path to refer to the given `item` visible from the `from` ModuleId\n fn find_path_inner(\n     db: &dyn DefDatabase,\n     item: ItemInNs,"}, {"sha": "0cca14a9f20d350e4b5a5dec7e65bb420d4de019", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -271,6 +271,7 @@ pub enum ImportKind {\n     TypeAlias,\n     BuiltinType,\n     AssociatedItem,\n+    Macro,\n }\n \n /// A way to match import map contents against the search query.\n@@ -464,6 +465,7 @@ fn item_import_kind(item: ItemInNs) -> Option<ImportKind> {\n         ModuleDefId::TraitId(_) => ImportKind::Trait,\n         ModuleDefId::TypeAliasId(_) => ImportKind::TypeAlias,\n         ModuleDefId::BuiltinType(_) => ImportKind::BuiltinType,\n+        ModuleDefId::MacroId(_) => ImportKind::Macro,\n     })\n }\n "}, {"sha": "1293319561b3e553715861ac4559a9789745a726", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -4,7 +4,7 @@\n use std::collections::hash_map::Entry;\n \n use base_db::CrateId;\n-use hir_expand::{name::Name, AstId, MacroCallId, MacroDefKind};\n+use hir_expand::{name::Name, AstId, MacroCallId};\n use once_cell::sync::Lazy;\n use profile::Count;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -14,7 +14,8 @@ use syntax::ast;\n \n use crate::{\n     attr::AttrId, db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType,\n-    ConstId, ImplId, LocalModuleId, MacroDefId, ModuleDefId, ModuleId, TraitId,\n+    ConstId, HasModule, ImplId, LocalModuleId, MacroId, MacroRulesId, ModuleDefId, ModuleId,\n+    TraitId,\n };\n \n #[derive(Copy, Clone)]\n@@ -38,13 +39,13 @@ pub struct ItemScope {\n     /// imports.\n     types: FxHashMap<Name, (ModuleDefId, Visibility)>,\n     values: FxHashMap<Name, (ModuleDefId, Visibility)>,\n-    macros: FxHashMap<Name, (MacroDefId, Visibility)>,\n+    macros: FxHashMap<Name, (MacroId, Visibility)>,\n     unresolved: FxHashSet<Name>,\n \n     /// The defs declared in this scope. Each def has a single scope where it is\n     /// declared.\n     declarations: Vec<ModuleDefId>,\n-    macro_declarations: Vec<MacroDefId>,\n+    macro_declarations: Vec<MacroId>,\n \n     impls: Vec<ImplId>,\n     unnamed_consts: Vec<ConstId>,\n@@ -62,7 +63,7 @@ pub struct ItemScope {\n     /// Module scoped macros will be inserted into `items` instead of here.\n     // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n     // be all resolved to the last one defined if shadowing happens.\n-    legacy_macros: FxHashMap<Name, MacroDefId>,\n+    legacy_macros: FxHashMap<Name, MacroRulesId>,\n     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,\n     /// The derive macro invocations in this scope, keyed by the owner item over the actual derive attributes\n     /// paired with the derive macro invocations for the specific attribute.\n@@ -108,7 +109,7 @@ impl ItemScope {\n         self.declarations.iter().copied()\n     }\n \n-    pub fn macro_declarations(&self) -> impl Iterator<Item = MacroDefId> + '_ {\n+    pub fn macro_declarations(&self) -> impl Iterator<Item = MacroId> + '_ {\n         self.macro_declarations.iter().copied()\n     }\n \n@@ -127,12 +128,14 @@ impl ItemScope {\n     }\n \n     /// Iterate over all module scoped macros\n-    pub(crate) fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+    pub(crate) fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroId)> + 'a {\n         self.entries().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n     }\n \n     /// Iterate over all legacy textual scoped macros visible at the end of the module\n-    pub(crate) fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+    pub(crate) fn legacy_macros<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (&'a Name, MacroRulesId)> + 'a {\n         self.legacy_macros.iter().map(|(name, def)| (name, *def))\n     }\n \n@@ -163,8 +166,8 @@ impl ItemScope {\n     pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n         self.types\n             .values()\n-            .filter_map(|(def, _)| match def {\n-                ModuleDefId::TraitId(t) => Some(*t),\n+            .filter_map(|&(def, _)| match def {\n+                ModuleDefId::TraitId(t) => Some(t),\n                 _ => None,\n             })\n             .chain(self.unnamed_trait_imports.keys().copied())\n@@ -174,11 +177,11 @@ impl ItemScope {\n         self.declarations.push(def)\n     }\n \n-    pub(crate) fn declare_macro(&mut self, def: MacroDefId) {\n+    pub(crate) fn declare_macro(&mut self, def: MacroId) {\n         self.macro_declarations.push(def);\n     }\n \n-    pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n+    pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroRulesId> {\n         self.legacy_macros.get(name).copied()\n     }\n \n@@ -190,7 +193,7 @@ impl ItemScope {\n         self.unnamed_consts.push(konst);\n     }\n \n-    pub(crate) fn define_legacy_macro(&mut self, name: Name, mac: MacroDefId) {\n+    pub(crate) fn define_legacy_macro(&mut self, name: Name, mac: MacroRulesId) {\n         self.legacy_macros.insert(name, mac);\n     }\n \n@@ -320,7 +323,7 @@ impl ItemScope {\n         )\n     }\n \n-    pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {\n+    pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroRulesId> {\n         self.legacy_macros.clone()\n     }\n \n@@ -334,7 +337,7 @@ impl ItemScope {\n             .for_each(|vis| *vis = Visibility::Module(this_module));\n \n         for (mac, vis) in self.macros.values_mut() {\n-            if let MacroDefKind::ProcMacro(..) = mac.kind {\n+            if let MacroId::ProcMacroId(_) = mac {\n                 // FIXME: Technically this is insufficient since reexports of proc macros are also\n                 // forbidden. Practically nobody does that.\n                 continue;\n@@ -421,6 +424,7 @@ impl PerNs {\n             ModuleDefId::TraitId(_) => PerNs::types(def, v),\n             ModuleDefId::TypeAliasId(_) => PerNs::types(def, v),\n             ModuleDefId::BuiltinType(_) => PerNs::types(def, v),\n+            ModuleDefId::MacroId(mac) => PerNs::macros(mac, v),\n         }\n     }\n }\n@@ -429,7 +433,7 @@ impl PerNs {\n pub enum ItemInNs {\n     Types(ModuleDefId),\n     Values(ModuleDefId),\n-    Macros(MacroDefId),\n+    Macros(MacroId),\n }\n \n impl ItemInNs {\n@@ -444,7 +448,7 @@ impl ItemInNs {\n     pub fn krate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n         match self {\n             ItemInNs::Types(did) | ItemInNs::Values(did) => did.module(db).map(|m| m.krate),\n-            ItemInNs::Macros(id) => Some(id.krate),\n+            ItemInNs::Macros(id) => Some(id.module(db).krate),\n         }\n     }\n }"}, {"sha": "c5cb9a2af53747feb22f6180d64906a4cc22cd56", "filename": "crates/hir_def/src/keys.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fkeys.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -2,15 +2,16 @@\n \n use std::marker::PhantomData;\n \n-use hir_expand::{MacroCallId, MacroDefId};\n+use hir_expand::MacroCallId;\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstNode, AstPtr};\n \n use crate::{\n     attr::AttrId,\n     dyn_map::{DynMap, Policy},\n-    ConstId, EnumId, EnumVariantId, FieldId, FunctionId, ImplId, LifetimeParamId, StaticId,\n-    StructId, TraitId, TypeAliasId, TypeOrConstParamId, UnionId,\n+    ConstId, EnumId, EnumVariantId, FieldId, FunctionId, ImplId, LifetimeParamId, Macro2Id,\n+    MacroRulesId, ProcMacroId, StaticId, StructId, TraitId, TypeAliasId, TypeOrConstParamId,\n+    UnionId,\n };\n \n pub type Key<K, V> = crate::dyn_map::Key<K, V, AstPtrPolicy<K, V>>;\n@@ -32,7 +33,9 @@ pub const TYPE_PARAM: Key<ast::TypeParam, TypeOrConstParamId> = Key::new();\n pub const CONST_PARAM: Key<ast::ConstParam, TypeOrConstParamId> = Key::new();\n pub const LIFETIME_PARAM: Key<ast::LifetimeParam, LifetimeParamId> = Key::new();\n \n-pub const MACRO: Key<ast::Macro, MacroDefId> = Key::new();\n+pub const MACRO_RULES: Key<ast::MacroRules, MacroRulesId> = Key::new();\n+pub const MACRO2: Key<ast::MacroDef, Macro2Id> = Key::new();\n+pub const PROC_MACRO: Key<ast::Fn, ProcMacroId> = Key::new();\n pub const ATTR_MACRO_CALL: Key<ast::Item, MacroCallId> = Key::new();\n pub const DERIVE_MACRO_CALL: Key<ast::Attr, (AttrId, MacroCallId, Box<[Option<MacroCallId>]>)> =\n     Key::new();"}, {"sha": "481a69c5b102edc27b8c53c0f555de96e820fcc5", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 150, "deletions": 5, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -58,11 +58,15 @@ use std::{\n };\n \n use attr::Attr;\n-use base_db::{impl_intern_key, salsa, CrateId};\n+use base_db::{impl_intern_key, salsa, CrateId, ProcMacroKind};\n use hir_expand::{\n     ast_id_map::FileAstId,\n+    builtin_attr_macro::BuiltinAttrExpander,\n+    builtin_derive_macro::BuiltinDeriveExpander,\n+    builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n     eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n     hygiene::Hygiene,\n+    proc_macro::ProcMacroExpander,\n     AstId, ExpandError, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,\n     MacroDefKind, UnresolvedMacro,\n };\n@@ -77,8 +81,8 @@ use crate::{\n     attr::AttrId,\n     builtin_type::BuiltinType,\n     item_tree::{\n-        Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, ModItem, Static, Struct, Trait,\n-        TypeAlias, Union,\n+        Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, MacroDef, MacroRules, ModItem,\n+        Static, Struct, Trait, TypeAlias, Union,\n     },\n };\n \n@@ -268,6 +272,48 @@ pub struct ExternBlockId(salsa::InternId);\n type ExternBlockLoc = ItemLoc<ExternBlock>;\n impl_intern!(ExternBlockId, ExternBlockLoc, intern_extern_block, lookup_intern_extern_block);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum MacroExpander {\n+    Declarative,\n+    BuiltIn(BuiltinFnLikeExpander),\n+    BuiltInAttr(BuiltinAttrExpander),\n+    BuiltInDerive(BuiltinDeriveExpander),\n+    BuiltInEager(EagerExpander),\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub struct Macro2Id(salsa::InternId);\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Macro2Loc {\n+    pub container: ModuleId,\n+    pub id: ItemTreeId<MacroDef>,\n+    pub expander: MacroExpander,\n+}\n+impl_intern!(Macro2Id, Macro2Loc, intern_macro2, lookup_intern_macro2);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub struct MacroRulesId(salsa::InternId);\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroRulesLoc {\n+    pub container: ModuleId,\n+    pub id: ItemTreeId<MacroRules>,\n+    pub local_inner: bool,\n+    pub expander: MacroExpander,\n+}\n+impl_intern!(MacroRulesId, MacroRulesLoc, intern_macro_rules, lookup_intern_macro_rules);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub struct ProcMacroId(salsa::InternId);\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ProcMacroLoc {\n+    // FIXME: this should be a crate? or just a crate-root module\n+    pub container: ModuleId,\n+    pub id: ItemTreeId<Function>,\n+    pub expander: ProcMacroExpander,\n+    pub kind: ProcMacroKind,\n+}\n+impl_intern!(ProcMacroId, ProcMacroLoc, intern_proc_macro, lookup_intern_proc_macro);\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub struct BlockId(salsa::InternId);\n #[derive(Debug, Hash, PartialEq, Eq, Clone)]\n@@ -284,8 +330,8 @@ pub struct TypeOrConstParamId {\n     pub local_id: LocalTypeOrConstParamId,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n /// A TypeOrConstParamId with an invariant that it actually belongs to a type\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeParamId(TypeOrConstParamId);\n \n impl TypeParamId {\n@@ -359,6 +405,24 @@ pub enum AdtId {\n }\n impl_from!(StructId, UnionId, EnumId for AdtId);\n \n+/// A macro\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum MacroId {\n+    Macro2Id(Macro2Id),\n+    MacroRulesId(MacroRulesId),\n+    ProcMacroId(ProcMacroId),\n+}\n+impl_from!(Macro2Id, MacroRulesId, ProcMacroId for MacroId);\n+\n+impl MacroId {\n+    pub fn is_attribute(self, db: &dyn db::DefDatabase) -> bool {\n+        match self {\n+            MacroId::ProcMacroId(it) => it.lookup(db).kind == ProcMacroKind::Attr,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// A generic param\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum GenericParamId {\n@@ -381,8 +445,10 @@ pub enum ModuleDefId {\n     TraitId(TraitId),\n     TypeAliasId(TypeAliasId),\n     BuiltinType(BuiltinType),\n+    MacroId(MacroId),\n }\n impl_from!(\n+    MacroId,\n     ModuleId,\n     FunctionId,\n     AdtId(StructId, EnumId, UnionId),\n@@ -592,6 +658,16 @@ impl HasModule for VariantId {\n     }\n }\n \n+impl HasModule for MacroId {\n+    fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n+        match self {\n+            MacroId::MacroRulesId(it) => it.lookup(db).container,\n+            MacroId::Macro2Id(it) => it.lookup(db).container,\n+            MacroId::ProcMacroId(it) => it.lookup(db).container,\n+        }\n+    }\n+}\n+\n impl HasModule for DefWithBodyId {\n     fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         match self {\n@@ -652,6 +728,7 @@ impl ModuleDefId {\n             ModuleDefId::StaticId(id) => id.lookup(db).module(db),\n             ModuleDefId::TraitId(id) => id.lookup(db).container,\n             ModuleDefId::TypeAliasId(id) => id.lookup(db).module(db),\n+            ModuleDefId::MacroId(id) => id.module(db),\n             ModuleDefId::BuiltinType(_) => return None,\n         })\n     }\n@@ -762,7 +839,7 @@ fn macro_call_as_call_id(\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     error_sink: &mut dyn FnMut(ExpandError),\n ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n-    let def: MacroDefId =\n+    let def =\n         resolver(call.path.clone()).ok_or_else(|| UnresolvedMacro { path: call.path.clone() })?;\n \n     let res = if let MacroDefKind::BuiltInEager(..) = def.kind {\n@@ -779,6 +856,74 @@ fn macro_call_as_call_id(\n     Ok(res)\n }\n \n+fn macro_id_to_def_id(db: &dyn db::DefDatabase, id: MacroId) -> MacroDefId {\n+    match id {\n+        MacroId::Macro2Id(it) => {\n+            let loc = it.lookup(db);\n+\n+            let item_tree = loc.id.item_tree(db);\n+            let makro = &item_tree[loc.id.value];\n+            let in_file = |m: FileAstId<ast::MacroDef>| InFile::new(loc.id.file_id(), m.upcast());\n+            MacroDefId {\n+                krate: loc.container.krate,\n+                kind: match loc.expander {\n+                    MacroExpander::Declarative => MacroDefKind::Declarative(in_file(makro.ast_id)),\n+                    MacroExpander::BuiltIn(it) => MacroDefKind::BuiltIn(it, in_file(makro.ast_id)),\n+                    MacroExpander::BuiltInAttr(it) => {\n+                        MacroDefKind::BuiltInAttr(it, in_file(makro.ast_id))\n+                    }\n+                    MacroExpander::BuiltInDerive(it) => {\n+                        MacroDefKind::BuiltInDerive(it, in_file(makro.ast_id))\n+                    }\n+                    MacroExpander::BuiltInEager(it) => {\n+                        MacroDefKind::BuiltInEager(it, in_file(makro.ast_id))\n+                    }\n+                },\n+                local_inner: false,\n+            }\n+        }\n+        MacroId::MacroRulesId(it) => {\n+            let loc = it.lookup(db);\n+\n+            let item_tree = loc.id.item_tree(db);\n+            let makro = &item_tree[loc.id.value];\n+            let in_file = |m: FileAstId<ast::MacroRules>| InFile::new(loc.id.file_id(), m.upcast());\n+            MacroDefId {\n+                krate: loc.container.krate,\n+                kind: match loc.expander {\n+                    MacroExpander::Declarative => MacroDefKind::Declarative(in_file(makro.ast_id)),\n+                    MacroExpander::BuiltIn(it) => MacroDefKind::BuiltIn(it, in_file(makro.ast_id)),\n+                    MacroExpander::BuiltInAttr(it) => {\n+                        MacroDefKind::BuiltInAttr(it, in_file(makro.ast_id))\n+                    }\n+                    MacroExpander::BuiltInDerive(it) => {\n+                        MacroDefKind::BuiltInDerive(it, in_file(makro.ast_id))\n+                    }\n+                    MacroExpander::BuiltInEager(it) => {\n+                        MacroDefKind::BuiltInEager(it, in_file(makro.ast_id))\n+                    }\n+                },\n+                local_inner: loc.local_inner,\n+            }\n+        }\n+        MacroId::ProcMacroId(it) => {\n+            let loc = it.lookup(db);\n+\n+            let item_tree = loc.id.item_tree(db);\n+            let makro = &item_tree[loc.id.value];\n+            MacroDefId {\n+                krate: loc.container.krate,\n+                kind: MacroDefKind::ProcMacro(\n+                    loc.expander,\n+                    loc.kind,\n+                    InFile::new(loc.id.file_id(), makro.ast_id),\n+                ),\n+                local_inner: false,\n+            }\n+        }\n+    }\n+}\n+\n fn derive_macro_as_call_id(\n     db: &dyn db::DefDatabase,\n     item_attr: &AstIdWithPath<ast::Adt>,"}, {"sha": "7e0598f4a0fb134f04476509115b834bc5c85843", "filename": "crates/hir_def/src/macro_expansion_tests.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -33,8 +33,8 @@ use syntax::{\n use tt::{Subtree, TokenId};\n \n use crate::{\n-    db::DefDatabase, nameres::ModuleSource, resolver::HasResolver, src::HasSource, test_db::TestDB,\n-    AdtId, AsMacroCall, Lookup, ModuleDefId,\n+    db::DefDatabase, macro_id_to_def_id, nameres::ModuleSource, resolver::HasResolver,\n+    src::HasSource, test_db::TestDB, AdtId, AsMacroCall, Lookup, ModuleDefId,\n };\n \n #[track_caller]\n@@ -128,7 +128,9 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n             .as_call_id_with_errors(\n                 &db,\n                 krate,\n-                |path| resolver.resolve_path_as_macro(&db, &path),\n+                |path| {\n+                    resolver.resolve_path_as_macro(&db, &path).map(|it| macro_id_to_def_id(&db, it))\n+                },\n                 &mut |err| error = Some(err),\n             )\n             .unwrap()"}, {"sha": "a7e2c3e8ad45b32785f1278d23261e7da4ca572a", "filename": "crates/hir_def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -8,6 +8,7 @@ use crate::{\n     attr_macro_as_call_id, builtin_attr,\n     db::DefDatabase,\n     item_scope::BuiltinShadowMode,\n+    macro_id_to_def_id,\n     nameres::path_resolution::ResolveMode,\n     path::{ModPath, PathKind},\n     AstIdWithPath, LocalModuleId, UnresolvedMacro,\n@@ -45,7 +46,7 @@ impl DefMap {\n         );\n         let def = match resolved_res.resolved_def.take_macros() {\n             Some(def) => {\n-                if def.is_attribute() {\n+                if def.is_attribute(db) {\n                     def\n                 } else {\n                     return Ok(ResolvedAttr::Other);\n@@ -54,7 +55,14 @@ impl DefMap {\n             None => return Err(UnresolvedMacro { path: ast_id.path.clone() }),\n         };\n \n-        Ok(ResolvedAttr::Macro(attr_macro_as_call_id(db, &ast_id, attr, self.krate, def, false)))\n+        Ok(ResolvedAttr::Macro(attr_macro_as_call_id(\n+            db,\n+            &ast_id,\n+            attr,\n+            self.krate,\n+            macro_id_to_def_id(db, def),\n+            false,\n+        )))\n     }\n \n     pub(crate) fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {"}, {"sha": "a6a90117f2af5fc1f8f18de6781da69470b3ae25", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 96, "deletions": 86, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -5,8 +5,9 @@\n \n use std::iter;\n \n-use base_db::{CrateId, Edition, FileId, ProcMacroId};\n+use base_db::{CrateId, Edition, FileId};\n use cfg::{CfgExpr, CfgOptions};\n+use either::Either;\n use hir_expand::{\n     ast_id_map::FileAstId,\n     builtin_attr_macro::find_builtin_attr,\n@@ -34,7 +35,7 @@ use crate::{\n         self, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, ItemTreeNode, MacroCall,\n         MacroDef, MacroRules, Mod, ModItem, ModKind, TreeId,\n     },\n-    macro_call_as_call_id,\n+    macro_call_as_call_id, macro_id_to_def_id,\n     nameres::{\n         diagnostics::DefDiagnostic,\n         mod_resolution::ModDir,\n@@ -46,8 +47,9 @@ use crate::{\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n     AdtId, AstId, AstIdWithPath, ConstLoc, EnumLoc, EnumVariantId, ExternBlockLoc, FunctionLoc,\n-    ImplLoc, Intern, ItemContainerId, LocalModuleId, ModuleDefId, StaticLoc, StructLoc, TraitLoc,\n-    TypeAliasLoc, UnionLoc, UnresolvedMacro,\n+    ImplLoc, Intern, ItemContainerId, LocalModuleId, Macro2Id, Macro2Loc, MacroExpander, MacroId,\n+    MacroRulesId, MacroRulesLoc, ModuleDefId, ModuleId, ProcMacroId, ProcMacroLoc, StaticLoc,\n+    StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro,\n };\n \n static GLOB_RECURSION_LIMIT: Limit = Limit::new(100);\n@@ -79,7 +81,10 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n         .map(|(idx, it)| {\n             // FIXME: a hacky way to create a Name from string.\n             let name = tt::Ident { text: it.name.clone(), id: tt::TokenId::unspecified() };\n-            (name.as_name(), ProcMacroExpander::new(def_map.krate, ProcMacroId(idx as u32)))\n+            (\n+                name.as_name(),\n+                ProcMacroExpander::new(def_map.krate, base_db::ProcMacroId(idx as u32)),\n+            )\n         })\n         .collect();\n \n@@ -543,28 +548,26 @@ impl DefCollector<'_> {\n     /// use a dummy expander that always errors. This comes with the drawback of macros potentially\n     /// going out of sync with what the build system sees (since we resolve using VFS state, but\n     /// Cargo builds only on-disk files). We could and probably should add diagnostics for that.\n-    fn export_proc_macro(&mut self, def: ProcMacroDef, ast_id: AstId<ast::Fn>) {\n+    fn export_proc_macro(\n+        &mut self,\n+        def: ProcMacroDef,\n+        id: ItemTreeId<item_tree::Function>,\n+        module_id: ModuleId,\n+    ) {\n         let kind = def.kind.to_basedb_kind();\n         self.exports_proc_macros = true;\n-        let macro_def = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n-            Some(&(_, expander)) => MacroDefId {\n-                krate: self.def_map.krate,\n-                kind: MacroDefKind::ProcMacro(expander, kind, ast_id),\n-                local_inner: false,\n-            },\n-            None => MacroDefId {\n-                krate: self.def_map.krate,\n-                kind: MacroDefKind::ProcMacro(\n-                    ProcMacroExpander::dummy(self.def_map.krate),\n-                    kind,\n-                    ast_id,\n-                ),\n-                local_inner: false,\n-            },\n+\n+        let (expander, kind) = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n+            Some(&(_, expander)) => (expander, kind),\n+            None => (ProcMacroExpander::dummy(self.def_map.krate), kind),\n         };\n \n-        self.define_proc_macro(def.name.clone(), macro_def);\n-        self.def_map.exported_proc_macros.insert(macro_def, def);\n+        let proc_macro_id =\n+            ProcMacroLoc { container: module_id, id, expander, kind }.intern(self.db);\n+        self.define_proc_macro(def.name.clone(), proc_macro_id.into());\n+        self.def_map\n+            .exported_proc_macros\n+            .insert(macro_id_to_def_id(self.db, proc_macro_id.into()), def);\n     }\n \n     /// Define a macro with `macro_rules`.\n@@ -596,11 +599,12 @@ impl DefCollector<'_> {\n         &mut self,\n         module_id: LocalModuleId,\n         name: Name,\n-        macro_: MacroDefId,\n+        macro_: MacroRulesId,\n         export: bool,\n     ) {\n         // Textual scoping\n         self.define_legacy_macro(module_id, name.clone(), macro_);\n+        let macro_ = macro_.into();\n         self.def_map.modules[module_id].scope.declare_macro(macro_);\n \n         // Module scoping\n@@ -623,7 +627,7 @@ impl DefCollector<'_> {\n     /// the definition of current module.\n     /// And also, `macro_use` on a module will import all legacy macros visible inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroDefId) {\n+    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroRulesId) {\n         // Always shadowing\n         self.def_map.modules[module_id].scope.define_legacy_macro(name, mac);\n     }\n@@ -635,11 +639,12 @@ impl DefCollector<'_> {\n         &mut self,\n         module_id: LocalModuleId,\n         name: Name,\n-        macro_: MacroDefId,\n+        macro_: Macro2Id,\n         vis: &RawVisibility,\n     ) {\n         let vis =\n             self.def_map.resolve_visibility(self.db, module_id, vis).unwrap_or(Visibility::Public);\n+        let macro_ = macro_.into();\n         self.def_map.modules[module_id].scope.declare_macro(macro_);\n         self.update(module_id, &[(Some(name), PerNs::macros(macro_, vis))], vis, ImportType::Named);\n     }\n@@ -648,7 +653,8 @@ impl DefCollector<'_> {\n     ///\n     /// A proc macro is similar to normal macro scope, but it would not visible in legacy textual scoped.\n     /// And unconditionally exported.\n-    fn define_proc_macro(&mut self, name: Name, macro_: MacroDefId) {\n+    fn define_proc_macro(&mut self, name: Name, macro_: ProcMacroId) {\n+        let macro_ = macro_.into();\n         self.def_map.modules[self.def_map.root].scope.declare_macro(macro_);\n         self.update(\n             self.def_map.root,\n@@ -691,8 +697,10 @@ impl DefCollector<'_> {\n     fn import_all_macros_exported(&mut self, current_module_id: LocalModuleId, krate: CrateId) {\n         let def_map = self.db.crate_def_map(krate);\n         for (name, def) in def_map[def_map.root].scope.macros() {\n-            // `macro_use` only bring things into legacy scope.\n-            self.define_legacy_macro(current_module_id, name.clone(), def);\n+            if let MacroId::MacroRulesId(def) = def {\n+                // `macro_use` only bring things into legacy scope.\n+                self.define_legacy_macro(current_module_id, name.clone(), def);\n+            }\n         }\n     }\n \n@@ -1049,7 +1057,7 @@ impl DefCollector<'_> {\n                     &path,\n                     BuiltinShadowMode::Module,\n                 );\n-                resolved_res.resolved_def.take_macros()\n+                resolved_res.resolved_def.take_macros().map(|it| macro_id_to_def_id(self.db, it))\n             };\n \n             match &directive.kind {\n@@ -1339,7 +1347,10 @@ impl DefCollector<'_> {\n                                 &path,\n                                 BuiltinShadowMode::Module,\n                             );\n-                            resolved_res.resolved_def.take_macros()\n+                            resolved_res\n+                                .resolved_def\n+                                .take_macros()\n+                                .map(|it| macro_id_to_def_id(self.db, it))\n                         },\n                         &mut |_| (),\n                     );\n@@ -1525,10 +1536,9 @@ impl ModCollector<'_, '_> {\n                     ),\n                 ),\n                 ModItem::MacroCall(mac) => self.collect_macro_call(&self.item_tree[mac], container),\n-                ModItem::MacroRules(id) => self.collect_macro_rules(id),\n-                ModItem::MacroDef(id) => self.collect_macro_def(id),\n+                ModItem::MacroRules(id) => self.collect_macro_rules(id, module),\n+                ModItem::MacroDef(id) => self.collect_macro_def(id, module),\n                 ModItem::Impl(imp) => {\n-                    let module = self.def_collector.def_map.module_id(self.module_id);\n                     let impl_id =\n                         ImplLoc { container: module, id: ItemTreeId::new(self.tree_id, imp) }\n                             .intern(db);\n@@ -1541,9 +1551,13 @@ impl ModCollector<'_, '_> {\n                     let vis = match is_proc_macro {\n                         Some(proc_macro) => {\n                             // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere\n-                            let ast_id = InFile::new(self.tree_id.file_id(), it.ast_id);\n                             let module_id = def_map.module_id(def_map.root());\n-                            self.def_collector.export_proc_macro(proc_macro, ast_id);\n+\n+                            self.def_collector.export_proc_macro(\n+                                proc_macro,\n+                                ItemTreeId::new(self.tree_id, id),\n+                                module_id,\n+                            );\n                             Visibility::Module(module_id)\n                         }\n                         None => resolve_vis(def_map, &self.item_tree[it.visibility]),\n@@ -1845,7 +1859,7 @@ impl ModCollector<'_, '_> {\n         Ok(())\n     }\n \n-    fn collect_macro_rules(&mut self, id: FileItemTreeId<MacroRules>) {\n+    fn collect_macro_rules(&mut self, id: FileItemTreeId<MacroRules>, module: ModuleId) {\n         let krate = self.def_collector.def_map.krate;\n         let mac = &self.item_tree[id];\n         let attrs = self.item_tree.attrs(self.def_collector.db, krate, ModItem::from(id).into());\n@@ -1854,7 +1868,7 @@ impl ModCollector<'_, '_> {\n         let export_attr = attrs.by_key(\"macro_export\");\n \n         let is_export = export_attr.exists();\n-        let is_local_inner = if is_export {\n+        let local_inner = if is_export {\n             export_attr.tt_values().flat_map(|it| &it.token_trees).any(|it| match it {\n                 tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n                     ident.text.contains(\"local_inner_macros\")\n@@ -1866,7 +1880,7 @@ impl ModCollector<'_, '_> {\n         };\n \n         // Case 1: builtin macros\n-        if attrs.by_key(\"rustc_builtin_macro\").exists() {\n+        let expander = if attrs.by_key(\"rustc_builtin_macro\").exists() {\n             // `#[rustc_builtin_macro = \"builtin_name\"]` overrides the `macro_rules!` name.\n             let name;\n             let name = match attrs.by_key(\"rustc_builtin_macro\").string_value() {\n@@ -1892,32 +1906,29 @@ impl ModCollector<'_, '_> {\n                     }\n                 }\n             };\n-            let krate = self.def_collector.def_map.krate;\n-            match find_builtin_macro(name, krate, ast_id) {\n-                Some(macro_id) => {\n-                    self.def_collector.define_macro_rules(\n-                        self.module_id,\n-                        mac.name.clone(),\n-                        macro_id,\n-                        is_export,\n-                    );\n-                    return;\n-                }\n+            match find_builtin_macro(name) {\n+                Some(Either::Left(it)) => MacroExpander::BuiltIn(it),\n+                Some(Either::Right(it)) => MacroExpander::BuiltInEager(it),\n                 None => {\n                     self.def_collector\n                         .def_map\n                         .diagnostics\n                         .push(DefDiagnostic::unimplemented_builtin_macro(self.module_id, ast_id));\n+                    return;\n                 }\n             }\n-        }\n-\n-        // Case 2: normal `macro_rules!` macro\n-        let macro_id = MacroDefId {\n-            krate: self.def_collector.def_map.krate,\n-            kind: MacroDefKind::Declarative(ast_id),\n-            local_inner: is_local_inner,\n+        } else {\n+            // Case 2: normal `macro_rules!` macro\n+            MacroExpander::Declarative\n         };\n+\n+        let macro_id = MacroRulesLoc {\n+            container: module,\n+            id: ItemTreeId::new(self.tree_id, id),\n+            local_inner,\n+            expander,\n+        }\n+        .intern(self.def_collector.db);\n         self.def_collector.define_macro_rules(\n             self.module_id,\n             mac.name.clone(),\n@@ -1926,44 +1937,38 @@ impl ModCollector<'_, '_> {\n         );\n     }\n \n-    fn collect_macro_def(&mut self, id: FileItemTreeId<MacroDef>) {\n+    fn collect_macro_def(&mut self, id: FileItemTreeId<MacroDef>, module: ModuleId) {\n         let krate = self.def_collector.def_map.krate;\n         let mac = &self.item_tree[id];\n         let ast_id = InFile::new(self.file_id(), mac.ast_id.upcast());\n \n         // Case 1: builtin macros\n         let attrs = self.item_tree.attrs(self.def_collector.db, krate, ModItem::from(id).into());\n-        if attrs.by_key(\"rustc_builtin_macro\").exists() {\n-            let macro_id = find_builtin_macro(&mac.name, krate, ast_id)\n-                .or_else(|| find_builtin_derive(&mac.name, krate, ast_id))\n-                .or_else(|| find_builtin_attr(&mac.name, krate, ast_id));\n-\n-            match macro_id {\n-                Some(macro_id) => {\n-                    self.def_collector.define_macro_def(\n-                        self.module_id,\n-                        mac.name.clone(),\n-                        macro_id,\n-                        &self.item_tree[mac.visibility],\n-                    );\n-                    return;\n-                }\n-                None => {\n-                    self.def_collector\n-                        .def_map\n-                        .diagnostics\n-                        .push(DefDiagnostic::unimplemented_builtin_macro(self.module_id, ast_id));\n+        let expander = if attrs.by_key(\"rustc_builtin_macro\").exists() {\n+            if let Some(expander) = find_builtin_macro(&mac.name) {\n+                match expander {\n+                    Either::Left(it) => MacroExpander::BuiltIn(it),\n+                    Either::Right(it) => MacroExpander::BuiltInEager(it),\n                 }\n+            } else if let Some(expander) = find_builtin_derive(&mac.name) {\n+                MacroExpander::BuiltInDerive(expander)\n+            } else if let Some(expander) = find_builtin_attr(&mac.name) {\n+                MacroExpander::BuiltInAttr(expander)\n+            } else {\n+                self.def_collector\n+                    .def_map\n+                    .diagnostics\n+                    .push(DefDiagnostic::unimplemented_builtin_macro(self.module_id, ast_id));\n+                return;\n             }\n-        }\n-\n-        // Case 2: normal `macro`\n-        let macro_id = MacroDefId {\n-            krate: self.def_collector.def_map.krate,\n-            kind: MacroDefKind::Declarative(ast_id),\n-            local_inner: false,\n+        } else {\n+            // Case 2: normal `macro`\n+            MacroExpander::Declarative\n         };\n \n+        let macro_id =\n+            Macro2Loc { container: module, id: ItemTreeId::new(self.tree_id, id), expander }\n+                .intern(self.def_collector.db);\n         self.def_collector.define_macro_def(\n             self.module_id,\n             mac.name.clone(),\n@@ -1987,7 +1992,12 @@ impl ModCollector<'_, '_> {\n                     self.def_collector.def_map.with_ancestor_maps(\n                         self.def_collector.db,\n                         self.module_id,\n-                        &mut |map, module| map[module].scope.get_legacy_macro(name),\n+                        &mut |map, module| {\n+                            map[module]\n+                                .scope\n+                                .get_legacy_macro(name)\n+                                .map(|it| macro_id_to_def_id(self.def_collector.db, it.into()))\n+                        },\n                     )\n                 })\n             },"}, {"sha": "809c6e0289cffad41d7bcb70e81810b489a37a46", "filename": "crates/hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -389,7 +389,7 @@ impl DefMap {\n         let from_legacy_macro = self[module]\n             .scope\n             .get_legacy_macro(name)\n-            .map_or_else(PerNs::none, |m| PerNs::macros(m, Visibility::Public));\n+            .map_or_else(PerNs::none, |m| PerNs::macros(m.into(), Visibility::Public));\n         let from_scope = self[module].scope.get(name);\n         let from_builtin = match self.block {\n             Some(_) => {"}, {"sha": "2e8cb3621fce663e35bd4a4a3cf93d4fb7b590c7", "filename": "crates/hir_def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -226,6 +226,7 @@ pub type Ty = ();\n                     ModuleDefId::TypeAliasId(it) => drop(db.type_alias_data(it)),\n                     ModuleDefId::EnumVariantId(_)\n                     | ModuleDefId::ModuleId(_)\n+                    | ModuleDefId::MacroId(_)\n                     | ModuleDefId::BuiltinType(_) => unreachable!(),\n                 }\n             }"}, {"sha": "bf5bf10c4caaf7cf21a75a805878fb230ec352f0", "filename": "crates/hir_def/src/per_ns.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fper_ns.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -3,15 +3,13 @@\n //!\n //! `PerNs` (per namespace) captures this.\n \n-use hir_expand::MacroDefId;\n-\n-use crate::{item_scope::ItemInNs, visibility::Visibility, ModuleDefId};\n+use crate::{item_scope::ItemInNs, visibility::Visibility, MacroId, ModuleDefId};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct PerNs {\n     pub types: Option<(ModuleDefId, Visibility)>,\n     pub values: Option<(ModuleDefId, Visibility)>,\n-    pub macros: Option<(MacroDefId, Visibility)>,\n+    pub macros: Option<(MacroId, Visibility)>,\n }\n \n impl Default for PerNs {\n@@ -37,7 +35,7 @@ impl PerNs {\n         PerNs { types: Some((types, v)), values: Some((values, v)), macros: None }\n     }\n \n-    pub fn macros(macro_: MacroDefId, v: Visibility) -> PerNs {\n+    pub fn macros(macro_: MacroId, v: Visibility) -> PerNs {\n         PerNs { types: None, values: None, macros: Some((macro_, v)) }\n     }\n \n@@ -57,7 +55,7 @@ impl PerNs {\n         self.values.map(|it| it.0)\n     }\n \n-    pub fn take_macros(self) -> Option<MacroDefId> {\n+    pub fn take_macros(self) -> Option<MacroId> {\n         self.macros.map(|it| it.0)\n     }\n "}, {"sha": "fcca84538afb457f9417e5975815bcc6ad624d6a", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -2,10 +2,7 @@\n use std::sync::Arc;\n \n use base_db::CrateId;\n-use hir_expand::{\n-    name::{name, Name},\n-    MacroDefId,\n-};\n+use hir_expand::name::{name, Name};\n use indexmap::IndexMap;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n@@ -24,8 +21,8 @@ use crate::{\n     visibility::{RawVisibility, Visibility},\n     AdtId, AssocItemId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId,\n     FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n-    LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeOrConstParamId, TypeParamId, VariantId,\n+    LocalModuleId, Lookup, MacroId, ModuleDefId, ModuleId, StaticId, StructId, TraitId,\n+    TypeAliasId, TypeOrConstParamId, TypeParamId, VariantId,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -347,11 +344,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_path_as_macro(\n-        &self,\n-        db: &dyn DefDatabase,\n-        path: &ModPath,\n-    ) -> Option<MacroDefId> {\n+    pub fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n         let (item_map, module) = self.module_scope()?;\n         item_map.resolve_path(db, module, path, BuiltinShadowMode::Other).0.take_macros()\n     }\n@@ -485,7 +478,6 @@ impl Resolver {\n #[derive(Debug, PartialEq, Eq)]\n pub enum ScopeDef {\n     ModuleDef(ModuleDefId),\n-    MacroDef(MacroDefId),\n     Unknown,\n     ImplSelfType(ImplId),\n     AdtSelfType(AdtId),\n@@ -509,7 +501,7 @@ impl Scope {\n                     acc.add_per_ns(name, def);\n                 });\n                 m.def_map[m.module_id].scope.legacy_macros().for_each(|(name, mac)| {\n-                    acc.add(name, ScopeDef::MacroDef(mac));\n+                    acc.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))));\n                 });\n                 m.def_map.extern_prelude().for_each(|(name, &def)| {\n                     acc.add(name, ScopeDef::ModuleDef(def));\n@@ -651,6 +643,7 @@ impl ModuleItemMap {\n                     | ModuleDefId::FunctionId(_)\n                     | ModuleDefId::EnumVariantId(_)\n                     | ModuleDefId::ConstId(_)\n+                    | ModuleDefId::MacroId(_)\n                     | ModuleDefId::StaticId(_) => return None,\n                 };\n                 Some(ResolveValueResult::Partial(ty, idx))\n@@ -682,6 +675,7 @@ fn to_value_ns(per_ns: PerNs) -> Option<ValueNs> {\n         | ModuleDefId::TraitId(_)\n         | ModuleDefId::TypeAliasId(_)\n         | ModuleDefId::BuiltinType(_)\n+        | ModuleDefId::MacroId(_)\n         | ModuleDefId::ModuleId(_) => return None,\n     };\n     Some(res)\n@@ -699,6 +693,7 @@ fn to_type_ns(per_ns: PerNs) -> Option<TypeNs> {\n \n         ModuleDefId::FunctionId(_)\n         | ModuleDefId::ConstId(_)\n+        | ModuleDefId::MacroId(_)\n         | ModuleDefId::StaticId(_)\n         | ModuleDefId::ModuleId(_) => return None,\n     };\n@@ -718,14 +713,14 @@ impl ScopeNames {\n         }\n     }\n     fn add_per_ns(&mut self, name: &Name, def: PerNs) {\n-        if let Some(ty) = &def.types {\n-            self.add(name, ScopeDef::ModuleDef(ty.0))\n+        if let &Some((ty, _)) = &def.types {\n+            self.add(name, ScopeDef::ModuleDef(ty))\n         }\n-        if let Some(val) = &def.values {\n-            self.add(name, ScopeDef::ModuleDef(val.0))\n+        if let &Some((def, _)) = &def.values {\n+            self.add(name, ScopeDef::ModuleDef(def))\n         }\n-        if let Some(mac) = &def.macros {\n-            self.add(name, ScopeDef::MacroDef(mac.0))\n+        if let &Some((mac, _)) = &def.macros {\n+            self.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(mac)))\n         }\n         if def.is_none() {\n             self.add(name, ScopeDef::Unknown)"}, {"sha": "f69356cac87d38e4e355cd5d88575463f7f4940d", "filename": "crates/hir_def/src/src.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_def%2Fsrc%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fsrc.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -2,8 +2,12 @@\n \n use hir_expand::InFile;\n use la_arena::ArenaMap;\n+use syntax::ast;\n \n-use crate::{db::DefDatabase, item_tree::ItemTreeNode, AssocItemLoc, ItemLoc};\n+use crate::{\n+    db::DefDatabase, item_tree::ItemTreeNode, AssocItemLoc, ItemLoc, Macro2Loc, MacroRulesLoc,\n+    ProcMacroLoc,\n+};\n \n pub trait HasSource {\n     type Value;\n@@ -36,6 +40,45 @@ impl<N: ItemTreeNode> HasSource for ItemLoc<N> {\n     }\n }\n \n+impl HasSource for Macro2Loc {\n+    type Value = ast::MacroDef;\n+\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<Self::Value> {\n+        let tree = self.id.item_tree(db);\n+        let ast_id_map = db.ast_id_map(self.id.file_id());\n+        let root = db.parse_or_expand(self.id.file_id()).unwrap();\n+        let node = &tree[self.id.value];\n+\n+        InFile::new(self.id.file_id(), ast_id_map.get(node.ast_id()).to_node(&root))\n+    }\n+}\n+\n+impl HasSource for MacroRulesLoc {\n+    type Value = ast::MacroRules;\n+\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<Self::Value> {\n+        let tree = self.id.item_tree(db);\n+        let ast_id_map = db.ast_id_map(self.id.file_id());\n+        let root = db.parse_or_expand(self.id.file_id()).unwrap();\n+        let node = &tree[self.id.value];\n+\n+        InFile::new(self.id.file_id(), ast_id_map.get(node.ast_id()).to_node(&root))\n+    }\n+}\n+\n+impl HasSource for ProcMacroLoc {\n+    type Value = ast::Fn;\n+\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<Self::Value> {\n+        let tree = self.id.item_tree(db);\n+        let ast_id_map = db.ast_id_map(self.id.file_id());\n+        let root = db.parse_or_expand(self.id.file_id()).unwrap();\n+        let node = &tree[self.id.value];\n+\n+        InFile::new(self.id.file_id(), ast_id_map.get(node.ast_id()).to_node(&root))\n+    }\n+}\n+\n pub trait HasChildSource<ChildId> {\n     type Value;\n     fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<ChildId, Self::Value>>;"}, {"sha": "6535f27a6368ee9a98b61184a194f61837db1962", "filename": "crates/hir_expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -1,12 +1,8 @@\n //! Builtin attributes.\n \n use itertools::Itertools;\n-use syntax::ast;\n \n-use crate::{\n-    db::AstDatabase, name, AstId, CrateId, ExpandResult, MacroCallId, MacroCallKind, MacroDefId,\n-    MacroDefKind,\n-};\n+use crate::{db::AstDatabase, name, ExpandResult, MacroCallId, MacroCallKind};\n \n macro_rules! register_builtin {\n     ( $(($name:ident, $variant:ident) => $expand:ident),* ) => {\n@@ -61,17 +57,8 @@ register_builtin! {\n     (test_case, TestCase) => dummy_attr_expand\n }\n \n-pub fn find_builtin_attr(\n-    ident: &name::Name,\n-    krate: CrateId,\n-    ast_id: AstId<ast::Macro>,\n-) -> Option<MacroDefId> {\n-    let expander = BuiltinAttrExpander::find_by_name(ident)?;\n-    Some(MacroDefId {\n-        krate,\n-        kind: MacroDefKind::BuiltInAttr(expander, ast_id),\n-        local_inner: false,\n-    })\n+pub fn find_builtin_attr(ident: &name::Name) -> Option<BuiltinAttrExpander> {\n+    BuiltinAttrExpander::find_by_name(ident)\n }\n \n fn dummy_attr_expand("}, {"sha": "5a909e9a5014c9a4c9d5856d9c7b81b564c102d0", "filename": "crates/hir_expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -8,10 +8,7 @@ use syntax::{\n };\n use tt::TokenId;\n \n-use crate::{\n-    db::AstDatabase, name, quote, AstId, CrateId, ExpandError, ExpandResult, MacroCallId,\n-    MacroDefId, MacroDefKind,\n-};\n+use crate::{db::AstDatabase, name, quote, ExpandError, ExpandResult, MacroCallId};\n \n macro_rules! register_builtin {\n     ( $($trait:ident => $expand:ident),* ) => {\n@@ -56,17 +53,8 @@ register_builtin! {\n     PartialEq => partial_eq_expand\n }\n \n-pub fn find_builtin_derive(\n-    ident: &name::Name,\n-    krate: CrateId,\n-    ast_id: AstId<ast::Macro>,\n-) -> Option<MacroDefId> {\n-    let expander = BuiltinDeriveExpander::find_by_name(ident)?;\n-    Some(MacroDefId {\n-        krate,\n-        kind: MacroDefKind::BuiltInDerive(expander, ast_id),\n-        local_inner: false,\n-    })\n+pub fn find_builtin_derive(ident: &name::Name) -> Option<BuiltinDeriveExpander> {\n+    BuiltinDeriveExpander::find_by_name(ident)\n }\n \n struct BasicAdtInfo {"}, {"sha": "bdea31a166f5fcd1605206d0cc91ee4440208291", "filename": "crates/hir_expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d46325a124c4820f3cab688785a2cd279cb974/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=42d46325a124c4820f3cab688785a2cd279cb974", "patch": "@@ -9,10 +9,7 @@ use syntax::{\n     SmolStr,\n };\n \n-use crate::{\n-    db::AstDatabase, name, quote, AstId, CrateId, ExpandError, ExpandResult, MacroCallId,\n-    MacroCallLoc, MacroDefId, MacroDefKind,\n-};\n+use crate::{db::AstDatabase, name, quote, ExpandError, ExpandResult, MacroCallId, MacroCallLoc};\n \n macro_rules! register_builtin {\n     ( LAZY: $(($name:ident, $kind: ident) => $expand:ident),* , EAGER: $(($e_name:ident, $e_kind: ident) => $e_expand:ident),*  ) => {\n@@ -79,23 +76,8 @@ impl ExpandedEager {\n \n pub fn find_builtin_macro(\n     ident: &name::Name,\n-    krate: CrateId,\n-    ast_id: AstId<ast::Macro>,\n-) -> Option<MacroDefId> {\n-    let kind = find_by_name(ident)?;\n-\n-    match kind {\n-        Either::Left(kind) => Some(MacroDefId {\n-            krate,\n-            kind: MacroDefKind::BuiltIn(kind, ast_id),\n-            local_inner: false,\n-        }),\n-        Either::Right(kind) => Some(MacroDefId {\n-            krate,\n-            kind: MacroDefKind::BuiltInEager(kind, ast_id),\n-            local_inner: false,\n-        }),\n-    }\n+) -> Option<Either<BuiltinFnLikeExpander, EagerExpander>> {\n+    find_by_name(ident)\n }\n \n register_builtin! {"}]}