{"sha": "3832a634d3aa6a7c60448906e6656a22f7e35628", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MzJhNjM0ZDNhYTZhN2M2MDQ0ODkwNmU2NjU2YTIyZjdlMzU2Mjg=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-07T23:34:53Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-08T05:57:07Z"}, "message": "Optimize `TokenStream::from_streams`.\n\nCurrently, this function creates a new empty stream, and then appends\nthe elements from each given stream onto that stream. This can cause\nquadratic behaviour.\n\nThis commit changes the function so that it modifies the first stream\n(which can be long) by extending it with the elements from the\nsubsequent streams (which are almost always short), which avoids the\nquadratic behaviour.", "tree": {"sha": "2a58862ac85c57aba8067ccacd18a8a0935e2d5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a58862ac85c57aba8067ccacd18a8a0935e2d5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3832a634d3aa6a7c60448906e6656a22f7e35628", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3832a634d3aa6a7c60448906e6656a22f7e35628", "html_url": "https://github.com/rust-lang/rust/commit/3832a634d3aa6a7c60448906e6656a22f7e35628", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3832a634d3aa6a7c60448906e6656a22f7e35628/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "421bd77f42c2fe8a2596dbcc1580ec97fb89009f", "url": "https://api.github.com/repos/rust-lang/rust/commits/421bd77f42c2fe8a2596dbcc1580ec97fb89009f", "html_url": "https://github.com/rust-lang/rust/commit/421bd77f42c2fe8a2596dbcc1580ec97fb89009f"}], "stats": {"total": 47, "additions": 37, "deletions": 10}, "files": [{"sha": "76983f8ef854c8cd78a8fa17f413f9911db05ce9", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3832a634d3aa6a7c60448906e6656a22f7e35628/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3832a634d3aa6a7c60448906e6656a22f7e35628/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=3832a634d3aa6a7c60448906e6656a22f7e35628", "patch": "@@ -249,20 +249,47 @@ impl TokenStream {\n             0 => TokenStream::empty(),\n             1 => streams.pop().unwrap(),\n             _ => {\n-                // rust-lang/rust#57735: pre-allocate vector to avoid\n-                // quadratic blow-up due to on-the-fly reallocations.\n-                let tree_count = streams.iter()\n-                    .map(|ts| match &ts.0 { None => 0, Some(s) => s.len() })\n+                // We are going to extend the first stream in `streams` with\n+                // the elements from the subsequent streams. This requires\n+                // using `make_mut()` on the first stream, and in practice this\n+                // doesn't cause cloning 99.9% of the time.\n+                //\n+                // One very common use case is when `streams` has two elements,\n+                // where the first stream has any number of elements within\n+                // (often 1, but sometimes many more) and the second stream has\n+                // a single element within.\n+\n+                // Determine how much the first stream will be extended.\n+                // Needed to avoid quadratic blow up from on-the-fly\n+                // reallocations (#57735).\n+                let num_appends = streams.iter()\n+                    .skip(1)\n+                    .map(|ts| ts.len())\n                     .sum();\n-                let mut vec = Vec::with_capacity(tree_count);\n \n-                for stream in streams {\n-                    match stream.0 {\n-                        None => {},\n-                        Some(stream2) => vec.extend(stream2.iter().cloned()),\n+                // Get the first stream. If it's `None`, create an empty\n+                // stream.\n+                let mut iter = streams.drain();\n+                let mut first_stream_lrc = match iter.next().unwrap().0 {\n+                    Some(first_stream_lrc) => first_stream_lrc,\n+                    None => Lrc::new(vec![]),\n+                };\n+\n+                // Append the elements to the first stream, after reserving\n+                // space for them.\n+                let first_vec_mut = Lrc::make_mut(&mut first_stream_lrc);\n+                first_vec_mut.reserve(num_appends);\n+                for stream in iter {\n+                    if let Some(stream) = stream.0 {\n+                        first_vec_mut.extend(stream.iter().cloned());\n                     }\n                 }\n-                TokenStream::new(vec)\n+\n+                // Create the final `TokenStream`.\n+                match first_vec_mut.len() {\n+                    0 => TokenStream(None),\n+                    _ => TokenStream(Some(first_stream_lrc)),\n+                }\n             }\n         }\n     }"}]}