{"sha": "c5849e4dff28784ec0c3d5ace090b1da9439ec1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ODQ5ZTRkZmYyODc4NGVjMGMzZDVhY2UwOTBiMWRhOTQzOWVjMWY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-12-22T18:17:59Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:04:34Z"}, "message": "Add specialization module.\n\nThe module contains a few important components:\n\n- The `specialize` function, which determines whether one impl is a\n  specialization of another.\n\n- The `SpecializationGraph`, a per-trait graph recording the\n  specialization tree. The main purpose of the graph is to allow\n  traversals upwards (to less specialized impls) for discovering\n  un-overridden defaults, and for ensuring that overridden items are\n  allowed to be overridden.", "tree": {"sha": "80312fc957263a472f4ecc8aea822e339f968b72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80312fc957263a472f4ecc8aea822e339f968b72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5849e4dff28784ec0c3d5ace090b1da9439ec1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5849e4dff28784ec0c3d5ace090b1da9439ec1f", "html_url": "https://github.com/rust-lang/rust/commit/c5849e4dff28784ec0c3d5ace090b1da9439ec1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5849e4dff28784ec0c3d5ace090b1da9439ec1f/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45f4bf112a422fe62b9152ecf557f8550eb9c7ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/45f4bf112a422fe62b9152ecf557f8550eb9c7ca", "html_url": "https://github.com/rust-lang/rust/commit/45f4bf112a422fe62b9152ecf557f8550eb9c7ca"}], "stats": {"total": 232, "additions": 232, "deletions": 0}, "files": [{"sha": "ad8d6c4f9566120024c86f036d524f88830e9626", "filename": "src/librustc/middle/traits/specialize.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/c5849e4dff28784ec0c3d5ace090b1da9439ec1f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5849e4dff28784ec0c3d5ace090b1da9439ec1f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs?ref=c5849e4dff28784ec0c3d5ace090b1da9439ec1f", "patch": "@@ -0,0 +1,232 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Logic and data structures related to impl specialization, explained in\n+// greater detail below.\n+//\n+// At the moment, this implementation support only the simple \"chain\" rule:\n+// If any two impls overlap, one must be a strict subset of the other.\n+\n+use super::util;\n+use super::SelectionContext;\n+\n+use middle::cstore::CrateStore;\n+use middle::def_id::DefId;\n+use middle::infer::{self, InferCtxt, TypeOrigin};\n+use middle::region;\n+use middle::subst::{Subst, Substs};\n+use middle::traits;\n+use middle::ty;\n+use syntax::codemap::DUMMY_SP;\n+use util::nodemap::DefIdMap;\n+\n+/// A per-trait graph of impls in specialization order.\n+///\n+/// The graph provides two key services:\n+///\n+/// - Construction, which implicitly checks for overlapping impls (i.e., impls\n+///   that overlap but where neither specializes the other -- an artifact of the\n+///   simple \"chain\" rule.\n+///\n+/// - Parent extraction. In particular, the graph can give you the *immediate*\n+///   parents of a given specializing impl, which is needed for extracting\n+///   default items amongst other thigns. In the simple \"chain\" rule, every impl\n+///   has at most one parent.\n+pub struct SpecializationGraph {\n+    // all impls have a parent; the \"root\" impls have as their parent the def_id\n+    // of the trait\n+    parent: DefIdMap<DefId>,\n+\n+    // the \"root\" impls are found by looking up the trait's def_id.\n+    children: DefIdMap<Vec<DefId>>,\n+}\n+\n+/// Information pertinent to an overlapping impl error.\n+pub struct Overlap<'tcx> {\n+    pub with_impl: DefId,\n+    pub on_trait_ref: ty::TraitRef<'tcx>,\n+}\n+\n+impl SpecializationGraph {\n+    pub fn new() -> SpecializationGraph {\n+        SpecializationGraph {\n+            parent: Default::default(),\n+            children: Default::default(),\n+        }\n+    }\n+\n+    /// Insert a local impl into the specialization graph. If an existing impl\n+    /// conflicts with it (has overlap, but neither specializes the other),\n+    /// information about the area of overlap is returned in the `Err`.\n+    pub fn insert<'tcx>(&mut self,\n+                        tcx: &ty::ctxt<'tcx>,\n+                        impl_def_id: DefId,\n+                        trait_ref: ty::TraitRef)\n+                        -> Result<(), Overlap<'tcx>> {\n+        assert!(impl_def_id.is_local());\n+\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+        let mut parent = trait_ref.def_id;\n+\n+        let mut my_children = vec![];\n+\n+        // descend the existing tree, looking for the right location to add this impl\n+        'descend: loop {\n+            let mut possible_siblings = self.children.entry(parent).or_insert(vec![]);\n+\n+            for slot in possible_siblings.iter_mut() {\n+                let possible_sibling = *slot;\n+\n+                let overlap = infcx.probe(|_| {\n+                    traits::overlapping_impls(&infcx, possible_sibling, impl_def_id)\n+                });\n+\n+                if let Some(trait_ref) = overlap {\n+                    let le = specializes(&infcx, impl_def_id, possible_sibling);\n+                    let ge = specializes(&infcx, possible_sibling, impl_def_id);\n+\n+                    if le && !ge {\n+                        // the impl specializes possible_sibling\n+                        parent = possible_sibling;\n+                        continue 'descend;\n+                    } else if ge && !le {\n+                        // possible_sibling specializes the impl\n+                        *slot = impl_def_id;\n+                        self.parent.insert(possible_sibling, impl_def_id);\n+                        my_children.push(possible_sibling);\n+                    } else {\n+                        // overlap, but no specialization; error out\n+                        return Err(Overlap {\n+                            with_impl: possible_sibling,\n+                            on_trait_ref: trait_ref,\n+                        });\n+                    }\n+\n+                    break 'descend;\n+                }\n+            }\n+\n+            // no overlap with any potential siblings, so add as a new sibling\n+            self.parent.insert(impl_def_id, parent);\n+            possible_siblings.push(impl_def_id);\n+            break;\n+        }\n+\n+        if self.children.insert(impl_def_id, my_children).is_some() {\n+            panic!(\"When inserting an impl into the specialization graph, existing children for \\\n+                    the impl were already present.\");\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Insert cached metadata mapping from a child impl back to its parent\n+    pub fn record_impl_from_cstore(&mut self, parent: DefId, child: DefId) {\n+        if self.parent.insert(child, Some(parent)).is_some() {\n+            panic!(\"When recording an impl from the crate store, information about its parent \\\n+                    was already present.\");\n+        }\n+\n+        self.children.entry(parent).or_insert(vec![]).push(child);\n+    }\n+}\n+\n+fn skolemizing_subst_for_impl<'a>(tcx: &ty::ctxt<'a>, impl_def_id: DefId) -> Substs<'a> {\n+    let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n+\n+    let types = impl_generics.types.map(|def| tcx.mk_param_from_def(def));\n+\n+    // FIXME: figure out what we actually want here\n+    let regions = impl_generics.regions.map(|_| ty::Region::ReStatic);\n+    // |d| infcx.next_region_var(infer::RegionVariableOrigin::EarlyBoundRegion(span, d.name)));\n+\n+    Substs::new(types, regions)\n+}\n+\n+/// Is impl1 a specialization of impl2?\n+///\n+/// Specialization is determined by the sets of types to which the impls apply;\n+/// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n+/// to.\n+pub fn specializes(infcx: &InferCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n+    let tcx = &infcx.tcx;\n+\n+    // We determine whether there's a subset relationship by:\n+    //\n+    // - skolemizing impl1,\n+    // - assuming the where clauses for impl1,\n+    // - unifying,\n+    // - attempting to prove the where clauses for impl2\n+    //\n+    // See RFC 1210 for more details and justification.\n+\n+    let impl1_substs = skolemizing_subst_for_impl(tcx, impl1_def_id);\n+    let (impl1_trait_ref, impl1_obligations) = {\n+        let selcx = &mut SelectionContext::new(&infcx);\n+        util::impl_trait_ref_and_oblig(selcx, impl1_def_id, &impl1_substs)\n+    };\n+\n+    let impl1_predicates: Vec<_> = impl1_obligations.iter()\n+        .cloned()\n+        .map(|oblig| oblig.predicate)\n+        .collect();\n+\n+    let penv = ty::ParameterEnvironment {\n+        tcx: tcx,\n+        free_substs: impl1_substs,\n+        implicit_region_bound: ty::ReEmpty, // FIXME: is this OK?\n+        caller_bounds: impl1_predicates,\n+        selection_cache: traits::SelectionCache::new(),\n+        evaluation_cache: traits::EvaluationCache::new(),\n+        free_id_outlive: region::DUMMY_CODE_EXTENT, // FIXME: is this OK?\n+    };\n+\n+    // FIXME: unclear what `errors_will_be_reported` should be here...\n+    let infcx = infer::new_infer_ctxt(tcx, infcx.tables, Some(penv), true);\n+    let selcx = &mut SelectionContext::new(&infcx);\n+\n+    let impl2_substs = util::fresh_type_vars_for_impl(&infcx, DUMMY_SP, impl2_def_id);\n+    let (impl2_trait_ref, impl2_obligations) =\n+        util::impl_trait_ref_and_oblig(selcx, impl2_def_id, &impl2_substs);\n+\n+    // do the impls unify? If not, no specialization.\n+    if let Err(_) = infer::mk_eq_trait_refs(&infcx,\n+                                            true,\n+                                            TypeOrigin::Misc(DUMMY_SP),\n+                                            impl1_trait_ref,\n+                                            impl2_trait_ref) {\n+        debug!(\"specializes: {:?} does not unify with {:?}\",\n+               impl1_trait_ref,\n+               impl2_trait_ref);\n+        return false;\n+    }\n+\n+    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n+\n+    // attempt to prove all of the predicates for impl2 given those for impl1\n+    // (which are packed up in penv)\n+    for oblig in impl2_obligations.into_iter() {\n+        fulfill_cx.register_predicate_obligation(&infcx, oblig);\n+    }\n+\n+    if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n+        debug!(\"specializes: for impls on {:?} and {:?}, could not fulfill: {:?} given {:?}\",\n+               impl1_trait_ref,\n+               impl2_trait_ref,\n+               errors,\n+               infcx.parameter_environment.caller_bounds);\n+        return false;\n+    }\n+\n+    debug!(\"specializes: an impl for {:?} specializes {:?} (`where` clauses elided)\",\n+           impl1_trait_ref,\n+           impl2_trait_ref);\n+    true\n+}"}]}