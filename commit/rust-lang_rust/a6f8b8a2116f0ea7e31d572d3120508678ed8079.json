{"sha": "a6f8b8a2116f0ea7e31d572d3120508678ed8079", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZjhiOGEyMTE2ZjBlYTdlMzFkNTcyZDMxMjA1MDg2NzhlZDgwNzk=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-02T18:27:15Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-17T18:49:35Z"}, "message": "Generating the coverage map\n\nrustc now generates the coverage map and can support (limited)\ncoverage report generation, at the function level.\n\nExample:\n\n$ BUILD=$HOME/rust/build/x86_64-unknown-linux-gnu\n$ $BUILD/stage1/bin/rustc -Zinstrument-coverage \\\n$HOME/rust/src/test/run-make-fulldeps/instrument-coverage/main.rs\n$ LLVM_PROFILE_FILE=\"main.profraw\" ./main\ncalled\n$ $BUILD/llvm/bin/llvm-profdata merge -sparse main.profraw -o main.profdata\n$ $BUILD/llvm/bin/llvm-cov show --instr-profile=main.profdata main\n    1|      1|pub fn will_be_called() {\n    2|      1|    println!(\"called\");\n    3|      1|}\n    4|       |\n    5|      0|pub fn will_not_be_called() {\n    6|      0|    println!(\"should not have been called\");\n    7|      0|}\n    8|       |\n    9|      1|fn main() {\n   10|      1|    let less = 1;\n   11|      1|    let more = 100;\n   12|      1|\n   13|      1|    if less < more {\n   14|      1|        will_be_called();\n   15|      1|    } else {\n   16|      1|        will_not_be_called();\n   17|      1|    }\n   18|      1|}", "tree": {"sha": "ea4c018d3684b3990d2d01bc02efa923360c7129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea4c018d3684b3990d2d01bc02efa923360c7129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6f8b8a2116f0ea7e31d572d3120508678ed8079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6f8b8a2116f0ea7e31d572d3120508678ed8079", "html_url": "https://github.com/rust-lang/rust/commit/a6f8b8a2116f0ea7e31d572d3120508678ed8079", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6f8b8a2116f0ea7e31d572d3120508678ed8079/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "html_url": "https://github.com/rust-lang/rust/commit/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50"}], "stats": {"total": 1986, "additions": 1724, "deletions": 262}, "files": [{"sha": "07b5af15d2c9e2cbcaeca338a3c071065475705b", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -2788,6 +2788,13 @@ dependencies = [\n  \"rls-span\",\n ]\n \n+[[package]]\n+name = \"rust-demangler\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc-demangle\",\n+]\n+\n [[package]]\n name = \"rustbook\"\n version = \"0.1.0\""}, {"sha": "efc6f4a0291ca6791b9088ad6f7a02bb4473106b", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -17,6 +17,7 @@ members = [\n   \"src/tools/remote-test-client\",\n   \"src/tools/remote-test-server\",\n   \"src/tools/rust-installer\",\n+  \"src/tools/rust-demangler\",\n   \"src/tools/cargo\",\n   \"src/tools/rustdoc\",\n   \"src/tools/rls\","}, {"sha": "128e8dd6ba807ebe2e072c3bc26b4a635da0f3fe", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -369,6 +369,7 @@ impl<'a> Builder<'a> {\n                 tool::Cargo,\n                 tool::Rls,\n                 tool::RustAnalyzer,\n+                tool::RustDemangler,\n                 tool::Rustdoc,\n                 tool::Clippy,\n                 tool::CargoClippy,"}, {"sha": "a5f5a2f99500ead4e161d55d346a973d8519da31", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1019,6 +1019,10 @@ impl Step for Compiletest {\n             cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler));\n         }\n \n+        if mode == \"run-make\" && suite.ends_with(\"fulldeps\") {\n+            cmd.arg(\"--rust-demangler-path\").arg(builder.tool_exe(Tool::RustDemangler));\n+        }\n+\n         cmd.arg(\"--src-base\").arg(builder.src.join(\"src/test\").join(suite));\n         cmd.arg(\"--build-base\").arg(testdir(builder, compiler.host).join(suite));\n         cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));"}, {"sha": "233b15b40c708b2939d61d559019421f8c973cb8", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -361,6 +361,7 @@ bootstrap_tool!(\n     Compiletest, \"src/tools/compiletest\", \"compiletest\", is_unstable_tool = true;\n     BuildManifest, \"src/tools/build-manifest\", \"build-manifest\";\n     RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\";\n+    RustDemangler, \"src/tools/rust-demangler\", \"rust-demangler\";\n     RustInstaller, \"src/tools/rust-installer\", \"fabricate\", is_external_tool = true;\n     RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\";\n     ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";"}, {"sha": "db3b36d8d848486cedfff95a270337d9d12c0237", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1957,15 +1957,23 @@ extern \"rust-intrinsic\" {\n     /// Internal placeholder for injecting code coverage counters when the \"instrument-coverage\"\n     /// option is enabled. The placeholder is replaced with `llvm.instrprof.increment` during code\n     /// generation.\n+    #[cfg(not(bootstrap))]\n     #[lang = \"count_code_region\"]\n-    pub fn count_code_region(index: u32, start_byte_pos: u32, end_byte_pos: u32);\n+    pub fn count_code_region(\n+        function_source_hash: u64,\n+        index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n \n     /// Internal marker for code coverage expressions, injected into the MIR when the\n     /// \"instrument-coverage\" option is enabled. This intrinsic is not converted into a\n     /// backend intrinsic call, but its arguments are extracted during the production of a\n     /// \"coverage map\", which is injected into the generated code, as additional data.\n     /// This marker identifies a code region and two other counters or counter expressions\n     /// whose sum is the number of times the code region was executed.\n+    #[cfg(not(bootstrap))]\n+    #[lang = \"coverage_counter_add\"]\n     pub fn coverage_counter_add(\n         index: u32,\n         left_index: u32,\n@@ -1977,6 +1985,8 @@ extern \"rust-intrinsic\" {\n     /// This marker identifies a code region and two other counters or counter expressions\n     /// whose difference is the number of times the code region was executed.\n     /// (See `coverage_counter_add` for more information.)\n+    #[cfg(not(bootstrap))]\n+    #[lang = \"coverage_counter_subtract\"]\n     pub fn coverage_counter_subtract(\n         index: u32,\n         left_index: u32,"}, {"sha": "227a87ff8199495c2b8a9549c2bd44a1b827c777", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -133,6 +133,9 @@ fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         return;\n     }\n \n+    // FIXME(richkadel): Make sure probestack plays nice with `-Z instrument-coverage`\n+    // or disable it if not, similar to above early exits.\n+\n     // Flag our internal `__rust_probestack` function as the stack probe symbol.\n     // This is defined in the `compiler-builtins` crate for each architecture.\n     llvm::AddFunctionAttrStringValue("}, {"sha": "b19199b9cfabd5bc80beb7dbc6fc167f3af7e0df", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -144,17 +144,18 @@ pub fn compile_codegen_unit(\n                 }\n             }\n \n+            // Finalize code coverage by injecting the coverage map. Note, the coverage map will\n+            // also be added to the `llvm.used` variable, created next.\n+            if cx.sess().opts.debugging_opts.instrument_coverage {\n+                cx.coverageinfo_finalize();\n+            }\n+\n             // Create the llvm.used variable\n             // This variable has type [N x i8*] and is stored in the llvm.metadata section\n             if !cx.used_statics().borrow().is_empty() {\n                 cx.create_used_variable()\n             }\n \n-            // Finalize code coverage by injecting the coverage map\n-            if cx.sess().opts.debugging_opts.instrument_coverage {\n-                cx.coverageinfo_finalize();\n-            }\n-\n             // Finalize debuginfo\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();"}, {"sha": "d58aad340a1dcbc57044edd5f0b473098b84cfbd", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1060,7 +1060,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             fn_name, hash, num_counters, index\n         );\n \n-        let llfn = unsafe { llvm::LLVMRustGetInstrprofIncrementIntrinsic(self.cx().llmod) };\n+        let llfn = unsafe { llvm::LLVMRustGetInstrProfIncrementIntrinsic(self.cx().llmod) };\n         let args = &[fn_name, hash, num_counters, index];\n         let args = self.check_call(\"call\", llfn, args);\n "}, {"sha": "c954415f19f346c080508c8df49bc1aa29f83ed7", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -493,10 +493,14 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n             }\n \n             if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n-                // This static will be stored in the llvm.used variable which is an array of i8*\n-                let cast = llvm::LLVMConstPointerCast(g, self.type_i8p());\n-                self.used_statics.borrow_mut().push(cast);\n+                self.add_used_global(g);\n             }\n         }\n     }\n+\n+    /// Add a global value to a list to be stored in the `llvm.used` variable, an array of i8*.\n+    fn add_used_global(&self, global: &'ll Value) {\n+        let cast = unsafe { llvm::LLVMConstPointerCast(global, self.type_i8p()) };\n+        self.used_statics.borrow_mut().push(cast);\n+    }\n }"}, {"sha": "7f48b1d864c7ca2256aa7334273812b9e72632e2", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,274 @@\n+use crate::llvm;\n+\n+use crate::common::CodegenCx;\n+use crate::coverageinfo;\n+\n+use log::debug;\n+use rustc_codegen_ssa::coverageinfo::map::*;\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, MiscMethods};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_llvm::RustString;\n+use rustc_middle::ty::Instance;\n+use rustc_middle::{bug, mir};\n+\n+use std::collections::BTreeMap;\n+use std::ffi::CString;\n+use std::path::PathBuf;\n+\n+// FIXME(richkadel): Complete all variations of generating and exporting the coverage map to LLVM.\n+// The current implementation is an initial foundation with basic capabilities (Counters, but not\n+// CounterExpressions, etc.).\n+\n+/// Generates and exports the Coverage Map.\n+///\n+/// This Coverage Map complies with Coverage Mapping Format version 3 (zero-based encoded as 2),\n+/// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format)\n+/// and published in Rust's current (July 2020) fork of LLVM. This version is supported by the\n+/// LLVM coverage tools (`llvm-profdata` and `llvm-cov`) bundled with Rust's fork of LLVM.\n+///\n+/// Consequently, Rust's bundled version of Clang also generates Coverage Maps compliant with\n+/// version 3. Clang's implementation of Coverage Map generation was referenced when implementing\n+/// this Rust version, and though the format documentation is very explicit and detailed, some\n+/// undocumented details in Clang's implementation (that may or may not be important) were also\n+/// replicated for Rust's Coverage Map.\n+pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n+    let mut coverage_writer = CoverageMappingWriter::new(cx);\n+\n+    let function_coverage_map = cx.coverage_context().take_function_coverage_map();\n+\n+    // Encode coverage mappings and generate function records\n+    let mut function_records = Vec::<&'ll llvm::Value>::new();\n+    let coverage_mappings_buffer = llvm::build_byte_buffer(|coverage_mappings_buffer| {\n+        for (instance, function_coverage) in function_coverage_map.into_iter() {\n+            if let Some(function_record) = coverage_writer.write_function_mappings_and_record(\n+                instance,\n+                function_coverage,\n+                coverage_mappings_buffer,\n+            ) {\n+                function_records.push(function_record);\n+            }\n+        }\n+    });\n+\n+    // Encode all filenames covered in this module, ordered by `file_id`\n+    let filenames_buffer = llvm::build_byte_buffer(|filenames_buffer| {\n+        coverageinfo::write_filenames_section_to_buffer(\n+            &coverage_writer.filenames,\n+            filenames_buffer,\n+        );\n+    });\n+\n+    if coverage_mappings_buffer.len() > 0 {\n+        // Generate the LLVM IR representation of the coverage map and store it in a well-known\n+        // global constant.\n+        coverage_writer.write_coverage_map(\n+            function_records,\n+            filenames_buffer,\n+            coverage_mappings_buffer,\n+        );\n+    }\n+}\n+\n+struct CoverageMappingWriter<'a, 'll, 'tcx> {\n+    cx: &'a CodegenCx<'ll, 'tcx>,\n+    filenames: Vec<CString>,\n+    filename_to_index: FxHashMap<CString, u32>,\n+}\n+\n+impl<'a, 'll, 'tcx> CoverageMappingWriter<'a, 'll, 'tcx> {\n+    fn new(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n+        Self { cx, filenames: Vec::new(), filename_to_index: FxHashMap::<CString, u32>::default() }\n+    }\n+\n+    /// For the given function, get the coverage region data, stream it to the given buffer, and\n+    /// then generate and return a new function record.\n+    fn write_function_mappings_and_record(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        mut function_coverage: FunctionCoverage,\n+        coverage_mappings_buffer: &RustString,\n+    ) -> Option<&'ll llvm::Value> {\n+        let cx = self.cx;\n+        let coverageinfo: &mir::CoverageInfo = cx.tcx.coverageinfo(instance.def_id());\n+        debug!(\n+            \"Generate coverage map for: {:?}, num_counters: {}, num_expressions: {}\",\n+            instance, coverageinfo.num_counters, coverageinfo.num_expressions\n+        );\n+        debug_assert!(coverageinfo.num_counters > 0);\n+\n+        let regions_in_file_order = function_coverage.regions_in_file_order(cx.sess().source_map());\n+        if regions_in_file_order.len() == 0 {\n+            return None;\n+        }\n+\n+        // Stream the coverage mapping regions for the function (`instance`) to the buffer, and\n+        // compute the data byte size used.\n+        let old_len = coverage_mappings_buffer.len();\n+        self.regions_to_mappings(regions_in_file_order, coverage_mappings_buffer);\n+        let mapping_data_size = coverage_mappings_buffer.len() - old_len;\n+        debug_assert!(mapping_data_size > 0);\n+\n+        let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n+        let name_ref = coverageinfo::compute_hash(&mangled_function_name);\n+        let function_source_hash = function_coverage.source_hash();\n+\n+        // Generate and return the function record\n+        let name_ref_val = cx.const_u64(name_ref);\n+        let mapping_data_size_val = cx.const_u32(mapping_data_size as u32);\n+        let func_hash_val = cx.const_u64(function_source_hash);\n+        Some(cx.const_struct(\n+            &[name_ref_val, mapping_data_size_val, func_hash_val],\n+            /*packed=*/ true,\n+        ))\n+    }\n+\n+    /// For each coverage region, extract its coverage data from the earlier coverage analysis.\n+    /// Use LLVM APIs to convert the data into buffered bytes compliant with the LLVM Coverage\n+    /// Mapping format.\n+    fn regions_to_mappings(\n+        &mut self,\n+        regions_in_file_order: BTreeMap<PathBuf, BTreeMap<CoverageLoc, (usize, CoverageKind)>>,\n+        coverage_mappings_buffer: &RustString,\n+    ) {\n+        let mut virtual_file_mapping = Vec::new();\n+        let mut mapping_regions = coverageinfo::SmallVectorCounterMappingRegion::new();\n+        let mut expressions = coverageinfo::SmallVectorCounterExpression::new();\n+\n+        for (file_id, (file_path, file_coverage_regions)) in\n+            regions_in_file_order.into_iter().enumerate()\n+        {\n+            let file_id = file_id as u32;\n+            let filename = CString::new(file_path.to_string_lossy().to_string())\n+                .expect(\"null error converting filename to C string\");\n+            debug!(\"  file_id: {} = '{:?}'\", file_id, filename);\n+            let filenames_index = match self.filename_to_index.get(&filename) {\n+                Some(index) => *index,\n+                None => {\n+                    let index = self.filenames.len() as u32;\n+                    self.filenames.push(filename.clone());\n+                    self.filename_to_index.insert(filename, index);\n+                    index\n+                }\n+            };\n+            virtual_file_mapping.push(filenames_index);\n+\n+            let mut mapping_indexes = vec![0 as u32; file_coverage_regions.len()];\n+            for (mapping_index, (region_id, _)) in file_coverage_regions.values().enumerate() {\n+                mapping_indexes[*region_id] = mapping_index as u32;\n+            }\n+\n+            for (region_loc, (region_id, region_kind)) in file_coverage_regions.into_iter() {\n+                let mapping_index = mapping_indexes[region_id];\n+                match region_kind {\n+                    CoverageKind::Counter => {\n+                        debug!(\n+                            \"  Counter {}, file_id: {}, region_loc: {}\",\n+                            mapping_index, file_id, region_loc\n+                        );\n+                        mapping_regions.push_from(\n+                            mapping_index,\n+                            file_id,\n+                            region_loc.start_line,\n+                            region_loc.start_col,\n+                            region_loc.end_line,\n+                            region_loc.end_col,\n+                        );\n+                    }\n+                    CoverageKind::CounterExpression(lhs, op, rhs) => {\n+                        debug!(\n+                            \"  CounterExpression {} = {} {:?} {}, file_id: {}, region_loc: {:?}\",\n+                            mapping_index, lhs, op, rhs, file_id, region_loc,\n+                        );\n+                        mapping_regions.push_from(\n+                            mapping_index,\n+                            file_id,\n+                            region_loc.start_line,\n+                            region_loc.start_col,\n+                            region_loc.end_line,\n+                            region_loc.end_col,\n+                        );\n+                        expressions.push_from(op, lhs, rhs);\n+                    }\n+                    CoverageKind::Unreachable => {\n+                        debug!(\n+                            \"  Unreachable region, file_id: {}, region_loc: {:?}\",\n+                            file_id, region_loc,\n+                        );\n+                        bug!(\"Unreachable region not expected and not yet handled!\")\n+                        // FIXME(richkadel): implement and call\n+                        //   mapping_regions.push_from(...) for unreachable regions\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Encode and append the current function's coverage mapping data\n+        coverageinfo::write_mapping_to_buffer(\n+            virtual_file_mapping,\n+            expressions,\n+            mapping_regions,\n+            coverage_mappings_buffer,\n+        );\n+    }\n+\n+    fn write_coverage_map(\n+        self,\n+        function_records: Vec<&'ll llvm::Value>,\n+        filenames_buffer: Vec<u8>,\n+        mut coverage_mappings_buffer: Vec<u8>,\n+    ) {\n+        let cx = self.cx;\n+\n+        // Concatenate the encoded filenames and encoded coverage mappings, and add additional zero\n+        // bytes as-needed to ensure 8-byte alignment.\n+        let mut coverage_size = coverage_mappings_buffer.len();\n+        let filenames_size = filenames_buffer.len();\n+        let remaining_bytes =\n+            (filenames_size + coverage_size) % coverageinfo::COVMAP_VAR_ALIGN_BYTES;\n+        if remaining_bytes > 0 {\n+            let pad = coverageinfo::COVMAP_VAR_ALIGN_BYTES - remaining_bytes;\n+            coverage_mappings_buffer.append(&mut [0].repeat(pad));\n+            coverage_size += pad;\n+        }\n+        let filenames_and_coverage_mappings = [filenames_buffer, coverage_mappings_buffer].concat();\n+        let filenames_and_coverage_mappings_val =\n+            cx.const_bytes(&filenames_and_coverage_mappings[..]);\n+\n+        debug!(\n+            \"cov map: n_records = {}, filenames_size = {}, coverage_size = {}, 0-based version = {}\",\n+            function_records.len(),\n+            filenames_size,\n+            coverage_size,\n+            coverageinfo::mapping_version()\n+        );\n+\n+        // Create the coverage data header\n+        let n_records_val = cx.const_u32(function_records.len() as u32);\n+        let filenames_size_val = cx.const_u32(filenames_size as u32);\n+        let coverage_size_val = cx.const_u32(coverage_size as u32);\n+        let version_val = cx.const_u32(coverageinfo::mapping_version());\n+        let cov_data_header_val = cx.const_struct(\n+            &[n_records_val, filenames_size_val, coverage_size_val, version_val],\n+            /*packed=*/ false,\n+        );\n+\n+        // Create the function records array\n+        let name_ref_from_u64 = cx.type_i64();\n+        let mapping_data_size_from_u32 = cx.type_i32();\n+        let func_hash_from_u64 = cx.type_i64();\n+        let function_record_ty = cx.type_struct(\n+            &[name_ref_from_u64, mapping_data_size_from_u32, func_hash_from_u64],\n+            /*packed=*/ true,\n+        );\n+        let function_records_val = cx.const_array(function_record_ty, &function_records[..]);\n+\n+        // Create the complete LLVM coverage data value to add to the LLVM IR\n+        let cov_data_val = cx.const_struct(\n+            &[cov_data_header_val, function_records_val, filenames_and_coverage_mappings_val],\n+            /*packed=*/ false,\n+        );\n+\n+        // Save the coverage data value to LLVM IR\n+        coverageinfo::save_map_to_mod(cx, cov_data_val);\n+    }\n+}"}, {"sha": "76894bcd6c1b1c4a63c8b1bcc8c0ef859a629b58", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 204, "deletions": 62, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1,88 +1,67 @@\n+use crate::llvm;\n+\n use crate::builder::Builder;\n use crate::common::CodegenCx;\n+\n+use libc::c_uint;\n use log::debug;\n use rustc_codegen_ssa::coverageinfo::map::*;\n-use rustc_codegen_ssa::traits::{CoverageInfoBuilderMethods, CoverageInfoMethods};\n+use rustc_codegen_ssa::traits::{\n+    BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, StaticMethods,\n+};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_llvm::RustString;\n use rustc_middle::ty::Instance;\n \n use std::cell::RefCell;\n+use std::ffi::CString;\n+\n+pub mod mapgen;\n+\n+const COVMAP_VAR_ALIGN_BYTES: usize = 8;\n \n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'tcx> {\n     // Coverage region data for each instrumented function identified by DefId.\n-    pub(crate) coverage_regions: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverageRegions>>,\n+    pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage>>,\n }\n \n impl<'tcx> CrateCoverageContext<'tcx> {\n     pub fn new() -> Self {\n-        Self { coverage_regions: Default::default() }\n+        Self { function_coverage_map: Default::default() }\n     }\n-}\n \n-/// Generates and exports the Coverage Map.\n-// FIXME(richkadel): Actually generate and export the coverage map to LLVM.\n-// The current implementation is actually just debug messages to show the data is available.\n-pub fn finalize(cx: &CodegenCx<'_, '_>) {\n-    let coverage_regions = &*cx.coverage_context().coverage_regions.borrow();\n-    for instance in coverage_regions.keys() {\n-        let coverageinfo = cx.tcx.coverageinfo(instance.def_id());\n-        debug_assert!(coverageinfo.num_counters > 0);\n-        debug!(\n-            \"Generate coverage map for: {:?}, hash: {}, num_counters: {}\",\n-            instance, coverageinfo.hash, coverageinfo.num_counters\n-        );\n-        let function_coverage_regions = &coverage_regions[instance];\n-        for (index, region) in function_coverage_regions.indexed_regions() {\n-            match region.kind {\n-                CoverageKind::Counter => debug!(\n-                    \"  Counter {}, for {}..{}\",\n-                    index, region.coverage_span.start_byte_pos, region.coverage_span.end_byte_pos\n-                ),\n-                CoverageKind::CounterExpression(lhs, op, rhs) => debug!(\n-                    \"  CounterExpression {} = {} {:?} {}, for {}..{}\",\n-                    index,\n-                    lhs,\n-                    op,\n-                    rhs,\n-                    region.coverage_span.start_byte_pos,\n-                    region.coverage_span.end_byte_pos\n-                ),\n-            }\n-        }\n-        for unreachable in function_coverage_regions.unreachable_regions() {\n-            debug!(\n-                \"  Unreachable code region: {}..{}\",\n-                unreachable.start_byte_pos, unreachable.end_byte_pos\n-            );\n-        }\n+    pub fn take_function_coverage_map(&self) -> FxHashMap<Instance<'tcx>, FunctionCoverage> {\n+        self.function_coverage_map.replace(FxHashMap::default())\n     }\n }\n \n impl CoverageInfoMethods for CodegenCx<'ll, 'tcx> {\n     fn coverageinfo_finalize(&self) {\n-        finalize(self)\n+        mapgen::finalize(self)\n     }\n }\n \n impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,\n+        function_source_hash: u64,\n         index: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding counter to coverage map: instance={:?}, index={}, byte range {}..{}\",\n-            instance, index, start_byte_pos, end_byte_pos,\n-        );\n-        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n-        coverage_regions.entry(instance).or_default().add_counter(\n-            index,\n-            start_byte_pos,\n-            end_byte_pos,\n+            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, index={}, byte range {}..{}\",\n+            instance, function_source_hash, index, start_byte_pos, end_byte_pos,\n         );\n+        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n+        coverage_regions\n+            .entry(instance)\n+            .or_insert_with(|| {\n+                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n+            })\n+            .add_counter(function_source_hash, index, start_byte_pos, end_byte_pos);\n     }\n \n     fn add_counter_expression_region(\n@@ -96,18 +75,16 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding counter expression to coverage map: instance={:?}, index={}, {} {:?} {}, byte range {}..{}\",\n+            \"adding counter expression to coverage_regions: instance={:?}, index={}, {} {:?} {}, byte range {}..{}\",\n             instance, index, lhs, op, rhs, start_byte_pos, end_byte_pos,\n         );\n-        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n-        coverage_regions.entry(instance).or_default().add_counter_expression(\n-            index,\n-            lhs,\n-            op,\n-            rhs,\n-            start_byte_pos,\n-            end_byte_pos,\n-        );\n+        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n+        coverage_regions\n+            .entry(instance)\n+            .or_insert_with(|| {\n+                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n+            })\n+            .add_counter_expression(index, lhs, op, rhs, start_byte_pos, end_byte_pos);\n     }\n \n     fn add_unreachable_region(\n@@ -117,10 +94,175 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding unreachable code to coverage map: instance={:?}, byte range {}..{}\",\n+            \"adding unreachable code to coverage_regions: instance={:?}, byte range {}..{}\",\n             instance, start_byte_pos, end_byte_pos,\n         );\n-        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n-        coverage_regions.entry(instance).or_default().add_unreachable(start_byte_pos, end_byte_pos);\n+        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n+        coverage_regions\n+            .entry(instance)\n+            .or_insert_with(|| {\n+                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n+            })\n+            .add_unreachable(start_byte_pos, end_byte_pos);\n+    }\n+}\n+\n+/// This struct wraps an opaque reference to the C++ template instantiation of\n+/// `llvm::SmallVector<coverage::CounterExpression>`. Each `coverage::CounterExpression` object is\n+/// constructed from primative-typed arguments, and pushed to the `SmallVector`, in the C++\n+/// implementation of `LLVMRustCoverageSmallVectorCounterExpressionAdd()` (see\n+/// `src/rustllvm/CoverageMappingWrapper.cpp`).\n+pub struct SmallVectorCounterExpression<'a> {\n+    pub raw: &'a mut llvm::coverageinfo::SmallVectorCounterExpression<'a>,\n+}\n+\n+impl SmallVectorCounterExpression<'a> {\n+    pub fn new() -> Self {\n+        SmallVectorCounterExpression {\n+            raw: unsafe { llvm::LLVMRustCoverageSmallVectorCounterExpressionCreate() },\n+        }\n+    }\n+\n+    pub fn as_ptr(&self) -> *const llvm::coverageinfo::SmallVectorCounterExpression<'a> {\n+        self.raw\n+    }\n+\n+    pub fn push_from(\n+        &mut self,\n+        kind: rustc_codegen_ssa::coverageinfo::CounterOp,\n+        left_index: u32,\n+        right_index: u32,\n+    ) {\n+        unsafe {\n+            llvm::LLVMRustCoverageSmallVectorCounterExpressionAdd(\n+                &mut *(self.raw as *mut _),\n+                kind,\n+                left_index,\n+                right_index,\n+            )\n+        }\n+    }\n+}\n+\n+impl Drop for SmallVectorCounterExpression<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustCoverageSmallVectorCounterExpressionDispose(&mut *(self.raw as *mut _));\n+        }\n+    }\n+}\n+\n+/// This struct wraps an opaque reference to the C++ template instantiation of\n+/// `llvm::SmallVector<coverage::CounterMappingRegion>`. Each `coverage::CounterMappingRegion`\n+/// object is constructed from primative-typed arguments, and pushed to the `SmallVector`, in the\n+/// C++ implementation of `LLVMRustCoverageSmallVectorCounterMappingRegionAdd()` (see\n+/// `src/rustllvm/CoverageMappingWrapper.cpp`).\n+pub struct SmallVectorCounterMappingRegion<'a> {\n+    pub raw: &'a mut llvm::coverageinfo::SmallVectorCounterMappingRegion<'a>,\n+}\n+\n+impl SmallVectorCounterMappingRegion<'a> {\n+    pub fn new() -> Self {\n+        SmallVectorCounterMappingRegion {\n+            raw: unsafe { llvm::LLVMRustCoverageSmallVectorCounterMappingRegionCreate() },\n+        }\n+    }\n+\n+    pub fn as_ptr(&self) -> *const llvm::coverageinfo::SmallVectorCounterMappingRegion<'a> {\n+        self.raw\n+    }\n+\n+    pub fn push_from(\n+        &mut self,\n+        index: u32,\n+        file_id: u32,\n+        line_start: u32,\n+        column_start: u32,\n+        line_end: u32,\n+        column_end: u32,\n+    ) {\n+        unsafe {\n+            llvm::LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n+                &mut *(self.raw as *mut _),\n+                index,\n+                file_id,\n+                line_start,\n+                column_start,\n+                line_end,\n+                column_end,\n+            )\n+        }\n+    }\n+}\n+\n+impl Drop for SmallVectorCounterMappingRegion<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n+                &mut *(self.raw as *mut _),\n+            );\n+        }\n+    }\n+}\n+\n+pub(crate) fn write_filenames_section_to_buffer(filenames: &Vec<CString>, buffer: &RustString) {\n+    let c_str_vec = filenames.iter().map(|cstring| cstring.as_ptr()).collect::<Vec<_>>();\n+    unsafe {\n+        llvm::LLVMRustCoverageWriteFilenamesSectionToBuffer(\n+            c_str_vec.as_ptr(),\n+            c_str_vec.len(),\n+            buffer,\n+        );\n+    }\n+}\n+\n+pub(crate) fn write_mapping_to_buffer(\n+    virtual_file_mapping: Vec<u32>,\n+    expressions: SmallVectorCounterExpression<'_>,\n+    mapping_regions: SmallVectorCounterMappingRegion<'_>,\n+    buffer: &RustString,\n+) {\n+    unsafe {\n+        llvm::LLVMRustCoverageWriteMappingToBuffer(\n+            virtual_file_mapping.as_ptr(),\n+            virtual_file_mapping.len() as c_uint,\n+            expressions.as_ptr(),\n+            mapping_regions.as_ptr(),\n+            buffer,\n+        );\n     }\n }\n+\n+pub(crate) fn compute_hash(name: &str) -> u64 {\n+    let name = CString::new(name).expect(\"null error converting hashable name to C string\");\n+    unsafe { llvm::LLVMRustCoverageComputeHash(name.as_ptr()) }\n+}\n+\n+pub(crate) fn mapping_version() -> u32 {\n+    unsafe { llvm::LLVMRustCoverageMappingVersion() }\n+}\n+\n+pub(crate) fn save_map_to_mod<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    cov_data_val: &'ll llvm::Value,\n+) {\n+    let covmap_var_name = llvm::build_string(|s| unsafe {\n+        llvm::LLVMRustCoverageWriteMappingVarNameToString(s);\n+    })\n+    .expect(\"Rust Coverage Mapping var name failed UTF-8 conversion\");\n+    debug!(\"covmap var name: {:?}\", covmap_var_name);\n+\n+    let covmap_section_name = llvm::build_string(|s| unsafe {\n+        llvm::LLVMRustCoverageWriteSectionNameToString(cx.llmod, s);\n+    })\n+    .expect(\"Rust Coverage section name failed UTF-8 conversion\");\n+    debug!(\"covmap section name: {:?}\", covmap_section_name);\n+\n+    let llglobal = llvm::add_global(cx.llmod, cx.val_ty(cov_data_val), &covmap_var_name);\n+    llvm::set_initializer(llglobal, cov_data_val);\n+    llvm::set_global_constant(llglobal, true);\n+    llvm::set_linkage(llglobal, llvm::Linkage::InternalLinkage);\n+    llvm::set_section(llglobal, &covmap_section_name);\n+    llvm::set_alignment(llglobal, COVMAP_VAR_ALIGN_BYTES);\n+    cx.add_used_global(llglobal);\n+}"}, {"sha": "63ec8031483fed508f50f03fa06d6d29284f627a", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -90,45 +90,64 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &Vec<Operand<'tcx>>,\n         caller_instance: ty::Instance<'tcx>,\n     ) -> bool {\n-        match intrinsic {\n-            sym::count_code_region => {\n-                use coverage::count_code_region_args::*;\n-                self.add_counter_region(\n-                    caller_instance,\n-                    op_to_u32(&args[COUNTER_INDEX]),\n-                    op_to_u32(&args[START_BYTE_POS]),\n-                    op_to_u32(&args[END_BYTE_POS]),\n-                );\n-                true // Also inject the counter increment in the backend\n-            }\n-            sym::coverage_counter_add | sym::coverage_counter_subtract => {\n-                use coverage::coverage_counter_expression_args::*;\n-                self.add_counter_expression_region(\n-                    caller_instance,\n-                    op_to_u32(&args[COUNTER_EXPRESSION_INDEX]),\n-                    op_to_u32(&args[LEFT_INDEX]),\n-                    if intrinsic == sym::coverage_counter_add {\n-                        CounterOp::Add\n-                    } else {\n-                        CounterOp::Subtract\n-                    },\n-                    op_to_u32(&args[RIGHT_INDEX]),\n-                    op_to_u32(&args[START_BYTE_POS]),\n-                    op_to_u32(&args[END_BYTE_POS]),\n-                );\n-                false // Does not inject backend code\n-            }\n-            sym::coverage_unreachable => {\n-                use coverage::coverage_unreachable_args::*;\n-                self.add_unreachable_region(\n-                    caller_instance,\n-                    op_to_u32(&args[START_BYTE_POS]),\n-                    op_to_u32(&args[END_BYTE_POS]),\n-                );\n-                false // Does not inject backend code\n+        if self.tcx.sess.opts.debugging_opts.instrument_coverage {\n+            // Add the coverage information from the MIR to the Codegen context. Some coverage\n+            // intrinsics are used only to pass along the coverage information (returns `false`\n+            // for `is_codegen_intrinsic()`), but `count_code_region` is also converted into an\n+            // LLVM intrinsic to increment a coverage counter.\n+            match intrinsic {\n+                sym::count_code_region => {\n+                    use coverage::count_code_region_args::*;\n+                    self.add_counter_region(\n+                        caller_instance,\n+                        op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n+                        op_to_u32(&args[COUNTER_INDEX]),\n+                        op_to_u32(&args[START_BYTE_POS]),\n+                        op_to_u32(&args[END_BYTE_POS]),\n+                    );\n+                    return true; // Also inject the counter increment in the backend\n+                }\n+                sym::coverage_counter_add | sym::coverage_counter_subtract => {\n+                    use coverage::coverage_counter_expression_args::*;\n+                    self.add_counter_expression_region(\n+                        caller_instance,\n+                        op_to_u32(&args[COUNTER_EXPRESSION_INDEX]),\n+                        op_to_u32(&args[LEFT_INDEX]),\n+                        if intrinsic == sym::coverage_counter_add {\n+                            CounterOp::Add\n+                        } else {\n+                            CounterOp::Subtract\n+                        },\n+                        op_to_u32(&args[RIGHT_INDEX]),\n+                        op_to_u32(&args[START_BYTE_POS]),\n+                        op_to_u32(&args[END_BYTE_POS]),\n+                    );\n+                    return false; // Does not inject backend code\n+                }\n+                sym::coverage_unreachable => {\n+                    use coverage::coverage_unreachable_args::*;\n+                    self.add_unreachable_region(\n+                        caller_instance,\n+                        op_to_u32(&args[START_BYTE_POS]),\n+                        op_to_u32(&args[END_BYTE_POS]),\n+                    );\n+                    return false; // Does not inject backend code\n+                }\n+                _ => {}\n+            }\n+        } else {\n+            // NOT self.tcx.sess.opts.debugging_opts.instrument_coverage\n+            if intrinsic == sym::count_code_region {\n+                // An external crate may have been pre-compiled with coverage instrumentation, and\n+                // some references from the current crate to the external crate might carry along\n+                // the call terminators to coverage intrinsics, like `count_code_region` (for\n+                // example, when instantiating a generic function). If the current crate has\n+                // `instrument_coverage` disabled, the `count_code_region` call terminators should\n+                // be ignored.\n+                return false; // Do not inject coverage counters inlined from external crates\n             }\n-            _ => true, // Unhandled intrinsics should be passed to `codegen_intrinsic_call()`\n         }\n+        true // Unhandled intrinsics should be passed to `codegen_intrinsic_call()`\n     }\n \n     fn codegen_intrinsic_call(\n@@ -197,12 +216,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n                 let mangled_fn = tcx.symbol_name(caller_instance);\n                 let (mangled_fn_name, _len_val) = self.const_str(Symbol::intern(mangled_fn.name));\n-                let hash = self.const_u64(coverageinfo.hash);\n                 let num_counters = self.const_u32(coverageinfo.num_counters);\n                 use coverage::count_code_region_args::*;\n+                let hash = args[FUNCTION_SOURCE_HASH].immediate();\n                 let index = args[COUNTER_INDEX].immediate();\n                 debug!(\n-                    \"count_code_region to LLVM intrinsic instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n+                    \"translating Rust intrinsic `count_code_region()` to LLVM intrinsic: \\\n+                    instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n                     mangled_fn.name, hash, num_counters, index,\n                 );\n                 self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n@@ -2222,3 +2242,7 @@ fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n fn op_to_u32<'tcx>(op: &Operand<'tcx>) -> u32 {\n     Operand::scalar_from_const(op).to_u32().expect(\"Scalar is u32\")\n }\n+\n+fn op_to_u64<'tcx>(op: &Operand<'tcx>) -> u64 {\n+    Operand::scalar_from_const(op).to_u64().expect(\"Scalar is u64\")\n+}"}, {"sha": "9784beaa079de7f2b892b710ad730ec129fc325e", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1,6 +1,8 @@\n #![allow(non_camel_case_types)]\n #![allow(non_upper_case_globals)]\n \n+use super::coverageinfo::{SmallVectorCounterExpression, SmallVectorCounterMappingRegion};\n+\n use super::debuginfo::{\n     DIArray, DIBasicType, DIBuilder, DICompositeType, DIDerivedType, DIDescriptor, DIEnumerator,\n     DIFile, DIFlags, DIGlobalVariableExpression, DILexicalBlock, DINameSpace, DISPFlags, DIScope,\n@@ -650,6 +652,16 @@ pub struct Linker<'a>(InvariantOpaque<'a>);\n pub type DiagnosticHandler = unsafe extern \"C\" fn(&DiagnosticInfo, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(&SMDiagnostic, *const c_void, c_uint);\n \n+pub mod coverageinfo {\n+    use super::InvariantOpaque;\n+\n+    #[repr(C)]\n+    pub struct SmallVectorCounterExpression<'a>(InvariantOpaque<'a>);\n+\n+    #[repr(C)]\n+    pub struct SmallVectorCounterMappingRegion<'a>(InvariantOpaque<'a>);\n+}\n+\n pub mod debuginfo {\n     use super::{InvariantOpaque, Metadata};\n     use bitflags::bitflags;\n@@ -1365,7 +1377,7 @@ extern \"C\" {\n \n     // Miscellaneous instructions\n     pub fn LLVMBuildPhi(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMRustGetInstrprofIncrementIntrinsic(M: &Module) -> &'a Value;\n+    pub fn LLVMRustGetInstrProfIncrementIntrinsic(M: &Module) -> &'a Value;\n     pub fn LLVMRustBuildCall(\n         B: &Builder<'a>,\n         Fn: &'a Value,\n@@ -1633,6 +1645,58 @@ extern \"C\" {\n         ConstraintsLen: size_t,\n     ) -> bool;\n \n+    pub fn LLVMRustCoverageSmallVectorCounterExpressionCreate()\n+    -> &'a mut SmallVectorCounterExpression<'a>;\n+    pub fn LLVMRustCoverageSmallVectorCounterExpressionDispose(\n+        Container: &'a mut SmallVectorCounterExpression<'a>,\n+    );\n+    pub fn LLVMRustCoverageSmallVectorCounterExpressionAdd(\n+        Container: &mut SmallVectorCounterExpression<'a>,\n+        Kind: rustc_codegen_ssa::coverageinfo::CounterOp,\n+        LeftIndex: c_uint,\n+        RightIndex: c_uint,\n+    );\n+\n+    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionCreate()\n+    -> &'a mut SmallVectorCounterMappingRegion<'a>;\n+    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n+        Container: &'a mut SmallVectorCounterMappingRegion<'a>,\n+    );\n+    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n+        Container: &mut SmallVectorCounterMappingRegion<'a>,\n+        Index: c_uint,\n+        FileID: c_uint,\n+        LineStart: c_uint,\n+        ColumnStart: c_uint,\n+        LineEnd: c_uint,\n+        ColumnEnd: c_uint,\n+    );\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteFilenamesSectionToBuffer(\n+        Filenames: *const *const c_char,\n+        FilenamesLen: size_t,\n+        BufferOut: &RustString,\n+    );\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteMappingToBuffer(\n+        VirtualFileMappingIDs: *const c_uint,\n+        NumVirtualFileMappingIDs: c_uint,\n+        Expressions: *const SmallVectorCounterExpression<'_>,\n+        MappingRegions: *const SmallVectorCounterMappingRegion<'_>,\n+        BufferOut: &RustString,\n+    );\n+\n+    pub fn LLVMRustCoverageComputeHash(Name: *const c_char) -> u64;\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteSectionNameToString(M: &Module, Str: &RustString);\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteMappingVarNameToString(Str: &RustString);\n+\n+    pub fn LLVMRustCoverageMappingVersion() -> u32;\n     pub fn LLVMRustDebugMetadataVersion() -> u32;\n     pub fn LLVMRustVersionMajor() -> u32;\n     pub fn LLVMRustVersionMinor() -> u32;"}, {"sha": "c09e3659f80a20053b6819df530bee4d783b78f8", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -12,7 +12,7 @@ use libc::c_uint;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_llvm::RustString;\n use std::cell::RefCell;\n-use std::ffi::CStr;\n+use std::ffi::{CStr, CString};\n use std::str::FromStr;\n use std::string::FromUtf8Error;\n \n@@ -189,6 +189,42 @@ pub fn mk_section_iter(llof: &ffi::ObjectFile) -> SectionIter<'_> {\n     unsafe { SectionIter { llsi: LLVMGetSections(llof) } }\n }\n \n+pub fn set_section(llglobal: &Value, section_name: &str) {\n+    let section_name_cstr = CString::new(section_name).expect(\"unexpected CString error\");\n+    unsafe {\n+        LLVMSetSection(llglobal, section_name_cstr.as_ptr());\n+    }\n+}\n+\n+pub fn add_global<'a>(llmod: &'a Module, ty: &'a Type, name: &str) -> &'a Value {\n+    let name_cstr = CString::new(name).expect(\"unexpected CString error\");\n+    unsafe { LLVMAddGlobal(llmod, ty, name_cstr.as_ptr()) }\n+}\n+\n+pub fn set_initializer(llglobal: &Value, constant_val: &Value) {\n+    unsafe {\n+        LLVMSetInitializer(llglobal, constant_val);\n+    }\n+}\n+\n+pub fn set_global_constant(llglobal: &Value, is_constant: bool) {\n+    unsafe {\n+        LLVMSetGlobalConstant(llglobal, if is_constant { ffi::True } else { ffi::False });\n+    }\n+}\n+\n+pub fn set_linkage(llglobal: &Value, linkage: Linkage) {\n+    unsafe {\n+        LLVMRustSetLinkage(llglobal, linkage);\n+    }\n+}\n+\n+pub fn set_alignment(llglobal: &Value, bytes: usize) {\n+    unsafe {\n+        ffi::LLVMSetAlignment(llglobal, bytes as c_uint);\n+    }\n+}\n+\n /// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n pub fn get_param(llfn: &Value, index: c_uint) -> &Value {\n     unsafe {\n@@ -225,6 +261,12 @@ pub fn build_string(f: impl FnOnce(&RustString)) -> Result<String, FromUtf8Error\n     String::from_utf8(sr.bytes.into_inner())\n }\n \n+pub fn build_byte_buffer(f: impl FnOnce(&RustString)) -> Vec<u8> {\n+    let sr = RustString { bytes: RefCell::new(Vec::new()) };\n+    f(&sr);\n+    sr.bytes.into_inner()\n+}\n+\n pub fn twine_to_string(tr: &Twine) -> String {\n     unsafe {\n         build_string(|s| LLVMRustWriteTwineToString(tr, s)).expect(\"got a non-UTF8 Twine from LLVM\")"}, {"sha": "2d65282ce7798751268970eb62534bf7349201b6", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1659,7 +1659,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // FIXME: Order dependent, applies to the following objects. Where should it be placed?\n     // Try to strip as much out of the generated object by removing unused\n     // sections if possible. See more comments in linker.rs\n-    if !sess.opts.cg.link_dead_code {\n+    if sess.opts.cg.link_dead_code != Some(true) {\n         let keep_metadata = crate_type == CrateType::Dylib;\n         cmd.gc_sections(keep_metadata);\n     }\n@@ -1695,7 +1695,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     );\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.opts.cg.profile_generate.enabled() {\n+    if sess.opts.cg.profile_generate.enabled() || sess.opts.debugging_opts.instrument_coverage {\n         cmd.pgo_gen();\n     }\n "}, {"sha": "7d742e7a7afd2b35a613fb20f1b9569f2133507b", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -203,6 +203,17 @@ fn exported_symbols_provider_local(\n         }));\n     }\n \n+    if tcx.sess.opts.debugging_opts.instrument_coverage {\n+        // Similar to PGO profiling, preserve symbols used by LLVM InstrProf coverage profiling.\n+        const COVERAGE_WEAK_SYMBOLS: [&str; 3] =\n+            [\"__llvm_profile_filename\", \"__llvm_coverage_mapping\", \"__llvm_covmap\"];\n+\n+        symbols.extend(COVERAGE_WEAK_SYMBOLS.iter().map(|sym| {\n+            let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, sym));\n+            (exported_symbol, SymbolExportLevel::C)\n+        }));\n+    }\n+\n     if tcx.sess.opts.debugging_opts.sanitizer.contains(SanitizerSet::MEMORY) {\n         // Similar to profiling, preserve weak msan symbol during LTO.\n         const MSAN_WEAK_SYMBOLS: [&str; 2] = [\"__msan_track_origins\", \"__msan_keep_going\"];"}, {"sha": "a8ffef8bc5b6b2fae298aac14e5cdd8509bc45e9", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 241, "deletions": 35, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1,83 +1,289 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use std::collections::hash_map;\n-use std::slice;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_middle::mir;\n+use rustc_span::source_map::{Pos, SourceFile, SourceMap};\n+use rustc_span::{BytePos, FileName, RealFileName};\n+\n+use std::cmp::{Ord, Ordering};\n+use std::collections::BTreeMap;\n+use std::fmt;\n+use std::path::PathBuf;\n \n #[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n pub enum CounterOp {\n-    Add,\n+    // Note the order (and therefore the default values) is important. With the attribute\n+    // `#[repr(C)]`, this enum matches the layout of the LLVM enum defined for the nested enum,\n+    // `llvm::coverage::CounterExpression::ExprKind`, as shown in the following source snippet:\n+    // https://github.com/rust-lang/llvm-project/blob/f208b70fbc4dee78067b3c5bd6cb92aa3ba58a1e/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146\n     Subtract,\n+    Add,\n }\n \n+#[derive(Copy, Clone, Debug)]\n pub enum CoverageKind {\n     Counter,\n     CounterExpression(u32, CounterOp, u32),\n+    Unreachable,\n }\n \n-pub struct CoverageSpan {\n+#[derive(Clone, Debug)]\n+pub struct CoverageRegion {\n+    pub kind: CoverageKind,\n     pub start_byte_pos: u32,\n     pub end_byte_pos: u32,\n }\n \n-pub struct CoverageRegion {\n-    pub kind: CoverageKind,\n-    pub coverage_span: CoverageSpan,\n+impl CoverageRegion {\n+    pub fn source_loc(&self, source_map: &SourceMap) -> Option<(Lrc<SourceFile>, CoverageLoc)> {\n+        let (start_file, start_line, start_col) =\n+            lookup_file_line_col(source_map, BytePos::from_u32(self.start_byte_pos));\n+        let (end_file, end_line, end_col) =\n+            lookup_file_line_col(source_map, BytePos::from_u32(self.end_byte_pos));\n+        let start_file_path = match &start_file.name {\n+            FileName::Real(RealFileName::Named(path)) => path,\n+            _ => {\n+                bug!(\"start_file_path should be a RealFileName, but it was: {:?}\", start_file.name)\n+            }\n+        };\n+        let end_file_path = match &end_file.name {\n+            FileName::Real(RealFileName::Named(path)) => path,\n+            _ => bug!(\"end_file_path should be a RealFileName, but it was: {:?}\", end_file.name),\n+        };\n+        if start_file_path == end_file_path {\n+            Some((start_file, CoverageLoc { start_line, start_col, end_line, end_col }))\n+        } else {\n+            None\n+            // FIXME(richkadel): There seems to be a problem computing the file location in\n+            // some cases. I need to investigate this more. When I generate and show coverage\n+            // for the example binary in the crates.io crate `json5format`, I had a couple of\n+            // notable problems:\n+            //\n+            //   1. I saw a lot of coverage spans in `llvm-cov show` highlighting regions in\n+            //      various comments (not corresponding to rustdoc code), indicating a possible\n+            //      problem with the byte_pos-to-source-map implementation.\n+            //\n+            //   2. And (perhaps not related) when I build the aforementioned example binary with:\n+            //      `RUST_FLAGS=\"-Zinstrument-coverage\" cargo build --example formatjson5`\n+            //      and then run that binary with\n+            //      `LLVM_PROFILE_FILE=\"formatjson5.profraw\" ./target/debug/examples/formatjson5 \\\n+            //      some.json5` for some reason the binary generates *TWO* `.profraw` files. One\n+            //      named `default.profraw` and the other named `formatjson5.profraw` (the expected\n+            //      name, in this case).\n+            //\n+            // If the byte range conversion is wrong, fix it. But if it\n+            // is right, then it is possible for the start and end to be in different files.\n+            // Can I do something other than ignore coverages that span multiple files?\n+            //\n+            // If I can resolve this, remove the \"Option<>\" result type wrapper\n+            // `regions_in_file_order()` accordingly.\n+        }\n+    }\n+}\n+\n+impl Default for CoverageRegion {\n+    fn default() -> Self {\n+        Self {\n+            // The default kind (Unreachable) is a placeholder that will be overwritten before\n+            // backend codegen.\n+            kind: CoverageKind::Unreachable,\n+            start_byte_pos: 0,\n+            end_byte_pos: 0,\n+        }\n+    }\n+}\n+\n+/// A source code region used with coverage information.\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct CoverageLoc {\n+    /// The (1-based) line number of the region start.\n+    pub start_line: u32,\n+    /// The (1-based) column number of the region start.\n+    pub start_col: u32,\n+    /// The (1-based) line number of the region end.\n+    pub end_line: u32,\n+    /// The (1-based) column number of the region end.\n+    pub end_col: u32,\n+}\n+\n+impl Ord for CoverageLoc {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        (self.start_line, &self.start_col, &self.end_line, &self.end_col).cmp(&(\n+            other.start_line,\n+            &other.start_col,\n+            &other.end_line,\n+            &other.end_col,\n+        ))\n+    }\n+}\n+\n+impl PartialOrd for CoverageLoc {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl fmt::Display for CoverageLoc {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Customize debug format, and repeat the file name, so generated location strings are\n+        // \"clickable\" in many IDEs.\n+        write!(f, \"{}:{} - {}:{}\", self.start_line, self.start_col, self.end_line, self.end_col)\n+    }\n+}\n+\n+fn lookup_file_line_col(source_map: &SourceMap, byte_pos: BytePos) -> (Lrc<SourceFile>, u32, u32) {\n+    let found = source_map\n+        .lookup_line(byte_pos)\n+        .expect(\"should find coverage region byte position in source\");\n+    let file = found.sf;\n+    let line_pos = file.line_begin_pos(byte_pos);\n+\n+    // Use 1-based indexing.\n+    let line = (found.line + 1) as u32;\n+    let col = (byte_pos - line_pos).to_u32() + 1;\n+\n+    (file, line, col)\n }\n \n /// Collects all of the coverage regions associated with (a) injected counters, (b) counter\n /// expressions (additions or subtraction), and (c) unreachable regions (always counted as zero),\n /// for a given Function. Counters and counter expressions are indexed because they can be operands\n-/// in an expression.\n+/// in an expression. This struct also stores the `function_source_hash`, computed during\n+/// instrumentation and forwarded with counters.\n ///\n /// Note, it's important to distinguish the `unreachable` region type from what LLVM's refers to as\n /// a \"gap region\" (or \"gap area\"). A gap region is a code region within a counted region (either\n /// counter or expression), but the line or lines in the gap region are not executable (such as\n /// lines with only whitespace or comments). According to LLVM Code Coverage Mapping documentation,\n /// \"A count for a gap area is only used as the line execution count if there are no other regions\n /// on a line.\"\n-#[derive(Default)]\n-pub struct FunctionCoverageRegions {\n-    indexed: FxHashMap<u32, CoverageRegion>,\n-    unreachable: Vec<CoverageSpan>,\n+pub struct FunctionCoverage {\n+    source_hash: u64,\n+    counters: Vec<CoverageRegion>,\n+    expressions: Vec<CoverageRegion>,\n+    unreachable: Vec<CoverageRegion>,\n+    translated: bool,\n }\n \n-impl FunctionCoverageRegions {\n-    pub fn add_counter(&mut self, index: u32, start_byte_pos: u32, end_byte_pos: u32) {\n-        self.indexed.insert(\n-            index,\n-            CoverageRegion {\n-                kind: CoverageKind::Counter,\n-                coverage_span: CoverageSpan { start_byte_pos, end_byte_pos },\n-            },\n-        );\n+impl FunctionCoverage {\n+    pub fn with_coverageinfo<'tcx>(coverageinfo: &'tcx mir::CoverageInfo) -> Self {\n+        Self {\n+            source_hash: 0, // will be set with the first `add_counter()`\n+            counters: vec![CoverageRegion::default(); coverageinfo.num_counters as usize],\n+            expressions: vec![CoverageRegion::default(); coverageinfo.num_expressions as usize],\n+            unreachable: Vec::new(),\n+            translated: false,\n+        }\n     }\n \n-    pub fn add_counter_expression(\n+    /// Adds a code region to be counted by an injected counter intrinsic. Return a counter ID\n+    /// for the call.\n+    pub fn add_counter(\n         &mut self,\n+        source_hash: u64,\n         index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        self.source_hash = source_hash;\n+        self.counters[index as usize] =\n+            CoverageRegion { kind: CoverageKind::Counter, start_byte_pos, end_byte_pos };\n+    }\n+\n+    pub fn add_counter_expression(\n+        &mut self,\n+        translated_index: u32,\n         lhs: u32,\n         op: CounterOp,\n         rhs: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n-        self.indexed.insert(\n-            index,\n-            CoverageRegion {\n-                kind: CoverageKind::CounterExpression(lhs, op, rhs),\n-                coverage_span: CoverageSpan { start_byte_pos, end_byte_pos },\n-            },\n-        );\n+        let index = u32::MAX - translated_index;\n+        // Counter expressions start with \"translated indexes\", descending from `u32::MAX`, so\n+        // the range of expression indexes is disjoint from the range of counter indexes. This way,\n+        // both counters and expressions can be operands in other expressions.\n+        //\n+        // Once all counters have been added, the final \"region index\" for an expression is\n+        // `counters.len() + expression_index` (where `expression_index` is its index in\n+        // `self.expressions`), and the expression operands (`lhs` and `rhs`) can be converted to\n+        // final \"region index\" references by the same conversion, after subtracting from\n+        // `u32::MAX`.\n+        self.expressions[index as usize] = CoverageRegion {\n+            kind: CoverageKind::CounterExpression(lhs, op, rhs),\n+            start_byte_pos,\n+            end_byte_pos,\n+        };\n     }\n \n     pub fn add_unreachable(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n-        self.unreachable.push(CoverageSpan { start_byte_pos, end_byte_pos });\n+        self.unreachable.push(CoverageRegion {\n+            kind: CoverageKind::Unreachable,\n+            start_byte_pos,\n+            end_byte_pos,\n+        });\n+    }\n+\n+    pub fn source_hash(&self) -> u64 {\n+        self.source_hash\n+    }\n+\n+    fn regions(&'a mut self) -> impl Iterator<Item = &'a CoverageRegion> {\n+        assert!(self.source_hash != 0);\n+        self.ensure_expressions_translated();\n+        self.counters.iter().chain(self.expressions.iter().chain(self.unreachable.iter()))\n     }\n \n-    pub fn indexed_regions(&self) -> hash_map::Iter<'_, u32, CoverageRegion> {\n-        self.indexed.iter()\n+    pub fn regions_in_file_order(\n+        &'a mut self,\n+        source_map: &SourceMap,\n+    ) -> BTreeMap<PathBuf, BTreeMap<CoverageLoc, (usize, CoverageKind)>> {\n+        let mut regions_in_file_order = BTreeMap::new();\n+        for (region_id, region) in self.regions().enumerate() {\n+            if let Some((source_file, region_loc)) = region.source_loc(source_map) {\n+                // FIXME(richkadel): `region.source_loc()` sometimes fails with two different\n+                // filenames for the start and end byte position. This seems wrong, but for\n+                // now, if encountered, the region is skipped. If resolved, convert the result\n+                // to a non-option value so regions are never skipped.\n+                let real_file_path = match &(*source_file).name {\n+                    FileName::Real(RealFileName::Named(path)) => path.clone(),\n+                    _ => bug!(\"coverage mapping expected only real, named files\"),\n+                };\n+                let file_coverage_regions =\n+                    regions_in_file_order.entry(real_file_path).or_insert_with(|| BTreeMap::new());\n+                file_coverage_regions.insert(region_loc, (region_id, region.kind));\n+            }\n+        }\n+        regions_in_file_order\n     }\n \n-    pub fn unreachable_regions(&self) -> slice::Iter<'_, CoverageSpan> {\n-        self.unreachable.iter()\n+    /// A one-time translation of expression operands is needed, for any operands referencing\n+    /// other CounterExpressions. CounterExpression operands get an initial operand ID that is\n+    /// computed by the simple translation: `u32::max - expression_index` because, when created,\n+    /// the total number of Counters is not yet known. This function recomputes region indexes\n+    /// for expressions so they start with the next region index after the last counter index.\n+    fn ensure_expressions_translated(&mut self) {\n+        if !self.translated {\n+            self.translated = true;\n+            let start = self.counters.len() as u32;\n+            assert!(\n+                (start as u64 + self.expressions.len() as u64) < u32::MAX as u64,\n+                \"the number of counters and counter expressions in a single function exceeds {}\",\n+                u32::MAX\n+            );\n+            for region in self.expressions.iter_mut() {\n+                match region.kind {\n+                    CoverageKind::CounterExpression(lhs, op, rhs) => {\n+                        let lhs = to_region_index(start, lhs);\n+                        let rhs = to_region_index(start, rhs);\n+                        region.kind = CoverageKind::CounterExpression(lhs, op, rhs);\n+                    }\n+                    _ => bug!(\"expressions must only contain CounterExpression kinds\"),\n+                }\n+            }\n+        }\n     }\n }\n+\n+fn to_region_index(start: u32, index: u32) -> u32 {\n+    if index < start { index } else { start + (u32::MAX - index) }\n+}"}, {"sha": "1b9faa42484f1ad536a21b3ccdc35e9a5b9f70d4", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -10,6 +10,7 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,\n+        function_source_hash: u64,\n         index: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,"}, {"sha": "817fc02d166a35ba9dff5e61e3087e9628d59c3b", "filename": "src/librustc_codegen_ssa/traits/statics.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -5,6 +5,18 @@ use rustc_target::abi::Align;\n pub trait StaticMethods: BackendTypes {\n     fn static_addr_of(&self, cv: Self::Value, align: Align, kind: Option<&str>) -> Self::Value;\n     fn codegen_static(&self, def_id: DefId, is_mutable: bool);\n+\n+    /// Mark the given global value as \"used\", to prevent a backend from potentially removing a\n+    /// static variable that may otherwise appear unused.\n+    ///\n+    /// Static variables in Rust can be annotated with the `#[used]` attribute to direct the `rustc`\n+    /// compiler to mark the variable as a \"used global\".\n+    ///\n+    /// ```no_run\n+    /// #[used]\n+    /// static FOO: u32 = 0;\n+    /// ```\n+    fn add_used_global(&self, global: Self::Value);\n }\n \n pub trait StaticBuilderMethods: BackendTypes {"}, {"sha": "91db58054b61fde3e8a5d8b497d4a07b8a32b109", "filename": "src/librustc_hir/fake_lang_items.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_hir%2Ffake_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_hir%2Ffake_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Ffake_lang_items.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,37 @@\n+//! Validity checking for fake lang items\n+\n+use crate::def_id::DefId;\n+use crate::{lang_items, LangItem, LanguageItems};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::symbol::{sym, Symbol};\n+\n+use lazy_static::lazy_static;\n+\n+macro_rules! fake_lang_items {\n+    ($($item:ident, $name:ident, $method:ident;)*) => (\n+\n+lazy_static! {\n+    pub static ref FAKE_ITEMS_REFS: FxHashMap<Symbol, LangItem> = {\n+        let mut map = FxHashMap::default();\n+        $(map.insert(sym::$name, lang_items::$item);)*\n+        map\n+    };\n+}\n+\n+impl LanguageItems {\n+    pub fn is_fake_lang_item(&self, item_def_id: DefId) -> bool {\n+        let did = Some(item_def_id);\n+\n+        $(self.$method() == did)||*\n+    }\n+}\n+\n+) }\n+\n+fake_lang_items! {\n+//  Variant name,                      Symbol,                    Method name,\n+    CountCodeRegionFnLangItem,         count_code_region,         count_code_region_fn;\n+    CoverageCounterAddFnLangItem,      coverage_counter_add,      coverage_counter_add_fn;\n+    CoverageCounterSubtractFnLangItem, coverage_counter_subtract, coverage_counter_subtract_fn;\n+}"}, {"sha": "4b71407acfb8cf44c57f7b202dd6900b13174326", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -276,8 +276,6 @@ language_item_table! {\n \n     StartFnLangItem,               sym::start,              start_fn,                Target::Fn;\n \n-    CountCodeRegionFnLangItem,     sym::count_code_region,  count_code_region_fn,    Target::Fn;\n-\n     EhPersonalityLangItem,         sym::eh_personality,     eh_personality,          Target::Fn;\n     EhCatchTypeinfoLangItem,       sym::eh_catch_typeinfo,  eh_catch_typeinfo,       Target::Static;\n \n@@ -295,4 +293,9 @@ language_item_table! {\n     TerminationTraitLangItem,      sym::termination,        termination,             Target::Trait;\n \n     TryTraitLangItem,              kw::Try,                 try_trait,               Target::Trait;\n+\n+    // language items related to source code coverage instrumentation (-Zinstrument-coverage)\n+    CountCodeRegionFnLangItem,         sym::count_code_region,         count_code_region_fn,         Target::Fn;\n+    CoverageCounterAddFnLangItem,      sym::coverage_counter_add,      coverage_counter_add_fn,      Target::Fn;\n+    CoverageCounterSubtractFnLangItem, sym::coverage_counter_subtract, coverage_counter_subtract_fn, Target::Fn;\n }"}, {"sha": "52131cb3d3d4cab03a12ae46f2ef769aaa9b93f0", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -17,6 +17,7 @@ mod arena;\n pub mod def;\n pub mod definitions;\n pub use rustc_span::def_id;\n+pub mod fake_lang_items;\n mod hir;\n pub mod hir_id;\n pub mod intravisit;"}, {"sha": "3c549b88523684fa812623d87bfb0aa48fdd9614", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -401,7 +401,7 @@ fn test_codegen_options_tracking_hash() {\n     untracked!(incremental, Some(String::from(\"abc\")));\n     // `link_arg` is omitted because it just forwards to `link_args`.\n     untracked!(link_args, vec![String::from(\"abc\"), String::from(\"def\")]);\n-    untracked!(link_dead_code, true);\n+    untracked!(link_dead_code, Some(true));\n     untracked!(linker, Some(PathBuf::from(\"linker\")));\n     untracked!(linker_flavor, Some(LinkerFlavor::Gcc));\n     untracked!(no_stack_check, true);"}, {"sha": "78e27b10ec657e35f83d37d51256f567aa0d5986", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -104,8 +104,16 @@ fn main() {\n         optional_components.push(\"riscv\");\n     }\n \n-    let required_components =\n-        &[\"ipo\", \"bitreader\", \"bitwriter\", \"linker\", \"asmparser\", \"lto\", \"instrumentation\"];\n+    let required_components = &[\n+        \"ipo\",\n+        \"bitreader\",\n+        \"bitwriter\",\n+        \"linker\",\n+        \"asmparser\",\n+        \"lto\",\n+        \"coverage\",\n+        \"instrumentation\",\n+    ];\n \n     let components = output(Command::new(&llvm_config).arg(\"--components\"));\n     let mut components = components.split_whitespace().collect::<Vec<_>>();\n@@ -169,6 +177,7 @@ fn main() {\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n         .file(\"../rustllvm/RustWrapper.cpp\")\n         .file(\"../rustllvm/ArchiveWrapper.cpp\")\n+        .file(\"../rustllvm/CoverageMappingWrapper.cpp\")\n         .file(\"../rustllvm/Linker.cpp\")\n         .cpp(true)\n         .cpp_link_stdlib(None) // we handle this below"}, {"sha": "9d23397ade08e80e170bd9b41ebce4e72c5c7982", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -13,6 +13,12 @@ pub struct RustString {\n     pub bytes: RefCell<Vec<u8>>,\n }\n \n+impl RustString {\n+    pub fn len(&self) -> usize {\n+        self.bytes.borrow().len()\n+    }\n+}\n+\n /// Appending to a Rust string -- used by RawRustStringOstream.\n #[no_mangle]\n #[allow(improper_ctypes_definitions)]"}, {"sha": "1e06dadfa24532bbc5f3651679c4c57c3b9d21c6", "filename": "src/librustc_middle/mir/coverage/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -2,9 +2,10 @@\n \n /// Positional arguments to `libcore::count_code_region()`\n pub mod count_code_region_args {\n-    pub const COUNTER_INDEX: usize = 0;\n-    pub const START_BYTE_POS: usize = 1;\n-    pub const END_BYTE_POS: usize = 2;\n+    pub const FUNCTION_SOURCE_HASH: usize = 0;\n+    pub const COUNTER_INDEX: usize = 1;\n+    pub const START_BYTE_POS: usize = 2;\n+    pub const END_BYTE_POS: usize = 3;\n }\n \n /// Positional arguments to `libcore::coverage_counter_add()` and"}, {"sha": "1ad5008d28a987f264550781c599d21debf8bebb", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> MonoItem<'tcx> {\n             .debugging_opts\n             .inline_in_all_cgus\n             .unwrap_or_else(|| tcx.sess.opts.optimize != OptLevel::No)\n-            && !tcx.sess.opts.cg.link_dead_code;\n+            && tcx.sess.opts.cg.link_dead_code != Some(true);\n \n         match *self {\n             MonoItem::Fn(ref instance) => {"}, {"sha": "508a696d89654d126a447baf820cd9a496c7d6bc", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -400,13 +400,11 @@ pub struct DestructuredConst<'tcx> {\n /// `InstrumentCoverage` MIR pass and can be retrieved via the `coverageinfo` query.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct CoverageInfo {\n-    /// A hash value that can be used by the consumer of the coverage profile data to detect\n-    /// changes to the instrumented source of the associated MIR body (typically, for an\n-    /// individual function).\n-    pub hash: u64,\n-\n     /// The total number of coverage region counters added to the MIR `Body`.\n     pub num_counters: u32,\n+\n+    /// The total number of coverage region counter expressions added to the MIR `Body`.\n+    pub num_expressions: u32,\n }\n \n impl<'tcx> TyCtxt<'tcx> {"}, {"sha": "6162651db14a0b8d8780a5fadd6e32351eaa5f74", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -161,7 +161,7 @@ where\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n-    if !tcx.sess.opts.cg.link_dead_code {\n+    if tcx.sess.opts.cg.link_dead_code != Some(true) {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n         internalize_symbols(tcx, &mut post_inlining, inlining_map);\n     }\n@@ -906,7 +906,7 @@ fn collect_and_partition_mono_items(\n             }\n         }\n         None => {\n-            if tcx.sess.opts.cg.link_dead_code {\n+            if tcx.sess.opts.cg.link_dead_code == Some(true) {\n                 MonoItemCollectionMode::Eager\n             } else {\n                 MonoItemCollectionMode::Lazy"}, {"sha": "9933a975e4dac194f98fe19a806e203280a6bdc9", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 204, "deletions": 56, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -35,46 +35,64 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> Coverage\n     // represents a single function. Validate and/or correct if inlining (which should be disabled\n     // if -Zinstrument-coverage is enabled) and/or monomorphization invalidates these assumptions.\n     let count_code_region_fn = tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n+    let coverage_counter_add_fn =\n+        tcx.require_lang_item(lang_items::CoverageCounterAddFnLangItem, None);\n+    let coverage_counter_subtract_fn =\n+        tcx.require_lang_item(lang_items::CoverageCounterSubtractFnLangItem, None);\n \n     // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n     // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n     // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n     // not work; but computing the num_counters by adding `1` to the highest index (for a given\n     // instrumented function) is valid.\n+    //\n+    // `num_expressions` is the number of counter expressions added to the MIR body. Both\n+    // `num_counters` and `num_expressions` are used to initialize new vectors, during backend\n+    // code generate, to lookup counters and expressions by their simple u32 indexes.\n     let mut num_counters: u32 = 0;\n-    for terminator in traversal::preorder(mir_body)\n-        .map(|(_, data)| (data, count_code_region_fn))\n-        .filter_map(terminators_that_call_given_fn)\n+    let mut num_expressions: u32 = 0;\n+    for terminator in\n+        traversal::preorder(mir_body).map(|(_, data)| data).filter_map(call_terminators)\n     {\n-        if let TerminatorKind::Call { args, .. } = &terminator.kind {\n-            let index_arg = args.get(count_code_region_args::COUNTER_INDEX).expect(\"arg found\");\n-            let index =\n-                mir::Operand::scalar_from_const(index_arg).to_u32().expect(\"index arg is u32\");\n-            num_counters = std::cmp::max(num_counters, index + 1);\n-        }\n-    }\n-    let hash = if num_counters > 0 { hash_mir_source(tcx, mir_def_id) } else { 0 };\n-    CoverageInfo { num_counters, hash }\n-}\n-\n-fn terminators_that_call_given_fn(\n-    (data, fn_def_id): (&'tcx BasicBlockData<'tcx>, DefId),\n-) -> Option<&'tcx Terminator<'tcx>> {\n-    if let Some(terminator) = &data.terminator {\n-        if let TerminatorKind::Call { func: Operand::Constant(func), .. } = &terminator.kind {\n-            if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n-                if called_fn_def_id == fn_def_id {\n-                    return Some(&terminator);\n+        if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } = &terminator.kind {\n+            match func.literal.ty.kind {\n+                FnDef(id, _) if id == count_code_region_fn => {\n+                    let index_arg =\n+                        args.get(count_code_region_args::COUNTER_INDEX).expect(\"arg found\");\n+                    let counter_index = mir::Operand::scalar_from_const(index_arg)\n+                        .to_u32()\n+                        .expect(\"index arg is u32\");\n+                    num_counters = std::cmp::max(num_counters, counter_index + 1);\n+                }\n+                FnDef(id, _)\n+                    if id == coverage_counter_add_fn || id == coverage_counter_subtract_fn =>\n+                {\n+                    let index_arg = args\n+                        .get(coverage_counter_expression_args::COUNTER_EXPRESSION_INDEX)\n+                        .expect(\"arg found\");\n+                    let translated_index = mir::Operand::scalar_from_const(index_arg)\n+                        .to_u32()\n+                        .expect(\"index arg is u32\");\n+                    // Counter expressions start with \"translated indexes\", descending from\n+                    // `u32::MAX`, so the range of expression indexes is disjoint from the range of\n+                    // counter indexes. This way, both counters and expressions can be operands in\n+                    // other expressions.\n+                    let expression_index = u32::MAX - translated_index;\n+                    num_expressions = std::cmp::max(num_expressions, expression_index + 1);\n                 }\n+                _ => {}\n             }\n         }\n     }\n-    None\n+    CoverageInfo { num_counters, num_expressions }\n }\n \n-struct Instrumentor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    num_counters: u32,\n+fn call_terminators(data: &'tcx BasicBlockData<'tcx>) -> Option<&'tcx Terminator<'tcx>> {\n+    let terminator = data.terminator();\n+    match terminator.kind {\n+        TerminatorKind::Call { .. } => Some(terminator),\n+        _ => None,\n+    }\n }\n \n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n@@ -83,42 +101,106 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n             // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n             // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n             if src.promoted.is_none() {\n-                debug!(\n-                    \"instrumenting {:?}, span: {}\",\n-                    src.def_id(),\n-                    tcx.sess.source_map().span_to_string(mir_body.span)\n-                );\n-                Instrumentor::new(tcx).inject_counters(mir_body);\n+                Instrumentor::new(tcx, src, mir_body).inject_counters();\n             }\n         }\n     }\n }\n \n-impl<'tcx> Instrumentor<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        Self { tcx, num_counters: 0 }\n+/// Distinguishes the expression operators.\n+enum Op {\n+    Add,\n+    Subtract,\n+}\n+\n+struct Instrumentor<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    mir_def_id: DefId,\n+    mir_body: &'a mut mir::Body<'tcx>,\n+    hir_body: &'tcx rustc_hir::Body<'tcx>,\n+    function_source_hash: Option<u64>,\n+    num_counters: u32,\n+    num_expressions: u32,\n+}\n+\n+impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, mir_body: &'a mut mir::Body<'tcx>) -> Self {\n+        let mir_def_id = src.def_id();\n+        let hir_body = hir_body(tcx, mir_def_id);\n+        Self {\n+            tcx,\n+            mir_def_id,\n+            mir_body,\n+            hir_body,\n+            function_source_hash: None,\n+            num_counters: 0,\n+            num_expressions: 0,\n+        }\n     }\n \n+    /// Counter IDs start from zero and go up.\n     fn next_counter(&mut self) -> u32 {\n+        assert!(self.num_counters < u32::MAX - self.num_expressions);\n         let next = self.num_counters;\n         self.num_counters += 1;\n         next\n     }\n \n-    fn inject_counters(&mut self, mir_body: &mut mir::Body<'tcx>) {\n+    /// Expression IDs start from u32::MAX and go down because a CounterExpression can reference\n+    /// (add or subtract counts) of both Counter regions and CounterExpression regions. The indexes\n+    /// of each type of region must be contiguous, but also must be unique across both sets.\n+    /// The expression IDs are eventually translated into region indexes (starting after the last\n+    /// counter index, for the given function), during backend code generation, by the helper method\n+    /// `rustc_codegen_ssa::coverageinfo::map::FunctionCoverage::translate_expressions()`.\n+    fn next_expression(&mut self) -> u32 {\n+        assert!(self.num_counters < u32::MAX - self.num_expressions);\n+        let next = u32::MAX - self.num_expressions;\n+        self.num_expressions += 1;\n+        next\n+    }\n+\n+    fn function_source_hash(&mut self) -> u64 {\n+        match self.function_source_hash {\n+            Some(hash) => hash,\n+            None => {\n+                let hash = hash_mir_source(self.tcx, self.hir_body);\n+                self.function_source_hash.replace(hash);\n+                hash\n+            }\n+        }\n+    }\n+\n+    fn inject_counters(&mut self) {\n+        let body_span = self.hir_body.value.span;\n+        debug!(\n+            \"instrumenting {:?}, span: {}\",\n+            self.mir_def_id,\n+            self.tcx.sess.source_map().span_to_string(body_span)\n+        );\n+\n         // FIXME(richkadel): As a first step, counters are only injected at the top of each\n         // function. The complete solution will inject counters at each conditional code branch.\n-        let code_region = mir_body.span;\n         let next_block = START_BLOCK;\n-        self.inject_counter(mir_body, code_region, next_block);\n+        self.inject_counter(body_span, next_block);\n+\n+        // FIXME(richkadel): The next step to implement source based coverage analysis will be\n+        // instrumenting branches within functions, and some regions will be counted by \"counter\n+        // expression\". The function to inject counter expression is implemented. Replace this\n+        // \"fake use\" with real use.\n+        let fake_use = false;\n+        if fake_use {\n+            let add = false;\n+            if add {\n+                self.inject_counter_expression(body_span, next_block, 1, Op::Add, 2);\n+            } else {\n+                self.inject_counter_expression(body_span, next_block, 1, Op::Subtract, 2);\n+            }\n+        }\n     }\n \n-    fn inject_counter(\n-        &mut self,\n-        mir_body: &mut mir::Body<'tcx>,\n-        code_region: Span,\n-        next_block: BasicBlock,\n-    ) {\n+    fn inject_counter(&mut self, code_region: Span, next_block: BasicBlock) -> u32 {\n+        let counter_id = self.next_counter();\n+        let function_source_hash = self.function_source_hash();\n         let injection_point = code_region.shrink_to_lo();\n \n         let count_code_region_fn = function_handle(\n@@ -127,50 +209,113 @@ impl<'tcx> Instrumentor<'tcx> {\n             injection_point,\n         );\n \n-        let index = self.next_counter();\n-\n         let mut args = Vec::new();\n \n         use count_code_region_args::*;\n+        debug_assert_eq!(FUNCTION_SOURCE_HASH, args.len());\n+        args.push(self.const_u64(function_source_hash, injection_point));\n+\n         debug_assert_eq!(COUNTER_INDEX, args.len());\n-        args.push(self.const_u32(index, injection_point));\n+        args.push(self.const_u32(counter_id, injection_point));\n \n         debug_assert_eq!(START_BYTE_POS, args.len());\n         args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n \n         debug_assert_eq!(END_BYTE_POS, args.len());\n         args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n \n-        let mut patch = MirPatch::new(mir_body);\n+        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n \n-        let temp = patch.new_temp(self.tcx.mk_unit(), code_region);\n-        let new_block = patch.new_block(placeholder_block(code_region));\n+        counter_id\n+    }\n+\n+    fn inject_counter_expression(\n+        &mut self,\n+        code_region: Span,\n+        next_block: BasicBlock,\n+        lhs: u32,\n+        op: Op,\n+        rhs: u32,\n+    ) -> u32 {\n+        let expression_id = self.next_expression();\n+        let injection_point = code_region.shrink_to_lo();\n+\n+        let count_code_region_fn = function_handle(\n+            self.tcx,\n+            self.tcx.require_lang_item(\n+                match op {\n+                    Op::Add => lang_items::CoverageCounterAddFnLangItem,\n+                    Op::Subtract => lang_items::CoverageCounterSubtractFnLangItem,\n+                },\n+                None,\n+            ),\n+            injection_point,\n+        );\n+\n+        let mut args = Vec::new();\n+\n+        use coverage_counter_expression_args::*;\n+        debug_assert_eq!(COUNTER_EXPRESSION_INDEX, args.len());\n+        args.push(self.const_u32(expression_id, injection_point));\n+\n+        debug_assert_eq!(LEFT_INDEX, args.len());\n+        args.push(self.const_u32(lhs, injection_point));\n+\n+        debug_assert_eq!(RIGHT_INDEX, args.len());\n+        args.push(self.const_u32(rhs, injection_point));\n+\n+        debug_assert_eq!(START_BYTE_POS, args.len());\n+        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+\n+        debug_assert_eq!(END_BYTE_POS, args.len());\n+        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n+\n+        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n+\n+        expression_id\n+    }\n+\n+    fn inject_call(\n+        &mut self,\n+        func: Operand<'tcx>,\n+        args: Vec<Operand<'tcx>>,\n+        fn_span: Span,\n+        next_block: BasicBlock,\n+    ) {\n+        let mut patch = MirPatch::new(self.mir_body);\n+\n+        let temp = patch.new_temp(self.tcx.mk_unit(), fn_span);\n+        let new_block = patch.new_block(placeholder_block(fn_span));\n         patch.patch_terminator(\n             new_block,\n             TerminatorKind::Call {\n-                func: count_code_region_fn,\n+                func,\n                 args,\n                 // new_block will swapped with the next_block, after applying patch\n                 destination: Some((Place::from(temp), new_block)),\n                 cleanup: None,\n                 from_hir_call: false,\n-                fn_span: injection_point,\n+                fn_span,\n             },\n         );\n \n         patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n         patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n \n-        patch.apply(mir_body);\n+        patch.apply(self.mir_body);\n \n         // To insert the `new_block` in front of the first block in the counted branch (the\n         // `next_block`), just swap the indexes, leaving the rest of the graph unchanged.\n-        mir_body.basic_blocks_mut().swap(next_block, new_block);\n+        self.mir_body.basic_blocks_mut().swap(next_block, new_block);\n     }\n \n     fn const_u32(&self, value: u32, span: Span) -> Operand<'tcx> {\n         Operand::const_from_scalar(self.tcx, self.tcx.types.u32, Scalar::from_u32(value), span)\n     }\n+\n+    fn const_u64(&self, value: u64, span: Span) -> Operand<'tcx> {\n+        Operand::const_from_scalar(self.tcx, self.tcx.types.u64, Scalar::from_u64(value), span)\n+    }\n }\n \n fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {\n@@ -192,10 +337,13 @@ fn placeholder_block(span: Span) -> BasicBlockData<'tcx> {\n     }\n }\n \n-fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> u64 {\n+fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx rustc_hir::Body<'tcx> {\n     let hir_node = tcx.hir().get_if_local(def_id).expect(\"DefId is local\");\n     let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n-    let hir_body = tcx.hir().body(fn_body_id);\n+    tcx.hir().body(fn_body_id)\n+}\n+\n+fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n     let mut hcx = tcx.create_no_span_stable_hashing_context();\n     hash(&mut hcx, &hir_body.value).to_smaller_hash()\n }"}, {"sha": "3b11fb379625f717b78521c34de778f7d69d04c0", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -3,14 +3,13 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::fake_lang_items::FAKE_ITEMS_REFS;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::lang_items;\n-use rustc_hir::lang_items::ITEM_REFS;\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::required;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n-use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n@@ -77,15 +76,14 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n             if self.items.require(item).is_err() {\n                 self.items.missing.push(item);\n             }\n-        } else if name == sym::count_code_region {\n-            // `core::intrinsics::code_count_region()` is (currently) the only `extern` lang item\n-            // that is never actually linked. It is not a `weak_lang_item` that can be registered\n-            // when used, and should be registered here instead.\n-            if let Some((item_index, _)) = ITEM_REFS.get(&name).cloned() {\n-                if self.items.items[item_index].is_none() {\n-                    let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n-                    self.items.items[item_index] = Some(item_def_id);\n-                }\n+        } else if let Some(&item) = FAKE_ITEMS_REFS.get(&name) {\n+            // Ensure \"fake lang items\" are registered. These are `extern` lang items that are\n+            // injected into the MIR automatically (such as source code coverage counters), but are\n+            // never actually linked; therefore, unlike \"weak lang items\", they cannot by registered\n+            // when used, because they never appear to be used.\n+            if self.items.items[item as usize].is_none() {\n+                let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n+                self.items.items[item as usize] = Some(item_def_id);\n             }\n         } else {\n             struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)"}, {"sha": "839ffa5785adacb372b7068475b3998ebe25e49f", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1707,6 +1707,31 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         );\n     }\n \n+    if debugging_opts.instrument_coverage {\n+        if cg.profile_generate.enabled() || cg.profile_use.is_some() {\n+            early_error(\n+                error_format,\n+                \"option `-Z instrument-coverage` is not compatible with either `-C profile-use` \\\n+                or `-C profile-generate`\",\n+            );\n+        }\n+\n+        // `-Z instrument-coverage` implies:\n+        //   * `-Z symbol-mangling-version=v0` - to ensure consistent and reversable name mangling.\n+        //     Note, LLVM coverage tools can analyze coverage over multiple runs, including some\n+        //     changes to source code; so mangled names must be consistent across compilations.\n+        //   * `-C link-dead-code` - so unexecuted code is still counted as zero, rather than be\n+        //     optimized out. Note that instrumenting dead code can be explicitly disabled with:\n+        //         `-Z instrument-coverage -C link-dead-code=no`.\n+        debugging_opts.symbol_mangling_version = SymbolManglingVersion::V0;\n+        if cg.link_dead_code == None {\n+            // FIXME(richkadel): Investigate if the `instrument-coverage` implementation can\n+            // inject [\"zero counters\"](https://llvm.org/docs/CoverageMappingFormat.html#counter)\n+            // in the coverage map when \"dead code\" is removed, rather than forcing `link-dead-code`.\n+            cg.link_dead_code = Some(true);\n+        }\n+    }\n+\n     if !cg.embed_bitcode {\n         match cg.lto {\n             LtoCli::No | LtoCli::Unspecified => {}"}, {"sha": "8c1f6a77497407fe269b5ada524926ce56f37d0e", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -715,7 +715,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"a single extra argument to append to the linker invocation (can be used several times)\"),\n     link_args: Vec<String> = (Vec::new(), parse_list, [UNTRACKED],\n         \"extra arguments to append to the linker invocation (space separated)\"),\n-    link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n+    link_dead_code: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n         \"keep dead code at link time (useful for code coverage) (default: no)\"),\n     linker: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n         \"system linker to link outputs with\"),\n@@ -880,10 +880,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n     instrument_coverage: bool = (false, parse_bool, [TRACKED],\n-        \"instrument the generated code with LLVM code region counters to (in the \\\n-        future) generate coverage reports; disables/overrides some optimization \\\n-        options (note, the compiler build config must include `profiler = true`) \\\n-        (default: no)\"),\n+        \"instrument the generated code to support LLVM source-based code coverage \\\n+        reports (note, the compiler build config must include `profiler = true`, \\\n+        and is mutually exclusive with `-C profile-generate`/`-C profile-use`); \\\n+        implies `-C link-dead-code` (unless explicitly disabled)` and\n+        `-Z symbol-mangling-version=v0`; and disables/overrides some optimization \\\n+        options (default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "4ad95e95e9a86a68fe5e30eebf489878e3067909", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1357,6 +1357,20 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         );\n     }\n \n+    // FIXME(richkadel): See `src/test/run-make-fulldeps/instrument-coverage/Makefile`. After\n+    // compiling with `-Zinstrument-coverage`, the resulting binary generates a segfault during\n+    // the program's exit process (likely while attempting to generate the coverage stats in\n+    // the \"*.profraw\" file). An investigation to resolve the problem on Windows is ongoing,\n+    // but until this is resolved, the option is disabled on Windows, and the test is skipped\n+    // when targeting `MSVC`.\n+    if sess.opts.debugging_opts.instrument_coverage && sess.target.target.options.is_like_msvc {\n+        sess.warn(\n+            \"Rust source-based code coverage instrumentation (with `-Z instrument-coverage`) \\\n+            is not yet supported on Windows when targeting MSVC. The resulting binaries will \\\n+            still be instrumented for experimentation purposes, but may not execute correctly.\",\n+        );\n+    }\n+\n     const ASAN_SUPPORTED_TARGETS: &[&str] = &[\n         \"aarch64-fuchsia\",\n         \"aarch64-unknown-linux-gnu\","}, {"sha": "a09edf575c8072b17370bd3461048b8eb58b1e99", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -386,7 +386,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             }\n \n             sym::count_code_region => {\n-                (0, vec![tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n+                (0, vec![tcx.types.u64, tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n             }\n \n             sym::coverage_counter_add | sym::coverage_counter_subtract => ("}, {"sha": "c6c4cdb5562f87a2b347d9f3721e6410227a1ac9", "filename": "src/rustllvm/CoverageMappingWrapper.cpp", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Frustllvm%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Frustllvm%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FCoverageMappingWrapper.cpp?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,115 @@\n+#include \"rustllvm.h\"\n+#include \"llvm/ProfileData/Coverage/CoverageMapping.h\"\n+#include \"llvm/ProfileData/Coverage/CoverageMappingWriter.h\"\n+#include \"llvm/ProfileData/InstrProf.h\"\n+#include \"llvm/ADT/ArrayRef.h\"\n+\n+#include <iostream>\n+\n+using namespace llvm;\n+\n+extern \"C\" SmallVectorTemplateBase<coverage::CounterExpression>\n+    *LLVMRustCoverageSmallVectorCounterExpressionCreate() {\n+  return new SmallVector<coverage::CounterExpression, 32>();\n+}\n+\n+extern \"C\" void LLVMRustCoverageSmallVectorCounterExpressionDispose(\n+    SmallVectorTemplateBase<coverage::CounterExpression> *Vector) {\n+  delete Vector;\n+}\n+\n+extern \"C\" void LLVMRustCoverageSmallVectorCounterExpressionAdd(\n+    SmallVectorTemplateBase<coverage::CounterExpression> *Expressions,\n+    coverage::CounterExpression::ExprKind Kind,\n+    unsigned LeftIndex,\n+    unsigned RightIndex) {\n+  auto LHS = coverage::Counter::getCounter(LeftIndex);\n+  auto RHS = coverage::Counter::getCounter(RightIndex);\n+  Expressions->push_back(coverage::CounterExpression { Kind, LHS, RHS });\n+}\n+\n+extern \"C\" SmallVectorTemplateBase<coverage::CounterMappingRegion>\n+    *LLVMRustCoverageSmallVectorCounterMappingRegionCreate() {\n+  return new SmallVector<coverage::CounterMappingRegion, 32>();\n+}\n+\n+extern \"C\" void LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n+    SmallVectorTemplateBase<coverage::CounterMappingRegion> *Vector) {\n+  delete Vector;\n+}\n+\n+extern \"C\" void LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n+    SmallVectorTemplateBase<coverage::CounterMappingRegion> *MappingRegions,\n+    unsigned Index,\n+    unsigned FileID,\n+    unsigned LineStart,\n+    unsigned ColumnStart,\n+    unsigned LineEnd,\n+    unsigned ColumnEnd) {\n+  auto Counter = coverage::Counter::getCounter(Index);\n+  MappingRegions->push_back(coverage::CounterMappingRegion::makeRegion(\n+           Counter, FileID, LineStart,\n+           ColumnStart, LineEnd, ColumnEnd));\n+\n+  // FIXME(richkadel): As applicable, implement additional CounterMappingRegion types using the\n+  // static method alternatives to `coverage::CounterMappingRegion::makeRegion`:\n+  //\n+  //   makeExpansion(unsigned FileID, unsigned ExpandedFileID, unsigned LineStart,\n+  //                 unsigned ColumnStart, unsigned LineEnd, unsigned ColumnEnd) {\n+  //   makeSkipped(unsigned FileID, unsigned LineStart, unsigned ColumnStart,\n+  //               unsigned LineEnd, unsigned ColumnEnd) {\n+  //   makeGapRegion(Counter Count, unsigned FileID, unsigned LineStart,\n+  //                 unsigned ColumnStart, unsigned LineEnd, unsigned ColumnEnd) {\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n+    const char* const Filenames[],\n+    size_t FilenamesLen,\n+    RustStringRef BufferOut) {\n+  SmallVector<StringRef,32> FilenameRefs;\n+  for (size_t i = 0; i < FilenamesLen; i++) {\n+    FilenameRefs.push_back(StringRef(Filenames[i]));\n+  }\n+  auto FilenamesWriter = coverage::CoverageFilenamesSectionWriter(\n+    makeArrayRef(FilenameRefs));\n+  RawRustStringOstream OS(BufferOut);\n+  FilenamesWriter.write(OS);\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n+    const unsigned *VirtualFileMappingIDs,\n+    unsigned NumVirtualFileMappingIDs,\n+    const SmallVectorImpl<coverage::CounterExpression> *Expressions,\n+    SmallVectorImpl<coverage::CounterMappingRegion> *MappingRegions,\n+    RustStringRef BufferOut) {\n+  auto CoverageMappingWriter = coverage::CoverageMappingWriter(\n+    makeArrayRef(VirtualFileMappingIDs, NumVirtualFileMappingIDs),\n+    makeArrayRef(*Expressions),\n+    MutableArrayRef<coverage::CounterMappingRegion> { *MappingRegions });\n+  RawRustStringOstream OS(BufferOut);\n+  CoverageMappingWriter.write(OS);\n+}\n+\n+extern \"C\" uint64_t LLVMRustCoverageComputeHash(const char *Name) {\n+  StringRef NameRef(Name);\n+  return IndexedInstrProf::ComputeHash(NameRef);\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteSectionNameToString(LLVMModuleRef M,\n+                                                         RustStringRef Str) {\n+  Triple TargetTriple(unwrap(M)->getTargetTriple());\n+  auto name = getInstrProfSectionName(IPSK_covmap,\n+                                      TargetTriple.getObjectFormat());\n+  RawRustStringOstream OS(Str);\n+  OS << name;\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteMappingVarNameToString(RustStringRef Str) {\n+  auto name = getCoverageMappingVarName();\n+  RawRustStringOstream OS(Str);\n+  OS << name;\n+}\n+\n+extern \"C\" uint32_t LLVMRustCoverageMappingVersion() {\n+  return coverage::CovMapVersion::CurrentVersion;\n+}"}, {"sha": "667bf4a2ded37e7931df99735435f05eef8cbda0", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -1395,7 +1395,7 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n       FTy, Callee, makeArrayRef(unwrap(Args), NumArgs), Bundles));\n }\n \n-extern \"C\" LLVMValueRef LLVMRustGetInstrprofIncrementIntrinsic(LLVMModuleRef M) {\n+extern \"C\" LLVMValueRef LLVMRustGetInstrProfIncrementIntrinsic(LLVMModuleRef M) {\n   return wrap(llvm::Intrinsic::getDeclaration(unwrap(M),\n               (llvm::Intrinsic::ID)llvm::Intrinsic::instrprof_increment));\n }"}, {"sha": "57b8664d3b6058d1050790354cb0a5fc89cc16ca", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -3,6 +3,7 @@\n #include \"llvm-c/Object.h\"\n #include \"llvm/ADT/ArrayRef.h\"\n #include \"llvm/ADT/DenseSet.h\"\n+#include \"llvm/ADT/SmallVector.h\"\n #include \"llvm/ADT/Triple.h\"\n #include \"llvm/Analysis/Lint.h\"\n #include \"llvm/Analysis/Passes.h\""}, {"sha": "e7fef4622b1c6cb09e791cd3586dea2049d5978c", "filename": "src/test/mir-opt/instrument_coverage/rustc.bar.InstrumentCoverage.diff", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -3,34 +3,40 @@\n   \n   fn bar() -> bool {\n       let mut _0: bool;                    // return place in scope 0 at $DIR/instrument_coverage.rs:18:13: 18:17\n-+     let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++     let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n   \n       bb0: {\n-+         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n-+         _1 = const std::intrinsics::count_code_region(const 0_u32, const 484_u32, const 513_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n++         _1 = const std::intrinsics::count_code_region(const 10208505205182607101_u64, const 0_u32, const 501_u32, const 513_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u64\n++                                          // + val: Value(Scalar(0x8dabe565aaa2aefd))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + literal: Const { ty: u64, val: Value(Scalar(0x8dabe565aaa2aefd)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x000001e4))\n++                                          // + val: Value(Scalar(0x000001f5))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001e4)) }\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001f5)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000201))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000201)) }\n +     }\n + "}, {"sha": "51378c216da641b9d2958a6def88f14c62a971ed", "filename": "src/test/mir-opt/instrument_coverage/rustc.main.InstrumentCoverage.diff", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -6,35 +6,41 @@\n       let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n       let mut _2: bool;                    // in scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n       let mut _3: !;                       // in scope 0 at $DIR/instrument_coverage.rs:11:18: 13:10\n-+     let mut _4: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++     let mut _4: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n   \n       bb0: {\n -         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n-+         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n-+         _4 = const std::intrinsics::count_code_region(const 0_u32, const 387_u32, const 465_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n++         _4 = const std::intrinsics::count_code_region(const 16004455475339839479_u64, const 0_u32, const 397_u32, const 465_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u64\n++                                          // + val: Value(Scalar(0xde1b3f75a72fc7f7))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + literal: Const { ty: u64, val: Value(Scalar(0xde1b3f75a72fc7f7)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x00000183))\n++                                          // + val: Value(Scalar(0x0000018d))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000183)) }\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x0000018d)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x000001d1))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001d1)) }\n       }\n   "}, {"sha": "df47305b547a82e7070dd9f126b65b68e1ea1ef8", "filename": "src/test/run-make-fulldeps/instrument-coverage/Makefile", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2FMakefile?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,57 @@\n+# needs-profiler-support\n+# ignore-msvc\n+\n+# FIXME(richkadel): Debug the following problem, and reenable on Windows (by\n+# removing the `# ignore-msvc` directive above). The current implementation\n+# generates a segfault when running the instrumented `main` executable,\n+# after the `main` program code executes, but before the process terminates.\n+# This most likely points to a problem generating the LLVM \"main.profraw\"\n+# file.\n+\n+-include ../tools.mk\n+\n+# This test makes sure that LLVM coverage maps are genereated in LLVM IR.\n+\n+COMMON_FLAGS=-Zinstrument-coverage\n+\n+all:\n+\t# Compile the test program with instrumentation, and also generate LLVM IR\n+\t$(RUSTC) $(COMMON_FLAGS) main.rs\n+\n+\t# Run it in order to generate some profiling data,\n+\t# with `LLVM_PROFILE_FILE=<profdata_file>` environment variable set to\n+\t# output the coverage stats for this run.\n+\tLLVM_PROFILE_FILE=\"$(TMPDIR)\"/main.profraw \\\n+\t  $(call RUN,main)\n+\n+\t# Postprocess the profiling data so it can be used by the llvm-cov tool\n+\t\"$(LLVM_BIN_DIR)\"/llvm-profdata merge --sparse \\\n+\t  \"$(TMPDIR)\"/main.profraw \\\n+\t\t-o \"$(TMPDIR)\"/main.profdata\n+\n+\t# Generate a coverage report using `llvm-cov show`. The output ordering\n+\t# can be non-deterministic, so ignore the return status. If the test fails\n+\t# when comparing the JSON `export`, the `show` output may be useful when\n+\t# debugging.\n+\t\"$(LLVM_BIN_DIR)\"/llvm-cov show \\\n+\t  --Xdemangler=\"$(RUST_DEMANGLER)\" \\\n+\t  --show-line-counts-or-regions \\\n+\t  --instr-profile=\"$(TMPDIR)\"/main.profdata \\\n+\t\t$(call BIN,\"$(TMPDIR)\"/main) \\\n+\t\t> \"$(TMPDIR)\"/actual_show_coverage.txt\n+\n+\t# Compare the show coverage output\n+\t$(DIFF) typical_show_coverage.txt \"$(TMPDIR)\"/actual_show_coverage.txt || \\\n+\t  >&2 echo 'diff failed for `llvm-cov show` (might not be an error)'\n+\n+\t# Generate a coverage report in JSON, using `llvm-cov export`, and fail if\n+\t# there are differences from the expected output.\n+\t\"$(LLVM_BIN_DIR)\"/llvm-cov export \\\n+\t  --summary-only \\\n+\t  --instr-profile=\"$(TMPDIR)\"/main.profdata \\\n+\t\t$(call BIN,\"$(TMPDIR)\"/main) \\\n+\t\t| \"$(PYTHON)\" prettify_json.py \\\n+\t\t> \"$(TMPDIR)\"/actual_export_coverage.json\n+\n+\t# Check that the exported JSON coverage data matches what we expect\n+\t$(DIFF) expected_export_coverage.json \"$(TMPDIR)\"/actual_export_coverage.json"}, {"sha": "9d739a89114e2c37f359977e4ca0fb6e9e09df92", "filename": "src/test/run-make-fulldeps/instrument-coverage/expected_export_coverage.json", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fexpected_export_coverage.json", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fexpected_export_coverage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fexpected_export_coverage.json?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,59 @@\n+{\n+  \"data\": [\n+    {\n+      \"files\": [\n+        {\n+          \"filename\": \"main.rs\",\n+          \"summary\": {\n+            \"functions\": {\n+              \"count\": 7,\n+              \"covered\": 5,\n+              \"percent\": 71.42857142857143\n+            },\n+            \"instantiations\": {\n+              \"count\": 8,\n+              \"covered\": 6,\n+              \"percent\": 75\n+            },\n+            \"lines\": {\n+              \"count\": 30,\n+              \"covered\": 25,\n+              \"percent\": 83.33333333333334\n+            },\n+            \"regions\": {\n+              \"count\": 7,\n+              \"covered\": 5,\n+              \"notcovered\": 2,\n+              \"percent\": 71.42857142857143\n+            }\n+          }\n+        }\n+      ],\n+      \"totals\": {\n+        \"functions\": {\n+          \"count\": 7,\n+          \"covered\": 5,\n+          \"percent\": 71.42857142857143\n+        },\n+        \"instantiations\": {\n+          \"count\": 8,\n+          \"covered\": 6,\n+          \"percent\": 75\n+        },\n+        \"lines\": {\n+          \"count\": 30,\n+          \"covered\": 25,\n+          \"percent\": 83.33333333333334\n+        },\n+        \"regions\": {\n+          \"count\": 7,\n+          \"covered\": 5,\n+          \"notcovered\": 2,\n+          \"percent\": 71.42857142857143\n+        }\n+      }\n+    }\n+  ],\n+  \"type\": \"llvm.coverage.json.export\",\n+  \"version\": \"2.0.0\"\n+}"}, {"sha": "358c25677ae1d1561f528d395e563852e898f17f", "filename": "src/test/run-make-fulldeps/instrument-coverage/main.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fmain.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,38 @@\n+pub fn will_be_called() -> &'static str {\n+    let val = \"called\";\n+    println!(\"{}\", val);\n+    val\n+}\n+\n+pub fn will_not_be_called() -> bool {\n+    println!(\"should not have been called\");\n+    false\n+}\n+\n+pub fn print<T>(left: &str, value: T, right: &str)\n+where\n+    T: std::fmt::Display,\n+{\n+    println!(\"{}{}{}\", left, value, right);\n+}\n+\n+pub fn wrap_with<F, T>(inner: T, should_wrap: bool, wrapper: F)\n+where\n+    F: FnOnce(&T)\n+{\n+    if should_wrap {\n+        wrapper(&inner)\n+    }\n+}\n+\n+fn main() {\n+    let less = 1;\n+    let more = 100;\n+\n+    if less < more {\n+        wrap_with(will_be_called(), less < more, |inner| print(\" ***\", inner, \"*** \"));\n+        wrap_with(will_be_called(), more < less, |inner| print(\" ***\", inner, \"*** \"));\n+    } else {\n+        wrap_with(will_not_be_called(), true, |inner| print(\"wrapped result is: \", inner, \"\"));\n+    }\n+}"}, {"sha": "ed9279841f70e5929208cd14a21616cc6969876a", "filename": "src/test/run-make-fulldeps/instrument-coverage/prettify_json.py", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fprettify_json.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fprettify_json.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fprettify_json.py?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,9 @@\n+#!/usr/bin/env python\n+\n+import sys\n+import json\n+\n+# Try to decode line in order to ensure it is a valid JSON document\n+for line in sys.stdin:\n+    parsed = json.loads(line)\n+    print (json.dumps(parsed, indent=2, separators=(',', ': '), sort_keys=True))"}, {"sha": "9c593d0809d484ce3dfc1cf934148496b1ce8b07", "filename": "src/test/run-make-fulldeps/instrument-coverage/typical_show_coverage.txt", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftypical_show_coverage.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftypical_show_coverage.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftypical_show_coverage.txt?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,55 @@\n+    1|      2|pub fn will_be_called() -> &'static str {\n+    2|      2|    let val = \"called\";\n+    3|      2|    println!(\"{}\", val);\n+    4|      2|    val\n+    5|      2|}\n+    6|       |\n+    7|      0|pub fn will_not_be_called() -> bool {\n+    8|      0|    println!(\"should not have been called\");\n+    9|      0|    false\n+   10|      0|}\n+   11|       |\n+   12|       |pub fn print<T>(left: &str, value: T, right: &str)\n+   13|       |where\n+   14|       |    T: std::fmt::Display,\n+   15|      1|{\n+   16|      1|    println!(\"{}{}{}\", left, value, right);\n+   17|      1|}\n+   18|       |\n+   19|       |pub fn wrap_with<F, T>(inner: T, should_wrap: bool, wrapper: F)\n+   20|       |where\n+   21|       |    F: FnOnce(&T)\n+   22|      2|{\n+   23|      2|    if should_wrap {\n+   24|      2|        wrapper(&inner)\n+   25|      2|    }\n+   26|      2|}\n+  ------------------\n+  | main[317d481089b8c8fe]::wrap_with::<main[317d481089b8c8fe]::main::{closure#0}, &str>:\n+  |   22|      1|{\n+  |   23|      1|    if should_wrap {\n+  |   24|      1|        wrapper(&inner)\n+  |   25|      1|    }\n+  |   26|      1|}\n+  ------------------\n+  | main[317d481089b8c8fe]::wrap_with::<main[317d481089b8c8fe]::main::{closure#1}, &str>:\n+  |   22|      1|{\n+  |   23|      1|    if should_wrap {\n+  |   24|      1|        wrapper(&inner)\n+  |   25|      1|    }\n+  |   26|      1|}\n+  ------------------\n+   27|       |\n+   28|      1|fn main() {\n+   29|      1|    let less = 1;\n+   30|      1|    let more = 100;\n+   31|      1|\n+   32|      1|    if less < more {\n+   33|      1|        wrap_with(will_be_called(), less < more, |inner| print(\" ***\", inner, \"*** \"));\n+   34|      1|        wrap_with(will_be_called(), more < less, |inner| print(\" ***\", inner, \"*** \"));\n+                                                                       ^0\n+   35|      1|    } else {\n+   36|      1|        wrap_with(will_not_be_called(), true, |inner| print(\"wrapped result is: \", inner, \"\"));\n+   37|      1|    }\n+   38|      1|}\n+"}, {"sha": "860d155505d80fcc4d8e3d5ba887fdabdd478bf8", "filename": "src/test/run-make-fulldeps/tools.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -18,6 +18,9 @@ endif\n HTMLDOCCK := '$(PYTHON)' '$(S)/src/etc/htmldocck.py'\n CGREP := \"$(S)/src/etc/cat-and-grep.sh\"\n \n+# diff with common flags for multi-platform diffs against text output\n+DIFF := diff -u --strip-trailing-cr\n+\n # This is the name of the binary we will generate and run; use this\n # e.g. for `$(CC) -o $(RUN_BINFILE)`.\n RUN_BINFILE = $(TMPDIR)/$(1)"}, {"sha": "5f7373be6594636540e3ba6845bbd5e8a4505cf8", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -186,6 +186,9 @@ pub struct Config {\n     /// The rustdoc executable.\n     pub rustdoc_path: Option<PathBuf>,\n \n+    /// The rust-demangler executable.\n+    pub rust_demangler_path: Option<PathBuf>,\n+\n     /// The Python executable to use for LLDB.\n     pub lldb_python: String,\n "}, {"sha": "07eba22c6eeb3a048f0a0322bfd492217ce389d2", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -53,6 +53,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         .reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\")\n         .reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\")\n         .optopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\")\n+        .optopt(\"\", \"rust-demangler-path\", \"path to rust-demangler to use in tests\", \"PATH\")\n         .reqopt(\"\", \"lldb-python\", \"path to python to use for doc tests\", \"PATH\")\n         .reqopt(\"\", \"docck-python\", \"path to python to use for doc tests\", \"PATH\")\n         .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n@@ -182,6 +183,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         run_lib_path: make_absolute(opt_path(matches, \"run-lib-path\")),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n         rustdoc_path: matches.opt_str(\"rustdoc-path\").map(PathBuf::from),\n+        rust_demangler_path: matches.opt_str(\"rust-demangler-path\").map(PathBuf::from),\n         lldb_python: matches.opt_str(\"lldb-python\").unwrap(),\n         docck_python: matches.opt_str(\"docck-python\").unwrap(),\n         valgrind_path: matches.opt_str(\"valgrind-path\"),\n@@ -246,6 +248,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n     logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n     logv(c, format!(\"rustdoc_path: {:?}\", config.rustdoc_path));\n+    logv(c, format!(\"rust_demangler_path: {:?}\", config.rust_demangler_path));\n     logv(c, format!(\"src_base: {:?}\", config.src_base.display()));\n     logv(c, format!(\"build_base: {:?}\", config.build_base.display()));\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n@@ -479,6 +482,8 @@ fn common_inputs_stamp(config: &Config) -> Stamp {\n         stamp.add_path(&rustdoc_path);\n         stamp.add_path(&rust_src_dir.join(\"src/etc/htmldocck.py\"));\n     }\n+    // FIXME(richkadel): Do I need to add an `if let Some(rust_demangler_path) contribution to the\n+    // stamp here as well?\n \n     // Compiletest itself.\n     stamp.add_dir(&rust_src_dir.join(\"src/tools/compiletest/\"));"}, {"sha": "f09f7621aa170ebc453b0508ee89f0fddaae0acf", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -2739,6 +2739,10 @@ impl<'test> TestCx<'test> {\n             cmd.env(\"RUSTDOC\", cwd.join(rustdoc));\n         }\n \n+        if let Some(ref rust_demangler) = self.config.rust_demangler_path {\n+            cmd.env(\"RUST_DEMANGLER\", cwd.join(rust_demangler));\n+        }\n+\n         if let Some(ref node) = self.config.nodejs {\n             cmd.env(\"NODE\", node);\n         }"}, {"sha": "0b8d974d2558adc9be243833e51733234ab662de", "filename": "src/tools/rust-demangler/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Frust-demangler%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Frust-demangler%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-demangler%2FCargo.toml?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rust-demangler\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[dependencies]\n+rustc-demangle = \"0.1\"\n+\n+[[bin]]\n+name = \"rust-demangler\"\n+path = \"main.rs\""}, {"sha": "a9f1011c450a9b67ac2d0b23aae2546dfd45d186", "filename": "src/tools/rust-demangler/main.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Frust-demangler%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f8b8a2116f0ea7e31d572d3120508678ed8079/src%2Ftools%2Frust-demangler%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-demangler%2Fmain.rs?ref=a6f8b8a2116f0ea7e31d572d3120508678ed8079", "patch": "@@ -0,0 +1,39 @@\n+//! Demangles rustc mangled names.\n+//!\n+//! This tool uses https://crates.io/crates/rustc-demangle to convert an input buffer of\n+//! newline-separated mangled names into their demangled translations.\n+//!\n+//! This tool can be leveraged by other applications that support third-party demanglers.\n+//! It takes a list of mangled names (one per line) on standard input, and prints a corresponding\n+//! list of demangled names. The tool is designed to support other programs that can leverage a\n+//! third-party demangler, such as `llvm-cov`, via the `-Xdemangler=<path-to-demangler>` option.\n+//!\n+//! To use `rust-demangler`, first build the tool with:\n+//!\n+//! ```shell\n+//! $ ./x.py build rust-demangler\n+//! ```\n+//!\n+//! Then, with `llvm-cov` for example, add the `-Xdemangler=...` option:\n+//!\n+//! ```shell\n+//! $ TARGET=\"${PWD}/build/x86_64-unknown-linux-gnu\"\n+//! $ \"${TARGET}\"/llvm/bin/llvm-cov show --Xdemangler=\"${TARGET}\"/stage0-tools-bin/rust-demangler \\\n+//!   --instr-profile=main.profdata ./main --show-line-counts-or-regions\n+//! ```\n+\n+use rustc_demangle::demangle;\n+use std::io::{self, Read, Write};\n+\n+fn main() -> io::Result<()> {\n+    let mut buffer = String::new();\n+    io::stdin().read_to_string(&mut buffer)?;\n+    let lines = buffer.lines();\n+    let mut demangled = Vec::new();\n+    for mangled in lines {\n+        demangled.push(demangle(mangled).to_string());\n+    }\n+    demangled.push(\"\".to_string());\n+    io::stdout().write_all(demangled.join(\"\\n\").as_bytes())?;\n+    Ok(())\n+}"}]}