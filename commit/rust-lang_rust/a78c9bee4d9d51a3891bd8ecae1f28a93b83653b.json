{"sha": "a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "node_id": "C_kwDOAAsO6NoAKGE3OGM5YmVlNGQ5ZDUxYTM4OTFiZDhlY2FlMWYyOGE5M2I4MzY1M2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-22T07:15:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-22T07:15:48Z"}, "message": "Auto merge of #104702 - Manishearth:rollup-75hagzd, r=Manishearth\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #83608 (Add slice methods for indexing via an array of indices.)\n - #95583 (Deprecate the unstable `ptr_to_from_bits` feature)\n - #101655 (Make the Box one-liner more descriptive)\n - #102207 (Constify remaining `Layout` methods)\n - #103193 (mark sys_common::once::generic::Once::new const-stable)\n - #104622 (Use clang for the UEFI targets)\n - #104638 (Move macro_rules diagnostics to diagnostics module)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7425ff737355fa24f044a5d4c5bf738a2829c80a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7425ff737355fa24f044a5d4c5bf738a2829c80a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "html_url": "https://github.com/rust-lang/rust/commit/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "html_url": "https://github.com/rust-lang/rust/commit/0f7d81754db66d46ee9aa033735a1ee5c1daa44d"}, {"sha": "9043dfd946164ff9de6d6c10e0a99e17dc25c098", "url": "https://api.github.com/repos/rust-lang/rust/commits/9043dfd946164ff9de6d6c10e0a99e17dc25c098", "html_url": "https://github.com/rust-lang/rust/commit/9043dfd946164ff9de6d6c10e0a99e17dc25c098"}], "stats": {"total": 856, "additions": 597, "deletions": 259}, "files": [{"sha": "95e1787980a170fb3b983059b0506bb9b63b6e99", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -789,9 +789,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.82\"\n+version = \"0.1.84\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18cd7635fea7bb481ea543b392789844c1ad581299da70184c7175ce3af76603\"\n+checksum = \"989b2c1ca6e90ad06fdc69d1d1862fa28d27a977be6d92ae2fa762cf61fe0b10\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\","}, {"sha": "c2b1b96cd646533da285458ac3c6dd661cbfe0fc", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -1,7 +1,7 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n use crate::hygiene::SyntaxContext;\n-use crate::mbe::macro_rules::annotate_err_with_kind;\n+use crate::mbe::diagnostics::annotate_err_with_kind;\n use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n "}, {"sha": "a43b2a001883a38d2cd0ff230b44c7831e7497b8", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -3,6 +3,7 @@\n //! why we call this module `mbe`. For external documentation, prefer the\n //! official terminology: \"declarative macros\".\n \n+pub(crate) mod diagnostics;\n pub(crate) mod macro_check;\n pub(crate) mod macro_parser;\n pub(crate) mod macro_rules;"}, {"sha": "197f056917f5de75171e64c73c238b82559b7315", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -0,0 +1,257 @@\n+use std::borrow::Cow;\n+\n+use crate::base::{DummyResult, ExtCtxt, MacResult};\n+use crate::expand::{parse_ast_fragment, AstFragmentKind};\n+use crate::mbe::{\n+    macro_parser::{MatcherLoc, NamedParseResult, ParseResult::*, TtParser},\n+    macro_rules::{try_match_macro, Tracker},\n+};\n+use rustc_ast::token::{self, Token};\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage};\n+use rustc_parse::parser::{Parser, Recovery};\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+use super::macro_rules::{parser_from_cx, NoopTracker};\n+\n+pub(super) fn failed_to_match_macro<'cx>(\n+    cx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    def_span: Span,\n+    name: Ident,\n+    arg: TokenStream,\n+    lhses: &[Vec<MatcherLoc>],\n+) -> Box<dyn MacResult + 'cx> {\n+    let sess = &cx.sess.parse_sess;\n+\n+    // An error occurred, try the expansion again, tracking the expansion closely for better diagnostics.\n+    let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n+\n+    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n+\n+    if try_success_result.is_ok() {\n+        // Nonterminal parser recovery might turn failed matches into successful ones,\n+        // but for that it must have emitted an error already\n+        tracker.cx.sess.delay_span_bug(sp, \"Macro matching returned a success on the second try\");\n+    }\n+\n+    if let Some(result) = tracker.result {\n+        // An irrecoverable error occurred and has been emitted.\n+        return result;\n+    }\n+\n+    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n+        return DummyResult::any(sp);\n+    };\n+\n+    let span = token.span.substitute_dummy(sp);\n+\n+    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n+    err.span_label(span, label);\n+    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n+        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n+    }\n+\n+    annotate_doc_comment(&mut err, sess.source_map(), span);\n+\n+    if let Some(span) = remaining_matcher.span() {\n+        err.span_note(span, format!(\"while trying to match {remaining_matcher}\"));\n+    } else {\n+        err.note(format!(\"while trying to match {remaining_matcher}\"));\n+    }\n+\n+    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n+    if let Some((arg, comma_span)) = arg.add_comma() {\n+        for lhs in lhses {\n+            let parser = parser_from_cx(sess, arg.clone(), Recovery::Allowed);\n+            let mut tt_parser = TtParser::new(name);\n+\n+            if let Success(_) =\n+                tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker)\n+            {\n+                if comma_span.is_dummy() {\n+                    err.note(\"you might be missing a comma\");\n+                } else {\n+                    err.span_suggestion_short(\n+                        comma_span,\n+                        \"missing comma here\",\n+                        \", \",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+    err.emit();\n+    cx.trace_macros_diag();\n+    DummyResult::any(sp)\n+}\n+\n+/// The tracker used for the slow error path that collects useful info for diagnostics.\n+struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    cx: &'a mut ExtCtxt<'cx>,\n+    remaining_matcher: Option<&'matcher MatcherLoc>,\n+    /// Which arm's failure should we report? (the one furthest along)\n+    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n+    root_span: Span,\n+    result: Option<Box<dyn MacResult + 'cx>>,\n+}\n+\n+impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n+        if self.remaining_matcher.is_none()\n+            || (parser.has_no_remaining_items_for_step() && *matcher != MatcherLoc::Eof)\n+        {\n+            self.remaining_matcher = Some(matcher);\n+        }\n+    }\n+\n+    fn after_arm(&mut self, result: &NamedParseResult) {\n+        match result {\n+            Success(_) => {\n+                // Nonterminal parser recovery might turn failed matches into successful ones,\n+                // but for that it must have emitted an error already\n+                self.cx.sess.delay_span_bug(\n+                    self.root_span,\n+                    \"should not collect detailed info for successful macro match\",\n+                );\n+            }\n+            Failure(token, msg) => match self.best_failure {\n+                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n+                _ => {\n+                    self.best_failure = Some((\n+                        token.clone(),\n+                        msg,\n+                        self.remaining_matcher\n+                            .expect(\"must have collected matcher already\")\n+                            .clone(),\n+                    ))\n+                }\n+            },\n+            Error(err_sp, msg) => {\n+                let span = err_sp.substitute_dummy(self.root_span);\n+                self.cx.struct_span_err(span, msg).emit();\n+                self.result = Some(DummyResult::any(span));\n+            }\n+            ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),\n+        }\n+    }\n+\n+    fn description() -> &'static str {\n+        \"detailed\"\n+    }\n+\n+    fn recovery() -> Recovery {\n+        Recovery::Allowed\n+    }\n+}\n+\n+impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n+    fn new(cx: &'a mut ExtCtxt<'cx>, root_span: Span) -> Self {\n+        Self { cx, remaining_matcher: None, best_failure: None, root_span, result: None }\n+    }\n+}\n+\n+pub(super) fn emit_frag_parse_err(\n+    mut e: DiagnosticBuilder<'_, rustc_errors::ErrorGuaranteed>,\n+    parser: &Parser<'_>,\n+    orig_parser: &mut Parser<'_>,\n+    site_span: Span,\n+    arm_span: Span,\n+    kind: AstFragmentKind,\n+) {\n+    // FIXME(davidtwco): avoid depending on the error message text\n+    if parser.token == token::Eof\n+        && let DiagnosticMessage::Str(message) = &e.message[0].0\n+        && message.ends_with(\", found `<eof>`\")\n+    {\n+        let msg = &e.message[0];\n+        e.message[0] = (\n+            DiagnosticMessage::Str(format!(\n+                \"macro expansion ends with an incomplete expression: {}\",\n+                message.replace(\", found `<eof>`\", \"\"),\n+            )),\n+            msg.1,\n+        );\n+        if !e.span.is_dummy() {\n+            // early end of macro arm (#52866)\n+            e.replace_span_with(parser.token.span.shrink_to_hi());\n+        }\n+    }\n+    if e.span.is_dummy() {\n+        // Get around lack of span in error (#30128)\n+        e.replace_span_with(site_span);\n+        if !parser.sess.source_map().is_imported(arm_span) {\n+            e.span_label(arm_span, \"in this macro arm\");\n+        }\n+    } else if parser.sess.source_map().is_imported(parser.token.span) {\n+        e.span_label(site_span, \"in this macro invocation\");\n+    }\n+    match kind {\n+        // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n+        AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n+            Err(err) => err.cancel(),\n+            Ok(_) => {\n+                e.note(\n+                    \"the macro call doesn't expand to an expression, but it can expand to a statement\",\n+                );\n+                e.span_suggestion_verbose(\n+                    site_span.shrink_to_hi(),\n+                    \"add `;` to interpret the expansion as a statement\",\n+                    \";\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        },\n+        _ => annotate_err_with_kind(&mut e, kind, site_span),\n+    };\n+    e.emit();\n+}\n+\n+pub(crate) fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n+    match kind {\n+        AstFragmentKind::Ty => {\n+            err.span_label(span, \"this macro call doesn't expand to a type\");\n+        }\n+        AstFragmentKind::Pat => {\n+            err.span_label(span, \"this macro call doesn't expand to a pattern\");\n+        }\n+        _ => {}\n+    };\n+}\n+\n+#[derive(Subdiagnostic)]\n+enum ExplainDocComment {\n+    #[label(expand_explain_doc_comment_inner)]\n+    Inner {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(expand_explain_doc_comment_outer)]\n+    Outer {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+pub(super) fn annotate_doc_comment(err: &mut Diagnostic, sm: &SourceMap, span: Span) {\n+    if let Ok(src) = sm.span_to_snippet(span) {\n+        if src.starts_with(\"///\") || src.starts_with(\"/**\") {\n+            err.subdiagnostic(ExplainDocComment::Outer { span });\n+        } else if src.starts_with(\"//!\") || src.starts_with(\"/*!\") {\n+            err.subdiagnostic(ExplainDocComment::Inner { span });\n+        }\n+    }\n+}\n+\n+/// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n+/// other tokens, this is \"unexpected token...\".\n+pub(super) fn parse_failure_msg(tok: &Token) -> String {\n+    match tok.kind {\n+        token::Eof => \"unexpected end of macro invocation\".to_string(),\n+        _ => format!(\"no rules expected the token `{}`\", pprust::token_to_string(tok),),\n+    }\n+}"}, {"sha": "2dbb90e2190f0db42004859a03b5455d9995f19a", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 9, "deletions": 236, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -2,6 +2,7 @@ use crate::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstFragmentKind};\n use crate::mbe;\n+use crate::mbe::diagnostics::{annotate_doc_comment, parse_failure_msg};\n use crate::mbe::macro_check;\n use crate::mbe::macro_parser::{Error, ErrorReported, Failure, Success, TtParser};\n use crate::mbe::macro_parser::{MatchedSeq, MatchedTokenTree, MatcherLoc};\n@@ -14,9 +15,7 @@ use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_errors::{\n-    Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n-};\n+use rustc_errors::{Applicability, ErrorGuaranteed};\n use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n@@ -27,14 +26,14 @@ use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent};\n use rustc_span::Span;\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n+use super::diagnostics;\n use super::macro_parser::{NamedMatches, NamedParseResult};\n \n pub(crate) struct ParserAnyMacro<'a> {\n@@ -51,74 +50,6 @@ pub(crate) struct ParserAnyMacro<'a> {\n     is_local: bool,\n }\n \n-pub(crate) fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n-    match kind {\n-        AstFragmentKind::Ty => {\n-            err.span_label(span, \"this macro call doesn't expand to a type\");\n-        }\n-        AstFragmentKind::Pat => {\n-            err.span_label(span, \"this macro call doesn't expand to a pattern\");\n-        }\n-        _ => {}\n-    };\n-}\n-\n-fn emit_frag_parse_err(\n-    mut e: DiagnosticBuilder<'_, rustc_errors::ErrorGuaranteed>,\n-    parser: &Parser<'_>,\n-    orig_parser: &mut Parser<'_>,\n-    site_span: Span,\n-    arm_span: Span,\n-    kind: AstFragmentKind,\n-) {\n-    // FIXME(davidtwco): avoid depending on the error message text\n-    if parser.token == token::Eof\n-        && let DiagnosticMessage::Str(message) = &e.message[0].0\n-        && message.ends_with(\", found `<eof>`\")\n-    {\n-        let msg = &e.message[0];\n-        e.message[0] = (\n-            DiagnosticMessage::Str(format!(\n-                \"macro expansion ends with an incomplete expression: {}\",\n-                message.replace(\", found `<eof>`\", \"\"),\n-            )),\n-            msg.1,\n-        );\n-        if !e.span.is_dummy() {\n-            // early end of macro arm (#52866)\n-            e.replace_span_with(parser.token.span.shrink_to_hi());\n-        }\n-    }\n-    if e.span.is_dummy() {\n-        // Get around lack of span in error (#30128)\n-        e.replace_span_with(site_span);\n-        if !parser.sess.source_map().is_imported(arm_span) {\n-            e.span_label(arm_span, \"in this macro arm\");\n-        }\n-    } else if parser.sess.source_map().is_imported(parser.token.span) {\n-        e.span_label(site_span, \"in this macro invocation\");\n-    }\n-    match kind {\n-        // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n-        AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n-            Err(err) => err.cancel(),\n-            Ok(_) => {\n-                e.note(\n-                    \"the macro call doesn't expand to an expression, but it can expand to a statement\",\n-                );\n-                e.span_suggestion_verbose(\n-                    site_span.shrink_to_hi(),\n-                    \"add `;` to interpret the expansion as a statement\",\n-                    \";\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-        },\n-        _ => annotate_err_with_kind(&mut e, kind, site_span),\n-    };\n-    e.emit();\n-}\n-\n impl<'a> ParserAnyMacro<'a> {\n     pub(crate) fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro {\n@@ -134,7 +65,7 @@ impl<'a> ParserAnyMacro<'a> {\n         let fragment = match parse_ast_fragment(parser, kind) {\n             Ok(f) => f,\n             Err(err) => {\n-                emit_frag_parse_err(err, parser, snapshot, site_span, arm_span, kind);\n+                diagnostics::emit_frag_parse_err(err, parser, snapshot, site_span, arm_span, kind);\n                 return kind.dummy(site_span);\n             }\n         };\n@@ -224,7 +155,7 @@ pub(super) trait Tracker<'matcher> {\n }\n \n /// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization.\n-struct NoopTracker;\n+pub(super) struct NoopTracker;\n \n impl<'matcher> Tracker<'matcher> for NoopTracker {\n     fn before_match_loc(&mut self, _: &TtParser, _: &'matcher MatcherLoc) {}\n@@ -331,135 +262,10 @@ fn expand_macro<'cx>(\n         }\n     }\n \n-    // An error occurred, try the expansion again, tracking the expansion closely for better diagnostics.\n-    let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n-\n-    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n-\n-    if try_success_result.is_ok() {\n-        // Nonterminal parser recovery might turn failed matches into successful ones,\n-        // but for that it must have emitted an error already\n-        tracker.cx.sess.delay_span_bug(sp, \"Macro matching returned a success on the second try\");\n-    }\n-\n-    if let Some(result) = tracker.result {\n-        // An irrecoverable error occurred and has been emitted.\n-        return result;\n-    }\n-\n-    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n-        return DummyResult::any(sp);\n-    };\n-\n-    let span = token.span.substitute_dummy(sp);\n-\n-    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n-    err.span_label(span, label);\n-    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n-        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n-    }\n-\n-    annotate_doc_comment(&mut err, sess.source_map(), span);\n-\n-    if let Some(span) = remaining_matcher.span() {\n-        err.span_note(span, format!(\"while trying to match {remaining_matcher}\"));\n-    } else {\n-        err.note(format!(\"while trying to match {remaining_matcher}\"));\n-    }\n-\n-    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n-    if let Some((arg, comma_span)) = arg.add_comma() {\n-        for lhs in lhses {\n-            let parser = parser_from_cx(sess, arg.clone(), Recovery::Allowed);\n-            let mut tt_parser = TtParser::new(name);\n-\n-            if let Success(_) =\n-                tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker)\n-            {\n-                if comma_span.is_dummy() {\n-                    err.note(\"you might be missing a comma\");\n-                } else {\n-                    err.span_suggestion_short(\n-                        comma_span,\n-                        \"missing comma here\",\n-                        \", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    err.emit();\n-    cx.trace_macros_diag();\n-    DummyResult::any(sp)\n+    diagnostics::failed_to_match_macro(cx, sp, def_span, name, arg, lhses)\n }\n \n-/// The tracker used for the slow error path that collects useful info for diagnostics.\n-struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n-    cx: &'a mut ExtCtxt<'cx>,\n-    remaining_matcher: Option<&'matcher MatcherLoc>,\n-    /// Which arm's failure should we report? (the one furthest along)\n-    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n-    root_span: Span,\n-    result: Option<Box<dyn MacResult + 'cx>>,\n-}\n-\n-impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n-    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n-        if self.remaining_matcher.is_none()\n-            || (parser.has_no_remaining_items_for_step() && *matcher != MatcherLoc::Eof)\n-        {\n-            self.remaining_matcher = Some(matcher);\n-        }\n-    }\n-\n-    fn after_arm(&mut self, result: &NamedParseResult) {\n-        match result {\n-            Success(_) => {\n-                // Nonterminal parser recovery might turn failed matches into successful ones,\n-                // but for that it must have emitted an error already\n-                self.cx.sess.delay_span_bug(\n-                    self.root_span,\n-                    \"should not collect detailed info for successful macro match\",\n-                );\n-            }\n-            Failure(token, msg) => match self.best_failure {\n-                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n-                _ => {\n-                    self.best_failure = Some((\n-                        token.clone(),\n-                        msg,\n-                        self.remaining_matcher\n-                            .expect(\"must have collected matcher already\")\n-                            .clone(),\n-                    ))\n-                }\n-            },\n-            Error(err_sp, msg) => {\n-                let span = err_sp.substitute_dummy(self.root_span);\n-                self.cx.struct_span_err(span, msg).emit();\n-                self.result = Some(DummyResult::any(span));\n-            }\n-            ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),\n-        }\n-    }\n-\n-    fn description() -> &'static str {\n-        \"detailed\"\n-    }\n-\n-    fn recovery() -> Recovery {\n-        Recovery::Allowed\n-    }\n-}\n-\n-impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n-    fn new(cx: &'a mut ExtCtxt<'cx>, root_span: Span) -> Self {\n-        Self { cx, remaining_matcher: None, best_failure: None, root_span, result: None }\n-    }\n-}\n-\n-enum CanRetry {\n+pub(super) enum CanRetry {\n     Yes,\n     /// We are not allowed to retry macro expansion as a fatal error has been emitted already.\n     No(ErrorGuaranteed),\n@@ -469,7 +275,7 @@ enum CanRetry {\n /// and nothing if it failed. On failure, it's the callers job to use `track` accordingly to record all errors\n /// correctly.\n #[instrument(level = \"debug\", skip(sess, arg, lhses, track), fields(tracking = %T::description()))]\n-fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n+pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n     sess: &ParseSess,\n     name: Ident,\n     arg: &TokenStream,\n@@ -769,30 +575,6 @@ pub fn compile_declarative_macro(\n     (mk_syn_ext(expander), rule_spans)\n }\n \n-#[derive(Subdiagnostic)]\n-enum ExplainDocComment {\n-    #[label(expand_explain_doc_comment_inner)]\n-    Inner {\n-        #[primary_span]\n-        span: Span,\n-    },\n-    #[label(expand_explain_doc_comment_outer)]\n-    Outer {\n-        #[primary_span]\n-        span: Span,\n-    },\n-}\n-\n-fn annotate_doc_comment(err: &mut Diagnostic, sm: &SourceMap, span: Span) {\n-    if let Ok(src) = sm.span_to_snippet(span) {\n-        if src.starts_with(\"///\") || src.starts_with(\"/**\") {\n-            err.subdiagnostic(ExplainDocComment::Outer { span });\n-        } else if src.starts_with(\"//!\") || src.starts_with(\"/*!\") {\n-            err.subdiagnostic(ExplainDocComment::Inner { span });\n-        }\n-    }\n-}\n-\n fn check_lhs_nt_follows(sess: &ParseSess, def: &ast::Item, lhs: &mbe::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n@@ -1577,15 +1359,6 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn parser_from_cx(sess: &ParseSess, tts: TokenStream, recovery: Recovery) -> Parser<'_> {\n+pub(super) fn parser_from_cx(sess: &ParseSess, tts: TokenStream, recovery: Recovery) -> Parser<'_> {\n     Parser::new(sess, tts, true, rustc_parse::MACRO_ARGUMENTS).recovery(recovery)\n }\n-\n-/// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n-/// other tokens, this is \"unexpected token...\".\n-fn parse_failure_msg(tok: &Token) -> String {\n-    match tok.kind {\n-        token::Eof => \"unexpected end of macro invocation\".to_string(),\n-        _ => format!(\"no rules expected the token `{}`\", pprust::token_to_string(tok),),\n-    }\n-}"}, {"sha": "e5f6b0c0c65d2b0700dac2b59b8a353698644f3c", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -187,7 +187,7 @@ pub use thin::ThinBox;\n \n mod thin;\n \n-/// A pointer type for heap allocation.\n+/// A pointer type that uniquely owns a heap allocation of type `T`.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]"}, {"sha": "ac3d84718d54e0e8fd95ff674960251a3e55a257", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -157,9 +157,10 @@ impl Layout {\n     /// allocate backing structure for `T` (which could be a trait\n     /// or other unsized type like a slice).\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[must_use]\n     #[inline]\n-    pub fn for_value<T: ?Sized>(t: &T) -> Self {\n+    pub const fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n         // SAFETY: see rationale in `new` for why this is using the unsafe variant\n         unsafe { Layout::from_size_align_unchecked(size, align) }\n@@ -191,8 +192,9 @@ impl Layout {\n     /// [trait object]: ../../book/ch17-02-trait-objects.html\n     /// [extern type]: ../../unstable-book/language-features/extern-types.html\n     #[unstable(feature = \"layout_for_ptr\", issue = \"69835\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[must_use]\n-    pub unsafe fn for_value_raw<T: ?Sized>(t: *const T) -> Self {\n+    pub const unsafe fn for_value_raw<T: ?Sized>(t: *const T) -> Self {\n         // SAFETY: we pass along the prerequisites of these functions to the caller\n         let (size, align) = unsafe { (mem::size_of_val_raw(t), mem::align_of_val_raw(t)) };\n         // SAFETY: see rationale in `new` for why this is using the unsafe variant\n@@ -229,8 +231,9 @@ impl Layout {\n     /// Returns an error if the combination of `self.size()` and the given\n     /// `align` violates the conditions listed in [`Layout::from_size_align`].\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn align_to(&self, align: usize) -> Result<Self, LayoutError> {\n+    pub const fn align_to(&self, align: usize) -> Result<Self, LayoutError> {\n         Layout::from_size_align(self.size(), cmp::max(self.align(), align))\n     }\n \n@@ -287,10 +290,11 @@ impl Layout {\n     /// This is equivalent to adding the result of `padding_needed_for`\n     /// to the layout's current size.\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[must_use = \"this returns a new `Layout`, \\\n                   without modifying the original\"]\n     #[inline]\n-    pub fn pad_to_align(&self) -> Layout {\n+    pub const fn pad_to_align(&self) -> Layout {\n         let pad = self.padding_needed_for(self.align());\n         // This cannot overflow. Quoting from the invariant of Layout:\n         // > `size`, when rounded up to the nearest multiple of `align`,\n@@ -311,8 +315,9 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `LayoutError`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {\n+    pub const fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {\n         // This cannot overflow. Quoting from the invariant of Layout:\n         // > `size`, when rounded up to the nearest multiple of `align`,\n         // > must not overflow isize (i.e., the rounded value must be\n@@ -321,7 +326,8 @@ impl Layout {\n         let alloc_size = padded_size.checked_mul(n).ok_or(LayoutError)?;\n \n         // The safe constructor is called here to enforce the isize size limit.\n-        Layout::from_size_alignment(alloc_size, self.align).map(|layout| (layout, padded_size))\n+        let layout = Layout::from_size_alignment(alloc_size, self.align)?;\n+        Ok((layout, padded_size))\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -370,8 +376,9 @@ impl Layout {\n     /// # assert_eq!(repr_c(&[u64, u32, u16, u32]), Ok((s, vec![0, 8, 12, 16])));\n     /// ```\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutError> {\n+    pub const fn extend(&self, next: Self) -> Result<(Self, usize), LayoutError> {\n         let new_align = cmp::max(self.align, next.align);\n         let pad = self.padding_needed_for(next.align());\n \n@@ -396,8 +403,9 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `LayoutError`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutError> {\n+    pub const fn repeat_packed(&self, n: usize) -> Result<Self, LayoutError> {\n         let size = self.size().checked_mul(n).ok_or(LayoutError)?;\n         // The safe constructor is called here to enforce the isize size limit.\n         Layout::from_size_alignment(size, self.align)\n@@ -410,8 +418,9 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `LayoutError`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutError> {\n+    pub const fn extend_packed(&self, next: Self) -> Result<Self, LayoutError> {\n         let new_size = self.size().checked_add(next.size()).ok_or(LayoutError)?;\n         // The safe constructor is called here to enforce the isize size limit.\n         Layout::from_size_alignment(new_size, self.align)\n@@ -422,13 +431,18 @@ impl Layout {\n     /// On arithmetic overflow or when the total size would exceed\n     /// `isize::MAX`, returns `LayoutError`.\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn array<T>(n: usize) -> Result<Self, LayoutError> {\n+    pub const fn array<T>(n: usize) -> Result<Self, LayoutError> {\n         // Reduce the amount of code we need to monomorphize per `T`.\n         return inner(mem::size_of::<T>(), Alignment::of::<T>(), n);\n \n         #[inline]\n-        fn inner(element_size: usize, align: Alignment, n: usize) -> Result<Layout, LayoutError> {\n+        const fn inner(\n+            element_size: usize,\n+            align: Alignment,\n+            n: usize,\n+        ) -> Result<Layout, LayoutError> {\n             // We need to check two things about the size:\n             //  - That the total size won't overflow a `usize`, and\n             //  - That the total size still fits in an `isize`."}, {"sha": "7152300abcbf3a446cca031d797040d23abb2353", "filename": "library/core/src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -506,3 +506,6 @@ impl Error for crate::ffi::FromBytesWithNulError {\n \n #[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n impl Error for crate::ffi::FromBytesUntilNulError {}\n+\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+impl<const N: usize> Error for crate::slice::GetManyMutError<N> {}"}, {"sha": "1823fd3006279d1c7bacddb75892b04b3fd93204", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -99,6 +99,8 @@\n // Library features:\n #![feature(const_align_offset)]\n #![feature(const_align_of_val)]\n+#![feature(const_align_of_val_raw)]\n+#![feature(const_alloc_layout)]\n #![feature(const_arguments_as_str)]\n #![feature(const_array_into_iter_constructors)]\n #![feature(const_bigint_helper_methods)]\n@@ -141,6 +143,7 @@\n #![feature(const_ptr_write)]\n #![feature(const_raw_ptr_comparison)]\n #![feature(const_size_of_val)]\n+#![feature(const_size_of_val_raw)]\n #![feature(const_slice_from_raw_parts_mut)]\n #![feature(const_slice_ptr_len)]\n #![feature(const_slice_split_at_mut)]"}, {"sha": "64a5290c3a267d6c378ea2680859a9c60fc0fc21", "filename": "library/core/src/ptr/alignment.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -9,7 +9,9 @@ use crate::{cmp, fmt, hash, mem, num};\n /// Note that particularly large alignments, while representable in this type,\n /// are likely not to be supported by actual allocators and linkers.\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n-#[derive(Copy, Clone, Eq, PartialEq)]\n+#[derive(Copy, Clone, Eq)]\n+#[cfg_attr(bootstrap, derive(PartialEq))]\n+#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n #[repr(transparent)]\n pub struct Alignment(AlignmentEnum);\n \n@@ -167,16 +169,18 @@ impl From<Alignment> for usize {\n     }\n }\n \n+#[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n-impl cmp::Ord for Alignment {\n+impl const cmp::Ord for Alignment {\n     #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n-        self.as_nonzero().cmp(&other.as_nonzero())\n+        self.as_nonzero().get().cmp(&other.as_nonzero().get())\n     }\n }\n \n+#[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n-impl cmp::PartialOrd for Alignment {\n+impl const cmp::PartialOrd for Alignment {\n     #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n         Some(self.cmp(other))\n@@ -198,7 +202,9 @@ type AlignmentEnum = AlignmentEnum32;\n #[cfg(target_pointer_width = \"64\")]\n type AlignmentEnum = AlignmentEnum64;\n \n-#[derive(Copy, Clone, Eq, PartialEq)]\n+#[derive(Copy, Clone, Eq)]\n+#[cfg_attr(bootstrap, derive(PartialEq))]\n+#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n #[repr(u16)]\n enum AlignmentEnum16 {\n     _Align1Shl0 = 1 << 0,\n@@ -219,7 +225,9 @@ enum AlignmentEnum16 {\n     _Align1Shl15 = 1 << 15,\n }\n \n-#[derive(Copy, Clone, Eq, PartialEq)]\n+#[derive(Copy, Clone, Eq)]\n+#[cfg_attr(bootstrap, derive(PartialEq))]\n+#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n #[repr(u32)]\n enum AlignmentEnum32 {\n     _Align1Shl0 = 1 << 0,\n@@ -256,7 +264,9 @@ enum AlignmentEnum32 {\n     _Align1Shl31 = 1 << 31,\n }\n \n-#[derive(Copy, Clone, Eq, PartialEq)]\n+#[derive(Copy, Clone, Eq)]\n+#[cfg_attr(bootstrap, derive(PartialEq))]\n+#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n #[repr(u64)]\n enum AlignmentEnum64 {\n     _Align1Shl0 = 1 << 0,"}, {"sha": "969029e262e02917efa933cdbd77fc02ddfa3f4e", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -119,6 +119,11 @@ impl<T: ?Sized> *const T {\n     /// assert_eq!(p1.to_bits() - p0.to_bits(), 4);\n     /// ```\n     #[unstable(feature = \"ptr_to_from_bits\", issue = \"91126\")]\n+    #[deprecated(\n+        since = \"1.67\",\n+        note = \"replaced by the `exposed_addr` method, or update your code \\\n+            to follow the strict provenance rules using its APIs\"\n+    )]\n     pub fn to_bits(self) -> usize\n     where\n         T: Sized,\n@@ -140,6 +145,11 @@ impl<T: ?Sized> *const T {\n     /// assert_eq!(<*const u8>::from_bits(1), dangling);\n     /// ```\n     #[unstable(feature = \"ptr_to_from_bits\", issue = \"91126\")]\n+    #[deprecated(\n+        since = \"1.67\",\n+        note = \"replaced by the `ptr::from_exposed_addr` function, or update \\\n+            your code to follow the strict provenance rules using its APIs\"\n+    )]\n     #[allow(fuzzy_provenance_casts)] // this is an unstable and semi-deprecated cast function\n     pub fn from_bits(bits: usize) -> Self\n     where"}, {"sha": "d1b3a63443379b8a69e953ddc1f8821cedce6376", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -125,6 +125,11 @@ impl<T: ?Sized> *mut T {\n     /// assert_eq!(p1.to_bits() - p0.to_bits(), 4);\n     /// ```\n     #[unstable(feature = \"ptr_to_from_bits\", issue = \"91126\")]\n+    #[deprecated(\n+        since = \"1.67\",\n+        note = \"replaced by the `exposed_addr` method, or update your code \\\n+            to follow the strict provenance rules using its APIs\"\n+    )]\n     pub fn to_bits(self) -> usize\n     where\n         T: Sized,\n@@ -146,6 +151,11 @@ impl<T: ?Sized> *mut T {\n     /// assert_eq!(<*mut u8>::from_bits(1), dangling);\n     /// ```\n     #[unstable(feature = \"ptr_to_from_bits\", issue = \"91126\")]\n+    #[deprecated(\n+        since = \"1.67\",\n+        note = \"replaced by the `ptr::from_exposed_addr_mut` function, or \\\n+            update your code to follow the strict provenance rules using its APIs\"\n+    )]\n     #[allow(fuzzy_provenance_casts)] // this is an unstable and semi-deprecated cast function\n     pub fn from_bits(bits: usize) -> Self\n     where"}, {"sha": "04486ed2d14e31a3c9c977ec9978e692b98b2a52", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -7,6 +7,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering::{self, Greater, Less};\n+use crate::fmt;\n use crate::intrinsics::{assert_unsafe_precondition, exact_div};\n use crate::marker::Copy;\n use crate::mem::{self, SizedTypeProperties};\n@@ -4082,6 +4083,88 @@ impl<T> [T] {\n         *self = rem;\n         Some(last)\n     }\n+\n+    /// Returns mutable references to many indices at once, without doing any checks.\n+    ///\n+    /// For a safe alternative see [`get_many_mut`].\n+    ///\n+    /// # Safety\n+    ///\n+    /// Calling this method with overlapping or out-of-bounds indices is *[undefined behavior]*\n+    /// even if the resulting references are not used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_many_mut)]\n+    ///\n+    /// let x = &mut [1, 2, 4];\n+    ///\n+    /// unsafe {\n+    ///     let [a, b] = x.get_many_unchecked_mut([0, 2]);\n+    ///     *a *= 10;\n+    ///     *b *= 100;\n+    /// }\n+    /// assert_eq!(x, &[10, 2, 400]);\n+    /// ```\n+    ///\n+    /// [`get_many_mut`]: slice::get_many_mut\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    #[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+    #[inline]\n+    pub unsafe fn get_many_unchecked_mut<const N: usize>(\n+        &mut self,\n+        indices: [usize; N],\n+    ) -> [&mut T; N] {\n+        // NB: This implementation is written as it is because any variation of\n+        // `indices.map(|i| self.get_unchecked_mut(i))` would make miri unhappy,\n+        // or generate worse code otherwise. This is also why we need to go\n+        // through a raw pointer here.\n+        let slice: *mut [T] = self;\n+        let mut arr: mem::MaybeUninit<[&mut T; N]> = mem::MaybeUninit::uninit();\n+        let arr_ptr = arr.as_mut_ptr();\n+\n+        // SAFETY: We expect `indices` to contain disjunct values that are\n+        // in bounds of `self`.\n+        unsafe {\n+            for i in 0..N {\n+                let idx = *indices.get_unchecked(i);\n+                *(*arr_ptr).get_unchecked_mut(i) = &mut *slice.get_unchecked_mut(idx);\n+            }\n+            arr.assume_init()\n+        }\n+    }\n+\n+    /// Returns mutable references to many indices at once.\n+    ///\n+    /// Returns an error if any index is out-of-bounds, or if the same index was\n+    /// passed more than once.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_many_mut)]\n+    ///\n+    /// let v = &mut [1, 2, 3];\n+    /// if let Ok([a, b]) = v.get_many_mut([0, 2]) {\n+    ///     *a = 413;\n+    ///     *b = 612;\n+    /// }\n+    /// assert_eq!(v, &[413, 2, 612]);\n+    /// ```\n+    #[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+    #[inline]\n+    pub fn get_many_mut<const N: usize>(\n+        &mut self,\n+        indices: [usize; N],\n+    ) -> Result<[&mut T; N], GetManyMutError<N>> {\n+        if !get_many_check_valid(&indices, self.len()) {\n+            return Err(GetManyMutError { _private: () });\n+        }\n+        // SAFETY: The `get_many_check_valid()` call checked that all indices\n+        // are disjunct and in bounds.\n+        unsafe { Ok(self.get_many_unchecked_mut(indices)) }\n+    }\n }\n \n impl<T, const N: usize> [[T; N]] {\n@@ -4304,3 +4387,56 @@ impl<T, const N: usize> SlicePattern for [T; N] {\n         self\n     }\n }\n+\n+/// This checks every index against each other, and against `len`.\n+///\n+/// This will do `binomial(N + 1, 2) = N * (N + 1) / 2 = 0, 1, 3, 6, 10, ..`\n+/// comparison operations.\n+fn get_many_check_valid<const N: usize>(indices: &[usize; N], len: usize) -> bool {\n+    // NB: The optimzer should inline the loops into a sequence\n+    // of instructions without additional branching.\n+    let mut valid = true;\n+    for (i, &idx) in indices.iter().enumerate() {\n+        valid &= idx < len;\n+        for &idx2 in &indices[..i] {\n+            valid &= idx != idx2;\n+        }\n+    }\n+    valid\n+}\n+\n+/// The error type returned by [`get_many_mut<N>`][`slice::get_many_mut`].\n+///\n+/// It indicates one of two possible errors:\n+/// - An index is out-of-bounds.\n+/// - The same index appeared multiple times in the array.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(get_many_mut)]\n+///\n+/// let v = &mut [1, 2, 3];\n+/// assert!(v.get_many_mut([0, 999]).is_err());\n+/// assert!(v.get_many_mut([1, 1]).is_err());\n+/// ```\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+// NB: The N here is there to be forward-compatible with adding more details\n+// to the error type at a later point\n+pub struct GetManyMutError<const N: usize> {\n+    _private: (),\n+}\n+\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+impl<const N: usize> fmt::Debug for GetManyMutError<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"GetManyMutError\").finish_non_exhaustive()\n+    }\n+}\n+\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+impl<const N: usize> fmt::Display for GetManyMutError<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(\"an index is out of bounds or appeared multiple times in the array\", f)\n+    }\n+}"}, {"sha": "99d4a40c4c962816f5637333c421579f518c6082", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -108,6 +108,7 @@\n #![feature(provide_any)]\n #![feature(utf8_chunks)]\n #![feature(is_ascii_octdigit)]\n+#![feature(get_many_mut)]\n #![deny(unsafe_op_in_unsafe_fn)]\n #![deny(fuzzy_provenance_casts)]\n "}, {"sha": "4e06e0f43988687dc514a36cfe157ffc8b5b5957", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -2595,3 +2595,63 @@ fn test_flatten_mut_size_overflow() {\n     let x = &mut [[(); usize::MAX]; 2][..];\n     let _ = x.flatten_mut();\n }\n+\n+#[test]\n+fn test_get_many_mut_normal_2() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a, b] = v.get_many_mut([3, 0]).unwrap();\n+    *a += 10;\n+    *b += 100;\n+    assert_eq!(v, vec![101, 2, 3, 14, 5]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_normal_3() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a, b, c] = v.get_many_mut([0, 4, 2]).unwrap();\n+    *a += 10;\n+    *b += 100;\n+    *c += 1000;\n+    assert_eq!(v, vec![11, 2, 1003, 4, 105]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_empty() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [] = v.get_many_mut([]).unwrap();\n+    assert_eq!(v, vec![1, 2, 3, 4, 5]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_single_first() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a] = v.get_many_mut([0]).unwrap();\n+    *a += 10;\n+    assert_eq!(v, vec![11, 2, 3, 4, 5]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_single_last() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a] = v.get_many_mut([4]).unwrap();\n+    *a += 10;\n+    assert_eq!(v, vec![1, 2, 3, 4, 15]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_oob_nonempty() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    assert!(v.get_many_mut([5]).is_err());\n+}\n+\n+#[test]\n+fn test_get_many_mut_oob_empty() {\n+    let mut v: Vec<i32> = vec![];\n+    assert!(v.get_many_mut([0]).is_err());\n+}\n+\n+#[test]\n+fn test_get_many_mut_duplicate() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    assert!(v.get_many_mut([1, 3, 3, 4]).is_err());\n+}"}, {"sha": "63ee6c521d793babfc515a583f9c22086b79eab9", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -347,6 +347,7 @@\n #![feature(stdsimd)]\n #![feature(test)]\n #![feature(trace_macros)]\n+#![feature(get_many_mut)]\n //\n // Only used in tests/benchmarks:\n //"}, {"sha": "d953a6745923417b1981531e0bb2343812fa23ee", "filename": "library/std/src/sys_common/once/generic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fgeneric.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -107,6 +107,7 @@ struct WaiterQueue<'a> {\n \n impl Once {\n     #[inline]\n+    #[rustc_const_stable(feature = \"const_once_new\", since = \"1.32.0\")]\n     pub const fn new() -> Once {\n         Once { state_and_queue: AtomicPtr::new(ptr::invalid_mut(INCOMPLETE)) }\n     }"}, {"sha": "0cd778a0cbb1d07074f7f56ba31da405c278f73c", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -53,6 +53,7 @@ dependencies = [\n  \"hex\",\n  \"ignore\",\n  \"libc\",\n+ \"object\",\n  \"once_cell\",\n  \"opener\",\n  \"pretty_assertions\",\n@@ -400,6 +401,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.29.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"once_cell\"\n version = \"1.12.0\""}, {"sha": "4c24c214d2c5416ee3b04b3d8d2de3dae86077b6", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -42,6 +42,7 @@ getopts = \"0.2.19\"\n cc = \"1.0.69\"\n libc = \"0.2\"\n hex = \"0.4\"\n+object = { version = \"0.29.0\", default-features = false, features = [\"archive\", \"coff\", \"read_core\", \"unaligned\"] }\n serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n sha2 = \"0.10\""}, {"sha": "2fef7f65827dd65c90e43c4b2141b964a4943fef", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -10,10 +10,14 @@\n \n use std::collections::HashSet;\n use std::env;\n+use std::ffi::OsStr;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use object::read::archive::ArchiveFile;\n+use object::BinaryFormat;\n+\n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::channel;\n@@ -555,6 +559,39 @@ fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n     }\n }\n \n+/// Check that all objects in rlibs for UEFI targets are COFF. This\n+/// ensures that the C compiler isn't producing ELF objects, which would\n+/// not link correctly with the COFF objects.\n+fn verify_uefi_rlib_format(builder: &Builder<'_>, target: TargetSelection, stamp: &Path) {\n+    if !target.ends_with(\"-uefi\") {\n+        return;\n+    }\n+\n+    for (path, _) in builder.read_stamp_file(stamp) {\n+        if path.extension() != Some(OsStr::new(\"rlib\")) {\n+            continue;\n+        }\n+\n+        let data = t!(fs::read(&path));\n+        let data = data.as_slice();\n+        let archive = t!(ArchiveFile::parse(data));\n+        for member in archive.members() {\n+            let member = t!(member);\n+            let member_data = t!(member.data(data));\n+\n+            let is_coff = match object::File::parse(member_data) {\n+                Ok(member_file) => member_file.format() == BinaryFormat::Coff,\n+                Err(_) => false,\n+            };\n+\n+            if !is_coff {\n+                let member_name = String::from_utf8_lossy(member.name());\n+                panic!(\"member {} in {} is not COFF\", member_name, path.display());\n+            }\n+        }\n+    }\n+}\n+\n /// Copy stamped files into an image's `target/lib` directory.\n fn copy_target_libs(builder: &Builder<'_>, target: TargetSelection, image: &Path, stamp: &Path) {\n     let dst = image.join(\"lib/rustlib\").join(target.triple).join(\"lib\");\n@@ -610,6 +647,7 @@ impl Step for Std {\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         let stamp = compile::libstd_stamp(builder, compiler_to_use, target);\n+        verify_uefi_rlib_format(builder, target, &stamp);\n         copy_target_libs(builder, target, &tarball.image_dir(), &stamp);\n \n         Some(tarball.generate())"}, {"sha": "93ef7dfcbf54906d2335e329f5e924e6db1fb699", "filename": "src/ci/docker/host-x86_64/dist-various-2/Dockerfile", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -61,6 +61,12 @@ ENV \\\n     AR_i686_unknown_freebsd=i686-unknown-freebsd12-ar \\\n     CC_i686_unknown_freebsd=i686-unknown-freebsd12-clang \\\n     CXX_i686_unknown_freebsd=i686-unknown-freebsd12-clang++ \\\n+    CC_aarch64_unknown_uefi=clang-11 \\\n+    CXX_aarch64_unknown_uefi=clang++-11 \\\n+    CC_i686_unknown_uefi=clang-11 \\\n+    CXX_i686_unknown_uefi=clang++-11 \\\n+    CC_x86_64_unknown_uefi=clang-11 \\\n+    CXX_x86_64_unknown_uefi=clang++-11 \\\n     CC=gcc-8 \\\n     CXX=g++-8\n "}, {"sha": "0bddffa3436f4320fe4058b9e1cf187fd3f57592", "filename": "src/ci/docker/host-x86_64/test-various/Dockerfile", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile?ref=a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "patch": "@@ -1,6 +1,7 @@\n FROM ubuntu:20.04\n \n RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \\\n+  clang-11 \\\n   g++ \\\n   make \\\n   ninja-build \\\n@@ -67,7 +68,9 @@ ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n ENV MUSL_SCRIPT python3 /checkout/x.py --stage 2 test --host='' --target $MUSL_TARGETS\n \n COPY host-x86_64/test-various/uefi_qemu_test /uefi_qemu_test\n-ENV UEFI_TARGETS=x86_64-unknown-uefi\n+ENV UEFI_TARGETS=x86_64-unknown-uefi \\\n+    CC_x86_64_unknown_uefi=clang-11 \\\n+    CXX_x86_64_unknown_uefi=clang++-11\n ENV UEFI_SCRIPT python3 /checkout/x.py --stage 2 build --host='' --target $UEFI_TARGETS && \\\n   python3 -u /uefi_qemu_test/run.py\n "}]}