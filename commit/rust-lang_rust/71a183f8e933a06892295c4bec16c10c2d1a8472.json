{"sha": "71a183f8e933a06892295c4bec16c10c2d1a8472", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYTE4M2Y4ZTkzM2EwNjg5MjI5NWM0YmVjMTZjMTBjMmQxYTg0NzI=", "commit": {"author": {"name": "Jonathan Turner", "email": "jonathandturner@users.noreply.github.com", "date": "2016-10-14T19:07:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-14T19:07:07Z"}, "message": "Rollup merge of #36755 - Rantanen:master, r=GuillaumeGomez\n\nExplain motivation behind lifetimes\n\nStart the lifetime section with an explanation of the issues that lack of explicit lifetimes cause and how the explicit lifetimes solve these.\n\n----------------\n\nI had really hard time figuring out why I would need to care about the explicit reference lifetimes when going through the book at first. With strong background in C++, I'm familiar with the dangling reference problem - but given the section seems to focus more on the lifetime syntax and various ways to define lifetimes on functions and structs, I was unable to understand how they are used to solve the reference problem.\n\nThis PR is an attempt at getting the reader to understand what the explicit lifetimes are used for and why they are an awesome thing instead of a bit of syntax that just has to be written.\n\nIt's been less than a week that I've been diving into Rust so I'm far from certain about the terminology and technical correctness. I tried mimicking the existing terminology from the lifetimes section, but still no promises on getting it right.", "tree": {"sha": "dc66eef46f70bd797574ff8923e707aec4ce02cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc66eef46f70bd797574ff8923e707aec4ce02cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71a183f8e933a06892295c4bec16c10c2d1a8472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71a183f8e933a06892295c4bec16c10c2d1a8472", "html_url": "https://github.com/rust-lang/rust/commit/71a183f8e933a06892295c4bec16c10c2d1a8472", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71a183f8e933a06892295c4bec16c10c2d1a8472/comments", "author": {"login": "jonathandturner", "id": 111457284, "node_id": "O_kgDOBqS0BA", "avatar_url": "https://avatars.githubusercontent.com/u/111457284?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathandturner", "html_url": "https://github.com/jonathandturner", "followers_url": "https://api.github.com/users/jonathandturner/followers", "following_url": "https://api.github.com/users/jonathandturner/following{/other_user}", "gists_url": "https://api.github.com/users/jonathandturner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathandturner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathandturner/subscriptions", "organizations_url": "https://api.github.com/users/jonathandturner/orgs", "repos_url": "https://api.github.com/users/jonathandturner/repos", "events_url": "https://api.github.com/users/jonathandturner/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathandturner/received_events", "type": "Organization", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd0c70f430d00bc9ef850ec3ce0816ecd2aa88cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd0c70f430d00bc9ef850ec3ce0816ecd2aa88cc", "html_url": "https://github.com/rust-lang/rust/commit/cd0c70f430d00bc9ef850ec3ce0816ecd2aa88cc"}, {"sha": "cb90723f90ca68093e6030b1d4f94e8e9e5062ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb90723f90ca68093e6030b1d4f94e8e9e5062ee", "html_url": "https://github.com/rust-lang/rust/commit/cb90723f90ca68093e6030b1d4f94e8e9e5062ee"}], "stats": {"total": 90, "additions": 76, "deletions": 14}, "files": [{"sha": "df1ee5a293c9d6b8e2638ff8c8394c2a6a286ed6", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 76, "deletions": 14, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/71a183f8e933a06892295c4bec16c10c2d1a8472/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/71a183f8e933a06892295c4bec16c10c2d1a8472/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=71a183f8e933a06892295c4bec16c10c2d1a8472", "patch": "@@ -50,11 +50,78 @@ complicated. For example, imagine this set of operations:\n 4. You decide to use the resource.\n \n Uh oh! Your reference is pointing to an invalid resource. This is called a\n-dangling pointer or \u2018use after free\u2019, when the resource is memory.\n+dangling pointer or \u2018use after free\u2019, when the resource is memory. A small\n+example of such a situation would be:\n+\n+```rust,compile_fail\n+let r;              // Introduce reference: r\n+{\n+    let i = 1;      // Introduce scoped value: i\n+    r = &i;         // Store reference of i in r\n+}                   // i goes out of scope and is dropped.\n+\n+println!(\"{}\", r);  // r still refers to i\n+```\n \n To fix this, we have to make sure that step four never happens after step\n-three. The ownership system in Rust does this through a concept called\n-lifetimes, which describe the scope that a reference is valid for.\n+three. In the small example above the Rust compiler is able to report the issue\n+as it can see the lifetimes of the various values in the function.\n+\n+When we have a function that takes arguments by reference the situation becomes\n+more complex. Consider the following example:\n+\n+```rust,compile_fail,E0106\n+fn skip_prefix(line: &str, prefix: &str) -> &str {\n+    // ...\n+#   line\n+}\n+\n+let line = \"lang:en=Hello World!\";\n+let lang = \"en\";\n+\n+let v;\n+{\n+    let p = format!(\"lang:{}=\", lang);  // -+ p goes into scope\n+    v = skip_prefix(line, p.as_str());  //  |\n+}                                       // -+ p goes out of scope\n+println!(\"{}\", v);\n+```\n+\n+Here we have a function `skip_prefix` which takes two `&str` references\n+as parameters and returns a single `&str` reference. We call it\n+by passing in references to `line` and `p`: Two variables with different\n+lifetimes. Now the safety of the `println!`-line depends on whether the\n+reference returned by `skip_prefix` function references the still living\n+`line` or the already dropped `p` string.\n+\n+Because of the above ambiguity, Rust will refuse to compile the example\n+code. To get it to compile we need to tell the compiler more about the\n+lifetimes of the references. This can be done by making the lifetimes\n+explicit in the function declaration:\n+\n+```rust\n+fn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {\n+    // ...\n+#   line\n+}\n+```\n+\n+Let's examine the changes without going too deep into the syntax for now -\n+we'll get to that later. The first change was adding the `<'a, 'b>` after the\n+method name. This introduces two lifetime parameters: `'a` and `'b`. Next each\n+reference in the function signature was associated with one of the lifetime\n+parameters by adding the lifetime name after the `&`. This tells the compiler\n+how the lifetimes between different references are related.\n+\n+As a result the compiler is now able to deduce that the return value of\n+`skip_prefix` has the same lifetime as the `line` parameter, which makes the `v`\n+reference safe to use even after the `p` goes out of scope in the original\n+example.\n+\n+In addition to the compiler being able to validate the usage of `skip_prefix`\n+return value, it can also ensure that the implementation follows the contract\n+established by the function declaration. This is useful especially when you are\n+implementing traits that are introduced [later in the book][traits].\n \n **Note** It's important to understand that lifetime annotations are\n _descriptive_, not _prescriptive_. This means that how long a reference is valid\n@@ -63,20 +130,14 @@ give information about lifetimes to the compiler that uses them to check the\n validity of references. The compiler can do so without annotations in simple\n cases, but needs the programmers support in complex scenarios.\n \n-```rust\n-// implicit\n-fn foo(x: &i32) {\n-}\n+[traits]: traits.html\n \n-// explicit\n-fn bar<'a>(x: &'a i32) {\n-}\n-```\n+# Syntax\n \n The `'a` reads \u2018the lifetime a\u2019. Technically, every reference has some lifetime\n associated with it, but the compiler lets you elide (i.e. omit, see\n-[\"Lifetime Elision\"][lifetime-elision] below) them in common cases.\n-Before we get to that, though, let\u2019s break the explicit example down:\n+[\"Lifetime Elision\"][lifetime-elision] below) them in common cases. Before we\n+get to that, though, let\u2019s look at a short example with explicit lifetimes:\n \n [lifetime-elision]: #lifetime-elision\n \n@@ -94,7 +155,8 @@ focus on the lifetimes aspect.\n [generics]: generics.html\n \n We use `<>` to declare our lifetimes. This says that `bar` has one lifetime,\n-`'a`. If we had two reference parameters, it would look like this:\n+`'a`. If we had two reference parameters with different lifetimes, it would\n+look like this:\n \n \n ```rust,ignore"}]}