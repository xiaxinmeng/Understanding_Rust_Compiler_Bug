{"sha": "29806052cec82925c09bc77f39730925a5e4c732", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ODA2MDUyY2VjODI5MjVjMDliYzc3ZjM5NzMwOTI1YTVlNGM3MzI=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-05-18T22:54:19Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-05-18T22:54:19Z"}, "message": "Refactored and renamed functions to avoid failure", "tree": {"sha": "95db8240ceb9f07ebb0c0380216a4bfe8eb5db69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95db8240ceb9f07ebb0c0380216a4bfe8eb5db69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29806052cec82925c09bc77f39730925a5e4c732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29806052cec82925c09bc77f39730925a5e4c732", "html_url": "https://github.com/rust-lang/rust/commit/29806052cec82925c09bc77f39730925a5e4c732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29806052cec82925c09bc77f39730925a5e4c732/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b06105c2a9f188df1e24c10c3d28c8f869cd558", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b06105c2a9f188df1e24c10c3d28c8f869cd558", "html_url": "https://github.com/rust-lang/rust/commit/2b06105c2a9f188df1e24c10c3d28c8f869cd558"}], "stats": {"total": 120, "additions": 57, "deletions": 63}, "files": [{"sha": "898b011b23e605effdd5ff8f90ca3203d49d529e", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 57, "deletions": 63, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/29806052cec82925c09bc77f39730925a5e4c732/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29806052cec82925c09bc77f39730925a5e4c732/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=29806052cec82925c09bc77f39730925a5e4c732", "patch": "@@ -39,14 +39,14 @@ impl<T: TotalOrd> PriorityQueue<T> {\n         Items { iter: self.data.iter() }\n     }\n \n-    /// Returns the greatest item in the queue - fails if empty\n-    pub fn top<'a>(&'a self) -> &'a T { self.data.get(0) }\n-\n-    /// Returns the greatest item in the queue - None if empty\n-    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n-        if self.is_empty() { None } else { Some(self.top()) }\n+    /// Returns the greatest item in a queue or None if it is empty\n+    pub fn top<'a>(&'a self) -> Option<&'a T> {\n+        if self.is_empty() { None } else { Some(self.data.get(0)) }\n     }\n \n+    #[deprecated=\"renamed to `top`\"]\n+    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> { self.top() }\n+\n     /// Returns the number of elements the queue can hold without reallocating\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n@@ -60,20 +60,23 @@ impl<T: TotalOrd> PriorityQueue<T> {\n         self.data.reserve(n)\n     }\n \n-    /// Pop the greatest item from the queue - fails if empty\n-    pub fn pop(&mut self) -> T {\n-        let mut item = self.data.pop().unwrap();\n-        if !self.is_empty() {\n-            swap(&mut item, self.data.get_mut(0));\n-            self.siftdown(0);\n+    /// Remove the greatest item from a queue and return it, or `None` if it is\n+    /// empty.\n+    pub fn pop(&mut self) -> Option<T> {\n+        match self.data.pop() {\n+            None           => { None }\n+            Some(mut item) => {\n+                if !self.is_empty() {\n+                    swap(&mut item, self.data.get_mut(0));\n+                    self.siftdown(0);\n+                }\n+                Some(item)\n+            }\n         }\n-        item\n     }\n \n-    /// Pop the greatest item from the queue - None if empty\n-    pub fn maybe_pop(&mut self) -> Option<T> {\n-        if self.is_empty() { None } else { Some(self.pop()) }\n-    }\n+    #[deprecated=\"renamed to `pop`\"]\n+    pub fn maybe_pop(&mut self) -> Option<T> { self.pop() }\n \n     /// Push an item onto the queue\n     pub fn push(&mut self, item: T) {\n@@ -84,18 +87,24 @@ impl<T: TotalOrd> PriorityQueue<T> {\n \n     /// Optimized version of a push followed by a pop\n     pub fn push_pop(&mut self, mut item: T) -> T {\n-        if !self.is_empty() && *self.top() > item {\n+        if !self.is_empty() && *self.top().unwrap() > item {\n             swap(&mut item, self.data.get_mut(0));\n             self.siftdown(0);\n         }\n         item\n     }\n \n-    /// Optimized version of a pop followed by a push - fails if empty\n-    pub fn replace(&mut self, mut item: T) -> T {\n-        swap(&mut item, self.data.get_mut(0));\n-        self.siftdown(0);\n-        item\n+    /// Optimized version of a pop followed by a push. The push is done\n+    /// regardless of whether the queue is empty.\n+    pub fn replace(&mut self, mut item: T) -> Option<T> {\n+        if !self.is_empty() {\n+            swap(&mut item, self.data.get_mut(0));\n+            self.siftdown(0);\n+            Some(item)\n+        } else {\n+            self.push(item);\n+            None\n+        }\n     }\n \n     #[deprecated=\"renamed to `into_vec`\"]\n@@ -117,7 +126,7 @@ impl<T: TotalOrd> PriorityQueue<T> {\n             q.data.as_mut_slice().swap(0, end);\n             q.siftdown_range(0, end)\n         }\n-        q.to_vec()\n+        q.into_vec()\n     }\n \n     /// Create an empty PriorityQueue\n@@ -247,53 +256,53 @@ mod tests {\n         sorted.sort();\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n-            assert_eq!(heap.top(), sorted.last().unwrap());\n-            assert_eq!(heap.pop(), sorted.pop().unwrap());\n+            assert_eq!(heap.top().unwrap(), sorted.last().unwrap());\n+            assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n         }\n     }\n \n     #[test]\n     fn test_push() {\n         let mut heap = PriorityQueue::from_vec(vec!(2, 4, 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top() == 9);\n+        assert!(*heap.top().unwrap() == 9);\n         heap.push(11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top() == 11);\n+        assert!(*heap.top().unwrap() == 11);\n         heap.push(5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top() == 11);\n+        assert!(*heap.top().unwrap() == 11);\n         heap.push(27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top() == 27);\n+        assert!(*heap.top().unwrap() == 27);\n         heap.push(3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top() == 27);\n+        assert!(*heap.top().unwrap() == 27);\n         heap.push(103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top() == 103);\n+        assert!(*heap.top().unwrap() == 103);\n     }\n \n     #[test]\n     fn test_push_unique() {\n         let mut heap = PriorityQueue::from_vec(vec!(box 2, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top() == box 9);\n+        assert!(*heap.top().unwrap() == box 9);\n         heap.push(box 11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top() == box 11);\n+        assert!(*heap.top().unwrap() == box 11);\n         heap.push(box 5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top() == box 11);\n+        assert!(*heap.top().unwrap() == box 11);\n         heap.push(box 27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top() == box 27);\n+        assert!(*heap.top().unwrap() == box 27);\n         heap.push(box 3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top() == box 27);\n+        assert!(*heap.top().unwrap() == box 27);\n         heap.push(box 103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top() == box 103);\n+        assert!(*heap.top().unwrap() == box 103);\n     }\n \n     #[test]\n@@ -314,24 +323,24 @@ mod tests {\n     fn test_replace() {\n         let mut heap = PriorityQueue::from_vec(vec!(5, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(6), 5);\n+        assert_eq!(heap.replace(6).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(0), 6);\n+        assert_eq!(heap.replace(0).unwrap(), 6);\n         assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(4), 5);\n+        assert_eq!(heap.replace(4).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(1), 4);\n+        assert_eq!(heap.replace(1).unwrap(), 4);\n         assert_eq!(heap.len(), 5);\n     }\n \n     fn check_to_vec(mut data: Vec<int>) {\n         let heap = PriorityQueue::from_vec(data.clone());\n-        let mut v = heap.clone().to_vec();\n+        let mut v = heap.clone().into_vec();\n         v.sort();\n         data.sort();\n \n         assert_eq!(v, data);\n-        assert_eq!(heap.to_sorted_vec(), data);\n+        assert_eq!(heap.into_sorted_vec(), data);\n     }\n \n     #[test]\n@@ -352,36 +361,21 @@ mod tests {\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_empty_pop() {\n         let mut heap: PriorityQueue<int> = PriorityQueue::new();\n-        heap.pop();\n+        assert!(heap.pop().is_none());\n     }\n \n     #[test]\n-    fn test_empty_maybe_pop() {\n-        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n-        assert!(heap.maybe_pop().is_none());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n     fn test_empty_top() {\n         let empty: PriorityQueue<int> = PriorityQueue::new();\n-        empty.top();\n-    }\n-\n-    #[test]\n-    fn test_empty_maybe_top() {\n-        let empty: PriorityQueue<int> = PriorityQueue::new();\n-        assert!(empty.maybe_top().is_none());\n+        assert!(empty.top().is_none());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_empty_replace() {\n         let mut heap: PriorityQueue<int> = PriorityQueue::new();\n-        heap.replace(5);\n+        heap.replace(5).is_none();\n     }\n \n     #[test]\n@@ -391,7 +385,7 @@ mod tests {\n         let mut q: PriorityQueue<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n-            assert_eq!(q.pop(), x);\n+            assert_eq!(q.pop().unwrap(), x);\n         }\n     }\n }"}]}