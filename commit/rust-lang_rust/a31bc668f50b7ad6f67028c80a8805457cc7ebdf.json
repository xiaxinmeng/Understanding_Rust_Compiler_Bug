{"sha": "a31bc668f50b7ad6f67028c80a8805457cc7ebdf", "node_id": "C_kwDOAAsO6NoAKGEzMWJjNjY4ZjUwYjdhZDZmNjcwMjhjODBhODgwNTQ1N2NjN2ViZGY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-03T13:31:35Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-03T13:35:26Z"}, "message": "Hide generic constructors if appropriate", "tree": {"sha": "d40cb461c4ca3a97af4ec0f9680b7804bb7438eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d40cb461c4ca3a97af4ec0f9680b7804bb7438eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a31bc668f50b7ad6f67028c80a8805457cc7ebdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a31bc668f50b7ad6f67028c80a8805457cc7ebdf", "html_url": "https://github.com/rust-lang/rust/commit/a31bc668f50b7ad6f67028c80a8805457cc7ebdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a31bc668f50b7ad6f67028c80a8805457cc7ebdf/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "992b4648d9f6a186c7c444a4db36b2bba00b09a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/992b4648d9f6a186c7c444a4db36b2bba00b09a5", "html_url": "https://github.com/rust-lang/rust/commit/992b4648d9f6a186c7c444a4db36b2bba00b09a5"}], "stats": {"total": 89, "additions": 60, "deletions": 29}, "files": [{"sha": "3dcb510ab05107ad12d9da493bc87e96a8987f48", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a31bc668f50b7ad6f67028c80a8805457cc7ebdf/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a31bc668f50b7ad6f67028c80a8805457cc7ebdf/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=a31bc668f50b7ad6f67028c80a8805457cc7ebdf", "patch": "@@ -2,6 +2,7 @@ use either::Either;\n use hir::{known, Callable, HasVisibility, HirDisplay, Semantics, TypeInfo};\n use ide_db::RootDatabase;\n use ide_db::{base_db::FileRange, helpers::FamousDefs};\n+use itertools::Itertools;\n use stdx::to_lower_snake_case;\n use syntax::{\n     ast::{self, AstNode, HasArgList, HasName},\n@@ -211,11 +212,11 @@ fn get_bind_pat_hints(\n     let label = match label {\n         Some(label) => label,\n         None => {\n-            let ty = ty.display_truncated(sema.db, config.max_length).to_string();\n-            if Some(&*ty) == get_constructor_name(sema, pat).as_deref() {\n+            let ty_name = ty.display_truncated(sema.db, config.max_length).to_string();\n+            if is_named_constructor(sema, pat, &ty_name).is_some() {\n                 return None;\n             }\n-            ty.into()\n+            ty_name.into()\n         }\n     };\n \n@@ -231,34 +232,60 @@ fn get_bind_pat_hints(\n     Some(())\n }\n \n-fn get_constructor_name(sema: &Semantics<RootDatabase>, pat: &ast::IdentPat) -> Option<String> {\n-    let it = pat.syntax().parent()?;\n+fn is_named_constructor(\n+    sema: &Semantics<RootDatabase>,\n+    pat: &ast::IdentPat,\n+    ty_name: &str,\n+) -> Option<()> {\n+    let let_node = pat.syntax().parent()?;\n     let expr = match_ast! {\n-        match it {\n+        match let_node {\n             ast::LetStmt(it) => it.initializer(),\n             ast::Condition(it) => it.expr(),\n             _ => None,\n         }\n+    }?;\n+\n+    let expr = sema.descend_node_into_attributes(expr.clone()).pop().unwrap_or(expr);\n+    // unwrap postfix expressions\n+    let expr = match expr {\n+        ast::Expr::TryExpr(it) => it.expr(),\n+        ast::Expr::AwaitExpr(it) => it.expr(),\n+        expr => Some(expr),\n+    }?;\n+    let expr = match expr {\n+        ast::Expr::CallExpr(call) => match call.expr()? {\n+            ast::Expr::PathExpr(p) => p,\n+            _ => return None,\n+        },\n+        _ => return None,\n     };\n+    let path = expr.path()?;\n \n-    if let Some(expr) = expr {\n-        let expr = sema.descend_node_into_attributes(expr.clone()).pop().unwrap_or(expr);\n-        let expr = match expr {\n-            ast::Expr::TryExpr(it) => it.expr(),\n-            ast::Expr::AwaitExpr(it) => it.expr(),\n-            expr => Some(expr),\n-        }?;\n-        let path = match expr {\n-            ast::Expr::CallExpr(call) => match call.expr()? {\n-                ast::Expr::PathExpr(p) => p.path(),\n-                _ => None,\n-            },\n-            _ => None,\n-        }?;\n-        let seg = path.qualifier()?.segment()?;\n-        return Some(seg.to_string());\n+    // Check for tuple-struct or tuple-variant in which case we can check the last segment\n+    let callable = sema.type_of_expr(&ast::Expr::PathExpr(expr))?.original.as_callable(sema.db);\n+    let callable_kind = callable.map(|it| it.kind());\n+    if let Some(hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_)) =\n+        callable_kind\n+    {\n+        if let Some(ctor) = path.segment() {\n+            return (&ctor.to_string() == ty_name).then(|| ());\n+        }\n     }\n-    None\n+\n+    // otherwise use the qualifying segment as the constructor name\n+    let qual_seg = path.qualifier()?.segment()?;\n+    let ctor_name = match qual_seg.kind()? {\n+        ast::PathSegmentKind::Name(name_ref) => {\n+            match qual_seg.generic_arg_list().map(|it| it.generic_args()) {\n+                Some(generics) => format!(\"{}<{}>\", name_ref, generics.format(\", \")),\n+                None => name_ref.to_string(),\n+            }\n+        }\n+        ast::PathSegmentKind::Type { type_ref: Some(ty), trait_ref: None } => ty.to_string(),\n+        _ => return None,\n+    };\n+    (&ctor_name == ty_name).then(|| ())\n }\n \n /// Checks if the type is an Iterator from std::iter and replaces its hint with an `impl Iterator<Item = Ty>`.\n@@ -511,10 +538,12 @@ mod tests {\n         max_length: None,\n     };\n \n+    #[track_caller]\n     fn check(ra_fixture: &str) {\n         check_with_config(TEST_CONFIG, ra_fixture);\n     }\n \n+    #[track_caller]\n     fn check_params(ra_fixture: &str) {\n         check_with_config(\n             InlayHintsConfig {\n@@ -527,6 +556,7 @@ mod tests {\n         );\n     }\n \n+    #[track_caller]\n     fn check_types(ra_fixture: &str) {\n         check_with_config(\n             InlayHintsConfig {\n@@ -539,6 +569,7 @@ mod tests {\n         );\n     }\n \n+    #[track_caller]\n     fn check_chains(ra_fixture: &str) {\n         check_with_config(\n             InlayHintsConfig {\n@@ -551,6 +582,7 @@ mod tests {\n         );\n     }\n \n+    #[track_caller]\n     fn check_with_config(config: InlayHintsConfig, ra_fixture: &str) {\n         let (analysis, file_id) = fixture::file(&ra_fixture);\n         let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n@@ -560,6 +592,7 @@ mod tests {\n         assert_eq!(expected, actual, \"\\nExpected:\\n{:#?}\\n\\nActual:\\n{:#?}\", expected, actual);\n     }\n \n+    #[track_caller]\n     fn check_expect(config: InlayHintsConfig, ra_fixture: &str, expect: Expect) {\n         let (analysis, file_id) = fixture::file(&ra_fixture);\n         let inlay_hints = analysis.inlay_hints(&config, file_id).unwrap();\n@@ -1232,11 +1265,12 @@ trait Display {}\n trait Sync {}\n \n fn main() {\n-    let _v = Vec::<Box<&(dyn Display + Sync)>>::new();\n+    // The block expression wrapping disables the constructor hint hiding logic\n+    let _v = { Vec::<Box<&(dyn Display + Sync)>>::new() };\n       //^^ Vec<Box<&(dyn Display + Sync)>>\n-    let _v = Vec::<Box<*const (dyn Display + Sync)>>::new();\n+    let _v = { Vec::<Box<*const (dyn Display + Sync)>>::new() };\n       //^^ Vec<Box<*const (dyn Display + Sync)>>\n-    let _v = Vec::<Box<dyn Display + Sync>>::new();\n+    let _v = { Vec::<Box<dyn Display + Sync>>::new() };\n       //^^ Vec<Box<dyn Display + Sync>>\n }\n \"#,\n@@ -1304,13 +1338,10 @@ impl Generic<i32> {\n fn main() {\n     let strukt = Struct::new();\n     let tuple_struct = TupleStruct();\n-     // ^^^^^^^^^^^^ TupleStruct\n     let generic0 = Generic::new();\n      // ^^^^^^^^ Generic<i32>\n     let generic1 = Generic::<i32>::new();\n-     // ^^^^^^^^ Generic<i32>\n     let generic2 = <Generic<i32>>::new();\n-     // ^^^^^^^^ Generic<i32>\n }\n \n fn fallible() -> ControlFlow<()> {"}]}