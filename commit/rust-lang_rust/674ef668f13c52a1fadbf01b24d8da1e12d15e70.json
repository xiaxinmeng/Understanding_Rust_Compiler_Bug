{"sha": "674ef668f13c52a1fadbf01b24d8da1e12d15e70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NGVmNjY4ZjEzYzUyYTFmYWRiZjAxYjI0ZDhkYTFlMTJkMTVlNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-22T11:11:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-22T11:11:14Z"}, "message": "Auto merge of #53424 - RalfJung:miri-refactor, r=oli-obk\n\nCTFE engine refactor\n\n* Value gets renamed to `Operand`, so that now `interpret::{Place, Operand}` are the \"dynamic\" versions of `mir::{Place, Operand}`.\n* `Operand` and `Place` share the data for their \"stuff is in memory\"-base in a new type, `MemPlace`. This also makes it possible to give some more precise types in other areas. Both `Operand` and `MemPlace` have methods available to project into fields (and other kinds of projections) without causing further allocations.\n* The type for \"a `Scalar` or a `ScalarPair`\" is called `Value`, and again used to give some more precise types.\n* All of these have versions with an attached layout, so that we can more often drag the layout along instead of recomputing it. This lets us get rid of `PlaceExtra::Downcast`. `MPlaceTy` and `PlaceTy` can only be constructed in place.rs, making sure the layout is handled properly. (The same should eventually be done for `ValTy` and `OpTy`.)\n This is used to check, when copying an operand to a place, that the sizes match (which caught a bunch of bugs).\n* All the high-level functions to write typed memory take a `Place`, and live in `place.rs`. All the high-level typed functions to read typed memory take an `Operand`, and live in `operands.rs`.\n* Remove `cur_frame` and handling of signedess from memory (catching a bug in the float casting code).\n* [Only functional change] Enable sanity check to recurse below dyn traits and slices.\n\nr? @oli-obk\n\nCc @eddyb", "tree": {"sha": "e3fec554d0ba8fb806e969928278e30f2663093a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3fec554d0ba8fb806e969928278e30f2663093a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/674ef668f13c52a1fadbf01b24d8da1e12d15e70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/674ef668f13c52a1fadbf01b24d8da1e12d15e70", "html_url": "https://github.com/rust-lang/rust/commit/674ef668f13c52a1fadbf01b24d8da1e12d15e70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/674ef668f13c52a1fadbf01b24d8da1e12d15e70/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71a1ef181683615f1c8da5efb3d8617c0b743009", "url": "https://api.github.com/repos/rust-lang/rust/commits/71a1ef181683615f1c8da5efb3d8617c0b743009", "html_url": "https://github.com/rust-lang/rust/commit/71a1ef181683615f1c8da5efb3d8617c0b743009"}, {"sha": "4fec615ebf604cf7ef952770650d93ad5b7b784e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fec615ebf604cf7ef952770650d93ad5b7b784e", "html_url": "https://github.com/rust-lang/rust/commit/4fec615ebf604cf7ef952770650d93ad5b7b784e"}], "stats": {"total": 5271, "additions": 2827, "deletions": 2444}, "files": [{"sha": "90081d5b85ef9ec7186ee1931cb16f398a482140", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -632,7 +632,7 @@ define_dep_nodes!( <'tcx>\n     // queries). Making them anonymous avoids hashing the result, which\n     // may save a bit of time.\n     [anon] EraseRegionsTy { ty: Ty<'tcx> },\n-    [anon] ConstValueToAllocation { val: &'tcx ty::Const<'tcx> },\n+    [anon] ConstToAllocation { val: &'tcx ty::Const<'tcx> },\n \n     [input] Freevars(DefId),\n     [input] MaybeUnusedTraitImport(DefId),"}, {"sha": "46f4ed4ec478b1b7ba1eed0182eae1cb3b11cb4a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -397,12 +397,6 @@ impl_stable_hash_for!(enum mir::interpret::ScalarMaybeUndef {\n     Undef\n });\n \n-impl_stable_hash_for!(enum mir::interpret::Value {\n-    Scalar(v),\n-    ScalarPair(a, b),\n-    ByRef(ptr, align)\n-});\n-\n impl_stable_hash_for!(struct mir::interpret::Pointer {\n     alloc_id,\n     offset"}, {"sha": "ca664c6e18b4d40095227fec643d61568b60e69e", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -13,7 +13,7 @@ pub use self::error::{\n     FrameInfo, ConstEvalResult,\n };\n \n-pub use self::value::{Scalar, Value, ConstValue, ScalarMaybeUndef};\n+pub use self::value::{Scalar, ConstValue, ScalarMaybeUndef};\n \n use std::fmt;\n use mir;\n@@ -135,7 +135,7 @@ impl<'tcx> Pointer {\n         Pointer { alloc_id, offset }\n     }\n \n-    pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n+    pub fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n         Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().wrapping_signed_offset(self.offset.bytes(), i)),\n@@ -147,7 +147,7 @@ impl<'tcx> Pointer {\n         (Pointer::new(self.alloc_id, Size::from_bytes(res)), over)\n     }\n \n-    pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n@@ -567,25 +567,33 @@ pub fn write_target_uint(\n     }\n }\n \n-pub fn write_target_int(\n-    endianness: layout::Endian,\n-    mut target: &mut [u8],\n-    data: i128,\n-) -> Result<(), io::Error> {\n-    let len = target.len();\n-    match endianness {\n-        layout::Endian::Little => target.write_int128::<LittleEndian>(data, len),\n-        layout::Endian::Big => target.write_int128::<BigEndian>(data, len),\n-    }\n-}\n-\n pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n     match endianness {\n         layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Methods to faciliate working with signed integers stored in a u128\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub fn sign_extend(value: u128, size: Size) -> u128 {\n+    let size = size.bits();\n+    // sign extend\n+    let shift = 128 - size;\n+    // shift the unsigned value to the left\n+    // and back to the right as signed (essentially fills with FF on the left)\n+    (((value << shift) as i128) >> shift) as u128\n+}\n+\n+pub fn truncate(value: u128, size: Size) -> u128 {\n+    let size = size.bits();\n+    let shift = 128 - size;\n+    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+    (value << shift) >> shift\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "b142de81c1e91ce96331e7146a82c646b592be1d", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 81, "deletions": 124, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1,21 +1,22 @@\n #![allow(unknown_lints)]\n \n-use ty::layout::{Align, HasDataLayout, Size};\n-use ty;\n+use ty::layout::{HasDataLayout, Size};\n use ty::subst::Substs;\n use hir::def_id::DefId;\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation};\n \n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n-/// matches Value's optimizations for easy conversions between these two types\n+/// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n     /// Never returned from the `const_eval` query, but the HIR contains these frequently in order\n     /// to allow HIR creation to happen for everything before needing to be able to run constant\n     /// evaluation\n     Unevaluated(DefId, &'tcx Substs<'tcx>),\n     /// Used only for types with layout::abi::Scalar ABI and ZSTs\n+    ///\n+    /// Not using the enum `Value` to encode that this must not be `Undef`\n     Scalar(Scalar),\n     /// Used only for types with layout::abi::ScalarPair\n     ///\n@@ -26,25 +27,6 @@ pub enum ConstValue<'tcx> {\n }\n \n impl<'tcx> ConstValue<'tcx> {\n-    #[inline]\n-    pub fn from_byval_value(val: Value) -> EvalResult<'static, Self> {\n-        Ok(match val {\n-            Value::ByRef(..) => bug!(),\n-            Value::ScalarPair(a, b) => ConstValue::ScalarPair(a.unwrap_or_err()?, b),\n-            Value::Scalar(val) => ConstValue::Scalar(val.unwrap_or_err()?),\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn to_byval_value(&self) -> Option<Value> {\n-        match *self {\n-            ConstValue::Unevaluated(..) |\n-            ConstValue::ByRef(..) => None,\n-            ConstValue::ScalarPair(a, b) => Some(Value::ScalarPair(a.into(), b)),\n-            ConstValue::Scalar(val) => Some(Value::Scalar(val.into())),\n-        }\n-    }\n-\n     #[inline]\n     pub fn try_to_scalar(&self) -> Option<Scalar> {\n         match *self {\n@@ -56,58 +38,44 @@ impl<'tcx> ConstValue<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_bits(&self, size: Size) -> Option<u128> {\n+    pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n         self.try_to_scalar()?.to_bits(size).ok()\n     }\n \n     #[inline]\n-    pub fn to_ptr(&self) -> Option<Pointer> {\n+    pub fn try_to_ptr(&self) -> Option<Pointer> {\n         self.try_to_scalar()?.to_ptr().ok()\n     }\n-}\n \n-/// A `Value` represents a single self-contained Rust value.\n-///\n-/// A `Value` can either refer to a block of memory inside an allocation (`ByRef`) or to a primitive\n-/// value held directly, outside of any allocation (`Scalar`).  For `ByRef`-values, we remember\n-/// whether the pointer is supposed to be aligned or not (also see Place).\n-///\n-/// For optimization of a few very common cases, there is also a representation for a pair of\n-/// primitive values (`ScalarPair`). It allows Miri to avoid making allocations for checked binary\n-/// operations and fat pointers. This idea was taken from rustc's codegen.\n-#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum Value {\n-    ByRef(Scalar, Align),\n-    Scalar(ScalarMaybeUndef),\n-    ScalarPair(ScalarMaybeUndef, ScalarMaybeUndef),\n-}\n-\n-impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n-    fn super_fold_with<'gcx: 'tcx, F: ty::fold::TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n+    pub fn new_slice(\n+        val: Scalar,\n+        len: u64,\n+        cx: impl HasDataLayout\n+    ) -> Self {\n+        ConstValue::ScalarPair(val, Scalar::Bits {\n+            bits: len as u128,\n+            size: cx.data_layout().pointer_size.bytes() as u8,\n+        }.into())\n     }\n-    fn super_visit_with<V: ty::fold::TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n+\n+    pub fn new_dyn_trait(val: Scalar, vtable: Pointer) -> Self {\n+        ConstValue::ScalarPair(val, Scalar::Ptr(vtable).into())\n     }\n }\n \n impl<'tcx> Scalar {\n-    pub fn ptr_null<C: HasDataLayout>(cx: C) -> Self {\n+    pub fn ptr_null(cx: impl HasDataLayout) -> Self {\n         Scalar::Bits {\n             bits: 0,\n             size: cx.data_layout().pointer_size.bytes() as u8,\n         }\n     }\n \n-    pub fn to_value_with_len<C: HasDataLayout>(self, len: u64, cx: C) -> Value {\n-        ScalarMaybeUndef::Scalar(self).to_value_with_len(len, cx)\n-    }\n-\n-    pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n-        ScalarMaybeUndef::Scalar(self).to_value_with_vtable(vtable)\n+    pub fn zst() -> Self {\n+        Scalar::Bits { bits: 0, size: 0 }\n     }\n \n-    pub fn ptr_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_signed_offset(self, i: i64, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -121,7 +89,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_offset(self, i: Size, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -135,7 +103,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn ptr_wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n+    pub fn ptr_wrapping_signed_offset(self, i: i64, cx: impl HasDataLayout) -> Self {\n         let layout = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -149,7 +117,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn is_null_ptr<C: HasDataLayout>(self, cx: C) -> bool {\n+    pub fn is_null_ptr(self, cx: impl HasDataLayout) -> bool {\n         match self {\n             Scalar::Bits { bits, size } =>  {\n                 assert_eq!(size as u64, cx.data_layout().pointer_size.bytes());\n@@ -159,12 +127,58 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn to_value(self) -> Value {\n-        Value::Scalar(ScalarMaybeUndef::Scalar(self))\n+    pub fn from_bool(b: bool) -> Self {\n+        Scalar::Bits { bits: b as u128, size: 1 }\n+    }\n+\n+    pub fn from_char(c: char) -> Self {\n+        Scalar::Bits { bits: c as u128, size: 4 }\n+    }\n+\n+    pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n+        match self {\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(target_size.bytes(), size as u64);\n+                assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n+                Ok(bits)\n+            }\n+            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n+        }\n+    }\n+\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+        match self {\n+            Scalar::Bits { bits: 0, .. } => err!(InvalidNullPointerUsage),\n+            Scalar::Bits { .. } => err!(ReadBytesAsPointer),\n+            Scalar::Ptr(p) => Ok(p),\n+        }\n+    }\n+\n+    pub fn is_bits(self) -> bool {\n+        match self {\n+            Scalar::Bits { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_ptr(self) -> bool {\n+        match self {\n+            Scalar::Ptr(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n+        match self {\n+            Scalar::Bits { bits: 0, size: 1 } => Ok(false),\n+            Scalar::Bits { bits: 1, size: 1 } => Ok(true),\n+            _ => err!(InvalidBool),\n+        }\n     }\n }\n \n impl From<Pointer> for Scalar {\n+    #[inline(always)]\n     fn from(ptr: Pointer) -> Self {\n         Scalar::Ptr(ptr)\n     }\n@@ -179,7 +193,7 @@ pub enum Scalar {\n     /// The raw bytes of a simple value.\n     Bits {\n         /// The first `size` bytes are the value.\n-        /// Do not try to read less or more bytes that that\n+        /// Do not try to read less or more bytes that that. The remaining bytes must be 0.\n         size: u8,\n         bits: u128,\n     },\n@@ -197,86 +211,29 @@ pub enum ScalarMaybeUndef {\n }\n \n impl From<Scalar> for ScalarMaybeUndef {\n+    #[inline(always)]\n     fn from(s: Scalar) -> Self {\n         ScalarMaybeUndef::Scalar(s)\n     }\n }\n \n-impl ScalarMaybeUndef {\n-    pub fn unwrap_or_err(self) -> EvalResult<'static, Scalar> {\n+impl<'tcx> ScalarMaybeUndef {\n+    pub fn not_undef(self) -> EvalResult<'static, Scalar> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUndef::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n-    pub fn to_value_with_len<C: HasDataLayout>(self, len: u64, cx: C) -> Value {\n-        Value::ScalarPair(self, Scalar::Bits {\n-            bits: len as u128,\n-            size: cx.data_layout().pointer_size.bytes() as u8,\n-        }.into())\n-    }\n-\n-    pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n-        Value::ScalarPair(self, Scalar::Ptr(vtable).into())\n-    }\n-\n-    pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n-        match self {\n-            ScalarMaybeUndef::Scalar(scalar) => {\n-                scalar.ptr_offset(i, cx).map(ScalarMaybeUndef::Scalar)\n-            },\n-            ScalarMaybeUndef::Undef => Ok(ScalarMaybeUndef::Undef)\n-        }\n-    }\n-}\n-\n-impl<'tcx> Scalar {\n-    pub fn from_bool(b: bool) -> Self {\n-        Scalar::Bits { bits: b as u128, size: 1 }\n-    }\n-\n-    pub fn from_char(c: char) -> Self {\n-        Scalar::Bits { bits: c as u128, size: 4 }\n-    }\n-\n-    pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n-        match self {\n-            Scalar::Bits { bits, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n-                assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n-                Ok(bits)\n-            }\n-            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n-        }\n-    }\n-\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n-        match self {\n-            Scalar::Bits {..} => err!(ReadBytesAsPointer),\n-            Scalar::Ptr(p) => Ok(p),\n-        }\n+        self.not_undef()?.to_ptr()\n     }\n \n-    pub fn is_bits(self) -> bool {\n-        match self {\n-            Scalar::Bits { .. } => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_ptr(self) -> bool {\n-        match self {\n-            Scalar::Ptr(_) => true,\n-            _ => false,\n-        }\n+    pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n+        self.not_undef()?.to_bits(target_size)\n     }\n \n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n-        match self {\n-            Scalar::Bits { bits: 0, size: 1 } => Ok(false),\n-            Scalar::Bits { bits: 1, size: 1 } => Ok(true),\n-            _ => err!(InvalidBool),\n-        }\n+        self.not_undef()?.to_bool()\n     }\n }"}, {"sha": "e958ca9b9bb023b90a6a36a78d4b7fb17a7ee39b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -17,7 +17,7 @@ use hir::def::CtorKind;\n use hir::def_id::DefId;\n use hir::{self, HirId, InlineAsm};\n use middle::region;\n-use mir::interpret::{EvalErrorKind, Scalar, Value, ScalarMaybeUndef};\n+use mir::interpret::{EvalErrorKind, Scalar, ScalarMaybeUndef, ConstValue};\n use mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n@@ -1469,14 +1469,14 @@ impl<'tcx> TerminatorKind<'tcx> {\n                     .iter()\n                     .map(|&u| {\n                         let mut s = String::new();\n-                        print_miri_value(\n-                            Scalar::Bits {\n-                                bits: u,\n-                                size: size.bytes() as u8,\n-                            }.to_value(),\n-                            switch_ty,\n-                            &mut s,\n-                        ).unwrap();\n+                        let c = ty::Const {\n+                            val: ConstValue::Scalar(Scalar::Bits {\n+                                    bits: u,\n+                                    size: size.bytes() as u8,\n+                                }.into()),\n+                            ty: switch_ty,\n+                        };\n+                        fmt_const_val(&mut s, &c).unwrap();\n                         s.into()\n                     })\n                     .chain(iter::once(String::from(\"otherwise\").into()))\n@@ -2220,18 +2220,12 @@ impl<'tcx> Debug for Constant<'tcx> {\n }\n \n /// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n-pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n-    if let Some(value) = const_val.to_byval_value() {\n-        print_miri_value(value, const_val.ty, fmt)\n-    } else {\n-        write!(fmt, \"{:?}:{}\", const_val.val, const_val.ty)\n-    }\n-}\n-\n-pub fn print_miri_value<'tcx, W: Write>(value: Value, ty: Ty<'tcx>, f: &mut W) -> fmt::Result {\n+pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const) -> fmt::Result {\n     use ty::TypeVariants::*;\n+    let value = const_val.val;\n+    let ty = const_val.ty;\n     // print some primitives\n-    if let Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits, .. })) = value {\n+    if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = value {\n         match ty.sty {\n             TyBool if bits == 0 => return write!(f, \"false\"),\n             TyBool if bits == 1 => return write!(f, \"true\"),\n@@ -2258,8 +2252,8 @@ pub fn print_miri_value<'tcx, W: Write>(value: Value, ty: Ty<'tcx>, f: &mut W) -\n         return write!(f, \"{}\", item_path_str(did));\n     }\n     // print string literals\n-    if let Value::ScalarPair(ptr, len) = value {\n-        if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = ptr {\n+    if let ConstValue::ScalarPair(ptr, len) = value {\n+        if let Scalar::Ptr(ptr) = ptr {\n             if let ScalarMaybeUndef::Scalar(Scalar::Bits { bits: len, .. }) = len {\n                 if let TyRef(_, &ty::TyS { sty: TyStr, .. }, _) = ty.sty {\n                     return ty::tls::with(|tcx| {"}, {"sha": "b5093d0a1fc951f9cb059da4e5cb55ab1eeb915a", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -198,9 +198,9 @@ impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::const_value_to_allocation<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::const_to_allocation<'tcx> {\n     fn describe(_tcx: TyCtxt, val: &'tcx ty::Const<'tcx>) -> String {\n-        format!(\"converting value `{:?}` to an allocation\", val)\n+        format!(\"converting constant `{:?}` to an allocation\", val)\n     }\n }\n "}, {"sha": "c1372293a1b68a2d152619a3392e4bd04974ce40", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -287,8 +287,8 @@ define_queries! { <'tcx>\n         [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalResult<'tcx>,\n \n-        /// Converts a constant value to an constant allocation\n-        [] fn const_value_to_allocation: const_value_to_allocation(\n+        /// Converts a constant value to a constant allocation\n+        [] fn const_to_allocation: const_to_allocation(\n             &'tcx ty::Const<'tcx>\n         ) -> &'tcx Allocation,\n     },\n@@ -706,10 +706,10 @@ fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n     DepConstructor::EraseRegionsTy { ty }\n }\n \n-fn const_value_to_allocation<'tcx>(\n+fn const_to_allocation<'tcx>(\n     val: &'tcx ty::Const<'tcx>,\n ) -> DepConstructor<'tcx> {\n-    DepConstructor::ConstValueToAllocation { val }\n+    DepConstructor::ConstToAllocation { val }\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {"}, {"sha": "8473e4af40e3b9944063eb63234bebcc93bdb8d4", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1062,7 +1062,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::FulfillObligation |\n         DepKind::VtableMethods |\n         DepKind::EraseRegionsTy |\n-        DepKind::ConstValueToAllocation |\n+        DepKind::ConstToAllocation |\n         DepKind::NormalizeProjectionTy |\n         DepKind::NormalizeTyAfterErasingRegions |\n         DepKind::ImpliedOutlivesBounds |"}, {"sha": "7c0857cd2f99885d8d2e0ab1956400a6a9e702db", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -20,7 +20,7 @@ use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS, ParamEnvAnd, ParamEnv};\n use util::captures::Captures;\n-use mir::interpret::{Scalar, Pointer, Value};\n+use mir::interpret::{Scalar, Pointer};\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -1973,17 +1973,12 @@ impl<'tcx> Const<'tcx> {\n         }\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;\n-        self.val.to_bits(size)\n+        self.val.try_to_bits(size)\n     }\n \n     #[inline]\n     pub fn to_ptr(&self) -> Option<Pointer> {\n-        self.val.to_ptr()\n-    }\n-\n-    #[inline]\n-    pub fn to_byval_value(&self) -> Option<Value> {\n-        self.val.to_byval_value()\n+        self.val.try_to_ptr()\n     }\n \n     #[inline]\n@@ -1995,7 +1990,7 @@ impl<'tcx> Const<'tcx> {\n         assert_eq!(self.ty, ty.value);\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;\n-        self.val.to_bits(size)\n+        self.val.try_to_bits(size)\n     }\n \n     #[inline]"}, {"sha": "c79a1a4bd04c6608bdbf6fcf5c07dbc721c6a48c", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1359,6 +1359,7 @@ fn describe_enum_variant(\n     // If this is not a univariant enum, there is also the discriminant field.\n     let (discr_offset, discr_arg) = match discriminant_info {\n         RegularDiscriminant(_) => {\n+            // We have the layout of an enum variant, we need the layout of the outer enum\n             let enum_layout = cx.layout_of(layout.ty);\n             (Some(enum_layout.fields.offset(0)),\n              Some((\"RUST$ENUM$DISR\".to_string(), enum_layout.field(cx, 0).ty)))"}, {"sha": "6774ce818c1f6d694a804febcb8d3571785b8caf", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use llvm;\n-use rustc::mir::interpret::ConstEvalErr;\n-use rustc_mir::interpret::{read_target_uint, const_val_field};\n+use rustc::mir::interpret::{ConstEvalErr, read_target_uint};\n+use rustc_mir::interpret::{const_field};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -186,7 +186,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     ref other => bug!(\"invalid simd shuffle type: {}\", other),\n                 };\n                 let values: Result<Vec<_>, Lrc<_>> = (0..fields).map(|field| {\n-                    let field = const_val_field(\n+                    let field = const_field(\n                         bx.tcx(),\n                         ty::ParamEnv::reveal_all(),\n                         self.instance,"}, {"sha": "681e9195805674541c9b70d7af86e532fd99c6ae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1615,21 +1615,20 @@ fn validate_const<'a, 'tcx>(\n ) {\n     let mut ecx = ::rustc_mir::interpret::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n     let result = (|| {\n-        let val = ecx.const_to_value(constant.val)?;\n         use rustc_target::abi::LayoutOf;\n+        use rustc_mir::interpret::OpTy;\n+\n+        let op = ecx.const_value_to_op(constant.val)?;\n         let layout = ecx.layout_of(constant.ty)?;\n-        let place = ecx.allocate_place_for_value(val, layout, None)?;\n-        let ptr = place.to_ptr()?;\n-        let mut todo = vec![(ptr, layout.ty, String::new())];\n+        let place = ecx.allocate_op(OpTy { op, layout })?.into();\n+\n+        let mut todo = vec![(place, Vec::new())];\n         let mut seen = FxHashSet();\n-        seen.insert((ptr, layout.ty));\n-        while let Some((ptr, ty, path)) = todo.pop() {\n-            let layout = ecx.layout_of(ty)?;\n-            ecx.validate_ptr_target(\n-                ptr,\n-                layout.align,\n-                layout,\n-                path,\n+        seen.insert(place);\n+        while let Some((place, mut path)) = todo.pop() {\n+            ecx.validate_mplace(\n+                place,\n+                &mut path,\n                 &mut seen,\n                 &mut todo,\n             )?;"}, {"sha": "79483e454ecea3c1c08c0800e0742d3089c55776", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -167,8 +167,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             LitKind::Str(ref s, _) => {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n-                let value = Scalar::Ptr(id.into()).to_value_with_len(s.len() as u64, self.tcx);\n-                ConstValue::from_byval_value(value).unwrap()\n+                ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, self.tcx)\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);"}, {"sha": "16d6a08981abc9a562854510eb5877def5829262", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -16,10 +16,10 @@ mod check_match;\n pub use self::check_match::check_crate;\n pub(crate) use self::check_match::check_match;\n \n-use interpret::{const_val_field, const_variant_index, self};\n+use interpret::{const_field, const_variant_index};\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::interpret::{Scalar, GlobalId, ConstValue};\n+use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -795,7 +795,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         debug!(\"const_to_pat: cv={:#?}\", cv);\n         let adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n-            let val = const_val_field(\n+            let val = const_field(\n                 self.tcx, self.param_env, instance,\n                 variant_opt, field, cv,\n             ).expect(\"field access failed\");\n@@ -1085,8 +1085,9 @@ pub fn compare_const_vals<'a, 'tcx>(\n             },\n             ty::TyInt(_) => {\n                 let layout = tcx.layout_of(ty).ok()?;\n-                let a = interpret::sign_extend(a, layout);\n-                let b = interpret::sign_extend(b, layout);\n+                assert!(layout.abi.is_signed());\n+                let a = sign_extend(a, layout.size);\n+                let b = sign_extend(b, layout.size);\n                 Some((a as i128).cmp(&(b as i128)))\n             },\n             _ => Some(a.cmp(&b)),\n@@ -1106,8 +1107,8 @@ pub fn compare_const_vals<'a, 'tcx>(\n                         len_b,\n                     ),\n                 ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n-                    let len_a = len_a.unwrap_or_err().ok();\n-                    let len_b = len_b.unwrap_or_err().ok();\n+                    let len_a = len_a.not_undef().ok();\n+                    let len_b = len_b.not_undef().ok();\n                     if len_a.is_none() || len_b.is_none() {\n                         tcx.sess.struct_err(\"str slice len is undef\").delay_as_bug();\n                     }\n@@ -1153,8 +1154,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n             let id = tcx.allocate_bytes(s.as_bytes());\n-            let value = Scalar::Ptr(id.into()).to_value_with_len(s.len() as u64, tcx);\n-            ConstValue::from_byval_value(value).unwrap()\n+            ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, tcx)\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);"}, {"sha": "b4d36afa0f80d7524566574083d913d8bbf4132a", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 191, "deletions": 76, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1,87 +1,85 @@\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutOf, TyLayout};\n+use rustc::ty::{self, Ty, TypeAndMut};\n+use rustc::ty::layout::{self, TyLayout, Size};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n-use super::{EvalContext, Machine};\n-use rustc::mir::interpret::{Scalar, EvalResult, Pointer, PointerArithmetic, Value, EvalErrorKind};\n+use rustc::mir::interpret::{\n+    Scalar, EvalResult, Pointer, PointerArithmetic, EvalErrorKind,\n+    truncate, sign_extend\n+};\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n-use interpret::eval_context::ValTy;\n-use interpret::Place;\n+\n+use super::{EvalContext, Machine, PlaceTy, OpTy, Value};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n+        match ty.sty {\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::TyRef(_, ty, _) => !self.type_is_sized(ty),\n+            ty::TyAdt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n+            _ => false,\n+        }\n+    }\n+\n     crate fn cast(\n         &mut self,\n-        src: ValTy<'tcx>,\n+        src: OpTy<'tcx>,\n         kind: CastKind,\n-        dest_ty: Ty<'tcx>,\n-        dest: Place,\n+        dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let src_layout = self.layout_of(src.ty)?;\n-        let dst_layout = self.layout_of(dest_ty)?;\n+        let src_layout = src.layout;\n+        let dst_layout = dest.layout;\n         use rustc::mir::CastKind::*;\n         match kind {\n             Unsize => {\n-                self.unsize_into(src.value, src_layout, dest, dst_layout)?;\n+                self.unsize_into(src, dest)?;\n             }\n \n             Misc => {\n-                if self.type_is_fat_ptr(src.ty) {\n-                    match (src.value, self.type_is_fat_ptr(dest_ty)) {\n-                        (Value::ByRef { .. }, _) |\n+                let src = self.read_value(src)?;\n+                if self.type_is_fat_ptr(src_layout.ty) {\n+                    match (src.value, self.type_is_fat_ptr(dest.layout.ty)) {\n                         // pointers to extern types\n                         (Value::Scalar(_),_) |\n                         // slices and trait objects to other slices/trait objects\n                         (Value::ScalarPair(..), true) => {\n-                            let valty = ValTy {\n-                                value: src.value,\n-                                ty: dest_ty,\n-                            };\n-                            self.write_value(valty, dest)?;\n+                            // No change to value\n+                            self.write_value(src.value, dest)?;\n                         }\n                         // slices and trait objects to thin pointers (dropping the metadata)\n                         (Value::ScalarPair(data, _), false) => {\n-                            let valty = ValTy {\n-                                value: Value::Scalar(data),\n-                                ty: dest_ty,\n-                            };\n-                            self.write_value(valty, dest)?;\n+                            self.write_scalar(data, dest)?;\n                         }\n                     }\n                 } else {\n-                    let src_layout = self.layout_of(src.ty)?;\n                     match src_layout.variants {\n                         layout::Variants::Single { index } => {\n-                            if let Some(def) = src.ty.ty_adt_def() {\n+                            if let Some(def) = src_layout.ty.ty_adt_def() {\n                                 let discr_val = def\n                                     .discriminant_for_variant(*self.tcx, index)\n                                     .val;\n                                 return self.write_scalar(\n-                                    dest,\n                                     Scalar::Bits {\n                                         bits: discr_val,\n                                         size: dst_layout.size.bytes() as u8,\n                                     },\n-                                    dest_ty);\n+                                    dest);\n                             }\n                         }\n                         layout::Variants::Tagged { .. } |\n                         layout::Variants::NicheFilling { .. } => {},\n                     }\n \n-                    let src_val = self.value_to_scalar(src)?;\n-                    let dest_val = self.cast_scalar(src_val, src_layout, dst_layout)?;\n-                    let valty = ValTy {\n-                        value: Value::Scalar(dest_val.into()),\n-                        ty: dest_ty,\n-                    };\n-                    self.write_value(valty, dest)?;\n+                    let src = src.to_scalar()?;\n+                    let dest_val = self.cast_scalar(src, src_layout, dest.layout)?;\n+                    self.write_scalar(dest_val, dest)?;\n                 }\n             }\n \n             ReifyFnPointer => {\n-                match src.ty.sty {\n+                // The src operand does not matter, just its type\n+                match src_layout.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n                         if self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n                             bug!(\"reifying a fn ptr that requires \\\n@@ -94,29 +92,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             substs,\n                         ).ok_or_else(|| EvalErrorKind::TooGeneric.into());\n                         let fn_ptr = self.memory.create_fn_alloc(instance?);\n-                        let valty = ValTy {\n-                            value: Value::Scalar(Scalar::Ptr(fn_ptr.into()).into()),\n-                            ty: dest_ty,\n-                        };\n-                        self.write_value(valty, dest)?;\n+                        self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n                     ref other => bug!(\"reify fn pointer on {:?}\", other),\n                 }\n             }\n \n             UnsafeFnPointer => {\n-                match dest_ty.sty {\n+                let src = self.read_value(src)?;\n+                match dest.layout.ty.sty {\n                     ty::TyFnPtr(_) => {\n-                        let mut src = src;\n-                        src.ty = dest_ty;\n-                        self.write_value(src, dest)?;\n+                        // No change to value\n+                        self.write_value(*src, dest)?;\n                     }\n                     ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                 }\n             }\n \n             ClosureFnPointer => {\n-                match src.ty.sty {\n+                // The src operand does not matter, just its type\n+                match src_layout.ty.sty {\n                     ty::TyClosure(def_id, substs) => {\n                         let substs = self.tcx.subst_and_normalize_erasing_regions(\n                             self.substs(),\n@@ -130,11 +125,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             ty::ClosureKind::FnOnce,\n                         );\n                         let fn_ptr = self.memory.create_fn_alloc(instance);\n-                        let valty = ValTy {\n-                            value: Value::Scalar(Scalar::Ptr(fn_ptr.into()).into()),\n-                            ty: dest_ty,\n-                        };\n-                        self.write_value(valty, dest)?;\n+                        let val = Value::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n+                        self.write_value(val, dest)?;\n                     }\n                     ref other => bug!(\"closure fn pointer on {:?}\", other),\n                 }\n@@ -155,11 +147,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match val {\n             Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n             Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, src_layout.size.bytes());\n-                match src_layout.ty.sty {\n-                    TyFloat(fty) => self.cast_from_float(bits, fty, dest_layout.ty),\n-                    _ => self.cast_from_int(bits, src_layout, dest_layout),\n+                debug_assert_eq!(size as u64, src_layout.size.bytes());\n+                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                    \"Unexpected value of size {} before casting\", size);\n+\n+                let res = match src_layout.ty.sty {\n+                    TyFloat(fty) => self.cast_from_float(bits, fty, dest_layout.ty)?,\n+                    _ => self.cast_from_int(bits, src_layout, dest_layout)?,\n+                };\n+\n+                // Sanity check\n+                match res {\n+                    Scalar::Ptr(_) => bug!(\"Fabricated a ptr value from an int...?\"),\n+                    Scalar::Bits { bits, size } => {\n+                        debug_assert_eq!(size as u64, dest_layout.size.bytes());\n+                        debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                            \"Unexpected value of size {} after casting\", size);\n+                    }\n                 }\n+                // Done\n+                Ok(res)\n             }\n         }\n     }\n@@ -229,30 +236,31 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             // float -> uint\n             TyUint(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n-                match fty {\n-                    FloatTy::F32 => Ok(Scalar::Bits {\n-                        bits: Single::from_bits(bits).to_u128(width).value,\n-                        size: (width / 8) as u8,\n-                    }),\n-                    FloatTy::F64 => Ok(Scalar::Bits {\n-                        bits: Double::from_bits(bits).to_u128(width).value,\n-                        size: (width / 8) as u8,\n-                    }),\n-                }\n+                let v = match fty {\n+                    FloatTy::F32 => Single::from_bits(bits).to_u128(width).value,\n+                    FloatTy::F64 => Double::from_bits(bits).to_u128(width).value,\n+                };\n+                // This should already fit the bit width\n+                Ok(Scalar::Bits {\n+                    bits: v,\n+                    size: (width / 8) as u8,\n+                })\n             },\n             // float -> int\n             TyInt(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n-                match fty {\n-                    FloatTy::F32 => Ok(Scalar::Bits {\n-                        bits: Single::from_bits(bits).to_i128(width).value as u128,\n-                        size: (width / 8) as u8,\n-                    }),\n-                    FloatTy::F64 => Ok(Scalar::Bits {\n-                        bits: Double::from_bits(bits).to_i128(width).value as u128,\n-                        size: (width / 8) as u8,\n-                    }),\n-                }\n+                let v = match fty {\n+                    FloatTy::F32 => Single::from_bits(bits).to_i128(width).value,\n+                    FloatTy::F64 => Double::from_bits(bits).to_i128(width).value,\n+                };\n+                // We got an i128, but we may need something smaller. We have to truncate ourselves.\n+                let truncated = truncate(v as u128, Size::from_bits(width as u64));\n+                assert_eq!(sign_extend(truncated, Size::from_bits(width as u64)) as i128, v,\n+                    \"truncating and extending changed the value?!?\");\n+                Ok(Scalar::Bits {\n+                    bits: truncated,\n+                    size: (width / 8) as u8,\n+                })\n             },\n             // f64 -> f32\n             TyFloat(FloatTy::F32) if fty == FloatTy::F64 => {\n@@ -292,4 +300,111 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             _ => err!(Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }\n     }\n+\n+    fn unsize_into_ptr(\n+        &mut self,\n+        src: OpTy<'tcx>,\n+        dest: PlaceTy<'tcx>,\n+        // The pointee types\n+        sty: Ty<'tcx>,\n+        dty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        // A<Struct> -> A<Trait> conversion\n+        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n+\n+        match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n+            (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n+                let ptr = self.read_value(src)?.to_scalar_ptr()?;\n+                // u64 cast is from usize to u64, which is always good\n+                let val = Value::new_slice(ptr, length.unwrap_usize(self.tcx.tcx), self.tcx.tcx);\n+                self.write_value(val, dest)\n+            }\n+            (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n+                // For now, upcasts are limited to changes in marker\n+                // traits, and hence never actually require an actual\n+                // change to the vtable.\n+                self.copy_op(src, dest)\n+            }\n+            (_, &ty::TyDynamic(ref data, _)) => {\n+                // Initial cast from sized to dyn trait\n+                let trait_ref = data.principal().unwrap().with_self_ty(\n+                    *self.tcx,\n+                    src_pointee_ty,\n+                );\n+                let trait_ref = self.tcx.erase_regions(&trait_ref);\n+                let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n+                let ptr = self.read_value(src)?.to_scalar_ptr()?;\n+                let val = Value::new_dyn_trait(ptr, vtable);\n+                self.write_value(val, dest)\n+            }\n+\n+            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src.layout.ty, dest.layout.ty),\n+        }\n+    }\n+\n+    fn unsize_into(\n+        &mut self,\n+        src: OpTy<'tcx>,\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        match (&src.layout.ty.sty, &dest.layout.ty.sty) {\n+            (&ty::TyRef(_, s, _), &ty::TyRef(_, d, _)) |\n+            (&ty::TyRef(_, s, _), &ty::TyRawPtr(TypeAndMut { ty: d, .. })) |\n+            (&ty::TyRawPtr(TypeAndMut { ty: s, .. }),\n+             &ty::TyRawPtr(TypeAndMut { ty: d, .. })) => {\n+                self.unsize_into_ptr(src, dest, s, d)\n+            }\n+            (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+                assert_eq!(def_a, def_b);\n+                if def_a.is_box() || def_b.is_box() {\n+                    if !def_a.is_box() || !def_b.is_box() {\n+                        bug!(\"invalid unsizing between {:?} -> {:?}\", src.layout, dest.layout);\n+                    }\n+                    return self.unsize_into_ptr(\n+                        src,\n+                        dest,\n+                        src.layout.ty.boxed_ty(),\n+                        dest.layout.ty.boxed_ty(),\n+                    );\n+                }\n+\n+                // unsizing of generic struct with pointer fields\n+                // Example: `Arc<T>` -> `Arc<Trait>`\n+                // here we need to increase the size of every &T thin ptr field to a fat ptr\n+                for i in 0..src.layout.fields.count() {\n+                    let dst_field = self.place_field(dest, i as u64)?;\n+                    if dst_field.layout.is_zst() {\n+                        continue;\n+                    }\n+                    let src_field = match src.try_as_mplace() {\n+                        Ok(mplace) => {\n+                            let src_field = self.mplace_field(mplace, i as u64)?;\n+                            src_field.into()\n+                        }\n+                        Err(..) => {\n+                            let src_field_layout = src.layout.field(&self, i)?;\n+                            // this must be a field covering the entire thing\n+                            assert_eq!(src.layout.fields.offset(i).bytes(), 0);\n+                            assert_eq!(src_field_layout.size, src.layout.size);\n+                            // just sawp out the layout\n+                            OpTy { op: src.op, layout: src_field_layout }\n+                        }\n+                    };\n+                    if src_field.layout.ty == dst_field.layout.ty {\n+                        self.copy_op(src_field, dst_field)?;\n+                    } else {\n+                        self.unsize_into(src_field, dst_field)?;\n+                    }\n+                }\n+                Ok(())\n+            }\n+            _ => {\n+                bug!(\n+                    \"unsize_into: invalid conversion: {:?} -> {:?}\",\n+                    src.layout,\n+                    dest.layout\n+                )\n+            }\n+        }\n+    }\n }"}, {"sha": "8aba49531239eda4318e5d45a942ffa57241254c", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 104, "deletions": 111, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -2,22 +2,25 @@ use std::fmt;\n use std::error::Error;\n \n use rustc::hir;\n-use rustc::mir::interpret::{ConstEvalErr, ScalarMaybeUndef};\n+use rustc::mir::interpret::ConstEvalErr;\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt, Ty, Instance};\n-use rustc::ty::layout::{self, LayoutOf, Primitive, TyLayout};\n+use rustc::ty::{self, TyCtxt, Instance};\n+use rustc::ty::layout::{LayoutOf, Primitive, TyLayout};\n use rustc::ty::subst::Subst;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n use syntax::source_map::DUMMY_SP;\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Value, Scalar, AllocId, Allocation, ConstValue,\n+    Scalar, AllocId, Allocation, ConstValue,\n+};\n+use super::{\n+    Place, PlaceExtra, PlaceTy, MemPlace, OpTy, Operand, Value,\n+    EvalContext, StackPopCleanup, Memory, MemoryKind\n };\n-use super::{Place, EvalContext, StackPopCleanup, ValTy, Memory, MemoryKind};\n \n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -35,7 +38,7 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n         instance,\n         span,\n         mir,\n-        return_place: Place::undef(),\n+        return_place: Place::null(tcx),\n         return_to_block: StackPopCleanup::None,\n         stmt: 0,\n     });\n@@ -56,7 +59,7 @@ pub fn mk_eval_cx<'a, 'tcx>(\n         instance,\n         mir.span,\n         mir,\n-        Place::undef(),\n+        Place::null(tcx),\n         StackPopCleanup::None,\n     )?;\n     Ok(ecx)\n@@ -67,47 +70,59 @@ pub fn eval_promoted<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Value, Scalar, TyLayout<'tcx>)> {\n+) -> EvalResult<'tcx, OpTy<'tcx>> {\n     ecx.with_fresh_body(|ecx| {\n         eval_body_using_ecx(ecx, cid, Some(mir), param_env)\n     })\n }\n \n-pub fn value_to_const_value<'tcx>(\n+pub fn op_to_const<'tcx>(\n     ecx: &EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n-    val: Value,\n-    layout: TyLayout<'tcx>,\n+    op: OpTy<'tcx>,\n+    normalize: bool,\n ) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n-    match (val, &layout.abi) {\n-        (Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size: 0, ..})), _) if layout.is_zst() => {},\n-        (Value::ByRef(..), _) |\n-        (Value::Scalar(_), &layout::Abi::Scalar(_)) |\n-        (Value::ScalarPair(..), &layout::Abi::ScalarPair(..)) => {},\n-        _ => bug!(\"bad value/layout combo: {:#?}, {:#?}\", val, layout),\n-    }\n-    let val = match val {\n-        Value::Scalar(val) => ConstValue::Scalar(val.unwrap_or_err()?),\n-        Value::ScalarPair(a, b) => ConstValue::ScalarPair(a.unwrap_or_err()?, b),\n-        Value::ByRef(ptr, align) => {\n-            let ptr = ptr.to_ptr().unwrap();\n+    let normalized_op = if normalize {\n+        ecx.try_read_value(op)?\n+    } else {\n+        match op.op {\n+            Operand::Indirect(mplace) => Err(mplace),\n+            Operand::Immediate(val) => Ok(val)\n+        }\n+    };\n+    let val = match normalized_op {\n+        Err(MemPlace { ptr, align, extra }) => {\n+            // extract alloc-offset pair\n+            assert_eq!(extra, PlaceExtra::None);\n+            let ptr = ptr.to_ptr()?;\n             let alloc = ecx.memory.get(ptr.alloc_id)?;\n             assert!(alloc.align.abi() >= align.abi());\n-            assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= layout.size.bytes());\n+            assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= op.layout.size.bytes());\n             let mut alloc = alloc.clone();\n             alloc.align = align;\n             let alloc = ecx.tcx.intern_const_alloc(alloc);\n             ConstValue::ByRef(alloc, ptr.offset)\n-        }\n+        },\n+        Ok(Value::Scalar(x)) =>\n+            ConstValue::Scalar(x.not_undef()?),\n+        Ok(Value::ScalarPair(a, b)) =>\n+            ConstValue::ScalarPair(a.not_undef()?, b),\n     };\n-    Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, layout.ty))\n+    Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, op.layout.ty))\n+}\n+pub fn const_to_op<'tcx>(\n+    ecx: &mut EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n+    cnst: &'tcx ty::Const<'tcx>,\n+) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    let op = ecx.const_value_to_op(cnst.val)?;\n+    Ok(OpTy { op, layout: ecx.layout_of(cnst.ty)? })\n }\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, (Value, Scalar, TyLayout<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n+) -> (EvalResult<'tcx, OpTy<'tcx>>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n     debug!(\"eval_body_and_ecx: {:?}, {:?}\", cid, param_env);\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n@@ -118,12 +133,13 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     (r, ecx)\n }\n \n+// Returns a pointer to where the result lives\n fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Value, Scalar, TyLayout<'tcx>)> {\n+) -> EvalResult<'tcx, OpTy<'tcx>> {\n     debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let mut mir = match mir {\n@@ -135,11 +151,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     }\n     let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n-    let ptr = ecx.memory.allocate(\n-        layout.size,\n-        layout.align,\n-        MemoryKind::Stack,\n-    )?;\n+    let ret = ecx.allocate(layout, MemoryKind::Stack)?;\n     let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n     let is_static = tcx.is_static(cid.instance.def_id());\n     let mutability = if is_static == Some(hir::Mutability::MutMutable) || internally_mutable {\n@@ -156,19 +168,14 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n         cid.instance,\n         mir.span,\n         mir,\n-        Place::from_ptr(ptr, layout.align),\n+        Place::Ptr(*ret),\n         cleanup,\n     )?;\n \n+    // The main interpreter loop.\n     while ecx.step()? {}\n-    let ptr = ptr.into();\n-    // always try to read the value and report errors\n-    let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n-        Some(val) if is_static.is_none() && cid.promoted.is_none() => val,\n-        // point at the allocation\n-        _ => Value::ByRef(ptr, layout.align),\n-    };\n-    Ok((value, ptr, layout))\n+\n+    Ok(ret.into())\n }\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash)]\n@@ -222,14 +229,14 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Place, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n+        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        args: &[OpTy<'tcx>],\n         span: Span,\n-        sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n         if !ecx.tcx.is_const_fn(instance.def_id()) {\n             let def_id = instance.def_id();\n+            // Some fn calls are actually BinOp intrinsics\n             let (op, oflo) = if let Some(op) = ecx.tcx.is_binop_lang_item(def_id) {\n                 op\n             } else {\n@@ -238,11 +245,12 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 );\n             };\n             let (dest, bb) = destination.expect(\"128 lowerings can't diverge\");\n-            let dest_ty = sig.output();\n+            let l = ecx.read_value(args[0])?;\n+            let r = ecx.read_value(args[1])?;\n             if oflo {\n-                ecx.intrinsic_with_overflow(op, args[0], args[1], dest, dest_ty)?;\n+                ecx.binop_with_overflow(op, l, r, dest)?;\n             } else {\n-                ecx.intrinsic_overflowing(op, args[0], args[1], dest, dest_ty)?;\n+                ecx.binop_ignore_overflow(op, l, r, dest)?;\n             }\n             ecx.goto_block(bb);\n             return Ok(true);\n@@ -260,8 +268,8 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n             }\n         };\n         let (return_place, return_to_block) = match destination {\n-            Some((place, block)) => (place, StackPopCleanup::Goto(block)),\n-            None => (Place::undef(), StackPopCleanup::None),\n+            Some((place, block)) => (*place, StackPopCleanup::Goto(block)),\n+            None => (Place::null(&ecx), StackPopCleanup::None),\n         };\n \n         ecx.push_stack_frame(\n@@ -279,9 +287,8 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     fn call_intrinsic<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[ValTy<'tcx>],\n-        dest: Place,\n-        dest_layout: layout::TyLayout<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: PlaceTy<'tcx>,\n         target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n         let substs = instance.substs;\n@@ -293,34 +300,34 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n                 let align_val = Scalar::Bits {\n                     bits: elem_align as u128,\n-                    size: dest_layout.size.bytes() as u8,\n+                    size: dest.layout.size.bytes() as u8,\n                 };\n-                ecx.write_scalar(dest, align_val, dest_layout.ty)?;\n+                ecx.write_scalar(align_val, dest)?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = ecx.layout_of(ty)?.size.bytes() as u128;\n                 let size_val = Scalar::Bits {\n                     bits: size,\n-                    size: dest_layout.size.bytes() as u8,\n+                    size: dest.layout.size.bytes() as u8,\n                 };\n-                ecx.write_scalar(dest, size_val, dest_layout.ty)?;\n+                ecx.write_scalar(size_val, dest)?;\n             }\n \n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let type_id = ecx.tcx.type_id_hash(ty) as u128;\n                 let id_val = Scalar::Bits {\n                     bits: type_id,\n-                    size: dest_layout.size.bytes() as u8,\n+                    size: dest.layout.size.bytes() as u8,\n                 };\n-                ecx.write_scalar(dest, id_val, dest_layout.ty)?;\n+                ecx.write_scalar(id_val, dest)?;\n             }\n             \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n                 let ty = substs.type_at(0);\n                 let layout_of = ecx.layout_of(ty)?;\n-                let bits = ecx.value_to_scalar(args[0])?.to_bits(layout_of.size)?;\n+                let bits = ecx.read_scalar(args[0])?.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n                     _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n@@ -333,7 +340,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 } else {\n                     numeric_intrinsic(intrinsic_name, bits, kind)?\n                 };\n-                ecx.write_scalar(dest, out_val, ty)?;\n+                ecx.write_scalar(out_val, dest)?;\n             }\n \n             name => return Err(\n@@ -353,9 +360,9 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         left: Scalar,\n-        _left_ty: Ty<'tcx>,\n+        _left_layout: TyLayout<'tcx>,\n         right: Scalar,\n-        _right_ty: Ty<'tcx>,\n+        _right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n         if left.is_bits() && right.is_bits() {\n             Ok(None)\n@@ -387,8 +394,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n \n     fn box_alloc<'a>(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _ty: Ty<'tcx>,\n-        _dest: Place,\n+        _dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n@@ -406,38 +412,30 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     }\n }\n \n-pub fn const_val_field<'a, 'tcx>(\n+/// Project to a field of a (variant of a) const\n+pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     instance: ty::Instance<'tcx>,\n     variant: Option<usize>,\n     field: mir::Field,\n     value: &'tcx ty::Const<'tcx>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n-    trace!(\"const_val_field: {:?}, {:?}, {:?}\", instance, field, value);\n+    trace!(\"const_field: {:?}, {:?}, {:?}\", instance, field, value);\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let result = (|| {\n-        let ty = value.ty;\n-        let value = ecx.const_to_value(value.val)?;\n-        let layout = ecx.layout_of(ty)?;\n-        let place = ecx.allocate_place_for_value(value, layout, variant)?;\n-        let (place, layout) = ecx.place_field(place, field, layout)?;\n-        let (ptr, align) = place.to_ptr_align();\n-        let mut new_value = Value::ByRef(ptr.unwrap_or_err()?, align);\n-        new_value = ecx.try_read_by_ref(new_value, layout.ty)?;\n-        use rustc_data_structures::indexed_vec::Idx;\n-        match (value, new_value) {\n-            (Value::Scalar(_), Value::ByRef(..)) |\n-            (Value::ScalarPair(..), Value::ByRef(..)) |\n-            (Value::Scalar(_), Value::ScalarPair(..)) => bug!(\n-                \"field {} of {:?} yielded {:?}\",\n-                field.index(),\n-                value,\n-                new_value,\n-            ),\n-            _ => {},\n-        }\n-        value_to_const_value(&ecx, new_value, layout)\n+        // get the operand again\n+        let op = const_to_op(&mut ecx, value)?;\n+        // downcast\n+        let down = match variant {\n+            None => op,\n+            Some(variant) => ecx.operand_downcast(op, variant)?\n+        };\n+        // then project\n+        let field = ecx.operand_field(down, field.index() as u64)?;\n+        // and finally move back to the const world, always normalizing because\n+        // this is not called for statics.\n+        op_to_const(&ecx, field, true)\n     })();\n     result.map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n@@ -457,21 +455,11 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> EvalResult<'tcx, usize> {\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n-    let value = ecx.const_to_value(val.val)?;\n-    let layout = ecx.layout_of(val.ty)?;\n-    let (ptr, align) = match value {\n-        Value::ScalarPair(..) | Value::Scalar(_) => {\n-            let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?.into();\n-            ecx.write_value_to_ptr(value, ptr, layout.align, val.ty)?;\n-            (ptr, layout.align)\n-        },\n-        Value::ByRef(ptr, align) => (ptr, align),\n-    };\n-    let place = Place::from_scalar_ptr(ptr.into(), align);\n-    ecx.read_discriminant_as_variant_index(place, layout)\n+    let op = const_to_op(&mut ecx, val)?;\n+    ecx.read_discriminant_as_variant_index(op)\n }\n \n-pub fn const_value_to_allocation_provider<'a, 'tcx>(\n+pub fn const_to_allocation_provider<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     val: &'tcx ty::Const<'tcx>,\n ) -> &'tcx Allocation {\n@@ -488,11 +476,11 @@ pub fn const_value_to_allocation_provider<'a, 'tcx>(\n             ty::ParamEnv::reveal_all(),\n             CompileTimeEvaluator,\n             ());\n-        let value = ecx.const_to_value(val.val)?;\n-        let layout = ecx.layout_of(val.ty)?;\n-        let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?;\n-        ecx.write_value_to_ptr(value, ptr.into(), layout.align, val.ty)?;\n-        let alloc = ecx.memory.get(ptr.alloc_id)?;\n+        let op = const_to_op(&mut ecx, val)?;\n+        // Make a new allocation, copy things there\n+        let ptr = ecx.allocate(op.layout, MemoryKind::Stack)?;\n+        ecx.copy_op(op, ptr.into())?;\n+        let alloc = ecx.memory.get(ptr.to_ptr()?.alloc_id)?;\n         Ok(tcx.intern_const_alloc(alloc.clone()))\n     };\n     result().expect(\"unable to convert ConstValue to Allocation\")\n@@ -534,11 +522,16 @@ pub fn const_eval_provider<'a, 'tcx>(\n     };\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.and_then(|(mut val, _, layout)| {\n-        if tcx.is_static(def_id).is_none() && cid.promoted.is_none() {\n-            val = ecx.try_read_by_ref(val, layout.ty)?;\n+    res.and_then(|op| {\n+        let normalize = tcx.is_static(def_id).is_none() && cid.promoted.is_none();\n+        if !normalize {\n+            // Sanity check: These must always be a MemPlace\n+            match op.op {\n+                Operand::Indirect(_) => { /* all is good */ },\n+                Operand::Immediate(_) => bug!(\"const eval gave us an Immediate\"),\n+            }\n         }\n-        value_to_const_value(&ecx, val, layout)\n+        op_to_const(&ecx, op, normalize)\n     }).map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n         let err = ConstEvalErr {"}, {"sha": "33420b6150bb789918f58825effad23f9ec5fbdd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 147, "deletions": 1268, "changes": 1415, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -6,49 +6,28 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::mir;\n-use rustc::ty::layout::{self, Size, Align, HasDataLayout, IntegerExt, LayoutOf, TyLayout, Primitive};\n+use rustc::ty::layout::{\n+    self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n+};\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt, TypeAndMut};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::fx::{FxHashSet, FxHasher};\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::interpret::{\n-    GlobalId, Value, Scalar, FrameInfo, AllocType,\n-    EvalResult, EvalErrorKind, Pointer, ConstValue,\n+    GlobalId, Scalar, FrameInfo,\n+    EvalResult, EvalErrorKind,\n     ScalarMaybeUndef,\n+    truncate, sign_extend,\n };\n \n use syntax::source_map::{self, Span};\n use syntax::ast::Mutability;\n \n-use super::{Place, PlaceExtra, Memory,\n-            HasMemory, MemoryKind,\n-            Machine};\n-\n-macro_rules! validation_failure{\n-    ($what:expr, $where:expr, $details:expr) => {{\n-        let where_ = if $where.is_empty() {\n-            String::new()\n-        } else {\n-            format!(\" at {}\", $where)\n-        };\n-        err!(ValidationFailure(format!(\n-            \"encountered {}{}, but expected {}\",\n-            $what, where_, $details,\n-        )))\n-    }};\n-    ($what:expr, $where:expr) => {{\n-        let where_ = if $where.is_empty() {\n-            String::new()\n-        } else {\n-            format!(\" at {}\", $where)\n-        };\n-        err!(ValidationFailure(format!(\n-            \"encountered {}{}\",\n-            $what, where_,\n-        )))\n-    }};\n-}\n+use super::{\n+    Value, Operand, MemPlace, MPlaceTy, Place, PlaceExtra,\n+    Memory, Machine\n+};\n \n pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n@@ -119,21 +98,6 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub stmt: usize,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub enum LocalValue {\n-    Dead,\n-    Live(Value),\n-}\n-\n-impl LocalValue {\n-    pub fn access(self) -> EvalResult<'static, Value> {\n-        match self {\n-            LocalValue::Dead => err!(DeadLocal),\n-            LocalValue::Live(val) => Ok(val),\n-        }\n-    }\n-}\n-\n impl<'mir, 'tcx: 'mir> Eq for Frame<'mir, 'tcx> {}\n \n impl<'mir, 'tcx: 'mir> PartialEq for Frame<'mir, 'tcx> {\n@@ -182,6 +146,33 @@ impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n     }\n }\n \n+// State of a local variable\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum LocalValue {\n+    Dead,\n+    // Mostly for convenience, we re-use the `Operand` type here.\n+    // This is an optimization over just always having a pointer here;\n+    // we can thus avoid doing an allocation when the local just stores\n+    // immediate values *and* never has its address taken.\n+    Live(Operand),\n+}\n+\n+impl<'tcx> LocalValue {\n+    pub fn access(&self) -> EvalResult<'tcx, &Operand> {\n+        match self {\n+            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Live(ref val) => Ok(val),\n+        }\n+    }\n+\n+    pub fn access_mut(&mut self) -> EvalResult<'tcx, &mut Operand> {\n+        match self {\n+            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Live(ref mut val) => Ok(val),\n+        }\n+    }\n+}\n+\n /// The virtual machine state during const-evaluation at a given point in time.\n type EvalSnapshot<'a, 'mir, 'tcx, M>\n     = (M, Vec<Frame<'mir, 'tcx>>, Memory<'a, 'mir, 'tcx, M>);\n@@ -263,25 +254,6 @@ pub enum StackPopCleanup {\n     None,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct TyAndPacked<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub packed: bool,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct ValTy<'tcx> {\n-    pub value: Value,\n-    pub ty: Ty<'tcx>,\n-}\n-\n-impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n-    type Target = Value;\n-    fn deref(&self) -> &Value {\n-        &self.value\n-    }\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n@@ -316,6 +288,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for &'a EvalContext<'a, 'm\n     type Ty = Ty<'tcx>;\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n+    #[inline]\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n             .map_err(|layout| EvalErrorKind::Layout(layout).into())\n@@ -363,12 +336,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         r\n     }\n \n-    pub fn alloc_ptr(&mut self, layout: TyLayout<'tcx>) -> EvalResult<'tcx, Pointer> {\n-        assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n-\n-        self.memory.allocate(layout.size, layout.align, MemoryKind::Stack)\n-    }\n-\n     pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         &self.memory\n     }\n@@ -387,31 +354,28 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.stack.len() - 1\n     }\n \n-    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n-        let ptr = self.memory.allocate_bytes(s.as_bytes());\n-        Ok(Scalar::Ptr(ptr).to_value_with_len(s.len() as u64, self.tcx.tcx))\n+    /// Mark a storage as live, killing the previous content and returning it.\n+    /// Remember to deallocate that!\n+    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, LocalValue> {\n+        trace!(\"{:?} is now live\", local);\n+\n+        let layout = self.layout_of_local(self.cur_frame(), local)?;\n+        let init = LocalValue::Live(self.uninit_operand(layout)?);\n+        // StorageLive *always* kills the value that's currently stored\n+        Ok(mem::replace(&mut self.frame_mut().locals[local], init))\n     }\n \n-    pub fn const_to_value(\n-        &mut self,\n-        val: ConstValue<'tcx>,\n-    ) -> EvalResult<'tcx, Value> {\n-        match val {\n-            ConstValue::Unevaluated(def_id, substs) => {\n-                let instance = self.resolve(def_id, substs)?;\n-                self.read_global_as_value(GlobalId {\n-                    instance,\n-                    promoted: None,\n-                })\n-            }\n-            ConstValue::ByRef(alloc, offset) => {\n-                // FIXME: Allocate new AllocId for all constants inside\n-                let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n-                Ok(Value::ByRef(Pointer::new(id, offset).into(), alloc.align))\n-            },\n-            ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a.into(), b.into())),\n-            ConstValue::Scalar(val) => Ok(Value::Scalar(val.into())),\n-        }\n+    /// Returns the old value of the local.\n+    /// Remember to deallocate that!\n+    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue {\n+        trace!(\"{:?} is now dead\", local);\n+\n+        mem::replace(&mut self.frame_mut().locals[local], LocalValue::Dead)\n+    }\n+\n+    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n+        let ptr = self.memory.allocate_bytes(s.as_bytes());\n+        Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n     }\n \n     pub(super) fn resolve(&self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n@@ -455,48 +419,65 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub fn monomorphize(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+        &self,\n+        t: T,\n+        substs: &'tcx Substs<'tcx>\n+    ) -> T {\n         // miri doesn't care about lifetimes, and will choke on some crazy ones\n         // let's simply get rid of them\n-        let substituted = ty.subst(*self.tcx, substs);\n+        let substituted = t.subst(*self.tcx, substs);\n         self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted)\n     }\n \n-    /// Return the size and alignment of the value at the given type.\n+    pub fn layout_of_local(\n+        &self,\n+        frame: usize,\n+        local: mir::Local\n+    ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n+        let local_ty = self.stack[frame].mir.local_decls[local].ty;\n+        let local_ty = self.monomorphize(\n+            local_ty,\n+            self.stack[frame].instance.substs\n+        );\n+        self.layout_of(local_ty)\n+    }\n+\n+    /// Return the actual dynamic size and alignment of the place at the given type.\n     /// Note that the value does not matter if the type is sized. For unsized types,\n     /// the value has to be a fat pointer, and we only care about the \"extra\" data in it.\n-    pub fn size_and_align_of_dst(\n+    pub fn size_and_align_of_mplace(\n         &self,\n-        ty: Ty<'tcx>,\n-        value: Value,\n+        mplace: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        let layout = self.layout_of(ty)?;\n-        if !layout.is_unsized() {\n-            Ok(layout.size_and_align())\n+        if let PlaceExtra::None = mplace.extra {\n+            assert!(!mplace.layout.is_unsized());\n+            Ok(mplace.layout.size_and_align())\n         } else {\n-            match ty.sty {\n+            let layout = mplace.layout;\n+            assert!(layout.is_unsized());\n+            match layout.ty.sty {\n                 ty::TyAdt(..) | ty::TyTuple(..) => {\n                     // First get the size of all statically known fields.\n                     // Don't use type_of::sizing_type_of because that expects t to be sized,\n                     // and it also rounds up to alignment, which we want to avoid,\n                     // as the unsized field's alignment could be smaller.\n-                    assert!(!ty.is_simd());\n-                    debug!(\"DST {} layout: {:?}\", ty, layout);\n+                    assert!(!layout.ty.is_simd());\n+                    debug!(\"DST layout: {:?}\", layout);\n \n                     let sized_size = layout.fields.offset(layout.fields.count() - 1);\n                     let sized_align = layout.align;\n                     debug!(\n                         \"DST {} statically sized prefix size: {:?} align: {:?}\",\n-                        ty,\n+                        layout.ty,\n                         sized_size,\n                         sized_align\n                     );\n \n                     // Recurse to get the size of the dynamically sized field (must be\n                     // the last field).\n-                    let field_ty = layout.field(self, layout.fields.count() - 1)?.ty;\n-                    let (unsized_size, unsized_align) =\n-                        self.size_and_align_of_dst(field_ty, value)?;\n+                    let field = self.mplace_field(mplace, layout.fields.count() as u64 - 1)?;\n+                    let (unsized_size, unsized_align) = self.size_and_align_of_mplace(field)?;\n \n                     // FIXME (#26403, #27023): We should be adding padding\n                     // to `sized_size` (to accommodate the `unsized_align`\n@@ -526,18 +507,24 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     Ok((size.abi_align(align), align))\n                 }\n                 ty::TyDynamic(..) => {\n-                    let (_, vtable) = self.into_ptr_vtable_pair(value)?;\n+                    let vtable = match mplace.extra {\n+                        PlaceExtra::Vtable(vtable) => vtable,\n+                        _ => bug!(\"Expected vtable\"),\n+                    };\n                     // the second entry in the vtable is the dynamic size of the object.\n                     self.read_size_and_align_from_vtable(vtable)\n                 }\n \n                 ty::TySlice(_) | ty::TyStr => {\n+                    let len = match mplace.extra {\n+                        PlaceExtra::Length(len) => len,\n+                        _ => bug!(\"Expected length\"),\n+                    };\n                     let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n-                    let (_, len) = self.into_slice(value)?;\n                     Ok((elem_size * len, align))\n                 }\n \n-                _ => bug!(\"size_of_val::<{:?}>\", ty),\n+                _ => bug!(\"size_of_val::<{:?}> not supported\", layout.ty),\n             }\n         }\n     }\n@@ -568,10 +555,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n         // don't allocate at all for trivial constants\n         if mir.local_decls.len() > 1 {\n-            let mut locals = IndexVec::from_elem(LocalValue::Dead, &mir.local_decls);\n-            for (local, decl) in locals.iter_mut().zip(mir.local_decls.iter()) {\n-                *local = LocalValue::Live(self.init_value(decl.ty)?);\n-            }\n+            // We put some marker value into the locals that we later want to initialize.\n+            // This can be anything except for LocalValue::Dead -- because *that* is the\n+            // value we use for things that we know are initially dead.\n+            let dummy =\n+                LocalValue::Live(Operand::Immediate(Value::Scalar(ScalarMaybeUndef::Undef)));\n+            let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n+            // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n                 Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n@@ -582,18 +572,32 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             use rustc::mir::StatementKind::{StorageDead, StorageLive};\n                             match stmt.kind {\n                                 StorageLive(local) |\n-                                StorageDead(local) => locals[local] = LocalValue::Dead,\n+                                StorageDead(local) => {\n+                                    locals[local] = LocalValue::Dead;\n+                                }\n                                 _ => {}\n                             }\n                         }\n                     }\n                 },\n             }\n+            // Finally, properly initialize all those that still have the dummy value\n+            for (local, decl) in locals.iter_mut().zip(mir.local_decls.iter()) {\n+                match *local {\n+                    LocalValue::Live(_) => {\n+                        // This needs to be peoperly initialized.\n+                        let layout = self.layout_of(self.monomorphize(decl.ty, instance.substs))?;\n+                        *local = LocalValue::Live(self.uninit_operand(layout)?);\n+                    }\n+                    LocalValue::Dead => {\n+                        // Nothing to do\n+                    }\n+                }\n+            }\n+            // done\n             self.frame_mut().locals = locals;\n         }\n \n-        self.memory.cur_frame = self.cur_frame();\n-\n         if self.stack.len() > self.stack_limit {\n             err!(StackFrameLimitReached)\n         } else {\n@@ -607,16 +611,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n-        if !self.stack.is_empty() {\n-            // TODO: Is this the correct time to start considering these accesses as originating from the returned-to stack frame?\n-            self.memory.cur_frame = self.cur_frame();\n-        }\n         match frame.return_to_block {\n             StackPopCleanup::MarkStatic(mutable) => {\n-                if let Place::Ptr { ptr, .. } = frame.return_place {\n+                if let Place::Ptr(MemPlace { ptr, .. }) = frame.return_place {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n                     self.memory.mark_static_initialized(\n-                        ptr.unwrap_or_err()?.to_ptr()?.alloc_id,\n+                        ptr.to_ptr()?.alloc_id,\n                         mutable,\n                     )?\n                 } else {\n@@ -634,9 +634,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(())\n     }\n \n-    pub fn deallocate_local(&mut self, local: LocalValue) -> EvalResult<'tcx> {\n+    crate fn deallocate_local(&mut self, local: LocalValue) -> EvalResult<'tcx> {\n         // FIXME: should we tell the user that there was a local which was never written to?\n-        if let LocalValue::Live(Value::ByRef(ptr, _align)) = local {\n+        if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n@@ -645,419 +645,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(())\n     }\n \n-    /// Evaluate an assignment statement.\n-    ///\n-    /// There is no separate `eval_rvalue` function. Instead, the code for handling each rvalue\n-    /// type writes its results directly into the memory specified by the place.\n-    pub(super) fn eval_rvalue_into_place(\n-        &mut self,\n-        rvalue: &mir::Rvalue<'tcx>,\n-        place: &mir::Place<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        let dest = self.eval_place(place)?;\n-        let dest_ty = self.place_ty(place);\n-        let dest_layout = self.layout_of(dest_ty)?;\n-\n-        use rustc::mir::Rvalue::*;\n-        match *rvalue {\n-            Use(ref operand) => {\n-                let value = self.eval_operand(operand)?.value;\n-                let valty = ValTy {\n-                    value,\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)?;\n-            }\n-\n-            BinaryOp(bin_op, ref left, ref right) => {\n-                let left = self.eval_operand(left)?;\n-                let right = self.eval_operand(right)?;\n-                self.intrinsic_overflowing(\n-                    bin_op,\n-                    left,\n-                    right,\n-                    dest,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            CheckedBinaryOp(bin_op, ref left, ref right) => {\n-                let left = self.eval_operand(left)?;\n-                let right = self.eval_operand(right)?;\n-                self.intrinsic_with_overflow(\n-                    bin_op,\n-                    left,\n-                    right,\n-                    dest,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            UnaryOp(un_op, ref operand) => {\n-                let val = self.eval_operand_to_scalar(operand)?;\n-                let val = self.unary_op(un_op, val, dest_layout)?;\n-                self.write_scalar(\n-                    dest,\n-                    val,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            Aggregate(ref kind, ref operands) => {\n-                let (dest, active_field_index) = match **kind {\n-                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n-                        self.write_discriminant_value(dest_ty, dest, variant_index)?;\n-                        if adt_def.is_enum() {\n-                            (self.place_downcast(dest, variant_index)?, active_field_index)\n-                        } else {\n-                            (dest, active_field_index)\n-                        }\n-                    }\n-                    _ => (dest, None)\n-                };\n-\n-                let layout = self.layout_of(dest_ty)?;\n-                for (i, operand) in operands.iter().enumerate() {\n-                    let value = self.eval_operand(operand)?;\n-                    // Ignore zero-sized fields.\n-                    if !self.layout_of(value.ty)?.is_zst() {\n-                        let field_index = active_field_index.unwrap_or(i);\n-                        let (field_dest, _) = self.place_field(dest, mir::Field::new(field_index), layout)?;\n-                        self.write_value(value, field_dest)?;\n-                    }\n-                }\n-            }\n-\n-            Repeat(ref operand, _) => {\n-                let (elem_ty, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (elem_ty, n.unwrap_usize(self.tcx.tcx)),\n-                    _ => {\n-                        bug!(\n-                            \"tried to assign array-repeat to non-array type {:?}\",\n-                            dest_ty\n-                        )\n-                    }\n-                };\n-                let elem_size = self.layout_of(elem_ty)?.size;\n-                let value = self.eval_operand(operand)?.value;\n-\n-                let (dest, dest_align) = self.force_allocation(dest)?.to_ptr_align();\n-\n-                if length > 0 {\n-                    let dest = dest.unwrap_or_err()?;\n-                    //write the first value\n-                    self.write_value_to_ptr(value, dest, dest_align, elem_ty)?;\n-\n-                    if length > 1 {\n-                        let rest = dest.ptr_offset(elem_size * 1 as u64, &self)?;\n-                        self.memory.copy_repeatedly(dest, dest_align, rest, dest_align, elem_size, length - 1, false)?;\n-                    }\n-                }\n-            }\n-\n-            Len(ref place) => {\n-                // FIXME(CTFE): don't allow computing the length of arrays in const eval\n-                let src = self.eval_place(place)?;\n-                let ty = self.place_ty(place);\n-                let (_, len) = src.elem_ty_and_len(ty, self.tcx.tcx);\n-                let size = self.memory.pointer_size().bytes() as u8;\n-                self.write_scalar(\n-                    dest,\n-                    Scalar::Bits {\n-                        bits: len as u128,\n-                        size,\n-                    },\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            Ref(_, _, ref place) => {\n-                let src = self.eval_place(place)?;\n-                // We ignore the alignment of the place here -- special handling for packed structs ends\n-                // at the `&` operator.\n-                let (ptr, _align, extra) = self.force_allocation(src)?.to_ptr_align_extra();\n-\n-                let val = match extra {\n-                    PlaceExtra::None => Value::Scalar(ptr),\n-                    PlaceExtra::Length(len) => ptr.to_value_with_len(len, self.tcx.tcx),\n-                    PlaceExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n-                    PlaceExtra::DowncastVariant(..) => {\n-                        bug!(\"attempted to take a reference to an enum downcast place\")\n-                    }\n-                };\n-                let valty = ValTy {\n-                    value: val,\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)?;\n-            }\n-\n-            NullaryOp(mir::NullOp::Box, ty) => {\n-                let ty = self.monomorphize(ty, self.substs());\n-                M::box_alloc(self, ty, dest)?;\n-            }\n-\n-            NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let ty = self.monomorphize(ty, self.substs());\n-                let layout = self.layout_of(ty)?;\n-                assert!(!layout.is_unsized(),\n-                        \"SizeOf nullary MIR operator called for unsized type\");\n-                let size = self.memory.pointer_size().bytes() as u8;\n-                self.write_scalar(\n-                    dest,\n-                    Scalar::Bits {\n-                        bits: layout.size.bytes() as u128,\n-                        size,\n-                    },\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            Cast(kind, ref operand, cast_ty) => {\n-                debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest_ty);\n-                let src = self.eval_operand(operand)?;\n-                self.cast(src, kind, dest_ty, dest)?;\n-            }\n-\n-            Discriminant(ref place) => {\n-                let ty = self.place_ty(place);\n-                let layout = self.layout_of(ty)?;\n-                let place = self.eval_place(place)?;\n-                let discr_val = self.read_discriminant_value(place, layout)?;\n-                let size = self.layout_of(dest_ty).unwrap().size.bytes() as u8;\n-                self.write_scalar(dest, Scalar::Bits {\n-                    bits: discr_val,\n-                    size,\n-                }, dest_ty)?;\n-            }\n-        }\n-\n-        self.dump_local(dest);\n-\n-        Ok(())\n-    }\n-\n-    pub(super) fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.sty {\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::TyRef(_, ty, _) => !self.type_is_sized(ty),\n-            ty::TyAdt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n-            _ => false,\n-        }\n-    }\n-\n-    pub(super) fn eval_operand_to_scalar(\n-        &mut self,\n-        op: &mir::Operand<'tcx>,\n-    ) -> EvalResult<'tcx, Scalar> {\n-        let valty = self.eval_operand(op)?;\n-        self.value_to_scalar(valty)\n-    }\n-\n-    pub(crate) fn operands_to_args(\n-        &mut self,\n-        ops: &[mir::Operand<'tcx>],\n-    ) -> EvalResult<'tcx, Vec<ValTy<'tcx>>> {\n-        ops.into_iter()\n-            .map(|op| self.eval_operand(op))\n-            .collect()\n-    }\n-\n-    pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n-        use rustc::mir::Operand::*;\n-        let ty = self.monomorphize(op.ty(self.mir(), *self.tcx), self.substs());\n-        match *op {\n-            // FIXME: do some more logic on `move` to invalidate the old location\n-            Copy(ref place) |\n-            Move(ref place) => {\n-                Ok(ValTy {\n-                    value: self.eval_and_read_place(place)?,\n-                    ty\n-                })\n-            },\n-\n-            Constant(ref constant) => {\n-                let value = self.const_to_value(constant.literal.val)?;\n-\n-                Ok(ValTy {\n-                    value,\n-                    ty,\n-                })\n-            }\n-        }\n-    }\n-\n-    /// reads a tag and produces the corresponding variant index\n-    pub fn read_discriminant_as_variant_index(\n-        &self,\n-        place: Place,\n-        layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, usize> {\n-        match layout.variants {\n-            ty::layout::Variants::Single { index } => Ok(index),\n-            ty::layout::Variants::Tagged { .. } => {\n-                let discr_val = self.read_discriminant_value(place, layout)?;\n-                layout\n-                    .ty\n-                    .ty_adt_def()\n-                    .expect(\"tagged layout for non adt\")\n-                    .discriminants(self.tcx.tcx)\n-                    .position(|var| var.val == discr_val)\n-                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant.into())\n-            }\n-            ty::layout::Variants::NicheFilling { .. } => {\n-                let discr_val = self.read_discriminant_value(place, layout)?;\n-                assert_eq!(discr_val as usize as u128, discr_val);\n-                Ok(discr_val as usize)\n-            },\n-        }\n-    }\n-\n-    pub fn read_discriminant_value(\n-        &self,\n-        place: Place,\n-        layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, u128> {\n-        trace!(\"read_discriminant_value {:#?}\", layout);\n-        if layout.abi == layout::Abi::Uninhabited {\n-            return Ok(0);\n-        }\n-\n-        match layout.variants {\n-            layout::Variants::Single { index } => {\n-                let discr_val = layout.ty.ty_adt_def().map_or(\n-                    index as u128,\n-                    |def| def.discriminant_for_variant(*self.tcx, index).val);\n-                return Ok(discr_val);\n-            }\n-            layout::Variants::Tagged { .. } |\n-            layout::Variants::NicheFilling { .. } => {},\n-        }\n-        let discr_place_val = self.read_place(place)?;\n-        let (discr_val, discr) = self.read_field(discr_place_val, None, mir::Field::new(0), layout)?;\n-        trace!(\"discr value: {:?}, {:?}\", discr_val, discr);\n-        let raw_discr = self.value_to_scalar(ValTy {\n-            value: discr_val,\n-            ty: discr.ty\n-        })?;\n-        let discr_val = match layout.variants {\n-            layout::Variants::Single { .. } => bug!(),\n-            // FIXME: should we catch invalid discriminants here?\n-            layout::Variants::Tagged { .. } => {\n-                if discr.ty.is_signed() {\n-                    let i = raw_discr.to_bits(discr.size)? as i128;\n-                    // going from layout tag type to typeck discriminant type\n-                    // requires first sign extending with the layout discriminant\n-                    let shift = 128 - discr.size.bits();\n-                    let sexted = (i << shift) >> shift;\n-                    // and then zeroing with the typeck discriminant type\n-                    let discr_ty = layout\n-                        .ty\n-                        .ty_adt_def().expect(\"tagged layout corresponds to adt\")\n-                        .repr\n-                        .discr_type();\n-                    let discr_ty = layout::Integer::from_attr(self.tcx.tcx, discr_ty);\n-                    let shift = 128 - discr_ty.size().bits();\n-                    let truncatee = sexted as u128;\n-                    (truncatee << shift) >> shift\n-                } else {\n-                    raw_discr.to_bits(discr.size)?\n-                }\n-            },\n-            layout::Variants::NicheFilling {\n-                dataful_variant,\n-                ref niche_variants,\n-                niche_start,\n-                ..\n-            } => {\n-                let variants_start = *niche_variants.start() as u128;\n-                let variants_end = *niche_variants.end() as u128;\n-                match raw_discr {\n-                    Scalar::Ptr(_) => {\n-                        assert!(niche_start == 0);\n-                        assert!(variants_start == variants_end);\n-                        dataful_variant as u128\n-                    },\n-                    Scalar::Bits { bits: raw_discr, size } => {\n-                        assert_eq!(size as u64, discr.size.bytes());\n-                        let discr = raw_discr.wrapping_sub(niche_start)\n-                            .wrapping_add(variants_start);\n-                        if variants_start <= discr && discr <= variants_end {\n-                            discr\n-                        } else {\n-                            dataful_variant as u128\n-                        }\n-                    },\n-                }\n-            }\n-        };\n-\n-        Ok(discr_val)\n-    }\n-\n-\n-    pub fn write_discriminant_value(\n-        &mut self,\n-        dest_ty: Ty<'tcx>,\n-        dest: Place,\n-        variant_index: usize,\n-    ) -> EvalResult<'tcx> {\n-        let layout = self.layout_of(dest_ty)?;\n-\n-        match layout.variants {\n-            layout::Variants::Single { index } => {\n-                if index != variant_index {\n-                    // If the layout of an enum is `Single`, all\n-                    // other variants are necessarily uninhabited.\n-                    assert_eq!(layout.for_variant(&self, variant_index).abi,\n-                               layout::Abi::Uninhabited);\n-                }\n-            }\n-            layout::Variants::Tagged { ref tag, .. } => {\n-                let discr_val = dest_ty.ty_adt_def().unwrap()\n-                    .discriminant_for_variant(*self.tcx, variant_index)\n-                    .val;\n-\n-                // raw discriminants for enums are isize or bigger during\n-                // their computation, but the in-memory tag is the smallest possible\n-                // representation\n-                let size = tag.value.size(self.tcx.tcx);\n-                let shift = 128 - size.bits();\n-                let discr_val = (discr_val << shift) >> shift;\n-\n-                let (discr_dest, tag) = self.place_field(dest, mir::Field::new(0), layout)?;\n-                self.write_scalar(discr_dest, Scalar::Bits {\n-                    bits: discr_val,\n-                    size: size.bytes() as u8,\n-                }, tag.ty)?;\n-            }\n-            layout::Variants::NicheFilling {\n-                dataful_variant,\n-                ref niche_variants,\n-                niche_start,\n-                ..\n-            } => {\n-                if variant_index != dataful_variant {\n-                    let (niche_dest, niche) =\n-                        self.place_field(dest, mir::Field::new(0), layout)?;\n-                    let niche_value = ((variant_index - niche_variants.start()) as u128)\n-                        .wrapping_add(niche_start);\n-                    self.write_scalar(niche_dest, Scalar::Bits {\n-                        bits: niche_value,\n-                        size: niche.size.bytes() as u8,\n-                    }, niche.ty)?;\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    pub fn read_global_as_value(&mut self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Value> {\n-        let cv = self.const_eval(gid)?;\n-        self.const_to_value(cv.val)\n-    }\n-\n     pub fn const_eval(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n         let param_env = if self.tcx.is_static(gid.instance.def_id()).is_some() {\n             ty::ParamEnv::reveal_all()\n@@ -1067,492 +654,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.tcx.const_eval(param_env.and(gid)).map_err(|err| EvalErrorKind::ReferencedConstant(err).into())\n     }\n \n-    pub fn allocate_place_for_value(\n-        &mut self,\n-        value: Value,\n-        layout: TyLayout<'tcx>,\n-        variant: Option<usize>,\n-    ) -> EvalResult<'tcx, Place> {\n-        let (ptr, align) = match value {\n-            Value::ByRef(ptr, align) => (ptr, align),\n-            Value::ScalarPair(..) | Value::Scalar(_) => {\n-                let ptr = self.alloc_ptr(layout)?.into();\n-                self.write_value_to_ptr(value, ptr, layout.align, layout.ty)?;\n-                (ptr, layout.align)\n-            },\n-        };\n-        Ok(Place::Ptr {\n-            ptr: ptr.into(),\n-            align,\n-            extra: variant.map_or(PlaceExtra::None, PlaceExtra::DowncastVariant),\n-        })\n-    }\n-\n-    pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n-        let new_place = match place {\n-            Place::Local { frame, local } => {\n-                match self.stack[frame].locals[local].access()? {\n-                    Value::ByRef(ptr, align) => {\n-                        Place::Ptr {\n-                            ptr: ptr.into(),\n-                            align,\n-                            extra: PlaceExtra::None,\n-                        }\n-                    }\n-                    val => {\n-                        let ty = self.stack[frame].mir.local_decls[local].ty;\n-                        let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n-                        let layout = self.layout_of(ty)?;\n-                        let ptr = self.alloc_ptr(layout)?;\n-                        self.stack[frame].locals[local] =\n-                            LocalValue::Live(Value::ByRef(ptr.into(), layout.align)); // it stays live\n-\n-                        let place = Place::from_ptr(ptr, layout.align);\n-                        self.write_value(ValTy { value: val, ty }, place)?;\n-                        place\n-                    }\n-                }\n-            }\n-            Place::Ptr { .. } => place,\n-        };\n-        Ok(new_place)\n-    }\n-\n-    /// ensures this Value is not a ByRef\n-    pub fn follow_by_ref_value(\n-        &self,\n-        value: Value,\n-        ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Value> {\n-        match value {\n-            Value::ByRef(ptr, align) => {\n-                self.read_value(ptr, align, ty)\n-            }\n-            other => Ok(other),\n-        }\n-    }\n-\n-    pub fn value_to_scalar(\n-        &self,\n-        ValTy { value, ty } : ValTy<'tcx>,\n-    ) -> EvalResult<'tcx, Scalar> {\n-        match self.follow_by_ref_value(value, ty)? {\n-            Value::ByRef { .. } => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n-\n-            Value::Scalar(scalar) => scalar.unwrap_or_err(),\n-\n-            Value::ScalarPair(..) => bug!(\"value_to_scalar can't work with fat pointers\"),\n-        }\n-    }\n-\n-    pub fn write_ptr(&mut self, dest: Place, val: Scalar, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        let valty = ValTy {\n-            value: val.to_value(),\n-            ty: dest_ty,\n-        };\n-        self.write_value(valty, dest)\n-    }\n-\n-    pub fn write_scalar(\n-        &mut self,\n-        dest: Place,\n-        val: impl Into<ScalarMaybeUndef>,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        let valty = ValTy {\n-            value: Value::Scalar(val.into()),\n-            ty: dest_ty,\n-        };\n-        self.write_value(valty, dest)\n-    }\n-\n-    pub fn write_value(\n-        &mut self,\n-        ValTy { value: src_val, ty: dest_ty } : ValTy<'tcx>,\n-        dest: Place,\n-    ) -> EvalResult<'tcx> {\n-        //trace!(\"Writing {:?} to {:?} at type {:?}\", src_val, dest, dest_ty);\n-        // Note that it is really important that the type here is the right one, and matches the type things are read at.\n-        // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n-        // correct if we never look at this data with the wrong type.\n-\n-        match dest {\n-            Place::Ptr { ptr, align, extra } => {\n-                assert_eq!(extra, PlaceExtra::None);\n-                self.write_value_to_ptr(src_val, ptr.unwrap_or_err()?, align, dest_ty)\n-            }\n-\n-            Place::Local { frame, local } => {\n-                let old_val = self.stack[frame].locals[local].access()?;\n-                self.write_value_possibly_by_val(\n-                    src_val,\n-                    |this, val| this.stack[frame].set_local(local, val),\n-                    old_val,\n-                    dest_ty,\n-                )\n-            }\n-        }\n-    }\n-\n-    // The cases here can be a bit subtle. Read carefully!\n-    fn write_value_possibly_by_val<F: FnOnce(&mut Self, Value) -> EvalResult<'tcx>>(\n-        &mut self,\n-        src_val: Value,\n-        write_dest: F,\n-        old_dest_val: Value,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        // FIXME: this should be a layout check, not underlying value\n-        if let Value::ByRef(dest_ptr, align) = old_dest_val {\n-            // If the value is already `ByRef` (that is, backed by an `Allocation`),\n-            // then we must write the new value into this allocation, because there may be\n-            // other pointers into the allocation. These other pointers are logically\n-            // pointers into the local variable, and must be able to observe the change.\n-            //\n-            // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n-            // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_value_to_ptr(src_val, dest_ptr, align, dest_ty)?;\n-        } else if let Value::ByRef(src_ptr, align) = src_val {\n-            // If the value is not `ByRef`, then we know there are no pointers to it\n-            // and we can simply overwrite the `Value` in the locals array directly.\n-            //\n-            // In this specific case, where the source value is `ByRef`, we must duplicate\n-            // the allocation, because this is a by-value operation. It would be incorrect\n-            // if they referred to the same allocation, since then a change to one would\n-            // implicitly change the other.\n-            //\n-            // It is a valid optimization to attempt reading a primitive value out of the\n-            // source and write that into the destination without making an allocation, so\n-            // we do so here.\n-            if let Ok(Some(src_val)) = self.try_read_value(src_ptr, align, dest_ty) {\n-                write_dest(self, src_val)?;\n-            } else {\n-                let layout = self.layout_of(dest_ty)?;\n-                let dest_ptr = self.alloc_ptr(layout)?.into();\n-                self.memory.copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size, false)?;\n-                write_dest(self, Value::ByRef(dest_ptr, layout.align))?;\n-            }\n-        } else {\n-            // Finally, we have the simple case where neither source nor destination are\n-            // `ByRef`. We may simply copy the source value over the the destintion.\n-            write_dest(self, src_val)?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn write_value_to_ptr(\n-        &mut self,\n-        value: Value,\n-        dest: Scalar,\n-        dest_align: Align,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        let layout = self.layout_of(dest_ty)?;\n-        trace!(\"write_value_to_ptr: {:#?}, {}, {:#?}\", value, dest_ty, layout);\n-        match value {\n-            Value::ByRef(ptr, align) => {\n-                self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size, false)\n-            }\n-            Value::Scalar(scalar) => {\n-                let signed = match layout.abi {\n-                    layout::Abi::Scalar(ref scal) => match scal.value {\n-                        layout::Primitive::Int(_, signed) => signed,\n-                        _ => false,\n-                    },\n-                    _ => false,\n-                };\n-                self.memory.write_scalar(dest, dest_align, scalar, layout.size, layout.align, signed)\n-            }\n-            Value::ScalarPair(a_val, b_val) => {\n-                trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n-                let (a, b) = match layout.abi {\n-                    layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\"write_value_to_ptr: invalid ScalarPair layout: {:#?}\", layout)\n-                };\n-                let (a_size, b_size) = (a.size(&self), b.size(&self));\n-                let (a_align, b_align) = (a.align(&self), b.align(&self));\n-                let a_ptr = dest;\n-                let b_offset = a_size.abi_align(b_align);\n-                let b_ptr = dest.ptr_offset(b_offset, &self)?.into();\n-                // TODO: What about signedess?\n-                self.memory.write_scalar(a_ptr, dest_align, a_val, a_size, a_align, false)?;\n-                self.memory.write_scalar(b_ptr, dest_align, b_val, b_size, b_align, false)\n-            }\n-        }\n-    }\n-\n-    pub fn read_value(&self, ptr: Scalar, align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        if let Some(val) = self.try_read_value(ptr, align, ty)? {\n-            Ok(val)\n-        } else {\n-            bug!(\"primitive read failed for type: {:?}\", ty);\n-        }\n-    }\n-\n-    fn validate_scalar(\n-        &self,\n-        value: ScalarMaybeUndef,\n-        size: Size,\n-        scalar: &layout::Scalar,\n-        path: &str,\n-        ty: Ty,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n-        let (lo, hi) = scalar.valid_range.clone().into_inner();\n-\n-        let value = match value {\n-            ScalarMaybeUndef::Scalar(scalar) => scalar,\n-            ScalarMaybeUndef::Undef => return validation_failure!(\"undefined bytes\", path),\n-        };\n-\n-        let bits = match value {\n-            Scalar::Bits { bits, size: value_size } => {\n-                assert_eq!(value_size as u64, size.bytes());\n-                bits\n-            },\n-            Scalar::Ptr(_) => {\n-                let ptr_size = self.memory.pointer_size();\n-                let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n-                return if lo > hi {\n-                    if lo - hi == 1 {\n-                        // no gap, all values are ok\n-                        Ok(())\n-                    } else if hi < ptr_max || lo > 1 {\n-                        let max = u128::max_value() >> (128 - size.bits());\n-                        validation_failure!(\n-                            \"pointer\",\n-                            path,\n-                            format!(\"something in the range {:?} or {:?}\", 0..=lo, hi..=max)\n-                        )\n-                    } else {\n-                        Ok(())\n-                    }\n-                } else if hi < ptr_max || lo > 1 {\n-                    validation_failure!(\n-                        \"pointer\",\n-                        path,\n-                        format!(\"something in the range {:?}\", scalar.valid_range)\n-                    )\n-                } else {\n-                    Ok(())\n-                };\n-            },\n-        };\n-\n-        // char gets a special treatment, because its number space is not contiguous so `TyLayout`\n-        // has no special checks for chars\n-        match ty.sty {\n-            ty::TyChar => {\n-                debug_assert_eq!(size.bytes(), 4);\n-                if ::std::char::from_u32(bits as u32).is_none() {\n-                    return err!(InvalidChar(bits));\n-                }\n-            }\n-            _ => {},\n-        }\n-\n-        use std::ops::RangeInclusive;\n-        let in_range = |bound: RangeInclusive<u128>| bound.contains(&bits);\n-        if lo > hi {\n-            if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n-                Ok(())\n-            } else {\n-                validation_failure!(\n-                    bits,\n-                    path,\n-                    format!(\"something in the range {:?} or {:?}\", ..=hi, lo..)\n-                )\n-            }\n-        } else {\n-            if in_range(scalar.valid_range.clone()) {\n-                Ok(())\n-            } else {\n-                validation_failure!(\n-                    bits,\n-                    path,\n-                    format!(\"something in the range {:?}\", scalar.valid_range)\n-                )\n-            }\n-        }\n-    }\n-\n-    /// This function checks the memory where `ptr` points to.\n-    /// It will error if the bits at the destination do not match the ones described by the layout.\n-    pub fn validate_ptr_target(\n-        &self,\n-        ptr: Pointer,\n-        ptr_align: Align,\n-        mut layout: TyLayout<'tcx>,\n-        path: String,\n-        seen: &mut FxHashSet<(Pointer, Ty<'tcx>)>,\n-        todo: &mut Vec<(Pointer, Ty<'tcx>, String)>,\n-    ) -> EvalResult<'tcx> {\n-        self.memory.dump_alloc(ptr.alloc_id);\n-        trace!(\"validate_ptr_target: {:?}, {:#?}\", ptr, layout);\n-\n-        let variant;\n-        match layout.variants {\n-            layout::Variants::NicheFilling { niche: ref tag, .. } |\n-            layout::Variants::Tagged { ref tag, .. } => {\n-                let size = tag.value.size(self);\n-                let (tag_value, tag_layout) = self.read_field(\n-                    Value::ByRef(ptr.into(), ptr_align),\n-                    None,\n-                    mir::Field::new(0),\n-                    layout,\n-                )?;\n-                let tag_value = match self.follow_by_ref_value(tag_value, tag_layout.ty)? {\n-                    Value::Scalar(val) => val,\n-                    _ => bug!(\"tag must be scalar\"),\n-                };\n-                let path = format!(\"{}.TAG\", path);\n-                self.validate_scalar(tag_value, size, tag, &path, tag_layout.ty)?;\n-                let variant_index = self.read_discriminant_as_variant_index(\n-                    Place::from_ptr(ptr, ptr_align),\n-                    layout,\n-                )?;\n-                variant = variant_index;\n-                layout = layout.for_variant(self, variant_index);\n-                trace!(\"variant layout: {:#?}\", layout);\n-            },\n-            layout::Variants::Single { index } => variant = index,\n-        }\n-        match layout.fields {\n-            // primitives are unions with zero fields\n-            layout::FieldPlacement::Union(0) => {\n-                match layout.abi {\n-                    // nothing to do, whatever the pointer points to, it is never going to be read\n-                    layout::Abi::Uninhabited => validation_failure!(\"a value of an uninhabited type\", path),\n-                    // check that the scalar is a valid pointer or that its bit range matches the\n-                    // expectation.\n-                    layout::Abi::Scalar(ref scalar) => {\n-                        let size = scalar.value.size(self);\n-                        let value = self.memory.read_scalar(ptr, ptr_align, size)?;\n-                        self.validate_scalar(value, size, scalar, &path, layout.ty)?;\n-                        if scalar.value == Primitive::Pointer {\n-                            // ignore integer pointers, we can't reason about the final hardware\n-                            if let Scalar::Ptr(ptr) = value.unwrap_or_err()? {\n-                                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                                if let Some(AllocType::Static(did)) = alloc_kind {\n-                                    // statics from other crates are already checked\n-                                    // extern statics should not be validated as they have no body\n-                                    if !did.is_local() || self.tcx.is_foreign_item(did) {\n-                                        return Ok(());\n-                                    }\n-                                }\n-                                if let Some(tam) = layout.ty.builtin_deref(false) {\n-                                    // we have not encountered this pointer+layout combination before\n-                                    if seen.insert((ptr, tam.ty)) {\n-                                        todo.push((ptr, tam.ty, format!(\"(*{})\", path)))\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        Ok(())\n-                    },\n-                    _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", layout.abi),\n-                }\n-            }\n-            layout::FieldPlacement::Union(_) => {\n-                // We can't check unions, their bits are allowed to be anything.\n-                // The fields don't need to correspond to any bit pattern of the union's fields.\n-                // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n-                Ok(())\n-            },\n-            layout::FieldPlacement::Array { stride, count } => {\n-                let elem_layout = layout.field(self, 0)?;\n-                for i in 0..count {\n-                    let mut path = path.clone();\n-                    self.write_field_name(&mut path, layout.ty, i as usize, variant).unwrap();\n-                    self.validate_ptr_target(ptr.offset(stride * i, self)?, ptr_align, elem_layout, path, seen, todo)?;\n-                }\n-                Ok(())\n-            },\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-\n-                // check length field and vtable field\n-                match layout.ty.builtin_deref(false).map(|tam| &tam.ty.sty) {\n-                    | Some(ty::TyStr)\n-                    | Some(ty::TySlice(_)) => {\n-                        let (len, len_layout) = self.read_field(\n-                            Value::ByRef(ptr.into(), ptr_align),\n-                            None,\n-                            mir::Field::new(1),\n-                            layout,\n-                        )?;\n-                        let len = self.value_to_scalar(ValTy { value: len, ty: len_layout.ty })?;\n-                        if len.to_bits(len_layout.size).is_err() {\n-                            return validation_failure!(\"length is not a valid integer\", path);\n-                        }\n-                    },\n-                    Some(ty::TyDynamic(..)) => {\n-                        let (vtable, vtable_layout) = self.read_field(\n-                            Value::ByRef(ptr.into(), ptr_align),\n-                            None,\n-                            mir::Field::new(1),\n-                            layout,\n-                        )?;\n-                        let vtable = self.value_to_scalar(ValTy { value: vtable, ty: vtable_layout.ty })?;\n-                        if vtable.to_ptr().is_err() {\n-                            return validation_failure!(\"vtable address is not a pointer\", path);\n-                        }\n-                    }\n-                    _ => {},\n-                }\n-                for (i, &offset) in offsets.iter().enumerate() {\n-                    let field_layout = layout.field(self, i)?;\n-                    let mut path = path.clone();\n-                    self.write_field_name(&mut path, layout.ty, i, variant).unwrap();\n-                    self.validate_ptr_target(ptr.offset(offset, self)?, ptr_align, field_layout, path, seen, todo)?;\n-                }\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    pub fn try_read_by_ref(&self, mut val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        // Convert to ByVal or ScalarPair if possible\n-        if let Value::ByRef(ptr, align) = val {\n-            if let Some(read_val) = self.try_read_value(ptr, align, ty)? {\n-                val = read_val;\n-            }\n-        }\n-        Ok(val)\n-    }\n-\n-    pub fn try_read_value(&self, ptr: Scalar, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n-        let layout = self.layout_of(ty)?;\n-        self.memory.check_align(ptr, ptr_align)?;\n-\n-        if layout.size.bytes() == 0 {\n-            return Ok(Some(Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits: 0, size: 0 }))));\n-        }\n-\n-        let ptr = ptr.to_ptr()?;\n-\n-        match layout.abi {\n-            layout::Abi::Scalar(..) => {\n-                let scalar = self.memory.read_scalar(ptr, ptr_align, layout.size)?;\n-                Ok(Some(Value::Scalar(scalar)))\n-            }\n-            layout::Abi::ScalarPair(ref a, ref b) => {\n-                let (a, b) = (&a.value, &b.value);\n-                let (a_size, b_size) = (a.size(self), b.size(self));\n-                let a_ptr = ptr;\n-                let b_offset = a_size.abi_align(b.align(self));\n-                let b_ptr = ptr.offset(b_offset, self)?.into();\n-                let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n-                let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n-                Ok(Some(Value::ScalarPair(a_val, b_val)))\n-            }\n-            _ => Ok(None),\n-        }\n-    }\n-\n+    #[inline(always)]\n     pub fn frame(&self) -> &Frame<'mir, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n+    #[inline(always)]\n     pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n@@ -1569,132 +676,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    fn unsize_into_ptr(\n-        &mut self,\n-        src: Value,\n-        src_ty: Ty<'tcx>,\n-        dest: Place,\n-        dest_ty: Ty<'tcx>,\n-        sty: Ty<'tcx>,\n-        dty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        // A<Struct> -> A<Trait> conversion\n-        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n-\n-        match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n-            (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                let ptr = self.into_ptr(src)?;\n-                // u64 cast is from usize to u64, which is always good\n-                let valty = ValTy {\n-                    value: ptr.to_value_with_len(length.unwrap_usize(self.tcx.tcx), self.tcx.tcx),\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)\n-            }\n-            (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n-                // For now, upcasts are limited to changes in marker\n-                // traits, and hence never actually require an actual\n-                // change to the vtable.\n-                let valty = ValTy {\n-                    value: src,\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)\n-            }\n-            (_, &ty::TyDynamic(ref data, _)) => {\n-                let trait_ref = data.principal().unwrap().with_self_ty(\n-                    *self.tcx,\n-                    src_pointee_ty,\n-                );\n-                let trait_ref = self.tcx.erase_regions(&trait_ref);\n-                let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n-                let ptr = self.into_ptr(src)?;\n-                let valty = ValTy {\n-                    value: ptr.to_value_with_vtable(vtable),\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)\n-            }\n-\n-            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n-        }\n-    }\n-\n-    crate fn unsize_into(\n-        &mut self,\n-        src: Value,\n-        src_layout: TyLayout<'tcx>,\n-        dst: Place,\n-        dst_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        match (&src_layout.ty.sty, &dst_layout.ty.sty) {\n-            (&ty::TyRef(_, s, _), &ty::TyRef(_, d, _)) |\n-            (&ty::TyRef(_, s, _), &ty::TyRawPtr(TypeAndMut { ty: d, .. })) |\n-            (&ty::TyRawPtr(TypeAndMut { ty: s, .. }),\n-             &ty::TyRawPtr(TypeAndMut { ty: d, .. })) => {\n-                self.unsize_into_ptr(src, src_layout.ty, dst, dst_layout.ty, s, d)\n-            }\n-            (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n-                assert_eq!(def_a, def_b);\n-                if def_a.is_box() || def_b.is_box() {\n-                    if !def_a.is_box() || !def_b.is_box() {\n-                        bug!(\"invalid unsizing between {:?} -> {:?}\", src_layout, dst_layout);\n-                    }\n-                    return self.unsize_into_ptr(\n-                        src,\n-                        src_layout.ty,\n-                        dst,\n-                        dst_layout.ty,\n-                        src_layout.ty.boxed_ty(),\n-                        dst_layout.ty.boxed_ty(),\n-                    );\n-                }\n-\n-                // unsizing of generic struct with pointer fields\n-                // Example: `Arc<T>` -> `Arc<Trait>`\n-                // here we need to increase the size of every &T thin ptr field to a fat ptr\n-                for i in 0..src_layout.fields.count() {\n-                    let (dst_f_place, dst_field) =\n-                        self.place_field(dst, mir::Field::new(i), dst_layout)?;\n-                    if dst_field.is_zst() {\n-                        continue;\n-                    }\n-                    let (src_f_value, src_field) = match src {\n-                        Value::ByRef(ptr, align) => {\n-                            let src_place = Place::from_scalar_ptr(ptr.into(), align);\n-                            let (src_f_place, src_field) =\n-                                self.place_field(src_place, mir::Field::new(i), src_layout)?;\n-                            (self.read_place(src_f_place)?, src_field)\n-                        }\n-                        Value::Scalar(_) | Value::ScalarPair(..) => {\n-                            let src_field = src_layout.field(&self, i)?;\n-                            assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n-                            assert_eq!(src_field.size, src_layout.size);\n-                            (src, src_field)\n-                        }\n-                    };\n-                    if src_field.ty == dst_field.ty {\n-                        self.write_value(ValTy {\n-                            value: src_f_value,\n-                            ty: src_field.ty,\n-                        }, dst_f_place)?;\n-                    } else {\n-                        self.unsize_into(src_f_value, src_field, dst_f_place, dst_field)?;\n-                    }\n-                }\n-                Ok(())\n-            }\n-            _ => {\n-                bug!(\n-                    \"unsize_into: invalid conversion: {:?} -> {:?}\",\n-                    src_layout,\n-                    dst_layout\n-                )\n-            }\n-        }\n-    }\n-\n-    pub fn dump_local(&self, place: Place) {\n+    pub fn dump_place(&self, place: Place) {\n         // Debug output\n         if !log_enabled!(::log::Level::Trace) {\n             return;\n@@ -1716,22 +698,23 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             panic!(\"Failed to access local: {:?}\", err);\n                         }\n                     }\n-                    Ok(Value::ByRef(ptr, align)) => {\n+                    Ok(Operand::Indirect(mplace)) => {\n+                        let (ptr, align) = mplace.to_scalar_ptr_align();\n                         match ptr {\n                             Scalar::Ptr(ptr) => {\n                                 write!(msg, \" by align({}) ref:\", align.abi()).unwrap();\n                                 allocs.push(ptr.alloc_id);\n                             }\n-                            ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n+                            ptr => write!(msg, \" by integral ref: {:?}\", ptr).unwrap(),\n                         }\n                     }\n-                    Ok(Value::Scalar(val)) => {\n+                    Ok(Operand::Immediate(Value::Scalar(val))) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n                         if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n-                    Ok(Value::ScalarPair(val1, val2)) => {\n+                    Ok(Operand::Immediate(Value::ScalarPair(val1, val2))) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n                         if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val1 {\n                             allocs.push(ptr.alloc_id);\n@@ -1745,10 +728,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 trace!(\"{}\", msg);\n                 self.memory.dump_allocs(allocs);\n             }\n-            Place::Ptr { ptr, align, .. } => {\n-                match ptr {\n-                    ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n-                        trace!(\"by align({}) ref:\", align.abi());\n+            Place::Ptr(mplace) => {\n+                match mplace.ptr {\n+                    Scalar::Ptr(ptr) => {\n+                        trace!(\"by align({}) ref:\", mplace.align.abi());\n                         self.memory.dump_alloc(ptr.alloc_id);\n                     }\n                     ptr => trace!(\" integral by ref: {:?}\", ptr),\n@@ -1795,119 +778,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         (frames, self.tcx.span)\n     }\n \n+    #[inline(always)]\n     pub fn sign_extend(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n-        super::sign_extend(value, ty)\n+        assert!(ty.abi.is_signed());\n+        sign_extend(value, ty.size)\n     }\n \n+    #[inline(always)]\n     pub fn truncate(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n-        super::truncate(value, ty)\n-    }\n-\n-    fn write_field_name(&self, s: &mut String, ty: Ty<'tcx>, i: usize, variant: usize) -> ::std::fmt::Result {\n-        match ty.sty {\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyInt(_) |\n-            ty::TyUint(_) |\n-            ty::TyFloat(_) |\n-            ty::TyFnPtr(_) |\n-            ty::TyNever |\n-            ty::TyFnDef(..) |\n-            ty::TyGeneratorWitness(..) |\n-            ty::TyForeign(..) |\n-            ty::TyDynamic(..) => {\n-                bug!(\"field_name({:?}): not applicable\", ty)\n-            }\n-\n-            // Potentially-fat pointers.\n-            ty::TyRef(_, pointee, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                assert!(i < 2);\n-\n-                // Reuse the fat *T type as its own thin pointer data field.\n-                // This provides information about e.g. DST struct pointees\n-                // (which may have no non-DST form), and will work as long\n-                // as the `Abi` or `FieldPlacement` is checked by users.\n-                if i == 0 {\n-                    return write!(s, \".data_ptr\");\n-                }\n-\n-                match self.tcx.struct_tail(pointee).sty {\n-                    ty::TySlice(_) |\n-                    ty::TyStr => write!(s, \".len\"),\n-                    ty::TyDynamic(..) => write!(s, \".vtable_ptr\"),\n-                    _ => bug!(\"field_name({:?}): not applicable\", ty)\n-                }\n-            }\n-\n-            // Arrays and slices.\n-            ty::TyArray(_, _) |\n-            ty::TySlice(_) |\n-            ty::TyStr => write!(s, \"[{}]\", i),\n-\n-            // generators and closures.\n-            ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n-                let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar = self.tcx.with_freevars(node_id, |fv| fv[i]);\n-                write!(s, \".upvar({})\", self.tcx.hir.name(freevar.var_id()))\n-            }\n-\n-            ty::TyTuple(_) => write!(s, \".{}\", i),\n-\n-            // enums\n-            ty::TyAdt(def, ..) if def.is_enum() => {\n-                let variant = &def.variants[variant];\n-                write!(s, \".{}::{}\", variant.name, variant.fields[i].ident)\n-            }\n-\n-            // other ADTs.\n-            ty::TyAdt(def, _) => write!(s, \".{}\", def.non_enum_variant().fields[i].ident),\n-\n-            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n-            ty::TyInfer(_) | ty::TyError => {\n-                bug!(\"write_field_name: unexpected type `{}`\", ty)\n-            }\n-        }\n-    }\n-\n-    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, LocalValue> {\n-        trace!(\"{:?} is now live\", local);\n-\n-        let ty = self.frame().mir.local_decls[local].ty;\n-        let init = self.init_value(ty)?;\n-        // StorageLive *always* kills the value that's currently stored\n-        Ok(mem::replace(&mut self.frame_mut().locals[local], LocalValue::Live(init)))\n-    }\n-\n-    fn init_value(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        let ty = self.monomorphize(ty, self.substs());\n-        let layout = self.layout_of(ty)?;\n-        Ok(match layout.abi {\n-            layout::Abi::Scalar(..) => Value::Scalar(ScalarMaybeUndef::Undef),\n-            layout::Abi::ScalarPair(..) => Value::ScalarPair(\n-                ScalarMaybeUndef::Undef,\n-                ScalarMaybeUndef::Undef,\n-            ),\n-            _ => Value::ByRef(self.alloc_ptr(layout)?.into(), layout.align),\n-        })\n+        truncate(value, ty.size)\n     }\n }\n \n-impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n-    fn set_local(&mut self, local: mir::Local, value: Value) -> EvalResult<'tcx> {\n-        match self.locals[local] {\n-            LocalValue::Dead => err!(DeadLocal),\n-            LocalValue::Live(ref mut local) => {\n-                *local = value;\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    /// Returns the old value of the local\n-    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue {\n-        trace!(\"{:?} is now dead\", local);\n-\n-        mem::replace(&mut self.locals[local], LocalValue::Dead)\n-    }\n-}"}, {"sha": "84556c7249dbde9f6f2ea5795f63a706426037df", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -5,10 +5,10 @@\n use std::hash::Hash;\n \n use rustc::mir::interpret::{AllocId, EvalResult, Scalar, Pointer, AccessKind, GlobalId};\n-use super::{EvalContext, Place, ValTy, Memory};\n+use super::{EvalContext, PlaceTy, OpTy, Memory};\n \n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, layout::TyLayout};\n use rustc::ty::layout::Size;\n use syntax::source_map::Span;\n use syntax::ast::Mutability;\n@@ -31,19 +31,17 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Place, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n+        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        args: &[OpTy<'tcx>],\n         span: Span,\n-        sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool>;\n \n     /// directly process an intrinsic without pushing a stack frame.\n     fn call_intrinsic<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[ValTy<'tcx>],\n-        dest: Place,\n-        dest_layout: ty::layout::TyLayout<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: PlaceTy<'tcx>,\n         target: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n \n@@ -57,9 +55,9 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: Scalar,\n-        left_ty: Ty<'tcx>,\n+        left_layout: TyLayout<'tcx>,\n         right: Scalar,\n-        right_ty: Ty<'tcx>,\n+        right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n \n     /// Called when trying to mark machine defined `MemoryKinds` as static\n@@ -81,8 +79,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n     /// Returns a pointer to the allocated memory\n     fn box_alloc<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        ty: Ty<'tcx>,\n-        dest: Place,\n+        dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx>;\n \n     /// Called when trying to access a global declared with a `linkage` attribute"}, {"sha": "89c308d87ef28a5c3062fbb4d0915a882cface59", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 40, "deletions": 99, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1,3 +1,11 @@\n+//! The memory subsystem.\n+//!\n+//! Generally, we use `Pointer` to denote memory addresses. However, some operations\n+//! have a \"size\"-like parameter, and they take `Scalar` for the address because\n+//! if the size is 0, then the pointer can also be a (properly aligned, non-NULL)\n+//! integer.  It is crucial that these operations call `check_align` *before*\n+//! short-circuiting the empty case!\n+\n use std::collections::VecDeque;\n use std::hash::{Hash, Hasher};\n use std::ptr;\n@@ -7,15 +15,16 @@ use rustc::ty::Instance;\n use rustc::ty::ParamEnv;\n use rustc::ty::query::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n-use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, Value, ScalarMaybeUndef,\n-                            EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n-pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n+use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, ScalarMaybeUndef,\n+                            EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType, truncate};\n+pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n \n use syntax::ast::Mutability;\n \n use super::{EvalContext, Machine};\n \n+\n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n@@ -43,9 +52,6 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n     alloc_map: FxHashMap<AllocId, Allocation>,\n \n-    /// The current stack frame.  Used to check accesses against locks.\n-    pub cur_frame: usize,\n-\n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n@@ -63,14 +69,12 @@ impl<'a, 'mir, 'tcx, M> PartialEq for Memory<'a, 'mir, 'tcx, M>\n             data,\n             alloc_kind,\n             alloc_map,\n-            cur_frame,\n             tcx: _,\n         } = self;\n \n         *data == other.data\n             && *alloc_kind == other.alloc_kind\n             && *alloc_map == other.alloc_map\n-            && *cur_frame == other.cur_frame\n     }\n }\n \n@@ -83,12 +87,10 @@ impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n             data,\n             alloc_kind: _,\n             alloc_map: _,\n-            cur_frame,\n             tcx: _,\n         } = self;\n \n         data.hash(state);\n-        cur_frame.hash(state);\n \n         // We ignore some fields which don't change between evaluation steps.\n \n@@ -114,7 +116,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             alloc_kind: FxHashMap::default(),\n             alloc_map: FxHashMap::default(),\n             tcx,\n-            cur_frame: usize::max_value(),\n         }\n     }\n \n@@ -264,7 +265,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.tcx.data_layout.endian\n     }\n \n-    /// Check that the pointer is aligned AND non-NULL.\n+    /// Check that the pointer is aligned AND non-NULL. This supports scalars\n+    /// for the benefit of other parts of miri that need to check alignment even for ZST.\n     pub fn check_align(&self, ptr: Scalar, required_align: Align) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr {\n@@ -301,6 +303,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n+    /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n+    /// in-bounds!  This follows C's/LLVM's rules.\n     pub fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n@@ -331,7 +336,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             assert!(self.tcx.is_static(def_id).is_some());\n             EvalErrorKind::ReferencedConstant(err).into()\n         }).map(|val| {\n-            self.tcx.const_value_to_allocation(val)\n+            self.tcx.const_to_allocation(val)\n         })\n     }\n \n@@ -499,6 +504,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Byte accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+    /// This checks alignment!\n     fn get_bytes_unchecked(\n         &self,\n         ptr: Pointer,\n@@ -519,6 +525,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(&alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n \n+    /// This checks alignment!\n     fn get_bytes_unchecked_mut(\n         &mut self,\n         ptr: Pointer,\n@@ -556,7 +563,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size.bytes(), 0);\n         self.clear_relocations(ptr, size)?;\n-        self.mark_definedness(ptr.into(), size, true)?;\n+        self.mark_definedness(ptr, size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size, align)\n     }\n }\n@@ -635,10 +642,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         length: u64,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n-        // Empty accesses don't need to be valid pointers, but they should still be aligned\n-        self.check_align(src, src_align)?;\n-        self.check_align(dest, dest_align)?;\n         if size.bytes() == 0 {\n+            // Nothing to do for ZST, other than checking alignment and non-NULLness.\n+            self.check_align(src, src_align)?;\n+            self.check_align(dest, dest_align)?;\n             return Ok(());\n         }\n         let src = src.to_ptr()?;\n@@ -664,6 +671,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             new_relocations\n         };\n \n+        // This also checks alignment.\n         let src_bytes = self.get_bytes_unchecked(src, size, src_align)?.as_ptr();\n         let dest_bytes = self.get_bytes_mut(dest, size * length, dest_align)?.as_mut_ptr();\n \n@@ -721,8 +729,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn read_bytes(&self, ptr: Scalar, size: Size) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n-        self.check_align(ptr, align)?;\n         if size.bytes() == 0 {\n+            self.check_align(ptr, align)?;\n             return Ok(&[]);\n         }\n         self.get_bytes(ptr.to_ptr()?, size, align)\n@@ -731,8 +739,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn write_bytes(&mut self, ptr: Scalar, src: &[u8]) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n-        self.check_align(ptr, align)?;\n         if src.is_empty() {\n+            self.check_align(ptr, align)?;\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, Size::from_bytes(src.len() as u64), align)?;\n@@ -743,8 +751,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn write_repeat(&mut self, ptr: Scalar, val: u8, count: Size) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n-        self.check_align(ptr, align)?;\n         if count.bytes() == 0 {\n+            self.check_align(ptr, align)?;\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, align)?;\n@@ -754,9 +762,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n+    /// Read a *non-ZST* scalar\n     pub fn read_scalar(&self, ptr: Pointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, ScalarMaybeUndef> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianness = self.endianness();\n+        // get_bytes_unchecked tests alignment\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n@@ -789,17 +799,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.read_scalar(ptr, ptr_align, self.pointer_size())\n     }\n \n+    /// Write a *non-ZST* scalar\n     pub fn write_scalar(\n         &mut self,\n-        ptr: Scalar,\n+        ptr: Pointer,\n         ptr_align: Align,\n         val: ScalarMaybeUndef,\n         type_size: Size,\n-        type_align: Align,\n-        signed: bool,\n     ) -> EvalResult<'tcx> {\n         let endianness = self.endianness();\n-        self.check_align(ptr, ptr_align)?;\n \n         let val = match val {\n             ScalarMaybeUndef::Scalar(scalar) => scalar,\n@@ -812,27 +820,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 val.offset.bytes() as u128\n             }\n \n-            Scalar::Bits { size: 0, .. } => {\n-                // nothing to do for ZSTs\n-                assert_eq!(type_size.bytes(), 0);\n-                return Ok(());\n-            }\n-\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, type_size.bytes());\n+                assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                    \"Unexpected value of size {} when writing to memory\", size);\n                 bits\n             },\n         };\n \n-        let ptr = ptr.to_ptr()?;\n-\n         {\n-            let dst = self.get_bytes_mut(ptr, type_size, ptr_align.min(type_align))?;\n-            if signed {\n-                write_target_int(endianness, dst, bytes as i128).unwrap();\n-            } else {\n-                write_target_uint(endianness, dst, bytes).unwrap();\n-            }\n+            // get_bytes_mut checks alignment\n+            let dst = self.get_bytes_mut(ptr, type_size, ptr_align)?;\n+            write_target_uint(endianness, dst, bytes).unwrap();\n         }\n \n         // See if we have to also write a relocation\n@@ -849,9 +848,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized_unsigned(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n-        self.write_scalar(ptr.into(), ptr_align, val, ptr_size, ptr_align, false)\n+        self.write_scalar(ptr.into(), ptr_align, val, ptr_size)\n     }\n \n     fn int_align(&self, size: Size) -> Align {\n@@ -967,14 +966,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: Scalar,\n+        ptr: Pointer,\n         size: Size,\n         new_state: bool,\n     ) -> EvalResult<'tcx> {\n         if size.bytes() == 0 {\n             return Ok(());\n         }\n-        let ptr = ptr.to_ptr()?;\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         alloc.undef_mask.set_range(\n             ptr.offset,\n@@ -992,63 +990,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M>;\n     fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M>;\n-\n-    /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n-    /// this may have to perform a load.\n-    fn into_ptr(\n-        &self,\n-        value: Value,\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef> {\n-        Ok(match value {\n-            Value::ByRef(ptr, align) => {\n-                self.memory().read_ptr_sized(ptr.to_ptr()?, align)?\n-            }\n-            Value::Scalar(ptr) |\n-            Value::ScalarPair(ptr, _) => ptr,\n-        }.into())\n-    }\n-\n-    fn into_ptr_vtable_pair(\n-        &self,\n-        value: Value,\n-    ) -> EvalResult<'tcx, (ScalarMaybeUndef, Pointer)> {\n-        match value {\n-            Value::ByRef(ref_ptr, align) => {\n-                let mem = self.memory();\n-                let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n-                let vtable = mem.read_ptr_sized(\n-                    ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    align\n-                )?.unwrap_or_err()?.to_ptr()?;\n-                Ok((ptr, vtable))\n-            }\n-\n-            Value::ScalarPair(ptr, vtable) => Ok((ptr, vtable.unwrap_or_err()?.to_ptr()?)),\n-            _ => bug!(\"expected ptr and vtable, got {:?}\", value),\n-        }\n-    }\n-\n-    fn into_slice(\n-        &self,\n-        value: Value,\n-    ) -> EvalResult<'tcx, (ScalarMaybeUndef, u64)> {\n-        match value {\n-            Value::ByRef(ref_ptr, align) => {\n-                let mem = self.memory();\n-                let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n-                let len = mem.read_ptr_sized(\n-                    ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    align\n-                )?.unwrap_or_err()?.to_bits(mem.pointer_size())? as u64;\n-                Ok((ptr, len))\n-            }\n-            Value::ScalarPair(ptr, val) => {\n-                let len = val.unwrap_or_err()?.to_bits(self.memory().pointer_size())?;\n-                Ok((ptr, len as u64))\n-            }\n-            Value::Scalar(_) => bug!(\"expected ptr and length, got {:?}\", value),\n-        }\n-    }\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Memory<'a, 'mir, 'tcx, M> {"}, {"sha": "b769dae0a7abc2c8b73af5d22f6c502feab10544", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1,22 +1,23 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n mod cast;\n-mod const_eval;\n mod eval_context;\n mod place;\n+mod operand;\n mod machine;\n mod memory;\n mod operator;\n mod step;\n mod terminator;\n mod traits;\n+mod const_eval;\n+mod validity;\n \n pub use self::eval_context::{\n-    EvalContext, Frame, StackPopCleanup,\n-    TyAndPacked, ValTy,\n+    EvalContext, Frame, StackPopCleanup, LocalValue,\n };\n \n-pub use self::place::{Place, PlaceExtra};\n+pub use self::place::{Place, PlaceExtra, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind, HasMemory};\n \n@@ -25,32 +26,13 @@ pub use self::const_eval::{\n     mk_borrowck_eval_cx,\n     mk_eval_cx,\n     CompileTimeEvaluator,\n-    const_value_to_allocation_provider,\n+    const_to_allocation_provider,\n     const_eval_provider,\n-    const_val_field,\n+    const_field,\n     const_variant_index,\n-    value_to_const_value,\n+    op_to_const,\n };\n \n pub use self::machine::Machine;\n \n-pub use self::memory::{write_target_uint, write_target_int, read_target_uint};\n-\n-use rustc::ty::layout::TyLayout;\n-\n-pub fn sign_extend(value: u128, layout: TyLayout<'_>) -> u128 {\n-    let size = layout.size.bits();\n-    assert!(layout.abi.is_signed());\n-    // sign extend\n-    let shift = 128 - size;\n-    // shift the unsigned value to the left\n-    // and back to the right as signed (essentially fills with FF on the left)\n-    (((value << shift) as i128) >> shift) as u128\n-}\n-\n-pub fn truncate(value: u128, layout: TyLayout<'_>) -> u128 {\n-    let size = layout.size.bits();\n-    let shift = 128 - size;\n-    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n-    (value << shift) >> shift\n-}\n+pub use self::operand::{Value, ValTy, Operand, OpTy};"}, {"sha": "df3dc44b2298465344eaaacb9b3556232ccbfe5b", "filename": "src/librustc_mir/interpret/operand.rs", "status": "added", "additions": 614, "deletions": 0, "changes": 614, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -0,0 +1,614 @@\n+//! Functions concerning immediate values and operands, and reading from operands.\n+//! All high-level functions to read from memory work on operands as sources.\n+\n+use std::convert::TryInto;\n+\n+use rustc::mir;\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use rustc::mir::interpret::{\n+    GlobalId, ConstValue, Scalar, EvalResult, Pointer, ScalarMaybeUndef, EvalErrorKind\n+};\n+use super::{EvalContext, Machine, MemPlace, MPlaceTy, PlaceExtra, MemoryKind};\n+\n+/// A `Value` represents a single immediate self-contained Rust value.\n+///\n+/// For optimization of a few very common cases, there is also a representation for a pair of\n+/// primitive values (`ScalarPair`). It allows Miri to avoid making allocations for checked binary\n+/// operations and fat pointers. This idea was taken from rustc's codegen.\n+/// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n+/// defined on `Value`, and do not have to work with a `Place`.\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Value {\n+    Scalar(ScalarMaybeUndef),\n+    ScalarPair(ScalarMaybeUndef, ScalarMaybeUndef),\n+}\n+\n+impl<'tcx> Value {\n+    pub fn new_slice(\n+        val: Scalar,\n+        len: u64,\n+        cx: impl HasDataLayout\n+    ) -> Self {\n+        Value::ScalarPair(val.into(), Scalar::Bits {\n+            bits: len as u128,\n+            size: cx.data_layout().pointer_size.bytes() as u8,\n+        }.into())\n+    }\n+\n+    pub fn new_dyn_trait(val: Scalar, vtable: Pointer) -> Self {\n+        Value::ScalarPair(val.into(), Scalar::Ptr(vtable).into())\n+    }\n+\n+    #[inline]\n+    pub fn to_scalar_or_undef(self) -> ScalarMaybeUndef {\n+        match self {\n+            Value::Scalar(val) => val,\n+            Value::ScalarPair(..) => bug!(\"Got a fat pointer where a scalar was expected\"),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_scalar(self) -> EvalResult<'tcx, Scalar> {\n+        self.to_scalar_or_undef().not_undef()\n+    }\n+\n+    /// Convert the value into a pointer (or a pointer-sized integer).\n+    /// Throws away the second half of a ScalarPair!\n+    #[inline]\n+    pub fn to_scalar_ptr(self) -> EvalResult<'tcx, Scalar> {\n+        match self {\n+            Value::Scalar(ptr) |\n+            Value::ScalarPair(ptr, _) => ptr.not_undef(),\n+        }\n+    }\n+\n+    pub fn to_scalar_dyn_trait(self) -> EvalResult<'tcx, (Scalar, Pointer)> {\n+        match self {\n+            Value::ScalarPair(ptr, vtable) =>\n+                Ok((ptr.not_undef()?, vtable.to_ptr()?)),\n+            _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n+        }\n+    }\n+\n+    pub fn to_scalar_slice(self, cx: impl HasDataLayout) -> EvalResult<'tcx, (Scalar, u64)> {\n+        match self {\n+            Value::ScalarPair(ptr, val) => {\n+                let len = val.to_bits(cx.data_layout().pointer_size)?;\n+                Ok((ptr.not_undef()?, len as u64))\n+            }\n+            _ => bug!(\"expected ptr and length, got {:?}\", self),\n+        }\n+    }\n+}\n+\n+// ScalarPair needs a type to interpret, so we often have a value and a type together\n+// as input for binary and cast operations.\n+#[derive(Copy, Clone, Debug)]\n+pub struct ValTy<'tcx> {\n+    pub value: Value,\n+    pub layout: TyLayout<'tcx>,\n+}\n+\n+impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n+    type Target = Value;\n+    #[inline(always)]\n+    fn deref(&self) -> &Value {\n+        &self.value\n+    }\n+}\n+\n+/// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n+/// or still in memory.  The latter is an optimization, to delay reading that chunk of\n+/// memory and to avoid having to store arbitrary-sized data here.\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Operand {\n+    Immediate(Value),\n+    Indirect(MemPlace),\n+}\n+\n+impl Operand {\n+    #[inline]\n+    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n+        Operand::Indirect(MemPlace::from_ptr(ptr, align))\n+    }\n+\n+    #[inline]\n+    pub fn from_scalar_value(val: Scalar) -> Self {\n+        Operand::Immediate(Value::Scalar(val.into()))\n+    }\n+\n+    #[inline]\n+    pub fn to_mem_place(self) -> MemPlace {\n+        match self {\n+            Operand::Indirect(mplace) => mplace,\n+            _ => bug!(\"to_mem_place: expected Operand::Indirect, got {:?}\", self),\n+\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_immediate(self) -> Value {\n+        match self {\n+            Operand::Immediate(val) => val,\n+            _ => bug!(\"to_immediate: expected Operand::Immediate, got {:?}\", self),\n+\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct OpTy<'tcx> {\n+    pub op: Operand,\n+    pub layout: TyLayout<'tcx>,\n+}\n+\n+impl<'tcx> ::std::ops::Deref for OpTy<'tcx> {\n+    type Target = Operand;\n+    #[inline(always)]\n+    fn deref(&self) -> &Operand {\n+        &self.op\n+    }\n+}\n+\n+impl<'tcx> From<MPlaceTy<'tcx>> for OpTy<'tcx> {\n+    #[inline(always)]\n+    fn from(mplace: MPlaceTy<'tcx>) -> Self {\n+        OpTy {\n+            op: Operand::Indirect(*mplace),\n+            layout: mplace.layout\n+        }\n+    }\n+}\n+\n+impl<'tcx> From<ValTy<'tcx>> for OpTy<'tcx> {\n+    #[inline(always)]\n+    fn from(val: ValTy<'tcx>) -> Self {\n+        OpTy {\n+            op: Operand::Immediate(val.value),\n+            layout: val.layout\n+        }\n+    }\n+}\n+\n+impl<'tcx> OpTy<'tcx> {\n+    #[inline]\n+    pub fn from_ptr(ptr: Pointer, align: Align, layout: TyLayout<'tcx>) -> Self {\n+        OpTy { op: Operand::from_ptr(ptr, align), layout }\n+    }\n+\n+    #[inline]\n+    pub fn from_aligned_ptr(ptr: Pointer, layout: TyLayout<'tcx>) -> Self {\n+        OpTy { op: Operand::from_ptr(ptr, layout.align), layout }\n+    }\n+\n+    #[inline]\n+    pub fn from_scalar_value(val: Scalar, layout: TyLayout<'tcx>) -> Self {\n+        OpTy { op: Operand::Immediate(Value::Scalar(val.into())), layout }\n+    }\n+}\n+\n+// Use the existing layout if given (but sanity check in debug mode),\n+// or compute the layout.\n+#[inline(always)]\n+fn from_known_layout<'tcx>(\n+    layout: Option<TyLayout<'tcx>>,\n+    compute: impl FnOnce() -> EvalResult<'tcx, TyLayout<'tcx>>\n+) -> EvalResult<'tcx, TyLayout<'tcx>> {\n+    match layout {\n+        None => compute(),\n+        Some(layout) => {\n+            if cfg!(debug_assertions) {\n+                let layout2 = compute()?;\n+                assert_eq!(layout.details, layout2.details,\n+                    \"Mismatch in layout of supposedly equal-layout types {:?} and {:?}\",\n+                    layout.ty, layout2.ty);\n+            }\n+            Ok(layout)\n+        }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    /// Try reading a value in memory; this is interesting particularily for ScalarPair.\n+    /// Return None if the layout does not permit loading this as a value.\n+    fn try_read_value_from_mplace(\n+        &self,\n+        mplace: MPlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx, Option<Value>> {\n+        if mplace.extra != PlaceExtra::None {\n+            return Ok(None);\n+        }\n+        let (ptr, ptr_align) = mplace.to_scalar_ptr_align();\n+\n+        if mplace.layout.size.bytes() == 0 {\n+            // Not all ZSTs have a layout we would handle below, so just short-circuit them\n+            // all here.\n+            self.memory.check_align(ptr, ptr_align)?;\n+            return Ok(Some(Value::Scalar(Scalar::zst().into())));\n+        }\n+\n+        let ptr = ptr.to_ptr()?;\n+        match mplace.layout.abi {\n+            layout::Abi::Scalar(..) => {\n+                let scalar = self.memory.read_scalar(ptr, ptr_align, mplace.layout.size)?;\n+                Ok(Some(Value::Scalar(scalar)))\n+            }\n+            layout::Abi::ScalarPair(ref a, ref b) => {\n+                let (a, b) = (&a.value, &b.value);\n+                let (a_size, b_size) = (a.size(self), b.size(self));\n+                let a_ptr = ptr;\n+                let b_offset = a_size.abi_align(b.align(self));\n+                assert!(b_offset.bytes() > 0); // we later use the offset to test which field to use\n+                let b_ptr = ptr.offset(b_offset, self)?.into();\n+                let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n+                let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n+                Ok(Some(Value::ScalarPair(a_val, b_val)))\n+            }\n+            _ => Ok(None),\n+        }\n+    }\n+\n+    /// Try returning an immediate value for the operand.\n+    /// If the layout does not permit loading this as a value, return where in memory\n+    /// we can find the data.\n+    /// Note that for a given layout, this operation will either always fail or always\n+    /// succeed!  Whether it succeeds depends on whether the layout can be represented\n+    /// in a `Value`, not on which data is stored there currently.\n+    pub(super) fn try_read_value(\n+        &self,\n+        src: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, Result<Value, MemPlace>> {\n+        Ok(match src.try_as_mplace() {\n+            Ok(mplace) => {\n+                if let Some(val) = self.try_read_value_from_mplace(mplace)? {\n+                    Ok(val)\n+                } else {\n+                    Err(*mplace)\n+                }\n+            },\n+            Err(val) => Ok(val),\n+        })\n+    }\n+\n+    /// Read a value from a place, asserting that that is possible with the given layout.\n+    #[inline(always)]\n+    pub fn read_value(&self, op: OpTy<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n+        if let Ok(value) = self.try_read_value(op)? {\n+            Ok(ValTy { value, layout: op.layout })\n+        } else {\n+            bug!(\"primitive read failed for type: {:?}\", op.layout.ty);\n+        }\n+    }\n+\n+    /// Read a scalar from a place\n+    pub fn read_scalar(&self, op: OpTy<'tcx>) -> EvalResult<'tcx, ScalarMaybeUndef> {\n+        match *self.read_value(op)? {\n+            Value::ScalarPair(..) => bug!(\"got ScalarPair for type: {:?}\", op.layout.ty),\n+            Value::Scalar(val) => Ok(val),\n+        }\n+    }\n+\n+    pub fn uninit_operand(&mut self, layout: TyLayout<'tcx>) -> EvalResult<'tcx, Operand> {\n+        // This decides which types we will use the Immediate optimization for, and hence should\n+        // match what `try_read_value` and `eval_place_to_op` support.\n+        if layout.is_zst() {\n+            return Ok(Operand::Immediate(Value::Scalar(Scalar::zst().into())));\n+        }\n+\n+        Ok(match layout.abi {\n+            layout::Abi::Scalar(..) =>\n+                Operand::Immediate(Value::Scalar(ScalarMaybeUndef::Undef)),\n+            layout::Abi::ScalarPair(..) =>\n+                Operand::Immediate(Value::ScalarPair(\n+                    ScalarMaybeUndef::Undef,\n+                    ScalarMaybeUndef::Undef,\n+                )),\n+            _ => {\n+                trace!(\"Forcing allocation for local of type {:?}\", layout.ty);\n+                Operand::Indirect(\n+                    *self.allocate(layout, MemoryKind::Stack)?\n+                )\n+            }\n+        })\n+    }\n+\n+    /// Projection functions\n+    pub fn operand_field(\n+        &self,\n+        op: OpTy<'tcx>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        let base = match op.try_as_mplace() {\n+            Ok(mplace) => {\n+                // The easy case\n+                let field = self.mplace_field(mplace, field)?;\n+                return Ok(field.into());\n+            },\n+            Err(value) => value\n+        };\n+\n+        let field = field.try_into().unwrap();\n+        let field_layout = op.layout.field(self, field)?;\n+        if field_layout.size.bytes() == 0 {\n+            let val = Value::Scalar(Scalar::zst().into());\n+            return Ok(OpTy { op: Operand::Immediate(val), layout: field_layout });\n+        }\n+        let offset = op.layout.fields.offset(field);\n+        let value = match base {\n+            // the field covers the entire type\n+            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => base,\n+            // extract fields from types with `ScalarPair` ABI\n+            Value::ScalarPair(a, b) => {\n+                let val = if offset.bytes() == 0 { a } else { b };\n+                Value::Scalar(val)\n+            },\n+            Value::Scalar(val) =>\n+                bug!(\"field access on non aggregate {:#?}, {:#?}\", val, op.layout),\n+        };\n+        Ok(OpTy { op: Operand::Immediate(value), layout: field_layout })\n+    }\n+\n+    pub(super) fn operand_downcast(\n+        &self,\n+        op: OpTy<'tcx>,\n+        variant: usize,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        // Downcasts only change the layout\n+        Ok(match op.try_as_mplace() {\n+            Ok(mplace) => {\n+                self.mplace_downcast(mplace, variant)?.into()\n+            },\n+            Err(..) => {\n+                let layout = op.layout.for_variant(self, variant);\n+                OpTy { layout, ..op }\n+            }\n+        })\n+    }\n+\n+    // Take an operand, representing a pointer, and dereference it -- that\n+    // will always be a MemPlace.\n+    pub(super) fn deref_operand(\n+        &self,\n+        src: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        let val = self.read_value(src)?;\n+        trace!(\"deref to {} on {:?}\", val.layout.ty, val);\n+        Ok(self.ref_to_mplace(val)?)\n+    }\n+\n+    pub fn operand_projection(\n+        &self,\n+        base: OpTy<'tcx>,\n+        proj_elem: &mir::PlaceElem<'tcx>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        use rustc::mir::ProjectionElem::*;\n+        Ok(match *proj_elem {\n+            Field(field, _) => self.operand_field(base, field.index() as u64)?,\n+            Downcast(_, variant) => self.operand_downcast(base, variant)?,\n+            Deref => self.deref_operand(base)?.into(),\n+            // The rest should only occur as mplace, we do not use Immediates for types\n+            // allowing such operations.  This matches place_projection forcing an allocation.\n+            Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n+                let mplace = base.to_mem_place();\n+                self.mplace_projection(mplace, proj_elem)?.into()\n+            }\n+        })\n+    }\n+\n+    // Evaluate a place with the goal of reading from it.  This lets us sometimes\n+    // avoid allocations.  If you already know the layout, you can pass it in\n+    // to avoid looking it up again.\n+    fn eval_place_to_op(\n+        &mut self,\n+        mir_place: &mir::Place<'tcx>,\n+        layout: Option<TyLayout<'tcx>>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        use rustc::mir::Place::*;\n+        Ok(match *mir_place {\n+            Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n+            Local(local) => {\n+                let op = *self.frame().locals[local].access()?;\n+                let layout = from_known_layout(layout,\n+                    || self.layout_of_local(self.cur_frame(), local))?;\n+                OpTy { op, layout }\n+            },\n+\n+            Projection(ref proj) => {\n+                let op = self.eval_place_to_op(&proj.base, None)?;\n+                self.operand_projection(op, &proj.elem)?\n+            }\n+\n+            // Everything else is an mplace, so we just call `eval_place`.\n+            // Note that getting an mplace for a static aways requires `&mut`,\n+            // so this does not \"cost\" us anything in terms if mutability.\n+            Promoted(_) | Static(_) => {\n+                let place = self.eval_place(mir_place)?;\n+                place.to_mem_place().into()\n+            }\n+        })\n+    }\n+\n+    /// Evaluate the operand, returning a place where you can then find the data.\n+    /// if you already know the layout, you can save two some table lookups\n+    /// by passing it in here.\n+    pub fn eval_operand(\n+        &mut self,\n+        mir_op: &mir::Operand<'tcx>,\n+        layout: Option<TyLayout<'tcx>>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        use rustc::mir::Operand::*;\n+        let op = match *mir_op {\n+            // FIXME: do some more logic on `move` to invalidate the old location\n+            Copy(ref place) |\n+            Move(ref place) =>\n+                self.eval_place_to_op(place, layout)?,\n+\n+            Constant(ref constant) => {\n+                let layout = from_known_layout(layout, || {\n+                    let ty = self.monomorphize(mir_op.ty(self.mir(), *self.tcx), self.substs());\n+                    self.layout_of(ty)\n+                })?;\n+                let op = self.const_value_to_op(constant.literal.val)?;\n+                OpTy { op, layout }\n+            }\n+        };\n+        trace!(\"{:?}: {:?}\", mir_op, *op);\n+        Ok(op)\n+    }\n+\n+    /// Evaluate a bunch of operands at once\n+    pub(crate) fn eval_operands(\n+        &mut self,\n+        ops: &[mir::Operand<'tcx>],\n+    ) -> EvalResult<'tcx, Vec<OpTy<'tcx>>> {\n+        ops.into_iter()\n+            .map(|op| self.eval_operand(op, None))\n+            .collect()\n+    }\n+\n+    // Also used e.g. when miri runs into a constant.\n+    // Unfortunately, this needs an `&mut` to be able to allocate a copy of a `ByRef`\n+    // constant.  This bleeds up to `eval_operand` needing `&mut`.\n+    pub fn const_value_to_op(\n+        &mut self,\n+        val: ConstValue<'tcx>,\n+    ) -> EvalResult<'tcx, Operand> {\n+        match val {\n+            ConstValue::Unevaluated(def_id, substs) => {\n+                let instance = self.resolve(def_id, substs)?;\n+                self.global_to_op(GlobalId {\n+                    instance,\n+                    promoted: None,\n+                })\n+            }\n+            ConstValue::ByRef(alloc, offset) => {\n+                // FIXME: Allocate new AllocId for all constants inside\n+                let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n+                Ok(Operand::from_ptr(Pointer::new(id, offset), alloc.align))\n+            },\n+            ConstValue::ScalarPair(a, b) =>\n+                Ok(Operand::Immediate(Value::ScalarPair(a.into(), b))),\n+            ConstValue::Scalar(x) =>\n+                Ok(Operand::Immediate(Value::Scalar(x.into()))),\n+        }\n+    }\n+\n+    pub(super) fn global_to_op(&mut self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Operand> {\n+        let cv = self.const_eval(gid)?;\n+        self.const_value_to_op(cv.val)\n+    }\n+\n+    /// We cannot do self.read_value(self.eval_operand) due to eval_operand taking &mut self,\n+    /// so this helps avoid unnecessary let.\n+    #[inline]\n+    pub fn eval_operand_and_read_value(\n+        &mut self,\n+        op: &mir::Operand<'tcx>,\n+        layout: Option<TyLayout<'tcx>>,\n+    ) -> EvalResult<'tcx, ValTy<'tcx>> {\n+        let op = self.eval_operand(op, layout)?;\n+        self.read_value(op)\n+    }\n+\n+    /// reads a tag and produces the corresponding variant index\n+    pub fn read_discriminant_as_variant_index(\n+        &self,\n+        rval: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, usize> {\n+        match rval.layout.variants {\n+            layout::Variants::Single { index } => Ok(index),\n+            layout::Variants::Tagged { .. } => {\n+                let discr_val = self.read_discriminant_value(rval)?;\n+                rval.layout.ty\n+                    .ty_adt_def()\n+                    .expect(\"tagged layout for non adt\")\n+                    .discriminants(self.tcx.tcx)\n+                    .position(|var| var.val == discr_val)\n+                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant.into())\n+            }\n+            layout::Variants::NicheFilling { .. } => {\n+                let discr_val = self.read_discriminant_value(rval)?;\n+                assert_eq!(discr_val as usize as u128, discr_val);\n+                Ok(discr_val as usize)\n+            },\n+        }\n+    }\n+\n+    pub fn read_discriminant_value(\n+        &self,\n+        rval: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, u128> {\n+        trace!(\"read_discriminant_value {:#?}\", rval.layout);\n+        if rval.layout.abi == layout::Abi::Uninhabited {\n+            return err!(Unreachable);\n+        }\n+\n+        match rval.layout.variants {\n+            layout::Variants::Single { index } => {\n+                let discr_val = rval.layout.ty.ty_adt_def().map_or(\n+                    index as u128,\n+                    |def| def.discriminant_for_variant(*self.tcx, index).val);\n+                return Ok(discr_val);\n+            }\n+            layout::Variants::Tagged { .. } |\n+            layout::Variants::NicheFilling { .. } => {},\n+        }\n+        let discr_op = self.operand_field(rval, 0)?;\n+        let discr_val = self.read_value(discr_op)?;\n+        trace!(\"discr value: {:?}\", discr_val);\n+        let raw_discr = discr_val.to_scalar()?;\n+        Ok(match rval.layout.variants {\n+            layout::Variants::Single { .. } => bug!(),\n+            // FIXME: We should catch invalid discriminants here!\n+            layout::Variants::Tagged { .. } => {\n+                if discr_val.layout.ty.is_signed() {\n+                    let i = raw_discr.to_bits(discr_val.layout.size)? as i128;\n+                    // going from layout tag type to typeck discriminant type\n+                    // requires first sign extending with the layout discriminant\n+                    let shift = 128 - discr_val.layout.size.bits();\n+                    let sexted = (i << shift) >> shift;\n+                    // and then zeroing with the typeck discriminant type\n+                    let discr_ty = rval.layout.ty\n+                        .ty_adt_def().expect(\"tagged layout corresponds to adt\")\n+                        .repr\n+                        .discr_type();\n+                    let discr_ty = layout::Integer::from_attr(self.tcx.tcx, discr_ty);\n+                    let shift = 128 - discr_ty.size().bits();\n+                    let truncatee = sexted as u128;\n+                    (truncatee << shift) >> shift\n+                } else {\n+                    raw_discr.to_bits(discr_val.layout.size)?\n+                }\n+            },\n+            layout::Variants::NicheFilling {\n+                dataful_variant,\n+                ref niche_variants,\n+                niche_start,\n+                ..\n+            } => {\n+                let variants_start = *niche_variants.start() as u128;\n+                let variants_end = *niche_variants.end() as u128;\n+                match raw_discr {\n+                    Scalar::Ptr(_) => {\n+                        assert!(niche_start == 0);\n+                        assert!(variants_start == variants_end);\n+                        dataful_variant as u128\n+                    },\n+                    Scalar::Bits { bits: raw_discr, size } => {\n+                        assert_eq!(size as u64, discr_val.layout.size.bytes());\n+                        let discr = raw_discr.wrapping_sub(niche_start)\n+                            .wrapping_add(variants_start);\n+                        if variants_start <= discr && discr <= variants_end {\n+                            discr\n+                        } else {\n+                            dataful_variant as u128\n+                        }\n+                    },\n+                }\n+            }\n+        })\n+    }\n+\n+}"}, {"sha": "c5475f9a4c0640a491a976fe134c9e711bc6f8d9", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 26, "deletions": 45, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1,58 +1,39 @@\n use rustc::mir;\n-use rustc::ty::{self, Ty, layout};\n+use rustc::ty::{self, layout::{self, TyLayout}};\n use syntax::ast::FloatTy;\n-use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n+use rustc::mir::interpret::{EvalResult, Scalar};\n \n-use super::{EvalContext, Place, Machine, ValTy};\n+use super::{EvalContext, PlaceTy, Value, Machine, ValTy};\n \n-use rustc::mir::interpret::{EvalResult, Scalar, Value};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    fn binop_with_overflow(\n-        &self,\n-        op: mir::BinOp,\n-        left: ValTy<'tcx>,\n-        right: ValTy<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n-        let left_val = self.value_to_scalar(left)?;\n-        let right_val = self.value_to_scalar(right)?;\n-        self.binary_op(op, left_val, left.ty, right_val, right.ty)\n-    }\n-\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n-    pub fn intrinsic_with_overflow(\n+    pub fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n         left: ValTy<'tcx>,\n         right: ValTy<'tcx>,\n-        dest: Place,\n-        dest_ty: Ty<'tcx>,\n+        dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n+        let (val, overflowed) = self.binary_op(op, left, right)?;\n         let val = Value::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n-        let valty = ValTy {\n-            value: val,\n-            ty: dest_ty,\n-        };\n-        self.write_value(valty, dest)\n+        self.write_value(val, dest)\n     }\n \n     /// Applies the binary operation `op` to the arguments and writes the result to the\n-    /// destination. Returns `true` if the operation overflowed.\n-    pub fn intrinsic_overflowing(\n+    /// destination.\n+    pub fn binop_ignore_overflow(\n         &mut self,\n         op: mir::BinOp,\n         left: ValTy<'tcx>,\n         right: ValTy<'tcx>,\n-        dest: Place,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        self.write_scalar(dest, val, dest_ty)?;\n-        Ok(overflowed)\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        let (val, _overflowed) = self.binary_op(op, left, right)?;\n+        self.write_scalar(val, dest)\n     }\n }\n \n@@ -61,29 +42,29 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n-        left_ty: Ty<'tcx>,\n-        right: Scalar,\n-        right_ty: Ty<'tcx>,\n+        ValTy { value: left, layout: left_layout }: ValTy<'tcx>,\n+        ValTy { value: right, layout: right_layout }: ValTy<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        let left_layout = self.layout_of(left_ty)?;\n-        let right_layout = self.layout_of(right_ty)?;\n+        let left = left.to_scalar()?;\n+        let right = right.to_scalar()?;\n \n         let left_kind = match left_layout.abi {\n             layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => return err!(TypeNotPrimitive(left_ty)),\n+            _ => return err!(TypeNotPrimitive(left_layout.ty)),\n         };\n         let right_kind = match right_layout.abi {\n             layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => return err!(TypeNotPrimitive(right_ty)),\n+            _ => return err!(TypeNotPrimitive(right_layout.ty)),\n         };\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n         if !left_kind.is_float() && !right_kind.is_float() {\n-            if let Some(handled) = M::try_ptr_op(self, bin_op, left, left_ty, right, right_ty)? {\n+            if let Some(handled) =\n+                M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n+            {\n                 return Ok(handled);\n             }\n         }\n@@ -188,7 +169,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        if let ty::TyFloat(fty) = left_ty.sty {\n+        if let ty::TyFloat(fty) = left_layout.ty.sty {\n             macro_rules! float_math {\n                 ($ty:path, $size:expr) => {{\n                     let l = <$ty>::from_bits(l);\n@@ -220,7 +201,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        let size = self.layout_of(left_ty).unwrap().size.bytes() as u8;\n+        let size = left_layout.size.bytes() as u8;\n \n         // only ints left\n         let val = match bin_op {\n@@ -260,9 +241,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n                     bin_op,\n                     left,\n-                    left_ty,\n+                    left_layout.ty,\n                     right,\n-                    right_ty,\n+                    right_layout.ty,\n                 );\n                 return err!(Unimplemented(msg));\n             }"}, {"sha": "91182edc2f5b7ea525e5c702f88ed2e9731ac273", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 673, "deletions": 351, "changes": 1024, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1,472 +1,794 @@\n+//! Computations on places -- field projections, going from mir::Place, and writing\n+//! into a place.\n+//! All high-level functions to write to memory work on places as destinations.\n+\n+use std::hash::{Hash, Hasher};\n+use std::convert::TryFrom;\n+\n use rustc::mir;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer, ScalarMaybeUndef};\n-use super::{EvalContext, Machine, ValTy};\n-use interpret::memory::HasMemory;\n+use rustc::mir::interpret::{\n+    GlobalId, Scalar, EvalResult, Pointer, ScalarMaybeUndef\n+};\n+use super::{EvalContext, Machine, Value, ValTy, Operand, OpTy, MemoryKind};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct MemPlace {\n+    /// A place may have an integral pointer for ZSTs, and since it might\n+    /// be turned back into a reference before ever being dereferenced.\n+    /// However, it may never be undef.\n+    pub ptr: Scalar,\n+    pub align: Align,\n+    pub extra: PlaceExtra,\n+}\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Place {\n     /// A place referring to a value allocated in the `Memory` system.\n-    Ptr {\n-        /// A place may have an invalid (integral or undef) pointer,\n-        /// since it might be turned back into a reference\n-        /// before ever being dereferenced.\n-        ptr: ScalarMaybeUndef,\n-        align: Align,\n-        extra: PlaceExtra,\n-    },\n+    Ptr(MemPlace),\n \n-    /// A place referring to a value on the stack. Represented by a stack frame index paired with\n-    /// a Mir local index.\n-    Local { frame: usize, local: mir::Local },\n+    /// To support alloc-free locals, we are able to write directly to a local.\n+    /// (Without that optimization, we'd just always be a `MemPlace`.)\n+    Local {\n+        frame: usize,\n+        local: mir::Local,\n+    },\n }\n \n+// Extra information for fat pointers / places\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum PlaceExtra {\n     None,\n     Length(u64),\n     Vtable(Pointer),\n-    DowncastVariant(usize),\n }\n \n-impl<'tcx> Place {\n-    /// Produces a Place that will error if attempted to be read from\n-    pub fn undef() -> Self {\n-        Self::from_scalar_ptr(ScalarMaybeUndef::Undef, Align::from_bytes(1, 1).unwrap())\n+#[derive(Copy, Clone, Debug)]\n+pub struct PlaceTy<'tcx> {\n+    place: Place,\n+    pub layout: TyLayout<'tcx>,\n+}\n+\n+impl<'tcx> ::std::ops::Deref for PlaceTy<'tcx> {\n+    type Target = Place;\n+    #[inline(always)]\n+    fn deref(&self) -> &Place {\n+        &self.place\n+    }\n+}\n+\n+/// A MemPlace with its layout. Constructing it is only possible in this module.\n+#[derive(Copy, Clone, Debug)]\n+pub struct MPlaceTy<'tcx> {\n+    mplace: MemPlace,\n+    pub layout: TyLayout<'tcx>,\n+}\n+\n+impl<'tcx> ::std::ops::Deref for MPlaceTy<'tcx> {\n+    type Target = MemPlace;\n+    #[inline(always)]\n+    fn deref(&self) -> &MemPlace {\n+        &self.mplace\n     }\n+}\n+\n+impl<'tcx> From<MPlaceTy<'tcx>> for PlaceTy<'tcx> {\n+    #[inline(always)]\n+    fn from(mplace: MPlaceTy<'tcx>) -> Self {\n+        PlaceTy {\n+            place: Place::Ptr(mplace.mplace),\n+            layout: mplace.layout\n+        }\n+    }\n+}\n \n-    pub fn from_scalar_ptr(ptr: ScalarMaybeUndef, align: Align) -> Self {\n-        Place::Ptr {\n+impl MemPlace {\n+    #[inline(always)]\n+    pub fn from_scalar_ptr(ptr: Scalar, align: Align) -> Self {\n+        MemPlace {\n             ptr,\n             align,\n             extra: PlaceExtra::None,\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n+        Self::from_scalar_ptr(ptr.into(), align)\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_scalar_ptr_align(self) -> (Scalar, Align) {\n+        assert_eq!(self.extra, PlaceExtra::None);\n+        (self.ptr, self.align)\n+    }\n+\n+    /// Extract the ptr part of the mplace\n+    #[inline(always)]\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+        // At this point, we forget about the alignment information -- the place has been turned into a reference,\n+        // and no matter where it came from, it now must be aligned.\n+        self.to_scalar_ptr_align().0.to_ptr()\n+    }\n+\n+    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n+    /// This is the inverse of `ref_to_mplace`.\n+    pub fn to_ref(self, cx: impl HasDataLayout) -> Value {\n+        // We ignore the alignment of the place here -- special handling for packed structs ends\n+        // at the `&` operator.\n+        match self.extra {\n+            PlaceExtra::None => Value::Scalar(self.ptr.into()),\n+            PlaceExtra::Length(len) => Value::new_slice(self.ptr.into(), len, cx),\n+            PlaceExtra::Vtable(vtable) => Value::new_dyn_trait(self.ptr.into(), vtable),\n+        }\n+    }\n+}\n+\n+impl<'tcx> MPlaceTy<'tcx> {\n+    #[inline]\n+    fn from_aligned_ptr(ptr: Pointer, layout: TyLayout<'tcx>) -> Self {\n+        MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align), layout }\n+    }\n+\n+    #[inline]\n+    pub(super) fn len(self) -> u64 {\n+        // Sanity check\n+        let ty_len = match self.layout.fields {\n+            layout::FieldPlacement::Array { count, .. } => count,\n+            _ => bug!(\"Length for non-array layout {:?} requested\", self.layout),\n+        };\n+        if let PlaceExtra::Length(len) = self.extra {\n+            len\n+        } else {\n+            ty_len\n+        }\n+    }\n+}\n+\n+// Validation needs to hash MPlaceTy, but we cannot hash Layout -- so we just hash the type\n+impl<'tcx> Hash for MPlaceTy<'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.mplace.hash(state);\n+        self.layout.ty.hash(state);\n+    }\n+}\n+impl<'tcx> PartialEq for MPlaceTy<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.mplace == other.mplace && self.layout.ty == other.layout.ty\n+    }\n+}\n+impl<'tcx> Eq for MPlaceTy<'tcx> {}\n+\n+impl<'tcx> OpTy<'tcx> {\n+    #[inline(always)]\n+    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx>, Value> {\n+        match *self {\n+            Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n+            Operand::Immediate(value) => Err(value),\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_mem_place(self) -> MPlaceTy<'tcx> {\n+        self.try_as_mplace().unwrap()\n+    }\n+}\n+\n+impl<'tcx> Place {\n+    /// Produces a Place that will error if attempted to be read from or written to\n+    #[inline]\n+    pub fn null(cx: impl HasDataLayout) -> Self {\n+        Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1, 1).unwrap())\n+    }\n+\n+    #[inline]\n+    pub fn from_scalar_ptr(ptr: Scalar, align: Align) -> Self {\n+        Place::Ptr(MemPlace::from_scalar_ptr(ptr, align))\n+    }\n+\n+    #[inline]\n     pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n-        Self::from_scalar_ptr(ScalarMaybeUndef::Scalar(ptr.into()), align)\n+        Place::Ptr(MemPlace::from_ptr(ptr, align))\n     }\n \n-    pub fn to_ptr_align_extra(self) -> (ScalarMaybeUndef, Align, PlaceExtra) {\n+    #[inline]\n+    pub fn to_mem_place(self) -> MemPlace {\n         match self {\n-            Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n-            _ => bug!(\"to_ptr_and_extra: expected Place::Ptr, got {:?}\", self),\n+            Place::Ptr(mplace) => mplace,\n+            _ => bug!(\"to_mem_place: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n \n-    pub fn to_ptr_align(self) -> (ScalarMaybeUndef, Align) {\n-        let (ptr, align, _extra) = self.to_ptr_align_extra();\n-        (ptr, align)\n+    #[inline]\n+    pub fn to_scalar_ptr_align(self) -> (Scalar, Align) {\n+        self.to_mem_place().to_scalar_ptr_align()\n     }\n \n+    #[inline]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n-        // At this point, we forget about the alignment information -- the place has been turned into a reference,\n-        // and no matter where it came from, it now must be aligned.\n-        self.to_ptr_align().0.unwrap_or_err()?.to_ptr()\n-    }\n-\n-    pub(super) fn elem_ty_and_len(\n-        self,\n-        ty: Ty<'tcx>,\n-        tcx: TyCtxt<'_, 'tcx, '_>\n-    ) -> (Ty<'tcx>, u64) {\n-        match ty.sty {\n-            ty::TyArray(elem, n) => (elem, n.unwrap_usize(tcx)),\n-\n-            ty::TySlice(elem) => {\n-                match self {\n-                    Place::Ptr { extra: PlaceExtra::Length(len), .. } => (elem, len),\n-                    _ => {\n-                        bug!(\n-                            \"elem_ty_and_len of a TySlice given non-slice place: {:?}\",\n-                            self\n-                        )\n-                    }\n-                }\n-            }\n+        self.to_mem_place().to_ptr()\n+    }\n+}\n \n-            _ => bug!(\"elem_ty_and_len expected array or slice, got {:?}\", ty),\n-        }\n+impl<'tcx> PlaceTy<'tcx> {\n+    /// Produces a Place that will error if attempted to be read from or written to\n+    #[inline]\n+    pub fn null(cx: impl HasDataLayout, layout: TyLayout<'tcx>) -> Self {\n+        PlaceTy { place: Place::from_scalar_ptr(Scalar::ptr_null(cx), layout.align), layout }\n+    }\n+\n+    #[inline]\n+    pub fn to_mem_place(self) -> MPlaceTy<'tcx> {\n+        MPlaceTy { mplace: self.place.to_mem_place(), layout: self.layout }\n     }\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Reads a value from the place without going through the intermediate step of obtaining\n-    /// a `miri::Place`\n-    pub fn try_read_place(\n+    /// Take a value, which represents a (thin or fat) reference, and make it a place.\n+    /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref`.\n+    pub fn ref_to_mplace(\n+        &self, val: ValTy<'tcx>\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n+        let layout = self.layout_of(pointee_type)?;\n+        let mplace = match self.tcx.struct_tail(pointee_type).sty {\n+            ty::TyDynamic(..) => {\n+                let (ptr, vtable) = val.to_scalar_dyn_trait()?;\n+                MemPlace {\n+                    ptr,\n+                    align: layout.align,\n+                    extra: PlaceExtra::Vtable(vtable),\n+                }\n+            }\n+            ty::TyStr | ty::TySlice(_) => {\n+                let (ptr, len) = val.to_scalar_slice(self)?;\n+                MemPlace {\n+                    ptr,\n+                    align: layout.align,\n+                    extra: PlaceExtra::Length(len),\n+                }\n+            }\n+            _ => MemPlace {\n+                ptr: val.to_scalar()?,\n+                align: layout.align,\n+                extra: PlaceExtra::None,\n+            },\n+        };\n+        Ok(MPlaceTy { mplace, layout })\n+    }\n+\n+    /// Offset a pointer to project to a field. Unlike place_field, this is always\n+    /// possible without allocating, so it can take &self. Also return the field's layout.\n+    /// This supports both struct and array fields.\n+    #[inline(always)]\n+    pub fn mplace_field(\n         &self,\n-        place: &mir::Place<'tcx>,\n-    ) -> EvalResult<'tcx, Option<Value>> {\n-        use rustc::mir::Place::*;\n-        match *place {\n-            // Might allow this in the future, right now there's no way to do this from Rust code anyway\n-            Local(mir::RETURN_PLACE) => err!(ReadFromReturnPointer),\n-            // Directly reading a local will always succeed\n-            Local(local) => self.frame().locals[local].access().map(Some),\n-            // No fast path for statics. Reading from statics is rare and would require another\n-            // Machine function to handle differently in miri.\n-            Promoted(_) |\n-            Static(_) => Ok(None),\n-            Projection(ref proj) => self.try_read_place_projection(proj),\n-        }\n+        base: MPlaceTy<'tcx>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        // Not using the layout method because we want to compute on u64\n+        let offset = match base.layout.fields {\n+            layout::FieldPlacement::Arbitrary { ref offsets, .. } =>\n+                offsets[usize::try_from(field).unwrap()],\n+            layout::FieldPlacement::Array { stride, .. } => {\n+                let len = base.len();\n+                assert!(field < len, \"Tried to access element {} of array/slice with length {}\", field, len);\n+                stride * field\n+            }\n+            layout::FieldPlacement::Union(count) => {\n+                assert!(field < count as u64, \"Tried to access field {} of union with {} fields\", field, count);\n+                // Offset is always 0\n+                Size::from_bytes(0)\n+            }\n+        };\n+        // the only way conversion can fail if is this is an array (otherwise we already panicked\n+        // above). In that case, all fields are equal.\n+        let field_layout = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n+\n+        // Adjust offset\n+        let offset = match base.extra {\n+            PlaceExtra::Vtable(vtable) => {\n+                let (_, align) = self.read_size_and_align_from_vtable(vtable)?;\n+                // FIXME: Is this right? Should we always do this, or only when actually\n+                // accessing the field to which the vtable applies?\n+                offset.abi_align(align)\n+            }\n+            _ => {\n+                // No adjustment needed\n+                offset\n+            }\n+        };\n+\n+        let ptr = base.ptr.ptr_offset(offset, self)?;\n+        let align = base.align.min(field_layout.align);\n+        let extra = if !field_layout.is_unsized() {\n+            PlaceExtra::None\n+        } else {\n+            assert!(base.extra != PlaceExtra::None, \"Expected fat ptr\");\n+            base.extra\n+        };\n+\n+        Ok(MPlaceTy { mplace: MemPlace { ptr, align, extra }, layout: field_layout })\n     }\n \n-    pub fn read_field(\n+    // Iterates over all fields of an array. Much more efficient than doing the\n+    // same by repeatedly calling `mplace_array`.\n+    pub fn mplace_array_fields(\n         &self,\n-        base: Value,\n-        variant: Option<usize>,\n-        field: mir::Field,\n-        mut base_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Value, TyLayout<'tcx>)> {\n-        if let Some(variant_index) = variant {\n-            base_layout = base_layout.for_variant(self, variant_index);\n-        }\n-        let field_index = field.index();\n-        let field = base_layout.field(self, field_index)?;\n-        if field.size.bytes() == 0 {\n-            return Ok((\n-                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits: 0, size: 0 })),\n-                field,\n-            ));\n-        }\n-        let offset = base_layout.fields.offset(field_index);\n-        let value = match base {\n-            // the field covers the entire type\n-            Value::ScalarPair(..) |\n-            Value::Scalar(_) if offset.bytes() == 0 && field.size == base_layout.size => base,\n-            // extract fields from types with `ScalarPair` ABI\n-            Value::ScalarPair(a, b) => {\n-                let val = if offset.bytes() == 0 { a } else { b };\n-                Value::Scalar(val)\n-            },\n-            Value::ByRef(base_ptr, align) => {\n-                let offset = base_layout.fields.offset(field_index);\n-                let ptr = base_ptr.ptr_offset(offset, self)?;\n-                let align = align.min(base_layout.align).min(field.align);\n-                assert!(!field.is_unsized());\n-                Value::ByRef(ptr, align)\n-            },\n-            Value::Scalar(val) => bug!(\"field access on non aggregate {:#?}, {:#?}\", val, base_layout),\n+        base: MPlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx, impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx>>> + 'a> {\n+        let len = base.len();\n+        let stride = match base.layout.fields {\n+            layout::FieldPlacement::Array { stride, .. } => stride,\n+            _ => bug!(\"mplace_array_fields: expected an array layout\"),\n         };\n-        Ok((value, field))\n+        let layout = base.layout.field(self, 0)?;\n+        let dl = &self.tcx.data_layout;\n+        Ok((0..len).map(move |i| {\n+            let ptr = base.ptr.ptr_offset(i * stride, dl)?;\n+            Ok(MPlaceTy {\n+                mplace: MemPlace { ptr, align: base.align, extra: PlaceExtra::None },\n+                layout\n+            })\n+        }))\n     }\n \n-    fn try_read_place_projection(\n+    pub fn mplace_subslice(\n         &self,\n-        proj: &mir::PlaceProjection<'tcx>,\n-    ) -> EvalResult<'tcx, Option<Value>> {\n-        use rustc::mir::ProjectionElem::*;\n-        let base = match self.try_read_place(&proj.base)? {\n-            Some(base) => base,\n-            None => return Ok(None),\n+        base: MPlaceTy<'tcx>,\n+        from: u64,\n+        to: u64,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        let len = base.len();\n+        assert!(from <= len - to);\n+\n+        // Not using layout method because that works with usize, and does not work with slices\n+        // (that have count 0 in their layout).\n+        let from_offset = match base.layout.fields {\n+            layout::FieldPlacement::Array { stride, .. } =>\n+                stride * from,\n+            _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n-        let base_ty = self.place_ty(&proj.base);\n-        let base_layout = self.layout_of(base_ty)?;\n-        match proj.elem {\n-            Field(field, _) => Ok(Some(self.read_field(base, None, field, base_layout)?.0)),\n-            // The NullablePointer cases should work fine, need to take care for normal enums\n-            Downcast(..) |\n-            Subslice { .. } |\n-            // reading index 0 or index 1 from a ByVal or ByVal pair could be optimized\n-            ConstantIndex { .. } | Index(_) |\n-            // No way to optimize this projection any better than the normal place path\n-            Deref => Ok(None),\n-        }\n+        let ptr = base.ptr.ptr_offset(from_offset, self)?;\n+\n+        // Compute extra and new layout\n+        let inner_len = len - to - from;\n+        let (extra, ty) = match base.layout.ty.sty {\n+            ty::TyArray(inner, _) =>\n+                (PlaceExtra::None, self.tcx.mk_array(inner, inner_len)),\n+            ty::TySlice(..) =>\n+                (PlaceExtra::Length(inner_len), base.layout.ty),\n+            _ =>\n+                bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n+        };\n+        let layout = self.layout_of(ty)?;\n+\n+        Ok(MPlaceTy {\n+            mplace: MemPlace { ptr, align: base.align, extra },\n+            layout\n+        })\n+    }\n+\n+    pub fn mplace_downcast(\n+        &self,\n+        base: MPlaceTy<'tcx>,\n+        variant: usize,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        // Downcasts only change the layout\n+        assert_eq!(base.extra, PlaceExtra::None);\n+        Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n+    }\n+\n+    /// Project into an mplace\n+    pub fn mplace_projection(\n+        &self,\n+        base: MPlaceTy<'tcx>,\n+        proj_elem: &mir::PlaceElem<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        use rustc::mir::ProjectionElem::*;\n+        Ok(match *proj_elem {\n+            Field(field, _) => self.mplace_field(base, field.index() as u64)?,\n+            Downcast(_, variant) => self.mplace_downcast(base, variant)?,\n+            Deref => self.deref_operand(base.into())?,\n+\n+            Index(local) => {\n+                let n = *self.frame().locals[local].access()?;\n+                let n_layout = self.layout_of(self.tcx.types.usize)?;\n+                let n = self.read_scalar(OpTy { op: n, layout: n_layout })?;\n+                let n = n.to_bits(self.tcx.data_layout.pointer_size)?;\n+                self.mplace_field(base, u64::try_from(n).unwrap())?\n+            }\n+\n+            ConstantIndex {\n+                offset,\n+                min_length,\n+                from_end,\n+            } => {\n+                let n = base.len();\n+                assert!(n >= min_length as u64);\n+\n+                let index = if from_end {\n+                    n - u64::from(offset)\n+                } else {\n+                    u64::from(offset)\n+                };\n+\n+                self.mplace_field(base, index)?\n+            }\n+\n+            Subslice { from, to } =>\n+                self.mplace_subslice(base, u64::from(from), u64::from(to))?,\n+        })\n     }\n \n-    /// Returns a value and (in case of a ByRef) if we are supposed to use aligned accesses.\n-    pub(super) fn eval_and_read_place(\n+    /// Get the place of a field inside the place, and also the field's type.\n+    /// Just a convenience function, but used quite a bit.\n+    pub fn place_field(\n         &mut self,\n-        place: &mir::Place<'tcx>,\n-    ) -> EvalResult<'tcx, Value> {\n-        // Shortcut for things like accessing a fat pointer's field,\n-        // which would otherwise (in the `eval_place` path) require moving a `ScalarPair` to memory\n-        // and returning an `Place::Ptr` to it\n-        if let Some(val) = self.try_read_place(place)? {\n-            return Ok(val);\n-        }\n-        let place = self.eval_place(place)?;\n-        self.read_place(place)\n+        base: PlaceTy<'tcx>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+        // FIXME: We could try to be smarter and avoid allocation for fields that span the\n+        // entire place.\n+        let mplace = self.force_allocation(base)?;\n+        Ok(self.mplace_field(mplace, field)?.into())\n     }\n \n-    pub fn read_place(&self, place: Place) -> EvalResult<'tcx, Value> {\n-        match place {\n-            Place::Ptr { ptr, align, extra } => {\n-                assert_eq!(extra, PlaceExtra::None);\n-                Ok(Value::ByRef(ptr.unwrap_or_err()?, align))\n+    pub fn place_downcast(\n+        &mut self,\n+        base: PlaceTy<'tcx>,\n+        variant: usize,\n+    ) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+        // Downcast just changes the layout\n+        Ok(match base.place {\n+            Place::Ptr(mplace) =>\n+                self.mplace_downcast(MPlaceTy { mplace, layout: base.layout }, variant)?.into(),\n+            Place::Local { .. } => {\n+                let layout = base.layout.for_variant(&self, variant);\n+                PlaceTy { layout, ..base }\n             }\n-            Place::Local { frame, local } => self.stack[frame].locals[local].access(),\n-        }\n+        })\n     }\n \n-    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, Place> {\n+    /// Project into a place\n+    pub fn place_projection(\n+        &mut self,\n+        base: PlaceTy<'tcx>,\n+        proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n+    ) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+        use rustc::mir::ProjectionElem::*;\n+        Ok(match *proj_elem {\n+            Field(field, _) =>  self.place_field(base, field.index() as u64)?,\n+            Downcast(_, variant) => self.place_downcast(base, variant)?,\n+            Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n+            // For the other variants, we have to force an allocation.\n+            // This matches `operand_projection`.\n+            Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n+                let mplace = self.force_allocation(base)?;\n+                self.mplace_projection(mplace, proj_elem)?.into()\n+            }\n+        })\n+    }\n+\n+    /// Compute a place.  You should only use this if you intend to write into this\n+    /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n+    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n         use rustc::mir::Place::*;\n         let place = match *mir_place {\n-            Local(mir::RETURN_PLACE) => self.frame().return_place,\n-            Local(local) => Place::Local {\n-                frame: self.cur_frame(),\n-                local,\n+            Local(mir::RETURN_PLACE) => PlaceTy {\n+                place: self.frame().return_place,\n+                layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n+            },\n+            Local(local) => PlaceTy {\n+                place: Place::Local {\n+                    frame: self.cur_frame(),\n+                    local,\n+                },\n+                layout: self.layout_of_local(self.cur_frame(), local)?,\n             },\n \n             Promoted(ref promoted) => {\n                 let instance = self.frame().instance;\n-                let val = self.read_global_as_value(GlobalId {\n+                let op = self.global_to_op(GlobalId {\n                     instance,\n                     promoted: Some(promoted.0),\n                 })?;\n-                if let Value::ByRef(ptr, align) = val {\n-                    Place::Ptr {\n-                        ptr: ptr.into(),\n-                        align,\n-                        extra: PlaceExtra::None,\n-                    }\n-                } else {\n-                    bug!(\"evaluated promoted and got {:#?}\", val);\n+                let mplace = op.to_mem_place();\n+                let ty = self.monomorphize(promoted.1, self.substs());\n+                PlaceTy {\n+                    place: Place::Ptr(mplace),\n+                    layout: self.layout_of(ty)?,\n                 }\n             }\n \n             Static(ref static_) => {\n-                let layout = self.layout_of(self.place_ty(mir_place))?;\n+                let ty = self.monomorphize(static_.ty, self.substs());\n+                let layout = self.layout_of(ty)?;\n                 let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n                 let cid = GlobalId {\n                     instance,\n                     promoted: None\n                 };\n                 let alloc = Machine::init_static(self, cid)?;\n-                Place::Ptr {\n-                    ptr: ScalarMaybeUndef::Scalar(Scalar::Ptr(alloc.into())),\n-                    align: layout.align,\n-                    extra: PlaceExtra::None,\n-                }\n+                MPlaceTy::from_aligned_ptr(alloc.into(), layout).into()\n             }\n \n             Projection(ref proj) => {\n-                let ty = self.place_ty(&proj.base);\n                 let place = self.eval_place(&proj.base)?;\n-                return self.eval_place_projection(place, ty, &proj.elem);\n+                self.place_projection(place, &proj.elem)?\n             }\n         };\n \n-        self.dump_local(place);\n+        self.dump_place(place.place);\n \n         Ok(place)\n     }\n \n-    pub fn place_field(\n+    /// Write a scalar to a place\n+    pub fn write_scalar(\n         &mut self,\n-        base: Place,\n-        field: mir::Field,\n-        mut base_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Place, TyLayout<'tcx>)> {\n-        match base {\n-            Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } => {\n-                base_layout = base_layout.for_variant(&self, variant_index);\n-            }\n-            _ => {}\n-        }\n-        let field_index = field.index();\n-        let field = base_layout.field(&self, field_index)?;\n-        let offset = base_layout.fields.offset(field_index);\n+        val: impl Into<ScalarMaybeUndef>,\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        self.write_value(Value::Scalar(val.into()), dest)\n+    }\n \n-        // Do not allocate in trivial cases\n-        let (base_ptr, base_align, base_extra) = match base {\n-            Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n+    /// Write a value to a place\n+    pub fn write_value(\n+        &mut self,\n+        src_val: Value,\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"write_value: {:?} <- {:?}\", *dest, src_val);\n+        // See if we can avoid an allocation. This is the counterpart to `try_read_value`,\n+        // but not factored as a separate function.\n+        let mplace = match dest.place {\n             Place::Local { frame, local } => {\n-                match (self.stack[frame].locals[local].access()?, &base_layout.abi) {\n-                    // in case the field covers the entire type, just return the value\n-                    (Value::Scalar(_), &layout::Abi::Scalar(_)) |\n-                    (Value::ScalarPair(..), &layout::Abi::ScalarPair(..))\n-                    if offset.bytes() == 0 && field.size == base_layout.size => {\n-                        return Ok((base, field))\n+                match *self.stack[frame].locals[local].access_mut()? {\n+                    Operand::Immediate(ref mut dest_val) => {\n+                        // Yay, we can just change the local directly.\n+                        *dest_val = src_val;\n+                        return Ok(());\n                     },\n-                    _ => self.force_allocation(base)?.to_ptr_align_extra(),\n+                    Operand::Indirect(mplace) => mplace, // already in memory\n                 }\n-            }\n+            },\n+            Place::Ptr(mplace) => mplace, // already in memory\n         };\n \n-        let offset = match base_extra {\n-            PlaceExtra::Vtable(tab) => {\n-                let (_, align) = self.size_and_align_of_dst(\n-                    base_layout.ty,\n-                    base_ptr.to_value_with_vtable(tab),\n-                )?;\n-                offset.abi_align(align)\n+        // This is already in memory, write there.\n+        let dest = MPlaceTy { mplace, layout: dest.layout };\n+        self.write_value_to_mplace(src_val, dest)\n+    }\n+\n+    /// Write a value to memory\n+    fn write_value_to_mplace(\n+        &mut self,\n+        value: Value,\n+        dest: MPlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        let (ptr, ptr_align) = dest.to_scalar_ptr_align();\n+        // Note that it is really important that the type here is the right one, and matches the type things are read at.\n+        // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n+        // correct if we never look at this data with the wrong type.\n+\n+        // Nothing to do for ZSTs, other than checking alignment\n+        if dest.layout.size.bytes() == 0 {\n+            self.memory.check_align(ptr, ptr_align)?;\n+            return Ok(());\n+        }\n+\n+        let ptr = ptr.to_ptr()?;\n+        match value {\n+            Value::Scalar(scalar) => {\n+                self.memory.write_scalar(\n+                    ptr, ptr_align.min(dest.layout.align), scalar, dest.layout.size\n+                )\n             }\n-            _ => offset,\n-        };\n+            Value::ScalarPair(a_val, b_val) => {\n+                let (a, b) = match dest.layout.abi {\n+                    layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n+                    _ => bug!(\"write_value_to_mplace: invalid ScalarPair layout: {:#?}\", dest.layout)\n+                };\n+                let (a_size, b_size) = (a.size(&self), b.size(&self));\n+                let (a_align, b_align) = (a.align(&self), b.align(&self));\n+                let b_offset = a_size.abi_align(b_align);\n+                let b_ptr = ptr.offset(b_offset, &self)?.into();\n \n-        let ptr = base_ptr.ptr_offset(offset, &self)?;\n-        let align = base_align.min(base_layout.align).min(field.align);\n-        let extra = if !field.is_unsized() {\n-            PlaceExtra::None\n-        } else {\n-            match base_extra {\n-                PlaceExtra::None => bug!(\"expected fat pointer\"),\n-                PlaceExtra::DowncastVariant(..) => {\n-                    bug!(\"Rust doesn't support unsized fields in enum variants\")\n-                }\n-                PlaceExtra::Vtable(_) |\n-                PlaceExtra::Length(_) => {}\n+                self.memory.write_scalar(ptr, ptr_align.min(a_align), a_val, a_size)?;\n+                self.memory.write_scalar(b_ptr, ptr_align.min(b_align), b_val, b_size)\n             }\n-            base_extra\n-        };\n+        }\n+    }\n \n-        Ok((Place::Ptr { ptr, align, extra }, field))\n+    /// Copy the data from an operand to a place\n+    pub fn copy_op(\n+        &mut self,\n+        src: OpTy<'tcx>,\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        assert_eq!(src.layout.size, dest.layout.size,\n+            \"Size mismatch when copying!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+\n+        // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n+        let (src_ptr, src_align) = match self.try_read_value(src)? {\n+            Ok(src_val) =>\n+                // Yay, we got a value that we can write directly.  We write with the\n+                // *source layout*, because that was used to load, and if they do not match\n+                // this is a transmute we want to support.\n+                return self.write_value(src_val, PlaceTy { place: *dest, layout: src.layout }),\n+            Err(mplace) => mplace.to_scalar_ptr_align(),\n+        };\n+        // Slow path, this does not fit into an immediate. Just memcpy.\n+        trace!(\"copy_op: {:?} <- {:?}\", *dest, *src);\n+        let (dest_ptr, dest_align) = self.force_allocation(dest)?.to_scalar_ptr_align();\n+        self.memory.copy(\n+            src_ptr, src_align,\n+            dest_ptr, dest_align,\n+            src.layout.size, false\n+        )\n     }\n \n-    pub fn val_to_place(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Place> {\n-        let layout = self.layout_of(ty)?;\n-        Ok(match self.tcx.struct_tail(ty).sty {\n-            ty::TyDynamic(..) => {\n-                let (ptr, vtable) = self.into_ptr_vtable_pair(val)?;\n-                Place::Ptr {\n-                    ptr,\n-                    align: layout.align,\n-                    extra: PlaceExtra::Vtable(vtable),\n-                }\n-            }\n-            ty::TyStr | ty::TySlice(_) => {\n-                let (ptr, len) = self.into_slice(val)?;\n-                Place::Ptr {\n-                    ptr,\n-                    align: layout.align,\n-                    extra: PlaceExtra::Length(len),\n-                }\n+    /// Make sure that a place is in memory, and return where it is.\n+    /// This is essentially `force_to_memplace`.\n+    pub fn force_allocation(\n+        &mut self,\n+        place: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        let mplace = match place.place {\n+            Place::Local { frame, local } => {\n+                // FIXME: Consider not doing anything for a ZST, and just returning\n+                // a fake pointer?\n+\n+                // We need the layout of the local.  We can NOT use the layout we got,\n+                // that might e.g. be a downcast variant!\n+                let local_layout = self.layout_of_local(frame, local)?;\n+                // Make sure it has a place\n+                let rval = *self.stack[frame].locals[local].access()?;\n+                let mplace = self.allocate_op(OpTy { op: rval, layout: local_layout })?.mplace;\n+                // This might have allocated the flag\n+                *self.stack[frame].locals[local].access_mut()? =\n+                    Operand::Indirect(mplace);\n+                // done\n+                mplace\n             }\n-            _ => Place::from_scalar_ptr(self.into_ptr(val)?, layout.align),\n-        })\n+            Place::Ptr(mplace) => mplace\n+        };\n+        // Return with the original layout, so that the caller can go on\n+        Ok(MPlaceTy { mplace, layout: place.layout })\n     }\n \n-    pub fn place_index(\n+    pub fn allocate(\n         &mut self,\n-        base: Place,\n-        outer_ty: Ty<'tcx>,\n-        n: u64,\n-    ) -> EvalResult<'tcx, Place> {\n-        // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n-        let base = self.force_allocation(base)?;\n-        let (base_ptr, align) = base.to_ptr_align();\n-\n-        let (elem_ty, len) = base.elem_ty_and_len(outer_ty, self.tcx.tcx);\n-        let elem_size = self.layout_of(elem_ty)?.size;\n-        assert!(\n-            n < len,\n-            \"Tried to access element {} of array/slice with length {}\",\n-            n,\n-            len\n-        );\n-        let ptr = base_ptr.ptr_offset(elem_size * n, &*self)?;\n-        Ok(Place::Ptr {\n-            ptr,\n-            align,\n-            extra: PlaceExtra::None,\n-        })\n+        layout: TyLayout<'tcx>,\n+        kind: MemoryKind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n+        let ptr = self.memory.allocate(layout.size, layout.align, kind)?;\n+        Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }\n \n-    pub(super) fn place_downcast(\n+    /// Make a place for an operand, allocating if needed\n+    pub fn allocate_op(\n         &mut self,\n-        base: Place,\n-        variant: usize,\n-    ) -> EvalResult<'tcx, Place> {\n-        // FIXME(solson)\n-        let base = self.force_allocation(base)?;\n-        let (ptr, align) = base.to_ptr_align();\n-        let extra = PlaceExtra::DowncastVariant(variant);\n-        Ok(Place::Ptr { ptr, align, extra })\n+        OpTy { op, layout }: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        Ok(match op {\n+            Operand::Indirect(mplace) => MPlaceTy { mplace, layout },\n+            Operand::Immediate(value) => {\n+                // FIXME: Is stack always right here?\n+                let ptr = self.allocate(layout, MemoryKind::Stack)?;\n+                self.write_value_to_mplace(value, ptr)?;\n+                ptr\n+            },\n+        })\n     }\n \n-    pub fn eval_place_projection(\n+    pub fn write_discriminant_value(\n         &mut self,\n-        base: Place,\n-        base_ty: Ty<'tcx>,\n-        proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n-    ) -> EvalResult<'tcx, Place> {\n-        use rustc::mir::ProjectionElem::*;\n-        match *proj_elem {\n-            Field(field, _) => {\n-                let layout = self.layout_of(base_ty)?;\n-                Ok(self.place_field(base, field, layout)?.0)\n-            }\n-\n-            Downcast(_, variant) => {\n-                self.place_downcast(base, variant)\n-            }\n-\n-            Deref => {\n-                let val = self.read_place(base)?;\n-\n-                let pointee_type = match base_ty.sty {\n-                    ty::TyRawPtr(ref tam) => tam.ty,\n-                    ty::TyRef(_, ty, _) => ty,\n-                    ty::TyAdt(def, _) if def.is_box() => base_ty.boxed_ty(),\n-                    _ => bug!(\"can only deref pointer types\"),\n-                };\n-\n-                trace!(\"deref to {} on {:?}\", pointee_type, val);\n-\n-                self.val_to_place(val, pointee_type)\n+        variant_index: usize,\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        match dest.layout.variants {\n+            layout::Variants::Single { index } => {\n+                if index != variant_index {\n+                    // If the layout of an enum is `Single`, all\n+                    // other variants are necessarily uninhabited.\n+                    assert_eq!(dest.layout.for_variant(&self, variant_index).abi,\n+                               layout::Abi::Uninhabited);\n+                }\n             }\n-\n-            Index(local) => {\n-                let value = self.frame().locals[local].access()?;\n-                let ty = self.tcx.types.usize;\n-                let n = self\n-                    .value_to_scalar(ValTy { value, ty })?\n-                    .to_bits(self.tcx.data_layout.pointer_size)?;\n-                self.place_index(base, base_ty, n as u64)\n+            layout::Variants::Tagged { ref tag, .. } => {\n+                let discr_val = dest.layout.ty.ty_adt_def().unwrap()\n+                    .discriminant_for_variant(*self.tcx, variant_index)\n+                    .val;\n+\n+                // raw discriminants for enums are isize or bigger during\n+                // their computation, but the in-memory tag is the smallest possible\n+                // representation\n+                let size = tag.value.size(self.tcx.tcx);\n+                let shift = 128 - size.bits();\n+                let discr_val = (discr_val << shift) >> shift;\n+\n+                let discr_dest = self.place_field(dest, 0)?;\n+                self.write_scalar(Scalar::Bits {\n+                    bits: discr_val,\n+                    size: size.bytes() as u8,\n+                }, discr_dest)?;\n             }\n-\n-            ConstantIndex {\n-                offset,\n-                min_length,\n-                from_end,\n+            layout::Variants::NicheFilling {\n+                dataful_variant,\n+                ref niche_variants,\n+                niche_start,\n+                ..\n             } => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, align) = base.to_ptr_align();\n-\n-                let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n-                let elem_size = self.layout_of(elem_ty)?.size;\n-                assert!(n >= min_length as u64);\n-\n-                let index = if from_end {\n-                    n - u64::from(offset)\n-                } else {\n-                    u64::from(offset)\n-                };\n-\n-                let ptr = base_ptr.ptr_offset(elem_size * index, &self)?;\n-                Ok(Place::Ptr { ptr, align, extra: PlaceExtra::None })\n+                if variant_index != dataful_variant {\n+                    let niche_dest =\n+                        self.place_field(dest, 0)?;\n+                    let niche_value = ((variant_index - niche_variants.start()) as u128)\n+                        .wrapping_add(niche_start);\n+                    self.write_scalar(Scalar::Bits {\n+                        bits: niche_value,\n+                        size: niche_dest.layout.size.bytes() as u8,\n+                    }, niche_dest)?;\n+                }\n             }\n+        }\n \n-            Subslice { from, to } => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, align) = base.to_ptr_align();\n-\n-                let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n-                let elem_size = self.layout_of(elem_ty)?.size;\n-                assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.ptr_offset(elem_size * u64::from(from), &self)?;\n-                // sublicing arrays produces arrays\n-                let extra = if self.type_is_sized(base_ty) {\n-                    PlaceExtra::None\n-                } else {\n-                    PlaceExtra::Length(n - u64::from(to) - u64::from(from))\n-                };\n-                Ok(Place::Ptr { ptr, align, extra })\n+        Ok(())\n+    }\n+\n+    /// Every place can be read from, so we can turm them into an operand\n+    #[inline(always)]\n+    pub fn place_to_op(&self, place: PlaceTy<'tcx>) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        let op = match place.place {\n+            Place::Ptr(mplace) => {\n+                Operand::Indirect(mplace)\n             }\n-        }\n+            Place::Local { frame, local } =>\n+                *self.stack[frame].locals[local].access()?\n+        };\n+        Ok(OpTy { op, layout: place.layout })\n     }\n \n-    pub fn place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(\n-            place.ty(self.mir(), *self.tcx).to_ty(*self.tcx),\n-            self.substs(),\n-        )\n+    /// Turn a place that is a dyn trait (i.e., PlaceExtra::Vtable and the appropriate layout)\n+    /// or a slice into the specific fixed-size place and layout that is given by the vtable/len.\n+    /// This \"unpacks\" the existential quantifier, so to speak.\n+    pub fn unpack_unsized_mplace(&self, mplace: MPlaceTy<'tcx>) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        trace!(\"Unpacking {:?} ({:?})\", *mplace, mplace.layout.ty);\n+        let layout = match mplace.extra {\n+            PlaceExtra::Vtable(vtable) => {\n+                // the drop function signature\n+                let drop_instance = self.read_drop_type_from_vtable(vtable)?;\n+                trace!(\"Found drop fn: {:?}\", drop_instance);\n+                let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n+                let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n+                // the drop function takes *mut T where T is the type being dropped, so get that\n+                let ty = fn_sig.inputs()[0].builtin_deref(true).unwrap().ty;\n+                let layout = self.layout_of(ty)?;\n+                // Sanity checks\n+                let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n+                assert_eq!(size, layout.size);\n+                assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n+                // FIXME: More checks for the vtable? We could make sure it is exactly\n+                // the one one would expect for this type.\n+                // Done!\n+                layout\n+            },\n+            PlaceExtra::Length(len) => {\n+                let ty = self.tcx.mk_array(mplace.layout.field(self, 0)?.ty, len);\n+                self.layout_of(ty)?\n+            }\n+            PlaceExtra::None => bug!(\"Expected a fat pointer\"),\n+        };\n+        trace!(\"Unpacked type: {:?}\", layout.ty);\n+        Ok(MPlaceTy {\n+            mplace: MemPlace { extra: PlaceExtra::None, ..*mplace },\n+            layout\n+        })\n     }\n }"}, {"sha": "f39a5ee3e4ef23929db5e20e6581935fae1b3435", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 193, "deletions": 7, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -3,10 +3,38 @@\n //! The main entry point is the `step` method.\n \n use rustc::mir;\n+use rustc::ty::layout::LayoutOf;\n+use rustc::mir::interpret::{EvalResult, Scalar};\n \n-use rustc::mir::interpret::EvalResult;\n use super::{EvalContext, Machine};\n \n+/// Classify whether an operator is \"left-homogeneous\", i.e. the LHS has the\n+/// same type as the result.\n+#[inline]\n+fn binop_left_homogeneous(op: mir::BinOp) -> bool {\n+    use rustc::mir::BinOp::*;\n+    match op {\n+        Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr |\n+        Offset | Shl | Shr =>\n+            true,\n+        Eq | Ne | Lt | Le | Gt | Ge =>\n+            false,\n+    }\n+}\n+/// Classify whether an operator is \"right-homogeneous\", i.e. the RHS has the\n+/// same type as the LHS.\n+#[inline]\n+fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n+    use rustc::mir::BinOp::*;\n+    match op {\n+        Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr |\n+        Eq | Ne | Lt | Le | Gt | Ge =>\n+            true,\n+        Offset | Shl | Shr =>\n+            false,\n+    }\n+}\n+\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn inc_step_counter_and_detect_loops(&mut self) -> EvalResult<'tcx, ()> {\n         /// The number of steps between loop detector snapshots.\n@@ -66,7 +94,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<'tcx> {\n-        trace!(\"{:?}\", stmt);\n+        debug!(\"{:?}\", stmt);\n \n         use rustc::mir::StatementKind::*;\n \n@@ -84,8 +112,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 variant_index,\n             } => {\n                 let dest = self.eval_place(place)?;\n-                let dest_ty = self.place_ty(place);\n-                self.write_discriminant_value(dest_ty, dest, variant_index)?;\n+                self.write_discriminant_value(variant_index, dest)?;\n             }\n \n             // Mark locals as alive\n@@ -96,7 +123,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             // Mark locals as dead\n             StorageDead(local) => {\n-                let old_val = self.frame_mut().storage_dead(local);\n+                let old_val = self.storage_dead(local);\n                 self.deallocate_local(old_val)?;\n             }\n \n@@ -127,13 +154,172 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n+    /// Evaluate an assignment statement.\n+    ///\n+    /// There is no separate `eval_rvalue` function. Instead, the code for handling each rvalue\n+    /// type writes its results directly into the memory specified by the place.\n+    fn eval_rvalue_into_place(\n+        &mut self,\n+        rvalue: &mir::Rvalue<'tcx>,\n+        place: &mir::Place<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        let dest = self.eval_place(place)?;\n+\n+        use rustc::mir::Rvalue::*;\n+        match *rvalue {\n+            Use(ref operand) => {\n+                // Avoid recomputing the layout\n+                let op = self.eval_operand(operand, Some(dest.layout))?;\n+                self.copy_op(op, dest)?;\n+            }\n+\n+            BinaryOp(bin_op, ref left, ref right) => {\n+                let layout = if binop_left_homogeneous(bin_op) { Some(dest.layout) } else { None };\n+                let left = self.eval_operand_and_read_value(left, layout)?;\n+                let layout = if binop_right_homogeneous(bin_op) { Some(left.layout) } else { None };\n+                let right = self.eval_operand_and_read_value(right, layout)?;\n+                self.binop_ignore_overflow(\n+                    bin_op,\n+                    left,\n+                    right,\n+                    dest,\n+                )?;\n+            }\n+\n+            CheckedBinaryOp(bin_op, ref left, ref right) => {\n+                // Due to the extra boolean in the result, we can never reuse the `dest.layout`.\n+                let left = self.eval_operand_and_read_value(left, None)?;\n+                let layout = if binop_right_homogeneous(bin_op) { Some(left.layout) } else { None };\n+                let right = self.eval_operand_and_read_value(right, layout)?;\n+                self.binop_with_overflow(\n+                    bin_op,\n+                    left,\n+                    right,\n+                    dest,\n+                )?;\n+            }\n+\n+            UnaryOp(un_op, ref operand) => {\n+                // The operand always has the same type as the result.\n+                let val = self.eval_operand_and_read_value(operand, Some(dest.layout))?;\n+                let val = self.unary_op(un_op, val.to_scalar()?, dest.layout)?;\n+                self.write_scalar(val, dest)?;\n+            }\n+\n+            Aggregate(ref kind, ref operands) => {\n+                let (dest, active_field_index) = match **kind {\n+                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n+                        self.write_discriminant_value(variant_index, dest)?;\n+                        if adt_def.is_enum() {\n+                            (self.place_downcast(dest, variant_index)?, active_field_index)\n+                        } else {\n+                            (dest, active_field_index)\n+                        }\n+                    }\n+                    _ => (dest, None)\n+                };\n+\n+                for (i, operand) in operands.iter().enumerate() {\n+                    let op = self.eval_operand(operand, None)?;\n+                    // Ignore zero-sized fields.\n+                    if !op.layout.is_zst() {\n+                        let field_index = active_field_index.unwrap_or(i);\n+                        let field_dest = self.place_field(dest, field_index as u64)?;\n+                        self.copy_op(op, field_dest)?;\n+                    }\n+                }\n+            }\n+\n+            Repeat(ref operand, _) => {\n+                let op = self.eval_operand(operand, None)?;\n+                let dest = self.force_allocation(dest)?;\n+                let length = dest.len();\n+\n+                if length > 0 {\n+                    // write the first\n+                    let first = self.mplace_field(dest, 0)?;\n+                    self.copy_op(op, first.into())?;\n+\n+                    if length > 1 {\n+                        // copy the rest\n+                        let (dest, dest_align) = first.to_scalar_ptr_align();\n+                        let rest = dest.ptr_offset(first.layout.size, &self)?;\n+                        self.memory.copy_repeatedly(\n+                            dest, dest_align, rest, dest_align, first.layout.size, length - 1, true\n+                        )?;\n+                    }\n+                }\n+            }\n+\n+            Len(ref place) => {\n+                // FIXME(CTFE): don't allow computing the length of arrays in const eval\n+                let src = self.eval_place(place)?;\n+                let mplace = self.force_allocation(src)?;\n+                let len = mplace.len();\n+                let size = self.memory.pointer_size().bytes() as u8;\n+                self.write_scalar(\n+                    Scalar::Bits {\n+                        bits: len as u128,\n+                        size,\n+                    },\n+                    dest,\n+                )?;\n+            }\n+\n+            Ref(_, _, ref place) => {\n+                let src = self.eval_place(place)?;\n+                let val = self.force_allocation(src)?.to_ref(&self);\n+                self.write_value(val, dest)?;\n+            }\n+\n+            NullaryOp(mir::NullOp::Box, _) => {\n+                M::box_alloc(self, dest)?;\n+            }\n+\n+            NullaryOp(mir::NullOp::SizeOf, ty) => {\n+                let ty = self.monomorphize(ty, self.substs());\n+                let layout = self.layout_of(ty)?;\n+                assert!(!layout.is_unsized(),\n+                        \"SizeOf nullary MIR operator called for unsized type\");\n+                let size = self.memory.pointer_size().bytes() as u8;\n+                self.write_scalar(\n+                    Scalar::Bits {\n+                        bits: layout.size.bytes() as u128,\n+                        size,\n+                    },\n+                    dest,\n+                )?;\n+            }\n+\n+            Cast(kind, ref operand, cast_ty) => {\n+                debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest.layout.ty);\n+                let src = self.eval_operand(operand, None)?;\n+                self.cast(src, kind, dest)?;\n+            }\n+\n+            Discriminant(ref place) => {\n+                let place = self.eval_place(place)?;\n+                let discr_val = self.read_discriminant_value(self.place_to_op(place)?)?;\n+                let size = dest.layout.size.bytes() as u8;\n+                self.write_scalar(Scalar::Bits {\n+                    bits: discr_val,\n+                    size,\n+                }, dest)?;\n+            }\n+        }\n+\n+        self.dump_place(*dest);\n+\n+        Ok(())\n+    }\n+\n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx> {\n-        trace!(\"{:?}\", terminator.kind);\n+        debug!(\"{:?}\", terminator.kind);\n         self.tcx.span = terminator.source_info.span;\n         self.memory.tcx.span = terminator.source_info.span;\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n-            trace!(\"// {:?}\", self.frame().block);\n+            debug!(\"// {:?}\", self.frame().block);\n         }\n         Ok(())\n     }"}, {"sha": "e044df2d1c0f972f68274be8762438863fc42b04", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 28, "deletions": 51, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1,77 +1,54 @@\n use rustc::mir::BasicBlock;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, layout::LayoutOf};\n use syntax::source_map::Span;\n \n-use rustc::mir::interpret::{EvalResult, Value};\n-use interpret::{Machine, ValTy, EvalContext, Place, PlaceExtra};\n+use rustc::mir::interpret::EvalResult;\n+use interpret::{Machine, EvalContext, PlaceTy, PlaceExtra, OpTy, Operand};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub(crate) fn drop_place(\n+    pub(crate) fn drop_in_place(\n         &mut self,\n-        place: Place,\n+        place: PlaceTy<'tcx>,\n         instance: ty::Instance<'tcx>,\n-        ty: Ty<'tcx>,\n         span: Span,\n         target: BasicBlock,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"drop_place: {:#?}\", place);\n+        trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n         // We take the address of the object.  This may well be unaligned, which is fine for us here.\n         // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared\n         // by rustc.\n-        let val = match self.force_allocation(place)? {\n-            Place::Ptr {\n-                ptr,\n-                align: _,\n-                extra: PlaceExtra::Vtable(vtable),\n-            } => ptr.to_value_with_vtable(vtable),\n-            Place::Ptr {\n-                ptr,\n-                align: _,\n-                extra: PlaceExtra::Length(len),\n-            } => ptr.to_value_with_len(len, self.tcx.tcx),\n-            Place::Ptr {\n-                ptr,\n-                align: _,\n-                extra: PlaceExtra::None,\n-            } => Value::Scalar(ptr),\n-            _ => bug!(\"force_allocation broken\"),\n-        };\n-        self.drop(val, instance, ty, span, target)\n-    }\n+        let place = self.force_allocation(place)?;\n \n-    fn drop(\n-        &mut self,\n-        arg: Value,\n-        instance: ty::Instance<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-        target: BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"drop: {:#?}, {:?}, {:?}\", arg, ty.sty, instance.def);\n-\n-        let instance = match ty.sty {\n+        let (instance, place) = match place.layout.ty.sty {\n             ty::TyDynamic(..) => {\n-                if let Value::ScalarPair(_, vtable) = arg {\n-                    self.read_drop_type_from_vtable(vtable.unwrap_or_err()?.to_ptr()?)?\n-                } else {\n-                    bug!(\"expected fat ptr, got {:?}\", arg);\n-                }\n+                // Dropping a trait object.\n+                let vtable = match place.extra {\n+                    PlaceExtra::Vtable(vtable) => vtable,\n+                    _ => bug!(\"Expected vtable when dropping {:#?}\", place),\n+                };\n+                let place = self.unpack_unsized_mplace(place)?;\n+                let instance = self.read_drop_type_from_vtable(vtable)?;\n+                (instance, place)\n             }\n-            _ => instance,\n+            _ => (instance, place),\n         };\n \n-        // the drop function expects a reference to the value\n-        let valty = ValTy {\n-            value: arg,\n-            ty: self.tcx.mk_mut_ptr(ty),\n+        let fn_sig = instance.ty(*self.tcx).fn_sig(*self.tcx);\n+        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n+\n+        let arg = OpTy {\n+            op: Operand::Immediate(place.to_ref(&self)),\n+            layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n \n-        let fn_sig = self.tcx.fn_sig(instance.def_id()).skip_binder().clone();\n+        // This should always be (), but getting it from the sig seems\n+        // easier than creating a layout of ().\n+        let dest = PlaceTy::null(&self, self.layout_of(fn_sig.output())?);\n \n         self.eval_fn_call(\n             instance,\n-            Some((Place::undef(), target)),\n-            &[valty],\n+            Some((dest, target)),\n+            &[arg],\n             span,\n             fn_sig,\n         )"}, {"sha": "82455cacac2d4c759e2e487439068f88d20b3304", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 69, "deletions": 73, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1,14 +1,13 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{LayoutOf, Size};\n+use rustc::ty::layout::LayoutOf;\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, Scalar, Value};\n-use super::{EvalContext, Place, Machine, ValTy};\n+use rustc::mir::interpret::{EvalResult, Scalar};\n+use super::{EvalContext, Machine, Value, OpTy, PlaceTy, ValTy, Operand};\n \n use rustc_data_structures::indexed_vec::Idx;\n-use interpret::memory::HasMemory;\n \n mod drop;\n \n@@ -25,7 +24,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         use rustc::mir::TerminatorKind::*;\n         match terminator.kind {\n             Return => {\n-                self.dump_local(self.frame().return_place);\n+                self.dump_place(self.frame().return_place);\n                 self.pop_stack_frame()?\n             }\n \n@@ -37,22 +36,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 ref targets,\n                 ..\n             } => {\n-                let discr_val = self.eval_operand(discr)?;\n-                let discr_prim = self.value_to_scalar(discr_val)?;\n-                let discr_layout = self.layout_of(discr_val.ty).unwrap();\n-                trace!(\"SwitchInt({:?}, {:#?})\", discr_prim, discr_layout);\n+                let discr_val = self.eval_operand(discr, None)?;\n+                let discr = self.read_value(discr_val)?;\n+                trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n                     // Compare using binary_op\n-                    let const_int = Scalar::Bits { bits: const_int, size: discr_layout.size.bytes() as u8 };\n-                    let res = self.binary_op(mir::BinOp::Eq,\n-                        discr_prim, discr_val.ty,\n-                        const_int, discr_val.ty\n+                    let const_int = Scalar::Bits { bits: const_int, size: discr.layout.size.bytes() as u8 };\n+                    let (res, _) = self.binary_op(mir::BinOp::Eq,\n+                        discr,\n+                        ValTy { value: Value::Scalar(const_int.into()), layout: discr.layout }\n                     )?;\n-                    if res.0.to_bits(Size::from_bytes(1))? != 0 {\n+                    if res.to_bool()? {\n                         target_block = targets[index];\n                         break;\n                     }\n@@ -72,10 +70,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     None => None,\n                 };\n \n-                let func = self.eval_operand(func)?;\n-                let (fn_def, sig) = match func.ty.sty {\n+                let func = self.eval_operand(func, None)?;\n+                let (fn_def, sig) = match func.layout.ty.sty {\n                     ty::TyFnPtr(sig) => {\n-                        let fn_ptr = self.value_to_scalar(func)?.to_ptr()?;\n+                        let fn_ptr = self.read_scalar(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n                         let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n@@ -99,22 +97,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     }\n                     ty::TyFnDef(def_id, substs) => (\n                         self.resolve(def_id, substs)?,\n-                        func.ty.fn_sig(*self.tcx),\n+                        func.layout.ty.fn_sig(*self.tcx),\n                     ),\n                     _ => {\n-                        let msg = format!(\"can't handle callee of type {:?}\", func.ty);\n+                        let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n                         return err!(Unimplemented(msg));\n                     }\n                 };\n-                let args = self.operands_to_args(args)?;\n+                let args = self.eval_operands(args)?;\n                 let sig = self.tcx.normalize_erasing_late_bound_regions(\n                     ty::ParamEnv::reveal_all(),\n                     &sig,\n                 );\n                 self.eval_fn_call(\n                     fn_def,\n                     destination,\n-                    &args,\n+                    &args[..],\n                     terminator.source_info.span,\n                     sig,\n                 )?;\n@@ -127,19 +125,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             } => {\n                 // FIXME(CTFE): forbid drop in const eval\n                 let place = self.eval_place(location)?;\n-                let ty = self.place_ty(location);\n-                let ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    self.substs(),\n-                    ty::ParamEnv::reveal_all(),\n-                    &ty,\n-                );\n+                let ty = place.layout.ty;\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n \n                 let instance = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n-                self.drop_place(\n+                self.drop_in_place(\n                     place,\n                     instance,\n-                    ty,\n                     terminator.source_info.span,\n                     target,\n                 )?;\n@@ -152,18 +144,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 target,\n                 ..\n             } => {\n-                let cond_val = self.eval_operand_to_scalar(cond)?.to_bool()?;\n+                let cond_val = self.eval_operand_and_read_value(cond, None)?.to_scalar()?.to_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let len = self.eval_operand_to_scalar(len)\n-                                .expect(\"can't eval len\")\n+                            let len = self.eval_operand_and_read_value(len, None)\n+                                .expect(\"can't eval len\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            let index = self.eval_operand_to_scalar(index)\n-                                .expect(\"can't eval index\")\n+                            let index = self.eval_operand_and_read_value(index, None)\n+                                .expect(\"can't eval index\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n                             err!(BoundsCheck { len, index })\n                         }\n@@ -259,54 +251,55 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Place, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n+        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        args: &[OpTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", instance);\n+        if let Some((place, _)) = destination {\n+            assert_eq!(place.layout.ty, sig.output());\n+        }\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 let (ret, target) = match destination {\n                     Some(dest) => dest,\n                     _ => return err!(Unreachable),\n                 };\n-                let ty = sig.output();\n-                let layout = self.layout_of(ty)?;\n-                M::call_intrinsic(self, instance, args, ret, layout, target)?;\n-                self.dump_local(ret);\n+                M::call_intrinsic(self, instance, args, ret, target)?;\n+                self.dump_place(*ret);\n                 Ok(())\n             }\n             // FIXME: figure out why we can't just go through the shim\n             ty::InstanceDef::ClosureOnceShim { .. } => {\n-                if M::eval_fn_call(self, instance, destination, args, span, sig)? {\n+                if M::eval_fn_call(self, instance, destination, args, span)? {\n                     return Ok(());\n                 }\n                 let mut arg_locals = self.frame().mir.args_iter();\n                 match sig.abi {\n                     // closure as closure once\n                     Abi::RustCall => {\n-                        for (arg_local, &valty) in arg_locals.zip(args) {\n+                        for (arg_local, &op) in arg_locals.zip(args) {\n                             let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            self.write_value(valty, dest)?;\n+                            self.copy_op(op, dest)?;\n                         }\n                     }\n                     // non capture closure as fn ptr\n                     // need to inject zst ptr for closure object (aka do nothing)\n                     // and need to pack arguments\n                     Abi::Rust => {\n                         trace!(\n-                            \"arg_locals: {:#?}\",\n-                            self.frame().mir.args_iter().collect::<Vec<_>>()\n+                            \"args: {:#?}\",\n+                            self.frame().mir.args_iter().zip(args.iter())\n+                                .map(|(local, arg)| (local, **arg, arg.layout.ty)).collect::<Vec<_>>()\n                         );\n-                        trace!(\"args: {:#?}\", args);\n                         let local = arg_locals.nth(1).unwrap();\n-                        for (i, &valty) in args.into_iter().enumerate() {\n+                        for (i, &op) in args.into_iter().enumerate() {\n                             let dest = self.eval_place(&mir::Place::Local(local).field(\n                                 mir::Field::new(i),\n-                                valty.ty,\n+                                op.layout.ty,\n                             ))?;\n-                            self.write_value(valty, dest)?;\n+                            self.copy_op(op, dest)?;\n                         }\n                     }\n                     _ => bug!(\"bad ABI for ClosureOnceShim: {:?}\", sig.abi),\n@@ -318,18 +311,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::CloneShim(..) |\n             ty::InstanceDef::Item(_) => {\n                 // Push the stack frame, and potentially be entirely done if the call got hooked\n-                if M::eval_fn_call(self, instance, destination, args, span, sig)? {\n+                if M::eval_fn_call(self, instance, destination, args, span)? {\n+                    // TODO: Can we make it return the frame to push, instead\n+                    // of the hook doing half of the work and us doing the argument\n+                    // initialization?\n                     return Ok(());\n                 }\n \n                 // Pass the arguments\n                 let mut arg_locals = self.frame().mir.args_iter();\n                 trace!(\"ABI: {:?}\", sig.abi);\n                 trace!(\n-                    \"arg_locals: {:#?}\",\n-                    self.frame().mir.args_iter().collect::<Vec<_>>()\n+                    \"args: {:#?}\",\n+                    self.frame().mir.args_iter().zip(args.iter())\n+                        .map(|(local, arg)| (local, **arg, arg.layout.ty)).collect::<Vec<_>>()\n                 );\n-                trace!(\"args: {:#?}\", args);\n                 match sig.abi {\n                     Abi::RustCall => {\n                         assert_eq!(args.len(), 2);\n@@ -338,47 +334,41 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             // write first argument\n                             let first_local = arg_locals.next().unwrap();\n                             let dest = self.eval_place(&mir::Place::Local(first_local))?;\n-                            self.write_value(args[0], dest)?;\n+                            self.copy_op(args[0], dest)?;\n                         }\n \n                         // unpack and write all other args\n-                        let layout = self.layout_of(args[1].ty)?;\n-                        if let ty::TyTuple(_) = args[1].ty.sty {\n+                        let layout = args[1].layout;\n+                        if let ty::TyTuple(_) = layout.ty.sty {\n                             if layout.is_zst() {\n                                 // Nothing to do, no need to unpack zsts\n                                 return Ok(());\n                             }\n                             if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n                                 for (i, arg_local) in arg_locals.enumerate() {\n-                                    let field = mir::Field::new(i);\n-                                    let (value, layout) = self.read_field(args[1].value, None, field, layout)?;\n+                                    let arg = self.operand_field(args[1], i as u64)?;\n                                     let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                                    let valty = ValTy {\n-                                        value,\n-                                        ty: layout.ty,\n-                                    };\n-                                    self.write_value(valty, dest)?;\n+                                    self.copy_op(arg, dest)?;\n                                 }\n                             } else {\n                                 trace!(\"manual impl of rust-call ABI\");\n                                 // called a manual impl of a rust-call function\n                                 let dest = self.eval_place(\n                                     &mir::Place::Local(arg_locals.next().unwrap()),\n                                 )?;\n-                                self.write_value(args[1], dest)?;\n+                                self.copy_op(args[1], dest)?;\n                             }\n                         } else {\n                             bug!(\n-                                \"rust-call ABI tuple argument was {:#?}, {:#?}\",\n-                                args[1].ty,\n+                                \"rust-call ABI tuple argument was {:#?}\",\n                                 layout\n                             );\n                         }\n                     }\n                     _ => {\n-                        for (arg_local, &valty) in arg_locals.zip(args) {\n+                        for (arg_local, &op) in arg_locals.zip(args) {\n                             let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            self.write_value(valty, dest)?;\n+                            self.copy_op(op, dest)?;\n                         }\n                     }\n                 }\n@@ -388,16 +378,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n-                let (ptr, vtable) = self.into_ptr_vtable_pair(args[0].value)?;\n+                let (ptr, vtable) = self.read_value(args[0])?.to_scalar_dyn_trait()?;\n                 let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                     ptr_align\n-                )?.unwrap_or_err()?.to_ptr()?;\n+                )?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n+\n+                // We have to patch the self argument, in particular get the layout\n+                // expected by the actual function. Cannot just use \"field 0\" due to\n+                // Box<self>.\n                 let mut args = args.to_vec();\n-                let ty = self.layout_of(args[0].ty)?.field(&self, 0)?.ty;\n-                args[0].ty = ty;\n-                args[0].value = Value::Scalar(ptr);\n+                let pointee = args[0].layout.ty.builtin_deref(true).unwrap().ty;\n+                let fake_fat_ptr_ty = self.tcx.mk_mut_ptr(pointee);\n+                args[0].layout = self.layout_of(fake_fat_ptr_ty)?.field(&self, 0)?;\n+                args[0].op = Operand::Immediate(Value::Scalar(ptr.into())); // strip vtable\n+                trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(instance, destination, &args, span, sig)\n             }"}, {"sha": "18718cc3dcd6e396b7eef38501d700a0b867df29", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -36,15 +36,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n+        self.memory.write_ptr_sized(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bits {\n+        self.memory.write_ptr_sized(size_ptr, ptr_align, Scalar::Bits {\n             bits: size as u128,\n             size: ptr_size.bytes() as u8,\n         }.into())?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bits {\n+        self.memory.write_ptr_sized(align_ptr, ptr_align, Scalar::Bits {\n             bits: align as u128,\n             size: ptr_size.bytes() as u8,\n         }.into())?;\n@@ -54,7 +54,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n+                self.memory.write_ptr_sized(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n             }\n         }\n \n@@ -72,7 +72,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.unwrap_or_err()?.to_ptr()?;\n+        let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.to_ptr()?;\n         self.memory.get_fn(drop_fn)\n     }\n \n@@ -82,11 +82,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.unwrap_or_err()?.to_bits(pointer_size)? as u64;\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n         let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n-        )?.unwrap_or_err()?.to_bits(pointer_size)? as u64;\n+        )?.to_bits(pointer_size)? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n     }\n }"}, {"sha": "8f0e8196605412446a01b4bd3bbb9f92de2e3fa9", "filename": "src/librustc_mir/interpret/validity.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -0,0 +1,348 @@\n+use std::fmt::Write;\n+\n+use syntax_pos::symbol::Symbol;\n+use rustc::ty::layout::{self, Size, Primitive};\n+use rustc::ty::{self, Ty};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc::mir::interpret::{\n+    Scalar, AllocType, EvalResult, ScalarMaybeUndef, EvalErrorKind\n+};\n+\n+use super::{\n+    MPlaceTy, Machine, EvalContext\n+};\n+\n+macro_rules! validation_failure{\n+    ($what:expr, $where:expr, $details:expr) => {{\n+        let where_ = path_format($where);\n+        let where_ = if where_.is_empty() {\n+            String::new()\n+        } else {\n+            format!(\" at {}\", where_)\n+        };\n+        err!(ValidationFailure(format!(\n+            \"encountered {}{}, but expected {}\",\n+            $what, where_, $details,\n+        )))\n+    }};\n+    ($what:expr, $where:expr) => {{\n+        let where_ = path_format($where);\n+        let where_ = if where_.is_empty() {\n+            String::new()\n+        } else {\n+            format!(\" at {}\", where_)\n+        };\n+        err!(ValidationFailure(format!(\n+            \"encountered {}{}\",\n+            $what, where_,\n+        )))\n+    }};\n+}\n+\n+/// We want to show a nice path to the invalid field for diagnotsics,\n+/// but avoid string operations in the happy case where no error happens.\n+/// So we track a `Vec<PathElem>` where `PathElem` contains all the data we\n+/// need to later print something for the user.\n+#[derive(Copy, Clone, Debug)]\n+pub enum PathElem {\n+    Field(Symbol),\n+    ClosureVar(Symbol),\n+    ArrayElem(usize),\n+    TupleElem(usize),\n+    Deref,\n+    Tag,\n+}\n+\n+// Adding a Deref and making a copy of the path to be put into the queue\n+// always go together.  This one does it with only new allocation.\n+fn path_clone_and_deref(path: &Vec<PathElem>) -> Vec<PathElem> {\n+    let mut new_path = Vec::with_capacity(path.len()+1);\n+    new_path.clone_from(path);\n+    new_path.push(PathElem::Deref);\n+    new_path\n+}\n+\n+/// Format a path\n+fn path_format(path: &Vec<PathElem>) -> String {\n+    use self::PathElem::*;\n+\n+    let mut out = String::new();\n+    for elem in path.iter() {\n+        match elem {\n+            Field(name) => write!(out, \".{}\", name).unwrap(),\n+            ClosureVar(name) => write!(out, \".<closure-var({})>\", name).unwrap(),\n+            TupleElem(idx) => write!(out, \".{}\", idx).unwrap(),\n+            ArrayElem(idx) => write!(out, \"[{}]\", idx).unwrap(),\n+            Deref =>\n+                // This does not match Rust syntax, but it is more readable for long paths -- and\n+                // some of the other items here also are not Rust syntax.  Actually we can't\n+                // even use the usual syntax because we are just showing the projections,\n+                // not the root.\n+                write!(out, \".<deref>\").unwrap(),\n+            Tag => write!(out, \".<enum-tag>\").unwrap(),\n+        }\n+    }\n+    out\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    fn validate_scalar(\n+        &self,\n+        value: ScalarMaybeUndef,\n+        size: Size,\n+        scalar: &layout::Scalar,\n+        path: &Vec<PathElem>,\n+        ty: Ty,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n+        let (lo, hi) = scalar.valid_range.clone().into_inner();\n+\n+        let value = match value {\n+            ScalarMaybeUndef::Scalar(scalar) => scalar,\n+            ScalarMaybeUndef::Undef => return validation_failure!(\"undefined bytes\", path),\n+        };\n+\n+        let bits = match value {\n+            Scalar::Bits { bits, size: value_size } => {\n+                assert_eq!(value_size as u64, size.bytes());\n+                bits\n+            },\n+            Scalar::Ptr(_) => {\n+                let ptr_size = self.memory.pointer_size();\n+                let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n+                return if lo > hi {\n+                    if lo - hi == 1 {\n+                        // no gap, all values are ok\n+                        Ok(())\n+                    } else if hi < ptr_max || lo > 1 {\n+                        let max = u128::max_value() >> (128 - size.bits());\n+                        validation_failure!(\n+                            \"pointer\",\n+                            path,\n+                            format!(\"something in the range {:?} or {:?}\", 0..=lo, hi..=max)\n+                        )\n+                    } else {\n+                        Ok(())\n+                    }\n+                } else if hi < ptr_max || lo > 1 {\n+                    validation_failure!(\n+                        \"pointer\",\n+                        path,\n+                        format!(\"something in the range {:?}\", scalar.valid_range)\n+                    )\n+                } else {\n+                    Ok(())\n+                };\n+            },\n+        };\n+\n+        // char gets a special treatment, because its number space is not contiguous so `TyLayout`\n+        // has no special checks for chars\n+        match ty.sty {\n+            ty::TyChar => {\n+                debug_assert_eq!(size.bytes(), 4);\n+                if ::std::char::from_u32(bits as u32).is_none() {\n+                    return validation_failure!(\n+                        \"character\",\n+                        path,\n+                        \"a valid unicode codepoint\"\n+                    );\n+                }\n+            }\n+            _ => {},\n+        }\n+\n+        use std::ops::RangeInclusive;\n+        let in_range = |bound: RangeInclusive<u128>| bound.contains(&bits);\n+        if lo > hi {\n+            if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n+                Ok(())\n+            } else {\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?} or {:?}\", ..=hi, lo..)\n+                )\n+            }\n+        } else {\n+            if in_range(scalar.valid_range.clone()) {\n+                Ok(())\n+            } else {\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?}\", scalar.valid_range)\n+                )\n+            }\n+        }\n+    }\n+\n+    /// This function checks the memory where `dest` points to.  The place must be sized\n+    /// (i.e., dest.extra == PlaceExtra::None).\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    /// The `path` may be pushed to, but the part that is present when the function\n+    /// starts must not be changed!\n+    pub fn validate_mplace(\n+        &self,\n+        dest: MPlaceTy<'tcx>,\n+        path: &mut Vec<PathElem>,\n+        seen: &mut FxHashSet<(MPlaceTy<'tcx>)>,\n+        todo: &mut Vec<(MPlaceTy<'tcx>, Vec<PathElem>)>,\n+    ) -> EvalResult<'tcx> {\n+        self.memory.dump_alloc(dest.to_ptr()?.alloc_id);\n+        trace!(\"validate_mplace: {:?}, {:#?}\", *dest, dest.layout);\n+\n+        // Find the right variant.  We have to handle this as a prelude, not via\n+        // proper recursion with the new inner layout, to be able to later nicely\n+        // print the field names of the enum field that is being accessed.\n+        let (variant, dest) = match dest.layout.variants {\n+            layout::Variants::NicheFilling { niche: ref tag, .. } |\n+            layout::Variants::Tagged { ref tag, .. } => {\n+                let size = tag.value.size(self);\n+                // we first read the tag value as scalar, to be able to validate it\n+                let tag_mplace = self.mplace_field(dest, 0)?;\n+                let tag_value = self.read_scalar(tag_mplace.into())?;\n+                path.push(PathElem::Tag);\n+                self.validate_scalar(\n+                    tag_value, size, tag, &path, tag_mplace.layout.ty\n+                )?;\n+                path.pop(); // remove the element again\n+                // then we read it again to get the index, to continue\n+                let variant = self.read_discriminant_as_variant_index(dest.into())?;\n+                let inner_dest = self.mplace_downcast(dest, variant)?;\n+                // Put the variant projection onto the path, as a field\n+                path.push(PathElem::Field(dest.layout.ty.ty_adt_def().unwrap().variants[variant].name));\n+                trace!(\"variant layout: {:#?}\", dest.layout);\n+                (variant, inner_dest)\n+            },\n+            layout::Variants::Single { index } => {\n+                (index, dest)\n+            }\n+        };\n+\n+        // Remember the length, in case we need to truncate\n+        let path_len = path.len();\n+\n+        // Validate all fields\n+        match dest.layout.fields {\n+            // primitives are unions with zero fields\n+            // We still check `layout.fields`, not `layout.abi`, because `layout.abi`\n+            // is `Scalar` for newtypes around scalars, but we want to descend through the\n+            // fields to get a proper `path`.\n+            layout::FieldPlacement::Union(0) => {\n+                match dest.layout.abi {\n+                    // nothing to do, whatever the pointer points to, it is never going to be read\n+                    layout::Abi::Uninhabited =>\n+                        return validation_failure!(\"a value of an uninhabited type\", path),\n+                    // check that the scalar is a valid pointer or that its bit range matches the\n+                    // expectation.\n+                    layout::Abi::Scalar(ref scalar_layout) => {\n+                        let size = scalar_layout.value.size(self);\n+                        let value = self.read_value(dest.into())?;\n+                        let scalar = value.to_scalar_or_undef();\n+                        self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n+                        if scalar_layout.value == Primitive::Pointer {\n+                            // ignore integer pointers, we can't reason about the final hardware\n+                            if let Scalar::Ptr(ptr) = scalar.not_undef()? {\n+                                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                                if let Some(AllocType::Static(did)) = alloc_kind {\n+                                    // statics from other crates are already checked.\n+                                    // extern statics should not be validated as they have no body.\n+                                    if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                                        return Ok(());\n+                                    }\n+                                }\n+                                if value.layout.ty.builtin_deref(false).is_some() {\n+                                    trace!(\"Recursing below ptr {:#?}\", value);\n+                                    let ptr_place = self.ref_to_mplace(value)?;\n+                                    // we have not encountered this pointer+layout combination before\n+                                    if seen.insert(ptr_place) {\n+                                        todo.push((ptr_place, path_clone_and_deref(path)));\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    },\n+                    _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", dest.layout.abi),\n+                }\n+            }\n+            layout::FieldPlacement::Union(_) => {\n+                // We can't check unions, their bits are allowed to be anything.\n+                // The fields don't need to correspond to any bit pattern of the union's fields.\n+                // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n+            },\n+            layout::FieldPlacement::Array { .. } => {\n+                for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n+                    let field = field?;\n+                    path.push(PathElem::ArrayElem(i));\n+                    self.validate_mplace(field, path, seen, todo)?;\n+                    path.truncate(path_len);\n+                }\n+            },\n+            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                // Fat pointers need special treatment.\n+                if dest.layout.ty.builtin_deref(true).is_some() {\n+                    // This is a fat pointer.\n+                    let ptr = match self.ref_to_mplace(self.read_value(dest.into())?) {\n+                        Ok(ptr) => ptr,\n+                        Err(err) => match err.kind {\n+                            EvalErrorKind::ReadPointerAsBytes =>\n+                                return validation_failure!(\n+                                    \"fat pointer length is not a valid integer\", path\n+                                ),\n+                            EvalErrorKind::ReadBytesAsPointer =>\n+                                return validation_failure!(\n+                                    \"fat pointer vtable is not a valid pointer\", path\n+                                ),\n+                            _ => return Err(err),\n+                        }\n+                    };\n+                    let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                    // for safe ptrs, recursively check it\n+                    if !dest.layout.ty.is_unsafe_ptr() {\n+                        trace!(\"Recursing below fat ptr {:?} (unpacked: {:?})\", ptr, unpacked_ptr);\n+                        if seen.insert(unpacked_ptr) {\n+                            todo.push((unpacked_ptr, path_clone_and_deref(path)));\n+                        }\n+                    }\n+                } else {\n+                    // Not a pointer, perform regular aggregate handling below\n+                    for i in 0..offsets.len() {\n+                        let field = self.mplace_field(dest, i as u64)?;\n+                        path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n+                        self.validate_mplace(field, path, seen, todo)?;\n+                        path.truncate(path_len);\n+                    }\n+                    // FIXME: For a TyStr, check that this is valid UTF-8.\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn aggregate_field_path_elem(&self, ty: Ty<'tcx>, variant: usize, field: usize) -> PathElem {\n+        match ty.sty {\n+            // generators and closures.\n+            ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n+                let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+                let freevar = self.tcx.with_freevars(node_id, |fv| fv[field]);\n+                PathElem::ClosureVar(self.tcx.hir.name(freevar.var_id()))\n+            }\n+\n+            // tuples\n+            ty::TyTuple(_) => PathElem::TupleElem(field),\n+\n+            // enums\n+            ty::TyAdt(def, ..) if def.is_enum() => {\n+                let variant = &def.variants[variant];\n+                PathElem::Field(variant.fields[field].ident.name)\n+            }\n+\n+            // other ADTs\n+            ty::TyAdt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n+\n+            // nothing else has an aggregate layout\n+            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", ty),\n+        }\n+    }\n+}"}, {"sha": "35b8f63c664fb6139ebe71c280adc1155f80513b", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -37,6 +37,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(step_trait)]\n #![feature(slice_concat_ext)]\n #![feature(if_while_or_patterns)]\n+#![feature(try_from)]\n \n #![recursion_limit=\"256\"]\n \n@@ -82,7 +83,7 @@ pub fn provide(providers: &mut Providers) {\n     shim::provide(providers);\n     transform::provide(providers);\n     providers.const_eval = interpret::const_eval_provider;\n-    providers.const_value_to_allocation = interpret::const_value_to_allocation_provider;\n+    providers.const_to_allocation = interpret::const_to_allocation_provider;\n     providers.check_match = hair::pattern::check_match;\n }\n "}, {"sha": "3f77e69b7dcbe43f8aaf8ed3605692f3d5393575", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -17,16 +17,16 @@ use rustc::mir::{Constant, Location, Place, Mir, Operand, Rvalue, Local};\n use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock, LocalKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext};\n-use rustc::mir::interpret::{ConstEvalErr, EvalErrorKind, ScalarMaybeUndef};\n+use rustc::mir::interpret::{\n+    ConstEvalErr, EvalErrorKind, ScalarMaybeUndef, Scalar, GlobalId, EvalResult\n+};\n use rustc::ty::{TyCtxt, self, Instance};\n-use rustc::mir::interpret::{Value, Scalar, GlobalId, EvalResult};\n-use interpret::EvalContext;\n-use interpret::CompileTimeEvaluator;\n-use interpret::{eval_promoted, mk_borrowck_eval_cx, ValTy};\n+use interpret::{EvalContext, CompileTimeEvaluator, eval_promoted, mk_borrowck_eval_cx};\n+use interpret::{Value, OpTy, MemoryKind};\n use transform::{MirPass, MirSource};\n use syntax::source_map::{Span, DUMMY_SP};\n use rustc::ty::subst::Substs;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::ty::ParamEnv;\n use rustc::ty::layout::{\n     LayoutOf, TyLayout, LayoutError,\n@@ -65,7 +65,7 @@ impl MirPass for ConstProp {\n     }\n }\n \n-type Const<'tcx> = (Value, TyLayout<'tcx>, Span);\n+type Const<'tcx> = (OpTy<'tcx>, Span);\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'b, 'a, 'tcx:'a+'b> {\n@@ -257,10 +257,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match self.ecx.const_to_value(c.literal.val) {\n-            Ok(val) => {\n+        match self.ecx.const_value_to_op(c.literal.val) {\n+            Ok(op) => {\n                 let layout = self.tcx.layout_of(self.param_env.and(c.literal.ty)).ok()?;\n-                Some((val, layout, c.span))\n+                Some((OpTy { op, layout }, c.span))\n             },\n             Err(error) => {\n                 let (stacktrace, span) = self.ecx.generate_stacktrace(None);\n@@ -284,12 +284,15 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _) => {\n                     trace!(\"field proj on {:?}\", proj.base);\n-                    let (base, layout, span) = self.eval_place(&proj.base, source_info)?;\n-                    let valty = self.use_ecx(source_info, |this| {\n-                        this.ecx.read_field(base, None, field, layout)\n+                    let (base, span) = self.eval_place(&proj.base, source_info)?;\n+                    let res = self.use_ecx(source_info, |this| {\n+                        this.ecx.operand_field(base, field.index() as u64)\n                     })?;\n-                    Some((valty.0, valty.1, span))\n+                    Some((res, span))\n                 },\n+                // We could get more projections by using e.g. `operand_projection`,\n+                // but we do not even have the stack frame set up properly so\n+                // an `Index` projection would throw us off-track.\n                 _ => None,\n             },\n             Place::Promoted(ref promoted) => {\n@@ -306,12 +309,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 };\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now\n-                let (value, _, ty) = self.use_ecx(source_info, |this| {\n+                let res = self.use_ecx(source_info, |this| {\n                     eval_promoted(&mut this.ecx, cid, this.mir, this.param_env)\n                 })?;\n-                let val = (value, ty, source_info.span);\n-                trace!(\"evaluated promoted {:?} to {:?}\", promoted, val);\n-                Some(val)\n+                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n+                Some((res, source_info.span))\n             },\n             _ => None,\n         }\n@@ -343,29 +345,25 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Rvalue::Discriminant(..) => None,\n \n             Rvalue::Cast(kind, ref operand, _) => {\n-                let (value, layout, span) = self.eval_operand(operand, source_info)?;\n+                let (op, span) = self.eval_operand(operand, source_info)?;\n                 self.use_ecx(source_info, |this| {\n-                    let dest_ptr = this.ecx.alloc_ptr(place_layout)?;\n-                    let place_align = place_layout.align;\n-                    let dest = ::interpret::Place::from_ptr(dest_ptr, place_align);\n-                    this.ecx.cast(ValTy { value, ty: layout.ty }, kind, place_layout.ty, dest)?;\n-                    Ok((\n-                        Value::ByRef(dest_ptr.into(), place_align),\n-                        place_layout,\n-                        span,\n-                    ))\n+                    let dest = this.ecx.allocate(place_layout, MemoryKind::Stack)?;\n+                    this.ecx.cast(op, kind, dest.into())?;\n+                    Ok((dest.into(), span))\n                 })\n             }\n \n             // FIXME(oli-obk): evaluate static/constant slice lengths\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n-                    Value::Scalar(Scalar::Bits {\n-                        bits: n as u128,\n-                        size: self.tcx.data_layout.pointer_size.bytes() as u8,\n-                    }.into()),\n-                    self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    OpTy::from_scalar_value(\n+                        Scalar::Bits {\n+                            bits: n as u128,\n+                            size: self.tcx.data_layout.pointer_size.bytes() as u8,\n+                        },\n+                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    ),\n                     span,\n                 )))\n             }\n@@ -381,12 +379,12 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     return None;\n                 }\n \n-                let val = self.eval_operand(arg, source_info)?;\n-                let prim = self.use_ecx(source_info, |this| {\n-                    this.ecx.value_to_scalar(ValTy { value: val.0, ty: val.1.ty })\n+                let (arg, _) = self.eval_operand(arg, source_info)?;\n+                let val = self.use_ecx(source_info, |this| {\n+                    let prim = this.ecx.read_scalar(arg)?.not_undef()?;\n+                    this.ecx.unary_op(op, prim, arg.layout)\n                 })?;\n-                let val = self.use_ecx(source_info, |this| this.ecx.unary_op(op, prim, val.1))?;\n-                Some((Value::Scalar(val.into()), place_layout, span))\n+                Some((OpTy::from_scalar_value(val, place_layout), span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -404,7 +402,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 }\n \n                 let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.value_to_scalar(ValTy { value: right.0, ty: right.1.ty })\n+                    this.ecx.read_value(right.0)\n                 })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n                     let left_ty = left.ty(self.mir, self.tcx);\n@@ -414,8 +412,9 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                         .unwrap()\n                         .size\n                         .bits();\n-                    let right_size = right.1.size;\n-                    if r.to_bits(right_size).ok().map_or(false, |b| b >= left_bits as u128) {\n+                    let right_size = right.0.layout.size;\n+                    let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n+                    if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n                         let source_scope_local_data = match self.mir.source_scope_local_data {\n                             ClearCrossCrate::Set(ref data) => data,\n                             ClearCrossCrate::Clear => return None,\n@@ -436,11 +435,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 }\n                 let left = self.eval_operand(left, source_info)?;\n                 let l = self.use_ecx(source_info, |this| {\n-                    this.ecx.value_to_scalar(ValTy { value: left.0, ty: left.1.ty })\n+                    this.ecx.read_value(left.0)\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op(op, l, left.1.ty, r, right.1.ty)\n+                    this.ecx.binary_op(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Value::ScalarPair(\n@@ -455,7 +454,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     }\n                     Value::Scalar(val.into())\n                 };\n-                Some((val, place_layout, span))\n+                let res = OpTy {\n+                    op: ::interpret::Operand::Immediate(val),\n+                    layout: place_layout,\n+                };\n+                Some((res, span))\n             },\n         }\n     }\n@@ -571,7 +574,8 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n             if let Some(value) = self.eval_operand(cond, source_info) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                if Value::Scalar(Scalar::from_bool(*expected).into()) != value.0 {\n+                let expected = Value::Scalar(Scalar::from_bool(*expected).into());\n+                if expected != value.0.to_immediate() {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -607,7 +611,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let len = self\n                                 .eval_operand(len, source_info)\n                                 .expect(\"len must be const\");\n-                            let len = match len.0 {\n+                            let len = match len.0.to_immediate() {\n                                 Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n@@ -616,7 +620,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let index = self\n                                 .eval_operand(index, source_info)\n                                 .expect(\"index must be const\");\n-                            let index = match index.0 {\n+                            let index = match index.0.to_immediate() {\n                                 Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,"}, {"sha": "010ca1f7ab47529005ee6ec5904324e4fcc8217f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1375,7 +1375,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt, id: DefId, span: Span) {\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n     if let Ok(static_) = tcx.const_eval(param_env.and(cid)) {\n-        let alloc = tcx.const_value_to_allocation(static_);\n+        let alloc = tcx.const_to_allocation(static_);\n         if alloc.relocations.len() != 0 {\n             let msg = \"statics with a custom `#[link_section]` must be a \\\n                        simple list of bytes on the wasm target with no \\"}, {"sha": "df1e6f8e4c4f0d7820dba78648a13ecefb7e1aad", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -22,7 +22,7 @@ error: this constant cannot be used\n LL | const Z2: i32 = unsafe { *(42 as *const i32) }; //~ ERROR cannot be used\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^-------------------^^^\n    |                          |\n-   |                          tried to access memory with alignment 2, but alignment 4 is required\n+   |                          a memory access tried to interpret some bytes as a pointer\n \n error: this constant cannot be used\n   --> $DIR/const_raw_ptr_ops.rs:27:1"}, {"sha": "739af12d09c6937b81cfdfaef036c256da19cf1f", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -5,7 +5,7 @@ LL | / static FOO: (&Foo, &Bar) = unsafe {( //~ undefined behavior\n LL | |     Union { usize: &BAR }.foo,\n LL | |     Union { usize: &BAR }.bar,\n LL | | )};\n-   | |___^ type validation failed: encountered 5 at (*.1).TAG, but expected something in the range 42..=99\n+   | |___^ type validation failed: encountered 5 at .1.<deref>.<enum-tag>, but expected something in the range 42..=99\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "8538dd14afed19292d3678d20279354fa02246ce", "filename": "src/test/ui/consts/const-eval/ub-enum-ptr.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/71a1ef181683615f1c8da5efb3d8617c0b743009/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a1ef181683615f1c8da5efb3d8617c0b743009/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.rs?ref=71a1ef181683615f1c8da5efb3d8617c0b743009", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[repr(usize)]\n-#[derive(Copy, Clone)]\n-enum Enum {\n-    A = 0,\n-}\n-\n-union Foo {\n-    a: &'static u8,\n-    b: Enum,\n-}\n-\n-// A pointer is guaranteed non-null\n-const BAD_ENUM: Enum = unsafe { Foo { a: &1 }.b};\n-//~^ ERROR this constant likely exhibits undefined behavior\n-\n-fn main() {\n-}"}, {"sha": "4b7ccc25c6c014615bba5bd7b3c68a707a0b58a2", "filename": "src/test/ui/consts/const-eval/ub-enum-ptr.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71a1ef181683615f1c8da5efb3d8617c0b743009/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71a1ef181683615f1c8da5efb3d8617c0b743009/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.stderr?ref=71a1ef181683615f1c8da5efb3d8617c0b743009", "patch": "@@ -1,11 +0,0 @@\n-error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/ub-enum-ptr.rs:23:1\n-   |\n-LL | const BAD_ENUM: Enum = unsafe { Foo { a: &1 }.b};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer at .TAG, but expected something in the range 0..=0\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "bcb71af54afdb4f03225b147f169f8303795c685", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(usize)]\n+#[derive(Copy, Clone)]\n+enum Enum {\n+    A = 0,\n+}\n+union TransmuteEnum {\n+    a: &'static u8,\n+    b: Enum,\n+}\n+\n+// A pointer is guaranteed non-null\n+const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.b };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// Invalid enum discriminant\n+#[repr(usize)]\n+#[derive(Copy, Clone)]\n+enum Enum2 {\n+    A = 2,\n+}\n+union TransmuteEnum2 {\n+    a: usize,\n+    b: Enum2,\n+}\n+const BAD_ENUM2 : Enum2 = unsafe { TransmuteEnum2 { a: 0 }.b };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// Invalid enum field content (mostly to test printing of apths for enum tuple\n+// variants and tuples).\n+union TransmuteChar {\n+    a: u32,\n+    b: char,\n+}\n+// Need to create something which does not clash with enum layout optimizations.\n+const BAD_ENUM_CHAR : Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+fn main() {\n+}"}, {"sha": "98e9b598b543f9acf3d3c117d84b33ea005d4b83", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -0,0 +1,27 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-enum.rs:22:1\n+   |\n+LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.b };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer at .<enum-tag>, but expected something in the range 0..=0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-enum.rs:35:1\n+   |\n+LL | const BAD_ENUM2 : Enum2 = unsafe { TransmuteEnum2 { a: 0 }.b };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0 at .<enum-tag>, but expected something in the range 2..=2\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-enum.rs:45:1\n+   |\n+LL | const BAD_ENUM_CHAR : Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered character at .Some.0.1, but expected a valid unicode codepoint\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "ffa824fc6af47ac2a0fc236ccde2d2cecc13d6b0", "filename": "src/test/ui/union-ub-fat-ptr.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -13,6 +13,11 @@\n // normalize-stderr-test \"allocation \\d+\" -> \"allocation N\"\n // normalize-stderr-test \"size \\d+\" -> \"size N\"\n \n+union BoolTransmute {\n+  val: u8,\n+  bl: bool,\n+}\n+\n #[repr(C)]\n #[derive(Copy, Clone)]\n struct SliceRepr {\n@@ -32,6 +37,7 @@ union SliceTransmute {\n     bad: BadSliceRepr,\n     slice: &'static [u8],\n     str: &'static str,\n+    my_str: &'static Str,\n }\n \n #[repr(C)]\n@@ -63,32 +69,48 @@ union DynTransmute {\n }\n \n trait Trait {}\n+impl Trait for bool {}\n+\n+struct Str(str);\n \n // OK\n const A: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.str};\n-// should lint\n+// bad str\n const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n-// bad\n+//~^ ERROR this constant likely exhibits undefined behavior\n+// bad str\n const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n //~^ ERROR this constant likely exhibits undefined behavior\n+// bad str in Str\n+const C2: &Str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+//~^ ERROR this constant likely exhibits undefined behavior\n \n // OK\n const A2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.slice};\n-// should lint\n+// bad slice\n const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n-// bad\n-const C2: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n+//~^ ERROR this constant likely exhibits undefined behavior\n+// bad slice\n+const C3: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n //~^ ERROR this constant likely exhibits undefined behavior\n \n-// bad\n+// bad trait object\n const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n //~^ ERROR this constant likely exhibits undefined behavior\n-// bad\n+// bad trait object\n const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n //~^ ERROR this constant likely exhibits undefined behavior\n-// bad\n+// bad trait object\n const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n //~^ ERROR this constant likely exhibits undefined behavior\n \n+// bad data *inside* the trait object\n+const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// bad data *inside* the slice\n+const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n fn main() {\n }"}, {"sha": "cc22422304d68ca92d5bd0e5d86fef9a336e8a4a", "filename": "src/test/ui/union-ub-fat-ptr.stderr", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/674ef668f13c52a1fadbf01b24d8da1e12d15e70/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr?ref=674ef668f13c52a1fadbf01b24d8da1e12d15e70", "patch": "@@ -1,43 +1,83 @@\n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:72:1\n+  --> $DIR/union-ub-fat-ptr.rs:79:1\n+   |\n+LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:82:1\n    |\n LL | const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered length is not a valid integer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:80:1\n+  --> $DIR/union-ub-fat-ptr.rs:85:1\n    |\n-LL | const C2: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered length is not a valid integer\n+LL | const C2: &Str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:84:1\n+  --> $DIR/union-ub-fat-ptr.rs:91:1\n+   |\n+LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:94:1\n+   |\n+LL | const C3: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:98:1\n    |\n LL | const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ tried to access memory with alignment N, but alignment N is required\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:87:1\n+  --> $DIR/union-ub-fat-ptr.rs:101:1\n    |\n LL | const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a memory access tried to interpret some bytes as a pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:90:1\n+  --> $DIR/union-ub-fat-ptr.rs:104:1\n    |\n LL | const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered vtable address is not a pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer vtable is not a valid pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:108:1\n+   |\n+LL | const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>, but expected something in the range 0..=1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:112:1\n+   |\n+LL | const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 10 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}