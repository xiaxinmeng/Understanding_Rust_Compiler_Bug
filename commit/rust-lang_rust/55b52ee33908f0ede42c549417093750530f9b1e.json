{"sha": "55b52ee33908f0ede42c549417093750530f9b1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YjUyZWUzMzkwOGYwZWRlNDJjNTQ5NDE3MDkzNzUwNTMwZjliMWU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-12-28T13:13:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-28T13:13:19Z"}, "message": "Rollup merge of #80408 - bjorn3:sync_cg_clif-2020-12-27, r=bjorn3\n\nSync rustc_codegen_cranelift\n\nThe highlight of this sync are two JIT mode improvements. The first is that it is now possible to use JIT mode when using `-Zcodegen-backend` instead of the custom driver using `-Cllvm-args=mode=jit`. The second one is a new JIT mode that lazily compiles functions when they are called the first time: https://github.com/bjorn3/rustc_codegen_cranelift/pull/1120\n\nIn addition this includes a few small runtime performance improvements and various fixes for rustc changes that didn't cause compilation to fail.\n\nr? ``@ghost``\n\n``@rustbot`` label +A-codegen +A-cranelift +T-compiler", "tree": {"sha": "71f1c1eca77380b3af594738097baec223fcfb92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71f1c1eca77380b3af594738097baec223fcfb92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55b52ee33908f0ede42c549417093750530f9b1e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf6dnwCRBK7hj4Ov3rIwAAdHIIAEPOP6HCeTtVFfUDzBpYRJGP\nRMdgdo2QvEgVV8SsT/Iv3t/zmxby/ttBo5tgyufamJPi5ADWtfkZ0FDyyzE3i27O\nESVOo9MYl7Vaz5qUu0BvOUoLDq2IV2rxHtKMUSqzkGLGrt46kHvkqBoiq0sgNj5Z\n8Jhc2GwWVgpqN5InVO2h973nfxSQzHxT5xWXdiMSfGpTBJhILYBEdl6EDFfldX88\n6qlpkRtyBo1FV0KQ5I9bQIV8IIwZa0qMQv7gC+nY8Pcj8g6dX+w+eACfpDrgOwLb\nfSOzpwDOcnlycZfKae/mI0w9iJXKVnuoGo5n5WD4mjUK4DMb7CrmC5OTWF9mvuw=\n=Qsgt\n-----END PGP SIGNATURE-----\n", "payload": "tree 71f1c1eca77380b3af594738097baec223fcfb92\nparent 70b1a29b80dc08ba471975e701ae549a0edaad58\nparent 52cf01c81579fa1add25e935d26de8cd3e9ea1d7\nauthor Dylan DPC <dylan.dpc@gmail.com> 1609161199 +0100\ncommitter GitHub <noreply@github.com> 1609161199 +0100\n\nRollup merge of #80408 - bjorn3:sync_cg_clif-2020-12-27, r=bjorn3\n\nSync rustc_codegen_cranelift\n\nThe highlight of this sync are two JIT mode improvements. The first is that it is now possible to use JIT mode when using `-Zcodegen-backend` instead of the custom driver using `-Cllvm-args=mode=jit`. The second one is a new JIT mode that lazily compiles functions when they are called the first time: https://github.com/bjorn3/rustc_codegen_cranelift/pull/1120\n\nIn addition this includes a few small runtime performance improvements and various fixes for rustc changes that didn't cause compilation to fail.\n\nr? ``@ghost``\n\n``@rustbot`` label +A-codegen +A-cranelift +T-compiler\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55b52ee33908f0ede42c549417093750530f9b1e", "html_url": "https://github.com/rust-lang/rust/commit/55b52ee33908f0ede42c549417093750530f9b1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55b52ee33908f0ede42c549417093750530f9b1e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70b1a29b80dc08ba471975e701ae549a0edaad58", "url": "https://api.github.com/repos/rust-lang/rust/commits/70b1a29b80dc08ba471975e701ae549a0edaad58", "html_url": "https://github.com/rust-lang/rust/commit/70b1a29b80dc08ba471975e701ae549a0edaad58"}, {"sha": "52cf01c81579fa1add25e935d26de8cd3e9ea1d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/52cf01c81579fa1add25e935d26de8cd3e9ea1d7", "html_url": "https://github.com/rust-lang/rust/commit/52cf01c81579fa1add25e935d26de8cd3e9ea1d7"}], "stats": {"total": 763, "additions": 489, "deletions": 274}, "files": [{"sha": "7618251acd5c26ae8972288cd292ed4afbe3cf89", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -1,6 +1,7 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\"],\n+    \"rust-analyzer.assist.importMergeBehaviour\": \"last\",\n     \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\","}, {"sha": "0382835269d1fdef8cb38b6aeadd28282b885374", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -50,15 +50,15 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n [[package]]\n name = \"cranelift-bforest\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -76,7 +76,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-codegen-meta\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n@@ -85,28 +85,46 @@ dependencies = [\n [[package]]\n name = \"cranelift-codegen-shared\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n \n [[package]]\n name = \"cranelift-entity\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n \n [[package]]\n name = \"cranelift-frontend\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n  \"smallvec\",\n  \"target-lexicon\",\n ]\n \n+[[package]]\n+name = \"cranelift-jit\"\n+version = \"0.68.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+dependencies = [\n+ \"anyhow\",\n+ \"cranelift-codegen\",\n+ \"cranelift-entity\",\n+ \"cranelift-module\",\n+ \"cranelift-native\",\n+ \"errno\",\n+ \"libc\",\n+ \"log\",\n+ \"region\",\n+ \"target-lexicon\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"cranelift-module\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -118,7 +136,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-native\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"raw-cpuid\",\n@@ -128,7 +146,7 @@ dependencies = [\n [[package]]\n name = \"cranelift-object\"\n version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -138,23 +156,6 @@ dependencies = [\n  \"target-lexicon\",\n ]\n \n-[[package]]\n-name = \"cranelift-simplejit\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#19640367dbf0da7093e61add3306c8d092644fb3\"\n-dependencies = [\n- \"cranelift-codegen\",\n- \"cranelift-entity\",\n- \"cranelift-module\",\n- \"cranelift-native\",\n- \"errno\",\n- \"libc\",\n- \"log\",\n- \"region\",\n- \"target-lexicon\",\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"crc32fast\"\n version = \"1.2.1\"\n@@ -325,9 +326,9 @@ dependencies = [\n  \"ar\",\n  \"cranelift-codegen\",\n  \"cranelift-frontend\",\n+ \"cranelift-jit\",\n  \"cranelift-module\",\n  \"cranelift-object\",\n- \"cranelift-simplejit\",\n  \"gimli\",\n  \"indexmap\",\n  \"libloading\","}, {"sha": "8e1933bb14e7c197fa8bb83050368c0187395c95", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -12,7 +12,7 @@ crate-type = [\"dylib\"]\n cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n-cranelift-simplejit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n+cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n target-lexicon = \"0.11.0\"\n gimli = { version = \"0.23.0\", default-features = false, features = [\"write\"]}\n@@ -27,15 +27,15 @@ libloading = { version = \"0.6.0\", optional = true }\n #cranelift-codegen = { path = \"../wasmtime/cranelift/codegen\" }\n #cranelift-frontend = { path = \"../wasmtime/cranelift/frontend\" }\n #cranelift-module = { path = \"../wasmtime/cranelift/module\" }\n-#cranelift-simplejit = { path = \"../wasmtime/cranelift/simplejit\" }\n+#cranelift-jit = { path = \"../wasmtime/cranelift/jit\" }\n #cranelift-object = { path = \"../wasmtime/cranelift/object\" }\n \n #[patch.crates-io]\n #gimli = { path = \"../\" }\n \n [features]\n default = [\"jit\", \"inline_asm\"]\n-jit = [\"cranelift-simplejit\", \"libloading\"]\n+jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n \n [profile.dev]"}, {"sha": "22d9e00923f006f1711a5d6791fd8ac78ad9d827", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -2,7 +2,7 @@\n \n > \u26a0\u26a0\u26a0 Certain kinds of FFI don't work yet. \u26a0\u26a0\u26a0\n \n-The goal of this project is to create an alternative codegen backend for the rust compiler based on [Cranelift](https://github.com/bytecodealliance/wasmtime/blob/master/cranelift).\n+The goal of this project is to create an alternative codegen backend for the rust compiler based on [Cranelift](https://github.com/bytecodealliance/wasmtime/blob/main/cranelift).\n This has the potential to improve compilation times in debug mode.\n If your project doesn't use any of the things listed under \"Not yet supported\", it should work fine.\n If not please open an issue.\n@@ -68,7 +68,15 @@ $ $cg_clif_dir/build/cargo.sh jit\n or\n \n ```bash\n-$ $cg_clif_dir/build/bin/cg_clif --jit my_crate.rs\n+$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n+```\n+\n+There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n+first called. It currently does not work with multi-threaded programs. When a not yet compiled\n+function is called from another thread than the main thread, you will get an ICE.\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh lazy-jit\n ```\n \n ### Shell\n@@ -77,7 +85,7 @@ These are a few functions that allow you to easily run rust code from the shell\n \n ```bash\n function jit_naked() {\n-    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - --jit\n+    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n }\n \n function jit() {"}, {"sha": "990557694ead4a4282f943a825c31d23baff9e83", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -47,9 +47,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.65\"\n+version = \"1.0.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"95752358c8f7552394baf48cd82695b345628ad3f170d607de3ca03b8dacca15\"\n+checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -141,9 +141,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.80\"\n+version = \"0.2.81\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d58d1b70b004888f764dfbf6a26a3b0342a1632d33968e4a179d8011c760614\"\n+checksum = \"1482821306169ec4d07f6aca392a4681f66c75c9918aa49641a2595db64053cb\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "3dbd28c286a246f25677b2420cc6fb07410961c8", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -5,13 +5,14 @@ version = \"0.0.0\"\n \n [dependencies]\n core = { path = \"./sysroot_src/library/core\" }\n-compiler_builtins = \"0.1\"\n alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n alloc_system = { path = \"./alloc_system\" }\n \n+compiler_builtins = { version = \"=0.1.36\", default-features = false }\n+\n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }\n rustc-std-workspace-alloc = { path = \"./sysroot_src/library/rustc-std-workspace-alloc\" }"}, {"sha": "015bbdfed4648ee106cb18d47f2e7217d7f30cd9", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -15,6 +15,8 @@ fn main() {\n     let stderr = ::std::io::stderr();\n     let mut stderr = stderr.lock();\n \n+    // FIXME support lazy jit when multi threading\n+    #[cfg(not(lazy_jit))]\n     std::thread::spawn(move || {\n         println!(\"Hello from another thread!\");\n     });"}, {"sha": "d6ad24bcf26ddf48007753c231b74bb11ac38281", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -1 +1 @@\n-nightly-2020-11-27\n+nightly-2020-12-23"}, {"sha": "a3d6d303057b8050ed0d51c30c00ab0cbcf9d31c", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -10,7 +10,9 @@ cmd=$1\n shift || true\n \n if [[ \"$cmd\" = \"jit\" ]]; then\n-cargo \"+${TOOLCHAIN}\" rustc \"$@\" -- --jit\n+cargo \"+${TOOLCHAIN}\" rustc \"$@\" -- -Cllvm-args=mode=jit -Cprefer-dynamic\n+elif [[ \"$cmd\" = \"lazy-jit\" ]]; then\n+cargo \"+${TOOLCHAIN}\" rustc \"$@\" -- -Cllvm-args=mode=jit-lazy -Cprefer-dynamic\n else\n cargo \"+${TOOLCHAIN}\" \"$cmd\" \"$@\"\n fi"}, {"sha": "15388926ec9ec62ddb5c707cc64c926317f75f09", "filename": "compiler/rustc_codegen_cranelift/scripts/filter_profile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -4,7 +4,7 @@\n pushd $(dirname \"$0\")/../\n source build/config.sh\n popd\n-PROFILE=$1 OUTPUT=$2 exec $RUSTC $RUSTFLAGS --jit $0\n+PROFILE=$1 OUTPUT=$2 exec $RUSTC $RUSTFLAGS -Cllvm-args=mode=jit -Cprefer-dynamic $0\n #*/\n \n //! This program filters away uninteresting samples and trims uninteresting frames for stackcollapse"}, {"sha": "a61774f479ec7f9cb7ee3533042806ff61b21c05", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -15,7 +15,10 @@ function no_sysroot_tests() {\n \n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC --jit example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n+        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n+\n+        echo \"[JIT-lazy] mini_core_hello_world\"\n+        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] mini_core_hello_world (skipped)\"\n     fi\n@@ -37,7 +40,10 @@ function base_sysroot_tests() {\n \n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] std_example\"\n-        $MY_RUSTC --jit example/std_example.rs --target \"$HOST_TRIPLE\"\n+        $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n+\n+        echo \"[JIT-lazy] std_example\"\n+        $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --cfg lazy_jit --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] std_example (skipped)\"\n     fi"}, {"sha": "0ce34c904bdcc43d274263f46035c5302d5b5a78", "filename": "compiler/rustc_codegen_cranelift/src/backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -162,7 +162,7 @@ impl AddConstructor for ObjectProduct {\n }\n \n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n-    let triple = crate::build_isa(sess, true).triple().clone();\n+    let triple = crate::build_isa(sess).triple().clone();\n \n     let binary_format = match triple.binary_format {\n         target_lexicon::BinaryFormat::Elf => object::BinaryFormat::Elf,\n@@ -193,7 +193,7 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n \n pub(crate) fn make_module(sess: &Session, name: String) -> ObjectModule {\n     let mut builder = ObjectBuilder::new(\n-        crate::build_isa(sess, true),\n+        crate::build_isa(sess),\n         name + \".o\",\n         cranelift_module::default_libcall_names(),\n     )"}, {"sha": "34c9561d6762287a6113ee700e4042e6041b4352", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -118,6 +118,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n     context.dce(cx.module.isa()).unwrap();\n \n+    context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n+\n     // Define function\n     let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n@@ -140,6 +142,16 @@ pub(crate) fn codegen_fn<'tcx>(\n         &clif_comments,\n     );\n \n+    if let Some(mach_compile_result) = &context.mach_compile_result {\n+        if let Some(disasm) = &mach_compile_result.disasm {\n+            crate::pretty_clif::write_ir_file(\n+                tcx,\n+                &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+                |file| file.write_all(disasm.as_bytes()),\n+            )\n+        }\n+    }\n+\n     // Define debuginfo for function\n     let isa = cx.module.isa();\n     let debug_context = &mut cx.debug_context;\n@@ -307,7 +319,9 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             } => {\n                 let discr = codegen_operand(fx, discr).load_scalar(fx);\n \n-                if switch_ty.kind() == fx.tcx.types.bool.kind() {\n+                let use_bool_opt = switch_ty.kind() == fx.tcx.types.bool.kind()\n+                    || (targets.iter().count() == 1 && targets.iter().next().unwrap().0 == 0);\n+                if use_bool_opt {\n                     assert_eq!(targets.iter().count(), 1);\n                     let (then_value, then_block) = targets.iter().next().unwrap();\n                     let then_block = fx.get_block(then_block);\n@@ -325,12 +339,22 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n                     let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     let discr =\n                         crate::optimize::peephole::make_branchable_value(&mut fx.bcx, discr);\n-                    if test_zero {\n-                        fx.bcx.ins().brz(discr, then_block, &[]);\n-                        fx.bcx.ins().jump(else_block, &[]);\n+                    if let Some(taken) = crate::optimize::peephole::maybe_known_branch_taken(\n+                        &fx.bcx, discr, test_zero,\n+                    ) {\n+                        if taken {\n+                            fx.bcx.ins().jump(then_block, &[]);\n+                        } else {\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        }\n                     } else {\n-                        fx.bcx.ins().brnz(discr, then_block, &[]);\n-                        fx.bcx.ins().jump(else_block, &[]);\n+                        if test_zero {\n+                            fx.bcx.ins().brz(discr, then_block, &[]);\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        } else {\n+                            fx.bcx.ins().brnz(discr, then_block, &[]);\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        }\n                     }\n                 } else {\n                     let mut switch = ::cranelift_frontend::Switch::new();"}, {"sha": "58e45b4e9b972fbb1adbc6bbe112015654cc4f4c", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -44,9 +44,7 @@ fn main() {\n     let mut callbacks = CraneliftPassesCallbacks::default();\n     rustc_driver::install_ice_hook();\n     let exit_code = rustc_driver::catch_with_exit_code(|| {\n-        let mut use_jit = false;\n-\n-        let mut args = std::env::args_os()\n+        let args = std::env::args_os()\n             .enumerate()\n             .map(|(i, arg)| {\n                 arg.into_string().unwrap_or_else(|arg| {\n@@ -56,23 +54,10 @@ fn main() {\n                     )\n                 })\n             })\n-            .filter(|arg| {\n-                if arg == \"--jit\" {\n-                    use_jit = true;\n-                    false\n-                } else {\n-                    true\n-                }\n-            })\n             .collect::<Vec<_>>();\n-        if use_jit {\n-            args.push(\"-Cprefer-dynamic\".to_string());\n-        }\n         let mut run_compiler = rustc_driver::RunCompiler::new(&args, &mut callbacks);\n         run_compiler.set_make_codegen_backend(Some(Box::new(move |_| {\n-            Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend {\n-                config: rustc_codegen_cranelift::BackendConfig { use_jit },\n-            })\n+            Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend { config: None })\n         })));\n         run_compiler.run()\n     });"}, {"sha": "8ee4cd46c94e0d2f36591b39622912437b95c225", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -92,9 +92,7 @@ fn main() {\n         let mut run_compiler = rustc_driver::RunCompiler::new(&args, &mut callbacks);\n         if use_clif {\n             run_compiler.set_make_codegen_backend(Some(Box::new(move |_| {\n-                Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend {\n-                    config: rustc_codegen_cranelift::BackendConfig { use_jit: false },\n-                })\n+                Box::new(rustc_codegen_cranelift::CraneliftCodegenBackend { config: None })\n             })));\n         }\n         run_compiler.run()"}, {"sha": "beff84fb2e217ae04445e7979f807ddebf7b65ab", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -100,7 +100,10 @@ fn codegen_static_ref<'tcx>(\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n     assert!(\n-        matches!(fx.bcx.func.global_values[local_data_id], GlobalValueData::Symbol { tls: false, ..}),\n+        matches!(\n+            fx.bcx.func.global_values[local_data_id],\n+            GlobalValueData::Symbol { tls: false, .. }\n+        ),\n         \"tls static referenced without Rvalue::ThreadLocalRef\"\n     );\n     CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n@@ -447,7 +450,8 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             data_ctx.write_data_addr(offset.bytes() as u32, global_value, addend as i64);\n         }\n \n-        module.define_data(data_id, &data_ctx).unwrap();\n+        // FIXME don't duplicate definitions in lazy jit mode\n+        let _ = module.define_data(data_id, &data_ctx);\n         cx.done.insert(data_id);\n     }\n "}, {"sha": "6160f9b78d8b3a6d9cd3cefde854f4ca60813f67", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -74,10 +74,7 @@ impl WriterRelocate {\n \n     /// Perform the collected relocations to be usable for JIT usage.\n     #[cfg(feature = \"jit\")]\n-    pub(super) fn relocate_for_jit(\n-        mut self,\n-        jit_module: &cranelift_simplejit::SimpleJITModule,\n-    ) -> Vec<u8> {\n+    pub(super) fn relocate_for_jit(mut self, jit_module: &cranelift_jit::JITModule) -> Vec<u8> {\n         use std::convert::TryInto;\n \n         for reloc in self.relocs.drain(..) {"}, {"sha": "49de927cdba059d0fd4c154bccae6737d46c916e", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -15,11 +15,11 @@ pub(crate) struct UnwindContext<'tcx> {\n }\n \n impl<'tcx> UnwindContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa, pic_eh_frame: bool) -> Self {\n         let mut frame_table = FrameTable::default();\n \n         let cie_id = if let Some(mut cie) = isa.create_systemv_cie() {\n-            if isa.flags().is_pic() {\n+            if pic_eh_frame {\n                 cie.fde_address_encoding =\n                     gimli::DwEhPe(gimli::DW_EH_PE_pcrel.0 | gimli::DW_EH_PE_sdata4.0);\n             }\n@@ -80,7 +80,7 @@ impl<'tcx> UnwindContext<'tcx> {\n     #[cfg(feature = \"jit\")]\n     pub(crate) unsafe fn register_jit(\n         self,\n-        jit_module: &cranelift_simplejit::SimpleJITModule,\n+        jit_module: &cranelift_jit::JITModule,\n     ) -> Option<UnwindRegistry> {\n         let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n             self.tcx,"}, {"sha": "16f9bfc99189f5cbe1e7f3d59b24f7cca8364b8c", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -8,7 +8,7 @@ use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::EncodedMetadata;\n-use rustc_middle::mir::mono::CodegenUnit;\n+use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{DebugInfo, OutputType};\n \n@@ -146,11 +146,34 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n         }\n     }\n \n-    let mut cx = crate::CodegenCx::new(tcx, module, tcx.sess.opts.debuginfo != DebugInfo::None);\n+    let mut cx = crate::CodegenCx::new(\n+        tcx,\n+        module,\n+        tcx.sess.opts.debuginfo != DebugInfo::None,\n+        true,\n+    );\n     super::predefine_mono_items(&mut cx, &mono_items);\n     for (mono_item, (linkage, visibility)) in mono_items {\n         let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n-        super::codegen_mono_item(&mut cx, mono_item, linkage);\n+        match mono_item {\n+            MonoItem::Fn(inst) => {\n+                cx.tcx.sess.time(\"codegen fn\", || {\n+                    crate::base::codegen_fn(&mut cx, inst, linkage)\n+                });\n+            }\n+            MonoItem::Static(def_id) => {\n+                crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n+            }\n+            MonoItem::GlobalAsm(hir_id) => {\n+                let item = cx.tcx.hir().expect_item(hir_id);\n+                if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n+                    cx.global_asm.push_str(&*asm.as_str());\n+                    cx.global_asm.push_str(\"\\n\\n\");\n+                } else {\n+                    bug!(\"Expected GlobalAsm found {:?}\", item);\n+                }\n+            }\n+        }\n     }\n     let (mut module, global_asm, debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n@@ -236,7 +259,7 @@ pub(super) fn run_aot(\n     tcx.sess.abort_if_errors();\n \n     let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n-    let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa());\n+    let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa(), true);\n     let created_alloc_shim =\n         crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n "}, {"sha": "9a42c675cc14498a1955983ce99e799a382ea63d", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 150, "deletions": 16, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -1,16 +1,23 @@\n //! The JIT driver uses [`cranelift_simplejit`] to JIT execute programs without writing any object\n //! files.\n \n+use std::cell::RefCell;\n use std::ffi::CString;\n use std::os::raw::{c_char, c_int};\n \n use rustc_codegen_ssa::CrateInfo;\n+use rustc_middle::mir::mono::MonoItem;\n \n-use cranelift_simplejit::{SimpleJITBuilder, SimpleJITModule};\n+use cranelift_jit::{JITBuilder, JITModule};\n \n use crate::prelude::*;\n+use crate::{CodegenCx, CodegenMode};\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n+thread_local! {\n+    pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n+}\n+\n+pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n     if !tcx.sess.opts.output_types.should_codegen() {\n         tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n     }\n@@ -35,12 +42,13 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n \n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let mut jit_builder = SimpleJITBuilder::with_isa(\n-        crate::build_isa(tcx.sess, false),\n+    let mut jit_builder = JITBuilder::with_isa(\n+        crate::build_isa(tcx.sess),\n         cranelift_module::default_libcall_names(),\n     );\n+    jit_builder.hotswap(matches!(codegen_mode, CodegenMode::JitLazy));\n     jit_builder.symbols(imported_symbols);\n-    let mut jit_module = SimpleJITModule::new(jit_builder);\n+    let mut jit_module = JITModule::new(jit_builder);\n     assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n \n     let sig = Signature {\n@@ -66,20 +74,42 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, jit_module, false);\n+    let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n \n-    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n-        super::time(tcx, \"codegen mono items\", || {\n-            super::predefine_mono_items(&mut cx, &mono_items);\n-            for (mono_item, (linkage, visibility)) in mono_items {\n-                let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n-                super::codegen_mono_item(&mut cx, mono_item, linkage);\n+    super::time(tcx, \"codegen mono items\", || {\n+        super::predefine_mono_items(&mut cx, &mono_items);\n+        for (mono_item, (linkage, visibility)) in mono_items {\n+            let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+            match mono_item {\n+                MonoItem::Fn(inst) => match codegen_mode {\n+                    CodegenMode::Aot => unreachable!(),\n+                    CodegenMode::Jit => {\n+                        cx.tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_fn(&mut cx, inst, linkage)\n+                        });\n+                    }\n+                    CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n+                },\n+                MonoItem::Static(def_id) => {\n+                    crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n+                }\n+                MonoItem::GlobalAsm(hir_id) => {\n+                    let item = cx.tcx.hir().expect_item(hir_id);\n+                    tcx.sess\n+                        .span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n+                }\n             }\n-            tcx.sess.time(\"finalize CodegenCx\", || cx.finalize())\n-        });\n+        }\n+    });\n+\n+    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n+        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n+    jit_module.finalize_definitions();\n+\n     if !global_asm.is_empty() {\n-        tcx.sess.fatal(\"Global asm is not supported in JIT mode\");\n+        tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n+\n     crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context, true);\n     crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n \n@@ -91,7 +121,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n \n     let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n \n-    println!(\"Rustc codegen cranelift will JIT run the executable, because --jit was passed\");\n+    println!(\"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\");\n \n     let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n         unsafe { ::std::mem::transmute(finalized_main) };\n@@ -107,11 +137,50 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n+    CURRENT_MODULE\n+        .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n+\n     let ret = f(args.len() as c_int, argv.as_ptr());\n \n     std::process::exit(ret);\n }\n \n+#[no_mangle]\n+extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8 {\n+    rustc_middle::ty::tls::with(|tcx| {\n+        // lift is used to ensure the correct lifetime for instance.\n+        let instance = tcx.lift(unsafe { *instance_ptr }).unwrap();\n+\n+        CURRENT_MODULE.with(|jit_module| {\n+            let mut jit_module = jit_module.borrow_mut();\n+            let jit_module = jit_module.as_mut().unwrap();\n+            let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+\n+            let (name, sig) = crate::abi::get_function_name_and_sig(\n+                tcx,\n+                cx.module.isa().triple(),\n+                instance,\n+                true,\n+            );\n+            let func_id = cx\n+                .module\n+                .declare_function(&name, Linkage::Export, &sig)\n+                .unwrap();\n+            cx.module.prepare_for_function_redefine(func_id).unwrap();\n+\n+            tcx.sess.time(\"codegen fn\", || {\n+                crate::base::codegen_fn(&mut cx, instance, Linkage::Export)\n+            });\n+\n+            let (jit_module, global_asm, _debug_context, unwind_context) = cx.finalize();\n+            assert!(global_asm.is_empty());\n+            jit_module.finalize_definitions();\n+            std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n+            jit_module.get_finalized_function(func_id)\n+        })\n+    })\n+}\n+\n fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     use rustc_middle::middle::dependency_format::Linkage;\n \n@@ -171,3 +240,68 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n \n     imported_symbols\n }\n+\n+pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: Instance<'tcx>) {\n+    let tcx = cx.tcx;\n+\n+    let pointer_type = cx.module.target_config().pointer_type();\n+\n+    let (name, sig) =\n+        crate::abi::get_function_name_and_sig(tcx, cx.module.isa().triple(), inst, true);\n+    let func_id = cx\n+        .module\n+        .declare_function(&name, Linkage::Export, &sig)\n+        .unwrap();\n+\n+    let instance_ptr = Box::into_raw(Box::new(inst));\n+\n+    let jit_fn = cx\n+        .module\n+        .declare_function(\n+            \"__clif_jit_fn\",\n+            Linkage::Import,\n+            &Signature {\n+                call_conv: cx.module.target_config().default_call_conv,\n+                params: vec![AbiParam::new(pointer_type)],\n+                returns: vec![AbiParam::new(pointer_type)],\n+            },\n+        )\n+        .unwrap();\n+\n+    let mut trampoline = Function::with_name_signature(ExternalName::default(), sig.clone());\n+    let mut builder_ctx = FunctionBuilderContext::new();\n+    let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n+\n+    let jit_fn = cx\n+        .module\n+        .declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let sig_ref = trampoline_builder.func.import_signature(sig);\n+\n+    let entry_block = trampoline_builder.create_block();\n+    trampoline_builder.append_block_params_for_function_params(entry_block);\n+    let fn_args = trampoline_builder\n+        .func\n+        .dfg\n+        .block_params(entry_block)\n+        .to_vec();\n+\n+    trampoline_builder.switch_to_block(entry_block);\n+    let instance_ptr = trampoline_builder\n+        .ins()\n+        .iconst(pointer_type, instance_ptr as u64 as i64);\n+    let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr]);\n+    let jitted_fn = trampoline_builder.func.dfg.inst_results(jitted_fn)[0];\n+    let call_inst = trampoline_builder\n+        .ins()\n+        .call_indirect(sig_ref, jitted_fn, &fn_args);\n+    let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n+    trampoline_builder.ins().return_(&ret_vals);\n+\n+    cx.module\n+        .define_function(\n+            func_id,\n+            &mut Context::for_function(trampoline),\n+            &mut cranelift_codegen::binemit::NullTrapSink {},\n+        )\n+        .unwrap();\n+}"}, {"sha": "9f4ea9a386551f88436198bf27214f7f6902f39a", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 17, "deletions": 39, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -7,6 +7,7 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n \n use crate::prelude::*;\n+use crate::CodegenMode;\n \n mod aot;\n #[cfg(feature = \"jit\")]\n@@ -20,24 +21,25 @@ pub(crate) fn codegen_crate(\n ) -> Box<dyn Any> {\n     tcx.sess.abort_if_errors();\n \n-    if config.use_jit {\n-        let is_executable = tcx\n-            .sess\n-            .crate_types()\n-            .contains(&rustc_session::config::CrateType::Executable);\n-        if !is_executable {\n-            tcx.sess.fatal(\"can't jit non-executable crate\");\n-        }\n+    match config.codegen_mode {\n+        CodegenMode::Aot => aot::run_aot(tcx, metadata, need_metadata_module),\n+        CodegenMode::Jit | CodegenMode::JitLazy => {\n+            let is_executable = tcx\n+                .sess\n+                .crate_types()\n+                .contains(&rustc_session::config::CrateType::Executable);\n+            if !is_executable {\n+                tcx.sess.fatal(\"can't jit non-executable crate\");\n+            }\n \n-        #[cfg(feature = \"jit\")]\n-        let _: ! = jit::run_jit(tcx);\n+            #[cfg(feature = \"jit\")]\n+            let _: ! = jit::run_jit(tcx, config.codegen_mode);\n \n-        #[cfg(not(feature = \"jit\"))]\n-        tcx.sess\n-            .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            #[cfg(not(feature = \"jit\"))]\n+            tcx.sess\n+                .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+        }\n     }\n-\n-    aot::run_aot(tcx, metadata, need_metadata_module)\n }\n \n fn predefine_mono_items<'tcx>(\n@@ -63,30 +65,6 @@ fn predefine_mono_items<'tcx>(\n     });\n }\n \n-fn codegen_mono_item<'tcx, M: Module>(\n-    cx: &mut crate::CodegenCx<'tcx, M>,\n-    mono_item: MonoItem<'tcx>,\n-    linkage: Linkage,\n-) {\n-    match mono_item {\n-        MonoItem::Fn(inst) => {\n-            cx.tcx\n-                .sess\n-                .time(\"codegen fn\", || crate::base::codegen_fn(cx, inst, linkage));\n-        }\n-        MonoItem::Static(def_id) => crate::constant::codegen_static(&mut cx.constants_cx, def_id),\n-        MonoItem::GlobalAsm(hir_id) => {\n-            let item = cx.tcx.hir().expect_item(hir_id);\n-            if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n-                cx.global_asm.push_str(&*asm.as_str());\n-                cx.global_asm.push_str(\"\\n\\n\");\n-            } else {\n-                bug!(\"Expected GlobalAsm found {:?}\", item);\n-            }\n-        }\n-    }\n-}\n-\n fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n     if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\")\n         .as_ref()"}, {"sha": "d58e4d499584210e78fda8527de716e4ccba5034", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -23,8 +23,8 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n \n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n         llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n-            let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, a.layout());\n-            let lane_ty = fx.clif_type(lane_layout.ty).unwrap();\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_ty = fx.clif_type(lane_ty).unwrap();\n             assert!(lane_count <= 32);\n \n             let mut res = fx.bcx.ins().iconst(types::I32, 0);"}, {"sha": "be5b247bb9f0bf7e1a4db31c2ed9c3593a78b92e", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 14, "deletions": 55, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -171,27 +171,6 @@ macro validate_simd_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     }\n }\n \n-fn lane_type_and_count<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    layout: TyAndLayout<'tcx>,\n-) -> (TyAndLayout<'tcx>, u16) {\n-    assert!(layout.ty.is_simd());\n-    let lane_count = match layout.fields {\n-        rustc_target::abi::FieldsShape::Array { stride: _, count } => u16::try_from(count).unwrap(),\n-        _ => unreachable!(\"lane_type_and_count({:?})\", layout),\n-    };\n-    let lane_layout = layout\n-        .field(\n-            &ty::layout::LayoutCx {\n-                tcx,\n-                param_env: ParamEnv::reveal_all(),\n-            },\n-            0,\n-        )\n-        .unwrap();\n-    (lane_layout, lane_count)\n-}\n-\n pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n     let (element, count) = match &layout.abi {\n         Abi::Vector { element, count } => (element.clone(), *count),\n@@ -218,8 +197,10 @@ fn simd_for_each_lane<'tcx, M: Module>(\n ) {\n     let layout = val.layout();\n \n-    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n-    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+    let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+    let lane_layout = fx.layout_of(lane_ty);\n+    let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+    let ret_lane_layout = fx.layout_of(ret_lane_ty);\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane_idx in 0..lane_count {\n@@ -248,8 +229,10 @@ fn simd_pair_for_each_lane<'tcx, M: Module>(\n     assert_eq!(x.layout(), y.layout());\n     let layout = x.layout();\n \n-    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n-    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+    let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+    let lane_layout = fx.layout_of(lane_ty);\n+    let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+    let ret_lane_layout = fx.layout_of(ret_lane_ty);\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane in 0..lane_count {\n@@ -269,13 +252,14 @@ fn simd_reduce<'tcx, M: Module>(\n     ret: CPlace<'tcx>,\n     f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, TyAndLayout<'tcx>, Value, Value) -> Value,\n ) {\n-    let (lane_layout, lane_count) = lane_type_and_count(fx.tcx, val.layout());\n+    let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n+    let lane_layout = fx.layout_of(lane_ty);\n     assert_eq!(lane_layout, ret.layout());\n \n     let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     for lane_idx in 1..lane_count {\n         let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.into()))\n+            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n             .load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n@@ -289,14 +273,14 @@ fn simd_reduce_bool<'tcx, M: Module>(\n     ret: CPlace<'tcx>,\n     f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, Value, Value) -> Value,\n ) {\n-    let (_lane_layout, lane_count) = lane_type_and_count(fx.tcx, val.layout());\n+    let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n \n     let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n         let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.into()))\n+            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n             .load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n@@ -460,9 +444,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 \"abort\" => {\n                     trap_abort(fx, \"Called intrinsic::abort.\");\n                 }\n-                \"unreachable\" => {\n-                    trap_unreachable(fx, \"[corruption] Called intrinsic::unreachable.\");\n-                }\n                 \"transmute\" => {\n                     crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", span);\n                 }\n@@ -575,12 +556,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n-        discriminant_value, (c ptr) {\n-            let pointee_layout = fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), pointee_layout);\n-            let discr = crate::discriminant::codegen_get_discriminant(fx, val, ret.layout());\n-            ret.write_cvalue(fx, discr);\n-        };\n         size_of_val, <T> (c ptr) {\n             let layout = fx.layout_of(T);\n             let size = if layout.is_unsized() {\n@@ -641,22 +616,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.starts_with(\"wrapping_\"), (c x, c y) {\n-            assert_eq!(x.layout().ty, y.layout().ty);\n-            let bin_op = match intrinsic {\n-                \"wrapping_add\" => BinOp::Add,\n-                \"wrapping_sub\" => BinOp::Sub,\n-                \"wrapping_mul\" => BinOp::Mul,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n-            };\n-            let res = crate::num::codegen_int_binop(\n-                fx,\n-                bin_op,\n-                x,\n-                y,\n-            );\n-            ret.write_cvalue(fx, res);\n-        };\n         _ if intrinsic.starts_with(\"saturating_\"), <T> (c lhs, c rhs) {\n             assert_eq!(lhs.layout().ty, rhs.layout().ty);\n             let bin_op = match intrinsic {\n@@ -916,7 +875,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             dest.write_cvalue(fx, val);\n         };\n \n-        size_of | pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n+        pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n             let const_val =\n                 fx.tcx.const_eval_instance(ParamEnv::reveal_all(), instance, None).unwrap();\n             let val = crate::constant::codegen_const_value("}, {"sha": "e0eb5c59590ffba54aeffe2931d933875cf9f093", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -73,11 +73,11 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             assert_eq!(x.layout(), y.layout());\n             let layout = x.layout();\n \n-            let (lane_type, lane_count) = lane_type_and_count(fx.tcx, layout);\n-            let (ret_lane_type, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+            let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n \n-            assert_eq!(lane_type, ret_lane_type);\n-            assert_eq!(n, ret_lane_count);\n+            assert_eq!(lane_ty, ret_lane_ty);\n+            assert_eq!(u64::from(n), ret_lane_count);\n \n             let total_len = lane_count * 2;\n \n@@ -105,14 +105,14 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             for &idx in &indexes {\n-                assert!(idx < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n+                assert!(u64::from(idx) < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n             }\n \n             for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n-                let in_lane = if in_idx < lane_count {\n+                let in_lane = if u64::from(in_idx) < lane_count {\n                     x.value_field(fx, mir::Field::new(in_idx.into()))\n                 } else {\n-                    y.value_field(fx, mir::Field::new((in_idx - lane_count).into()))\n+                    y.value_field(fx, mir::Field::new(usize::from(in_idx) - usize::try_from(lane_count).unwrap()))\n                 };\n                 let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n                 out_lane.write_cvalue(fx, in_lane);\n@@ -131,7 +131,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n-            let (_lane_type, lane_count) = lane_type_and_count(fx.tcx, base.layout());\n+            let (lane_count, _lane_ty) = base.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count));\n             }\n@@ -160,7 +160,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             };\n \n             let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n-            let (_lane_type, lane_count) = lane_type_and_count(fx.tcx, v.layout());\n+            let (lane_count, _lane_ty) = v.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n             }\n@@ -212,12 +212,13 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             assert_eq!(a.layout(), c.layout());\n             let layout = a.layout();\n \n-            let (_lane_layout, lane_count) = lane_type_and_count(fx.tcx, layout);\n-            let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx.tcx, ret.layout());\n+            let (lane_count, _lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n             assert_eq!(lane_count, ret_lane_count);\n+            let ret_lane_layout = fx.layout_of(ret_lane_ty);\n \n             for lane in 0..lane_count {\n-                let lane = mir::Field::new(lane.into());\n+                let lane = mir::Field::new(lane.try_into().unwrap());\n                 let a_lane = a.value_field(fx, lane).load_scalar(fx);\n                 let b_lane = b.value_field(fx, lane).load_scalar(fx);\n                 let c_lane = c.value_field(fx, lane).load_scalar(fx);"}, {"sha": "6e4f3bf2898d827900ec449dafd08325ea77b886", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -5,7 +5,8 @@\n     associated_type_bounds,\n     never_type,\n     try_blocks,\n-    hash_drain_filter\n+    hash_drain_filter,\n+    str_split_once\n )]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n@@ -34,6 +35,7 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n+use std::str::FromStr;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n@@ -141,8 +143,8 @@ struct CodegenCx<'tcx, M: Module> {\n }\n \n impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n-    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool) -> Self {\n-        let unwind_context = UnwindContext::new(tcx, module.isa());\n+    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool, pic_eh_frame: bool) -> Self {\n+        let unwind_context = UnwindContext::new(tcx, module.isa(), pic_eh_frame);\n         let debug_context = if debug_info {\n             Some(DebugContext::new(tcx, module.isa()))\n         } else {\n@@ -172,12 +174,55 @@ impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n }\n \n #[derive(Copy, Clone, Debug)]\n+pub enum CodegenMode {\n+    Aot,\n+    Jit,\n+    JitLazy,\n+}\n+\n+impl Default for CodegenMode {\n+    fn default() -> Self {\n+        CodegenMode::Aot\n+    }\n+}\n+\n+impl FromStr for CodegenMode {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"aot\" => Ok(CodegenMode::Aot),\n+            \"jit\" => Ok(CodegenMode::Jit),\n+            \"jit-lazy\" => Ok(CodegenMode::JitLazy),\n+            _ => Err(format!(\"Unknown codegen mode `{}`\", s)),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Default)]\n pub struct BackendConfig {\n-    pub use_jit: bool,\n+    pub codegen_mode: CodegenMode,\n+}\n+\n+impl BackendConfig {\n+    fn from_opts(opts: &[String]) -> Result<Self, String> {\n+        let mut config = BackendConfig::default();\n+        for opt in opts {\n+            if let Some((name, value)) = opt.split_once('=') {\n+                match name {\n+                    \"mode\" => config.codegen_mode = value.parse()?,\n+                    _ => return Err(format!(\"Unknown option `{}`\", name)),\n+                }\n+            } else {\n+                return Err(format!(\"Invalid option `{}`\", opt));\n+            }\n+        }\n+        Ok(config)\n+    }\n }\n \n pub struct CraneliftCodegenBackend {\n-    pub config: BackendConfig,\n+    pub config: Option<BackendConfig>,\n }\n \n impl CodegenBackend for CraneliftCodegenBackend {\n@@ -204,7 +249,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n-        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, self.config);\n+        let config = if let Some(config) = self.config {\n+            config\n+        } else {\n+            BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n+                .unwrap_or_else(|err| tcx.sess.fatal(&err))\n+        };\n+        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, config);\n \n         rustc_symbol_mangling::test::report_symbol_names(tcx);\n \n@@ -250,17 +301,13 @@ fn target_triple(sess: &Session) -> target_lexicon::Triple {\n     sess.target.llvm_target.parse().unwrap()\n }\n \n-fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'static> {\n+fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n     use target_lexicon::BinaryFormat;\n \n     let target_triple = crate::target_triple(sess);\n \n     let mut flags_builder = settings::builder();\n-    if enable_pic {\n-        flags_builder.enable(\"is_pic\").unwrap();\n-    } else {\n-        flags_builder.set(\"is_pic\", \"false\").unwrap();\n-    }\n+    flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     flags_builder\n         .set(\n@@ -283,8 +330,6 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n \n     flags_builder.set(\"enable_simd\", \"true\").unwrap();\n \n-    // FIXME(CraneStation/cranelift#732) fix LICM in presence of jump tables\n-    /*\n     use rustc_session::config::OptLevel;\n     match sess.opts.optimize {\n         OptLevel::No => {\n@@ -297,7 +342,7 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n         OptLevel::Size | OptLevel::SizeMin => {\n             sess.warn(\"Optimizing for size is not supported. Just ignoring the request\");\n         }\n-    }*/\n+    }\n \n     let flags = settings::Flags::new(flags_builder);\n \n@@ -311,7 +356,5 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n /// This is the entrypoint for a hot plugged rustc_codegen_cranelift\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n-    Box::new(CraneliftCodegenBackend {\n-        config: BackendConfig { use_jit: false },\n-    })\n+    Box::new(CraneliftCodegenBackend { config: None })\n }"}, {"sha": "a575ed8dc35f80b0a3662df42cade581ab5cf672", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -73,11 +73,48 @@ pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n     })()\n     .unwrap_or_else(|| {\n         match bcx.func.dfg.value_type(arg) {\n-            types::I8 | types::I32 => {\n+            types::I8 | types::I16 => {\n                 // WORKAROUND for brz.i8 and brnz.i8 not yet being implemented\n                 bcx.ins().uextend(types::I32, arg)\n             }\n             _ => arg,\n         }\n     })\n }\n+\n+/// Returns whether the branch is statically known to be taken or `None` if it isn't statically known.\n+pub(crate) fn maybe_known_branch_taken(\n+    bcx: &FunctionBuilder<'_>,\n+    arg: Value,\n+    test_zero: bool,\n+) -> Option<bool> {\n+    let arg_inst = if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+        arg_inst\n+    } else {\n+        return None;\n+    };\n+\n+    match bcx.func.dfg[arg_inst] {\n+        InstructionData::UnaryBool {\n+            opcode: Opcode::Bconst,\n+            imm,\n+        } => {\n+            if test_zero {\n+                Some(!imm)\n+            } else {\n+                Some(imm)\n+            }\n+        }\n+        InstructionData::UnaryImm {\n+            opcode: Opcode::Iconst,\n+            imm,\n+        } => {\n+            if test_zero {\n+                Some(imm.bits() == 0)\n+            } else {\n+                Some(imm.bits() != 0)\n+            }\n+        }\n+        _ => None,\n+    }\n+}"}, {"sha": "22c94fec82fc13a61b03ff1063376ecef26f652d", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 56, "deletions": 46, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -53,6 +53,7 @@\n //! ```\n \n use std::fmt;\n+use std::io::Write;\n \n use cranelift_codegen::{\n     entity::SecondaryMap,\n@@ -200,32 +201,24 @@ impl<M: Module> FunctionCx<'_, '_, M> {\n     }\n }\n \n-pub(crate) fn write_clif_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    postfix: &str,\n-    isa: Option<&dyn cranelift_codegen::isa::TargetIsa>,\n-    instance: Instance<'tcx>,\n-    context: &cranelift_codegen::Context,\n-    mut clif_comments: &CommentWriter,\n-) {\n-    use std::io::Write;\n-\n-    if !cfg!(debug_assertions)\n-        && !tcx\n+pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n+    cfg!(debug_assertions)\n+        || tcx\n             .sess\n             .opts\n             .output_types\n             .contains_key(&OutputType::LlvmAssembly)\n-    {\n+}\n+\n+pub(crate) fn write_ir_file<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    name: &str,\n+    write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n+) {\n+    if !should_write_ir(tcx) {\n         return;\n     }\n \n-    let value_ranges = isa.map(|isa| {\n-        context\n-            .build_value_labels_ranges(isa)\n-            .expect(\"value location ranges\")\n-    });\n-\n     let clif_output_dir = tcx.output_filenames(LOCAL_CRATE).with_extension(\"clif\");\n \n     match std::fs::create_dir(&clif_output_dir) {\n@@ -234,41 +227,58 @@ pub(crate) fn write_clif_file<'tcx>(\n         res @ Err(_) => res.unwrap(),\n     }\n \n-    let clif_file_name = clif_output_dir.join(format!(\n-        \"{}.{}.clif\",\n-        tcx.symbol_name(instance).name,\n-        postfix\n-    ));\n-\n-    let mut clif = String::new();\n-    cranelift_codegen::write::decorate_function(\n-        &mut clif_comments,\n-        &mut clif,\n-        &context.func,\n-        &DisplayFunctionAnnotations {\n-            isa: Some(&*crate::build_isa(\n-                tcx.sess, true, /* PIC doesn't matter here */\n-            )),\n-            value_ranges: value_ranges.as_ref(),\n-        },\n-    )\n-    .unwrap();\n+    let clif_file_name = clif_output_dir.join(name);\n \n     let res: std::io::Result<()> = try {\n         let mut file = std::fs::File::create(clif_file_name)?;\n-        let target_triple = crate::target_triple(tcx.sess);\n-        writeln!(file, \"test compile\")?;\n-        writeln!(file, \"set is_pic\")?;\n-        writeln!(file, \"set enable_simd\")?;\n-        writeln!(file, \"target {} haswell\", target_triple)?;\n-        writeln!(file)?;\n-        file.write_all(clif.as_bytes())?;\n+        write(&mut file)?;\n     };\n     if let Err(err) = res {\n-        tcx.sess.warn(&format!(\"err writing clif file: {}\", err));\n+        tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n     }\n }\n \n+pub(crate) fn write_clif_file<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    postfix: &str,\n+    isa: Option<&dyn cranelift_codegen::isa::TargetIsa>,\n+    instance: Instance<'tcx>,\n+    context: &cranelift_codegen::Context,\n+    mut clif_comments: &CommentWriter,\n+) {\n+    write_ir_file(\n+        tcx,\n+        &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n+        |file| {\n+            let value_ranges = isa.map(|isa| {\n+                context\n+                    .build_value_labels_ranges(isa)\n+                    .expect(\"value location ranges\")\n+            });\n+\n+            let mut clif = String::new();\n+            cranelift_codegen::write::decorate_function(\n+                &mut clif_comments,\n+                &mut clif,\n+                &context.func,\n+                &DisplayFunctionAnnotations {\n+                    isa: Some(&*crate::build_isa(tcx.sess)),\n+                    value_ranges: value_ranges.as_ref(),\n+                },\n+            )\n+            .unwrap();\n+\n+            writeln!(file, \"test compile\")?;\n+            writeln!(file, \"set is_pic\")?;\n+            writeln!(file, \"set enable_simd\")?;\n+            writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n+            writeln!(file)?;\n+            file.write_all(clif.as_bytes())?;\n+            Ok(())\n+        },\n+    );\n+}\n+\n impl<M: Module> fmt::Debug for FunctionCx<'_, '_, M> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         writeln!(f, \"{:?}\", self.instance.substs)?;"}, {"sha": "8f15586a9dc06b8c2444280a3d80509cefb36552", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b52ee33908f0ede42c549417093750530f9b1e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=55b52ee33908f0ede42c549417093750530f9b1e", "patch": "@@ -158,7 +158,8 @@ fn build_vtable<'tcx>(\n         )\n         .unwrap();\n \n-    fx.cx.module.define_data(data_id, &data_ctx).unwrap();\n+    // FIXME don't duplicate definitions in lazy jit mode\n+    let _ = fx.cx.module.define_data(data_id, &data_ctx);\n \n     data_id\n }"}]}