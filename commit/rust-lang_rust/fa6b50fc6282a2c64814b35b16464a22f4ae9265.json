{"sha": "fa6b50fc6282a2c64814b35b16464a22f4ae9265", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNmI1MGZjNjI4MmEyYzY0ODE0YjM1YjE2NDY0YTIyZjRhZTkyNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-20T06:28:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-20T06:28:16Z"}, "message": "Auto merge of #41413 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 5 pull requests\n\n- Successful merges: #41214, #41369, #41377, #41378, #41390\n- Failed merges:", "tree": {"sha": "3c2914f8b96d35eed2b3cbe0a27bc7b89be4272e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c2914f8b96d35eed2b3cbe0a27bc7b89be4272e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa6b50fc6282a2c64814b35b16464a22f4ae9265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa6b50fc6282a2c64814b35b16464a22f4ae9265", "html_url": "https://github.com/rust-lang/rust/commit/fa6b50fc6282a2c64814b35b16464a22f4ae9265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa6b50fc6282a2c64814b35b16464a22f4ae9265/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bb1530239c801bb46b705eb2874ac4e5b213e54", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bb1530239c801bb46b705eb2874ac4e5b213e54", "html_url": "https://github.com/rust-lang/rust/commit/1bb1530239c801bb46b705eb2874ac4e5b213e54"}, {"sha": "204243fcac7dfb646c37cab0138fc037dcb0bd53", "url": "https://api.github.com/repos/rust-lang/rust/commits/204243fcac7dfb646c37cab0138fc037dcb0bd53", "html_url": "https://github.com/rust-lang/rust/commit/204243fcac7dfb646c37cab0138fc037dcb0bd53"}], "stats": {"total": 246, "additions": 197, "deletions": 49}, "files": [{"sha": "4d8b31a33cdef59f12344fe95e94a4da1ce78376", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -1597,9 +1597,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // generic so we don't have to do anything quite this\n             // terrible.\n             let trace = TypeTrace::dummy(self.tcx);\n-            self.equate(true, trace, a, b).map(|InferOk { obligations, .. }| {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+            self.equate(true, trace, a, b).map(|InferOk { obligations: _, .. }| {\n+                // We can intentionally ignore obligations here, since\n+                // this is part of a simple test for general\n+                // \"equatability\". However, it's not entirely clear\n+                // that we *ought* to be, perhaps a better thing would\n+                // be to use a mini-fulfillment context or something\n+                // like that.\n             })\n         })\n     }"}, {"sha": "a943ef30e534bf57bec8449dd28ce4650160a820", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -55,16 +55,15 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    match selcx.infcx().eq_impl_headers(true,\n+    let obligations = match selcx.infcx().eq_impl_headers(true,\n                                         &ObligationCause::dummy(),\n                                         &a_impl_header,\n                                         &b_impl_header) {\n         Ok(InferOk { obligations, .. }) => {\n-            // FIXME(#32730) propagate obligations\n-            assert!(obligations.is_empty());\n+            obligations\n         }\n         Err(_) => return None\n-    }\n+    };\n \n     debug!(\"overlap: unification check succeeded\");\n \n@@ -78,6 +77,7 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n                      .map(|p| Obligation { cause: ObligationCause::dummy(),\n                                            recursion_depth: 0,\n                                            predicate: p })\n+                     .chain(obligations)\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {"}, {"sha": "ba340a40692c71d0a39c80235871260d54b146c2", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -329,22 +329,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 Some(val) => Some(val),\n                                 None => {\n                                     span_err!(self.tcx.sess, err_sp, E0272,\n-                                                    \"the #[rustc_on_unimplemented] \\\n-                                                            attribute on \\\n-                                                            trait definition for {} refers to \\\n-                                                            non-existent type parameter {}\",\n-                                                            trait_str, s);\n+                                              \"the #[rustc_on_unimplemented] attribute on trait \\\n+                                               definition for {} refers to non-existent type \\\n+                                               parameter {}\",\n+                                              trait_str, s);\n                                     errored = true;\n                                     None\n                                 }\n                             },\n                             _ => {\n                                 span_err!(self.tcx.sess, err_sp, E0273,\n-                                            \"the #[rustc_on_unimplemented] attribute \\\n-                                            on trait definition for {} must have \\\n-                                            named format arguments, eg \\\n-                                            `#[rustc_on_unimplemented = \\\n-                                            \\\"foo {{T}}\\\"]`\", trait_str);\n+                                          \"the #[rustc_on_unimplemented] attribute on trait \\\n+                                           definition for {} must have named format arguments, eg \\\n+                                           `#[rustc_on_unimplemented = \\\"foo {{T}}\\\"]`\",\n+                                          trait_str);\n                                 errored = true;\n                                 None\n                             }\n@@ -485,8 +483,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                              \"impl has stricter requirements than trait\");\n \n         if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n-            err.span_label(trait_item_span,\n-                           &format!(\"definition of `{}` from trait\", item_name));\n+            let span = self.tcx.sess.codemap().def_span(trait_item_span);\n+            err.span_label(span, &format!(\"definition of `{}` from trait\", item_name));\n         }\n \n         err.span_label(\n@@ -692,6 +690,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         assert!(type_def_id.is_local());\n         let span = self.hir.span_if_local(type_def_id).unwrap();\n+        let span = self.sess.codemap().def_span(span);\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n                                        self.item_path_str(type_def_id));\n@@ -709,13 +708,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                       -> DiagnosticBuilder<'tcx>\n     {\n         let trait_str = self.item_path_str(trait_def_id);\n+        let span = self.sess.codemap().def_span(span);\n         let mut err = struct_span_err!(\n             self.sess, span, E0038,\n             \"the trait `{}` cannot be made into an object\",\n             trait_str);\n-        err.span_label(span, &format!(\n-            \"the trait `{}` cannot be made into an object\", trait_str\n-        ));\n+        err.span_label(span, &format!(\"the trait `{}` cannot be made into an object\", trait_str));\n \n         let mut reported_violations = FxHashSet();\n         for violation in violations {"}, {"sha": "d49affa3e872c0172b7d245a6129ee5de377611c", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -184,6 +184,16 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n+    pub fn register_predicate_obligations(&mut self,\n+                                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                          obligations: Vec<PredicateObligation<'tcx>>)\n+    {\n+        for obligation in obligations {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n+    }\n+\n+\n     pub fn region_obligations(&self,\n                               body_id: ast::NodeId)\n                               -> &[RegionObligation<'tcx>]"}, {"sha": "5f02688be34bcbd2e13a8bdcfb3ef270be539556", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -218,7 +218,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n-    let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n+    let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                    target_impl,\n                                                                    target_substs);\n \n@@ -227,9 +227,8 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                               &ObligationCause::dummy(),\n                               source_trait_ref,\n                               target_trait_ref) {\n-        Ok(InferOk { obligations, .. }) => {\n-            // FIXME(#32730) propagate obligations\n-            assert!(obligations.is_empty())\n+        Ok(InferOk { obligations: o, .. }) => {\n+            obligations.extend(o);\n         }\n         Err(_) => {\n             debug!(\"fulfill_implication: {:?} does not unify with {:?}\","}, {"sha": "7447fba3038eaeb151e0c4cacb1fe1aed0c95e72", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub(t1, t2) {\n             Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) once obligations are being propagated, assert the right thing.\n+                // None of these tests should require nested obligations:\n                 assert!(obligations.is_empty());\n             }\n             Err(ref e) => {\n@@ -400,7 +400,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n         match self.lub(t1, t2) {\n             Ok(InferOk { obligations, value: t }) => {\n-                // FIXME(#32730) once obligations are being propagated, assert the right thing.\n+                // None of these tests should require nested obligations:\n                 assert!(obligations.is_empty());\n \n                 self.assert_eq(t, t_lub);\n@@ -415,7 +415,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         match self.glb(t1, t2) {\n             Err(e) => panic!(\"unexpected error computing LUB: {:?}\", e),\n             Ok(InferOk { obligations, value: t }) => {\n-                // FIXME(#32730) once obligations are being propagated, assert the right thing.\n+                // None of these tests should require nested obligations:\n                 assert!(obligations.is_empty());\n \n                 self.assert_eq(t, t_glb);"}, {"sha": "2cfab7df8b30bf93e6587e915acd2fea73964cd7", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -229,12 +229,12 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n         };\n \n         if in_mem {\n-            // `sret` / `byval` parameter thus one less integer register available\n-            int_regs -= 1;\n-\n             arg.make_indirect(ccx);\n             if is_arg {\n                 arg.attrs.set(ArgAttribute::ByVal);\n+            } else {\n+                // `sret` parameter thus one less integer register available\n+                int_regs -= 1;\n             }\n         } else {\n             // split into sized chunks passed individually"}, {"sha": "ae70049cc5bdc1a253dfd0d43819833fd053958a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -294,10 +294,9 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n         let sub_result = infcx.sub_types(false, &cause, impl_fty, trait_fty)\n-            .map(|InferOk { obligations, .. }| {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n-            });\n+                              .map(|InferOk { obligations, .. }| {\n+                                  inh.register_predicates(obligations);\n+                              });\n \n         if let Err(terr) = sub_result {\n             debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\","}, {"sha": "b71ff58ccec3305923fcf0085b165b9d607267e0", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -82,7 +82,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    tcx.infer_ctxt(impl_param_env, Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt(impl_param_env, Reveal::UserFacing).enter(|ref infcx| {\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n@@ -97,8 +97,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n         match infcx.eq_types(true, cause, named_type, fresh_impl_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                fulfillment_cx.register_predicate_obligations(infcx, obligations);\n             }\n             Err(_) => {\n                 let item_span = tcx.hir.span(self_type_node_id);"}, {"sha": "0754b52cf280a24a225d8549b7d20bbca85298a9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -109,7 +109,7 @@ use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::traits::{ObligationCause, ObligationCauseCode, Reveal};\n+use rustc::traits::{FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n use session::config;\n use util::common::time;\n \n@@ -153,15 +153,22 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::UserFacing).enter(|ref infcx| {\n+        let mut fulfill_cx = FulfillmentContext::new();\n         match infcx.eq_types(false, &cause, expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n-                true\n+                fulfill_cx.register_predicate_obligations(infcx, obligations);\n             }\n             Err(err) => {\n                 infcx.report_mismatched_types(cause, expected, actual, err).emit();\n+                return false;\n+            }\n+        }\n+\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Ok(()) => true,\n+            Err(errors) => {\n+                infcx.report_fulfillment_errors(&errors);\n                 false\n             }\n         }"}, {"sha": "b90192dd8af24ba2cd78569e1778091c90b2587b", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -677,7 +677,13 @@ impl Borrow<OsStr> for OsString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for OsStr {\n     type Owned = OsString;\n-    fn to_owned(&self) -> OsString { self.to_os_string() }\n+    fn to_owned(&self) -> OsString {\n+        self.to_os_string()\n+    }\n+    fn clone_into(&self, target: &mut OsString) {\n+        target.clear();\n+        target.push(self);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -863,4 +869,14 @@ mod tests {\n         let boxed = <Box<OsStr>>::default();\n         assert!(boxed.is_empty());\n     }\n+\n+    #[test]\n+    fn test_os_str_clone_into() {\n+        let mut os_string = OsString::with_capacity(123);\n+        os_string.push(\"hello\");\n+        let os_str = OsStr::new(\"bonjour\");\n+        os_str.clone_into(&mut os_string);\n+        assert_eq!(os_str, os_string);\n+        assert!(os_string.capacity() >= 123);\n+    }\n }"}, {"sha": "367779bb701c858f95f29fc28d39c510962f33e6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -311,6 +311,7 @@\n #![feature(str_utf16)]\n #![feature(test, rustc_private)]\n #![feature(thread_local)]\n+#![feature(toowned_clone_into)]\n #![feature(try_from)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]"}, {"sha": "812b65b61e7f0a9a2af511e4ad90d32bb7cec218", "filename": "src/libstd/path.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -1414,6 +1414,9 @@ impl ToOwned for Path {\n     fn to_owned(&self) -> PathBuf {\n         self.to_path_buf()\n     }\n+    fn clone_into(&self, target: &mut PathBuf) {\n+        self.inner.clone_into(&mut target.inner);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -3859,4 +3862,13 @@ mod tests {\n         assert_eq!(&*boxed, &*path_buf);\n         assert_eq!(&*path_buf, path);\n     }\n+\n+    #[test]\n+    fn test_clone_into() {\n+        let mut path_buf = PathBuf::from(\"supercalifragilisticexpialidocious\");\n+        let path = Path::new(\"short\");\n+        path.clone_into(&mut path_buf);\n+        assert_eq!(path, path_buf);\n+        assert!(path_buf.into_os_string().capacity() >= 15);\n+    }\n }"}, {"sha": "da2d0a33d1a10deeb1f175041aa3710758c25805", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -441,6 +441,25 @@ impl CodeMap {\n         }\n     }\n \n+    /// Given a `Span`, try to get a shorter span ending before the first occurrence of `c` `char`\n+    pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n+        match self.span_to_snippet(sp) {\n+            Ok(snippet) => {\n+                let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_right();\n+                if snippet.len() > 0 && !snippet.contains('\\n') {\n+                    Span { hi: BytePos(sp.lo.0 + snippet.len() as u32), ..sp }\n+                } else {\n+                    sp\n+                }\n+            }\n+            _ => sp,\n+        }\n+    }\n+\n+    pub fn def_span(&self, sp: Span) -> Span {\n+        self.span_until_char(sp, '{')\n+    }\n+\n     pub fn get_filemap(&self, filename: &str) -> Option<Rc<FileMap>> {\n         for fm in self.files.borrow().iter() {\n             if filename == fm.name {"}, {"sha": "dc6931c1d0bdd5c25ea129a8d19256fcaa9fb8e6", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -12,4 +12,4 @@\n # tarball for a stable release you'll likely see `1.x.0-$date` where `1.x.0` was\n # released on `$date`\n \n-rustc: beta-2017-03-21\n+rustc: beta-2017-04-05"}, {"sha": "44a940a17a98a40288a8281c39c945ae072d5451", "filename": "src/test/run-make/extern-fn-struct-passing-abi/test.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -137,6 +137,21 @@ void byval_rect_with_float(int32_t a, int32_t b, float c, int32_t d,\n     assert(s.d == 556);\n }\n \n+// System V x86_64 ABI:\n+// a, b, d, e, f should be byval pointer (on the stack)\n+// g passed via register (fixes #41375)\n+//\n+// Win64 ABI:\n+// a, b, d, e, f, g should be byval pointer\n+void byval_rect_with_many_huge(struct Huge a, struct Huge b, struct Huge c,\n+                               struct Huge d, struct Huge e, struct Huge f,\n+                               struct Rect g) {\n+    assert(g.a == 123);\n+    assert(g.b == 456);\n+    assert(g.c == 789);\n+    assert(g.d == 420);\n+}\n+\n // System V x86_64 & Win64 ABI:\n // a, b should be in registers\n // s should be split across 2 integer registers"}, {"sha": "aaae7ae4fb49bb3d58933502c42169853bf24544", "filename": "src/test/run-make/extern-fn-struct-passing-abi/test.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -64,6 +64,8 @@ extern {\n \n     fn byval_rect_with_float(a: i32, b: i32, c: f32, d: i32, e: i32, f: i32, s: Rect);\n \n+    fn byval_rect_with_many_huge(a: Huge, b: Huge, c: Huge, d: Huge, e: Huge, f: Huge, g: Rect);\n+\n     fn split_rect(a: i32, b: i32, s: Rect);\n \n     fn split_rect_floats(a: f32, b: f32, s: FloatRect);\n@@ -95,6 +97,12 @@ fn main() {\n         byval_many_rect(1, 2, 3, 4, 5, 6, s);\n         byval_rect_floats(1., 2., 3., 4., 5., 6., 7., s, u);\n         byval_rect_with_float(1, 2, 3.0, 4, 5, 6, s);\n+        byval_rect_with_many_huge(v, v, v, v, v, v, Rect {\n+            a: 123,\n+            b: 456,\n+            c: 789,\n+            d: 420\n+        });\n         split_rect(1, 2, s);\n         split_rect_floats(1., 2., u);\n         split_rect_with_floats(1, 2, 3.0, 4, 5.0, 6, s);"}, {"sha": "2b9baa746748b768dbddb10ff530346c24457151", "filename": "src/test/run-pass/issue-41298.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Frun-pass%2Fissue-41298.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Frun-pass%2Fissue-41298.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41298.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Function<T, F> { t: T, f: F }\n+\n+impl<T, R> Function<T, fn() -> R> { fn foo() { } }\n+impl<T, R> Function<T, fn() -> R> { fn bar() { } }\n+\n+fn main() { }"}, {"sha": "2ef8c830eb2fe5173c8f774a0a1053f75d74a33c", "filename": "src/test/ui/resolve/issue-3907-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -2,7 +2,7 @@ error[E0038]: the trait `issue_3907::Foo` cannot be made into an object\n   --> $DIR/issue-3907-2.rs:20:1\n    |\n 20 | fn bar(_x: Foo) {}\n-   | ^^^^^^^^^^^^^^^^^^ the trait `issue_3907::Foo` cannot be made into an object\n+   | ^^^^^^^^^^^^^^^ the trait `issue_3907::Foo` cannot be made into an object\n    |\n    = note: method `bar` has no receiver\n "}, {"sha": "18ade4f1ab68ef424fdae04d554d0c1c3318192e", "filename": "src/test/ui/span/E0072.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fspan%2FE0072.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fspan%2FE0072.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0072.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct ListNode { //~ ERROR E0072\n-                  //~| NOTE recursive type has infinite size\n+struct ListNode {\n     head: u8,\n     tail: Option<ListNode>,\n }", "previous_filename": "src/test/compile-fail/E0072.rs"}, {"sha": "5204390ef9d2a8ace3ca0ff18d4c7b47859462e0", "filename": "src/test/ui/span/E0072.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0072.stderr?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -0,0 +1,10 @@\n+error[E0072]: recursive type `ListNode` has infinite size\n+  --> $DIR/E0072.rs:11:1\n+   |\n+11 | struct ListNode {\n+   | ^^^^^^^^^^^^^^^ recursive type has infinite size\n+   |\n+   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ListNode` representable\n+\n+error: aborting due to previous error\n+"}, {"sha": "323e7fb5a42c09bc893880b6bcb19a537fe2583c", "filename": "src/test/ui/span/multiline-span-E0072.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.rs?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// It should just use the entire body instead of pointing at the next two lines\n+struct\n+ListNode\n+{\n+    head: u8,\n+    tail: Option<ListNode>,\n+}\n+\n+fn main() {\n+}"}, {"sha": "58cdc50230063cc99470275eadd2b8cda8ad8973", "filename": "src/test/ui/span/multiline-span-E0072.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6b50fc6282a2c64814b35b16464a22f4ae9265/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr?ref=fa6b50fc6282a2c64814b35b16464a22f4ae9265", "patch": "@@ -0,0 +1,16 @@\n+error[E0072]: recursive type `ListNode` has infinite size\n+  --> $DIR/multiline-span-E0072.rs:12:1\n+   |\n+12 |   struct\n+   |  _^ starting here...\n+13 | | ListNode\n+14 | | {\n+15 | |     head: u8,\n+16 | |     tail: Option<ListNode>,\n+17 | | }\n+   | |_^ ...ending here: recursive type has infinite size\n+   |\n+   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ListNode` representable\n+\n+error: aborting due to previous error\n+"}]}