{"sha": "13985724033467ab86da9136c43fe242092b294e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzOTg1NzI0MDMzNDY3YWI4NmRhOTEzNmM0M2ZlMjQyMDkyYjI5NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-25T00:31:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-25T00:31:58Z"}, "message": "Auto merge of #52680 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #52391 (Add unaligned volatile intrinsics)\n - #52402 (impl PartialEq+Eq for BuildHasherDefault)\n - #52645 (Allow declaring existential types inside blocks)\n - #52656 (Stablize Redox Unix Sockets)\n - #52658 (Prefer `Option::map`/etc over `match` wherever it improves clarity)\n - #52668 (clarify pointer offset function safety concerns)\n - #52677 (Release notes: add some missing 1.28 libs stabilization)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "b0f41cba1aee734fa57945896cb6044fc962a046", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0f41cba1aee734fa57945896cb6044fc962a046"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13985724033467ab86da9136c43fe242092b294e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13985724033467ab86da9136c43fe242092b294e", "html_url": "https://github.com/rust-lang/rust/commit/13985724033467ab86da9136c43fe242092b294e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13985724033467ab86da9136c43fe242092b294e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46804ef0cee4b55ed9922719da243b6edd9101b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/46804ef0cee4b55ed9922719da243b6edd9101b2", "html_url": "https://github.com/rust-lang/rust/commit/46804ef0cee4b55ed9922719da243b6edd9101b2"}, {"sha": "1deaed9e5e5c3d0676183e5dd250574e240b5138", "url": "https://api.github.com/repos/rust-lang/rust/commits/1deaed9e5e5c3d0676183e5dd250574e240b5138", "html_url": "https://github.com/rust-lang/rust/commit/1deaed9e5e5c3d0676183e5dd250574e240b5138"}], "stats": {"total": 257, "additions": 191, "deletions": 66}, "files": [{"sha": "b983851f881987a11089e8409ca0c5666e378c5f", "filename": "RELEASES.md", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -52,6 +52,16 @@ Stabilized APIs\n ---------------\n - [`Iterator::step_by`]\n - [`Path::ancestors`]\n+- [`SystemTime::UNIX_EPOCH`]\n+- [`alloc::GlobalAlloc`]\n+- [`alloc::Layout`]\n+- [`alloc::LayoutErr`]\n+- [`alloc::System`]\n+- [`alloc::alloc`]\n+- [`alloc::alloc_zeroed`]\n+- [`alloc::dealloc`]\n+- [`alloc::realloc`]\n+- [`alloc::handle_alloc_error`]\n - [`btree_map::Entry::or_default`]\n - [`fmt::Alignment`]\n - [`hash_map::Entry::or_default`]\n@@ -122,6 +132,16 @@ Compatibility Notes\n [cargo/5584]: https://github.com/rust-lang/cargo/pull/5584/\n [`Iterator::step_by`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by\n [`Path::ancestors`]: https://doc.rust-lang.org/std/path/struct.Path.html#method.ancestors\n+[`SystemTime::UNIX_EPOCH`]: https://doc.rust-lang.org/std/time/struct.SystemTime.html#associatedconstant.UNIX_EPOCH\n+[`alloc::GlobalAlloc`]: https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html\n+[`alloc::Layout`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html\n+[`alloc::LayoutErr`]: https://doc.rust-lang.org/std/alloc/struct.LayoutErr.html\n+[`alloc::System`]: https://doc.rust-lang.org/std/alloc/struct.System.html\n+[`alloc::alloc`]: https://doc.rust-lang.org/std/alloc/fn.alloc.html\n+[`alloc::alloc_zeroed`]: https://doc.rust-lang.org/std/alloc/fn.alloc_zeroed.html\n+[`alloc::dealloc`]: https://doc.rust-lang.org/std/alloc/fn.dealloc.html\n+[`alloc::realloc`]: https://doc.rust-lang.org/std/alloc/fn.realloc.html\n+[`alloc::handle_alloc_error`]: https://doc.rust-lang.org/std/alloc/fn.handle_alloc_error.html\n [`btree_map::Entry::or_default`]: https://doc.rust-lang.org/std/collections/btree_map/enum.Entry.html#method.or_default\n [`fmt::Alignment`]: https://doc.rust-lang.org/std/fmt/enum.Alignment.html\n [`hash_map::Entry::or_default`]: https://doc.rust-lang.org/std/collections/btree_map/enum.Entry.html#method.or_default\n@@ -3162,7 +3182,7 @@ Stabilized APIs\n * [`UnixDatagram::shutdown`](http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.shutdown)\n * RawFd impls for `UnixDatagram`\n * `{BTree,Hash}Map::values_mut`\n-* [`<[_]>::binary_search_by_key`](http://doc.rust-lang.org/beta/std/primitive.slice.html#method.binary_search_by_key)\n+* [`<[_]>::binary_search_by_key`](http://doc.rust-lang.org/std/primitive.slice.html#method.binary_search_by_key)\n \n Libraries\n ---------\n@@ -4080,7 +4100,7 @@ Compatibility Notes\n [1.6bh]: https://github.com/rust-lang/rust/pull/29811\n [1.6c]: https://github.com/rust-lang/cargo/pull/2192\n [1.6cc]: https://github.com/rust-lang/cargo/pull/2131\n-[1.6co]: http://doc.rust-lang.org/beta/core/index.html\n+[1.6co]: http://doc.rust-lang.org/core/index.html\n [1.6dv]: https://github.com/rust-lang/rust/pull/30000\n [1.6f]: https://github.com/rust-lang/rust/pull/29129\n [1.6m]: https://github.com/rust-lang/rust/pull/29828"}, {"sha": "e7907e0344493bf13b8a298a84f4ec08ce21c69b", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -542,6 +542,16 @@ impl<H> Default for BuildHasherDefault<H> {\n     }\n }\n \n+#[stable(since = \"1.29.0\", feature = \"build_hasher_eq\")]\n+impl<H> PartialEq for BuildHasherDefault<H> {\n+    fn eq(&self, _other: &BuildHasherDefault<H>) -> bool {\n+        true\n+    }\n+}\n+\n+#[stable(since = \"1.29.0\", feature = \"build_hasher_eq\")]\n+impl<H> Eq for BuildHasherDefault<H> {}\n+\n //////////////////////////////////////////////////////////////////////////////\n \n mod impls {"}, {"sha": "854cb5f4e3b3f77a1791896e3f8df6d0eaba57dd", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -1085,6 +1085,15 @@ extern \"rust-intrinsic\" {\n     /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n+    /// Perform a volatile load from the `src` pointer\n+    /// The pointer is not required to be aligned.\n+    #[cfg(not(stage0))]\n+    pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n+    /// Perform a volatile store to the `dst` pointer.\n+    /// The pointer is not required to be aligned.\n+    #[cfg(not(stage0))]\n+    pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n+\n     /// Returns the square root of an `f32`\n     pub fn sqrtf32(x: f32) -> f32;\n     /// Returns the square root of an `f64`"}, {"sha": "be82ab44cd1fcbf3b00d40ce528652d0aebc223d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -591,7 +591,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of an allocated object.\n+    ///   byte past the end of *the same* allocated object.\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -643,9 +643,15 @@ impl<T: ?Sized> *const T {\n     ///\n     /// The resulting pointer does not need to be in bounds, but it is\n     /// potentially hazardous to dereference (which requires `unsafe`).\n+    /// In particular, the resulting pointer may *not* be used to access a\n+    /// different allocated object than the one `self` points to. In other\n+    /// words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n+    /// *not* the same as `y`, and dereferencing it is undefined behavior\n+    /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.\n+    /// allows the compiler to optimize better.  If you need to cross object\n+    /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples\n     ///\n@@ -1340,7 +1346,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of an allocated object.\n+    ///   byte past the end of *the same* allocated object.\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -1391,9 +1397,15 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// The resulting pointer does not need to be in bounds, but it is\n     /// potentially hazardous to dereference (which requires `unsafe`).\n+    /// In particular, the resulting pointer may *not* be used to access a\n+    /// different allocated object than the one `self` points to. In other\n+    /// words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n+    /// *not* the same as `y`, and dereferencing it is undefined behavior\n+    /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.\n+    /// allows the compiler to optimize better.  If you need to cross object\n+    /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples\n     ///"}, {"sha": "86b8349fa3c89cd1894f39d8172b4d02e9465873", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -696,13 +696,10 @@ impl<'a> Iterator for CharIndices<'a> {\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(usize, char)> {\n-        match self.iter.next_back() {\n-            None => None,\n-            Some(ch) => {\n-                let index = self.front_offset + self.iter.iter.len();\n-                Some((index, ch))\n-            }\n-        }\n+        self.iter.next_back().map(|ch| {\n+            let index = self.front_offset + self.iter.iter.len();\n+            (index, ch)\n+        })\n     }\n }\n "}, {"sha": "e1395c3fa442723c2bba781ea5918aee35bd902d", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -190,11 +190,10 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n             if let Some(ref condition) = command.condition {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n-                    options.contains(&(c.name().as_str().to_string(),\n-                                      match c.value_str().map(|s| s.as_str().to_string()) {\n-                                          Some(s) => Some(s),\n-                                          None => None\n-                                      }))\n+                    options.contains(&(\n+                        c.name().as_str().to_string(),\n+                        c.value_str().map(|s| s.as_str().to_string())\n+                    ))\n                 }) {\n                     debug!(\"evaluate: skipping {:?} due to condition\", command);\n                     continue"}, {"sha": "c2795bae01029f4e27871d91441beecc8400a0d4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -2697,15 +2697,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.opt_associated_item(def_id)\n         };\n \n-        match item {\n-            Some(trait_item) => {\n-                match trait_item.container {\n-                    TraitContainer(_) => None,\n-                    ImplContainer(def_id) => Some(def_id),\n-                }\n+        item.and_then(|trait_item|\n+            match trait_item.container {\n+                TraitContainer(_) => None,\n+                ImplContainer(def_id) => Some(def_id),\n             }\n-            None => None\n-        }\n+        )\n     }\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`"}, {"sha": "b34d0f1cd9070854c013d58fcfa43c1c7a220570", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -54,6 +54,7 @@ bitflags! {\n     pub struct MemFlags: u8 {\n         const VOLATILE = 1 << 0;\n         const NONTEMPORAL = 1 << 1;\n+        const UNALIGNED = 1 << 2;\n     }\n }\n \n@@ -602,7 +603,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n-            llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n+            let align = if flags.contains(MemFlags::UNALIGNED) {\n+                1\n+            } else {\n+                align.abi() as c_uint\n+            };\n+            llvm::LLVMSetAlignment(store, align);\n             if flags.contains(MemFlags::VOLATILE) {\n                 llvm::LLVMSetVolatile(store, llvm::True);\n             }"}, {"sha": "9c5c0f730c161e8e8eb6a4fed1989a6e0c178c43", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -234,15 +234,20 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             memset_intrinsic(bx, true, substs.type_at(0),\n                              args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n-        \"volatile_load\" => {\n+        \"volatile_load\" | \"unaligned_volatile_load\" => {\n             let tp_ty = substs.type_at(0);\n             let mut ptr = args[0].immediate();\n             if let PassMode::Cast(ty) = fn_ty.ret.mode {\n                 ptr = bx.pointercast(ptr, ty.llvm_type(cx).ptr_to());\n             }\n             let load = bx.volatile_load(ptr);\n+            let align = if name == \"unaligned_volatile_load\" {\n+                1\n+            } else {\n+                cx.align_of(tp_ty).abi() as u32\n+            };\n             unsafe {\n-                llvm::LLVMSetAlignment(load, cx.align_of(tp_ty).abi() as u32);\n+                llvm::LLVMSetAlignment(load, align);\n             }\n             to_immediate(bx, load, cx.layout_of(tp_ty))\n         },\n@@ -251,6 +256,11 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             args[1].val.volatile_store(bx, dst);\n             return;\n         },\n+        \"unaligned_volatile_store\" => {\n+            let dst = args[0].deref(bx.cx);\n+            args[1].val.unaligned_volatile_store(bx, dst);\n+            return;\n+        },\n         \"prefetch_read_data\" | \"prefetch_write_data\" |\n         \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n             let expect = cx.get_intrinsic(&(\"llvm.prefetch\"));"}, {"sha": "c433df51110e352b9cabc0b41418abd8858df37e", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -276,6 +276,10 @@ impl<'a, 'tcx> OperandValue {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n     }\n \n+    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+        self.store_with_flags(bx, dest, MemFlags::VOLATILE | MemFlags::UNALIGNED);\n+    }\n+\n     pub fn nontemporal_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }"}, {"sha": "42af5db82942aadb25b10a31ccf10733dfde08fa", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -824,17 +824,14 @@ impl<'a> Context<'a> {\n         if rlib.is_none() && rmeta.is_none() && dylib.is_none() {\n             return None;\n         }\n-        match slot {\n-            Some((_, metadata)) => {\n-                Some(Library {\n-                    dylib,\n-                    rlib,\n-                    rmeta,\n-                    metadata,\n-                })\n+        slot.map(|(_, metadata)|\n+            Library {\n+                dylib,\n+                rlib,\n+                rmeta,\n+                metadata,\n             }\n-            None => None,\n-        }\n+        )\n     }\n }\n "}, {"sha": "af4356dc8de7816e1da472accfdf96903b0059c9", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -270,9 +270,9 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"roundf32\"     => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n             \"roundf64\"     => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n \n-            \"volatile_load\" =>\n+            \"volatile_load\" | \"unaligned_volatile_load\" =>\n                 (1, vec![ tcx.mk_imm_ptr(param(0)) ], param(0)),\n-            \"volatile_store\" =>\n+            \"volatile_store\" | \"unaligned_volatile_store\" =>\n                 (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil()),\n \n             \"ctpop\" | \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" |"}, {"sha": "008c5da171ffc663e68a1afe06701b71b40b3f23", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -53,10 +53,7 @@ impl<'a> Parser<'a> {\n         F: FnOnce(&mut Parser) -> Option<T>,\n     {\n         self.read_atomically(move |p| {\n-            match cb(p) {\n-                Some(x) => if p.is_eof() {Some(x)} else {None},\n-                None => None,\n-            }\n+            cb(p).filter(|_| p.is_eof())\n         })\n     }\n "}, {"sha": "688a7e99f10edf0b7cb57fc136122d2e2a016c50", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -1065,10 +1065,7 @@ impl<'a> Iterator for Ancestors<'a> {\n \n     fn next(&mut self) -> Option<Self::Item> {\n         let next = self.next;\n-        self.next = match next {\n-            Some(path) => path.parent(),\n-            None => None,\n-        };\n+        self.next = next.and_then(Path::parent);\n         next\n     }\n }"}, {"sha": "2ab7770324254b8109aaf705630c6cc0c42f5d5d", "filename": "src/libstd/sys/redox/ext/net.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"unix_socket_redox\", reason = \"new feature\", issue=\"51553\")]\n+#![stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n \n //! Unix-specific networking functionality\n \n@@ -37,6 +37,7 @@ use sys::{cvt, fd::FileDesc, syscall};\n /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n /// ```\n #[derive(Clone)]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n pub struct SocketAddr(());\n \n impl SocketAddr {\n@@ -64,6 +65,7 @@ impl SocketAddr {\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// assert_eq!(addr.as_pathname(), None);\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn as_pathname(&self) -> Option<&Path> {\n         None\n     }\n@@ -91,10 +93,12 @@ impl SocketAddr {\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// assert_eq!(addr.is_unnamed(), true);\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn is_unnamed(&self) -> bool {\n         false\n     }\n }\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl fmt::Debug for SocketAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"SocketAddr\")\n@@ -115,8 +119,10 @@ impl fmt::Debug for SocketAddr {\n /// stream.read_to_string(&mut response).unwrap();\n /// println!(\"{}\", response);\n /// ```\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n pub struct UnixStream(FileDesc);\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl fmt::Debug for UnixStream {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixStream\");\n@@ -147,6 +153,7 @@ impl UnixStream {\n     ///     }\n     /// };\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n         if let Some(s) = path.as_ref().to_str() {\n             cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CLOEXEC))\n@@ -177,6 +184,7 @@ impl UnixStream {\n     ///     }\n     /// };\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n         let server = cvt(syscall::open(\"chan:\", syscall::O_CREAT | syscall::O_CLOEXEC))\n             .map(FileDesc::new)?;\n@@ -200,6 +208,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn try_clone(&self) -> io::Result<UnixStream> {\n         self.0.duplicate().map(UnixStream)\n     }\n@@ -214,6 +223,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n     }\n@@ -228,6 +238,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n     }\n@@ -266,6 +277,7 @@ impl UnixStream {\n     /// let err = result.unwrap_err();\n     /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n     }\n@@ -304,6 +316,7 @@ impl UnixStream {\n     /// let err = result.unwrap_err();\n     /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n     }\n@@ -320,6 +333,7 @@ impl UnixStream {\n     /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n     /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n     }\n@@ -336,6 +350,7 @@ impl UnixStream {\n     /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n     /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n     }\n@@ -350,6 +365,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n@@ -369,6 +385,7 @@ impl UnixStream {\n     ///\n     /// # Platform specific\n     /// On Redox this always returns None.\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)\n     }\n@@ -390,11 +407,13 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl io::Read for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         io::Read::read(&mut &*self, buf)\n@@ -406,6 +425,7 @@ impl io::Read for UnixStream {\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl<'a> io::Read for &'a UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n@@ -417,6 +437,7 @@ impl<'a> io::Read for &'a UnixStream {\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl io::Write for UnixStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         io::Write::write(&mut &*self, buf)\n@@ -427,6 +448,7 @@ impl io::Write for UnixStream {\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl<'a> io::Write for &'a UnixStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n@@ -437,18 +459,21 @@ impl<'a> io::Write for &'a UnixStream {\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl AsRawFd for UnixStream {\n     fn as_raw_fd(&self) -> RawFd {\n         self.0.raw()\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl FromRawFd for UnixStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n         UnixStream(FileDesc::new(fd))\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl IntoRawFd for UnixStream {\n     fn into_raw_fd(self) -> RawFd {\n         self.0.into_raw()\n@@ -483,8 +508,10 @@ impl IntoRawFd for UnixStream {\n ///     }\n /// }\n /// ```\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n pub struct UnixListener(FileDesc);\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl fmt::Debug for UnixListener {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixListener\");\n@@ -512,6 +539,7 @@ impl UnixListener {\n     ///     }\n     /// };\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n         if let Some(s) = path.as_ref().to_str() {\n             cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CREAT | syscall::O_CLOEXEC))\n@@ -545,6 +573,7 @@ impl UnixListener {\n     ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n     /// }\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n         self.0.duplicate_path(b\"listen\").map(|fd| (UnixStream(fd), SocketAddr(())))\n     }\n@@ -564,6 +593,7 @@ impl UnixListener {\n     ///\n     /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn try_clone(&self) -> io::Result<UnixListener> {\n         self.0.duplicate().map(UnixListener)\n     }\n@@ -579,6 +609,7 @@ impl UnixListener {\n     ///\n     /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n     }\n@@ -594,6 +625,7 @@ impl UnixListener {\n     ///\n     /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n@@ -614,6 +646,7 @@ impl UnixListener {\n     ///\n     /// # Platform specific\n     /// On Redox this always returns None.\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)\n     }\n@@ -649,29 +682,34 @@ impl UnixListener {\n     ///     }\n     /// }\n     /// ```\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n         Incoming { listener: self }\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl AsRawFd for UnixListener {\n     fn as_raw_fd(&self) -> RawFd {\n         self.0.raw()\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl FromRawFd for UnixListener {\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n         UnixListener(FileDesc::new(fd))\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl IntoRawFd for UnixListener {\n     fn into_raw_fd(self) -> RawFd {\n         self.0.into_raw()\n     }\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl<'a> IntoIterator for &'a UnixListener {\n     type Item = io::Result<UnixStream>;\n     type IntoIter = Incoming<'a>;\n@@ -712,10 +750,12 @@ impl<'a> IntoIterator for &'a UnixListener {\n /// }\n /// ```\n #[derive(Debug)]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n pub struct Incoming<'a> {\n     listener: &'a UnixListener,\n }\n \n+#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n impl<'a> Iterator for Incoming<'a> {\n     type Item = io::Result<UnixStream>;\n "}, {"sha": "2db47bd59475e5feb57b96d1a3ddbfa74b59071b", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -156,16 +156,15 @@ pub fn log_enabled() -> Option<PrintFormat> {\n         _ => return Some(PrintFormat::Full),\n     }\n \n-    let val = match env::var_os(\"RUST_BACKTRACE\") {\n-        Some(x) => if &x == \"0\" {\n+    let val = env::var_os(\"RUST_BACKTRACE\").and_then(|x|\n+        if &x == \"0\" {\n             None\n         } else if &x == \"full\" {\n             Some(PrintFormat::Full)\n         } else {\n             Some(PrintFormat::Short)\n-        },\n-        None => None,\n-    };\n+        }\n+    );\n     ENABLED.store(match val {\n         Some(v) => v as isize,\n         None => 1,"}, {"sha": "64309dd9b8b93f2e9274325f4201c769195e545f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -4391,6 +4391,11 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(keywords::Extern) && self.look_ahead(1, |t| t != &token::ModSep)\n     }\n \n+    fn is_existential_type_decl(&self) -> bool {\n+        self.token.is_keyword(keywords::Existential) &&\n+        self.look_ahead(1, |t| t.is_keyword(keywords::Type))\n+    }\n+\n     fn is_auto_trait_item(&mut self) -> bool {\n         // auto trait\n         (self.token.is_keyword(keywords::Auto)\n@@ -4495,6 +4500,7 @@ impl<'a> Parser<'a> {\n                   !self.is_union_item() &&\n                   !self.is_crate_vis() &&\n                   !self.is_extern_non_path() &&\n+                  !self.is_existential_type_decl() &&\n                   !self.is_auto_trait_item() {\n             let pth = self.parse_path(PathStyle::Expr)?;\n "}, {"sha": "a0845e0982d2ad362deb7dc55a23a052405f1eba", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -138,17 +138,13 @@ pub fn nil_ty<'r>() -> Ty<'r> {\n }\n \n fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n-    match *lt {\n-        Some(s) => Some(cx.lifetime(span, Ident::from_str(s))),\n-        None => None,\n-    }\n+    lt.map(|s|\n+        cx.lifetime(span, Ident::from_str(s))\n+    )\n }\n \n fn mk_lifetimes(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Vec<ast::Lifetime> {\n-    match *lt {\n-        Some(s) => vec![cx.lifetime(span, Ident::from_str(s))],\n-        None => vec![],\n-    }\n+    mk_lifetime(cx, span, lt).into_iter().collect()\n }\n \n impl<'a> Ty<'a> {"}, {"sha": "d214a20139c9ca8bfd597ed9c82247d08ebc7a8e", "filename": "src/test/run-make-fulldeps/volatile-intrinsics/main.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Ftest%2Frun-make-fulldeps%2Fvolatile-intrinsics%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Ftest%2Frun-make-fulldeps%2Fvolatile-intrinsics%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fvolatile-intrinsics%2Fmain.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -10,17 +10,24 @@\n \n #![feature(core_intrinsics, volatile)]\n \n-use std::intrinsics::{volatile_load, volatile_store};\n+use std::intrinsics::{\n+    unaligned_volatile_load, unaligned_volatile_store, volatile_load, volatile_store,\n+};\n use std::ptr::{read_volatile, write_volatile};\n \n pub fn main() {\n     unsafe {\n-        let mut i : isize = 1;\n+        let mut i: isize = 1;\n         volatile_store(&mut i, 2);\n         assert_eq!(volatile_load(&i), 2);\n     }\n     unsafe {\n-        let mut i : isize = 1;\n+        let mut i: isize = 1;\n+        unaligned_volatile_store(&mut i, 2);\n+        assert_eq!(unaligned_volatile_load(&i), 2);\n+    }\n+    unsafe {\n+        let mut i: isize = 1;\n         write_volatile(&mut i, 2);\n         assert_eq!(read_volatile(&i), 2);\n     }"}, {"sha": "20f9e0d77c3127f50d0b36b7276523efa2b1cbd8", "filename": "src/test/ui/impl-trait/existential_type_in_fn_body.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/13985724033467ab86da9136c43fe242092b294e/src%2Ftest%2Fui%2Fimpl-trait%2Fexistential_type_in_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13985724033467ab86da9136c43fe242092b294e/src%2Ftest%2Fui%2Fimpl-trait%2Fexistential_type_in_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fexistential_type_in_fn_body.rs?ref=13985724033467ab86da9136c43fe242092b294e", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(existential_type)]\n+\n+use std::fmt::Debug;\n+\n+fn main() {\n+    existential type Existential: Debug;\n+\n+    fn f() -> Existential {}\n+    println!(\"{:?}\", f());\n+}"}]}