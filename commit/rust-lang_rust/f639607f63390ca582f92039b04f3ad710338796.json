{"sha": "f639607f63390ca582f92039b04f3ad710338796", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2Mzk2MDdmNjMzOTBjYTU4MmY5MjAzOWIwNGYzYWQ3MTAzMzg3OTY=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-20T23:18:13Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-11T20:14:05Z"}, "message": "Use new dataflow framework for drop elaboration and borrow checking", "tree": {"sha": "133ae65a99485d8120472eeba9e797c770e3118f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/133ae65a99485d8120472eeba9e797c770e3118f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f639607f63390ca582f92039b04f3ad710338796", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f639607f63390ca582f92039b04f3ad710338796", "html_url": "https://github.com/rust-lang/rust/commit/f639607f63390ca582f92039b04f3ad710338796", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f639607f63390ca582f92039b04f3ad710338796/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce3f37b42ba25ab6fe2f401135be847a0351fbbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3f37b42ba25ab6fe2f401135be847a0351fbbe", "html_url": "https://github.com/rust-lang/rust/commit/ce3f37b42ba25ab6fe2f401135be847a0351fbbe"}], "stats": {"total": 478, "additions": 166, "deletions": 312}, "files": [{"sha": "57c544fda0c5467f30099bf523dc75e76aebcdac", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f37b42ba25ab6fe2f401135be847a0351fbbe/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f37b42ba25ab6fe2f401135be847a0351fbbe/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=ce3f37b42ba25ab6fe2f401135be847a0351fbbe", "patch": "@@ -1,142 +0,0 @@\n-//! Manages the dataflow bits required for borrowck.\n-//!\n-//! FIXME: this might be better as a \"generic\" fixed-point combinator,\n-//! but is not as ugly as it is right now.\n-\n-use rustc::mir::{BasicBlock, Location};\n-use rustc_index::bit_set::BitIter;\n-\n-use crate::borrow_check::location::LocationIndex;\n-\n-use crate::borrow_check::nll::PoloniusOutput;\n-\n-use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::HasMoveData;\n-use crate::dataflow::Borrows;\n-use crate::dataflow::EverInitializedPlaces;\n-use crate::dataflow::MaybeUninitializedPlaces;\n-use crate::dataflow::{FlowAtLocation, FlowsAtLocation};\n-use either::Either;\n-use std::fmt;\n-use std::rc::Rc;\n-\n-crate struct Flows<'b, 'tcx> {\n-    borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n-    pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,\n-    pub ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,\n-\n-    /// Polonius Output\n-    pub polonius_output: Option<Rc<PoloniusOutput>>,\n-}\n-\n-impl<'b, 'tcx> Flows<'b, 'tcx> {\n-    crate fn new(\n-        borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n-        uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,\n-        ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,\n-        polonius_output: Option<Rc<PoloniusOutput>>,\n-    ) -> Self {\n-        Flows { borrows, uninits, ever_inits, polonius_output }\n-    }\n-\n-    crate fn borrows_in_scope(\n-        &self,\n-        location: LocationIndex,\n-    ) -> impl Iterator<Item = BorrowIndex> + '_ {\n-        if let Some(ref polonius) = self.polonius_output {\n-            Either::Left(polonius.errors_at(location).iter().cloned())\n-        } else {\n-            Either::Right(self.borrows.iter_incoming())\n-        }\n-    }\n-\n-    crate fn with_outgoing_borrows(&self, op: impl FnOnce(BitIter<'_, BorrowIndex>)) {\n-        self.borrows.with_iter_outgoing(op)\n-    }\n-}\n-\n-macro_rules! each_flow {\n-    ($this:ident, $meth:ident($arg:ident)) => {\n-        FlowAtLocation::$meth(&mut $this.borrows, $arg);\n-        FlowAtLocation::$meth(&mut $this.uninits, $arg);\n-        FlowAtLocation::$meth(&mut $this.ever_inits, $arg);\n-    };\n-}\n-\n-impl<'b, 'tcx> FlowsAtLocation for Flows<'b, 'tcx> {\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        each_flow!(self, reset_to_entry_of(bb));\n-    }\n-\n-    fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n-        each_flow!(self, reset_to_exit_of(bb));\n-    }\n-\n-    fn reconstruct_statement_effect(&mut self, location: Location) {\n-        each_flow!(self, reconstruct_statement_effect(location));\n-    }\n-\n-    fn reconstruct_terminator_effect(&mut self, location: Location) {\n-        each_flow!(self, reconstruct_terminator_effect(location));\n-    }\n-\n-    fn apply_local_effect(&mut self, location: Location) {\n-        each_flow!(self, apply_local_effect(location));\n-    }\n-}\n-\n-impl<'b, 'tcx> fmt::Display for Flows<'b, 'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut s = String::new();\n-\n-        s.push_str(\"borrows in effect: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_state_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow];\n-            s.push_str(&borrow_data.to_string());\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"borrows generated: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_gen_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow];\n-            s.push_str(&borrow_data.to_string());\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"uninits: [\");\n-        let mut saw_one = false;\n-        self.uninits.each_state_bit(|mpi_uninit| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_path = &self.uninits.operator().move_data().move_paths[mpi_uninit];\n-            s.push_str(&move_path.to_string());\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"ever_init: [\");\n-        let mut saw_one = false;\n-        self.ever_inits.each_state_bit(|mpi_ever_init| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let ever_init = &self.ever_inits.operator().move_data().inits[mpi_ever_init];\n-            s.push_str(&format!(\"{:?}\", ever_init));\n-        });\n-        s.push_str(\"]\");\n-\n-        fmt::Display::fmt(&s, fmt)\n-    }\n-}"}, {"sha": "95e21f3453377301b5852db61921fa8682927120", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 114, "deletions": 102, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=f639607f63390ca582f92039b04f3ad710338796", "patch": "@@ -4,8 +4,8 @@ use rustc::infer::InferCtxt;\n use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n-    read_only, Body, BodyAndCache, ClearCrossCrate, Local, Location, Mutability, Operand, Place,\n-    PlaceElem, PlaceRef, ReadOnlyBodyAndCache,\n+    read_only, traversal, Body, BodyAndCache, ClearCrossCrate, Local, Location, Mutability,\n+    Operand, Place, PlaceElem, PlaceRef, ReadOnlyBodyAndCache,\n };\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n@@ -21,6 +21,7 @@ use rustc_hir::{def_id::DefId, HirId, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n+use either::Either;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n@@ -30,19 +31,17 @@ use std::rc::Rc;\n use rustc_span::{Span, DUMMY_SP};\n use syntax::ast::Name;\n \n+use crate::dataflow;\n+use crate::dataflow::generic::{Analysis, BorrowckFlowState as Flows, BorrowckResults};\n use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n-use crate::dataflow::move_paths::{HasMoveData, InitLocation, LookupResult, MoveData, MoveError};\n+use crate::dataflow::move_paths::{InitLocation, LookupResult, MoveData, MoveError};\n use crate::dataflow::Borrows;\n-use crate::dataflow::DataflowResultsConsumer;\n use crate::dataflow::EverInitializedPlaces;\n-use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MoveDataParamEnv;\n-use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::MirSource;\n \n use self::diagnostics::{AccessKind, RegionName};\n-use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n@@ -54,7 +53,6 @@ mod constraint_generation;\n mod constraints;\n mod diagnostics;\n mod facts;\n-mod flows;\n mod invalidation;\n mod location;\n mod member_constraints;\n@@ -70,7 +68,7 @@ mod universal_regions;\n mod used_muts;\n \n crate use borrow_set::{BorrowData, BorrowSet};\n-crate use nll::ToRegionVid;\n+crate use nll::{PoloniusOutput, ToRegionVid};\n crate use place_ext::PlaceExt;\n crate use places_conflict::{places_conflict, PlaceConflictBias};\n crate use region_infer::RegionInferenceContext;\n@@ -115,7 +113,6 @@ fn do_mir_borrowck<'a, 'tcx>(\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n \n     let tcx = infcx.tcx;\n-    let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n     let id = tcx.hir().as_local_hir_id(def_id).expect(\"do_mir_borrowck: non-local DefId\");\n \n@@ -188,16 +185,10 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let mdpe = MoveDataParamEnv { move_data, param_env };\n \n-    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n-    let mut flow_inits = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        &body,\n-        def_id,\n-        &attributes,\n-        &dead_unwinds,\n-        MaybeInitializedPlaces::new(tcx, &body, &mdpe),\n-        |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n-    ));\n+    let mut flow_inits = MaybeInitializedPlaces::new(tcx, &body, &mdpe)\n+        .into_engine(tcx, &body, def_id)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(&body);\n \n     let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n     let borrow_set =\n@@ -233,33 +224,15 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let regioncx = Rc::new(regioncx);\n \n-    let flow_borrows = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        &body,\n-        def_id,\n-        &attributes,\n-        &dead_unwinds,\n-        Borrows::new(tcx, &body, regioncx.clone(), &borrow_set),\n-        |rs, i| DebugFormatted::new(&rs.location(i)),\n-    ));\n-    let flow_uninits = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        &body,\n-        def_id,\n-        &attributes,\n-        &dead_unwinds,\n-        MaybeUninitializedPlaces::new(tcx, &body, &mdpe),\n-        |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n-    ));\n-    let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        &body,\n-        def_id,\n-        &attributes,\n-        &dead_unwinds,\n-        EverInitializedPlaces::new(tcx, &body, &mdpe),\n-        |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n-    ));\n+    let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), &borrow_set)\n+        .into_engine(tcx, &body, def_id)\n+        .iterate_to_fixpoint();\n+    let flow_uninits = MaybeUninitializedPlaces::new(tcx, &body, &mdpe)\n+        .into_engine(tcx, &body, def_id)\n+        .iterate_to_fixpoint();\n+    let flow_ever_inits = EverInitializedPlaces::new(tcx, &body, &mdpe)\n+        .into_engine(tcx, &body, def_id)\n+        .iterate_to_fixpoint();\n \n     let movable_generator = match tcx.hir().get(id) {\n         Node::Expr(&hir::Expr {\n@@ -294,17 +267,28 @@ fn do_mir_borrowck<'a, 'tcx>(\n         local_names,\n         region_names: RefCell::default(),\n         next_region_name: RefCell::new(1),\n+        polonius_output,\n     };\n \n     // Compute and report region errors, if any.\n     mbcx.report_region_errors(nll_errors);\n \n-    let mut state = Flows::new(flow_borrows, flow_uninits, flow_ever_inits, polonius_output);\n+    let results = BorrowckResults {\n+        ever_inits: flow_ever_inits,\n+        uninits: flow_uninits,\n+        borrows: flow_borrows,\n+    };\n \n     if let Some(errors) = move_errors {\n         mbcx.report_move_errors(errors);\n     }\n-    mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n+\n+    dataflow::generic::visit_results(\n+        &*body,\n+        traversal::reverse_postorder(&*body).map(|(bb, _)| bb),\n+        &results,\n+        &mut mbcx,\n+    );\n \n     // Convert any reservation warnings into lints.\n     let reservation_warnings = mem::take(&mut mbcx.reservation_warnings);\n@@ -500,31 +484,26 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// The counter for generating new region names.\n     next_region_name: RefCell<usize>,\n+\n+    /// Results of Polonius analysis.\n+    polonius_output: Option<Rc<PoloniusOutput>>,\n }\n \n // Check that:\n // 1. assignments are always made to mutable locations (FIXME: does that still really go here?)\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n-impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n+impl<'cx, 'tcx> dataflow::generic::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n     type FlowState = Flows<'cx, 'tcx>;\n \n-    fn body(&self) -> &'cx Body<'tcx> {\n-        *self.body\n-    }\n-\n-    fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n-        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, flow_state);\n-    }\n-\n-    fn visit_statement_entry(\n+    fn visit_statement(\n         &mut self,\n-        location: Location,\n+        flow_state: &Flows<'cx, 'tcx>,\n         stmt: &'cx Statement<'tcx>,\n-        flow_state: &Self::FlowState,\n+        location: Location,\n     ) {\n-        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\", location, stmt, flow_state);\n+        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {:?}\", location, stmt, flow_state);\n         let span = stmt.source_info.span;\n \n         self.check_activations(location, span, flow_state);\n@@ -607,17 +586,16 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n         }\n     }\n \n-    fn visit_terminator_entry(\n+    fn visit_terminator(\n         &mut self,\n-        location: Location,\n+        flow_state: &Flows<'cx, 'tcx>,\n         term: &'cx Terminator<'tcx>,\n-        flow_state: &Self::FlowState,\n+        loc: Location,\n     ) {\n-        let loc = location;\n-        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\", location, term, flow_state);\n+        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?}): {:?}\", loc, term, flow_state);\n         let span = term.source_info.span;\n \n-        self.check_activations(location, span, flow_state);\n+        self.check_activations(loc, span, flow_state);\n \n         match term.kind {\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n@@ -686,19 +664,40 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n \n             TerminatorKind::Yield { ref value, resume: _, ref resume_arg, drop: _ } => {\n                 self.consume_operand(loc, (value, span), flow_state);\n+                self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n+            }\n+\n+            TerminatorKind::Goto { target: _ }\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdges { real_target: _, imaginary_target: _ }\n+            | TerminatorKind::FalseUnwind { real_target: _, unwind: _ } => {\n+                // no data used, thus irrelevant to borrowck\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator_exit(\n+        &mut self,\n+        flow_state: &Flows<'cx, 'tcx>,\n+        term: &'cx Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        let span = term.source_info.span;\n \n+        match term.kind {\n+            TerminatorKind::Yield { value: _, resume: _, resume_arg: _, drop: _ } => {\n                 if self.movable_generator {\n                     // Look for any active borrows to locals\n                     let borrow_set = self.borrow_set.clone();\n-                    flow_state.with_outgoing_borrows(|borrows| {\n-                        for i in borrows {\n-                            let borrow = &borrow_set[i];\n-                            self.check_for_local_borrow(borrow, span);\n-                        }\n-                    });\n+                    for i in flow_state.borrows.iter() {\n+                        let borrow = &borrow_set[i];\n+                        self.check_for_local_borrow(borrow, span);\n+                    }\n                 }\n-\n-                self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n             }\n \n             TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {\n@@ -707,20 +706,13 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 // StorageDead, but we don't always emit those (notably on unwind paths),\n                 // so this \"extra check\" serves as a kind of backup.\n                 let borrow_set = self.borrow_set.clone();\n-                flow_state.with_outgoing_borrows(|borrows| {\n-                    for i in borrows {\n-                        let borrow = &borrow_set[i];\n-                        self.check_for_invalidation_at_exit(loc, borrow, span);\n-                    }\n-                });\n-            }\n-            TerminatorKind::Goto { target: _ }\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::FalseEdges { real_target: _, imaginary_target: _ }\n-            | TerminatorKind::FalseUnwind { real_target: _, unwind: _ } => {\n-                // no data used, thus irrelevant to borrowck\n+                for i in flow_state.borrows.iter() {\n+                    let borrow = &borrow_set[i];\n+                    self.check_for_invalidation_at_exit(loc, borrow, span);\n+                }\n             }\n+\n+            _ => {}\n         }\n     }\n }\n@@ -855,6 +847,10 @@ impl InitializationRequiringAction {\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n+    fn body(&self) -> &'cx Body<'tcx> {\n+        *self.body\n+    }\n+\n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this\n@@ -934,16 +930,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         let body = self.body;\n         let body: &Body<'_> = &body;\n-        let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n+\n+        // Use polonius output if it has been enabled.\n+        let polonius_output = self.polonius_output.clone();\n+        let borrows_in_scope = if let Some(polonius) = &polonius_output {\n+            let location = self.location_table.start_index(location);\n+            Either::Left(polonius.errors_at(location).iter().copied())\n+        } else {\n+            Either::Right(flow_state.borrows.iter())\n+        };\n+\n         each_borrow_involving_path(\n             self,\n             tcx,\n             body,\n             location,\n             (sd, place_span.0),\n             &borrow_set,\n-            flow_state.borrows_in_scope(location_table),\n+            borrows_in_scope,\n             |this, borrow_index, borrow| match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n@@ -1473,9 +1478,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // initial reservation.\n         }\n     }\n-}\n \n-impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(\n         &mut self,\n         location: Location,\n@@ -1565,21 +1568,26 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         desired_action: InitializationRequiringAction,\n         place_span: (PlaceRef<'cx, 'tcx>, Span),\n-        maybe_uninits: &FlowAtLocation<'tcx, MaybeUninitializedPlaces<'cx, 'tcx>>,\n+        maybe_uninits: &BitSet<MovePathIndex>,\n         from: u32,\n         to: u32,\n     ) {\n         if let Some(mpi) = self.move_path_for_place(place_span.0) {\n-            let mut child = self.move_data.move_paths[mpi].first_child;\n+            let move_paths = &self.move_data.move_paths;\n+            let mut child = move_paths[mpi].first_child;\n             while let Some(child_mpi) = child {\n-                let child_move_place = &self.move_data.move_paths[child_mpi];\n-                let child_place = &child_move_place.place;\n-                let last_proj = child_place.projection.last().unwrap();\n+                let child_move_path = &move_paths[child_mpi];\n+                let last_proj = child_move_path.place.projection.last().unwrap();\n                 if let ProjectionElem::ConstantIndex { offset, from_end, .. } = last_proj {\n                     debug_assert!(!from_end, \"Array constant indexing shouldn't be `from_end`.\");\n \n                     if (from..to).contains(offset) {\n-                        if let Some(uninit_child) = maybe_uninits.has_any_child_of(child_mpi) {\n+                        let uninit_child =\n+                            self.move_data.find_in_move_path_or_its_descendants(child_mpi, |mpi| {\n+                                maybe_uninits.contains(mpi)\n+                            });\n+\n+                        if let Some(uninit_child) = uninit_child {\n                             self.report_use_of_moved_or_uninitialized(\n                                 location,\n                                 desired_action,\n@@ -1590,7 +1598,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         }\n                     }\n                 }\n-                child = child_move_place.next_sibling;\n+                child = child_move_path.next_sibling;\n             }\n         }\n     }\n@@ -1651,12 +1659,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"check_if_path_or_subpath_is_moved place: {:?}\", place_span.0);\n         if let Some(mpi) = self.move_path_for_place(place_span.0) {\n-            if let Some(child_mpi) = maybe_uninits.has_any_child_of(mpi) {\n+            let uninit_mpi = self\n+                .move_data\n+                .find_in_move_path_or_its_descendants(mpi, |mpi| maybe_uninits.contains(mpi));\n+\n+            if let Some(uninit_mpi) = uninit_mpi {\n                 self.report_use_of_moved_or_uninitialized(\n                     location,\n                     desired_action,\n                     (place_span.0, place_span.0, place_span.1),\n-                    child_mpi,\n+                    uninit_mpi,\n                 );\n                 return; // don't bother finding other problems.\n             }"}, {"sha": "a71dfc9a7780fe754f3d7d94e3233bac2da01e5b", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=f639607f63390ca582f92039b04f3ad710338796", "patch": "@@ -20,8 +20,8 @@ use std::str::FromStr;\n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n \n+use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::{InitKind, InitLocation, MoveData};\n-use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::MirSource;\n use crate::util as mir_util;\n@@ -149,7 +149,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     promoted: &IndexVec<Promoted, ReadOnlyBodyAndCache<'_, 'tcx>>,\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'tcx>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n+    flow_inits: &mut ResultsCursor<'cx, 'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) -> NllOutput<'tcx> {"}, {"sha": "cdf962ee31a6ee66bad985e34eb47bb913b539ab", "filename": "src/librustc_mir/borrow_check/type_check/liveness/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs?ref=f639607f63390ca582f92039b04f3ad710338796", "patch": "@@ -3,8 +3,8 @@ use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n \n+use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::MoveData;\n-use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n \n use crate::borrow_check::{\n@@ -30,11 +30,11 @@ mod trace;\n ///\n /// N.B., this computation requires normalization; therefore, it must be\n /// performed before\n-pub(super) fn generate<'tcx>(\n+pub(super) fn generate<'mir, 'tcx>(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n+    flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     location_table: &LocationTable,\n ) {"}, {"sha": "198f4b4b42e052d048c155a56a08a7914266eeee", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=f639607f63390ca582f92039b04f3ad710338796", "patch": "@@ -8,9 +8,10 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::HybridBitSet;\n use std::rc::Rc;\n \n+use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::indexes::MovePathIndex;\n-use crate::dataflow::move_paths::MoveData;\n-use crate::dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n+use crate::dataflow::move_paths::{HasMoveData, MoveData};\n+use crate::dataflow::MaybeInitializedPlaces;\n \n use crate::borrow_check::{\n     region_infer::values::{self, PointIndex, RegionValueElements},\n@@ -38,7 +39,7 @@ pub(super) fn trace(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n+    flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     live_locals: Vec<Local>,\n     polonius_drop_used: Option<Vec<(Local, Location)>>,\n@@ -85,7 +86,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n \n     /// Results of dataflow tracking which variables (and paths) have been\n     /// initialized.\n-    flow_inits: &'me mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'flow, 'tcx>>,\n+    flow_inits: &'me mut ResultsCursor<'flow, 'tcx, MaybeInitializedPlaces<'flow, 'tcx>>,\n \n     /// Index indicating where each variable is assigned, used, or\n     /// dropped.\n@@ -389,23 +390,26 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n }\n \n impl LivenessContext<'_, '_, '_, 'tcx> {\n+    /// Returns `true` if the local variable (or some part of it) is initialized at the current\n+    /// cursor position. Callers should call one of the `seek` methods immediately before to point\n+    /// the cursor to the desired location.\n+    fn initialized_at_curr_loc(&self, mpi: MovePathIndex) -> bool {\n+        let state = self.flow_inits.get();\n+        if state.contains(mpi) {\n+            return true;\n+        }\n+\n+        let move_paths = &self.flow_inits.analysis().move_data().move_paths;\n+        move_paths[mpi].find_descendant(&move_paths, |mpi| state.contains(mpi)).is_some()\n+    }\n+\n     /// Returns `true` if the local variable (or some part of it) is initialized in\n     /// the terminator of `block`. We need to check this to determine if a\n     /// DROP of some local variable will have an effect -- note that\n     /// drops, as they may unwind, are always terminators.\n     fn initialized_at_terminator(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n-        // Compute the set of initialized paths at terminator of block\n-        // by resetting to the start of the block and then applying\n-        // the effects of all statements. This is the only way to get\n-        // \"just ahead\" of a terminator.\n-        self.flow_inits.reset_to_entry_of(block);\n-        for statement_index in 0..self.body[block].statements.len() {\n-            let location = Location { block, statement_index };\n-            self.flow_inits.reconstruct_statement_effect(location);\n-            self.flow_inits.apply_local_effect(location);\n-        }\n-\n-        self.flow_inits.has_any_child_of(mpi).is_some()\n+        self.flow_inits.seek_before(self.body.terminator_loc(block));\n+        self.initialized_at_curr_loc(mpi)\n     }\n \n     /// Returns `true` if the path `mpi` (or some part of it) is initialized at\n@@ -414,8 +418,8 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n     /// **Warning:** Does not account for the result of `Call`\n     /// instructions.\n     fn initialized_at_exit(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n-        self.flow_inits.reset_to_exit_of(block);\n-        self.flow_inits.has_any_child_of(mpi).is_some()\n+        self.flow_inits.seek_after(self.body.terminator_loc(block));\n+        self.initialized_at_curr_loc(mpi)\n     }\n \n     /// Stores the result that all regions in `value` are live for the"}, {"sha": "100fd7dc48d0e7b7db0d05997378e32f8f6eaab8", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=f639607f63390ca582f92039b04f3ad710338796", "patch": "@@ -34,8 +34,8 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::{Span, DUMMY_SP};\n use syntax::ast;\n \n+use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::MoveData;\n-use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::promote_consts::should_suggest_const_in_array_repeat_expressions_attribute;\n \n@@ -114,7 +114,7 @@ mod relate_tys;\n ///   constraints for the regions in the types of variables\n /// - `flow_inits` -- results of a maybe-init dataflow analysis\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n-pub(crate) fn type_check<'tcx>(\n+pub(crate) fn type_check<'mir, 'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n@@ -124,7 +124,7 @@ pub(crate) fn type_check<'tcx>(\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n-    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n+    flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n ) -> MirTypeckResults<'tcx> {"}, {"sha": "74d1094f9645e2d9348af309b93b314ba34e9803", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=f639607f63390ca582f92039b04f3ad710338796", "patch": "@@ -4,11 +4,9 @@ use rustc::ty::TyCtxt;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n \n use crate::borrow_check::{\n-    places_conflict, BorrowData, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext,\n-    ToRegionVid,\n+    places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext, ToRegionVid,\n };\n use crate::dataflow::generic::{self, GenKill};\n use crate::dataflow::BottomValue;\n@@ -161,10 +159,6 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         }\n     }\n \n-    crate fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> {\n-        &self.borrow_set.borrows\n-    }\n-\n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n         &self.borrow_set.borrows[idx].reserve_location\n     }"}, {"sha": "319b6f35f1127d32c165202163eb2ad36e1f5f36", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f639607f63390ca582f92039b04f3ad710338796/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=f639607f63390ca582f92039b04f3ad710338796", "patch": "@@ -1,7 +1,7 @@\n-use crate::dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n-use crate::dataflow::DataflowResults;\n+use crate::dataflow;\n+use crate::dataflow::generic::{Analysis, Results};\n+use crate::dataflow::move_paths::{LookupResult, MoveData, MovePathIndex};\n use crate::dataflow::MoveDataParamEnv;\n-use crate::dataflow::{self, do_dataflow, DebugFormatted};\n use crate::dataflow::{drop_flag_effects_for_location, on_lookup_result_bits};\n use crate::dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n@@ -40,24 +40,16 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n             let body = &*body;\n             let env = MoveDataParamEnv { move_data, param_env };\n             let dead_unwinds = find_dead_unwinds(tcx, body, def_id, &env);\n-            let flow_inits = do_dataflow(\n-                tcx,\n-                body,\n-                def_id,\n-                &[],\n-                &dead_unwinds,\n-                MaybeInitializedPlaces::new(tcx, body, &env),\n-                |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]),\n-            );\n-            let flow_uninits = do_dataflow(\n-                tcx,\n-                body,\n-                def_id,\n-                &[],\n-                &dead_unwinds,\n-                MaybeUninitializedPlaces::new(tcx, body, &env),\n-                |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]),\n-            );\n+\n+            let flow_inits = MaybeInitializedPlaces::new(tcx, body, &env)\n+                .into_engine(tcx, body, def_id)\n+                .dead_unwinds(&dead_unwinds)\n+                .iterate_to_fixpoint();\n+\n+            let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &env)\n+                .into_engine(tcx, body, def_id)\n+                .dead_unwinds(&dead_unwinds)\n+                .iterate_to_fixpoint();\n \n             ElaborateDropsCtxt {\n                 tcx,\n@@ -87,15 +79,9 @@ fn find_dead_unwinds<'tcx>(\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n     let mut dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n-    let flow_inits = do_dataflow(\n-        tcx,\n-        body,\n-        def_id,\n-        &[],\n-        &dead_unwinds,\n-        MaybeInitializedPlaces::new(tcx, body, &env),\n-        |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]),\n-    );\n+    let flow_inits = MaybeInitializedPlaces::new(tcx, body, &env)\n+        .into_engine(tcx, body, def_id)\n+        .iterate_to_fixpoint();\n     for (bb, bb_data) in body.basic_blocks().iter_enumerated() {\n         let location = match bb_data.terminator().kind {\n             TerminatorKind::Drop { ref location, unwind: Some(_), .. }\n@@ -104,7 +90,7 @@ fn find_dead_unwinds<'tcx>(\n         };\n \n         let mut init_data = InitializationData {\n-            live: flow_inits.sets().entry_set_for(bb.index()).to_owned(),\n+            live: flow_inits.entry_set_for_block(bb).clone(),\n             dead: BitSet::new_empty(env.move_data.move_paths.len()),\n         };\n         debug!(\"find_dead_unwinds @ {:?}: {:?}; init_data={:?}\", bb, bb_data, init_data.live);\n@@ -283,8 +269,8 @@ struct ElaborateDropsCtxt<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx>,\n-    flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx>>,\n-    flow_uninits: DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx>>,\n+    flow_inits: Results<'tcx, MaybeInitializedPlaces<'a, 'tcx>>,\n+    flow_uninits: Results<'tcx, MaybeUninitializedPlaces<'a, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }\n@@ -300,8 +286,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn initialization_data_at(&self, loc: Location) -> InitializationData {\n         let mut data = InitializationData {\n-            live: self.flow_inits.sets().entry_set_for(loc.block.index()).to_owned(),\n-            dead: self.flow_uninits.sets().entry_set_for(loc.block.index()).to_owned(),\n+            live: self.flow_inits.entry_set_for_block(loc.block).to_owned(),\n+            dead: self.flow_uninits.entry_set_for_block(loc.block).to_owned(),\n         };\n         for stmt in 0..loc.statement_index {\n             data.apply_location("}]}