{"sha": "a0521971b1b9a3203c250591991092a445b50586", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNTIxOTcxYjFiOWEzMjAzYzI1MDU5MTk5MTA5MmE0NDViNTA1ODY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-10T06:16:52Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-10T06:16:52Z"}, "message": "Merge branch 'master' into floop-for-snapshot", "tree": {"sha": "ec2665d4a9ea775d305bcc7b052c8f01aa26d284", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec2665d4a9ea775d305bcc7b052c8f01aa26d284"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0521971b1b9a3203c250591991092a445b50586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0521971b1b9a3203c250591991092a445b50586", "html_url": "https://github.com/rust-lang/rust/commit/a0521971b1b9a3203c250591991092a445b50586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0521971b1b9a3203c250591991092a445b50586/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c758ef3f386578cffd5353e1b84e94d1f30d760f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c758ef3f386578cffd5353e1b84e94d1f30d760f", "html_url": "https://github.com/rust-lang/rust/commit/c758ef3f386578cffd5353e1b84e94d1f30d760f"}, {"sha": "e2dad03f44dd709c3263d2ede7d1bfae40a740b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2dad03f44dd709c3263d2ede7d1bfae40a740b9", "html_url": "https://github.com/rust-lang/rust/commit/e2dad03f44dd709c3263d2ede7d1bfae40a740b9"}], "stats": {"total": 2443, "additions": 680, "deletions": 1763}, "files": [{"sha": "5bb3a8abdfdaf1fc3f701d49642fe614c5ab6fa8", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -14,6 +14,7 @@ Brendan Eich <brendan@mozilla.org>\n Brian Anderson <banderson@mozilla.com>\n Chris Double <chris.double@double.co.nz>\n Chris Peterson <cpeterson@mozilla.com>\n+Damien Grassart <damien@grassart.com>\n Daniel Brooks <db48x@db48x.net>\n Daniel Luz <dev@mernen.com>\n Dave Herman <dherman@mozilla.com>"}, {"sha": "61ca2a2329f0088a983493b43f74b441fadaaaa7", "filename": "src/README.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.txt?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -2,7 +2,7 @@ This is preliminary version of the Rust compiler.\n \n Source layout:\n \n-comp/              The self-hosted compiler\n+rustc/             The self-hosted compiler\n \n cargo/             The package manager\n "}, {"sha": "ca7028e5e9eb5c8570ea30f2ed632e8937ea173b", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -163,6 +163,8 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let mutbl_map =\n         time(time_passes, \"mutability checking\",\n              bind middle::mutbl::check_crate(ty_cx, crate));\n+    time(time_passes, \"region checking\",\n+         bind middle::regionck::check_crate(ty_cx, crate));\n     let (copy_map, ref_map) =\n         time(time_passes, \"alias checking\",\n              bind middle::alias::check_crate(ty_cx, crate));"}, {"sha": "9a31d2c2a29031ef3966d9428d870dffcd449a88", "filename": "src/rustc/middle/regionck.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustc%2Fmiddle%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustc%2Fmiddle%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregionck.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -0,0 +1,71 @@\n+/*\n+ * The region checking pass. Ensures that region-annotated pointers never\n+ * outlive their referents.\n+ */\n+\n+import driver::session::session;\n+import middle::ty;\n+import std::map::hashmap;\n+import syntax::{ast, visit};\n+\n+type ctxt = {\n+    tcx: ty::ctxt,\n+    enclosing_block: option<ast::node_id>\n+};\n+\n+fn check_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n+    ty::walk_ty(cx.tcx, ty::expr_ty(cx.tcx, expr)) { |t|\n+        alt ty::get(t).struct {\n+            ty::ty_rptr(region, _) {\n+                alt region {\n+                    ty::re_named(_) | ty::re_caller(_) { /* ok */ }\n+                    ty::re_block(rbi) {\n+                        let referent_block_id = rbi;\n+                        let enclosing_block_id = alt cx.enclosing_block {\n+                            none {\n+                                cx.tcx.sess.span_bug(expr.span, \"block \" +\n+                                                     \"region type outside \" +\n+                                                     \"a block?!\");\n+                            }\n+                            some(eb) { eb }\n+                        };\n+\n+                        let parent_blocks = cx.tcx.region_map.parent_blocks;\n+                        while enclosing_block_id != referent_block_id {\n+                            if parent_blocks.contains_key(referent_block_id) {\n+                                referent_block_id =\n+                                    parent_blocks.get(referent_block_id);\n+                            } else {\n+                                // TODO: Enable this.\n+\n+                                //cx.tcx.sess.span_err(expr.span,\n+                                //                     \"reference escapes \" +\n+                                //                     \"its block\");\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ { /* no-op */ }\n+        }\n+    }\n+\n+    visit::visit_expr(expr, cx, visitor);\n+}\n+\n+fn check_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n+    let new_cx: ctxt = { enclosing_block: some(blk.node.id) with cx };\n+    visit::visit_block(blk, new_cx, visitor);\n+}\n+\n+fn check_crate(ty_cx: ty::ctxt, crate: @ast::crate) {\n+    let cx: ctxt = {tcx: ty_cx, enclosing_block: none};\n+    let visitor = visit::mk_vt(@{\n+        visit_expr: check_expr,\n+        visit_block: check_block\n+        with *visit::default_visitor()\n+    });\n+    visit::visit_crate(*crate, cx, visitor);\n+}\n+"}, {"sha": "4a512e059c18a694b5e831900f2bb12dba0ae88c", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -45,6 +45,7 @@ mod middle {\n     mod capture;\n     mod pat_util;\n     mod region;\n+    mod regionck;\n \n     mod tstate {\n         mod ck;"}, {"sha": "4e53151bf9a337bca020f68f48e5ad98e2979ffb", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 21, "deletions": 264, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -9,42 +9,14 @@ import rustc::syntax::ast;\n import rustc::front::attr;\n import core::tuple;\n \n-export crate_attrs, basic_attrs, fn_attrs, arg_attrs,\n-       variant_attrs, res_attrs, method_attrs;\n-export parse_crate, parse_basic, parse_fn,\n-       parse_variant, parse_res, parse_method;\n+export crate_attrs;\n+export parse_crate, parse_desc;\n export parse_hidden;\n \n type crate_attrs = {\n     name: option<str>\n };\n \n-type basic_attrs = {\n-    brief: option<str>,\n-    desc: option<str>\n-};\n-\n-type fn_attrs = {\n-    args: [arg_attrs],\n-    return: option<str>,\n-    failure: option<str>\n-};\n-\n-type arg_attrs = {\n-    name: str,\n-    desc: str\n-};\n-\n-type variant_attrs = {\n-    desc: option<str>\n-};\n-\n-type res_attrs = {\n-    args: [arg_attrs]\n-};\n-\n-type method_attrs = fn_attrs;\n-\n #[cfg(test)]\n mod test {\n \n@@ -121,259 +93,44 @@ fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n     assert attrs.name == none;\n }\n \n-fn parse_basic(\n-    attrs: [ast::attribute]\n-) -> {\n-    brief: option<str>,\n-    desc: option<str>\n-} {\n-    parse_short_doc_or(\n-        attrs,\n-        {|desc|\n-            {\n-                brief: none,\n-                desc: desc\n-            }\n-        },\n-        {|_items, brief, desc|\n-            {\n-                brief: brief,\n-                desc: desc\n-            }\n-        }\n-    )\n-}\n-\n-#[test]\n-fn parse_basic_should_handle_undocumented_mods() {\n-    let source = \"\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_basic(attrs);\n-    assert attrs.brief == none;\n-    assert attrs.desc == none;\n-}\n-\n-#[test]\n-fn parse_basic_should_parse_simple_doc_attributes() {\n-    let source = \"#[doc = \\\"basic\\\"]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_basic(attrs);\n-    assert attrs.desc == some(\"basic\");\n-}\n-\n-#[test]\n-fn parse_basic_should_parse_the_brief_description() {\n-    let source = \"#[doc(brief = \\\"short\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_basic(attrs);\n-    assert attrs.brief == some(\"short\");\n-}\n-\n-#[test]\n-fn parse_basic_should_parse_the_long_description() {\n-    let source = \"#[doc(desc = \\\"description\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_basic(attrs);\n-    assert attrs.desc == some(\"description\");\n-}\n-\n-fn parse_short_doc_or<T>(\n-    attrs: [ast::attribute],\n-    handle_short: fn&(\n-        short_desc: option<str>\n-    ) -> T,\n-    parse_long: fn&(\n-        doc_items: [@ast::meta_item],\n-        brief: option<str>,\n-        desc: option<str>\n-    ) -> T\n-) -> T {\n+fn parse_desc(attrs: [ast::attribute]) -> option<str> {\n     alt doc_meta(attrs) {\n       some(meta) {\n-        alt attr::get_meta_item_value_str(meta) {\n-          some(desc) { handle_short(some(desc)) }\n-          none {\n-            alt attr::get_meta_item_list(meta) {\n-              some(list) {\n-                let brief = attr::meta_item_value_from_list(list, \"brief\");\n-                let desc = attr::meta_item_value_from_list(list, \"desc\");\n-                parse_long(list, brief, desc)\n-              }\n-              none {\n-                handle_short(none)\n-              }\n-            }\n-          }\n-        }\n-      }\n-      none {\n-        handle_short(none)\n+        attr::get_meta_item_value_str(meta)\n       }\n-    }\n-}\n-\n-fn parse_long_doc<T>(\n-    attrs: [ast::attribute],\n-    parse_long: fn&(doc_items: [@ast::meta_item]) -> T\n-) -> T {\n-    alt doc_meta(attrs) {\n-      some(meta) {\n-        alt attr::get_meta_item_list(meta) {\n-          some(list) {\n-            parse_long(list)\n-          }\n-          none {\n-            parse_long([])\n-          }\n-        }\n-      }\n-      none { parse_long([]) }\n-    }\n-}\n-\n-fn parse_fn(attrs: [ast::attribute]) -> fn_attrs {\n-    parse_long_doc(attrs, parse_fn_long_doc)\n-}\n-\n-fn parse_fn_long_doc(items: [@ast::meta_item]) -> fn_attrs {\n-    let return = attr::meta_item_value_from_list(items, \"return\");\n-    let failure = attr::meta_item_value_from_list(items, \"failure\");\n-    let args = parse_args(items);\n-\n-    {\n-        args: args,\n-        return: return,\n-        failure: failure\n-    }\n-}\n-\n-fn parse_args(items: [@ast::meta_item]) -> [arg_attrs] {\n-    alt attr::meta_item_list_from_list(items, \"args\") {\n-      some(items) {\n-        vec::filter_map(items) {|item|\n-            option::map(attr::name_value_str_pair(item)) { |pair|\n-                {\n-                    name: tuple::first(pair),\n-                    desc: tuple::second(pair)\n-                }\n-            }\n-        }\n-      }\n-      none { [] }\n+      none { none }\n     }\n }\n \n #[test]\n-fn parse_fn_should_handle_undocumented_functions() {\n+fn parse_desc_should_handle_undocumented_mods() {\n     let source = \"\";\n     let attrs = test::parse_attributes(source);\n-    let attrs = parse_fn(attrs);\n-    assert attrs.return == none;\n-    assert vec::len(attrs.args) == 0u;\n-}\n-\n-#[test]\n-fn parse_fn_should_parse_the_return_value_description() {\n-    let source = \"#[doc(return = \\\"return value\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_fn(attrs);\n-    assert attrs.return == some(\"return value\");\n-}\n-\n-#[test]\n-fn parse_fn_should_parse_the_argument_descriptions() {\n-    let source = \"#[doc(args(a = \\\"arg a\\\", b = \\\"arg b\\\"))]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_fn(attrs);\n-    assert attrs.args[0] == {name: \"a\", desc: \"arg a\"};\n-    assert attrs.args[1] == {name: \"b\", desc: \"arg b\"};\n-}\n-\n-#[test]\n-fn parse_fn_should_parse_failure_conditions() {\n-    let source = \"#[doc(failure = \\\"it's the fail\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_fn(attrs);\n-    assert attrs.failure == some(\"it's the fail\");\n-}\n-\n-fn parse_variant(attrs: [ast::attribute]) -> variant_attrs {\n-    parse_short_doc_or(\n-        attrs,\n-        {|desc|\n-            {\n-                desc: desc\n-            }\n-        },\n-        {|_items, brief, desc|\n-            if option::is_some(brief) && option::is_some(desc) {\n-                // FIXME: Warn about dropping brief description\n-            }\n-\n-            {\n-                // Prefer desc over brief\n-                desc: option::maybe(brief, desc, {|s| some(s) })\n-            }\n-        }\n-    )\n-}\n-\n-#[test]\n-fn should_parse_variant_short_doc() {\n-    let source = \"#[doc = \\\"a\\\"]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_variant(attrs);\n-    assert attrs.desc == some(\"a\");\n+    let attrs = parse_desc(attrs);\n+    assert attrs == none;\n }\n \n #[test]\n-fn should_parse_variant_brief_doc() {\n-    let source = \"#[doc(brief = \\\"a\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_variant(attrs);\n-    assert attrs.desc == some(\"a\");\n-}\n-\n-#[test]\n-fn should_parse_variant_long_doc() {\n-    let source = \"#[doc(desc = \\\"a\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_variant(attrs);\n-    assert attrs.desc == some(\"a\");\n-}\n-\n-fn parse_res(attrs: [ast::attribute]) -> res_attrs {\n-    parse_long_doc(attrs, parse_res_long_doc)\n-}\n-\n-fn parse_res_long_doc(items: [@ast::meta_item]) -> res_attrs {\n-    {\n-        args: parse_args(items)\n-    }\n-}\n-\n-#[test]\n-fn shoulde_parse_resource_arg() {\n-    let source = \"#[doc(args(a = \\\"b\\\"))]\";\n+fn parse_desc_should_parse_simple_doc_attributes() {\n+    let source = \"#[doc = \\\"basic\\\"]\";\n     let attrs = test::parse_attributes(source);\n-    let attrs = parse_res(attrs);\n-    assert attrs.args[0].name == \"a\";\n-    assert attrs.args[0].desc == \"b\";\n-}\n-\n-fn parse_method(attrs: [ast::attribute]) -> method_attrs {\n-    parse_fn(attrs)\n+    let attrs = parse_desc(attrs);\n+    assert attrs == some(\"basic\");\n }\n \n fn parse_hidden(attrs: [ast::attribute]) -> bool {\n-    parse_short_doc_or(\n-        attrs,\n-        {|_desc| false },\n-        {|metas, _brief, _desc|\n+    alt doc_meta(attrs) {\n+      some(meta) {\n+        alt attr::get_meta_item_list(meta) {\n+          some(metas) {\n             let hiddens = attr::find_meta_items_by_name(metas, \"hidden\");\n             vec::is_not_empty(hiddens)\n+          }\n+          none { false }\n         }\n-    )\n+      }\n+      none { false }\n+    }\n }\n \n #[test]"}, {"sha": "c5f89209db4a46d9d0b9a60a142979d9a6d21b41", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 15, "deletions": 203, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -26,9 +26,7 @@ fn run(\n     let fold = fold::fold({\n         fold_crate: fold_crate,\n         fold_item: fold_item,\n-        fold_fn: fold_fn,\n         fold_enum: fold_enum,\n-        fold_res: fold_res,\n         fold_iface: fold_iface,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(srv)\n@@ -74,18 +72,17 @@ fn fold_item(\n     let srv = fold.ctxt;\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n-    let attrs = if doc.id == ast::crate_node_id {\n+    let desc = if doc.id == ast::crate_node_id {\n         // This is the top-level mod, use the crate attributes\n         astsrv::exec(srv) {|ctxt|\n-            attr_parser::parse_basic(ctxt.ast.node.attrs)\n+            attr_parser::parse_desc(ctxt.ast.node.attrs)\n         }\n     } else {\n-        parse_item_attrs(srv, doc.id, attr_parser::parse_basic)\n+        parse_item_attrs(srv, doc.id, attr_parser::parse_desc)\n     };\n \n     {\n-        brief: attrs.brief,\n-        desc: attrs.desc\n+        desc: desc\n         with doc\n     }\n }\n@@ -130,111 +127,12 @@ fn should_extract_native_fn_attributes() {\n     assert doc.cratemod().nmods()[0].fns[0].desc() == some(\"test\");\n }\n \n-fn fold_fn(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::fndoc\n-) -> doc::fndoc {\n-\n-    let srv = fold.ctxt;\n-\n-    let doc = fold::default_seq_fold_fn(fold, doc);\n-    let attrs = parse_item_attrs(srv, doc.id(), attr_parser::parse_fn);\n-    ret merge_fn_attrs(doc, attrs);\n-\n-    fn merge_fn_attrs(\n-        doc: doc::fndoc,\n-        attrs: attr_parser::fn_attrs\n-    ) -> doc::fndoc {\n-        ret {\n-            args: merge_arg_attrs(doc.args, attrs.args),\n-            return: merge_ret_attrs(doc.return, attrs.return),\n-            failure: attrs.failure\n-            with doc\n-        };\n-    }\n-}\n-\n-fn merge_arg_attrs(\n-    docs: [doc::argdoc],\n-    attrs: [attr_parser::arg_attrs]\n-) -> [doc::argdoc] {\n-    par::seqmap(docs) {|doc|\n-        alt vec::find(attrs) {|attr|\n-            attr.name == doc.name\n-        } {\n-            some(attr) {\n-                {\n-                    desc: some(attr.desc)\n-                    with doc\n-                }\n-            }\n-            none { doc }\n-        }\n-    }\n-    // FIXME: Warning when documenting a non-existent arg\n-}\n-\n-\n-fn merge_ret_attrs(\n-    doc: doc::retdoc,\n-    attrs: option<str>\n-) -> doc::retdoc {\n-    {\n-        desc: attrs\n-        with doc\n-    }\n-}\n-\n #[test]\n fn should_extract_fn_attributes() {\n     let doc = test::mk_doc(\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n     assert doc.cratemod().fns()[0].desc() == some(\"test\");\n }\n \n-#[test]\n-fn should_extract_fn_arg_attributes() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn c(a: bool) { }\");\n-    assert doc.cratemod().fns()[0].args[0].desc == some(\"b\");\n-}\n-\n-#[test]\n-fn should_extract_fn_return_attributes() {\n-    let source = \"#[doc(return = \\\"what\\\")] fn a() -> int { }\";\n-    astsrv::from_str(source) {|srv|\n-        let doc = extract::from_srv(srv, \"\");\n-        let doc = tystr_pass::mk_pass().f(srv, doc);\n-        let fold = fold::default_any_fold(srv);\n-        let doc = fold_fn(fold, doc.cratemod().fns()[0]);\n-        assert doc.return.desc == some(\"what\");\n-    }\n-}\n-\n-#[test]\n-fn should_preserve_fn_sig() {\n-    let source = \"fn a() -> int { }\";\n-    astsrv::from_str(source) {|srv|\n-        let doc = extract::from_srv(srv, \"\");\n-        let doc = tystr_pass::mk_pass().f(srv, doc);\n-        let fold = fold::default_any_fold(srv);\n-        let doc = fold_fn(fold, doc.cratemod().fns()[0]);\n-        assert doc.sig == some(\"fn a() -> int\");\n-    }\n-}\n-\n-#[test]\n-fn should_extract_fn_failure_conditions() {\n-    let doc = test::mk_doc(\"#[doc(failure = \\\"what\\\")] fn a() { }\");\n-    assert doc.cratemod().fns()[0].failure == some(\"what\");\n-}\n-\n-#[test]\n-fn should_extract_const_docs() {\n-    let doc = test::mk_doc(\"#[doc(brief = \\\"foo\\\", desc = \\\"bar\\\")]\\\n-                            const a: bool = true;\");\n-    assert doc.cratemod().consts()[0].brief() == some(\"foo\");\n-    assert doc.cratemod().consts()[0].desc() == some(\"bar\");\n-}\n-\n fn fold_enum(\n     fold: fold::fold<astsrv::srv>,\n     doc: doc::enumdoc\n@@ -246,7 +144,7 @@ fn fold_enum(\n \n     {\n         variants: par::anymap(doc.variants) {|variant|\n-            let attrs = astsrv::exec(srv) {|ctxt|\n+            let desc = astsrv::exec(srv) {|ctxt|\n                 alt check ctxt.ast_map.get(doc_id) {\n                   ast_map::node_item(@{\n                     node: ast::item_enum(ast_variants, _), _\n@@ -256,13 +154,13 @@ fn fold_enum(\n                             v.node.name == variant.name\n                         });\n \n-                    attr_parser::parse_variant(ast_variant.node.attrs)\n+                    attr_parser::parse_desc(ast_variant.node.attrs)\n                   }\n                 }\n             };\n \n             {\n-                desc: attrs.desc\n+                desc: desc\n                 with variant\n             }\n         }\n@@ -272,9 +170,8 @@ fn fold_enum(\n \n #[test]\n fn should_extract_enum_docs() {\n-    let doc = test::mk_doc(\"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n+    let doc = test::mk_doc(\"#[doc = \\\"b\\\"]\\\n                             enum a { v }\");\n-    assert doc.cratemod().enums()[0].brief() == some(\"a\");\n     assert doc.cratemod().enums()[0].desc() == some(\"b\");\n }\n \n@@ -284,49 +181,6 @@ fn should_extract_variant_docs() {\n     assert doc.cratemod().enums()[0].variants[0].desc == some(\"c\");\n }\n \n-fn fold_res(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::resdoc\n-) -> doc::resdoc {\n-\n-    let srv = fold.ctxt;\n-    let doc = fold::default_seq_fold_res(fold, doc);\n-    let attrs = parse_item_attrs(srv, doc.id(), attr_parser::parse_res);\n-\n-    {\n-        args: par::seqmap(doc.args) {|doc|\n-            alt vec::find(attrs.args) {|attr|\n-                attr.name == doc.name\n-            } {\n-                some(attr) {\n-                    {\n-                        desc: some(attr.desc)\n-                        with doc\n-                    }\n-                }\n-                none { doc }\n-            }\n-        }\n-        with doc\n-    }\n-}\n-\n-#[test]\n-fn should_extract_res_docs() {\n-    let doc = test::mk_doc(\"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n-                            resource r(b: bool) { }\");\n-    assert doc.cratemod().resources()[0].brief() == some(\"a\");\n-    assert doc.cratemod().resources()[0].desc() == some(\"b\");\n-}\n-\n-#[test]\n-fn should_extract_res_arg_docs() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))]\\\n-                            resource r(a: bool) { }\");\n-    assert doc.cratemod().resources()[0].args[0].name == \"a\";\n-    assert doc.cratemod().resources()[0].args[0].desc == some(\"b\");\n-}\n-\n fn fold_iface(\n     fold: fold::fold<astsrv::srv>,\n     doc: doc::ifacedoc\n@@ -346,30 +200,21 @@ fn merge_method_attrs(\n     docs: [doc::methoddoc]\n ) -> [doc::methoddoc] {\n \n-    type method_attrs = (attr_parser::basic_attrs,\n-                         attr_parser::method_attrs);\n-\n     // Create an assoc list from method name to attributes\n-    let attrs: [(str, method_attrs)] = astsrv::exec(srv) {|ctxt|\n+    let attrs: [(str, option<str>)] = astsrv::exec(srv) {|ctxt|\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, methods), _\n           }, _) {\n             par::seqmap(methods) {|method|\n-                (method.ident,\n-                 (attr_parser::parse_basic(method.attrs),\n-                  attr_parser::parse_method(method.attrs)\n-                 ))\n+                (method.ident, attr_parser::parse_desc(method.attrs))\n             }\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, methods), _\n           }, _) {\n             par::seqmap(methods) {|method|\n-                (method.ident,\n-                 (attr_parser::parse_basic(method.attrs),\n-                  attr_parser::parse_method(method.attrs)\n-                  ))\n+                (method.ident, attr_parser::parse_desc(method.attrs))\n             }\n           }\n           _ { fail \"unexpected item\" }\n@@ -378,15 +223,10 @@ fn merge_method_attrs(\n \n     vec::map2(docs, attrs) {|doc, attrs|\n         assert doc.name == tuple::first(attrs);\n-        let basic_attrs = tuple::first(tuple::second(attrs));\n-        let method_attrs = tuple::second(tuple::second(attrs));\n+        let desc = tuple::second(attrs);\n \n         {\n-            brief: basic_attrs.brief,\n-            desc: basic_attrs.desc,\n-            args: merge_arg_attrs(doc.args, method_attrs.args),\n-            return: merge_ret_attrs(doc.return, method_attrs.return),\n-            failure: method_attrs.failure\n+            desc: desc\n             with doc\n         }\n     }\n@@ -402,20 +242,10 @@ fn should_extract_iface_docs() {\n fn should_extract_iface_method_docs() {\n     let doc = test::mk_doc(\n         \"iface i {\\\n-         #[doc(\\\n-         brief = \\\"brief\\\",\\\n-         desc = \\\"desc\\\",\\\n-         args(a = \\\"a\\\"),\\\n-         return = \\\"return\\\",\\\n-         failure = \\\"failure\\\")]\\\n+         #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool;\\\n          }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].brief == some(\"brief\");\n     assert doc.cratemod().ifaces()[0].methods[0].desc == some(\"desc\");\n-    assert doc.cratemod().ifaces()[0].methods[0].args[0].desc == some(\"a\");\n-    assert doc.cratemod().ifaces()[0].methods[0].return.desc\n-        == some(\"return\");\n-    assert doc.cratemod().ifaces()[0].methods[0].failure == some(\"failure\");\n }\n \n \n@@ -443,28 +273,10 @@ fn should_extract_impl_docs() {\n fn should_extract_impl_method_docs() {\n     let doc = test::mk_doc(\n         \"impl i for int {\\\n-         #[doc(\\\n-         brief = \\\"brief\\\",\\\n-         desc = \\\"desc\\\",\\\n-         args(a = \\\"a\\\"),\\\n-         return = \\\"return\\\",\\\n-         failure = \\\"failure\\\")]\\\n+         #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool { }\\\n          }\");\n-    assert doc.cratemod().impls()[0].methods[0].brief == some(\"brief\");\n     assert doc.cratemod().impls()[0].methods[0].desc == some(\"desc\");\n-    assert doc.cratemod().impls()[0].methods[0].args[0].desc == some(\"a\");\n-    assert doc.cratemod().impls()[0].methods[0].return.desc == some(\"return\");\n-    assert doc.cratemod().impls()[0].methods[0].failure == some(\"failure\");\n-}\n-\n-#[test]\n-fn should_extract_type_docs() {\n-    let doc = test::mk_doc(\n-        \"#[doc(brief = \\\"brief\\\", desc = \\\"desc\\\")]\\\n-         type t = int;\");\n-    assert doc.cratemod().types()[0].brief() == some(\"brief\");\n-    assert doc.cratemod().types()[0].desc() == some(\"desc\");\n }\n \n #[cfg(test)]"}, {"sha": "dff9bfbc2573e394e57b2e4713e9cfda7e26be32", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 73, "deletions": 95, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -33,106 +33,94 @@ fn take_my_order_please(\n     _order: [omnomnomy]\n ) -> uint {\n \n-    #[doc(\n-        desc = \"OMG would you take my order already?\",\n-        args(_waitress = \"The waitress that you want to bother\",\n-             _order = \"The order vector. It should be filled with food.\"),\n-        return = \"The price of the order, including tax\",\n-        failure = \"This function is full of fail\"\n-    )];\n+    #[doc = \"\n+    OMG would you take my order already?\n \n-    fail;\n-}\n+    # Arguments\n \n-fn take_my_order_now(\n-    _waitress: waitress,\n-    _order: [omnomnomy]\n-) -> uint {\n+    * _waitress - The waitress that you want to bother\n+    * _order - The order vector. It should be filled with food\n \n-    #[doc(\n-        desc = \"OMG would you take my order already?\",\n-        args(_waitress = \"The waitress that you want to bother\",\n-             _order = \"The order vector. It should be filled with food.\"),\n-        return = \"\n+    # Return\n \n-        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed\n-        nec molestie nisl. Duis massa risus, pharetra a scelerisque a,\n-        molestie eu velit. Donec mattis ligula at ante imperdiet ut\n-        dapibus mauris malesuada.\n+    The price of the order, including tax\n \n-        Sed gravida nisi a metus elementum sit amet hendrerit dolor\n-        bibendum. Aenean sit amet neque massa, sed tempus tortor. Sed\n-        ut lobortis enim. Proin a mauris quis nunc fermentum ultrices\n-        eget a erat. Mauris in lectus vitae metus sodales\n-        auctor. Morbi nunc quam, ultricies at venenatis non,\n-        pellentesque ac dui.\n+    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec\n+    molestie nisl. Duis massa risus, pharetra a scelerisque a,\n+    molestie eu velit. Donec mattis ligula at ante imperdiet ut\n+    dapibus mauris malesuada.\n+\n+    Sed gravida nisi a metus elementum sit amet hendrerit dolor\n+    bibendum. Aenean sit amet neque massa, sed tempus tortor. Sed ut\n+    lobortis enim. Proin a mauris quis nunc fermentum ultrices eget a\n+    erat. Mauris in lectus vitae metus sodales auctor. Morbi nunc\n+    quam, ultricies at venenatis non, pellentesque ac dui.\n \n-        \",\n-        failure = \"This function is full of fail\"\n-    )];\n+    # Failure\n+\n+    This function is full of fail\n+    \"];\n \n     fail;\n }\n \n mod fortress_of_solitude {\n-    #[doc(\n-        brief = \"Superman's vacation home\",\n-        desc = \"\n+    #[doc = \"\n+    Superman's vacation home\n \n-        The fortress of solitude is located in the Arctic and it is\n-        cold. What you may not know about the fortress of solitude\n-        though is that it contains two separate bowling alleys. One of\n-        them features bumper-bowling and is kind of lame.\n+    The fortress of solitude is located in the Arctic and it is\n+    cold. What you may not know about the fortress of solitude\n+    though is that it contains two separate bowling alleys. One of\n+    them features bumper-bowling and is kind of lame.\n \n-        Really, it's pretty cool.\n+    Really, it's pretty cool.\n \n-    \")];\n+    \"];\n \n }\n \n mod blade_runner {\n-    #[doc(\n-        brief = \"Blade Runner is probably the best movie ever\",\n-        desc = \"I like that in the world of Blade Runner it is always\n-                raining, and that it's always night time. And Aliens\n-                was also a really good movie.\n-\n-                Alien 3 was crap though.\"\n-    )];\n-}\n+    #[doc = \"\n+    Blade Runner is probably the best movie ever\n \n-#[doc(\n-    brief = \"Bored\",\n-    desc = \"\n+    I like that in the world of Blade Runner it is always\n+    raining, and that it's always night time. And Aliens\n+    was also a really good movie.\n \n-    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec\n-    molestie nisl. Duis massa risus, pharetra a scelerisque a,\n-    molestie eu velit. Donec mattis ligula at ante imperdiet ut\n-    dapibus mauris malesuada. Sed gravida nisi a metus elementum sit\n-    amet hendrerit dolor bibendum. Aenean sit amet neque massa, sed\n-    tempus tortor. Sed ut lobortis enim. Proin a mauris quis nunc\n-    fermentum ultrices eget a erat. Mauris in lectus vitae metus\n-    sodales auctor. Morbi nunc quam, ultricies at venenatis non,\n-    pellentesque ac dui.\n-\n-    Quisque vitae est id eros placerat laoreet sit amet eu\n-    nisi. Curabitur suscipit neque porttitor est euismod\n-    lacinia. Curabitur non quam vitae ipsum adipiscing\n-    condimentum. Mauris ut ante eget metus sollicitudin\n-    blandit. Aliquam erat volutpat. Morbi sed nisl mauris. Nulla\n-    facilisi. Phasellus at mollis ipsum. Maecenas sed convallis\n-    sapien. Nullam in ligula turpis. Pellentesque a neque augue. Sed\n-    eget ante feugiat tortor congue auctor ac quis ante. Proin\n-    condimentum lacinia tincidunt.\n-\n-\")]\n+    Alien 3 was crap though.\n+    \"];\n+}\n+\n+#[doc = \"\n+Bored\n+\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec\n+molestie nisl. Duis massa risus, pharetra a scelerisque a,\n+molestie eu velit. Donec mattis ligula at ante imperdiet ut\n+dapibus mauris malesuada. Sed gravida nisi a metus elementum sit\n+amet hendrerit dolor bibendum. Aenean sit amet neque massa, sed\n+tempus tortor. Sed ut lobortis enim. Proin a mauris quis nunc\n+fermentum ultrices eget a erat. Mauris in lectus vitae metus\n+sodales auctor. Morbi nunc quam, ultricies at venenatis non,\n+pellentesque ac dui.\n+\n+Quisque vitae est id eros placerat laoreet sit amet eu\n+nisi. Curabitur suscipit neque porttitor est euismod\n+lacinia. Curabitur non quam vitae ipsum adipiscing\n+condimentum. Mauris ut ante eget metus sollicitudin\n+blandit. Aliquam erat volutpat. Morbi sed nisl mauris. Nulla\n+facilisi. Phasellus at mollis ipsum. Maecenas sed convallis\n+sapien. Nullam in ligula turpis. Pellentesque a neque augue. Sed\n+eget ante feugiat tortor congue auctor ac quis ante. Proin\n+condimentum lacinia tincidunt.\n+\n+\"]\n resource bored(bored: bool) {\n     log(error, bored);\n }\n \n-#[doc(\n-    brief = \"The Shunned House\",\n-    desc = \"\n+#[doc = \"\n+The Shunned House\n \n From even the greatest of horrors irony is seldom absent. Sometimes it\n enters directly into the composition of the events, while sometimes it\n@@ -147,11 +135,9 @@ northward along the same street to Mrs. Whitman's home and the\n neighboring hillside churchyard of St. John's, whose hidden expanse of\n Eighteenth Century gravestones had for him a peculiar fascination.\n \n-\")]\n+\"]\n iface the_shunned_house {\n-    #[doc(\n-        desc = \"\n-\n+    #[doc = \"\n     Now the irony is this. In this walk, so many times repeated, the\n     world's greatest master of the terrible and the bizarre was\n     obliged to pass a particular house on the eastern side of the\n@@ -165,17 +151,14 @@ iface the_shunned_house {\n     unknowingly, and stands starkly leering as a symbol of all that is\n     unutterably hideous.\n \n-    \",\n-        args(\n-            a =\n-            \"A yard dating from a time when the region was partly\n-             open country\"\n-    ))]\n-    fn dingy_house(unkempt_yard: int);\n+    # Arguments\n \n-    #[doc(\n-        desc = \"\n+    * unkempt_yard - A yard dating from a time when the region was partly\n+                     open country\n+    \"]\n+    fn dingy_house(unkempt_yard: int);\n \n+    #[doc = \"\n     The house was--and for that matter still is--of a kind to attract\n     the attention of the curious. Originally a farm or semi-farm\n     building, it followed the average New England colonial lines of\n@@ -191,17 +174,12 @@ iface the_shunned_house {\n     the graveyards of the first settlers, and straightened only when\n     the removal of the bodies to the North Burial Ground made it\n     decently possible to cut through the old family plots.\n-\n-    \",\n-        return = \"A dingy house with an unkempt yard\",\n-        failure = \"Will fail if bodies are removed from premises\"\n-    )]\n+    \"]\n     fn construct() -> bool;\n }\n \n #[doc = \"Whatever\"]\n impl of the_shunned_house for omnomnomy {\n-    #[doc(args(_unkempt_yard = \"Whatever\"))]\n     fn dingy_house(_unkempt_yard: int) {\n     }\n "}, {"sha": "4ff63120efb47cbc8d46f25e9b195d85f49edaa3", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 50, "deletions": 116, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -31,11 +31,9 @@ fn run(\n \n fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n-    let (brief, desc) = modify(doc.brief, doc.desc);\n \n     {\n-        brief: brief,\n-        desc: desc\n+        brief: extract(doc.desc)\n         with doc\n     }\n }\n@@ -45,11 +43,8 @@ fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n \n     {\n         methods: par::anymap(doc.methods) {|doc|\n-            let (brief, desc) = modify(doc.brief, doc.desc);\n-\n             {\n-                brief: brief,\n-                desc: desc\n+                brief: extract(doc.desc)\n                 with doc\n             }\n         }\n@@ -62,11 +57,8 @@ fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n \n     {\n         methods: par::anymap(doc.methods) {|doc|\n-            let (brief, desc) = modify(doc.brief, doc.desc);\n-\n             {\n-                brief: brief,\n-                desc: desc\n+                brief: extract(doc.desc)\n                 with doc\n             }\n         }\n@@ -75,76 +67,22 @@ fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n }\n \n #[test]\n-fn should_promote_mod_desc() {\n-    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] mod m { }\");\n+fn should_promote_desc() {\n+    let doc = test::mk_doc(\"#[doc = \\\"desc\\\"] mod m { }\");\n     assert doc.cratemod().mods()[0].brief() == some(\"desc\");\n-    assert doc.cratemod().mods()[0].desc() == none;\n-}\n-\n-#[test]\n-fn should_promote_const_desc() {\n-    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] const a: bool = true;\");\n-    assert doc.cratemod().consts()[0].brief() == some(\"desc\");\n-    assert doc.cratemod().consts()[0].desc() == none;\n-}\n-\n-#[test]\n-fn should_promote_fn_desc() {\n-    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] fn a() { }\");\n-    assert doc.cratemod().fns()[0].brief() == some(\"desc\");\n-    assert doc.cratemod().fns()[0].desc() == none;\n-}\n-\n-#[test]\n-fn should_promote_enum_desc() {\n-    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] enum a { b }\");\n-    assert doc.cratemod().enums()[0].brief() == some(\"desc\");\n-    assert doc.cratemod().enums()[0].desc() == none;\n-}\n-\n-#[test]\n-fn should_promote_resource_desc() {\n-    let doc = test::mk_doc(\n-        \"#[doc(desc = \\\"desc\\\")] resource r(a: bool) { }\");\n-    assert doc.cratemod().resources()[0].brief() == some(\"desc\");\n-    assert doc.cratemod().resources()[0].desc() == none;\n-}\n-\n-#[test]\n-fn should_promote_iface_desc() {\n-    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] iface i { fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].brief() == some(\"desc\");\n-    assert doc.cratemod().ifaces()[0].desc() == none;\n }\n \n #[test]\n fn should_promote_iface_method_desc() {\n-    let doc = test::mk_doc(\"iface i { #[doc(desc = \\\"desc\\\")] fn a(); }\");\n+    let doc = test::mk_doc(\"iface i { #[doc = \\\"desc\\\"] fn a(); }\");\n     assert doc.cratemod().ifaces()[0].methods[0].brief == some(\"desc\");\n-    assert doc.cratemod().ifaces()[0].methods[0].desc == none;\n-}\n-\n-#[test]\n-fn should_promote_impl_desc() {\n-    let doc = test::mk_doc(\n-        \"#[doc(desc = \\\"desc\\\")] impl i for int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].brief() == some(\"desc\");\n-    assert doc.cratemod().impls()[0].desc() == none;\n }\n \n #[test]\n fn should_promote_impl_method_desc() {\n     let doc = test::mk_doc(\n-        \"impl i for int { #[doc(desc = \\\"desc\\\")] fn a() { } }\");\n+        \"impl i for int { #[doc = \\\"desc\\\"] fn a() { } }\");\n     assert doc.cratemod().impls()[0].methods[0].brief == some(\"desc\");\n-    assert doc.cratemod().impls()[0].methods[0].desc == none;\n-}\n-\n-#[test]\n-fn should_promote_type_desc() {\n-    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] type t = int;\");\n-    assert doc.cratemod().types()[0].brief() == some(\"desc\");\n-    assert doc.cratemod().types()[0].desc() == none;\n }\n \n #[cfg(test)]\n@@ -158,42 +96,44 @@ mod test {\n     }\n }\n \n-fn modify(\n-    brief: option<str>,\n-    desc: option<str>\n-) -> (option<str>, option<str>) {\n-\n-    if option::is_some(brief) || option::is_none(desc) {\n-        ret (brief, desc);\n+fn extract(desc: option<str>) -> option<str> {\n+    if option::is_none(desc) {\n+        ret none\n     }\n \n     parse_desc(option::get(desc))\n }\n \n-fn parse_desc(desc: str) -> (option<str>, option<str>) {\n+fn parse_desc(desc: str) -> option<str> {\n \n     const max_brief_len: uint = 120u;\n \n-    let paras = paragraphs(desc);\n-\n-    if check vec::is_not_empty(paras) {\n-        let maybe_brief = vec::head(paras);\n-        if str::len(maybe_brief) <= max_brief_len {\n-            let desc_paras = vec::tail(paras);\n-            let desc = if vec::is_not_empty(desc_paras) {\n-                some(str::connect(desc_paras, \"\\n\\n\"))\n-            } else {\n-                none\n-            };\n-            (some(maybe_brief), desc)\n+    alt first_sentence(desc) {\n+      some(first_sentence) {\n+        if str::len(first_sentence) <= max_brief_len {\n+            some(first_sentence)\n         } else {\n-            (none, some(desc))\n+            none\n         }\n+      }\n+      none { none }\n+    }\n+}\n+\n+fn first_sentence(s: str) -> option<str> {\n+    let paras = paragraphs(s);\n+    if vec::is_not_empty(paras) {\n+        let first = vec::head(sentences(vec::head(paras)));\n+        some(str::replace(first, \"\\n\", \" \"))\n     } else {\n-        (none, none)\n+        none\n     }\n }\n \n+fn sentences(s: str) -> [str] {\n+    str::split_char(s, '.')\n+}\n+\n fn paragraphs(s: str) -> [str] {\n     let lines = str::lines_any(s);\n     let whitespace_lines = 0;\n@@ -244,42 +184,36 @@ fn test_paragraphs_2() {\n \n #[test]\n fn should_promote_short_descs() {\n-    let brief = none;\n     let desc = some(\"desc\");\n-    let (newbrief, newdesc) = modify(brief, desc);\n-    assert newbrief == desc;\n-    assert newdesc == none;\n+    let brief = extract(desc);\n+    assert brief == desc;\n }\n \n #[test]\n fn should_not_promote_long_descs() {\n-    let brief = none;\n     let desc = some(\"Warkworth Castle is a ruined medieval building\n-in the town of the same name in the English county of Northumberland.\n-The town and castle occupy a loop of the River Coquet, less than a mile\n+in the town of the same name in the English county of Northumberland,\n+and the town and castle occupy a loop of the River Coquet, less than a mile\n from England's north-east coast. When the castle was founded is uncertain,\n but traditionally its construction has been ascribed to Prince Henry of\n Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n-    let (newbrief, _) = modify(brief, desc);\n-    assert newbrief == none;\n+    let brief = extract(desc);\n+    assert brief == none;\n }\n \n #[test]\n-fn should_not_promote_descs_over_brief() {\n-    let brief = some(\"brief\");\n-    let desc = some(\"desc\");\n-    let (newbrief, newdesc) = modify(brief, desc);\n-    assert newbrief == brief;\n-    assert newdesc == desc;\n-}\n-\n-#[test]\n-fn should_extract_brief_from_desc() {\n-    let brief = none;\n-    let desc = some(\"brief\\n\\ndesc\");\n-    let (newbrief, newdesc) = modify(brief, desc);\n-    assert newbrief == some(\"brief\");\n-    assert newdesc == some(\"desc\");\n-}\n+fn should_promote_first_sentence() {\n+    let desc = some(\"Warkworth Castle is a ruined medieval building\n+in the town. of the same name in the English county of Northumberland,\n+and the town and castle occupy a loop of the River Coquet, less than a mile\n+from England's north-east coast. When the castle was founded is uncertain,\n+but traditionally its construction has been ascribed to Prince Henry of\n+Scotland in the mid 12th century, although it may have been built by\n+King Henry II of England when he took control of England'snorthern\n+counties.\");\n+    let brief = extract(desc);\n+    assert brief == some(\n+        \"Warkworth Castle is a ruined medieval building in the town\");\n+}\n\\ No newline at end of file"}, {"sha": "2da723fa7dd71196d9117b65dd690a0241b73d06", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 27, "deletions": 47, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -11,6 +11,15 @@ enum page {\n     itempage(itemtag)\n }\n \n+#[doc = \"\n+Most rustdocs can be parsed into 'sections' according to their markdown\n+headers\n+\"]\n+type section = {\n+    header: str,\n+    body: str\n+};\n+\n // FIXME: We currently give topmod the name of the crate.  There would\n // probably be fewer special cases if the crate had its own name and\n // topmod's name was the empty string.\n@@ -36,10 +45,16 @@ type itemdoc = {\n     path: [str],\n     brief: option<str>,\n     desc: option<str>,\n+    sections: [section],\n     // Indicates that this node is a reexport of a different item\n     reexport: bool\n };\n \n+type simpleitemdoc = {\n+    item: itemdoc,\n+    sig: option<str>\n+};\n+\n type moddoc = {\n     item: itemdoc,\n     items: [itemtag],\n@@ -51,27 +66,9 @@ type nmoddoc = {\n     fns: [fndoc]\n };\n \n-type constdoc = {\n-    item: itemdoc,\n-    ty: option<str>\n-};\n-\n-type fndoc = {\n-    item: itemdoc,\n-    args: [argdoc],\n-    return: retdoc,\n-    failure: option<str>,\n-    sig: option<str>\n-};\n-\n-type argdoc = {\n-    name: str,\n-    desc: option<str>\n-};\n+type constdoc = simpleitemdoc;\n \n-type retdoc = {\n-    desc: option<str>\n-};\n+type fndoc = simpleitemdoc;\n \n type enumdoc = {\n     item: itemdoc,\n@@ -84,11 +81,7 @@ type variantdoc = {\n     sig: option<str>\n };\n \n-type resdoc = {\n-    item: itemdoc,\n-    args: [argdoc],\n-    sig: option<str>\n-};\n+type resdoc = simpleitemdoc;\n \n type ifacedoc = {\n     item: itemdoc,\n@@ -99,9 +92,7 @@ type methoddoc = {\n     name: str,\n     brief: option<str>,\n     desc: option<str>,\n-    args: [argdoc],\n-    return: retdoc,\n-    failure: option<str>,\n+    sections: [section],\n     sig: option<str>\n };\n \n@@ -112,10 +103,7 @@ type impldoc = {\n     methods: [methoddoc]\n };\n \n-type tydoc = {\n-    item: itemdoc,\n-    sig: option<str>\n-};\n+type tydoc = simpleitemdoc;\n \n type index = {\n     entries: [index_entry]\n@@ -344,30 +332,22 @@ impl of item for itemtag {\n     }\n }\n \n-impl of item for moddoc {\n-    fn item() -> itemdoc { self.item }\n-}\n-\n-impl of item for nmoddoc {\n+impl of item for simpleitemdoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl of item for fndoc {\n+impl of item for moddoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl of item for constdoc {\n+impl of item for nmoddoc {\n     fn item() -> itemdoc { self.item }\n }\n \n impl of item for enumdoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl of item for resdoc {\n-    fn item() -> itemdoc { self.item }\n-}\n-\n impl of item for ifacedoc {\n     fn item() -> itemdoc { self.item }\n }\n@@ -376,10 +356,6 @@ impl of item for impldoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl of item for tydoc {\n-    fn item() -> itemdoc { self.item }\n-}\n-\n impl util<A:item> for A {\n     fn id() -> ast_id {\n         self.item().id\n@@ -400,4 +376,8 @@ impl util<A:item> for A {\n     fn desc() -> option<str> {\n         self.item().desc\n     }\n+\n+    fn sections() -> [section] {\n+        self.item().sections\n+    }\n }\n\\ No newline at end of file"}, {"sha": "23cc4755cf46e997c0ce22587cc2134dadd04fbd", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 12, "deletions": 70, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -44,6 +44,7 @@ fn mk_itemdoc(id: ast::node_id, name: ast::ident) -> doc::itemdoc {\n         path: [],\n         brief: none,\n         desc: none,\n+        sections: [],\n         reexport: false\n     }\n }\n@@ -67,9 +68,9 @@ fn moddoc_from_mod(\n                     nmoddoc_from_mod(itemdoc, nm)\n                 ))\n               }\n-              ast::item_fn(decl, _, _) {\n+              ast::item_fn(_, _, _) {\n                 some(doc::fntag(\n-                    fndoc_from_fn(itemdoc, decl)\n+                    fndoc_from_fn(itemdoc)\n                 ))\n               }\n               ast::item_const(_, _) {\n@@ -82,9 +83,9 @@ fn moddoc_from_mod(\n                     enumdoc_from_enum(itemdoc, variants)\n                 ))\n               }\n-              ast::item_res(decl, _, _, _, _) {\n+              ast::item_res(_, _, _, _, _) {\n                 some(doc::restag(\n-                    resdoc_from_resource(itemdoc, decl)\n+                    resdoc_from_resource(itemdoc)\n                 ))\n               }\n               ast::item_iface(_, methods) {\n@@ -120,54 +121,25 @@ fn nmoddoc_from_mod(\n         fns: par::seqmap(module.items) {|item|\n             let itemdoc = mk_itemdoc(item.id, item.ident);\n             alt item.node {\n-              ast::native_item_fn(decl, _) {\n-                fndoc_from_fn(itemdoc, decl)\n+              ast::native_item_fn(_, _) {\n+                fndoc_from_fn(itemdoc)\n               }\n             }\n         }\n     }\n }\n \n-fn fndoc_from_fn(\n-    itemdoc: doc::itemdoc,\n-    decl: ast::fn_decl\n-) -> doc::fndoc {\n+fn fndoc_from_fn(itemdoc: doc::itemdoc) -> doc::fndoc {\n     {\n         item: itemdoc,\n-        args: argdocs_from_args(decl.inputs),\n-        return: {\n-            desc: none\n-        },\n-        failure: none,\n         sig: none\n     }\n }\n \n-#[test]\n-fn should_extract_fn_args() {\n-    let source = \"fn a(b: int, c: int) { }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n-    let fn_ = doc.cratemod().fns()[0];\n-    assert fn_.args[0].name == \"b\";\n-    assert fn_.args[1].name == \"c\";\n-}\n-\n-fn argdocs_from_args(args: [ast::arg]) -> [doc::argdoc] {\n-    par::seqmap(args, argdoc_from_arg)\n-}\n-\n-fn argdoc_from_arg(arg: ast::arg) -> doc::argdoc {\n-    {\n-        name: arg.ident,\n-        desc: none\n-    }\n-}\n-\n fn constdoc_from_const(itemdoc: doc::itemdoc) -> doc::constdoc {\n     {\n         item: itemdoc,\n-        ty: none\n+        sig: none\n     }\n }\n \n@@ -215,13 +187,9 @@ fn should_extract_enum_variants() {\n     assert doc.cratemod().enums()[0].variants[0].name == \"v\";\n }\n \n-fn resdoc_from_resource(\n-    itemdoc: doc::itemdoc,\n-    decl: ast::fn_decl\n-) -> doc::resdoc {\n+fn resdoc_from_resource(itemdoc: doc::itemdoc) -> doc::resdoc {\n     {\n         item: itemdoc,\n-        args: argdocs_from_args(decl.inputs),\n         sig: none\n     }\n }\n@@ -233,12 +201,6 @@ fn should_extract_resources() {\n     assert doc.cratemod().resources()[0].name() == \"r\";\n }\n \n-#[test]\n-fn should_extract_resource_args() {\n-    let doc = test::mk_doc(\"resource r(b: bool) { }\");\n-    assert doc.cratemod().resources()[0].args[0].name == \"b\";\n-}\n-\n fn ifacedoc_from_iface(\n     itemdoc: doc::itemdoc,\n     methods: [ast::ty_method]\n@@ -250,11 +212,7 @@ fn ifacedoc_from_iface(\n                 name: method.ident,\n                 brief: none,\n                 desc: none,\n-                args: argdocs_from_args(method.decl.inputs),\n-                return: {\n-                    desc: none\n-                },\n-                failure: none,\n+                sections: [],\n                 sig: none\n             }\n         }\n@@ -273,12 +231,6 @@ fn should_extract_iface_methods() {\n     assert doc.cratemod().ifaces()[0].methods[0].name == \"f\";\n }\n \n-#[test]\n-fn should_extract_iface_method_args() {\n-    let doc = test::mk_doc(\"iface i { fn f(a: bool); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].args[0].name == \"a\";\n-}\n-\n fn impldoc_from_impl(\n     itemdoc: doc::itemdoc,\n     methods: [@ast::method]\n@@ -292,11 +244,7 @@ fn impldoc_from_impl(\n                 name: method.ident,\n                 brief: none,\n                 desc: none,\n-                args: argdocs_from_args(method.decl.inputs),\n-                return: {\n-                    desc: none\n-                },\n-                failure: none,\n+                sections: [],\n                 sig: none\n             }\n         }\n@@ -321,12 +269,6 @@ fn should_extract_impl_methods() {\n     assert doc.cratemod().impls()[0].methods[0].name == \"f\";\n }\n \n-#[test]\n-fn should_extract_impl_method_args() {\n-    let doc = test::mk_doc(\"impl i for int { fn f(a: bool) { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].args[0].name == \"a\";\n-}\n-\n fn tydoc_from_ty(\n     itemdoc: doc::itemdoc\n ) -> doc::tydoc {"}, {"sha": "28b9c015af0695ed2b92262fe6634fc1b0fe8f65", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -145,7 +145,7 @@ fn should_index_mod_contents_multi_page() {\n fn should_add_brief_desc_to_index() {\n     let doc = test::mk_doc(\n         config::doc_per_mod,\n-        \"#[doc(brief = \\\"test\\\")] mod a { }\"\n+        \"#[doc = \\\"test\\\"] mod a { }\"\n     );\n     assert option::get(doc.cratemod().index).entries[0].brief == some(\"test\");\n }\n@@ -160,6 +160,7 @@ mod test {\n             };\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n+            let doc = desc_to_brief_pass::mk_pass().f(srv, doc);\n             let doc = path_pass::mk_pass().f(srv, doc);\n             run(srv, doc, config)\n         }"}, {"sha": "bb8fd38d23ceb0df5f03dcee101278c07381309a", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 80, "deletions": 314, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -120,7 +120,8 @@ fn should_request_new_writer_for_each_page() {\n enum hlvl {\n     h1 = 1,\n     h2 = 2,\n-    h3 = 3\n+    h3 = 3,\n+    h4 = 4\n }\n \n fn write_header(ctxt: ctxt, lvl: hlvl, doc: doc::itemtag) {\n@@ -238,12 +239,55 @@ fn should_write_full_path_to_mod() {\n     assert str::contains(markdown, \"# Module `a::b::c`\");\n }\n \n+fn write_common(\n+    ctxt: ctxt,\n+    desc: option<str>,\n+    sections: [doc::section]\n+) {\n+    write_desc(ctxt, desc);\n+    write_sections(ctxt, sections);\n+}\n+\n+fn write_desc(\n+    ctxt: ctxt,\n+    desc: option<str>\n+) {\n+    alt desc {\n+        some(desc) {\n+            ctxt.w.write_line(desc);\n+            ctxt.w.write_line(\"\");\n+        }\n+        none { }\n+    }\n+}\n+\n+fn write_sections(ctxt: ctxt, sections: [doc::section]) {\n+    vec::iter(sections) {|section|\n+        write_section(ctxt, section);\n+    }\n+}\n+\n+fn write_section(ctxt: ctxt, section: doc::section) {\n+    write_header_(ctxt, h4, section.header);\n+    ctxt.w.write_line(section.body);\n+    ctxt.w.write_line(\"\");\n+}\n+\n+#[test]\n+fn should_write_sections() {\n+    let markdown = test::render(\n+        \"#[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert str::contains(markdown, \"#### Header\\n\\nBody\\n\\n\");\n+}\n+\n fn write_mod_contents(\n     ctxt: ctxt,\n     doc: doc::moddoc\n ) {\n-    write_brief(ctxt, doc.brief());\n-    write_desc(ctxt, doc.desc());\n+    write_common(ctxt, doc.desc(), doc.sections());\n     if option::is_some(doc.index) {\n         write_index(ctxt, option::get(doc.index));\n     }\n@@ -267,12 +311,6 @@ fn write_item(ctxt: ctxt, doc: doc::itemtag) {\n     }\n }\n \n-#[test]\n-fn should_write_crate_brief_description() {\n-    let markdown = test::render(\"#[doc(brief = \\\"this is the crate\\\")];\");\n-    assert str::contains(markdown, \"this is the crate\");\n-}\n-\n #[test]\n fn should_write_crate_description() {\n     let markdown = test::render(\"#[doc = \\\"this is the crate\\\"];\");\n@@ -309,7 +347,7 @@ fn should_write_index() {\n \n #[test]\n fn should_write_index_brief() {\n-    let markdown = test::render(\"#[doc(brief = \\\"test\\\")] mod a { }\");\n+    let markdown = test::render(\"#[doc = \\\"test\\\"] mod a { }\");\n     assert str::contains(markdown, \"(#module-a) - test\\n\");\n }\n \n@@ -321,9 +359,7 @@ fn should_not_write_index_if_no_entries() {\n \n fn write_nmod(ctxt: ctxt, doc: doc::nmoddoc) {\n     write_header(ctxt, h1, doc::nmodtag(doc));\n-\n-    write_brief(ctxt, doc.brief());\n-    write_desc(ctxt, doc.desc());\n+    write_common(ctxt, doc.desc(), doc.sections());\n \n     for fndoc in doc.fns {\n         write_fn(ctxt, fndoc);\n@@ -351,29 +387,19 @@ fn write_fn(\n     write_fnlike(\n         ctxt,\n         doc.sig,\n-        doc.brief(),\n         doc.desc(),\n-        doc.args,\n-        doc.return,\n-        doc.failure\n+        doc.sections()\n     );\n }\n \n fn write_fnlike(\n     ctxt: ctxt,\n     sig: option<str>,\n-    brief: option<str>,\n     desc: option<str>,\n-    args: [doc::argdoc],\n-    return: doc::retdoc,\n-    failure: option<str>\n+    sections: [doc::section]\n ) {\n     write_sig(ctxt, sig);\n-    write_brief(ctxt, brief);\n-    write_desc(ctxt, desc);\n-    write_args(ctxt, args);\n-    write_return(ctxt, return);\n-    write_failure(ctxt, failure);\n+    write_common(ctxt, desc, sections);\n }\n \n fn write_sig(ctxt: ctxt, sig: option<str>) {\n@@ -433,177 +459,17 @@ fn should_correctly_indent_fn_signature() {\n \n #[test]\n fn should_leave_blank_line_between_fn_header_and_sig() {\n-    let markdown = test::render(\"#[doc(brief = \\\"brief\\\")] fn a() { }\");\n-    assert str::contains(markdown, \"Function `a`\\n\\n    fn a()\");\n-}\n-\n-fn write_brief(\n-    ctxt: ctxt,\n-    brief: option<str>\n-) {\n-    alt brief {\n-      some(brief) {\n-        ctxt.w.write_line(brief);\n-        ctxt.w.write_line(\"\");\n-      }\n-      none { }\n-    }\n-}\n-\n-#[test]\n-fn should_leave_blank_line_after_brief() {\n-    let markdown = test::render(\"#[doc(brief = \\\"brief\\\")] fn a() { }\");\n-    assert str::contains(markdown, \"brief\\n\\n\");\n-}\n-\n-#[test]\n-fn should_leave_blank_line_between_brief_and_desc() {\n-    let markdown = test::render(\n-        \"#[doc(brief = \\\"brief\\\", desc = \\\"desc\\\")] fn a() { }\"\n-    );\n-    assert str::contains(markdown, \"brief\\n\\ndesc\");\n-}\n-\n-fn write_desc(\n-    ctxt: ctxt,\n-    desc: option<str>\n-) {\n-    alt desc {\n-        some(desc) {\n-            ctxt.w.write_line(desc);\n-            ctxt.w.write_line(\"\");\n-        }\n-        none { }\n-    }\n-}\n-\n-fn write_args(\n-    ctxt: ctxt,\n-    args: [doc::argdoc]\n-) {\n-    if vec::is_not_empty(args) {\n-        write_lead(ctxt, \"Arguments\");\n-        ctxt.w.write_line(\"\");\n-        ctxt.w.write_line(\"\");\n-        vec::iter(args) {|arg| write_arg(ctxt, arg) };\n-        ctxt.w.write_line(\"\");\n-    }\n-}\n-\n-fn write_arg(ctxt: ctxt, arg: doc::argdoc) {\n-    ctxt.w.write_str(#fmt(\n-        \"* `%s`\",\n-        arg.name\n-    ));\n-    alt arg.desc {\n-      some(desc) {\n-        ctxt.w.write_str(#fmt(\" - %s\", desc));\n-      }\n-      none { }\n-    }\n-    ctxt.w.write_line(\"\");\n-}\n-\n-#[test]\n-fn should_write_argument_list() {\n-    let source = \"fn a(b: int, c: int) { }\";\n-    let markdown = test::render(source);\n-    assert str::contains(\n-        markdown,\n-        \"__Arguments__: \\n\\\n-         \\n\\\n-         * `b`\\n\\\n-         * `c`\\n\\\n-         \\n\"\n-    );\n-}\n-\n-#[test]\n-fn should_not_write_arguments_if_none() {\n-    let source = \"fn a() { } fn b() { }\";\n-    let markdown = test::render(source);\n-    assert !str::contains(markdown, \"Arguments\");\n-}\n-\n-#[test]\n-fn should_write_argument_description() {\n-    let source = \"#[doc(args(a = \\\"milk\\\"))] fn f(a: bool) { }\";\n-    let markdown = test::render(source);\n-    assert str::contains(markdown, \"`a` - milk\");\n-}\n-\n-fn write_return(\n-    ctxt: ctxt,\n-    doc: doc::retdoc\n-) {\n-    alt doc.desc {\n-      some(d) {\n-        write_lead(ctxt, \"Return value\");\n-        ctxt.w.write_line(d);\n-        ctxt.w.write_line(\"\");\n-      }\n-      none { }\n-    }\n-}\n-\n-#[test]\n-fn should_write_return_type_on_new_line() {\n-    let markdown = test::render(\n-        \"#[doc(return = \\\"test\\\")] fn a() -> int { }\");\n-    assert str::contains(markdown, \"\\n__Return value__: test\");\n-}\n-\n-#[test]\n-fn should_write_blank_line_between_return_type_and_next_header() {\n-    let markdown = test::render(\n-        \"#[doc(return = \\\"test\\\")] fn a() -> int { } \\\n-         fn b() -> int { }\"\n-    );\n-    assert str::contains(markdown, \"__Return value__: test\\n\\n##\");\n-}\n-\n-#[test]\n-fn should_not_write_return_type_when_there_is_none() {\n     let markdown = test::render(\"fn a() { }\");\n-    assert !str::contains(markdown, \"Return value\");\n-}\n-\n-#[test]\n-fn should_write_blank_line_after_return_description() {\n-    let markdown = test::render(\n-        \"#[doc(return = \\\"blorp\\\")] fn a() -> int { }\"\n-    );\n-    assert str::contains(markdown, \"blorp\\n\\n\");\n-}\n-\n-fn write_failure(ctxt: ctxt, str: option<str>) {\n-    alt str {\n-      some(str) {\n-        write_lead(ctxt, \"Failure conditions\");\n-        ctxt.w.write_line(str);\n-        ctxt.w.write_line(\"\");\n-      }\n-      none { }\n-    }\n-}\n-\n-#[test]\n-fn should_write_failure_conditions() {\n-    let markdown = test::render(\n-        \"#[doc(failure = \\\"it's the fail\\\")] fn a () { }\");\n-    assert str::contains(\n-        markdown,\n-        \"\\n\\n__Failure conditions__: it's the fail\\n\\n\");\n+    assert str::contains(markdown, \"Function `a`\\n\\n    fn a()\");\n }\n \n fn write_const(\n     ctxt: ctxt,\n     doc: doc::constdoc\n ) {\n     write_header(ctxt, h2, doc::consttag(doc));\n-    write_sig(ctxt, doc.ty);\n-    write_brief(ctxt, doc.brief());\n-    write_desc(ctxt, doc.desc());\n+    write_sig(ctxt, doc.sig);\n+    write_common(ctxt, doc.desc(), doc.sections());\n }\n \n #[test]\n@@ -615,18 +481,17 @@ fn should_write_const_header() {\n #[test]\n fn should_write_const_description() {\n     let markdown = test::render(\n-        \"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n+        \"#[doc = \\\"b\\\"]\\\n          const a: bool = true;\");\n-    assert str::contains(markdown, \"\\n\\na\\n\\nb\\n\\n\");\n+    assert str::contains(markdown, \"\\n\\nb\\n\\n\");\n }\n \n fn write_enum(\n     ctxt: ctxt,\n     doc: doc::enumdoc\n ) {\n     write_header(ctxt, h2, doc::enumtag(doc));\n-    write_brief(ctxt, doc.brief());\n-    write_desc(ctxt, doc.desc());\n+    write_common(ctxt, doc.desc(), doc.sections());\n     write_variants(ctxt, doc.variants);\n }\n \n@@ -639,8 +504,8 @@ fn should_write_enum_header() {\n #[test]\n fn should_write_enum_description() {\n     let markdown = test::render(\n-        \"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")] enum a { b }\");\n-    assert str::contains(markdown, \"\\n\\na\\n\\nb\\n\\n\");\n+        \"#[doc = \\\"b\\\"] enum a { b }\");\n+    assert str::contains(markdown, \"\\n\\nb\\n\\n\");\n }\n \n fn write_variants(\n@@ -651,8 +516,7 @@ fn write_variants(\n         ret;\n     }\n \n-    ctxt.w.write_line(\"Variants:\");\n-    ctxt.w.write_line(\"\");\n+    write_header_(ctxt, h4, \"Variants\");\n \n     vec::iter(docs, {|variant| write_variant(ctxt, variant) });\n \n@@ -680,7 +544,7 @@ fn should_write_variant_list() {\n          #[doc = \\\"test\\\"] c }\");\n     assert str::contains(\n         markdown,\n-        \"\\n\\nVariants:\\n\\\n+        \"\\n\\n#### Variants\\n\\\n          \\n* `b` - test\\\n          \\n* `c` - test\\n\\n\");\n }\n@@ -690,7 +554,7 @@ fn should_write_variant_list_without_descs() {\n     let markdown = test::render(\"enum a { b, c }\");\n     assert str::contains(\n         markdown,\n-        \"\\n\\nVariants:\\n\\\n+        \"\\n\\n#### Variants\\n\\\n          \\n* `b`\\\n          \\n* `c`\\n\\n\");\n }\n@@ -700,17 +564,15 @@ fn should_write_variant_list_with_signatures() {\n     let markdown = test::render(\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n     assert str::contains(\n         markdown,\n-        \"\\n\\nVariants:\\n\\\n+        \"\\n\\n#### Variants\\n\\\n          \\n* `b(int)`\\\n          \\n* `c(int)` - a\\n\\n\");\n }\n \n fn write_res(ctxt: ctxt, doc: doc::resdoc) {\n     write_header(ctxt, h2, doc::restag(doc));\n     write_sig(ctxt, doc.sig);\n-    write_brief(ctxt, doc.brief());\n-    write_desc(ctxt, doc.desc());\n-    write_args(ctxt, doc.args);\n+    write_common(ctxt, doc.desc(), doc.sections());\n }\n \n #[test]\n@@ -725,17 +587,9 @@ fn should_write_resource_signature() {\n     assert str::contains(markdown, \"\\n    resource r(a: bool)\\n\");\n }\n \n-#[test]\n-fn should_write_resource_args() {\n-    let markdown = test::render(\"#[doc(args(a = \\\"b\\\"))]\\\n-                                 resource r(a: bool) { }\");\n-    assert str::contains(markdown, \"__Arguments__: \\n\\n* `a` - b\");\n-}\n-\n fn write_iface(ctxt: ctxt, doc: doc::ifacedoc) {\n     write_header(ctxt, h2, doc::ifacetag(doc));\n-    write_brief(ctxt, doc.brief());\n-    write_desc(ctxt, doc.desc());\n+    write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n@@ -748,11 +602,8 @@ fn write_method(ctxt: ctxt, doc: doc::methoddoc) {\n     write_fnlike(\n         ctxt,\n         doc.sig,\n-        doc.brief,\n         doc.desc,\n-        doc.args,\n-        doc.return,\n-        doc.failure\n+        doc.sections\n     );\n }\n \n@@ -762,17 +613,10 @@ fn should_write_iface_header() {\n     assert str::contains(markdown, \"## Interface `i`\");\n }\n \n-#[test]\n-fn should_write_iface_brief() {\n-    let markdown = test::render(\n-        \"#[doc(brief = \\\"brief\\\")] iface i { fn a(); }\");\n-    assert str::contains(markdown, \"brief\");\n-}\n-\n #[test]\n fn should_write_iface_desc() {\n     let markdown = test::render(\n-        \"#[doc(desc = \\\"desc\\\")] iface i { fn a(); }\");\n+        \"#[doc = \\\"desc\\\"] iface i { fn a(); }\");\n     assert str::contains(markdown, \"desc\");\n }\n \n@@ -790,45 +634,9 @@ fn should_write_iface_method_signature() {\n     assert str::contains(markdown, \"\\n    fn a()\");\n }\n \n-#[test]\n-fn should_write_iface_method_argument_header() {\n-    let markdown = test::render(\n-        \"iface a { fn a(b: int); }\");\n-    assert str::contains(markdown, \"\\n\\n__Arguments__: \\n\\n\");\n-}\n-\n-#[test]\n-fn should_write_iface_method_arguments() {\n-    let markdown = test::render(\n-        \"iface a { fn a(b: int); }\");\n-    assert str::contains(markdown, \"* `b`\\n\");\n-}\n-\n-#[test]\n-fn should_not_write_iface_method_arguments_if_none() {\n-    let markdown = test::render(\n-        \"iface a { fn a(); }\");\n-    assert !str::contains(markdown, \"Arguments\");\n-}\n-\n-#[test]\n-fn should_write_iface_method_return_info() {\n-    let markdown = test::render(\n-        \"iface a { #[doc(return = \\\"test\\\")] fn a() -> int; }\");\n-    assert str::contains(markdown, \"__Return value__: test\");\n-}\n-\n-#[test]\n-fn should_write_iface_method_failure_conditions() {\n-    let markdown = test::render(\n-        \"iface a { #[doc(failure = \\\"nuked\\\")] fn a(); }\");\n-    assert str::contains(markdown, \"__Failure conditions__: nuked\");\n-}\n-\n fn write_impl(ctxt: ctxt, doc: doc::impldoc) {\n     write_header(ctxt, h2, doc::impltag(doc));\n-    write_brief(ctxt, doc.brief());\n-    write_desc(ctxt, doc.desc());\n+    write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n@@ -844,17 +652,10 @@ fn should_write_impl_header_with_iface() {\n     assert str::contains(markdown, \"## Implementation `i of j for int`\");\n }\n \n-#[test]\n-fn should_write_impl_brief() {\n-    let markdown = test::render(\n-        \"#[doc(brief = \\\"brief\\\")] impl i for int { fn a() { } }\");\n-    assert str::contains(markdown, \"brief\");\n-}\n-\n #[test]\n fn should_write_impl_desc() {\n     let markdown = test::render(\n-        \"#[doc(desc = \\\"desc\\\")] impl i for int { fn a() { } }\");\n+        \"#[doc = \\\"desc\\\"] impl i for int { fn a() { } }\");\n     assert str::contains(markdown, \"desc\");\n }\n \n@@ -872,49 +673,13 @@ fn should_write_impl_method_signature() {\n     assert str::contains(markdown, \"\\n    fn a()\");\n }\n \n-#[test]\n-fn should_write_impl_method_argument_header() {\n-    let markdown = test::render(\n-        \"impl a for int { fn a(b: int) { } }\");\n-    assert str::contains(markdown, \"\\n\\n__Arguments__: \\n\\n\");\n-}\n-\n-#[test]\n-fn should_write_impl_method_arguments() {\n-    let markdown = test::render(\n-        \"impl a for int { fn a(b: int) { } }\");\n-    assert str::contains(markdown, \"* `b`\\n\");\n-}\n-\n-#[test]\n-fn should_not_write_impl_method_arguments_if_none() {\n-    let markdown = test::render(\n-        \"impl a for int { fn a() { } }\");\n-    assert !str::contains(markdown, \"Arguments\");\n-}\n-\n-#[test]\n-fn should_write_impl_method_return_info() {\n-    let markdown = test::render(\n-        \"impl a for int { #[doc(return = \\\"test\\\")] fn a() -> int { } }\");\n-    assert str::contains(markdown, \"__Return value__: test\");\n-}\n-\n-#[test]\n-fn should_write_impl_method_failure_conditions() {\n-    let markdown = test::render(\n-        \"impl a for int { #[doc(failure = \\\"nuked\\\")] fn a() { } }\");\n-    assert str::contains(markdown, \"__Failure conditions__: nuked\");\n-}\n-\n fn write_type(\n     ctxt: ctxt,\n     doc: doc::tydoc\n ) {\n     write_header(ctxt, h2, doc::tytag(doc));\n     write_sig(ctxt, doc.sig);\n-    write_brief(ctxt, doc.brief());\n-    write_desc(ctxt, doc.desc());\n+    write_common(ctxt, doc.desc(), doc.sections());\n }\n \n #[test]\n@@ -923,17 +688,10 @@ fn should_write_type_header() {\n     assert str::contains(markdown, \"## Type `t`\");\n }\n \n-#[test]\n-fn should_write_type_brief() {\n-    let markdown = test::render(\n-        \"#[doc(brief = \\\"brief\\\")] type t = int;\");\n-    assert str::contains(markdown, \"\\n\\nbrief\\n\\n\");\n-}\n-\n #[test]\n fn should_write_type_desc() {\n     let markdown = test::render(\n-        \"#[doc(desc = \\\"desc\\\")] type t = int;\");\n+        \"#[doc = \\\"desc\\\"] type t = int;\");\n     assert str::contains(markdown, \"\\n\\ndesc\\n\\n\");\n }\n \n@@ -968,6 +726,14 @@ mod test {\n             #debug(\"doc (path): %?\", doc);\n             let doc = attr_pass::mk_pass().f(srv, doc);\n             #debug(\"doc (attr): %?\", doc);\n+            let doc = desc_to_brief_pass::mk_pass().f(srv, doc);\n+            #debug(\"doc (desc_to_brief): %?\", doc);\n+            let doc = unindent_pass::mk_pass().f(srv, doc);\n+            #debug(\"doc (unindent): %?\", doc);\n+            let doc = sectionalize_pass::mk_pass().f(srv, doc);\n+            #debug(\"doc (trim): %?\", doc);\n+            let doc = trim_pass::mk_pass().f(srv, doc);\n+            #debug(\"doc (sectionalize): %?\", doc);\n             let doc = markdown_index_pass::mk_pass(config).f(srv, doc);\n             #debug(\"doc (index): %?\", doc);\n             (srv, doc)"}, {"sha": "dc4194e0fc79574053f4192db772f85ca9c2b2b8", "filename": "src/rustdoc/prune_undoc_details_pass.rs", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c758ef3f386578cffd5353e1b84e94d1f30d760f/src%2Frustdoc%2Fprune_undoc_details_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c758ef3f386578cffd5353e1b84e94d1f30d760f/src%2Frustdoc%2Fprune_undoc_details_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_details_pass.rs?ref=c758ef3f386578cffd5353e1b84e94d1f30d760f", "patch": "@@ -1,129 +0,0 @@\n-#[doc = \"Prunes args, retvals of the document tree that \\\n-         contain no documentation\"];\n-\n-export mk_pass;\n-\n-fn mk_pass() -> pass {\n-    {\n-        name: \"prune_undoc_details\",\n-        f: run\n-    }\n-}\n-\n-fn run(\n-    _srv: astsrv::srv,\n-    doc: doc::doc\n-) -> doc::doc {\n-    let fold = fold::fold({\n-        fold_fn: fold_fn,\n-        fold_res: fold_res,\n-        fold_iface: fold_iface,\n-        fold_impl: fold_impl\n-        with *fold::default_any_fold(())\n-    });\n-    fold.fold_doc(fold, doc)\n-}\n-\n-fn fold_fn(\n-    fold: fold::fold<()>,\n-    doc: doc::fndoc\n-) -> doc::fndoc {\n-    let doc = fold::default_seq_fold_fn(fold, doc);\n-\n-    {\n-        args: prune_args(doc.args)\n-        with doc\n-    }\n-}\n-\n-fn prune_args(docs: [doc::argdoc]) -> [doc::argdoc] {\n-    vec::filter_map(docs) {|doc|\n-        if option::is_some(doc.desc) {\n-            some(doc)\n-        } else {\n-            none\n-        }\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_arguments() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] fn a(b: int) { }\");\n-    assert vec::is_empty(doc.cratemod().fns()[0].args);\n-}\n-\n-fn fold_res(\n-    fold: fold::fold<()>,\n-    doc: doc::resdoc\n-) -> doc::resdoc {\n-    let doc = fold::default_seq_fold_res(fold, doc);\n-\n-    {\n-        args: prune_args(doc.args)\n-        with doc\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_resource_args() {\n-    let doc = test::mk_doc(\"#[doc = \\\"drunk\\\"]\\\n-                            resource r(a: bool) { }\");\n-    assert vec::is_empty(doc.cratemod().resources()[0].args);\n-}\n-\n-fn fold_iface(\n-    fold: fold::fold<()>,\n-    doc: doc::ifacedoc\n-) -> doc::ifacedoc {\n-    let doc = fold::default_seq_fold_iface(fold, doc);\n-\n-    {\n-        methods: prune_methods(doc.methods)\n-        with doc\n-    }\n-}\n-\n-fn prune_methods(docs: [doc::methoddoc]) -> [doc::methoddoc] {\n-    par::anymap(docs) {|doc|\n-        {\n-            args: prune_args(doc.args)\n-            with doc\n-        }\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_iface_method_args() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_empty(doc.cratemod().ifaces()[0].methods[0].args);\n-}\n-\n-fn fold_impl(\n-    fold: fold::fold<()>,\n-    doc: doc::impldoc\n-) -> doc::impldoc {\n-    let doc = fold::default_seq_fold_impl(fold, doc);\n-\n-    {\n-        methods: prune_methods(doc.methods)\n-        with doc\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_impl_method_args() {\n-    let doc = test::mk_doc(\n-        \"#[doc = \\\"hey\\\"] impl i for int { fn a(b: bool) { } }\");\n-    assert vec::is_empty(doc.cratemod().impls()[0].methods[0].args);\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n-            let doc = extract::from_srv(srv, \"\");\n-            let doc = attr_pass::mk_pass().f(srv, doc);\n-            run(srv, doc)\n-        }\n-    }\n-}"}, {"sha": "ca7287cb8fc5bcd539225a58f11f156b47be4230", "filename": "src/rustdoc/prune_undoc_items_pass.rs", "status": "removed", "additions": 0, "deletions": 377, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/c758ef3f386578cffd5353e1b84e94d1f30d760f/src%2Frustdoc%2Fprune_undoc_items_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c758ef3f386578cffd5353e1b84e94d1f30d760f/src%2Frustdoc%2Fprune_undoc_items_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_items_pass.rs?ref=c758ef3f386578cffd5353e1b84e94d1f30d760f", "patch": "@@ -1,377 +0,0 @@\n-#[doc = \"Prunes items of the document tree that contain no documentation\"];\n-\n-export mk_pass;\n-\n-fn mk_pass() -> pass {\n-    {\n-        name: \"prune_undoc_items\",\n-        f: run\n-    }\n-}\n-\n-type ctxt = {\n-    mutable have_docs: bool\n-};\n-\n-fn run(\n-    _srv: astsrv::srv,\n-    doc: doc::doc\n-) -> doc::doc {\n-    let ctxt = {\n-        mutable have_docs: true\n-    };\n-    let fold = fold::fold({\n-        fold_mod: fold_mod,\n-        fold_fn: fold_fn,\n-        fold_const: fold_const,\n-        fold_enum: fold_enum,\n-        fold_res: fold_res,\n-        fold_iface: fold_iface,\n-        fold_impl: fold_impl,\n-        fold_type: fold_type\n-        with *fold::default_any_fold(ctxt)\n-    });\n-    fold.fold_doc(fold, doc)\n-}\n-\n-fn fold_mod(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::moddoc\n-) -> doc::moddoc {\n-    let doc = {\n-        items: vec::filter_map(doc.items) {|itemtag|\n-            alt itemtag {\n-              doc::modtag(moddoc) {\n-                let doc = fold.fold_mod(fold, moddoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::modtag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::fntag(fndoc) {\n-                let doc = fold.fold_fn(fold, fndoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::fntag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::consttag(constdoc) {\n-                let doc = fold.fold_const(fold, constdoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::consttag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::enumtag(enumdoc) {\n-                let doc = fold.fold_enum(fold, enumdoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::enumtag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::restag(resdoc) {\n-                let doc = fold.fold_res(fold, resdoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::restag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::ifacetag(ifacedoc) {\n-                let doc = fold.fold_iface(fold, ifacedoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::ifacetag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::impltag(impldoc) {\n-                let doc = fold.fold_impl(fold, impldoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::impltag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::tytag(tydoc) {\n-                let doc = fold.fold_type(fold, tydoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::tytag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              _ { some(itemtag) }\n-            }\n-        }\n-        with fold::default_any_fold_mod(fold, doc)\n-    };\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || vec::is_not_empty(doc.items);\n-    ret doc;\n-}\n-\n-fn fold_fn(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::fndoc\n-) -> doc::fndoc {\n-    let doc = fold::default_seq_fold_fn(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || args_have_docs(doc.args)\n-        || doc.return.desc != none\n-        || doc.failure != none;\n-    ret doc;\n-}\n-\n-fn args_have_docs(docs: [doc::argdoc]) -> bool {\n-    vec::foldl(false, docs) {|accum, doc|\n-        accum || doc.desc != none\n-    }\n-}\n-\n-#[test]\n-fn should_elide_fns_with_undocumented_arguments() {\n-    let doc = test::mk_doc(\"fn a(a: int) { }\");\n-    assert vec::is_empty(doc.cratemod().fns());\n-}\n-\n-#[test]\n-fn should_not_elide_fns_with_documented_arguments() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn a(a: int) { }\");\n-    assert vec::is_not_empty(doc.cratemod().fns());\n-}\n-\n-#[test]\n-fn should_not_elide_fns_with_documented_failure_conditions() {\n-    let doc = test::mk_doc(\"#[doc(failure = \\\"yup\\\")] fn a() { }\");\n-    assert vec::is_not_empty(doc.cratemod().fns());\n-}\n-\n-#[test]\n-fn should_elide_undocumented_mods() {\n-    let doc = test::mk_doc(\"mod a { }\");\n-    assert vec::is_empty(doc.cratemod().mods());\n-}\n-\n-#[test]\n-fn should_not_elide_undocument_mods_with_documented_mods() {\n-    let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] mod b { } }\");\n-    assert vec::is_not_empty(doc.cratemod().mods());\n-}\n-\n-#[test]\n-fn should_not_elide_undocument_mods_with_documented_fns() {\n-    let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] fn b() { } }\");\n-    assert vec::is_not_empty(doc.cratemod().mods());\n-}\n-\n-#[test]\n-fn should_elide_undocumented_fns() {\n-    let doc = test::mk_doc(\"fn a() { }\");\n-    assert vec::is_empty(doc.cratemod().fns());\n-}\n-\n-fn fold_const(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::constdoc\n-) -> doc::constdoc {\n-    let doc = fold::default_seq_fold_const(fold, doc);\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none;\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_consts() {\n-    let doc = test::mk_doc(\"const a: bool = true;\");\n-    assert vec::is_empty(doc.cratemod().consts());\n-}\n-\n-fn fold_enum(fold: fold::fold<ctxt>, doc: doc::enumdoc) -> doc::enumdoc {\n-    let doc = {\n-        variants: vec::filter_map(doc.variants) {|variant|\n-            if variant.desc != none {\n-                some(variant)\n-            } else {\n-                none\n-            }\n-        }\n-        with fold::default_seq_fold_enum(fold, doc)\n-    };\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || vec::is_not_empty(doc.variants);\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_enums() {\n-    let doc = test::mk_doc(\"enum a { b }\");\n-    assert vec::is_empty(doc.cratemod().enums());\n-}\n-\n-#[test]\n-fn should_elide_undocumented_variants() {\n-    let doc = test::mk_doc(\"#[doc = \\\"a\\\"] enum a { b }\");\n-    assert vec::is_empty(doc.cratemod().enums()[0].variants);\n-}\n-\n-#[test]\n-fn should_not_elide_enums_with_documented_variants() {\n-    let doc = test::mk_doc(\"enum a { #[doc = \\\"a\\\"] b }\");\n-    assert vec::is_not_empty(doc.cratemod().enums());\n-}\n-\n-fn fold_res(fold: fold::fold<ctxt>, doc: doc::resdoc) -> doc::resdoc {\n-    let doc = fold::default_seq_fold_res(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || args_have_docs(doc.args);\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_resources() {\n-    let doc = test::mk_doc(\"resource r(a: bool) { }\");\n-    assert vec::is_empty(doc.cratemod().resources());\n-}\n-\n-#[test]\n-fn should_not_elide_resources_with_documented_args() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"drunk\\\"))]\\\n-                            resource r(a: bool) { }\");\n-    assert vec::is_not_empty(doc.cratemod().resources());\n-}\n-\n-fn fold_iface(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::ifacedoc\n-) -> doc::ifacedoc {\n-    let doc = fold::default_seq_fold_iface(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || methods_have_docs(doc.methods);\n-    ret doc;\n-}\n-\n-fn methods_have_docs(docs: [doc::methoddoc]) -> bool {\n-    vec::foldl(false, docs) {|accum, doc|\n-        accum\n-            || doc.brief != none\n-            || doc.desc != none\n-            || args_have_docs(doc.args)\n-            || doc.return.desc != none\n-            || doc.failure != none\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_ifaces() {\n-    let doc = test::mk_doc(\"iface i { fn a(); }\");\n-    assert vec::is_empty(doc.cratemod().ifaces());\n-}\n-\n-#[test]\n-fn should_not_elide_documented_ifaces() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_not_empty(doc.cratemod().ifaces());\n-}\n-\n-#[test]\n-fn should_elide_ifaces_with_undocumented_args() {\n-    let doc = test::mk_doc(\"iface i { fn a(b: bool); }\");\n-    assert vec::is_empty(doc.cratemod().ifaces());\n-}\n-\n-#[test]\n-fn should_not_elide_ifaces_with_documented_methods() {\n-    let doc = test::mk_doc(\"iface i { #[doc = \\\"hey\\\"] fn a(); }\");\n-    assert vec::is_not_empty(doc.cratemod().ifaces());\n-}\n-\n-#[test]\n-fn should_not_elide_undocumented_iface_methods() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_not_empty(doc.cratemod().ifaces()[0].methods);\n-}\n-\n-fn fold_impl(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::impldoc\n-) -> doc::impldoc {\n-    let doc = fold::default_seq_fold_impl(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || methods_have_docs(doc.methods);\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_impls() {\n-    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n-    assert vec::is_empty(doc.cratemod().impls());\n-}\n-\n-#[test]\n-fn should_not_elide_documented_impls() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] impl i for int { fn a() { } }\");\n-    assert vec::is_not_empty(doc.cratemod().impls());\n-}\n-\n-#[test]\n-fn should_not_elide_impls_with_documented_methods() {\n-    let doc = test::mk_doc(\"impl i for int { #[doc = \\\"hey\\\"] fn a() { } }\");\n-    assert vec::is_not_empty(doc.cratemod().impls());\n-}\n-\n-#[test]\n-fn should_not_elide_undocumented_impl_methods() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] impl i for int { fn a() { } }\");\n-    assert vec::is_not_empty(doc.cratemod().impls()[0].methods);\n-}\n-\n-fn fold_type(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::tydoc\n-) -> doc::tydoc {\n-    let doc = fold::default_seq_fold_type(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none;\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_types() {\n-    let doc = test::mk_doc(\"type t = int;\");\n-    assert vec::is_empty(doc.cratemod().types());\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n-            let doc = extract::from_srv(srv, \"\");\n-            let doc = attr_pass::mk_pass().f(srv, doc);\n-            run(srv, doc)\n-        }\n-    }\n-}"}, {"sha": "a4df1c7e8ea3647b48836c885d58f206baa62c26", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -24,8 +24,6 @@ mod fold;\n mod path_pass;\n mod attr_pass;\n mod tystr_pass;\n-mod prune_undoc_details_pass;\n-mod prune_undoc_items_pass;\n mod prune_unexported_pass;\n mod prune_hidden_pass;\n mod desc_to_brief_pass;\n@@ -40,3 +38,4 @@ mod sort_item_type_pass;\n mod reexport_pass;\n mod par;\n mod page_pass;\n+mod sectionalize_pass;\n\\ No newline at end of file"}, {"sha": "e087dcefc306e95e3d2ef899f4b409b467d2a66c", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -143,13 +143,11 @@ fn run(config: config::config) {\n             tystr_pass::mk_pass(),\n             path_pass::mk_pass(),\n             attr_pass::mk_pass(),\n-            prune_undoc_details_pass::mk_pass(),\n-            // FIXME: This pass should be optional\n-            // prune_undoc_items_pass::mk_pass(),\n             prune_hidden_pass::mk_pass(),\n             desc_to_brief_pass::mk_pass(),\n-            trim_pass::mk_pass(),\n             unindent_pass::mk_pass(),\n+            sectionalize_pass::mk_pass(),\n+            trim_pass::mk_pass(),\n             sort_item_name_pass::mk_pass(),\n             sort_item_type_pass::mk_pass(),\n             markdown_index_pass::mk_pass(config),"}, {"sha": "fc957835822a2ecacaf91b639d823d919f2017e0", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -0,0 +1,237 @@\n+#[doc = \"Breaks rustdocs into sections according to their headers\"];\n+\n+export mk_pass;\n+\n+fn mk_pass() -> pass {\n+    {\n+        name: \"sectionalize\",\n+        f: run\n+    }\n+}\n+\n+fn run(_srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n+    let fold = fold::fold({\n+        fold_item: fold_item,\n+        fold_iface: fold_iface,\n+        fold_impl: fold_impl\n+        with *fold::default_any_fold(())\n+    });\n+    fold.fold_doc(fold, doc)\n+}\n+\n+fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n+    let doc = fold::default_seq_fold_item(fold, doc);\n+    let (desc, sections) = sectionalize(doc.desc);\n+\n+    {\n+        desc: desc,\n+        sections: sections\n+        with doc\n+    }\n+}\n+\n+fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n+    let doc = fold::default_seq_fold_iface(fold, doc);\n+\n+    {\n+        methods: par::anymap(doc.methods) {|method|\n+            let (desc, sections) = sectionalize(method.desc);\n+\n+            {\n+                desc: desc,\n+                sections: sections\n+                with method\n+            }\n+        }\n+        with doc\n+    }\n+}\n+\n+fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n+    let doc = fold::default_seq_fold_impl(fold, doc);\n+\n+    {\n+        methods: par::anymap(doc.methods) {|method|\n+            let (desc, sections) = sectionalize(method.desc);\n+\n+            {\n+                desc: desc,\n+                sections: sections\n+                with method\n+            }\n+        }\n+        with doc\n+    }\n+}\n+\n+fn sectionalize(desc: option<str>) -> (option<str>, [doc::section]) {\n+\n+    #[doc = \"\n+\n+    Take a description of the form\n+\n+        General text\n+\n+        # Section header\n+\n+        Section text\n+\n+        # Section header\n+\n+        Section text\n+\n+    and remove each header and accompanying text into section records.\n+\n+    \"];\n+\n+    if option::is_none(desc) {\n+        ret (none, []);\n+    }\n+\n+    let lines = str::lines(option::get(desc));\n+\n+    let new_desc = none;\n+    let current_section = none;\n+    let sections = [];\n+\n+    for line in lines {\n+        alt parse_header(line) {\n+          some(header) {\n+            if option::is_some(current_section) {\n+                sections += [option::get(current_section)];\n+            }\n+            current_section = some({\n+                header: header,\n+                body: \"\"\n+            });\n+          }\n+          none {\n+            alt current_section {\n+              some(section) {\n+                current_section = some({\n+                    body: section.body + \"\\n\" + line\n+                    with section\n+                });\n+              }\n+              none {\n+                alt new_desc {\n+                  some(desc) {\n+                    new_desc = some(desc + \"\\n\" + line);\n+                  }\n+                  none {\n+                    new_desc = some(line);\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }\n+    }\n+\n+    if option::is_some(current_section) {\n+        sections += [option::get(current_section)];\n+    }\n+\n+    (new_desc, sections)\n+}\n+\n+fn parse_header(line: str) -> option<str> {\n+    if str::starts_with(line, \"# \") {\n+        some(str::slice(line, 2u, str::len(line)))\n+    } else {\n+        none\n+    }\n+}\n+\n+#[test]\n+fn should_create_section_headers() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert str::contains(\n+        doc.cratemod().mods()[0].item.sections[0].header,\n+        \"Header\");\n+}\n+\n+#[test]\n+fn should_create_section_bodies() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert str::contains(\n+        doc.cratemod().mods()[0].item.sections[0].body,\n+        \"Body\");\n+}\n+\n+#[test]\n+fn should_not_create_sections_from_indented_headers() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\n\\\n+         Text\\n             # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert vec::is_empty(doc.cratemod().mods()[0].item.sections);\n+}\n+\n+#[test]\n+fn should_remove_section_text_from_main_desc() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         Description\\n\\n\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert !str::contains(\n+        option::get(doc.cratemod().mods()[0].desc()),\n+        \"Header\");\n+    assert !str::contains(\n+        option::get(doc.cratemod().mods()[0].desc()),\n+        \"Body\");\n+}\n+\n+#[test]\n+fn should_eliminate_desc_if_it_is_just_whitespace() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         mod a { }\");\n+    assert doc.cratemod().mods()[0].desc() == none;\n+}\n+\n+#[test]\n+fn should_sectionalize_iface_methods() {\n+    let doc = test::mk_doc(\n+        \"iface i {\n+         #[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         fn a(); }\");\n+    assert doc.cratemod().ifaces()[0].methods[0].sections.len() == 1u;\n+}\n+\n+#[test]\n+fn should_sectionalize_impl_methods() {\n+    let doc = test::mk_doc(\n+        \"impl i for bool {\n+         #[doc = \\\"\\\n+         # Header\\n\\\n+         Body\\\"]\\\n+         fn a() { } }\");\n+    assert doc.cratemod().impls()[0].methods[0].sections.len() == 1u;\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::doc {\n+        astsrv::from_str(source) {|srv|\n+            let doc = extract::from_srv(srv, \"\");\n+            let doc = attr_pass::mk_pass().f(srv, doc);\n+            run(srv, doc)\n+        }\n+    }\n+}"}, {"sha": "18eb6c42110c3fb9ff1e334e06cfc61d1d23d44b", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 80, "deletions": 98, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -20,9 +20,7 @@ fn run(\n ) -> doc::doc {\n     let fold = fold::fold({\n         fold_item: fold_item,\n-        fold_fn: fold_fn,\n         fold_enum: fold_enum,\n-        fold_res: fold_res,\n         fold_iface: fold_iface,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(op)\n@@ -39,28 +37,18 @@ fn fold_item(fold: fold::fold<op>, doc: doc::itemdoc) -> doc::itemdoc {\n \n     {\n         brief: maybe_apply_op(fold.ctxt, doc.brief),\n-        desc: maybe_apply_op(fold.ctxt, doc.desc)\n+        desc: maybe_apply_op(fold.ctxt, doc.desc),\n+        sections: apply_to_sections(fold.ctxt, doc.sections)\n         with doc\n     }\n }\n \n-fn fold_fn(fold: fold::fold<op>, doc: doc::fndoc) -> doc::fndoc {\n-    let fold_ctxt = fold.ctxt;\n-    let doc = fold::default_seq_fold_fn(fold, doc);\n-\n-    {\n-        args: par::anymap(doc.args) {|doc|\n-            {\n-                desc: maybe_apply_op(fold_ctxt, doc.desc)\n-                with doc\n-            }\n-        },\n-        return: {\n-            desc: maybe_apply_op(fold.ctxt, doc.return.desc)\n-            with doc.return\n-        },\n-        failure: maybe_apply_op(fold.ctxt, doc.failure)\n-        with doc\n+fn apply_to_sections(op: op, sections: [doc::section]) -> [doc::section] {\n+    par::anymap(sections) {|section|\n+        {\n+            header: op(section.header),\n+            body: op(section.body)\n+        }\n     }\n }\n \n@@ -79,21 +67,6 @@ fn fold_enum(fold: fold::fold<op>, doc: doc::enumdoc) -> doc::enumdoc {\n     }\n }\n \n-fn fold_res(fold: fold::fold<op>, doc: doc::resdoc) -> doc::resdoc {\n-    let fold_ctxt = fold.ctxt;\n-    let doc = fold::default_seq_fold_res(fold, doc);\n-\n-    {\n-        args: par::anymap(doc.args) {|arg|\n-            {\n-                desc: maybe_apply_op(fold_ctxt, arg.desc)\n-                with arg\n-            }\n-        }\n-        with doc\n-    }\n-}\n-\n fn fold_iface(fold: fold::fold<op>, doc: doc::ifacedoc) -> doc::ifacedoc {\n     let doc = fold::default_seq_fold_iface(fold, doc);\n \n@@ -108,17 +81,7 @@ fn apply_to_methods(op: op, docs: [doc::methoddoc]) -> [doc::methoddoc] {\n         {\n             brief: maybe_apply_op(op, doc.brief),\n             desc: maybe_apply_op(op, doc.desc),\n-            args: par::anymap(doc.args) {|doc|\n-                {\n-                    desc: maybe_apply_op(op, doc.desc)\n-                    with doc\n-                }\n-            },\n-            return: {\n-                desc: maybe_apply_op(op, doc.return.desc)\n-                with doc.return\n-            },\n-            failure: maybe_apply_op(op, doc.failure)\n+            sections: apply_to_sections(op, doc.sections)\n             with doc\n         }\n     }\n@@ -135,13 +98,13 @@ fn fold_impl(fold: fold::fold<op>, doc: doc::impldoc) -> doc::impldoc {\n \n #[test]\n fn should_execute_op_on_enum_brief() {\n-    let doc = test::mk_doc(\"#[doc(brief = \\\" a \\\")] enum a { b }\");\n+    let doc = test::mk_doc(\"#[doc = \\\" a \\\"] enum a { b }\");\n     assert doc.cratemod().enums()[0].brief() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_enum_desc() {\n-    let doc = test::mk_doc(\"#[doc(desc = \\\" a \\\")] enum a { b }\");\n+    let doc = test::mk_doc(\"#[doc = \\\" a \\\"] enum a { b }\");\n     assert doc.cratemod().enums()[0].desc() == some(\"a\");\n }\n \n@@ -153,133 +116,150 @@ fn should_execute_op_on_variant_desc() {\n \n #[test]\n fn should_execute_op_on_resource_brief() {\n-    let doc = test::mk_doc(\"#[doc(brief = \\\" a \\\")] resource r(a: bool) { }\");\n+    let doc = test::mk_doc(\"#[doc = \\\" a \\\"] resource r(a: bool) { }\");\n     assert doc.cratemod().resources()[0].brief() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_desc() {\n-    let doc = test::mk_doc(\"#[doc(desc = \\\" a \\\")] resource r(a: bool) { }\");\n+    let doc = test::mk_doc(\"#[doc = \\\" a \\\"] resource r(a: bool) { }\");\n     assert doc.cratemod().resources()[0].desc() == some(\"a\");\n }\n \n-#[test]\n-fn should_execute_op_on_resource_args() {\n-    let doc = test::mk_doc(\n-        \"#[doc(args(a = \\\" a \\\"))] resource r(a: bool) { }\");\n-    assert doc.cratemod().resources()[0].args[0].desc == some(\"a\");\n-}\n-\n #[test]\n fn should_execute_op_on_iface_brief() {\n     let doc = test::mk_doc(\n-        \"#[doc(brief = \\\" a \\\")] iface i { fn a(); }\");\n+        \"#[doc = \\\" a \\\"] iface i { fn a(); }\");\n     assert doc.cratemod().ifaces()[0].brief() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_desc() {\n     let doc = test::mk_doc(\n-        \"#[doc(desc = \\\" a \\\")] iface i { fn a(); }\");\n+        \"#[doc = \\\" a \\\"] iface i { fn a(); }\");\n     assert doc.cratemod().ifaces()[0].desc() == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_brief() {\n     let doc = test::mk_doc(\n-        \"iface i { #[doc(brief = \\\" a \\\")] fn a(); }\");\n+        \"iface i { #[doc = \\\" a \\\"] fn a(); }\");\n     assert doc.cratemod().ifaces()[0].methods[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_desc() {\n     let doc = test::mk_doc(\n-        \"iface i { #[doc(desc = \\\" a \\\")] fn a(); }\");\n+        \"iface i { #[doc = \\\" a \\\"] fn a(); }\");\n     assert doc.cratemod().ifaces()[0].methods[0].desc == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_iface_method_args() {\n+fn should_execute_op_on_impl_brief() {\n     let doc = test::mk_doc(\n-        \"iface i { #[doc(args(a = \\\" a \\\"))] fn a(a: bool); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].args[0].desc == some(\"a\");\n+        \"#[doc = \\\" a \\\"] impl i for int { fn a() { } }\");\n+    assert doc.cratemod().impls()[0].brief() == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_iface_method_return() {\n+fn should_execute_op_on_impl_desc() {\n     let doc = test::mk_doc(\n-        \"iface i { #[doc(return = \\\" a \\\")] fn a() -> int; }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].return.desc == some(\"a\");\n+        \"#[doc = \\\" a \\\"] impl i for int { fn a() { } }\");\n+    assert doc.cratemod().impls()[0].desc() == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_iface_method_failure_condition() {\n-    let doc = test::mk_doc(\"iface i { #[doc(failure = \\\" a \\\")] fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].failure == some(\"a\");\n+fn should_execute_op_on_impl_method_brief() {\n+    let doc = test::mk_doc(\n+        \"impl i for int { #[doc = \\\" a \\\"] fn a() { } }\");\n+    assert doc.cratemod().impls()[0].methods[0].brief == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_impl_brief() {\n+fn should_execute_op_on_impl_method_desc() {\n     let doc = test::mk_doc(\n-        \"#[doc(brief = \\\" a \\\")] impl i for int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].brief() == some(\"a\");\n+        \"impl i for int { #[doc = \\\" a \\\"] fn a() { } }\");\n+    assert doc.cratemod().impls()[0].methods[0].desc == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_impl_desc() {\n+fn should_execute_op_on_type_brief() {\n     let doc = test::mk_doc(\n-        \"#[doc(desc = \\\" a \\\")] impl i for int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].desc() == some(\"a\");\n+        \"#[doc = \\\" a \\\"] type t = int;\");\n+    assert doc.cratemod().types()[0].brief() == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_impl_method_brief() {\n+fn should_execute_op_on_type_desc() {\n     let doc = test::mk_doc(\n-        \"impl i for int { #[doc(brief = \\\" a \\\")] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].brief == some(\"a\");\n+        \"#[doc = \\\" a \\\"] type t = int;\");\n+    assert doc.cratemod().types()[0].desc() == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_impl_method_desc() {\n+fn should_execute_on_item_section_headers() {\n     let doc = test::mk_doc(\n-        \"impl i for int { #[doc(desc = \\\" a \\\")] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].desc == some(\"a\");\n+        \"#[doc = \\\"\\\n+         #    Header    \\n\\\n+         Body\\\"]\\\n+         fn a() { }\");\n+    assert doc.cratemod().fns()[0].sections()[0].header == \"Header\";\n }\n \n #[test]\n-fn should_execute_op_on_impl_method_args() {\n+fn should_execute_on_item_section_bodies() {\n     let doc = test::mk_doc(\n-        \"impl i for int { #[doc(args(a = \\\" a \\\"))] fn a(a: bool) { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].args[0].desc == some(\"a\");\n+        \"#[doc = \\\"\\\n+         # Header\\n\\\n+         Body      \\\"]\\\n+         fn a() { }\");\n+    assert doc.cratemod().fns()[0].sections()[0].body == \"Body\";\n }\n \n #[test]\n-fn should_execute_op_on_impl_method_return() {\n+fn should_execute_on_iface_method_section_headers() {\n     let doc = test::mk_doc(\n-        \"impl i for int { #[doc(return = \\\" a \\\")] fn a() -> int { fail } }\");\n-    assert doc.cratemod().impls()[0].methods[0].return.desc == some(\"a\");\n+        \"iface i {\n+         #[doc = \\\"\\\n+         # Header    \\n\\\n+         Body\\\"]\\\n+         fn a(); }\");\n+    assert doc.cratemod().ifaces()[0].methods[0].sections[0].header\n+        == \"Header\";\n }\n \n #[test]\n-fn should_execute_op_on_impl_method_failure_condition() {\n+fn should_execute_on_iface_method_section_bodies() {\n     let doc = test::mk_doc(\n-        \"impl i for int { #[doc(failure = \\\" a \\\")] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].failure == some(\"a\");\n+        \"iface i {\n+         #[doc = \\\"\\\n+         # Header\\n\\\n+         Body     \\\"]\\\n+         fn a(); }\");\n+    assert doc.cratemod().ifaces()[0].methods[0].sections[0].body == \"Body\";\n }\n \n-\n #[test]\n-fn should_execute_op_on_type_brief() {\n+fn should_execute_on_impl_method_section_headers() {\n     let doc = test::mk_doc(\n-        \"#[doc(brief = \\\" a \\\")] type t = int;\");\n-    assert doc.cratemod().types()[0].brief() == some(\"a\");\n+        \"impl i for bool {\n+         #[doc = \\\"\\\n+         # Header   \\n\\\n+         Body\\\"]\\\n+         fn a() { } }\");\n+    assert doc.cratemod().impls()[0].methods[0].sections[0].header\n+        == \"Header\";\n }\n \n #[test]\n-fn should_execute_op_on_type_desc() {\n+fn should_execute_on_impl_method_section_bodies() {\n     let doc = test::mk_doc(\n-        \"#[doc(desc = \\\" a \\\")] type t = int;\");\n-    assert doc.cratemod().types()[0].desc() == some(\"a\");\n+        \"impl i for bool {\n+         #[doc = \\\"\\\n+         # Header\\n\\\n+         Body    \\\"]\\\n+         fn a() { } }\");\n+    assert doc.cratemod().impls()[0].methods[0].sections[0].body == \"Body\";\n }\n \n #[cfg(test)]\n@@ -288,6 +268,8 @@ mod test {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);\n+            let doc = desc_to_brief_pass::mk_pass().f(srv, doc);\n+            let doc = sectionalize_pass::mk_pass().f(srv, doc);\n             mk_pass(\"\", {|s| str::trim(s)}).f(srv, doc)\n         }\n     }"}, {"sha": "c0e9560ea02ce986039c53d5165693bb54c0a368", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -14,50 +14,12 @@ fn mk_pass() -> pass {\n }\n \n #[test]\n-fn should_trim_mod() {\n-    let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n-                            desc = \\\"\\ndesc\\n\\\")] \\\n+fn should_trim_text() {\n+    let doc = test::mk_doc(\"#[doc = \\\" desc \\\"] \\\n                             mod m { }\");\n-    assert doc.cratemod().mods()[0].brief() == some(\"brief\");\n     assert doc.cratemod().mods()[0].desc() == some(\"desc\");\n }\n \n-#[test]\n-fn should_trim_const() {\n-    let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n-                            desc = \\\"\\ndesc\\n\\\")] \\\n-                            const a: bool = true;\");\n-    assert doc.cratemod().consts()[0].brief() == some(\"brief\");\n-    assert doc.cratemod().consts()[0].desc() == some(\"desc\");\n-}\n-\n-#[test]\n-fn should_trim_fn() {\n-    let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n-                            desc = \\\"\\ndesc\\n\\\")] \\\n-                            fn a() { }\");\n-    assert doc.cratemod().fns()[0].brief() == some(\"brief\");\n-    assert doc.cratemod().fns()[0].desc() == some(\"desc\");\n-}\n-\n-#[test]\n-fn should_trim_args() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"\\na\\n\\\"))] fn a(a: int) { }\");\n-    assert doc.cratemod().fns()[0].args[0].desc == some(\"a\");\n-}\n-\n-#[test]\n-fn should_trim_ret() {\n-    let doc = test::mk_doc(\"#[doc(return = \\\"\\na\\n\\\")] fn a() -> int { }\");\n-    assert doc.cratemod().fns()[0].return.desc == some(\"a\");\n-}\n-\n-#[test]\n-fn should_trim_failure_conditions() {\n-    let doc = test::mk_doc(\"#[doc(failure = \\\"\\na\\n\\\")] fn a() -> int { }\");\n-    assert doc.cratemod().fns()[0].failure == some(\"a\");\n-}\n-\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {"}, {"sha": "949d3f7e65d30f9665225a7ccef57df81050ef04", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0521971b1b9a3203c250591991092a445b50586/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=a0521971b1b9a3203c250591991092a445b50586", "patch": "@@ -81,7 +81,7 @@ fn fold_const(\n     let srv = fold.ctxt;\n \n     {\n-        ty: some(astsrv::exec(srv) {|ctxt|\n+        sig: some(astsrv::exec(srv) {|ctxt|\n             alt check ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@{\n                 node: ast::item_const(ty, _), _\n@@ -97,7 +97,7 @@ fn fold_const(\n #[test]\n fn should_add_const_types() {\n     let doc = test::mk_doc(\"const a: bool = true;\");\n-    assert doc.cratemod().consts()[0].ty == some(\"bool\");\n+    assert doc.cratemod().consts()[0].sig == some(\"bool\");\n }\n \n fn fold_enum("}]}