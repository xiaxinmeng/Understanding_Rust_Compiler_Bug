{"sha": "dbc9913b7d0e4521430ef19862652df22c9e76c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzk5MTNiN2QwZTQ1MjE0MzBlZjE5ODYyNjUyZGYyMmM5ZTc2Yzc=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-19T05:03:46Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-19T05:03:46Z"}, "message": "Implement pointer primvals and comparison ops on them.", "tree": {"sha": "a33e329a1c053fb0d19b97e6d4fa616ff3812df6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a33e329a1c053fb0d19b97e6d4fa616ff3812df6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc9913b7d0e4521430ef19862652df22c9e76c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9913b7d0e4521430ef19862652df22c9e76c7", "html_url": "https://github.com/rust-lang/rust/commit/dbc9913b7d0e4521430ef19862652df22c9e76c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9913b7d0e4521430ef19862652df22c9e76c7/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81f49ed1c0c42ae2d404e4283147ea5d63ac6b17", "url": "https://api.github.com/repos/rust-lang/rust/commits/81f49ed1c0c42ae2d404e4283147ea5d63ac6b17", "html_url": "https://github.com/rust-lang/rust/commit/81f49ed1c0c42ae2d404e4283147ea5d63ac6b17"}], "stats": {"total": 160, "additions": 116, "deletions": 44}, "files": [{"sha": "f16bdc3b6b3c8400bf638992cedf50ba47f70a4a", "filename": "src/error.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dbc9913b7d0e4521430ef19862652df22c9e76c7/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc9913b7d0e4521430ef19862652df22c9e76c7/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=dbc9913b7d0e4521430ef19862652df22c9e76c7", "patch": "@@ -6,8 +6,9 @@ pub enum EvalError {\n     DanglingPointerDeref,\n     InvalidBool,\n     PointerOutOfBounds,\n-    InvalidPointerAccess,\n+    ReadPointerAsBytes,\n     ReadBytesAsPointer,\n+    InvalidPointerMath,\n }\n \n pub type EvalResult<T> = Result<T, EvalError>;\n@@ -18,10 +19,12 @@ impl Error for EvalError {\n             EvalError::DanglingPointerDeref => \"dangling pointer was dereferenced\",\n             EvalError::InvalidBool => \"invalid boolean value read\",\n             EvalError::PointerOutOfBounds => \"pointer offset outside bounds of allocation\",\n-            EvalError::InvalidPointerAccess =>\n-                \"a raw memory access tried to access part of a pointer value as bytes\",\n+            EvalError::ReadPointerAsBytes =>\n+                \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             EvalError::ReadBytesAsPointer =>\n-                \"attempted to read some raw bytes as a pointer address\",\n+                \"attempted to interpret some raw bytes as a pointer address\",\n+            EvalError::InvalidPointerMath =>\n+                \"attempted to do math or a comparison on pointers into different allocations\",\n         }\n     }\n "}, {"sha": "fe4217ca9aa7e97f82040d620263b9680ae0d778", "filename": "src/interpreter.rs", "status": "modified", "additions": 52, "deletions": 7, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dbc9913b7d0e4521430ef19862652df22c9e76c7/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc9913b7d0e4521430ef19862652df22c9e76c7/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=dbc9913b7d0e4521430ef19862652df22c9e76c7", "patch": "@@ -16,9 +16,9 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n \n-use error::EvalResult;\n+use error::{EvalError, EvalResult};\n use memory::{self, FieldRepr, Memory, Pointer, Repr};\n-use primval;\n+use primval::{self, PrimVal};\n \n const TRACE_EXECUTION: bool = true;\n \n@@ -404,19 +404,20 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             BinaryOp(bin_op, ref left, ref right) => {\n                 let left_ptr = try!(self.eval_operand(left));\n                 let left_ty = self.operand_ty(left);\n-                let left_val = try!(self.memory.read_primval(left_ptr, left_ty));\n+                let left_val = try!(self.read_primval(left_ptr, left_ty));\n \n                 let right_ptr = try!(self.eval_operand(right));\n                 let right_ty = self.operand_ty(right);\n-                let right_val = try!(self.memory.read_primval(right_ptr, right_ty));\n+                let right_val = try!(self.read_primval(right_ptr, right_ty));\n \n-                self.memory.write_primval(dest, primval::binary_op(bin_op, left_val, right_val))\n+                let val = try!(primval::binary_op(bin_op, left_val, right_val));\n+                self.memory.write_primval(dest, val)\n             }\n \n             UnaryOp(un_op, ref operand) => {\n                 let ptr = try!(self.eval_operand(operand));\n                 let ty = self.operand_ty(operand);\n-                let val = try!(self.memory.read_primval(ptr, ty));\n+                let val = try!(self.read_primval(ptr, ty));\n                 self.memory.write_primval(dest, primval::unary_op(un_op, val))\n             }\n \n@@ -627,6 +628,10 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         infer::normalize_associated_type(self.tcx, &substituted)\n     }\n \n+    fn type_is_sized(&self, ty: ty::Ty<'tcx>) -> bool {\n+        ty.is_sized(&self.tcx.empty_parameter_environment(), DUMMY_SP)\n+    }\n+\n     fn ty_size(&self, ty: ty::Ty<'tcx>) -> usize {\n         self.ty_to_repr(ty).size()\n     }\n@@ -671,7 +676,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n             ty::TyBox(ty) => {\n-                if ty.is_sized(&self.tcx.empty_parameter_environment(), DUMMY_SP) {\n+                if self.type_is_sized(ty) {\n                     Repr::Primitive { size: self.memory.pointer_size }\n                 } else {\n                     Repr::Primitive { size: self.memory.pointer_size * 2 }\n@@ -725,6 +730,46 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n     }\n \n+    pub fn read_primval(&mut self, ptr: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<PrimVal> {\n+        use syntax::ast::{IntTy, UintTy};\n+        let val = match ty.sty {\n+            ty::TyBool              => PrimVal::Bool(try!(self.memory.read_bool(ptr))),\n+            ty::TyInt(IntTy::I8)    => PrimVal::I8(try!(self.memory.read_int(ptr, 1)) as i8),\n+            ty::TyInt(IntTy::I16)   => PrimVal::I16(try!(self.memory.read_int(ptr, 2)) as i16),\n+            ty::TyInt(IntTy::I32)   => PrimVal::I32(try!(self.memory.read_int(ptr, 4)) as i32),\n+            ty::TyInt(IntTy::I64)   => PrimVal::I64(try!(self.memory.read_int(ptr, 8)) as i64),\n+            ty::TyUint(UintTy::U8)  => PrimVal::U8(try!(self.memory.read_uint(ptr, 1)) as u8),\n+            ty::TyUint(UintTy::U16) => PrimVal::U16(try!(self.memory.read_uint(ptr, 2)) as u16),\n+            ty::TyUint(UintTy::U32) => PrimVal::U32(try!(self.memory.read_uint(ptr, 4)) as u32),\n+            ty::TyUint(UintTy::U64) => PrimVal::U64(try!(self.memory.read_uint(ptr, 8)) as u64),\n+\n+            // TODO(tsion): Pick the PrimVal dynamically.\n+            ty::TyInt(IntTy::Is) =>\n+                PrimVal::I64(try!(self.memory.read_int(ptr, self.memory.pointer_size))),\n+            ty::TyUint(UintTy::Us) =>\n+                PrimVal::U64(try!(self.memory.read_uint(ptr, self.memory.pointer_size))),\n+\n+            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                if self.type_is_sized(ty) {\n+                    match self.memory.read_ptr(ptr) {\n+                        Ok(p) => PrimVal::AbstractPtr(p),\n+                        Err(EvalError::ReadBytesAsPointer) => {\n+                            let n = try!(self.memory.read_uint(ptr, self.memory.pointer_size));\n+                            PrimVal::IntegerPtr(n)\n+                        }\n+                        Err(e) => return Err(e),\n+                    }\n+                } else {\n+                    panic!(\"unimplemented: primitive read of fat pointer type: {:?}\", ty);\n+                }\n+            }\n+\n+            _ => panic!(\"primitive read of non-primitive type: {:?}\", ty),\n+        };\n+        Ok(val)\n+    }\n+\n     fn current_frame(&self) -> &Frame<'a, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }"}, {"sha": "1690ea8dc0b05a1368bdff536ffc4be5adbeea5c", "filename": "src/memory.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dbc9913b7d0e4521430ef19862652df22c9e76c7/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc9913b7d0e4521430ef19862652df22c9e76c7/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=dbc9913b7d0e4521430ef19862652df22c9e76c7", "patch": "@@ -1,5 +1,4 @@\n use byteorder::{self, ByteOrder, NativeEndian, ReadBytesExt, WriteBytesExt};\n-use rustc::middle::ty;\n use std::collections::{BTreeMap, HashMap};\n use std::collections::Bound::{Included, Excluded};\n use std::mem;\n@@ -169,26 +168,6 @@ impl Memory {\n         Ok(())\n     }\n \n-    pub fn read_primval(&self, ptr: Pointer, ty: ty::Ty) -> EvalResult<PrimVal> {\n-        use syntax::ast::{IntTy, UintTy};\n-        match ty.sty {\n-            ty::TyBool              => self.read_bool(ptr).map(PrimVal::Bool),\n-            ty::TyInt(IntTy::I8)    => self.read_int(ptr, 1).map(|n| PrimVal::I8(n as i8)),\n-            ty::TyInt(IntTy::I16)   => self.read_int(ptr, 2).map(|n| PrimVal::I16(n as i16)),\n-            ty::TyInt(IntTy::I32)   => self.read_int(ptr, 4).map(|n| PrimVal::I32(n as i32)),\n-            ty::TyInt(IntTy::I64)   => self.read_int(ptr, 8).map(|n| PrimVal::I64(n as i64)),\n-            ty::TyUint(UintTy::U8)  => self.read_uint(ptr, 1).map(|n| PrimVal::U8(n as u8)),\n-            ty::TyUint(UintTy::U16) => self.read_uint(ptr, 2).map(|n| PrimVal::U16(n as u16)),\n-            ty::TyUint(UintTy::U32) => self.read_uint(ptr, 4).map(|n| PrimVal::U32(n as u32)),\n-            ty::TyUint(UintTy::U64) => self.read_uint(ptr, 8).map(|n| PrimVal::U64(n as u64)),\n-\n-            // TODO(tsion): Pick the PrimVal dynamically.\n-            ty::TyInt(IntTy::Is)    => self.read_int(ptr, self.pointer_size).map(PrimVal::I64),\n-            ty::TyUint(UintTy::Us)  => self.read_uint(ptr, self.pointer_size).map(PrimVal::U64),\n-            _ => panic!(\"primitive read of non-primitive type: {:?}\", ty),\n-        }\n-    }\n-\n     pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<()> {\n         match val {\n             PrimVal::Bool(b) => self.write_bool(ptr, b),\n@@ -199,7 +178,8 @@ impl Memory {\n             PrimVal::U8(n)   => self.write_uint(ptr, n as u64, 1),\n             PrimVal::U16(n)  => self.write_uint(ptr, n as u64, 2),\n             PrimVal::U32(n)  => self.write_uint(ptr, n as u64, 4),\n-            PrimVal::U64(n)  => self.write_uint(ptr, n as u64, 8),\n+            PrimVal::U64(n) | PrimVal::IntegerPtr(n) => self.write_uint(ptr, n as u64, 8),\n+            PrimVal::AbstractPtr(_p) => unimplemented!(),\n         }\n     }\n \n@@ -258,7 +238,7 @@ impl Allocation {\n         if n == 0 {\n             Ok(())\n         } else {\n-            Err(EvalError::InvalidPointerAccess)\n+            Err(EvalError::ReadPointerAsBytes)\n         }\n     }\n \n@@ -267,7 +247,7 @@ impl Allocation {\n         if self.count_overlapping_relocations(start, end) == 0 {\n             Ok(())\n         } else {\n-            Err(EvalError::InvalidPointerAccess)\n+            Err(EvalError::ReadPointerAsBytes)\n         }\n     }\n }"}, {"sha": "c9117d033fdd5c584c11bf77d63f8eed1375f39e", "filename": "src/primval.rs", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dbc9913b7d0e4521430ef19862652df22c9e76c7/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc9913b7d0e4521430ef19862652df22c9e76c7/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=dbc9913b7d0e4521430ef19862652df22c9e76c7", "patch": "@@ -1,26 +1,32 @@\n use rustc::mir::repr as mir;\n \n+use error::{EvalError, EvalResult};\n+use memory::Pointer;\n+\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum PrimVal {\n     Bool(bool),\n     I8(i8), I16(i16), I32(i32), I64(i64),\n     U8(u8), U16(u16), U32(u32), U64(u64),\n+\n+    AbstractPtr(Pointer),\n+    IntegerPtr(u64),\n }\n \n-pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> PrimVal {\n+pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<PrimVal> {\n     macro_rules! int_binops {\n         ($v:ident, $l:ident, $r:ident) => ({\n             use rustc::mir::repr::BinOp::*;\n             use self::PrimVal::*;\n             match bin_op {\n-                Add => $v($l + $r),\n-                Sub => $v($l - $r),\n-                Mul => $v($l * $r),\n-                Div => $v($l / $r),\n-                Rem => $v($l % $r),\n+                Add    => $v($l + $r),\n+                Sub    => $v($l - $r),\n+                Mul    => $v($l * $r),\n+                Div    => $v($l / $r),\n+                Rem    => $v($l % $r),\n                 BitXor => $v($l ^ $r),\n                 BitAnd => $v($l & $r),\n-                BitOr => $v($l | $r),\n+                BitOr  => $v($l | $r),\n \n                 // TODO(tsion): Can have differently-typed RHS.\n                 Shl => $v($l << $r),\n@@ -36,8 +42,18 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> PrimVal {\n         })\n     }\n \n+    fn unrelated_ptr_ops(bin_op: mir::BinOp) -> EvalResult<PrimVal> {\n+        use rustc::mir::repr::BinOp::*;\n+        match bin_op {\n+            Eq => Ok(Bool(false)),\n+            Ne => Ok(Bool(true)),\n+            Lt | Le | Gt | Ge => Err(EvalError::InvalidPointerMath),\n+            _ => unimplemented!(),\n+        }\n+    }\n+\n     use self::PrimVal::*;\n-    match (left, right) {\n+    let val = match (left, right) {\n         (I8(l),  I8(r))  => int_binops!(I8, l, r),\n         (I16(l), I16(r)) => int_binops!(I16, l, r),\n         (I32(l), I32(r)) => int_binops!(I32, l, r),\n@@ -46,8 +62,36 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> PrimVal {\n         (U16(l), U16(r)) => int_binops!(U16, l, r),\n         (U32(l), U32(r)) => int_binops!(U32, l, r),\n         (U64(l), U64(r)) => int_binops!(U64, l, r),\n+\n+        (IntegerPtr(l), IntegerPtr(r)) => int_binops!(IntegerPtr, l, r),\n+\n+        (AbstractPtr(_), IntegerPtr(_)) | (IntegerPtr(_), AbstractPtr(_)) =>\n+            return unrelated_ptr_ops(bin_op),\n+\n+        (AbstractPtr(l_ptr), AbstractPtr(r_ptr)) => {\n+            if l_ptr.alloc_id != r_ptr.alloc_id {\n+                return unrelated_ptr_ops(bin_op);\n+            }\n+\n+            let l = l_ptr.offset;\n+            let r = r_ptr.offset;\n+\n+            use rustc::mir::repr::BinOp::*;\n+            match bin_op {\n+                Eq => Bool(l == r),\n+                Ne => Bool(l != r),\n+                Lt => Bool(l < r),\n+                Le => Bool(l <= r),\n+                Gt => Bool(l > r),\n+                Ge => Bool(l >= r),\n+                _ => unimplemented!(),\n+            }\n+        }\n+\n         _ => unimplemented!(),\n-    }\n+    };\n+\n+    Ok(val)\n }\n \n pub fn unary_op(un_op: mir::UnOp, val: PrimVal) -> PrimVal {"}]}