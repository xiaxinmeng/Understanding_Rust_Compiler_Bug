{"sha": "456f4e8d22dfa18de1fc0bafb4455a6b27f92aea", "node_id": "C_kwDOAAsO6NoAKDQ1NmY0ZThkMjJkZmExOGRlMWZjMGJhZmI0NDU1YTZiMjdmOTJhZWE", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-09-15T16:46:40Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-09-26T11:10:55Z"}, "message": "don't duplicate late-bound region names in print of Binder", "tree": {"sha": "6ccec8e8b267e3e1237276e2db20895760606fff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ccec8e8b267e3e1237276e2db20895760606fff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/456f4e8d22dfa18de1fc0bafb4455a6b27f92aea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/456f4e8d22dfa18de1fc0bafb4455a6b27f92aea", "html_url": "https://github.com/rust-lang/rust/commit/456f4e8d22dfa18de1fc0bafb4455a6b27f92aea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/456f4e8d22dfa18de1fc0bafb4455a6b27f92aea/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f4923979979abb5d6b975353e9b3053d257e60", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f4923979979abb5d6b975353e9b3053d257e60", "html_url": "https://github.com/rust-lang/rust/commit/72f4923979979abb5d6b975353e9b3053d257e60"}], "stats": {"total": 108, "additions": 81, "deletions": 27}, "files": [{"sha": "da964077285f41aef39a2e4e7d4e4bd7be5e99ec", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/456f4e8d22dfa18de1fc0bafb4455a6b27f92aea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456f4e8d22dfa18de1fc0bafb4455a6b27f92aea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=456f4e8d22dfa18de1fc0bafb4455a6b27f92aea", "patch": "@@ -1562,7 +1562,9 @@ pub struct FmtPrinterData<'a, 'tcx> {\n     in_value: bool,\n     pub print_alloc_ids: bool,\n \n+    // set of all named (non-anonymous) region names\n     used_region_names: FxHashSet<Symbol>,\n+\n     region_index: usize,\n     binder_depth: usize,\n     printed_type_count: usize,\n@@ -2118,23 +2120,31 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n     where\n         T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n     {\n-        fn name_by_region_index(index: usize) -> Symbol {\n-            match index {\n-                0 => Symbol::intern(\"'r\"),\n-                1 => Symbol::intern(\"'s\"),\n-                i => Symbol::intern(&format!(\"'t{}\", i - 2)),\n+        fn name_by_region_index(\n+            index: usize,\n+            available_names: &mut Vec<Symbol>,\n+            num_available: usize,\n+        ) -> Symbol {\n+            if let Some(name) = available_names.pop() {\n+                name\n+            } else {\n+                Symbol::intern(&format!(\"'t{}\", index - num_available))\n             }\n         }\n \n+        debug!(\"name_all_regions\");\n+\n         // Replace any anonymous late-bound regions with named\n         // variants, using new unique identifiers, so that we can\n         // clearly differentiate between named and unnamed regions in\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give.\n         if self.binder_depth == 0 {\n-            self.prepare_late_bound_region_info(value);\n+            self.prepare_region_info(value);\n         }\n \n+        debug!(\"self.used_region_names: {:?}\", &self.used_region_names);\n+\n         let mut empty = true;\n         let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n             let w = if empty {\n@@ -2151,13 +2161,23 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n \n         define_scoped_cx!(self);\n \n+        let possible_names = vec![Symbol::intern(\"'t\"), Symbol::intern(\"'s\"), Symbol::intern(\"'r\")];\n+\n+        let mut available_names = possible_names\n+            .into_iter()\n+            .filter(|name| !self.used_region_names.contains(&name))\n+            .collect::<Vec<_>>();\n+        debug!(?available_names);\n+        let num_available = available_names.len();\n+\n         let mut region_index = self.region_index;\n-        let mut next_name = |this: &Self| loop {\n-            let name = name_by_region_index(region_index);\n+        let mut next_name = |this: &Self| {\n+            let name = name_by_region_index(region_index, &mut available_names, num_available);\n+            debug!(?name);\n             region_index += 1;\n-            if !this.used_region_names.contains(&name) {\n-                break name;\n-            }\n+            assert!(!this.used_region_names.contains(&name));\n+\n+            name\n         };\n \n         // If we want to print verbosely, then print *all* binders, even if they\n@@ -2178,6 +2198,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                         ty::BrAnon(_) | ty::BrEnv => {\n                             start_or_continue(&mut self, \"for<\", \", \");\n                             let name = next_name(&self);\n+                            debug!(?name);\n                             do_continue(&mut self, name);\n                             ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n                         }\n@@ -2271,29 +2292,37 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         Ok(inner)\n     }\n \n-    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<'tcx, T>)\n+    fn prepare_region_info<T>(&mut self, value: &ty::Binder<'tcx, T>)\n     where\n         T: TypeVisitable<'tcx>,\n     {\n-        struct LateBoundRegionNameCollector<'a, 'tcx> {\n-            used_region_names: &'a mut FxHashSet<Symbol>,\n+        struct RegionNameCollector<'tcx> {\n+            used_region_names: FxHashSet<Symbol>,\n             type_collector: SsoHashSet<Ty<'tcx>>,\n         }\n \n-        impl<'tcx> ty::visit::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_, 'tcx> {\n+        impl<'tcx> RegionNameCollector<'tcx> {\n+            fn new() -> Self {\n+                RegionNameCollector {\n+                    used_region_names: Default::default(),\n+                    type_collector: SsoHashSet::new(),\n+                }\n+            }\n+        }\n+\n+        impl<'tcx> ty::visit::TypeVisitor<'tcx> for RegionNameCollector<'tcx> {\n             type BreakTy = ();\n \n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 trace!(\"address: {:p}\", r.0.0);\n-                if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) = *r {\n-                    self.used_region_names.insert(name);\n-                } else if let ty::RePlaceholder(ty::PlaceholderRegion {\n-                    name: ty::BrNamed(_, name),\n-                    ..\n-                }) = *r\n-                {\n+\n+                // Collect all named lifetimes. These allow us to prevent duplication\n+                // of already existing lifetime names when introducing names for\n+                // anonymous late-bound regions.\n+                if let Some(name) = r.get_name() {\n                     self.used_region_names.insert(name);\n                 }\n+\n                 r.super_visit_with(self)\n             }\n \n@@ -2309,12 +2338,9 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n             }\n         }\n \n-        self.used_region_names.clear();\n-        let mut collector = LateBoundRegionNameCollector {\n-            used_region_names: &mut self.used_region_names,\n-            type_collector: SsoHashSet::new(),\n-        };\n+        let mut collector = RegionNameCollector::new();\n         value.visit_with(&mut collector);\n+        self.used_region_names = collector.used_region_names;\n         self.region_index = 0;\n     }\n }"}, {"sha": "08fb6a329dffa7f72bfedb13a713fd1df9f2eea5", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/456f4e8d22dfa18de1fc0bafb4455a6b27f92aea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456f4e8d22dfa18de1fc0bafb4455a6b27f92aea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=456f4e8d22dfa18de1fc0bafb4455a6b27f92aea", "patch": "@@ -85,6 +85,17 @@ impl BoundRegionKind {\n             _ => false,\n         }\n     }\n+\n+    pub fn get_name(&self) -> Option<Symbol> {\n+        if self.is_named() {\n+            match *self {\n+                BoundRegionKind::BrNamed(_, name) => return Some(name),\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n pub trait Article {\n@@ -1445,6 +1456,23 @@ impl<'tcx> Region<'tcx> {\n         *self.0.0\n     }\n \n+    pub fn get_name(self) -> Option<Symbol> {\n+        if self.has_name() {\n+            let name = match *self {\n+                ty::ReEarlyBound(ebr) => Some(ebr.name),\n+                ty::ReLateBound(_, br) => br.kind.get_name(),\n+                ty::ReFree(fr) => fr.bound_region.get_name(),\n+                ty::ReStatic => Some(Symbol::intern(\"static\")),\n+                ty::RePlaceholder(placeholder) => placeholder.name.get_name(),\n+                _ => None,\n+            };\n+\n+            return name;\n+        }\n+\n+        None\n+    }\n+\n     /// Is this region named by the user?\n     pub fn has_name(self) -> bool {\n         match *self {"}]}