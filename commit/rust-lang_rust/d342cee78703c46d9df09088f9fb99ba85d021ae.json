{"sha": "d342cee78703c46d9df09088f9fb99ba85d021ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNDJjZWU3ODcwM2M0NmQ5ZGYwOTA4OGY5ZmI5OWJhODVkMDIxYWU=", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2020-04-07T20:40:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-07T20:40:18Z"}, "message": "Merge pull request #5434 from eddyb/rustup\n\nrustup: update for the new Ty::walk interface.\r\n\r\nThe first commit fixes a portability bug in `setup-toolchain.sh`, while the second rewrites the handling of \"trait impl methods\" in `use_self` - even if `Ty::walk` could've still been used, it was IMO a misuse.\r\n\r\nThis could also serve as a PSA: *please* use `hir_ty_to_ty` instead of trying to compare `hir::Ty`s between themselves or against semantic `Ty`s. Its \"quasi-deprecation\" is 3 years old and doesn't really mean anything, just that it's currently uncached and that we should eventually querify it (either for a single HIR node, or for all of the nodes in an entire definition).\r\n\r\n---\r\n\r\nchangelog: none", "tree": {"sha": "eef5f1d93b725bc7cf40d661e9c4f4cf2e2e7e59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eef5f1d93b725bc7cf40d661e9c4f4cf2e2e7e59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d342cee78703c46d9df09088f9fb99ba85d021ae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejOUyCRBK7hj4Ov3rIwAAdHIIACVBgUwZPD6YSig2VZJUypuz\nK0PqiqgER3r2pLKxZO25Ei77UH/6dSzQl8YK5NCAkfj3rHWMmvOJykGfiiId+hrF\nH7XEQQYXSUQARC1XniPSY5pO9hnR93wBu6G4RVq5PZenLskHJzt9Wm/6JCt+IFNC\npfPoNUzu1exypoHjKrGjic+34iafpCA06gMkfZp/86V1+EmIPXIRc3W5DYe+L8ZG\nZ5pVYQGDGcQodppm5x5UnGht4NLkbyuUewreWpCtZgiIJZsIeX3QUDUPCrahxrg+\nH6iGhMD+CFrqVRSBsP49P0ti3zYdarGiyOM8fnobXGpa/NWkjfqpQSbom6mfKh4=\n=9ICt\n-----END PGP SIGNATURE-----\n", "payload": "tree eef5f1d93b725bc7cf40d661e9c4f4cf2e2e7e59\nparent 7907abea272bbf97812683ce03a1ab9c22f0557b\nparent f5b6a0c54da3c9f94ccd53fae77dbf58fa16e680\nauthor Philipp Krones <hello@philkrones.com> 1586292018 +0200\ncommitter GitHub <noreply@github.com> 1586292018 +0200\n\nMerge pull request #5434 from eddyb/rustup\n\nrustup: update for the new Ty::walk interface.\r\n\r\nThe first commit fixes a portability bug in `setup-toolchain.sh`, while the second rewrites the handling of \"trait impl methods\" in `use_self` - even if `Ty::walk` could've still been used, it was IMO a misuse.\r\n\r\nThis could also serve as a PSA: *please* use `hir_ty_to_ty` instead of trying to compare `hir::Ty`s between themselves or against semantic `Ty`s. Its \"quasi-deprecation\" is 3 years old and doesn't really mean anything, just that it's currently uncached and that we should eventually querify it (either for a single HIR node, or for all of the nodes in an entire definition).\r\n\r\n---\r\n\r\nchangelog: none"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d342cee78703c46d9df09088f9fb99ba85d021ae", "html_url": "https://github.com/rust-lang/rust/commit/d342cee78703c46d9df09088f9fb99ba85d021ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d342cee78703c46d9df09088f9fb99ba85d021ae/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7907abea272bbf97812683ce03a1ab9c22f0557b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7907abea272bbf97812683ce03a1ab9c22f0557b", "html_url": "https://github.com/rust-lang/rust/commit/7907abea272bbf97812683ce03a1ab9c22f0557b"}, {"sha": "f5b6a0c54da3c9f94ccd53fae77dbf58fa16e680", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5b6a0c54da3c9f94ccd53fae77dbf58fa16e680", "html_url": "https://github.com/rust-lang/rust/commit/f5b6a0c54da3c9f94ccd53fae77dbf58fa16e680"}], "stats": {"total": 130, "additions": 68, "deletions": 62}, "files": [{"sha": "f8f84f3d42d02c8d1399daa8028c5858c7a4f986", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d342cee78703c46d9df09088f9fb99ba85d021ae/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d342cee78703c46d9df09088f9fb99ba85d021ae/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=d342cee78703c46d9df09088f9fb99ba85d021ae", "patch": "@@ -2,6 +2,7 @@ use if_chain::if_chain;\n use rustc_hir::{Local, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n use crate::utils::{is_must_use_func_call, is_must_use_ty, match_type, paths, span_lint_and_help};\n@@ -75,8 +76,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnderscore {\n             if let PatKind::Wild = local.pat.kind;\n             if let Some(ref init) = local.init;\n             then {\n-                let check_ty = |ty| SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, ty, path));\n-                if cx.tables.expr_ty(init).walk().any(check_ty) {\n+                let init_ty = cx.tables.expr_ty(init);\n+                let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n+                    GenericArgKind::Type(inner_ty) => {\n+                        SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n+                    },\n+\n+                    GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+                });\n+                if contains_sync_guard {\n                     span_lint_and_help(\n                         cx,\n                         LET_UNDERSCORE_LOCK,"}, {"sha": "124fc1d9878e80ef22b501941608eb5802c809de", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d342cee78703c46d9df09088f9fb99ba85d021ae/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d342cee78703c46d9df09088f9fb99ba85d021ae/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d342cee78703c46d9df09088f9fb99ba85d021ae", "patch": "@@ -15,6 +15,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Predicate, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n@@ -1407,7 +1408,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n         let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id);\n         let item = cx.tcx.hir().expect_item(parent);\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-        let ty = cx.tcx.type_of(def_id);\n+        let self_ty = cx.tcx.type_of(def_id);\n         if_chain! {\n             if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n@@ -1429,7 +1430,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                         if name == method_name &&\n                         sig.decl.inputs.len() == n_args &&\n                         out_type.matches(cx, &sig.decl.output) &&\n-                        self_kind.matches(cx, ty, first_arg_ty) {\n+                        self_kind.matches(cx, self_ty, first_arg_ty) {\n                             span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n                                 \"defining a method called `{}` on this type; consider implementing \\\n                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -1441,7 +1442,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                     .iter()\n                     .find(|(ref conv, _)| conv.check(&name))\n                 {\n-                    if !self_kinds.iter().any(|k| k.matches(cx, ty, first_arg_ty)) {\n+                    if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n                         let lint = if item.vis.node.is_pub() {\n                             WRONG_PUB_SELF_CONVENTION\n                         } else {\n@@ -1471,8 +1472,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id);\n \n+            let contains_self_ty = |ty: Ty<'tcx>| {\n+                ty.walk().any(|inner| match inner.unpack() {\n+                    GenericArgKind::Type(inner_ty) => same_tys(cx, self_ty, inner_ty),\n+\n+                    GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+                })\n+            };\n+\n             // walk the return type and check for Self (this does not check associated types)\n-            if ret_ty.walk().any(|inner_type| same_tys(cx, ty, inner_type)) {\n+            if contains_self_ty(ret_ty) {\n                 return;\n             }\n \n@@ -1486,18 +1495,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                             let associated_type = binder.skip_binder();\n \n                             // walk the associated type and check for Self\n-                            for inner_type in associated_type.walk() {\n-                                if same_tys(cx, ty, inner_type) {\n-                                    return;\n-                                }\n+                            if contains_self_ty(associated_type) {\n+                                return;\n                             }\n                         },\n                         (_, _) => {},\n                     }\n                 }\n             }\n \n-            if name == \"new\" && !same_tys(cx, ret_ty, ty) {\n+            if name == \"new\" && !same_tys(cx, ret_ty, self_ty) {\n                 span_lint(\n                     cx,\n                     NEW_RET_NO_SELF,"}, {"sha": "412bebb9bc6e5eca20d0dd200a9a66affe7f7d36", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d342cee78703c46d9df09088f9fb99ba85d021ae/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d342cee78703c46d9df09088f9fb99ba85d021ae/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=d342cee78703c46d9df09088f9fb99ba85d021ae", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty;\n use rustc_middle::ty::{DefIdTree, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::kw;\n+use rustc_typeck::hir_ty_to_ty;\n \n use crate::utils::{differing_macro_contexts, span_lint_and_sugg};\n \n@@ -80,37 +81,28 @@ fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path<'_>, last_segment: O\n     );\n }\n \n-struct TraitImplTyVisitor<'a, 'tcx> {\n-    item_type: Ty<'tcx>,\n+// FIXME: always use this (more correct) visitor, not just in method signatures.\n+struct SemanticUseSelfVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    trait_type_walker: ty::walk::TypeWalker<'tcx>,\n-    impl_type_walker: ty::walk::TypeWalker<'tcx>,\n+    self_ty: Ty<'tcx>,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for SemanticUseSelfVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n-    fn visit_ty(&mut self, t: &'tcx hir::Ty<'_>) {\n-        let trait_ty = self.trait_type_walker.next();\n-        let impl_ty = self.impl_type_walker.next();\n-\n-        if_chain! {\n-            if let TyKind::Path(QPath::Resolved(_, path)) = &t.kind;\n-\n-            // The implementation and trait types don't match which means that\n-            // the concrete type was specified by the implementation\n-            if impl_ty != trait_ty;\n-            if let Some(impl_ty) = impl_ty;\n-            if self.item_type == impl_ty;\n-            then {\n-                match path.res {\n-                    def::Res::SelfTy(..) => {},\n-                    _ => span_use_self_lint(self.cx, path, None)\n-                }\n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'_>) {\n+        if let TyKind::Path(QPath::Resolved(_, path)) = &hir_ty.kind {\n+            match path.res {\n+                def::Res::SelfTy(..) => {},\n+                _ => {\n+                    if hir_ty_to_ty(self.cx.tcx, hir_ty) == self.self_ty {\n+                        span_use_self_lint(self.cx, path, None);\n+                    }\n+                },\n             }\n         }\n \n-        walk_ty(self, t)\n+        walk_ty(self, hir_ty)\n     }\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n@@ -120,10 +112,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n \n fn check_trait_method_impl_decl<'a, 'tcx>(\n     cx: &'a LateContext<'a, 'tcx>,\n-    item_type: Ty<'tcx>,\n     impl_item: &ImplItem<'_>,\n     impl_decl: &'tcx FnDecl<'_>,\n-    impl_trait_ref: &ty::TraitRef<'_>,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n ) {\n     let trait_method = cx\n         .tcx\n@@ -134,34 +125,35 @@ fn check_trait_method_impl_decl<'a, 'tcx>(\n     let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n     let trait_method_sig = cx.tcx.erase_late_bound_regions(&trait_method_sig);\n \n-    let impl_method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-    let impl_method_sig = cx.tcx.fn_sig(impl_method_def_id);\n-    let impl_method_sig = cx.tcx.erase_late_bound_regions(&impl_method_sig);\n-\n-    let output_ty = if let FnRetTy::Return(ty) = &impl_decl.output {\n+    let output_hir_ty = if let FnRetTy::Return(ty) = &impl_decl.output {\n         Some(&**ty)\n     } else {\n         None\n     };\n \n-    // `impl_decl_ty` (of type `hir::Ty`) represents the type declared in the signature.\n-    // `impl_ty` (of type `ty:TyS`) is the concrete type that the compiler has determined for\n-    // that declaration. We use `impl_decl_ty` to see if the type was declared as `Self`\n-    // and use `impl_ty` to check its concrete type.\n-    for (impl_decl_ty, (impl_ty, trait_ty)) in impl_decl.inputs.iter().chain(output_ty).zip(\n-        impl_method_sig\n-            .inputs_and_output\n-            .iter()\n-            .zip(trait_method_sig.inputs_and_output),\n-    ) {\n-        let mut visitor = TraitImplTyVisitor {\n-            cx,\n-            item_type,\n-            trait_type_walker: trait_ty.walk(),\n-            impl_type_walker: impl_ty.walk(),\n-        };\n-\n-        visitor.visit_ty(&impl_decl_ty);\n+    // `impl_hir_ty` (of type `hir::Ty`) represents the type written in the signature.\n+    // `trait_ty` (of type `ty::Ty`) is the semantic type for the signature in the trait.\n+    // We use `impl_hir_ty` to see if the type was written as `Self`,\n+    // `hir_ty_to_ty(...)` to check semantic types of paths, and\n+    // `trait_ty` to determine which parts of the signature in the trait, mention\n+    // the type being implemented verbatim (as opposed to `Self`).\n+    for (impl_hir_ty, trait_ty) in impl_decl\n+        .inputs\n+        .iter()\n+        .chain(output_hir_ty)\n+        .zip(trait_method_sig.inputs_and_output)\n+    {\n+        // Check if the input/output type in the trait method specifies the implemented\n+        // type verbatim, and only suggest `Self` if that isn't the case.\n+        // This avoids suggestions to e.g. replace `Vec<u8>` with `Vec<Self>`,\n+        // in an `impl Trait for u8`, when the trait always uses `Vec<u8>`.\n+        // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n+        let self_ty = impl_trait_ref.self_ty();\n+        if !trait_ty.walk().any(|inner| inner == self_ty.into()) {\n+            let mut visitor = SemanticUseSelfVisitor { cx, self_ty };\n+\n+            visitor.visit_ty(&impl_hir_ty);\n+        }\n     }\n }\n \n@@ -197,8 +189,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n                             let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n                             if let ImplItemKind::Fn(FnSig{ decl: impl_decl, .. }, impl_body_id)\n                                     = &impl_item.kind {\n-                                let item_type = cx.tcx.type_of(impl_def_id);\n-                                check_trait_method_impl_decl(cx, item_type, impl_item, impl_decl, &impl_trait_ref);\n+                                check_trait_method_impl_decl(cx, impl_item, impl_decl, impl_trait_ref);\n \n                                 let body = cx.tcx.hir().body(*impl_body_id);\n                                 visitor.visit_body(body);"}, {"sha": "6038ed697f91ea7f2ccbec3672c6ac63bb2a695f", "filename": "setup-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d342cee78703c46d9df09088f9fb99ba85d021ae/setup-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d342cee78703c46d9df09088f9fb99ba85d021ae/setup-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/setup-toolchain.sh?ref=d342cee78703c46d9df09088f9fb99ba85d021ae", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Set up the appropriate rustc toolchain\n \n set -e"}]}