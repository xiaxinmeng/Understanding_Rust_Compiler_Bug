{"sha": "b8bea5a0a6aef3966008787a25949344f8cf6942", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YmVhNWEwYTZhZWYzOTY2MDA4Nzg3YTI1OTQ5MzQ0ZjhjZjY5NDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-05T01:57:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-05T01:57:01Z"}, "message": "Auto merge of #54017 - alexcrichton:wasm-atomics2, r=sfackler\n\nstd: Start implementing wasm32 atomics\n\nThis commit is an initial start at implementing the standard library for\nwasm32-unknown-unknown with the experimental `atomics` feature enabled. None of\nthese changes will be visible to users of the wasm32-unknown-unknown target\nbecause they all require recompiling the standard library. The hope with this is\nthat we can get this support into the standard library and start iterating on it\nin-tree to enable experimentation.\n\nCurrently there's a few components in this PR:\n\n* Atomic fences are disabled on wasm as there's no corresponding atomic op and\n  it's not clear yet what the convention should be, but this will change in the\n  future!\n* Implementations of `Mutex`, `Condvar`, and `RwLock` were all added based on\n  the atomic intrinsics that wasm has.\n* The `ReentrantMutex` and thread-local-storage implementations panic currently\n  as there's no great way to get a handle on the current thread's \"id\" yet.\n\nRight now the wasm32 target with atomics is unfortunately pretty unusable,\nrequiring a lot of manual things here and there to actually get it operational.\nThis will likely continue to evolve as the story for atomics and wasm unfolds,\nbut we also need more LLVM support for some operations like custom `global`\ndirectives for this to work best.", "tree": {"sha": "a29a02f8e323bab8a03ec8399341290ab521bbd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a29a02f8e323bab8a03ec8399341290ab521bbd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8bea5a0a6aef3966008787a25949344f8cf6942", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8bea5a0a6aef3966008787a25949344f8cf6942", "html_url": "https://github.com/rust-lang/rust/commit/b8bea5a0a6aef3966008787a25949344f8cf6942", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8bea5a0a6aef3966008787a25949344f8cf6942/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "html_url": "https://github.com/rust-lang/rust/commit/8c4ad4e9e42f4bcbdbb784692b936c2462061abc"}, {"sha": "b4877edd6750edc12aa2db1953a6551843bfa4b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4877edd6750edc12aa2db1953a6551843bfa4b4", "html_url": "https://github.com/rust-lang/rust/commit/b4877edd6750edc12aa2db1953a6551843bfa4b4"}], "stats": {"total": 515, "additions": 510, "deletions": 5}, "files": [{"sha": "59cc312bee5fcc4064751bca256ed75592fa31ea", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -117,6 +117,7 @@\n #![feature(powerpc_target_feature)]\n #![feature(mips_target_feature)]\n #![feature(aarch64_target_feature)]\n+#![feature(wasm_target_feature)]\n #![feature(const_slice_len)]\n #![feature(const_str_as_bytes)]\n #![feature(const_str_len)]"}, {"sha": "f130dbfb0e3dfea57259d2f89df93f6be11c00ab", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -2251,7 +2251,15 @@ unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(target_arch = \"wasm32\", allow(unused_variables))]\n pub fn fence(order: Ordering) {\n+    // On wasm32 it looks like fences aren't implemented in LLVM yet in that\n+    // they will cause LLVM to abort. The wasm instruction set doesn't have\n+    // fences right now. There's discussion online about the best way for tools\n+    // to conventionally implement fences at\n+    // https://github.com/WebAssembly/tool-conventions/issues/59. We should\n+    // follow that discussion and implement a solution when one comes about!\n+    #[cfg(not(target_arch = \"wasm32\"))]\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_fence_acq(),"}, {"sha": "c58bd364cedaba7857e9f607aedc464bcff11bab", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -257,6 +257,7 @@\n #![feature(const_cstr_unchecked)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n+#![feature(duration_as_u128)]\n #![feature(exact_size_is_empty)]\n #![feature(external_doc)]\n #![feature(fixed_size_array)]"}, {"sha": "5c55fd0a61868523e982dd4d3b4a8ae700f6d92a", "filename": "src/libstd/sys/wasm/condvar_atomics.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar_atomics.rs?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use arch::wasm32::atomic;\n+use cmp;\n+use mem;\n+use sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+use sys::mutex::Mutex;\n+use time::Duration;\n+\n+pub struct Condvar {\n+    cnt: AtomicUsize,\n+}\n+\n+// Condition variables are implemented with a simple counter internally that is\n+// likely to cause spurious wakeups. Blocking on a condition variable will first\n+// read the value of the internal counter, unlock the given mutex, and then\n+// block if and only if the counter's value is still the same. Notifying a\n+// condition variable will modify the counter (add one for now) and then wake up\n+// a thread waiting on the address of the counter.\n+//\n+// A thread waiting on the condition variable will as a result avoid going to\n+// sleep if it's notified after the lock is unlocked but before it fully goes to\n+// sleep. A sleeping thread is guaranteed to be woken up at some point as it can\n+// only be woken up with a call to `wake`.\n+//\n+// Note that it's possible for 2 or more threads to be woken up by a call to\n+// `notify_one` with this implementation. That can happen where the modification\n+// of `cnt` causes any threads in the middle of `wait` to avoid going to sleep,\n+// and the subsequent `wake` may wake up a thread that's actually blocking. We\n+// consider this a spurious wakeup, though, which all users of condition\n+// variables must already be prepared to handle. As a result, this source of\n+// spurious wakeups is currently though to be ok, although it may be problematic\n+// later on if it causes too many spurious wakeups.\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar { cnt: AtomicUsize::new(0) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        // nothing to do\n+    }\n+\n+    pub unsafe fn notify_one(&self) {\n+        self.cnt.fetch_add(1, SeqCst);\n+        atomic::wake(self.ptr(), 1);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_all(&self) {\n+        self.cnt.fetch_add(1, SeqCst);\n+        atomic::wake(self.ptr(), -1); // -1 == \"wake everyone\"\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        // \"atomically block and unlock\" implemented by loading our current\n+        // counter's value, unlocking the mutex, and blocking if the counter\n+        // still has the same value.\n+        //\n+        // Notifications happen by incrementing the counter and then waking a\n+        // thread. Incrementing the counter after we unlock the mutex will\n+        // prevent us from sleeping and otherwise the call to `wake` will\n+        // wake us up once we're asleep.\n+        let ticket = self.cnt.load(SeqCst) as i32;\n+        mutex.unlock();\n+        let val = atomic::wait_i32(self.ptr(), ticket, -1);\n+        // 0 == woken, 1 == not equal to `ticket`, 2 == timeout (shouldn't happen)\n+        debug_assert!(val == 0 || val == 1);\n+        mutex.lock();\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        let ticket = self.cnt.load(SeqCst) as i32;\n+        mutex.unlock();\n+        let nanos = dur.as_nanos();\n+        let nanos = cmp::min(i64::max_value() as u128, nanos);\n+\n+        // If the return value is 2 then a timeout happened, so we return\n+        // `false` as we weren't actually notified.\n+        let ret = atomic::wait_i32(self.ptr(), ticket, nanos as i64) != 2;\n+        mutex.lock();\n+        return ret\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        // nothing to do\n+    }\n+\n+    #[inline]\n+    fn ptr(&self) -> *mut i32 {\n+        assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n+        &self.cnt as *const AtomicUsize as *mut i32\n+    }\n+}"}, {"sha": "e11b4d71aaeea90cf01cee2b66eb99cc2423d90e", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -36,24 +36,38 @@ pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;\n pub mod cmath;\n-pub mod condvar;\n pub mod env;\n pub mod fs;\n pub mod memchr;\n-pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod os_str;\n pub mod path;\n pub mod pipe;\n pub mod process;\n-pub mod rwlock;\n pub mod stack_overflow;\n pub mod thread;\n-pub mod thread_local;\n pub mod time;\n pub mod stdio;\n \n+cfg_if! {\n+    if #[cfg(target_feature = \"atomics\")] {\n+        #[path = \"condvar_atomics.rs\"]\n+        pub mod condvar;\n+        #[path = \"mutex_atomics.rs\"]\n+        pub mod mutex;\n+        #[path = \"rwlock_atomics.rs\"]\n+        pub mod rwlock;\n+        #[path = \"thread_local_atomics.rs\"]\n+        pub mod thread_local;\n+    } else {\n+        pub mod condvar;\n+        pub mod mutex;\n+        pub mod rwlock;\n+        pub mod thread_local;\n+    }\n+}\n+\n #[cfg(not(test))]\n pub fn init() {\n }"}, {"sha": "ced6c17ef9605aba311f71bb9825202558c3a1f7", "filename": "src/libstd/sys/wasm/mutex_atomics.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -0,0 +1,163 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use arch::wasm32::atomic;\n+use cell::UnsafeCell;\n+use mem;\n+use sync::atomic::{AtomicUsize, AtomicU64, Ordering::SeqCst};\n+\n+pub struct Mutex {\n+    locked: AtomicUsize,\n+}\n+\n+// Mutexes have a pretty simple implementation where they contain an `i32`\n+// internally that is 0 when unlocked and 1 when the mutex is locked.\n+// Acquisition has a fast path where it attempts to cmpxchg the 0 to a 1, and\n+// if it fails it then waits for a notification. Releasing a lock is then done\n+// by swapping in 0 and then notifying any waiters, if present.\n+\n+impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex { locked: AtomicUsize::new(0) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        // nothing to do\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        while !self.try_lock() {\n+            let val = atomic::wait_i32(\n+                self.ptr(),\n+                1,  // we expect our mutex is locked\n+                -1, // wait infinitely\n+            );\n+            // we should have either woke up (0) or got a not-equal due to a\n+            // race (1). We should never time out (2)\n+            debug_assert!(val == 0 || val == 1);\n+        }\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        let prev = self.locked.swap(0, SeqCst);\n+        debug_assert_eq!(prev, 1);\n+        atomic::wake(self.ptr(), 1); // wake up one waiter, if any\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        self.locked.compare_exchange(0, 1, SeqCst, SeqCst).is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        // nothing to do\n+    }\n+\n+    #[inline]\n+    fn ptr(&self) -> *mut i32 {\n+        assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n+        &self.locked as *const AtomicUsize as *mut isize as *mut i32\n+    }\n+}\n+\n+pub struct ReentrantMutex {\n+    owner: AtomicU64,\n+    recursions: UnsafeCell<u32>,\n+}\n+\n+unsafe impl Send for ReentrantMutex {}\n+unsafe impl Sync for ReentrantMutex {}\n+\n+// Reentrant mutexes are similarly implemented to mutexs above except that\n+// instead of \"1\" meaning unlocked we use the id of a thread to represent\n+// whether it has locked a mutex. That way we have an atomic counter which\n+// always holds the id of the thread that currently holds the lock (or 0 if the\n+// lock is unlocked).\n+//\n+// Once a thread acquires a lock recursively, which it detects by looking at\n+// the value that's already there, it will update a local `recursions` counter\n+// in a nonatomic fashion (as we hold the lock). The lock is then fully\n+// released when this recursion counter reaches 0.\n+\n+impl ReentrantMutex {\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex {\n+            owner: AtomicU64::new(0),\n+            recursions: UnsafeCell::new(0),\n+        }\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        // nothing to do...\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        let me = thread_id();\n+        while let Err(owner) = self._try_lock(me) {\n+            let val = atomic::wait_i64(self.ptr(), owner as i64, -1);\n+            debug_assert!(val == 0 || val == 1);\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        self._try_lock(thread_id()).is_ok()\n+    }\n+\n+    #[inline]\n+    unsafe fn _try_lock(&self, id: u64) -> Result<(), u64> {\n+        let id = id.checked_add(1).unwrap(); // make sure `id` isn't 0\n+        match self.owner.compare_exchange(0, id, SeqCst, SeqCst) {\n+            // we transitioned from unlocked to locked\n+            Ok(_) => {\n+                debug_assert_eq!(*self.recursions.get(), 0);\n+                Ok(())\n+            }\n+\n+            // we currently own this lock, so let's update our count and return\n+            // true.\n+            Err(n) if n == id => {\n+                *self.recursions.get() += 1;\n+                Ok(())\n+            }\n+\n+            // Someone else owns the lock, let our caller take care of it\n+            Err(other) => Err(other),\n+        }\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        // If we didn't ever recursively lock the lock then we fully unlock the\n+        // mutex and wake up a waiter, if any. Otherwise we decrement our\n+        // recursive counter and let some one else take care of the zero.\n+        match *self.recursions.get() {\n+            0 => {\n+                self.owner.swap(0, SeqCst);\n+                atomic::wake(self.ptr() as *mut i32, 1); // wake up one waiter, if any\n+            }\n+            ref mut n => *n -= 1,\n+        }\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        // nothing to do...\n+    }\n+\n+    #[inline]\n+    fn ptr(&self) -> *mut i64 {\n+        &self.owner as *const AtomicU64 as *mut i64\n+    }\n+}\n+\n+fn thread_id() -> u64 {\n+    panic!(\"thread ids not implemented on wasm with atomics yet\")\n+}"}, {"sha": "3623333cc8610f59a9ab9ef4c71e6f2a228ca720", "filename": "src/libstd/sys/wasm/rwlock_atomics.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Frwlock_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Frwlock_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Frwlock_atomics.rs?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use sys::mutex::Mutex;\n+use sys::condvar::Condvar;\n+\n+pub struct RWLock {\n+    lock: Mutex,\n+    cond: Condvar,\n+    state: UnsafeCell<State>,\n+}\n+\n+enum State {\n+    Unlocked,\n+    Reading(usize),\n+    Writing,\n+}\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n+// This rwlock implementation is a relatively simple implementation which has a\n+// condition variable for readers/writers as well as a mutex protecting the\n+// internal state of the lock. A current downside of the implementation is that\n+// unlocking the lock will notify *all* waiters rather than just readers or just\n+// writers. This can cause lots of \"thundering stampede\" problems. While\n+// hopefully correct this implementation is very likely to want to be changed in\n+// the future.\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            lock: Mutex::new(),\n+            cond: Condvar::new(),\n+            state: UnsafeCell::new(State::Unlocked),\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        self.lock.lock();\n+        while !(*self.state.get()).inc_readers() {\n+            self.cond.wait(&self.lock);\n+        }\n+        self.lock.unlock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        self.lock.lock();\n+        let ok = (*self.state.get()).inc_readers();\n+        self.lock.unlock();\n+        return ok\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        self.lock.lock();\n+        while !(*self.state.get()).inc_writers() {\n+            self.cond.wait(&self.lock);\n+        }\n+        self.lock.unlock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        self.lock.lock();\n+        let ok = (*self.state.get()).inc_writers();\n+        self.lock.unlock();\n+        return ok\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        self.lock.lock();\n+        let notify = (*self.state.get()).dec_readers();\n+        self.lock.unlock();\n+        if notify {\n+            // FIXME: should only wake up one of these some of the time\n+            self.cond.notify_all();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        self.lock.lock();\n+        (*self.state.get()).dec_writers();\n+        self.lock.unlock();\n+        // FIXME: should only wake up one of these some of the time\n+        self.cond.notify_all();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        self.lock.destroy();\n+        self.cond.destroy();\n+    }\n+}\n+\n+impl State {\n+    fn inc_readers(&mut self) -> bool {\n+        match *self {\n+            State::Unlocked => {\n+                *self = State::Reading(1);\n+                true\n+            }\n+            State::Reading(ref mut cnt) => {\n+                *cnt += 1;\n+                true\n+            }\n+            State::Writing => false\n+        }\n+    }\n+\n+    fn inc_writers(&mut self) -> bool {\n+        match *self {\n+            State::Unlocked => {\n+                *self = State::Writing;\n+                true\n+            }\n+            State::Reading(_) |\n+            State::Writing => false\n+        }\n+    }\n+\n+    fn dec_readers(&mut self) -> bool {\n+        let zero = match *self {\n+            State::Reading(ref mut cnt) => {\n+                *cnt -= 1;\n+                *cnt == 0\n+            }\n+            State::Unlocked |\n+            State::Writing => invalid(),\n+        };\n+        if zero {\n+            *self = State::Unlocked;\n+        }\n+        zero\n+    }\n+\n+    fn dec_writers(&mut self) {\n+        match *self {\n+            State::Writing => {}\n+            State::Unlocked |\n+            State::Reading(_) => invalid(),\n+        }\n+        *self = State::Unlocked;\n+    }\n+}\n+\n+fn invalid() -> ! {\n+    panic!(\"inconsistent rwlock\");\n+}"}, {"sha": "bef6c1f34905e8b84e56cd5d5778e84a8ca6e153", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -33,10 +33,31 @@ impl Thread {\n         // nope\n     }\n \n+    #[cfg(not(target_feature = \"atomics\"))]\n     pub fn sleep(_dur: Duration) {\n         panic!(\"can't sleep\");\n     }\n \n+    #[cfg(target_feature = \"atomics\")]\n+    pub fn sleep(dur: Duration) {\n+        use arch::wasm32::atomic;\n+        use cmp;\n+\n+        // Use an atomic wait to block the current thread artificially with a\n+        // timeout listed. Note that we should never be notified (return value\n+        // of 0) or our comparison should never fail (return value of 1) so we\n+        // should always only resume execution through a timeout (return value\n+        // 2).\n+        let mut nanos = dur.as_nanos();\n+        while nanos > 0 {\n+            let amt = cmp::min(i64::max_value() as u128, nanos);\n+            let mut x = 0;\n+            let val = unsafe { atomic::wait_i32(&mut x, 0, amt as i64) };\n+            debug_assert_eq!(val, 2);\n+            nanos -= amt;\n+        }\n+    }\n+\n     pub fn join(self) {\n         match self.0 {}\n     }"}, {"sha": "1394013b4a314e782eabe56ceebce8f85308be76", "filename": "src/libstd/sys/wasm/thread_local_atomics.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bea5a0a6aef3966008787a25949344f8cf6942/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub type Key = usize;\n+\n+pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    panic!(\"TLS on wasm with atomics not implemented yet\");\n+}\n+\n+pub unsafe fn set(_key: Key, _value: *mut u8) {\n+    panic!(\"TLS on wasm with atomics not implemented yet\");\n+}\n+\n+pub unsafe fn get(_key: Key) -> *mut u8 {\n+    panic!(\"TLS on wasm with atomics not implemented yet\");\n+}\n+\n+pub unsafe fn destroy(_key: Key) {\n+    panic!(\"TLS on wasm with atomics not implemented yet\");\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "fe825c93788c841ac1872e8351a62c37a5f78427", "filename": "src/stdsimd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstdsimd?ref=b8bea5a0a6aef3966008787a25949344f8cf6942", "patch": "@@ -1 +1 @@\n-Subproject commit 05c2f61c384e2097a3a4c648344114fc4ac983be\n+Subproject commit fe825c93788c841ac1872e8351a62c37a5f78427"}]}