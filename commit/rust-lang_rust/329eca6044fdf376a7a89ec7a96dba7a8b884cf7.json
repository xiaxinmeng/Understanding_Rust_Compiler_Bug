{"sha": "329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOWVjYTYwNDRmZGYzNzZhN2E4OWVjN2E5NmRiYTdhOGI4ODRjZjc=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-26T03:00:46Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-26T03:00:46Z"}, "message": "Make vectors uglier ([]/~). Sorry. Should be temporary. Closes #2725.", "tree": {"sha": "7008814278a066914b6ba36818388d5212ffda9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7008814278a066914b6ba36818388d5212ffda9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "html_url": "https://github.com/rust-lang/rust/commit/329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c087aaf56b1109163126fea4c2760f8414ffbe56", "url": "https://api.github.com/repos/rust-lang/rust/commits/c087aaf56b1109163126fea4c2760f8414ffbe56", "html_url": "https://github.com/rust-lang/rust/commit/c087aaf56b1109163126fea4c2760f8414ffbe56"}], "stats": {"total": 8157, "additions": 4123, "deletions": 4034}, "files": [{"sha": "6f89e0a8fdfcea96afb03367c912faf5d5fabc01", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -21,15 +21,15 @@ type package = {\n     method: str,\n     description: str,\n     ref: option<str>,\n-    tags: [str],\n-    versions: [(str, str)]\n+    tags: [str]/~,\n+    versions: [(str, str)]/~\n };\n \n type local_package = {\n     name: str,\n     metaname: str,\n     version: str,\n-    files: [str]\n+    files: [str]/~\n };\n \n type source = @{\n@@ -38,7 +38,7 @@ type source = @{\n     mut method: str,\n     mut key: option<str>,\n     mut keyfp: option<str>,\n-    mut packages: [mut package]\n+    mut packages: [mut package]/~\n };\n \n type cargo = {\n@@ -62,21 +62,21 @@ type crate = {\n     desc: option<str>,\n     sigs: option<str>,\n     crate_type: option<str>,\n-    deps: [str]\n+    deps: [str]/~\n };\n \n type options = {\n     test: bool,\n     mode: mode,\n-    free: [str],\n+    free: [str]/~,\n     help: bool,\n };\n \n enum mode { system_mode, user_mode, local_mode }\n \n-fn opts() -> [getopts::opt] {\n+fn opts() -> [getopts::opt]/~ {\n     [optflag(\"g\"), optflag(\"G\"), optflag(\"test\"),\n-     optflag(\"h\"), optflag(\"help\")]\n+     optflag(\"h\"), optflag(\"help\")]/~\n }\n \n fn info(msg: str) {\n@@ -216,7 +216,7 @@ fn assume_source_method(url: str) -> str {\n     \"curl\"\n }\n \n-fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n+fn load_link(mis: [@ast::meta_item]/~) -> (option<str>,\n                                          option<str>,\n                                          option<str>) {\n     let mut name = none;\n@@ -240,7 +240,7 @@ fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n \n fn load_crate(filename: str) -> option<crate> {\n     let sess = parse::new_parse_sess(none);\n-    let c = parse::parse_crate_from_crate_file(filename, [], sess);\n+    let c = parse::parse_crate_from_crate_file(filename, []/~, sess);\n \n     let mut name = none;\n     let mut vers = none;\n@@ -275,15 +275,15 @@ fn load_crate(filename: str) -> option<crate> {\n     }\n \n     type env = @{\n-        mut deps: [str]\n+        mut deps: [str]/~\n     };\n \n     fn goto_view_item(e: env, i: @ast::view_item) {\n         alt i.node {\n             ast::view_item_use(ident, metas, id) {\n                 let name_items = attr::find_meta_items_by_name(metas, \"name\");\n                 let m = if name_items.is_empty() {\n-                    metas + [attr::mk_name_value_item_str(@\"name\", *ident)]\n+                    metas + [attr::mk_name_value_item_str(@\"name\", *ident)]/~\n                 } else {\n                     metas\n                 };\n@@ -326,7 +326,7 @@ fn load_crate(filename: str) -> option<crate> {\n     }\n \n     let e = @{\n-        mut deps: []\n+        mut deps: []/~\n     };\n     let v = visit::mk_simple_visitor(@{\n         visit_view_item: {|a|goto_view_item(e, a)},\n@@ -424,7 +424,7 @@ fn parse_source(name: str, j: json::json) -> source {\n                 mut method: method,\n                 mut key: key,\n                 mut keyfp: keyfp,\n-                mut packages: [mut] };\n+                mut packages: [mut]/~ };\n         }\n         _ { fail \"needed dict value in source\"; }\n     };\n@@ -498,7 +498,7 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n         _ { none }\n     };\n \n-    let mut tags = [];\n+    let mut tags = []/~;\n     alt p.find(\"tags\") {\n         some(json::list(js)) {\n             for (*js).each {|j|\n@@ -528,7 +528,7 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n         description: description,\n         ref: ref,\n         tags: tags,\n-        versions: []\n+        versions: []/~\n     };\n \n     alt src.packages.position({ |pkg| pkg.uuid == uuid }) {\n@@ -595,7 +595,7 @@ fn load_source_packages(c: cargo, src: source) {\n     };\n }\n \n-fn build_cargo_options(argv: [str]) -> options {\n+fn build_cargo_options(argv: [str]/~) -> options {\n     let match = alt getopts::getopts(argv, opts()) {\n         result::ok(m) { m }\n         result::err(f) {\n@@ -699,19 +699,19 @@ fn for_each_package(c: cargo, b: fn(source, package)) {\n fn run_programs(buildpath: str) {\n     let newv = os::list_dir_path(buildpath);\n     for newv.each {|ct|\n-        run::run_program(ct, []);\n+        run::run_program(ct, []/~);\n     }\n }\n \n // Runs rustc in <path + subdir> with the given flags\n // and returns <path + subdir>\n fn run_in_buildpath(what: str, path: str, subdir: str, cf: str,\n-                    extra_flags: [str]) -> option<str> {\n+                    extra_flags: [str]/~) -> option<str> {\n     let buildpath = path::connect(path, subdir);\n     need_dir(buildpath);\n     #debug(\"%s: %s -> %s\", what, cf, buildpath);\n     let p = run::program_output(rustc_sysroot(),\n-                                [\"--out-dir\", buildpath, cf] + extra_flags);\n+                                [\"--out-dir\", buildpath, cf]/~ + extra_flags);\n     if p.status != 0 {\n         error(#fmt[\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out]);\n         ret none;\n@@ -721,7 +721,7 @@ fn run_in_buildpath(what: str, path: str, subdir: str, cf: str,\n \n fn test_one_crate(_c: cargo, path: str, cf: str) {\n   let buildpath = alt run_in_buildpath(\"testing\", path, \"/test\", cf,\n-                                       [ \"--test\"]) {\n+                                       [ \"--test\"]/~) {\n       none { ret; }\n       some(bp) { bp }\n   };\n@@ -730,7 +730,7 @@ fn test_one_crate(_c: cargo, path: str, cf: str) {\n \n fn install_one_crate(c: cargo, path: str, cf: str) {\n     let buildpath = alt run_in_buildpath(\"installing\", path,\n-                                         \"/build\", cf, []) {\n+                                         \"/build\", cf, []/~) {\n       none { ret; }\n       some(bp) { bp }\n     };\n@@ -758,7 +758,7 @@ fn install_one_crate(c: cargo, path: str, cf: str) {\n fn rustc_sysroot() -> str {\n     alt os::self_exe_path() {\n         some(path) {\n-            let path = [path, \"..\", \"bin\", \"rustc\"];\n+            let path = [path, \"..\", \"bin\", \"rustc\"]/~;\n             check vec::is_not_empty(path);\n             let rustc = path::normalize(path::connect_many(path));\n             #debug(\"  rustc: %s\", rustc);\n@@ -772,7 +772,7 @@ fn install_source(c: cargo, path: str) {\n     #debug(\"source: %s\", path);\n     os::change_dir(path);\n \n-    let mut cratefiles = [];\n+    let mut cratefiles = []/~;\n     for os::walk_dir(\".\") {|p|\n         if str::ends_with(p, \".rc\") {\n             vec::push(cratefiles, p);\n@@ -811,11 +811,11 @@ fn install_source(c: cargo, path: str) {\n }\n \n fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n-    run::program_output(\"git\", [\"clone\", url, wd]);\n+    run::program_output(\"git\", [\"clone\", url, wd]/~);\n     if option::is_some(ref) {\n         let r = option::get(ref);\n         os::change_dir(wd);\n-        run::run_program(\"git\", [\"checkout\", r]);\n+        run::run_program(\"git\", [\"checkout\", r]/~);\n     }\n \n     install_source(c, wd);\n@@ -824,18 +824,18 @@ fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n fn install_curl(c: cargo, wd: str, url: str) {\n     let tarpath = path::connect(wd, \"pkg.tar\");\n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n-                                         tarpath, url]);\n+                                         tarpath, url]/~);\n     if p.status != 0 {\n         fail #fmt[\"fetch of %s failed: %s\", url, p.err];\n     }\n     run::run_program(\"tar\", [\"-x\", \"--strip-components=1\",\n-                             \"-C\", wd, \"-f\", tarpath]);\n+                             \"-C\", wd, \"-f\", tarpath]/~);\n     install_source(c, wd);\n }\n \n fn install_file(c: cargo, wd: str, path: str) {\n     run::program_output(\"tar\", [\"-x\", \"--strip-components=1\",\n-                             \"-C\", wd, \"-f\", path]);\n+                             \"-C\", wd, \"-f\", path]/~);\n     install_source(c, wd);\n }\n \n@@ -868,7 +868,7 @@ fn cargo_suggestion(c: cargo, fallback: fn())\n }\n \n fn install_uuid(c: cargo, wd: str, uuid: str) {\n-    let mut ps = [];\n+    let mut ps = []/~;\n     for_each_package(c, { |s, p|\n         if p.uuid == uuid {\n             vec::grow(ps, 1u, (s.name, copy p));\n@@ -892,7 +892,7 @@ fn install_uuid(c: cargo, wd: str, uuid: str) {\n }\n \n fn install_named(c: cargo, wd: str, name: str) {\n-    let mut ps = [];\n+    let mut ps = []/~;\n     for_each_package(c, { |s, p|\n         if p.name == name {\n             vec::grow(ps, 1u, (s.name, copy p));\n@@ -1082,7 +1082,7 @@ fn cmd_install(c: cargo) unsafe {\n \n     if vec::len(c.opts.free) == 2u {\n         let cwd = os::getcwd();\n-        let status = run::run_program(\"cp\", [\"-R\", cwd, wd]);\n+        let status = run::run_program(\"cp\", [\"-R\", cwd, wd]/~);\n \n         if status != 0 {\n             fail #fmt(\"could not copy directory: %s\", cwd);\n@@ -1135,7 +1135,7 @@ fn sync_one_file(c: cargo, dir: str, src: source) -> bool {\n     alt copy src.key {\n         some(u) {\n             let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n-                                                  u]);\n+                                                  u]/~);\n             if p.status != 0 {\n                 error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n                 ret false;\n@@ -1209,7 +1209,7 @@ fn sync_one_git(c: cargo, dir: str, src: source) -> bool {\n         }\n         else {\n             let p = run::program_output(\"git\", [\"reset\", \"--hard\",\n-                                                \"HEAD@{1}\"]);\n+                                                \"HEAD@{1}\"]/~);\n \n             if p.status != 0 {\n                 msg(name, insecure);\n@@ -1218,7 +1218,7 @@ fn sync_one_git(c: cargo, dir: str, src: source) -> bool {\n     }\n \n     if !os::path_exists(path::connect(dir, \".git\")) {\n-        let p = run::program_output(\"git\", [\"clone\", url, dir]);\n+        let p = run::program_output(\"git\", [\"clone\", url, dir]/~);\n \n         if p.status != 0 {\n             error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n@@ -1231,7 +1231,7 @@ fn sync_one_git(c: cargo, dir: str, src: source) -> bool {\n             ret false;\n         }\n \n-        let p = run::program_output(\"git\", [\"pull\"]);\n+        let p = run::program_output(\"git\", [\"pull\"]/~);\n \n         if p.status != 0 {\n             error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n@@ -1244,7 +1244,7 @@ fn sync_one_git(c: cargo, dir: str, src: source) -> bool {\n     alt copy src.key {\n         some(u) {\n             let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n-                                                  u]);\n+                                                  u]/~);\n             if p.status != 0 {\n                 error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n                 rollback(name, dir, false);\n@@ -1303,15 +1303,16 @@ fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n         url += \"/packages.json\";\n     }\n \n-    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", pkgfile, url]);\n+    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", pkgfile, url]/~);\n \n     if p.status != 0 {\n         error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n         ret false;\n     }\n     if smart {\n         url = src.url + \"/source.json\";\n-        let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcfile, url]);\n+        let p =\n+            run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcfile, url]/~);\n \n         if p.status == 0 {\n             has_src_file = true;\n@@ -1321,7 +1322,7 @@ fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n     alt copy src.key {\n         some(u) {\n             let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n-                                                  u]);\n+                                                  u]/~);\n             if p.status != 0 {\n                 error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n                 ret false;\n@@ -1340,7 +1341,7 @@ fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n             }\n \n             let mut p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n-                        sigfile, url]);\n+                        sigfile, url]/~);\n             if p.status != 0 {\n                 error(#fmt[\"fetch for source %s (sig %s) failed\", name, url]);\n                 ret false;\n@@ -1358,7 +1359,7 @@ fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n                 url = src.url + \"/source.json.sig\";\n \n                 p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcsigfile,\n-                                                     url]);\n+                                                     url]/~);\n                 if p.status != 0 {\n                     error(#fmt[\"fetch for source %s (sig %s) failed\",\n                           name, url]);\n@@ -1422,13 +1423,15 @@ fn cmd_init(c: cargo) {\n     let sigfile = path::connect(c.root, \"sources.json.sig\");\n     let destsrcfile = path::connect(c.root, \"sources.json\");\n \n-    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcfile, srcurl]);\n+    let p =\n+        run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcfile, srcurl]/~);\n     if p.status != 0 {\n         error(#fmt[\"fetch of sources.json failed: %s\", p.out]);\n         ret;\n     }\n \n-    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", sigfile, sigurl]);\n+    let p =\n+        run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", sigfile, sigurl]/~);\n     if p.status != 0 {\n         error(#fmt[\"fetch of sources.json.sig failed: %s\", p.out]);\n         ret;\n@@ -1530,7 +1533,7 @@ fn cmd_search(c: cargo) {\n fn install_to_dir(srcfile: str, destdir: str) {\n     let newfile = path::connect(destdir, path::basename(srcfile));\n \n-    let status = run::run_program(\"cp\", [\"-r\", srcfile, newfile]);\n+    let status = run::run_program(\"cp\", [\"-r\", srcfile, newfile]/~);\n     if status == 0 {\n         info(#fmt[\"installed: '%s'\", newfile]);\n     } else {\n@@ -1647,7 +1650,7 @@ fn cmd_sources(c: cargo) {\n                         mut method: assume_source_method(url),\n                         mut key: none,\n                         mut keyfp: none,\n-                        mut packages: [mut]\n+                        mut packages: [mut]/~\n                     });\n                     info(#fmt(\"added source: %s\", name));\n                 }\n@@ -1865,7 +1868,7 @@ Commands:\n     set-method      Change the method for a source.\");\n }\n \n-fn main(argv: [str]) {\n+fn main(argv: [str]/~) {\n     let o = build_cargo_options(argv);\n \n     if vec::len(o.free) < 2u {"}, {"sha": "8c0eb7f6ba2e4e04d109380e6ba437e4a01e09ad", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -1,4 +1,4 @@\n-fn gpg(args: [str]) -> { status: int, out: str, err: str } {\n+fn gpg(args: [str]/~) -> { status: int, out: str, err: str } {\n     ret run::program_output(\"gpg\", args);\n }\n \n@@ -59,15 +59,15 @@ fn signing_key_fp() -> str {\n }\n \n fn supported() -> bool {\n-    let r = gpg([\"--version\"]);\n+    let r = gpg([\"--version\"]/~);\n     r.status == 0\n }\n \n fn init(root: str) {\n     let p = path::connect(root, \"gpg\");\n     if !os::path_is_dir(p) {\n         os::make_dir(p, 0x1c0i32);\n-        let p = run::start_program(\"gpg\", [\"--homedir\", p, \"--import\"]);\n+        let p = run::start_program(\"gpg\", [\"--homedir\", p, \"--import\"]/~);\n         p.input().write_str(signing_key());\n         let s = p.finish();\n         if s != 0 {\n@@ -78,7 +78,8 @@ fn init(root: str) {\n \n fn add(root: str, key: str) {\n     let path = path::connect(root, \"gpg\");\n-    let p = run::program_output(\"gpg\", [\"--homedir\", path, \"--import\", key]);\n+    let p =\n+        run::program_output(\"gpg\", [\"--homedir\", path, \"--import\", key]/~);\n     if p.status != 0 {\n         fail \"pgp add failed: \" + p.out;\n     }\n@@ -87,7 +88,7 @@ fn add(root: str, key: str) {\n fn verify(root: str, data: str, sig: str, keyfp: str) -> bool {\n     let path = path::connect(root, \"gpg\");\n     let p = gpg([\"--homedir\", path, \"--with-fingerprint\", \"--verify\", sig,\n-                 data]);\n+                 data]/~);\n     let res = \"Primary key fingerprint: \" + keyfp;\n     for str::split_char(p.err, '\\n').each {|line|\n         if line == res { ret true; }"}, {"sha": "07bb35dc29299ecd50b9ab458399ad54e0d5aeb5", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -21,13 +21,13 @@ import common::mode_pretty;\n import common::mode;\n import util::logv;\n \n-fn main(args: [str]) {\n+fn main(args: [str]/~) {\n     let config = parse_config(args);\n     log_config(config);\n     run_tests(config);\n }\n \n-fn parse_config(args: [str]) -> config {\n+fn parse_config(args: [str]/~) -> config {\n     let opts =\n         [getopts::reqopt(\"compile-lib-path\"), getopts::reqopt(\"run-lib-path\"),\n          getopts::reqopt(\"rustc-path\"), getopts::reqopt(\"src-base\"),\n@@ -36,7 +36,7 @@ fn parse_config(args: [str]) -> config {\n          getopts::reqopt(\"mode\"), getopts::optflag(\"ignored\"),\n          getopts::optopt(\"runtool\"), getopts::optopt(\"rustcflags\"),\n          getopts::optflag(\"verbose\"),\n-         getopts::optopt(\"logfile\")];\n+         getopts::optopt(\"logfile\")]/~;\n \n     check (vec::is_not_empty(args));\n     let args_ = vec::tail(args);\n@@ -132,9 +132,9 @@ fn test_opts(config: config) -> test::test_opts {\n     }\n }\n \n-fn make_tests(config: config) -> [test::test_desc] {\n+fn make_tests(config: config) -> [test::test_desc]/~ {\n     #debug(\"making tests from %s\", config.src_base);\n-    let mut tests = [];\n+    let mut tests = []/~;\n     for os::list_dir_path(config.src_base).each {|file|\n         let file = file;\n         #debug(\"inspecting file %s\", file);\n@@ -148,8 +148,8 @@ fn make_tests(config: config) -> [test::test_desc] {\n fn is_test(config: config, testfile: str) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n-        alt config.mode { mode_pretty { [\".rs\"] } _ { [\".rc\", \".rs\"] } };\n-    let invalid_prefixes = [\".\", \"#\", \"~\"];\n+        alt config.mode { mode_pretty { [\".rs\"]/~ } _ { [\".rc\", \".rs\"]/~ } };\n+    let invalid_prefixes = [\".\", \"#\", \"~\"]/~;\n     let name = path::basename(testfile);\n \n     let mut valid = false;"}, {"sha": "5d1bba368d4359adf6f42fb78494019015ac3b5a", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -8,8 +8,8 @@ export expected_error;\n type expected_error = { line: uint, kind: str, msg: str };\n \n // Load any test directives embedded in the file\n-fn load_errors(testfile: str) -> [expected_error] {\n-    let mut error_patterns = [];\n+fn load_errors(testfile: str) -> [expected_error]/~ {\n+    let mut error_patterns = []/~;\n     let rdr = result::get(io::file_reader(testfile));\n     let mut line_num = 1u;\n     while !rdr.eof() {\n@@ -20,11 +20,11 @@ fn load_errors(testfile: str) -> [expected_error] {\n     ret error_patterns;\n }\n \n-fn parse_expected(line_num: uint, line: str) -> [expected_error] unsafe {\n+fn parse_expected(line_num: uint, line: str) -> [expected_error]/~ unsafe {\n     let error_tag = \"//!\";\n     let mut idx;\n     alt str::find_str(line, error_tag) {\n-         option::none { ret []; }\n+         option::none { ret []/~; }\n          option::some(nn) { idx = (nn as uint) + str::len(error_tag); }\n     }\n \n@@ -49,5 +49,5 @@ fn parse_expected(line_num: uint, line: str) -> [expected_error] unsafe {\n \n     #debug(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n \n-    ret [{line: line_num - adjust_line, kind: kind, msg: msg}];\n+    ret [{line: line_num - adjust_line, kind: kind, msg: msg}]/~;\n }"}, {"sha": "7d286211acbb9c2088b8a99630983691668d9eb4", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -10,23 +10,23 @@ export is_test_ignored;\n \n type test_props = {\n     // Lines that should be expected, in order, on standard out\n-    error_patterns: [str],\n+    error_patterns: [str]/~,\n     // Extra flags to pass to the compiler\n     compile_flags: option<str>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n     pp_exact: option<str>,\n     // Modules from aux directory that should be compiled\n-    aux_builds: [str],\n+    aux_builds: [str]/~,\n     // Environment settings to use during execution\n-    exec_env: [(str,str)]\n+    exec_env: [(str,str)]/~\n };\n \n // Load any test directives embedded in the file\n fn load_props(testfile: str) -> test_props {\n-    let mut error_patterns = [];\n-    let mut aux_builds = [];\n-    let mut exec_env = [];\n+    let mut error_patterns = []/~;\n+    let mut aux_builds = []/~;\n+    let mut exec_env = []/~;\n     let mut compile_flags = option::none;\n     let mut pp_exact = option::none;\n     for iter_header(testfile) {|ln|"}, {"sha": "374ad1cda0857d0211ec7c8bd64d245cee867ed8", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -5,7 +5,7 @@ import libc::{c_int, pid_t};\n export run;\n \n #[cfg(target_os = \"win32\")]\n-fn target_env(lib_path: str, prog: str) -> [(str,str)] {\n+fn target_env(lib_path: str, prog: str) -> [(str,str)]/~ {\n \n     let mut env = os::env();\n \n@@ -27,16 +27,16 @@ fn target_env(lib_path: str, prog: str) -> [(str,str)] {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn target_env(_lib_path: str, _prog: str) -> [(str,str)] {\n-    []\n+fn target_env(_lib_path: str, _prog: str) -> [(str,str)]/~ {\n+    []/~\n }\n \n \n // FIXME (#2659): This code is duplicated in core::run::program_output\n fn run(lib_path: str,\n        prog: str,\n-       args: [str],\n-       env: [(str, str)],\n+       args: [str]/~,\n+       env: [(str, str)]/~,\n        input: option<str>) -> {status: int, out: str, err: str} {\n \n     let pipe_in = os::pipe();"}, {"sha": "7d33843c0d32b133b57a6b779ed7a602fe8f938a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -92,7 +92,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: str) {\n     let rounds =\n         alt props.pp_exact { option::some(_) { 1 } option::none { 2 } };\n \n-    let mut srcs = [result::get(io::read_whole_file_str(testfile))];\n+    let mut srcs = [result::get(io::read_whole_file_str(testfile))]/~;\n \n     let mut round = 0;\n     while round < rounds {\n@@ -139,12 +139,12 @@ fn run_pretty_test(config: config, props: test_props, testfile: str) {\n \n     fn print_source(config: config, testfile: str, src: str) -> procres {\n         compose_and_run(config, testfile, make_pp_args(config, testfile),\n-                        [], config.compile_lib_path, option::some(src))\n+                        []/~, config.compile_lib_path, option::some(src))\n     }\n \n     fn make_pp_args(config: config, _testfile: str) -> procargs {\n         let prog = config.rustc_path;\n-        let args = [\"-\", \"--pretty\", \"normal\"];\n+        let args = [\"-\", \"--pretty\", \"normal\"]/~;\n         ret {prog: prog, args: args};\n     }\n \n@@ -179,7 +179,7 @@ actual:\\n\\\n     fn make_typecheck_args(config: config, testfile: str) -> procargs {\n         let prog = config.rustc_path;\n         let mut args = [\"-\", \"--no-trans\", \"--lib\", \"-L\", config.build_base,\n-                        \"-L\", aux_output_dir_name(config, testfile)];\n+                        \"-L\", aux_output_dir_name(config, testfile)]/~;\n         args += split_maybe_args(config.rustcflags);\n         ret {prog: prog, args: args};\n     }\n@@ -227,7 +227,7 @@ fn check_error_patterns(props: test_props,\n     }\n }\n \n-fn check_expected_errors(expected_errors: [errors::expected_error],\n+fn check_expected_errors(expected_errors: [errors::expected_error]/~,\n                          testfile: str,\n                          procres: procres) {\n \n@@ -286,13 +286,13 @@ fn check_expected_errors(expected_errors: [errors::expected_error],\n     }\n }\n \n-type procargs = {prog: str, args: [str]};\n+type procargs = {prog: str, args: [str]/~};\n \n type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n \n fn compile_test(config: config, props: test_props,\n                 testfile: str) -> procres {\n-    let link_args = [\"-L\", aux_output_dir_name(config, testfile)];\n+    let link_args = [\"-L\", aux_output_dir_name(config, testfile)]/~;\n     compose_and_run_compiler(\n         config, props, testfile,\n         make_compile_args(config, props, link_args,\n@@ -319,14 +319,14 @@ fn compose_and_run_compiler(\n         ensure_dir(aux_output_dir_name(config, testfile));\n     }\n \n-    let extra_link_args = [\"-L\", aux_output_dir_name(config, testfile)];\n+    let extra_link_args = [\"-L\", aux_output_dir_name(config, testfile)]/~;\n \n     vec::iter(props.aux_builds) {|rel_ab|\n         let abs_ab = path::connect(config.aux_base, rel_ab);\n         let aux_args =\n-            make_compile_args(config, props, [\"--lib\"] + extra_link_args,\n+            make_compile_args(config, props, [\"--lib\"]/~ + extra_link_args,\n                               {|a,b|make_lib_name(a, b, testfile)}, abs_ab);\n-        let auxres = compose_and_run(config, abs_ab, aux_args, [],\n+        let auxres = compose_and_run(config, abs_ab, aux_args, []/~,\n                                      config.compile_lib_path, option::none);\n         if auxres.status != 0 {\n             fatal_procres(\n@@ -335,7 +335,7 @@ fn compose_and_run_compiler(\n         }\n     }\n \n-    compose_and_run(config, testfile, args, [],\n+    compose_and_run(config, testfile, args, []/~,\n                     config.compile_lib_path, input)\n }\n \n@@ -348,19 +348,19 @@ fn ensure_dir(path: path) {\n \n fn compose_and_run(config: config, testfile: str,\n                    procargs: procargs,\n-                   procenv: [(str, str)],\n+                   procenv: [(str, str)]/~,\n                    lib_path: str,\n                    input: option<str>) -> procres {\n     ret program_output(config, testfile, lib_path,\n                        procargs.prog, procargs.args, procenv, input);\n }\n \n-fn make_compile_args(config: config, props: test_props, extras: [str],\n+fn make_compile_args(config: config, props: test_props, extras: [str]/~,\n                      xform: fn(config, str) -> str, testfile: str) ->\n    procargs {\n     let prog = config.rustc_path;\n     let mut args = [testfile, \"-o\", xform(config, testfile),\n-                    \"-L\", config.build_base] + extras;\n+                    \"-L\", config.build_base]/~ + extras;\n     args += split_maybe_args(config.rustcflags);\n     args += split_maybe_args(props.compile_flags);\n     ret {prog: prog, args: args};\n@@ -390,12 +390,12 @@ fn make_run_args(config: config, _props: test_props, testfile: str) ->\n             split_maybe_args(runtool)\n         };\n \n-    let args = toolargs + [make_exe_name(config, testfile)];\n+    let args = toolargs + [make_exe_name(config, testfile)]/~;\n     ret {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n }\n \n-fn split_maybe_args(argstr: option<str>) -> [str] {\n-    fn rm_whitespace(v: [str]) -> [str] {\n+fn split_maybe_args(argstr: option<str>) -> [str]/~ {\n+    fn rm_whitespace(v: [str]/~) -> [str]/~ {\n         fn flt(&&s: str) -> option<str> {\n           if !str::is_whitespace(s) { option::some(s) } else { option::none }\n         }\n@@ -404,12 +404,12 @@ fn split_maybe_args(argstr: option<str>) -> [str] {\n \n     alt argstr {\n       option::some(s) { rm_whitespace(str::split_char(s, ' ')) }\n-      option::none { [] }\n+      option::none { []/~ }\n     }\n }\n \n fn program_output(config: config, testfile: str, lib_path: str, prog: str,\n-                  args: [str], env: [(str, str)],\n+                  args: [str]/~, env: [(str, str)]/~,\n                   input: option<str>) -> procres {\n     let cmdline =\n         {\n@@ -429,12 +429,12 @@ fn program_output(config: config, testfile: str, lib_path: str, prog: str,\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn make_cmdline(_libpath: str, prog: str, args: [str]) -> str {\n+fn make_cmdline(_libpath: str, prog: str, args: [str]/~) -> str {\n     #fmt[\"%s %s\", prog, str::connect(args, \" \")]\n }\n \n #[cfg(target_os = \"win32\")]\n-fn make_cmdline(libpath: str, prog: str, args: [str]) -> str {\n+fn make_cmdline(libpath: str, prog: str, args: [str]/~) -> str {\n     #fmt[\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n          str::connect(args, \" \")]\n }\n@@ -454,7 +454,7 @@ fn dump_output(config: config, testfile: str, out: str, err: str) {\n fn dump_output_file(config: config, testfile: str, out: str, extension: str) {\n     let outfile = make_out_name(config, testfile, extension);\n     let writer = result::get(\n-        io::file_writer(outfile, [io::create, io::truncate]));\n+        io::file_writer(outfile, [io::create, io::truncate]/~));\n     writer.write_str(out);\n }\n "}, {"sha": "3eee008d376ac298ec956f8c456a98db561e99ad", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -1,7 +1,7 @@\n use std;\n import vec;\n \n-fn vec_equal<T>(v: [T], u: [T],\n+fn vec_equal<T>(v: [T]/~, u: [T]/~,\n                 element_equality_test: fn@(&&T, &&T) -> bool) ->\n    bool {\n     let Lv = vec::len(v);\n@@ -20,11 +20,11 @@ pure fn builtin_equal_int(&&a: int, &&b: int) -> bool { ret a == b; }\n fn main() {\n     assert (builtin_equal(5, 5));\n     assert (!builtin_equal(5, 4));\n-    assert (!vec_equal([5, 5], [5], bind builtin_equal(_, _)));\n-    assert (!vec_equal([5, 5], [5], builtin_equal_int));\n-    assert (!vec_equal([5, 5], [5, 4], builtin_equal_int));\n-    assert (!vec_equal([5, 5], [4, 5], builtin_equal_int));\n-    assert (vec_equal([5, 5], [5, 5], builtin_equal_int));\n+    assert (!vec_equal([5, 5]/~, [5]/~, bind builtin_equal(_, _)));\n+    assert (!vec_equal([5, 5]/~, [5]/~, builtin_equal_int));\n+    assert (!vec_equal([5, 5]/~, [5, 4]/~, builtin_equal_int));\n+    assert (!vec_equal([5, 5]/~, [4, 5]/~, builtin_equal_int));\n+    assert (vec_equal([5, 5]/~, [5, 5]/~, builtin_equal_int));\n \n     #error(\"Pass\");\n }"}, {"sha": "6a456d39d708bbbcbb845b1b8c7f096d619e9d51", "filename": "src/fuzzer/cycles.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fcycles.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -8,7 +8,7 @@ fn under(r : rand::rng, n : uint) -> uint {\n }\n \n // random choice from a vec\n-fn choice<T: copy>(r : rand::rng, v : [const T]) -> T {\n+fn choice<T: copy>(r : rand::rng, v : [const T]/~) -> T {\n     assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n }\n \n@@ -32,8 +32,8 @@ type pointy = {\n     mut f : fn@()->(),\n     mut g : fn~()->(),\n \n-    mut m : [maybe_pointy],\n-    mut n : [mut maybe_pointy],\n+    mut m : [maybe_pointy]/~,\n+    mut n : [mut maybe_pointy]/~,\n     mut o : {x : int, y : maybe_pointy}\n };\n // To add: objects; ifaces; anything type-parameterized?\n@@ -47,8 +47,8 @@ fn empty_pointy() -> @pointy {\n         mut f : fn@()->(){},\n         mut g : fn~()->(){},\n \n-        mut m : [],\n-        mut n : [mut],\n+        mut m : []/~,\n+        mut n : [mut]/~,\n         mut o : {x : 0, y : none}\n     }\n }\n@@ -58,7 +58,7 @@ fn nop<T>(_x: T) { }\n \n fn test_cycles(r : rand::rng, k: uint, n: uint)\n {\n-    let v : [mut @pointy] = [mut];\n+    let v : [mut @pointy]/~ = [mut]/~;\n \n     // Create a graph with no edges\n     range(0u, vlen) {|_i|"}, {"sha": "d99a40018f1e31789f2e3e75408799679abf5b16", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -10,18 +10,18 @@ type context = { mode: test_mode }; // + rng\n \n fn write_file(filename: str, content: str) {\n     result::get(\n-        io::file_writer(filename, [io::create, io::truncate]))\n+        io::file_writer(filename, [io::create, io::truncate]/~))\n         .write_str(content);\n }\n \n fn contains(haystack: str, needle: str) -> bool {\n     str::contains(haystack, needle)\n }\n \n-fn find_rust_files(&files: [str], path: str) {\n+fn find_rust_files(&files: [str]/~, path: str) {\n     if str::ends_with(path, \".rs\") && !contains(path, \"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n-        files += [path];\n+        files += [path]/~;\n     } else if os::path_is_dir(path)\n         && !contains(path, \"compile-fail\")\n         && !contains(path, \"build\") {\n@@ -32,7 +32,7 @@ fn find_rust_files(&files: [str], path: str) {\n }\n \n \n-fn common_exprs() -> [ast::expr] {\n+fn common_exprs() -> [ast::expr]/~ {\n     fn dse(e: ast::expr_) -> ast::expr {\n         { id: 0, node: e, span: ast_util::dummy_sp() }\n     }\n@@ -54,7 +54,7 @@ fn common_exprs() -> [ast::expr] {\n                          @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n      dse(ast::expr_unary(ast::uniq(ast::m_imm),\n                          @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n-    ]\n+    ]/~\n }\n \n pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n@@ -116,28 +116,28 @@ fn safe_to_steal_ty(t: @ast::ty, tm: test_mode) -> bool {\n \n // Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n-                 es: @mut [ast::expr],\n+                 es: @mut [ast::expr]/~,\n                  e: @ast::expr,\n                  tm: test_mode) {\n     if c(e, tm) {\n-        *es += [*e];\n+        *es += [*e]/~;\n     } else {/* now my indices are wrong :( */ }\n }\n \n fn stash_ty_if(c: fn@(@ast::ty, test_mode)->bool,\n-               es: @mut [ast::ty],\n+               es: @mut [ast::ty]/~,\n                e: @ast::ty,\n                tm: test_mode) {\n     if c(e, tm) {\n         vec::push(*es,*e);\n     } else {/* now my indices are wrong :( */ }\n }\n \n-type stolen_stuff = {exprs: [ast::expr], tys: [ast::ty]};\n+type stolen_stuff = {exprs: [ast::expr]/~, tys: [ast::ty]/~};\n \n fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n-    let exprs = @mut [];\n-    let tys = @mut [];\n+    let exprs = @mut []/~;\n+    let tys = @mut []/~;\n     let v = visit::mk_simple_visitor(@{\n         visit_expr: {|a|stash_expr_if(safe_to_steal_expr, exprs, a, tm)},\n         visit_ty: {|a|stash_ty_if(safe_to_steal_ty, tys, a, tm)}\n@@ -248,7 +248,7 @@ fn check_variants_T<T: copy>(\n   codemap: codemap::codemap,\n   filename: str,\n   thing_label: str,\n-  things: [T],\n+  things: [T]/~,\n   stringifier: fn@(@T) -> str,\n   replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n   cx: context\n@@ -333,19 +333,19 @@ fn check_whole_compiler(code: str, suggested_filename_prefix: str,\n fn removeIfExists(filename: str) {\n     // So sketchy!\n     assert !contains(filename, \" \");\n-    run::program_output(\"bash\", [\"-c\", \"rm \" + filename]);\n+    run::program_output(\"bash\", [\"-c\", \"rm \" + filename]/~);\n }\n \n fn removeDirIfExists(filename: str) {\n     // So sketchy!\n     assert !contains(filename, \" \");\n-    run::program_output(\"bash\", [\"-c\", \"rm -r \" + filename]);\n+    run::program_output(\"bash\", [\"-c\", \"rm -r \" + filename]/~);\n }\n \n fn check_running(exe_filename: str) -> happiness {\n     let p = run::program_output(\n         \"/Users/jruderman/scripts/timed_run_rust_program.py\",\n-        [exe_filename]);\n+        [exe_filename]/~);\n     let comb = p.out + \"\\n\" + p.err;\n     if str::len(comb) > 1u {\n         log(error, \"comb comb comb: \" + comb);\n@@ -385,7 +385,7 @@ fn check_compiling(filename: str) -> happiness {\n     let p = run::program_output(\n         \"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n          stage1/bin/rustc\",\n-        [filename]);\n+        [filename]/~);\n \n     //#error(\"Status: %d\", p.status);\n     if p.status == 0 {\n@@ -419,7 +419,7 @@ fn parse_and_print(code: @str) -> str {\n     let sess = parse::new_parse_sess(option::none);\n     write_file(filename, *code);\n     let crate = parse::parse_crate_from_source_str(\n-        filename, code, [], sess);\n+        filename, code, []/~, sess);\n     io::with_str_reader(*code) { |rdr|\n         as_str({|a|pprust::print_crate(sess.cm,\n                                         sess.span_diagnostic,\n@@ -451,15 +451,15 @@ fn content_is_dangerous_to_run(code: str) -> bool {\n          \"import\",  // espeically fs, run\n          \"native\",\n          \"unsafe\",\n-         \"log\"];    // python --> rust pipe deadlock?\n+         \"log\"]/~;    // python --> rust pipe deadlock?\n \n     for dangerous_patterns.each {|p| if contains(code, p) { ret true; } }\n     ret false;\n }\n \n fn content_is_dangerous_to_compile(code: str) -> bool {\n     let dangerous_patterns =\n-        [\"xfail-test\"];\n+        [\"xfail-test\"]/~;\n \n     for dangerous_patterns.each {|p| if contains(code, p) { ret true; } }\n     ret false;\n@@ -475,7 +475,7 @@ fn content_might_not_converge(code: str) -> bool {\n          \" be \",       // don't want to replace its child with a non-call:\n                        // \"Non-call expression in tail call\"\n          \"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n-        ];\n+        ]/~;\n \n     for confusing_patterns.each {|p| if contains(code, p) { ret true; } }\n     ret false;\n@@ -488,7 +488,7 @@ fn file_might_not_converge(filename: str) -> bool {\n       \"block-arg-in-ternary.rs\", // wrapping\n       \"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n       \"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n-    ];\n+    ]/~;\n \n \n     for confusing_files.each {|f| if contains(filename, f) { ret true; } }\n@@ -518,12 +518,12 @@ fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n         write_file(\"round-trip-b.rs\", *newv);\n         run::run_program(\"diff\",\n                          [\"-w\", \"-u\", \"round-trip-a.rs\",\n-                          \"round-trip-b.rs\"]);\n+                          \"round-trip-b.rs\"]/~);\n         fail \"Mismatch\";\n     }\n }\n \n-fn check_convergence(files: [str]) {\n+fn check_convergence(files: [str]/~) {\n     #error(\"pp convergence tests: %u files\", vec::len(files));\n     for files.each {|file|\n         if !file_might_not_converge(file) {\n@@ -538,7 +538,7 @@ fn check_convergence(files: [str]) {\n     }\n }\n \n-fn check_variants(files: [str], cx: context) {\n+fn check_variants(files: [str]/~, cx: context) {\n     for files.each {|file|\n         if cx.mode == tm_converge && file_might_not_converge(file) {\n             #error(\"Skipping convergence test based on\\\n@@ -562,7 +562,7 @@ fn check_variants(files: [str], cx: context) {\n         let crate =\n             parse::parse_crate_from_source_str(\n                 file,\n-                s, [], sess);\n+                s, []/~, sess);\n         io::with_str_reader(*s) { |rdr|\n             #error(\"%s\",\n                    as_str({|a|pprust::print_crate(sess.cm,\n@@ -576,12 +576,12 @@ fn check_variants(files: [str], cx: context) {\n     }\n }\n \n-fn main(args: [str]) {\n+fn main(args: [str]/~) {\n     if vec::len(args) != 2u {\n         #error(\"usage: %s <testdir>\", args[0]);\n         ret;\n     }\n-    let mut files = [];\n+    let mut files = []/~;\n     let root = args[1];\n \n     find_rust_files(files, root);"}, {"sha": "0f5e95a7d73a64d810e99526704fe53e9ea5013a", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -8,8 +8,8 @@ Idea: provide functions for 'exhaustive' and 'random' modification of vecs.\n \n It would be nice if this could be data-driven, so the two functions\n could share information:\n-  type vec_modifier = rec(fn (<T> v, uint i) -> [T] fun, uint lo, uint di);\n-  const [vec_modifier] vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...];\n+  type vec_modifier = rec(fn (<T> v, uint i) -> [T]/~ fun, uint lo, uint di);\n+  const [vec_modifier]/~ vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...]/~;\n But that gives me \"error: internal compiler error unimplemented consts\n that's not a plain literal\".\n https://github.com/graydon/rust/issues/570\n@@ -24,23 +24,23 @@ import vec::slice;\n import vec::len;\n import int;\n \n-fn vec_omit<T: copy>(v: [T], i: uint) -> [T] {\n+fn vec_omit<T: copy>(v: [T]/~, i: uint) -> [T]/~ {\n     slice(v, 0u, i) + slice(v, i + 1u, len(v))\n }\n-fn vec_dup<T: copy>(v: [T], i: uint) -> [T] {\n+fn vec_dup<T: copy>(v: [T]/~, i: uint) -> [T]/~ {\n     slice(v, 0u, i) + [v[i]] + slice(v, i, len(v))\n }\n-fn vec_swadj<T: copy>(v: [T], i: uint) -> [T] {\n+fn vec_swadj<T: copy>(v: [T]/~, i: uint) -> [T]/~ {\n     slice(v, 0u, i) + [v[i + 1u], v[i]] + slice(v, i + 2u, len(v))\n }\n-fn vec_prefix<T: copy>(v: [T], i: uint) -> [T] { slice(v, 0u, i) }\n-fn vec_suffix<T: copy>(v: [T], i: uint) -> [T] { slice(v, i, len(v)) }\n+fn vec_prefix<T: copy>(v: [T]/~, i: uint) -> [T]/~ { slice(v, 0u, i) }\n+fn vec_suffix<T: copy>(v: [T]/~, i: uint) -> [T]/~ { slice(v, i, len(v)) }\n \n-fn vec_poke<T: copy>(v: [T], i: uint, x: T) -> [T] {\n-    slice(v, 0u, i) + [x] + slice(v, i + 1u, len(v))\n+fn vec_poke<T: copy>(v: [T]/~, i: uint, x: T) -> [T]/~ {\n+    slice(v, 0u, i) + [x]/~ + slice(v, i + 1u, len(v))\n }\n-fn vec_insert<T: copy>(v: [T], i: uint, x: T) -> [T] {\n-    slice(v, 0u, i) + [x] + slice(v, i, len(v))\n+fn vec_insert<T: copy>(v: [T]/~, i: uint, x: T) -> [T]/~ {\n+    slice(v, 0u, i) + [x]/~ + slice(v, i, len(v))\n }\n \n // Iterates over 0...length, skipping the specified number on each side.\n@@ -51,23 +51,23 @@ fn ix(skip_low: uint, skip_high: uint, length: uint, it: block(uint)) {\n \n // Returns a bunch of modified versions of v, some of which introduce\n // new elements (borrowed from xs).\n-fn vec_edits<T: copy>(v: [T], xs: [T]) -> [[T]] {\n-    let edits: [[T]] = [];\n+fn vec_edits<T: copy>(v: [T]/~, xs: [T]/~) -> [[T]/~]/~ {\n+    let edits: [[T]/~]/~ = []/~;\n     let Lv: uint = len(v);\n \n     if Lv != 1u {\n         // When Lv == 1u, this is redundant with omit.\n-        vec::push(edits, []);\n+        vec::push(edits, []/~);\n     }\n     if Lv >= 3u {\n         // When Lv == 2u, this is redundant with swap.\n         vec::push(edits, vec::reversed(v));\n     }\n-    ix(0u, 1u, Lv) {|i| edits += [vec_omit(v, i)]; }\n-    ix(0u, 1u, Lv) {|i| edits += [vec_dup(v, i)]; }\n-    ix(0u, 2u, Lv) {|i| edits += [vec_swadj(v, i)]; }\n-    ix(1u, 2u, Lv) {|i| edits += [vec_prefix(v, i)]; }\n-    ix(2u, 1u, Lv) {|i| edits += [vec_suffix(v, i)]; }\n+    ix(0u, 1u, Lv) {|i| edits += [vec_omit(v, i)]/~; }\n+    ix(0u, 1u, Lv) {|i| edits += [vec_dup(v, i)]/~; }\n+    ix(0u, 2u, Lv) {|i| edits += [vec_swadj(v, i)]/~; }\n+    ix(1u, 2u, Lv) {|i| edits += [vec_prefix(v, i)]/~; }\n+    ix(2u, 1u, Lv) {|i| edits += [vec_suffix(v, i)]/~; }\n \n     ix(0u, 1u, len(xs)) {|j|\n         ix(0u, 1u, Lv) {|i|\n@@ -83,7 +83,7 @@ fn vec_edits<T: copy>(v: [T], xs: [T]) -> [[T]] {\n \n // Would be nice if this were built in:\n // https://github.com/graydon/rust/issues/424\n-fn vec_to_str(v: [int]) -> str {\n+fn vec_to_str(v: [int]/~) -> str {\n     let i = 0u;\n     let s = \"[\";\n     while i < len(v) {\n@@ -94,19 +94,19 @@ fn vec_to_str(v: [int]) -> str {\n     ret s + \"]\";\n }\n \n-fn show_edits(a: [int], xs: [int]) {\n+fn show_edits(a: [int]/~, xs: [int]/~) {\n     log(error, \"=== Edits of \" + vec_to_str(a) + \" ===\");\n     let b = vec_edits(a, xs);\n     ix(0u, 1u, len(b)) {|i| log(error, vec_to_str(b[i])); }\n }\n \n fn demo_edits() {\n-    let xs = [7, 8];\n-    show_edits([], xs);\n-    show_edits([1], xs);\n-    show_edits([1, 2], xs);\n-    show_edits([1, 2, 3], xs);\n-    show_edits([1, 2, 3, 4], xs);\n+    let xs = [7, 8]/~;\n+    show_edits([]/~, xs);\n+    show_edits([1]/~, xs);\n+    show_edits([1, 2]/~, xs);\n+    show_edits([1, 2, 3]/~, xs);\n+    show_edits([1, 2, 3, 4]/~, xs);\n }\n \n fn main() { demo_edits(); }"}, {"sha": "1ef3d140c22941696e8886f638e2b5c0302a3d74", "filename": "src/fuzzer/rand_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ffuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Frand_util.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -8,15 +8,15 @@ fn under(r : rand::rng, n : uint) -> uint {\n }\n \n // random choice from a vec\n-fn choice<T: copy>(r : rand::rng, v : [T]) -> T {\n+fn choice<T: copy>(r : rand::rng, v : [T]/~) -> T {\n     assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n }\n \n // 1 in n chance of being true\n fn unlikely(r : rand::rng, n : uint) -> bool { under(r, n) == 0u }\n \n // shuffle a vec in place\n-fn shuffle<T>(r : rand::rng, &v : [mut T]) {\n+fn shuffle<T>(r : rand::rng, &v : [mut T]/~) {\n     let i = vec::len(v);\n     while i >= 2u {\n         // Loop invariant: elements with index >= i have been locked in place.\n@@ -26,20 +26,20 @@ fn shuffle<T>(r : rand::rng, &v : [mut T]) {\n }\n \n // create a shuffled copy of a vec\n-fn shuffled<T: copy>(r : rand::rng, v : [T]) -> [T] {\n+fn shuffled<T: copy>(r : rand::rng, v : [T]/~) -> [T]/~ {\n     let w = vec::to_mut(v);\n     shuffle(r, w);\n     vec::from_mut(w) // Shouldn't this happen automatically?\n }\n \n // sample from a population without replacement\n-//fn sample<T>(r : rand::rng, pop : [T], k : uint) -> [T] { fail }\n+//fn sample<T>(r : rand::rng, pop : [T]/~, k : uint) -> [T]/~ { fail }\n \n // Two ways to make a weighted choice.\n // * weighted_choice is O(number of choices) time\n // * weighted_vec is O(total weight) space\n type weighted<T> = { weight: uint, item: T };\n-fn weighted_choice<T: copy>(r : rand::rng, v : [weighted<T>]) -> T {\n+fn weighted_choice<T: copy>(r : rand::rng, v : [weighted<T>]/~) -> T {\n     assert vec::len(v) != 0u;\n     let total = 0u;\n     for {weight: weight, item: _} in v {\n@@ -57,8 +57,8 @@ fn weighted_choice<T: copy>(r : rand::rng, v : [weighted<T>]) -> T {\n     core::unreachable();\n }\n \n-fn weighted_vec<T: copy>(v : [weighted<T>]) -> [T] {\n-    let r = [];\n+fn weighted_vec<T: copy>(v : [weighted<T>]/~) -> [T]/~ {\n+    let r = []/~;\n     for {weight: weight, item: item} in v {\n         let i = 0u;\n         while i < weight {\n@@ -74,10 +74,10 @@ fn main()\n     let r = rand::mk_rng();\n \n     log(error, under(r, 5u));\n-    log(error, choice(r, [10, 20, 30]));\n+    log(error, choice(r, [10, 20, 30]/~));\n     log(error, if unlikely(r, 5u) { \"unlikely\" } else { \"likely\" });\n \n-    let a = [mut 1, 2, 3];\n+    let a = [mut 1, 2, 3]/~;\n     shuffle(r, a);\n     log(error, a);\n \n@@ -86,7 +86,7 @@ fn main()\n         {weight:1u, item:\"low\"},\n         {weight:8u, item:\"middle\"},\n         {weight:1u, item:\"high\"}\n-    ];\n+    ]/~;\n     let w = weighted_vec(v);\n \n     while i < 1000u {"}, {"sha": "f13a34d260e52ef7f8cbd15193366faa72d19437", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -170,7 +170,7 @@ mod tests {\n \n     #[test]\n     fn manually_share_arc() {\n-        let v = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let v = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]/~;\n         let arc_v = arc::arc(v);\n \n         let p = port();\n@@ -182,7 +182,7 @@ mod tests {\n \n             let arc_v = p.recv();\n \n-            let v = *arc::get::<[int]>(&arc_v);\n+            let v = *arc::get::<[int]/~>(&arc_v);\n             assert v[3] == 4;\n         };\n \n@@ -196,7 +196,7 @@ mod tests {\n \n     #[test]\n     fn auto_share_arc() {\n-        let v = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let v = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]/~;\n         let (_res, arc_c) = shared_arc(v);\n \n         let p = port();\n@@ -216,7 +216,7 @@ mod tests {\n     #[test]\n     #[ignore] // this can probably infinite loop too.\n     fn exclusive_arc() {\n-        let mut futures = [];\n+        let mut futures = []/~;\n \n         let num_tasks = 10u;\n         let count = 1000u;\n@@ -231,7 +231,7 @@ mod tests {\n                         **count += 1u;\n                     }\n                 }\n-            })];\n+            })]/~;\n         };\n \n         for futures.each {|f| f.get() };"}, {"sha": "ffead7a523b95c73ae655bc73e5f12cf03423d31", "filename": "src/libcore/char.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -65,7 +65,7 @@ pure fn is_uppercase(c: char) -> bool {\n #[doc = \"\n Indicates whether a character is whitespace, defined in\n terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n-additional 'Cc'-category control codes in the range [0x09, 0x0d]\n+additional 'Cc'-category control codes in the range [0x09, 0x0d]/~\n \"]\n pure fn is_whitespace(c: char) -> bool {\n     ret ('\\x09' <= c && c <= '\\x0d')\n@@ -128,8 +128,8 @@ Return the hexadecimal unicode escape of a char.\n \n The rules are as follows:\n \n-  - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n-  - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n+  - chars in [0,0xff]/~ get 2-digit escapes: `\\\\xNN`\n+  - chars in [0x100,0xffff]/~ get 4-digit escapes: `\\\\uNNNN`\n   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n \"]\n fn escape_unicode(c: char) -> str {\n@@ -154,7 +154,7 @@ languages. The exact rules are:\n \n   - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n   - Single-quote, double-quote and backslash chars are backslash-escaped.\n-  - Any other chars in the range [0x20,0x7e] are not escaped.\n+  - Any other chars in the range [0x20,0x7e]/~ are not escaped.\n   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n \"]\n fn escape_default(c: char) -> str {"}, {"sha": "4a01ccea3241e63b94e4333fc4d071742b0c044f", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -217,7 +217,7 @@ fn peek_(p: *rust_port) -> bool {\n #[doc = \"Receive on one of two ports\"]\n fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n     -> either<A, B> {\n-    let ports = [(**p_a).po, (**p_b).po];\n+    let ports = [(**p_a).po, (**p_b).po]/~;\n     let n_ports = 2 as libc::size_t;\n     let yield = 0u, yieldp = ptr::addr_of(yield);\n "}, {"sha": "c94d0dc718b0732b4cad58ad798cd668323f2ab0", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -32,7 +32,7 @@ may permit read-only access during iteration or other use.\n # WARNING\n \n For maximum performance, this type is implemented using some rather\n-unsafe code.  In particular, this innocent looking `[mut A]` pointer\n+unsafe code.  In particular, this innocent looking `[mut A]/~` pointer\n *may be null!*  Therefore, it is important you not reach into the\n data structure manually but instead use the provided extensions.\n \n@@ -48,27 +48,26 @@ type could only produce 47 million pushes/second.\n \n \"]\n type dvec<A> = {\n-\n-    mut data: [mut A]\n+    mut data: [mut A]/~\n };\n \n #[doc = \"Creates a new, empty dvec\"]\n fn dvec<A>() -> dvec<A> {\n-    {mut data: [mut]}\n+    {mut data: [mut]/~}\n }\n \n #[doc = \"Creates a new dvec with a single element\"]\n fn from_elt<A>(+e: A) -> dvec<A> {\n-    {mut data: [mut e]}\n+    {mut data: [mut e]/~}\n }\n \n #[doc = \"Creates a new dvec with the contents of a vector\"]\n-fn from_vec<A>(+v: [mut A]) -> dvec<A> {\n+fn from_vec<A>(+v: [mut A]/~) -> dvec<A> {\n     {mut data: v}\n }\n \n #[doc = \"Consumes the vector and returns its contents\"]\n-fn unwrap<A>(-d: dvec<A>) -> [mut A] {\n+fn unwrap<A>(-d: dvec<A>) -> [mut A]/~ {\n     let {data: v} <- d;\n     ret v;\n }\n@@ -84,7 +83,7 @@ impl private_methods<A> for dvec<A> {\n     }\n \n     #[inline(always)]\n-    fn borrow<B>(f: fn(-[mut A]) -> B) -> B {\n+    fn borrow<B>(f: fn(-[mut A]/~) -> B) -> B {\n         unsafe {\n             let mut data = unsafe::reinterpret_cast(null::<()>());\n             data <-> self.data;\n@@ -95,7 +94,7 @@ impl private_methods<A> for dvec<A> {\n     }\n \n     #[inline(always)]\n-    fn return(-data: [mut A]) {\n+    fn return(-data: [mut A]/~) {\n         unsafe {\n             self.data <- data;\n         }\n@@ -114,7 +113,7 @@ impl extensions<A> for dvec<A> {\n \n     \"]\n     #[inline(always)]\n-    fn swap(f: fn(-[mut A]) -> [mut A]) {\n+    fn swap(f: fn(-[mut A]/~) -> [mut A]/~) {\n         self.borrow { |v| self.return(f(v)) }\n     }\n \n@@ -128,7 +127,7 @@ impl extensions<A> for dvec<A> {\n     }\n \n     #[doc = \"Overwrite the current contents\"]\n-    fn set(+w: [mut A]) {\n+    fn set(+w: [mut A]/~) {\n         self.check_not_borrowed();\n         self.data <- w;\n     }\n@@ -151,7 +150,7 @@ impl extensions<A> for dvec<A> {\n             let data_ptr: *() = unsafe::reinterpret_cast(data);\n             if data_ptr.is_null() { fail \"Recursive use of dvec\"; }\n             log(error, \"a\");\n-            self.data <- [mut t] + data;\n+            self.data <- [mut t]/~ + data;\n             log(error, \"b\");\n         }\n     }\n@@ -219,7 +218,7 @@ impl extensions<A:copy> for dvec<A> {\n             }\n            };\n \n-           for ts.each { |t| v += [t] };\n+           for ts.each { |t| v += [t]/~ };\n            v\n         }\n     }\n@@ -229,7 +228,7 @@ impl extensions<A:copy> for dvec<A> {\n \n         See `unwrap()` if you do not wish to copy the contents.\n     \"]\n-    fn get() -> [A] {\n+    fn get() -> [A]/~ {\n         self.borrow { |v|\n             let w = vec::from_mut(copy v);\n             self.return(v);\n@@ -271,4 +270,4 @@ impl extensions<A:copy> for dvec<A> {\n     fn last() -> A {\n         self.get_elt(self.len() - 1u)\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "564966c1493f75024ee5e7e5d264c33c94b4ab40", "filename": "src/libcore/either.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -21,39 +21,39 @@ fn either<T, U, V>(f_left: fn(T) -> V,\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n-fn lefts<T: copy, U>(eithers: [either<T, U>]) -> [T] {\n+fn lefts<T: copy, U>(eithers: [either<T, U>]/~) -> [T]/~ {\n     #[doc = \"Extracts from a vector of either all the left values\"];\n \n-    let mut result: [T] = [];\n+    let mut result: [T]/~ = []/~;\n     for vec::each(eithers) {|elt|\n-        alt elt { left(l) { result += [l]; } _ {/* fallthrough */ } }\n+        alt elt { left(l) { result += [l]/~; } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn rights<T, U: copy>(eithers: [either<T, U>]) -> [U] {\n+fn rights<T, U: copy>(eithers: [either<T, U>]/~) -> [U]/~ {\n     #[doc = \"Extracts from a vector of either all the right values\"];\n \n-    let mut result: [U] = [];\n+    let mut result: [U]/~ = []/~;\n     for vec::each(eithers) {|elt|\n-        alt elt { right(r) { result += [r]; } _ {/* fallthrough */ } }\n+        alt elt { right(r) { result += [r]/~; } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn partition<T: copy, U: copy>(eithers: [either<T, U>])\n-    -> {lefts: [T], rights: [U]} {\n+fn partition<T: copy, U: copy>(eithers: [either<T, U>]/~)\n+    -> {lefts: [T]/~, rights: [U]/~} {\n     #[doc = \"\n     Extracts from a vector of either all the left values and right values\n \n     Returns a structure containing a vector of left values and a vector of\n     right values.\n     \"];\n \n-    let mut lefts: [T] = [];\n-    let mut rights: [U] = [];\n+    let mut lefts: [T]/~ = []/~;\n+    let mut rights: [U]/~ = []/~;\n     for vec::each(eithers) {|elt|\n-        alt elt { left(l) { lefts += [l]; } right(r) { rights += [r]; } }\n+        alt elt { left(l) { lefts += [l]/~; } right(r) { rights += [r]/~; } }\n     }\n     ret {lefts: lefts, rights: rights};\n }\n@@ -112,49 +112,49 @@ fn test_either_right() {\n \n #[test]\n fn test_lefts() {\n-    let input = [left(10), right(11), left(12), right(13), left(14)];\n+    let input = [left(10), right(11), left(12), right(13), left(14)]/~;\n     let result = lefts(input);\n-    assert (result == [10, 12, 14]);\n+    assert (result == [10, 12, 14]/~);\n }\n \n #[test]\n fn test_lefts_none() {\n-    let input: [either<int, int>] = [right(10), right(10)];\n+    let input: [either<int, int>]/~ = [right(10), right(10)]/~;\n     let result = lefts(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_lefts_empty() {\n-    let input: [either<int, int>] = [];\n+    let input: [either<int, int>]/~ = []/~;\n     let result = lefts(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_rights() {\n-    let input = [left(10), right(11), left(12), right(13), left(14)];\n+    let input = [left(10), right(11), left(12), right(13), left(14)]/~;\n     let result = rights(input);\n-    assert (result == [11, 13]);\n+    assert (result == [11, 13]/~);\n }\n \n #[test]\n fn test_rights_none() {\n-    let input: [either<int, int>] = [left(10), left(10)];\n+    let input: [either<int, int>]/~ = [left(10), left(10)]/~;\n     let result = rights(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_rights_empty() {\n-    let input: [either<int, int>] = [];\n+    let input: [either<int, int>]/~ = []/~;\n     let result = rights(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_partition() {\n-    let input = [left(10), right(11), left(12), right(13), left(14)];\n+    let input = [left(10), right(11), left(12), right(13), left(14)]/~;\n     let result = partition(input);\n     assert (result.lefts[0] == 10);\n     assert (result.lefts[1] == 12);\n@@ -165,23 +165,23 @@ fn test_partition() {\n \n #[test]\n fn test_partition_no_lefts() {\n-    let input: [either<int, int>] = [right(10), right(11)];\n+    let input: [either<int, int>]/~ = [right(10), right(11)]/~;\n     let result = partition(input);\n     assert (vec::len(result.lefts) == 0u);\n     assert (vec::len(result.rights) == 2u);\n }\n \n #[test]\n fn test_partition_no_rights() {\n-    let input: [either<int, int>] = [left(10), left(11)];\n+    let input: [either<int, int>]/~ = [left(10), left(11)]/~;\n     let result = partition(input);\n     assert (vec::len(result.lefts) == 2u);\n     assert (vec::len(result.rights) == 0u);\n }\n \n #[test]\n fn test_partition_empty() {\n-    let input: [either<int, int>] = [];\n+    let input: [either<int, int>]/~ = []/~;\n     let result = partition(input);\n     assert (vec::len(result.lefts) == 0u);\n     assert (vec::len(result.rights) == 0u);"}, {"sha": "b1bb6d80a7aa34126737b6d3f51ee737391723ab", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -9,12 +9,12 @@ The 'fmt' extension is modeled on the posix printf system.\n \n A posix conversion ostensibly looks like this\n \n-> %[parameter][flags][width][.precision][length]type\n+> %[parameter]/~[flags]/~[width]/~[.precision]/~[length]/~type\n \n Given the different numeric type bestiary we have, we omit the 'length'\n parameter and support slightly different conversions for 'type'\n \n-> %[parameter][flags][width][.precision]type\n+> %[parameter]/~[flags]/~[width]/~[.precision]/~type\n \n we also only support translating-to-rust a tiny subset of the possible\n combinations at the moment.\n@@ -71,7 +71,7 @@ mod ct {\n     // A formatted conversion from an expression to a string\n     type conv =\n         {param: option<int>,\n-         flags: [flag],\n+         flags: [flag]/~,\n          width: count,\n          precision: count,\n          ty: ty};\n@@ -81,14 +81,14 @@ mod ct {\n     enum piece { piece_string(str), piece_conv(conv), }\n     type error_fn = fn@(str) -> ! ;\n \n-    fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n-        let mut pieces: [piece] = [];\n+    fn parse_fmt_string(s: str, error: error_fn) -> [piece]/~ {\n+        let mut pieces: [piece]/~ = []/~;\n         let lim = str::len(s);\n         let mut buf = \"\";\n-        fn flush_buf(buf: str, &pieces: [piece]) -> str {\n+        fn flush_buf(buf: str, &pieces: [piece]/~) -> str {\n             if str::len(buf) > 0u {\n                 let piece = piece_string(buf);\n-                pieces += [piece];\n+                pieces += [piece]/~;\n             }\n             ret \"\";\n         }\n@@ -108,7 +108,7 @@ mod ct {\n                 } else {\n                     buf = flush_buf(buf, pieces);\n                     let rs = parse_conversion(s, i, lim, error);\n-                    pieces += [rs.piece];\n+                    pieces += [rs.piece]/~;\n                     i = rs.next;\n                 }\n             } else { buf += curr; i += size; }\n@@ -162,16 +162,16 @@ mod ct {\n             };\n     }\n     fn parse_flags(s: str, i: uint, lim: uint) ->\n-       {flags: [flag], next: uint} {\n-        let noflags: [flag] = [];\n+       {flags: [flag]/~, next: uint} {\n+        let noflags: [flag]/~ = []/~;\n         if i >= lim { ret {flags: noflags, next: i}; }\n \n         fn more_(f: flag, s: str, i: uint, lim: uint) ->\n-           {flags: [flag], next: uint} {\n+           {flags: [flag]/~, next: uint} {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = next.flags;\n             let j = next.next;\n-            let curr: [flag] = [f];\n+            let curr: [flag]/~ = [f]/~;\n             ret {flags: curr + rest, next: j};\n         }\n         let more = {|x|more_(x, s, i, lim)};\n@@ -262,7 +262,7 @@ mod ct {\n // Functions used by the fmt extension at runtime. For now there are a lot of\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it this way, I think.\n+// implement it 0this way, I think.\n mod rt {\n     enum flag {\n         flag_left_justify,\n@@ -276,7 +276,7 @@ mod rt {\n \n     // FIXME (#1993): May not want to use a vector here for flags; instead\n     // just use a bool per flag.\n-    type conv = {flags: [flag], width: count, precision: count, ty: ty};\n+    type conv = {flags: [flag]/~, width: count, precision: count, ty: ty};\n \n     fn conv_int(cv: conv, i: int) -> str {\n         let radix = 10u;\n@@ -430,12 +430,13 @@ mod rt {\n         }\n         ret padstr + s;\n     }\n-    fn have_flag(flags: [flag], f: flag) -> bool {\n+    fn have_flag(flags: [flag]/~, f: flag) -> bool {\n         for vec::each(flags) {|candidate| if candidate == f { ret true; } }\n         ret false;\n     }\n }\n \n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "5f6da4c1674d77a66e6d7a20994a3a8fb8357b4e", "filename": "src/libcore/float.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -116,10 +116,10 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n     let mut frac = num - (trunc as float);\n \n     // stack of digits\n-    let mut fractionalParts = [];\n+    let mut fractionalParts = []/~;\n \n     // FIXME: (#2608)\n-    // This used to return right away without rounding, as \"[-]num\",\n+    // This used to return right away without rounding, as \"[-]/~num\",\n     // but given epsilon like in f64.rs, I don't see how the comparison\n     // to epsilon did much when only used there.\n     //    if (frac < epsilon && !exact) || digits == 0u { ret accum; }\n@@ -236,7 +236,7 @@ Leading and trailing whitespace are ignored.\n # Return value\n \n `none` if the string did not represent a valid number.  Otherwise, `some(n)`\n-where `n` is the floating-point number represented by `[num]`.\n+where `n` is the floating-point number represented by `[num]/~`.\n \"]\n fn from_str(num: str) -> option<float> {\n    if num == \"inf\" {\n@@ -261,7 +261,7 @@ fn from_str(num: str) -> option<float> {\n       _ { ret none; }\n    }\n \n-   //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n+   //Determine if first char is '-'/'+'. Set [pos]/~ and [neg]/~ accordingly.\n    let mut neg = false;               //Sign of the result\n    alt str::char_at(num, 0u) {\n       '-' {\n@@ -345,7 +345,7 @@ fn from_str(num: str) -> option<float> {\n              pos = char_range.next;\n           }\n           let multiplier = pow_with_uint(10u, exponent);\n-              //Note: not [int::pow], otherwise, we'll quickly\n+              //Note: not [int::pow]/~, otherwise, we'll quickly\n               //end up with a nice overflow\n           if neg_exponent {\n              total = total / multiplier;"}, {"sha": "5721ab750b4db64d810f02a47ada4e442f12dd64", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -66,7 +66,7 @@ Parse a buffer of bytes\n * buf - A byte buffer\n * radix - The base of the number\n \"]\n-fn parse_buf(buf: [u8], radix: uint) -> option<T> {\n+fn parse_buf(buf: [u8]/~, radix: uint) -> option<T> {\n     if vec::len(buf) == 0u { ret none; }\n     let mut i = vec::len(buf) - 1u;\n     let mut start = 0u;"}, {"sha": "2557b1253b749f356a92bc1f5af5272a28cacf2b", "filename": "src/libcore/int-template/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fint.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -11,7 +11,7 @@ pure fn hash(&&x: int) -> uint { ret x as uint; }\n \n #[doc = \"Returns `base` raised to the power of `exponent`\"]\n fn pow(base: int, exponent: uint) -> int {\n-    if exponent == 0u { ret 1; } //Not mathemtically true if [base == 0]\n+    if exponent == 0u { ret 1; } //Not mathemtically true if [base == 0]/~\n     if base     == 0  { ret 0; }\n     let mut my_pow  = exponent;\n     let mut acc     = 1;"}, {"sha": "ff7bdb2b2d6ddeec0c5c629f5d6b4dad03f48650", "filename": "src/libcore/io.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -30,7 +30,7 @@ enum seek_style { seek_set, seek_end, seek_cur, }\n // The raw underlying reader iface. All readers must implement this.\n iface reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n-    fn read_bytes(uint) -> [u8];\n+    fn read_bytes(uint) -> [u8]/~;\n     fn read_byte() -> int;\n     fn unread_byte(int);\n     fn eof() -> bool;\n@@ -41,9 +41,9 @@ iface reader {\n // Generic utility functions defined on readers\n \n impl reader_util for reader {\n-    fn read_chars(n: uint) -> [char] {\n+    fn read_chars(n: uint) -> [char]/~ {\n         // returns the (consumed offset, n_req), appends characters to &chars\n-        fn chars_from_buf(buf: [u8], &chars: [char]) -> (uint, uint) {\n+        fn chars_from_buf(buf: [u8]/~, &chars: [char]/~) -> (uint, uint) {\n             let mut i = 0u;\n             while i < vec::len(buf) {\n                 let b0 = buf[i];\n@@ -52,7 +52,7 @@ impl reader_util for reader {\n                 i += 1u;\n                 assert (w > 0u);\n                 if w == 1u {\n-                    chars += [ b0 as char ];\n+                    chars += [ b0 as char ]/~;\n                     cont;\n                 }\n                 // can't satisfy this char with the existing data\n@@ -71,12 +71,12 @@ impl reader_util for reader {\n                 // See str::char_at\n                 val += ((b0 << ((w + 1u) as u8)) as uint)\n                     << (w - 1u) * 6u - w - 1u;\n-                chars += [ val as char ];\n+                chars += [ val as char ]/~;\n             }\n             ret (i, 0u);\n         }\n-        let mut buf: [u8] = [];\n-        let mut chars: [char] = [];\n+        let mut buf: [u8]/~ = []/~;\n+        let mut chars: [char]/~ = []/~;\n         // might need more bytes, but reading n will never over-read\n         let mut nbread = n;\n         while nbread > 0u {\n@@ -110,20 +110,20 @@ impl reader_util for reader {\n     }\n \n     fn read_line() -> str {\n-        let mut buf: [u8] = [];\n+        let mut buf: [u8]/~ = []/~;\n         loop {\n             let ch = self.read_byte();\n             if ch == -1 || ch == 10 { break; }\n-            buf += [ch as u8];\n+            buf += [ch as u8]/~;\n         }\n         str::from_bytes(buf)\n     }\n \n     fn read_c_str() -> str {\n-        let mut buf: [u8] = [];\n+        let mut buf: [u8]/~ = []/~;\n         loop {\n             let ch = self.read_byte();\n-            if ch < 1 { break; } else { buf += [ch as u8]; }\n+            if ch < 1 { break; } else { buf += [ch as u8]/~; }\n         }\n         str::from_bytes(buf)\n     }\n@@ -156,8 +156,8 @@ impl reader_util for reader {\n         val\n     }\n \n-    fn read_whole_stream() -> [u8] {\n-        let mut buf: [u8] = [];\n+    fn read_whole_stream() -> [u8]/~ {\n+        let mut buf: [u8]/~ = []/~;\n         while !self.eof() { buf += self.read_bytes(2048u); }\n         buf\n     }\n@@ -192,8 +192,8 @@ fn convert_whence(whence: seek_style) -> i32 {\n }\n \n impl of reader for *libc::FILE {\n-    fn read_bytes(len: uint) -> [u8] {\n-        let mut buf : [mut u8] = [mut];\n+    fn read_bytes(len: uint) -> [u8]/~ {\n+        let mut buf : [mut u8]/~ = [mut]/~;\n         vec::reserve(buf, len);\n         vec::as_mut_buf(buf) {|b|\n             let read = libc::fread(b as *mut c_void, 1u as size_t,\n@@ -216,7 +216,7 @@ impl of reader for *libc::FILE {\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n impl <T: reader, C> of reader for {base: T, cleanup: C} {\n-    fn read_bytes(len: uint) -> [u8] { self.base.read_bytes(len) }\n+    fn read_bytes(len: uint) -> [u8]/~ { self.base.read_bytes(len) }\n     fn read_byte() -> int { self.base.read_byte() }\n     fn unread_byte(byte: int) { self.base.unread_byte(byte); }\n     fn eof() -> bool { self.base.eof() }\n@@ -260,10 +260,10 @@ fn file_reader(path: str) -> result<reader, str> {\n // Byte buffer readers\n \n // TODO: const u8, but this fails with rustboot.\n-type byte_buf = {buf: [u8], mut pos: uint, len: uint};\n+type byte_buf = {buf: [u8]/~, mut pos: uint, len: uint};\n \n impl of reader for byte_buf {\n-    fn read_bytes(len: uint) -> [u8] {\n+    fn read_bytes(len: uint) -> [u8]/~ {\n         let rest = self.len - self.pos;\n         let mut to_read = len;\n         if rest < to_read { to_read = rest; }\n@@ -286,19 +286,19 @@ impl of reader for byte_buf {\n     fn tell() -> uint { self.pos }\n }\n \n-fn bytes_reader(bytes: [u8]) -> reader {\n+fn bytes_reader(bytes: [u8]/~) -> reader {\n     bytes_reader_between(bytes, 0u, vec::len(bytes))\n }\n \n-fn bytes_reader_between(bytes: [u8], start: uint, end: uint) -> reader {\n+fn bytes_reader_between(bytes: [u8]/~, start: uint, end: uint) -> reader {\n     {buf: bytes, mut pos: start, len: end} as reader\n }\n \n-fn with_bytes_reader<t>(bytes: [u8], f: fn(reader) -> t) -> t {\n+fn with_bytes_reader<t>(bytes: [u8]/~, f: fn(reader) -> t) -> t {\n     f(bytes_reader(bytes))\n }\n \n-fn with_bytes_reader_between<t>(bytes: [u8], start: uint, end: uint,\n+fn with_bytes_reader_between<t>(bytes: [u8]/~, start: uint, end: uint,\n                                 f: fn(reader) -> t) -> t {\n     f(bytes_reader_between(bytes, start, end))\n }\n@@ -402,7 +402,7 @@ fn fd_writer(fd: fd_t, cleanup: bool) -> writer {\n }\n \n \n-fn mk_file_writer(path: str, flags: [fileflag])\n+fn mk_file_writer(path: str, flags: [fileflag]/~)\n     -> result<writer, str> {\n \n     #[cfg(windows)]\n@@ -451,9 +451,9 @@ fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn([u8]/&) -> T) -> T {\n               (n >> 56) as u8]/&) }\n       _ {\n \n-        let mut bytes: [u8] = [], i = size, n = n;\n+        let mut bytes: [u8]/~ = []/~, i = size, n = n;\n         while i > 0u {\n-            bytes += [(n & 255_u64) as u8];\n+            bytes += [(n & 255_u64) as u8]/~;\n             n >>= 8_u64;\n             i -= 1u;\n         }\n@@ -481,19 +481,19 @@ fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn([u8]/&) -> T) -> T {\n               (n >> 8) as u8,\n               n as u8]/&) }\n       _ {\n-        let mut bytes: [u8] = [];\n+        let mut bytes: [u8]/~ = []/~;\n         let mut i = size;\n         while i > 0u {\n             let shift = ((i - 1u) * 8u) as u64;\n-            bytes += [(n >> shift) as u8];\n+            bytes += [(n >> shift) as u8]/~;\n             i -= 1u;\n         }\n         f(bytes)\n       }\n     }\n }\n \n-fn u64_from_be_bytes(data: [u8], start: uint, size: uint) -> u64 {\n+fn u64_from_be_bytes(data: [u8]/~, start: uint, size: uint) -> u64 {\n     let mut sz = size;\n     assert (sz <= 8u);\n     let mut val = 0_u64;\n@@ -577,7 +577,7 @@ impl writer_util for writer {\n     fn write_u8(n: u8) { self.write([n]/&) }\n }\n \n-fn file_writer(path: str, flags: [fileflag]) -> result<writer, str> {\n+fn file_writer(path: str, flags: [fileflag]/~) -> result<writer, str> {\n     result::chain(mk_file_writer(path, flags), { |w| result::ok(w)})\n }\n \n@@ -638,7 +638,7 @@ fn mem_buffer() -> mem_buffer {\n     @{buf: dvec(), mut pos: 0u}\n }\n fn mem_buffer_writer(b: mem_buffer) -> writer { b as writer }\n-fn mem_buffer_buf(b: mem_buffer) -> [u8] { b.buf.get() }\n+fn mem_buffer_buf(b: mem_buffer) -> [u8]/~ { b.buf.get() }\n fn mem_buffer_str(b: mem_buffer) -> str {\n     str::from_bytes(b.buf.get())\n }\n@@ -650,7 +650,7 @@ fn with_str_writer(f: fn(writer)) -> str {\n     io::mem_buffer_str(buf)\n }\n \n-fn with_buf_writer(f: fn(writer)) -> [u8] {\n+fn with_buf_writer(f: fn(writer)) -> [u8]/~ {\n     let buf = mem_buffer();\n     let wr = mem_buffer_writer(buf);\n     f(wr);\n@@ -679,7 +679,7 @@ fn read_whole_file_str(file: str) -> result<str, str> {\n \n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n-fn read_whole_file(file: str) -> result<[u8], str> {\n+fn read_whole_file(file: str) -> result<[u8]/~, str> {\n     result::chain(file_reader(file), { |rdr|\n         result::ok(rdr.read_whole_stream())\n     })\n@@ -772,7 +772,7 @@ mod tests {\n         {\n             let out: io::writer =\n                 result::get(\n-                    io::file_writer(tmpfile, [io::create, io::truncate]));\n+                    io::file_writer(tmpfile, [io::create, io::truncate]/~));\n             out.write_str(frood);\n         }\n         let inp: io::reader = result::get(io::file_reader(tmpfile));\n@@ -784,22 +784,22 @@ mod tests {\n     #[test]\n     fn test_readchars_empty() {\n         let inp : io::reader = io::str_reader(\"\");\n-        let res : [char] = inp.read_chars(128u);\n+        let res : [char]/~ = inp.read_chars(128u);\n         assert(vec::len(res) == 0u);\n     }\n \n     #[test]\n     fn test_readchars_wide() {\n         let wide_test = \"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n-        let ivals : [int] = [\n+        let ivals : [int]/~ = [\n             29983, 38152, 30340, 27748,\n             21273, 20999, 32905, 27748,\n             104, 101, 108, 108, 111,\n             29983, 38152, 30340, 27748,\n-            21273, 20999, 32905, 27748];\n-        fn check_read_ln(len : uint, s: str, ivals: [int]) {\n+            21273, 20999, 32905, 27748]/~;\n+        fn check_read_ln(len : uint, s: str, ivals: [int]/~) {\n             let inp : io::reader = io::str_reader(s);\n-            let res : [char] = inp.read_chars(len);\n+            let res : [char]/~ = inp.read_chars(len);\n             if (len <= vec::len(ivals)) {\n                 assert(vec::len(res) == len);\n             }\n@@ -841,7 +841,7 @@ mod tests {\n \n     #[test]\n     fn file_writer_bad_name() {\n-        alt io::file_writer(\"?/?\", []) {\n+        alt io::file_writer(\"?/?\", []/~) {\n           result::err(e) {\n             assert str::starts_with(e, \"error opening ?/?\");\n           }\n@@ -862,16 +862,16 @@ mod tests {\n     #[test]\n     fn mem_buffer_overwrite() {\n         let mbuf = mem_buffer();\n-        mbuf.write([0u8, 1u8, 2u8, 3u8]);\n-        assert mem_buffer_buf(mbuf) == [0u8, 1u8, 2u8, 3u8];\n+        mbuf.write([0u8, 1u8, 2u8, 3u8]/~);\n+        assert mem_buffer_buf(mbuf) == [0u8, 1u8, 2u8, 3u8]/~;\n         mbuf.seek(-2, seek_cur);\n-        mbuf.write([4u8, 5u8, 6u8, 7u8]);\n-        assert mem_buffer_buf(mbuf) == [0u8, 1u8, 4u8, 5u8, 6u8, 7u8];\n+        mbuf.write([4u8, 5u8, 6u8, 7u8]/~);\n+        assert mem_buffer_buf(mbuf) == [0u8, 1u8, 4u8, 5u8, 6u8, 7u8]/~;\n         mbuf.seek(-2, seek_end);\n-        mbuf.write([8u8]);\n+        mbuf.write([8u8]/~);\n         mbuf.seek(1, seek_set);\n-        mbuf.write([9u8]);\n-        assert mem_buffer_buf(mbuf) == [0u8, 9u8, 4u8, 5u8, 8u8, 7u8];\n+        mbuf.write([9u8]/~);\n+        assert mem_buffer_buf(mbuf) == [0u8, 9u8, 4u8, 5u8, 8u8, 7u8]/~;\n     }\n }\n "}, {"sha": "59958e505a4696700dd51fadc1451a39fa0557e5", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -19,14 +19,14 @@ impl extensions<A> of iter::base_iter<A> for IMPL_T<A> {\n }\n \n impl extensions<A:copy> for IMPL_T<A> {\n-    fn filter_to_vec(pred: fn(A) -> bool) -> [A] {\n+    fn filter_to_vec(pred: fn(A) -> bool) -> [A]/~ {\n         iter::filter_to_vec(self, pred)\n     }\n-    fn map_to_vec<B>(op: fn(A) -> B) -> [B] { iter::map_to_vec(self, op) }\n-    fn to_vec() -> [A] { iter::to_vec(self) }\n+    fn map_to_vec<B>(op: fn(A) -> B) -> [B]/~ { iter::map_to_vec(self, op) }\n+    fn to_vec() -> [A]/~ { iter::to_vec(self) }\n \n     // FIXME--bug in resolve prevents this from working (#2611)\n-    // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> [B] {\n+    // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> [B]/~ {\n     //     iter::flat_map_to_vec(self, op)\n     // }\n "}, {"sha": "d6380a2968ae871fb0fa32501ae27a789b3a0651", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -26,17 +26,17 @@ fn any<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n }\n \n fn filter_to_vec<A:copy,IA:base_iter<A>>(self: IA,\n-                                         prd: fn(A) -> bool) -> [A] {\n-    let mut result = [];\n+                                         prd: fn(A) -> bool) -> [A]/~ {\n+    let mut result = []/~;\n     self.size_hint().iter {|hint| vec::reserve(result, hint); }\n     for self.each {|a|\n         if prd(a) { vec::push(result, a); }\n     }\n     ret result;\n }\n \n-fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> [B] {\n-    let mut result = [];\n+fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> [B]/~ {\n+    let mut result = []/~;\n     self.size_hint().iter {|hint| vec::reserve(result, hint); }\n     for self.each {|a|\n         vec::push(result, op(a));\n@@ -45,9 +45,9 @@ fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> [B] {\n }\n \n fn flat_map_to_vec<A:copy,B:copy,IA:base_iter<A>,IB:base_iter<B>>(\n-    self: IA, op: fn(A) -> IB) -> [B] {\n+    self: IA, op: fn(A) -> IB) -> [B]/~ {\n \n-    let mut result = [];\n+    let mut result = []/~;\n     for self.each {|a|\n         for op(a).each {|b|\n             vec::push(result, b);\n@@ -64,8 +64,8 @@ fn foldl<A,B,IA:base_iter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     ret b;\n }\n \n-fn to_vec<A:copy,IA:base_iter<A>>(self: IA) -> [A] {\n-    foldl::<A,[A],IA>(self, [], {|r, a| r + [a]})\n+fn to_vec<A:copy,IA:base_iter<A>>(self: IA) -> [A]/~ {\n+    foldl::<A,[A]/~,IA>(self, []/~, {|r, a| r + [a]/~})\n }\n \n fn contains<A,IA:base_iter<A>>(self: IA, x: A) -> bool {\n@@ -135,17 +135,17 @@ fn test_enumerate() {\n \n #[test]\n fn test_map_and_to_vec() {\n-    let a = bind vec::iter([0, 1, 2], _);\n+    let a = bind vec::iter([0, 1, 2]/~, _);\n     let b = bind map(a, {|i| 2*i}, _);\n     let c = to_vec(b);\n-    assert c == [0, 2, 4];\n+    assert c == [0, 2, 4]/~;\n }\n \n #[test]\n fn test_map_directly_on_vec() {\n-    let b = bind map([0, 1, 2], {|i| 2*i}, _);\n+    let b = bind map([0, 1, 2]/~, {|i| 2*i}, _);\n     let c = to_vec(b);\n-    assert c == [0, 2, 4];\n+    assert c == [0, 2, 4]/~;\n }\n \n #[test]\n@@ -155,7 +155,7 @@ fn test_filter_on_int_range() {\n     }\n \n     let l = to_vec(bind filter(bind int::range(0, 10, _), is_even, _));\n-    assert l == [0, 2, 4, 6, 8];\n+    assert l == [0, 2, 4, 6, 8]/~;\n }\n \n #[test]\n@@ -165,7 +165,7 @@ fn test_filter_on_uint_range() {\n     }\n \n     let l = to_vec(bind filter(bind uint::range(0u, 10u, _), is_even, _));\n-    assert l == [0u, 2u, 4u, 6u, 8u];\n+    assert l == [0u, 2u, 4u, 6u, 8u]/~;\n }\n \n #[test]\n@@ -180,7 +180,7 @@ fn test_filter_map() {\n \n     let l = to_vec(bind filter_map(\n         bind int::range(0, 5, _), negativate_the_evens, _));\n-    assert l == [0, -2, -4];\n+    assert l == [0, -2, -4]/~;\n }\n \n #[test]\n@@ -190,78 +190,78 @@ fn test_flat_map_with_option() {\n         else { none }\n     }\n \n-    let a = bind vec::iter([0, 1, 2], _);\n+    let a = bind vec::iter([0, 1, 2]/~, _);\n     let b = bind flat_map(a, if_even, _);\n     let c = to_vec(b);\n-    assert c == [0, 2];\n+    assert c == [0, 2]/~;\n }\n \n #[test]\n fn test_flat_map_with_list() {\n-    fn repeat(&&i: int) -> [int] {\n-        let mut r = [];\n-        int::range(0, i) {|_j| r += [i]; }\n+    fn repeat(&&i: int) -> [int]/~ {\n+        let mut r = []/~;\n+        int::range(0, i) {|_j| r += [i]/~; }\n         r\n     }\n \n-    let a = bind vec::iter([0, 1, 2, 3], _);\n+    let a = bind vec::iter([0, 1, 2, 3]/~, _);\n     let b = bind flat_map(a, repeat, _);\n     let c = to_vec(b);\n     #debug[\"c = %?\", c];\n-    assert c == [1, 2, 2, 3, 3, 3];\n+    assert c == [1, 2, 2, 3, 3, 3]/~;\n }\n \n #[test]\n fn test_repeat() {\n-    let mut c = [], i = 0u;\n+    let mut c = []/~, i = 0u;\n     repeat(5u) {||\n-        c += [(i * i)];\n+        c += [(i * i)]/~;\n         i += 1u;\n     };\n     #debug[\"c = %?\", c];\n-    assert c == [0u, 1u, 4u, 9u, 16u];\n+    assert c == [0u, 1u, 4u, 9u, 16u]/~;\n }\n \n #[test]\n fn test_min() {\n-    assert min([5, 4, 1, 2, 3]) == 1;\n+    assert min([5, 4, 1, 2, 3]/~) == 1;\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_min_empty() {\n-    min::<int, [int]>([]);\n+    min::<int, [int]/~>([]/~);\n }\n \n #[test]\n fn test_max() {\n-    assert max([1, 2, 4, 2, 3]) == 4;\n+    assert max([1, 2, 4, 2, 3]/~) == 4;\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_max_empty() {\n-    max::<int, [int]>([]);\n+    max::<int, [int]/~>([]/~);\n }\n \n #[test]\n fn test_reversed() {\n-    assert to_vec(bind reversed([1, 2, 3], _)) == [3, 2, 1];\n+    assert to_vec(bind reversed([1, 2, 3]/~, _)) == [3, 2, 1]/~;\n }\n \n #[test]\n fn test_count() {\n-    assert count([1, 2, 1, 2, 1], 1) == 3u;\n+    assert count([1, 2, 1, 2, 1]/~, 1) == 3u;\n }\n \n #[test]\n fn test_foldr() {\n     fn sub(&&a: int, &&b: int) -> int {\n         a - b\n     }\n-    let sum = foldr([1, 2, 3, 4], 0, sub);\n+    let sum = foldr([1, 2, 3, 4]/~, 0, sub);\n     assert sum == -2;\n }\n */"}, {"sha": "88608676d232c1b43ff0e4eeffe35c71d283a10c", "filename": "src/libcore/os.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -40,23 +40,23 @@ export walk_dir;\n export as_c_charp, fill_charp_buf;\n \n native mod rustrt {\n-    fn rust_env_pairs() -> [str];\n+    fn rust_env_pairs() -> [str]/~;\n     fn rust_getcwd() -> str;\n     fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n     fn rust_path_exists(path: *libc::c_char) -> c_int;\n-    fn rust_list_files(path: str) -> [str];\n+    fn rust_list_files(path: str) -> [str]/~;\n     fn rust_process_wait(handle: c_int) -> c_int;\n     fn last_os_error() -> str;\n     fn rust_set_exit_status(code: libc::intptr_t);\n }\n \n \n-fn env() -> [(str,str)] {\n-    let mut pairs = [];\n+fn env() -> [(str,str)]/~ {\n+    let mut pairs = []/~;\n     for vec::each(rustrt::rust_env_pairs()) {|p|\n         let vs = str::splitn_char(p, '=', 1u);\n         assert vec::len(vs) == 2u;\n-        pairs += [(vs[0], vs[1])];\n+        vec::push(pairs, (vs[0], vs[1]));\n     }\n     ret pairs;\n }\n@@ -116,7 +116,7 @@ mod win32 {\n     fn as_utf16_p<T>(s: str, f: fn(*u16) -> T) -> T {\n         let mut t = str::to_utf16(s);\n         // Null terminate before passing on.\n-        t += [0u16];\n+        t += [0u16]/~;\n         vec::as_buf(t, f)\n     }\n }\n@@ -373,7 +373,7 @@ fn self_exe_path() -> option<path> {\n             fill_charp_buf() {|buf, sz|\n                 let mib = [CTL_KERN as c_int,\n                            KERN_PROC as c_int,\n-                           KERN_PROC_PATHNAME as c_int, -1 as c_int];\n+                           KERN_PROC_PATHNAME as c_int, -1 as c_int]/~;\n                 sysctl(vec::unsafe::to_ptr(mib), vec::len(mib) as c_uint,\n                        buf as *mut c_void, ptr::mut_addr_of(sz),\n                        ptr::null(), 0u as size_t) == (0 as c_int)\n@@ -553,7 +553,7 @@ fn make_dir(p: path, mode: c_int) -> bool {\n }\n \n #[doc = \"Lists the contents of a directory\"]\n-fn list_dir(p: path) -> [str] {\n+fn list_dir(p: path) -> [str]/~ {\n \n     #[cfg(unix)]\n     fn star(p: str) -> str { p }\n@@ -579,7 +579,7 @@ Lists the contents of a directory\n \n This version prepends each entry with the directory.\n \"]\n-fn list_dir_path(p: path) -> [str] {\n+fn list_dir_path(p: path) -> [str]/~ {\n     let mut p = p;\n     let pl = str::len(p);\n     if pl == 0u || (p[pl - 1u] as char != path::consts::path_sep\n@@ -670,7 +670,7 @@ fn copy_file(from: path, to: path) -> bool {\n             fclose(istream);\n             ret false;\n         }\n-        let mut buf : [mut u8] = [mut];\n+        let mut buf : [mut u8]/~ = [mut]/~;\n         let bufsize = 8192u;\n         vec::reserve(buf, bufsize);\n         let mut done = false;\n@@ -978,7 +978,7 @@ mod tests {\n       };\n       assert (ostream as uint != 0u);\n       let s = \"hello\";\n-      let mut buf = vec::to_mut(str::bytes(s) + [0 as u8]);\n+      let mut buf = vec::to_mut(str::bytes(s) + [0 as u8]/~);\n       vec::as_mut_buf(buf) {|b|\n           assert (libc::fwrite(b as *c_void, 1u as size_t,\n                                (str::len(s) + 1u) as size_t, ostream)\n@@ -989,7 +989,7 @@ mod tests {\n         fail (#fmt(\"%s doesn't exist\", in));\n       }\n       assert(rs);\n-      let rslt = run::run_program(\"diff\", [in, out]);\n+      let rslt = run::run_program(\"diff\", [in, out]/~);\n       assert (rslt == 0);\n       assert (remove_file(in));\n       assert (remove_file(out));"}, {"sha": "e75f104bea4662a8fc993b50df1cfaddabed62e7", "filename": "src/libcore/path.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -127,7 +127,7 @@ Connects a vector of path segments into a single path.\n \n Inserts path separators as needed.\n \"]\n-fn connect_many(paths: [path]) -> path {\n+fn connect_many(paths: [path]/~) -> path {\n     ret if vec::len(paths) == 1u {\n         paths[0]\n     } else {\n@@ -144,7 +144,7 @@ each piece of the path. On Windows, if the path is absolute then\n the first element of the returned vector will be the drive letter\n followed by a colon.\n \"]\n-fn split(p: path) -> [path] {\n+fn split(p: path) -> [path]/~ {\n     str::split_nonempty(p, {|c|\n         c == consts::path_sep || c == consts::alt_path_sep\n     })\n@@ -234,7 +234,7 @@ fn normalize(p: path) -> path {\n \n     ret s;\n \n-    fn strip_dots(s: [path]) -> [path] {\n+    fn strip_dots(s: [path]/~) -> [path]/~ {\n         vec::filter_map(s, { |elem|\n             if elem == \".\" {\n                 option::none\n@@ -244,12 +244,12 @@ fn normalize(p: path) -> path {\n         })\n     }\n \n-    fn rollup_doubledots(s: [path]) -> [path] {\n+    fn rollup_doubledots(s: [path]/~) -> [path]/~ {\n         if vec::is_empty(s) {\n-            ret [];\n+            ret []/~;\n         }\n \n-        let mut t = [];\n+        let mut t = []/~;\n         let mut i = vec::len(s);\n         let mut skip = 0;\n         while i != 0u {\n@@ -258,15 +258,15 @@ fn normalize(p: path) -> path {\n                 skip += 1;\n             } else {\n                 if skip == 0 {\n-                    t += [s[i]];\n+                    vec::push(t, s[i]);\n                 } else {\n                     skip -= 1;\n                 }\n             }\n         }\n         let mut t = vec::reversed(t);\n         while skip > 0 {\n-            t += [\"..\"];\n+            vec::push(t, \"..\");\n             skip -= 1;\n         }\n         ret t;\n@@ -322,28 +322,28 @@ mod tests {\n     #[test]\n     fn split1() {\n         let actual = split(\"a\" + ps() + \"b\");\n-        let expected = [\"a\", \"b\"];\n+        let expected = [\"a\", \"b\"]/~;\n         assert actual == expected;\n     }\n \n     #[test]\n     fn split2() {\n         let actual = split(\"a\" + aps() + \"b\");\n-        let expected = [\"a\", \"b\"];\n+        let expected = [\"a\", \"b\"]/~;\n         assert actual == expected;\n     }\n \n     #[test]\n     fn split3() {\n         let actual = split(ps() + \"a\" + ps() + \"b\");\n-        let expected = [\"a\", \"b\"];\n+        let expected = [\"a\", \"b\"]/~;\n         assert actual == expected;\n     }\n \n     #[test]\n     fn split4() {\n         let actual = split(\"a\" + ps() + \"b\" + aps() + \"c\");\n-        let expected = [\"a\", \"b\", \"c\"];\n+        let expected = [\"a\", \"b\", \"c\"]/~;\n         assert actual == expected;\n     }\n "}, {"sha": "bda418d428cf3b566e5e19b75dbbd0565a34a2c3", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -149,8 +149,8 @@ fn test() {\n         assert (p.fst == 50);\n         assert (p.snd == 60);\n \n-        let v0 = [32000u16, 32001u16, 32002u16];\n-        let v1 = [0u16, 0u16, 0u16];\n+        let v0 = [32000u16, 32001u16, 32002u16]/~;\n+        let v1 = [0u16, 0u16, 0u16]/~;\n \n         ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 1u),\n                     ptr::offset(vec::unsafe::to_ptr(v0), 1u), 1u);\n@@ -185,7 +185,7 @@ fn test_buf_len() {\n     str::as_c_str(s0) {|p0|\n         str::as_c_str(s1) {|p1|\n             str::as_c_str(s2) {|p2|\n-                let v = [p0, p1, p2, null()];\n+                let v = [p0, p1, p2, null()]/~;\n                 vec::as_buf(v) {|vp|\n                     assert unsafe { buf_len(vp) } == 3u;\n                 }"}, {"sha": "e4cbd475c9a17a069331f00f5d2c4ba175cd26be", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -7,9 +7,9 @@ enum rctx {}\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn rand_seed() -> [u8];\n+    fn rand_seed() -> [u8]/~;\n     fn rand_new() -> *rctx;\n-    fn rand_new_seeded(seed: [u8]) -> *rctx;\n+    fn rand_new_seeded(seed: [u8]/~) -> *rctx;\n     fn rand_next(c: *rctx) -> u32;\n     fn rand_free(c: *rctx);\n }\n@@ -151,19 +151,19 @@ impl extensions for rng {\n     }\n \n     #[doc = \"Return a random byte string of the specified length\"]\n-    fn gen_bytes(len: uint) -> [u8] {\n+    fn gen_bytes(len: uint) -> [u8]/~ {\n         vec::from_fn(len) {|_i|\n             self.gen_u8()\n         }\n     }\n \n     #[doc = \"Choose an item randomly, failing if values is empty\"]\n-    fn choose<T:copy>(values: [T]) -> T {\n+    fn choose<T:copy>(values: [T]/~) -> T {\n         self.choose_option(values).get()\n     }\n \n     #[doc = \"Choose some(item) randomly, returning none if values is empty\"]\n-    fn choose_option<T:copy>(values: [T]) -> option<T> {\n+    fn choose_option<T:copy>(values: [T]/~) -> option<T> {\n         if values.is_empty() {\n             none\n         } else {\n@@ -173,13 +173,13 @@ impl extensions for rng {\n \n     #[doc = \"Choose an item respecting the relative weights, failing if \\\n              the sum of the weights is 0\"]\n-    fn choose_weighted<T: copy>(v : [weighted<T>]) -> T {\n+    fn choose_weighted<T: copy>(v : [weighted<T>]/~) -> T {\n         self.choose_weighted_option(v).get()\n     }\n \n     #[doc = \"Choose some(item) respecting the relative weights, returning \\\n              none if the sum of the weights is 0\"]\n-    fn choose_weighted_option<T:copy>(v: [weighted<T>]) -> option<T> {\n+    fn choose_weighted_option<T:copy>(v: [weighted<T>]/~) -> option<T> {\n         let mut total = 0u;\n         for v.each {|item|\n             total += item.weight;\n@@ -200,25 +200,25 @@ impl extensions for rng {\n \n     #[doc = \"Return a vec containing copies of the items, in order, where \\\n              the weight of the item determines how many copies there are\"]\n-    fn weighted_vec<T:copy>(v: [weighted<T>]) -> [T] {\n-        let mut r = [];\n+    fn weighted_vec<T:copy>(v: [weighted<T>]/~) -> [T]/~ {\n+        let mut r = []/~;\n         for v.each {|item|\n             for uint::range(0u, item.weight) {|_i|\n-                r += [item.item];\n+                r += [item.item]/~;\n             }\n         }\n         r\n     }\n \n     #[doc = \"Shuffle a vec\"]\n-    fn shuffle<T:copy>(values: [T]) -> [T] {\n+    fn shuffle<T:copy>(values: [T]/~) -> [T]/~ {\n         let mut m = vec::to_mut(values);\n         self.shuffle_mut(m);\n         ret vec::from_mut(m);\n     }\n \n     #[doc = \"Shuffle a mutable vec in place\"]\n-    fn shuffle_mut<T>(&&values: [mut T]) {\n+    fn shuffle_mut<T>(&&values: [mut T]/~) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place.\n@@ -241,7 +241,7 @@ impl of rng for @rand_res {\n }\n \n #[doc = \"Create a new random seed for seeded_rng\"]\n-fn seed() -> [u8] {\n+fn seed() -> [u8]/~ {\n     rustrt::rand_seed()\n }\n \n@@ -254,7 +254,7 @@ fn rng() -> rng {\n          generator constructed with a given seed will generate the same \\\n          sequence of values as all other generators constructed with the \\\n          same seed. The seed may be any length.\"]\n-fn seeded_rng(seed: [u8]) -> rng {\n+fn seeded_rng(seed: [u8]/~) -> rng {\n     @rand_res(rustrt::rand_new_seeded(seed)) as rng\n }\n \n@@ -301,15 +301,15 @@ mod tests {\n     #[test]\n     fn rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 bytes\n-        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n+        let seed = [2u8, 32u8, 4u8, 32u8, 51u8]/~;\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n         assert ra.gen_str(100u) == rb.gen_str(100u);\n     }\n \n     #[test]\n     fn rng_seeded_custom_seed2() {\n-        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n+        let seed = [2u8, 32u8, 4u8, 32u8, 51u8]/~;\n         let ra = rand::seeded_rng(seed);\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n@@ -387,55 +387,56 @@ mod tests {\n     #[test]\n     fn choose() {\n         let r = rand::rng();\n-        assert r.choose([1, 1, 1]) == 1;\n+        assert r.choose([1, 1, 1]/~) == 1;\n     }\n \n     #[test]\n     fn choose_option() {\n         let r = rand::rng();\n-        assert r.choose_option([]) == none::<int>;\n-        assert r.choose_option([1, 1, 1]) == some(1);\n+        assert r.choose_option([]/~) == none::<int>;\n+        assert r.choose_option([1, 1, 1]/~) == some(1);\n     }\n \n     #[test]\n     fn choose_weighted() {\n         let r = rand::rng();\n-        assert r.choose_weighted([{weight: 1u, item: 42}]) == 42;\n+        assert r.choose_weighted([{weight: 1u, item: 42}]/~) == 42;\n         assert r.choose_weighted([\n             {weight: 0u, item: 42},\n             {weight: 1u, item: 43}\n-        ]) == 43;\n+        ]/~) == 43;\n     }\n \n     #[test]\n     fn choose_weighted_option() {\n         let r = rand::rng();\n-        assert r.choose_weighted_option([{weight: 1u, item: 42}]) == some(42);\n+        assert r.choose_weighted_option([{weight: 1u, item: 42}]/~) ==\n+               some(42);\n         assert r.choose_weighted_option([\n             {weight: 0u, item: 42},\n             {weight: 1u, item: 43}\n-        ]) == some(43);\n-        assert r.choose_weighted_option([]) == none::<int>;\n+        ]/~) == some(43);\n+        assert r.choose_weighted_option([]/~) == none::<int>;\n     }\n \n     #[test]\n     fn weighted_vec() {\n         let r = rand::rng();\n-        let empty: [int] = [];\n-        assert r.weighted_vec([]) == empty;\n+        let empty: [int]/~ = []/~;\n+        assert r.weighted_vec([]/~) == empty;\n         assert r.weighted_vec([\n             {weight: 0u, item: 3u},\n             {weight: 1u, item: 2u},\n             {weight: 2u, item: 1u}\n-        ]) == [2u, 1u, 1u];\n+        ]/~) == [2u, 1u, 1u]/~;\n     }\n \n     #[test]\n     fn shuffle() {\n         let r = rand::rng();\n-        let empty: [int] = [];\n-        assert r.shuffle([]) == empty;\n-        assert r.shuffle([1, 1, 1]) == [1, 1, 1];\n+        let empty: [int]/~ = []/~;\n+        assert r.shuffle([]/~) == empty;\n+        assert r.shuffle([1, 1, 1]/~) == [1, 1, 1]/~;\n     }\n }\n "}, {"sha": "f9b8388f465f4828fcd4c4e18071c5fbf0cb6345", "filename": "src/libcore/result.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -245,18 +245,18 @@ checking for overflow:\n         if x == uint::max_value { ret err(\\\"overflow\\\"); }\n         else { ret ok(x+1u); }\n     }\n-    map([1u, 2u, 3u], inc_conditionally).chain {|incd|\n-        assert incd == [2u, 3u, 4u];\n+    map([1u, 2u, 3u]/~, inc_conditionally).chain {|incd|\n+        assert incd == [2u, 3u, 4u]/~;\n     }\n \"]\n fn map_vec<T,U:copy,V:copy>(\n-    ts: [T], op: fn(T) -> result<V,U>) -> result<[V],U> {\n+    ts: [T]/~, op: fn(T) -> result<V,U>) -> result<[V]/~,U> {\n \n-    let mut vs: [V] = [];\n+    let mut vs: [V]/~ = []/~;\n     vec::reserve(vs, vec::len(ts));\n     for vec::each(ts) {|t|\n         alt op(t) {\n-          ok(v) { vs += [v]; }\n+          ok(v) { vs += [v]/~; }\n           err(u) { ret err(u); }\n         }\n     }\n@@ -284,16 +284,17 @@ length.  While we do not often use preconditions in the standard\n library, a precondition is used here because result::t is generally\n used in 'careful' code contexts where it is both appropriate and easy\n to accommodate an error like the vectors being of different lengths.\"]\n-fn map_vec2<S,T,U:copy,V:copy>(ss: [S], ts: [T], op: fn(S,T) -> result<V,U>)\n-    : vec::same_length(ss, ts) -> result<[V],U> {\n+fn map_vec2<S,T,U:copy,V:copy>(ss: [S]/~, ts: [T]/~,\n+                               op: fn(S,T) -> result<V,U>)\n+    : vec::same_length(ss, ts) -> result<[V]/~,U> {\n \n     let n = vec::len(ts);\n-    let mut vs = [];\n+    let mut vs = []/~;\n     vec::reserve(vs, n);\n     let mut i = 0u;\n     while i < n {\n         alt op(ss[i],ts[i]) {\n-          ok(v) { vs += [v]; }\n+          ok(v) { vs += [v]/~; }\n           err(u) { ret err(u); }\n         }\n         i += 1u;\n@@ -306,7 +307,7 @@ Applies op to the pairwise elements from `ss` and `ts`, aborting on\n error.  This could be implemented using `map2()` but it is more efficient\n on its own as no result vector is built.\n \"]\n-fn iter_vec2<S,T,U:copy>(ss: [S], ts: [T],\n+fn iter_vec2<S,T,U:copy>(ss: [S]/~, ts: [T]/~,\n                          op: fn(S,T) -> result<(),U>)\n     : vec::same_length(ss, ts)\n     -> result<(),U> {"}, {"sha": "6c724db52b58cef3f17f96daed622b24732d1468", "filename": "src/libcore/run.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -62,8 +62,8 @@ Run a program, providing stdin, stdout and stderr handles\n \n The process id of the spawned process\n \"]\n-fn spawn_process(prog: str, args: [str],\n-                 env: option<[(str,str)]>,\n+fn spawn_process(prog: str, args: [str]/~,\n+                 env: option<[(str,str)]/~>,\n                  dir: option<str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n    -> pid_t {\n@@ -77,36 +77,36 @@ fn spawn_process(prog: str, args: [str],\n     }\n }\n \n-fn with_argv<T>(prog: str, args: [str],\n+fn with_argv<T>(prog: str, args: [str]/~,\n                 cb: fn(**libc::c_char) -> T) -> T {\n-    let mut argptrs = str::as_c_str(prog) {|b| [b] };\n-    let mut tmps = [];\n+    let mut argptrs = str::as_c_str(prog) {|b| [b]/~ };\n+    let mut tmps = []/~;\n     for vec::each(args) {|arg|\n         let t = @arg;\n-        tmps += [t];\n-        argptrs += str::as_c_str(*t) {|b| [b] };\n+        tmps += [t]/~;\n+        argptrs += str::as_c_str(*t) {|b| [b]/~ };\n     }\n-    argptrs += [ptr::null()];\n+    argptrs += [ptr::null()]/~;\n     vec::as_buf(argptrs, cb)\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: option<[(str,str)]>,\n+fn with_envp<T>(env: option<[(str,str)]/~>,\n                 cb: fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n     alt env {\n       some(es) if !vec::is_empty(es) {\n-        let mut tmps = [];\n-        let mut ptrs = [];\n+        let mut tmps = []/~;\n+        let mut ptrs = []/~;\n \n         for vec::each(es) {|e|\n             let (k,v) = e;\n             let t = @(#fmt(\"%s=%s\", k, v));\n             vec::push(tmps, t);\n-            ptrs += str::as_c_str(*t) {|b| [b]};\n+            ptrs += str::as_c_str(*t) {|b| [b]/~};\n         }\n-        ptrs += [ptr::null()];\n+        ptrs += [ptr::null()]/~;\n         vec::as_buf(ptrs) { |p|\n             unsafe { cb(::unsafe::reinterpret_cast(p)) }\n         }\n@@ -118,23 +118,23 @@ fn with_envp<T>(env: option<[(str,str)]>,\n }\n \n #[cfg(windows)]\n-fn with_envp<T>(env: option<[(str,str)]>,\n+fn with_envp<T>(env: option<[(str,str)]/~>,\n                 cb: fn(*c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n     unsafe {\n         alt env {\n           some(es) if !vec::is_empty(es) {\n-            let mut blk : [u8] = [];\n+            let mut blk : [u8]/~ = []/~;\n             for vec::each(es) {|e|\n                 let (k,v) = e;\n                 let t = #fmt(\"%s=%s\", k, v);\n-                let mut v : [u8] = ::unsafe::reinterpret_cast(t);\n+                let mut v : [u8]/~ = ::unsafe::reinterpret_cast(t);\n                 blk += v;\n                 ::unsafe::forget(v);\n             }\n-            blk += [0_u8];\n+            blk += [0_u8]/~;\n             vec::as_buf(blk) {|p| cb(::unsafe::reinterpret_cast(p)) }\n           }\n           _ {\n@@ -164,7 +164,7 @@ Spawns a process and waits for it to terminate\n \n The process id\n \"]\n-fn run_program(prog: str, args: [str]) -> int {\n+fn run_program(prog: str, args: [str]/~) -> int {\n     let pid = spawn_process(prog, args, none, none,\n                             0i32, 0i32, 0i32);\n     if pid == -1 as pid_t { fail; }\n@@ -187,7 +187,7 @@ The class will ensure that file descriptors are closed properly.\n \n A class with a <program> field\n \"]\n-fn start_program(prog: str, args: [str]) -> program {\n+fn start_program(prog: str, args: [str]/~) -> program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n@@ -271,7 +271,7 @@ contents of stdout and stderr.\n A record, {status: int, out: str, err: str} containing the exit code,\n the contents of stdout and the contents of stderr.\n \"]\n-fn program_output(prog: str, args: [str]) ->\n+fn program_output(prog: str, args: [str]/~) ->\n    {status: int, out: str, err: str} {\n \n     let pipe_in = os::pipe();\n@@ -397,9 +397,9 @@ mod tests {\n     // Regression test for memory leaks\n     #[ignore(cfg(windows))] // FIXME (#2626)\n     fn test_leaks() {\n-        run::run_program(\"echo\", []);\n-        run::start_program(\"echo\", []);\n-        run::program_output(\"echo\", []);\n+        run::run_program(\"echo\", []/~);\n+        run::start_program(\"echo\", []/~);\n+        run::program_output(\"echo\", []/~);\n     }\n \n     #[test]\n@@ -410,7 +410,7 @@ mod tests {\n \n         let pid =\n             run::spawn_process(\n-                \"cat\", [], none, none,\n+                \"cat\", []/~, none, none,\n                 pipe_in.in, pipe_out.out, pipe_err.out);\n         os::close(pipe_in.in);\n         os::close(pipe_out.out);\n@@ -430,7 +430,7 @@ mod tests {\n \n     #[test]\n     fn waitpid() {\n-        let pid = run::spawn_process(\"false\", [],\n+        let pid = run::spawn_process(\"false\", []/~,\n                                      none, none,\n                                      0i32, 0i32, 0i32);\n         let status = run::waitpid(pid);"}, {"sha": "63d833e197f5385d5498294f794054d750c5d7c1", "filename": "src/libcore/str.rs", "status": "modified", "additions": 127, "deletions": 126, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -122,7 +122,7 @@ Convert a vector of bytes to a UTF-8 string\n \n Fails if invalid UTF-8\n \"]\n-pure fn from_bytes(vv: [u8]) -> str {\n+pure fn from_bytes(vv: [u8]/~) -> str {\n     assert is_utf8(vv);\n     ret unsafe { unsafe::from_bytes(vv) };\n }\n@@ -136,7 +136,7 @@ Fails if invalid UTF-8\n \"]\n pure fn from_byte(b: u8) -> str {\n     assert b < 128u8;\n-    let mut v = [b, 0u8];\n+    let mut v = [b, 0u8]/~;\n     unsafe { ::unsafe::transmute(v) }\n }\n \n@@ -209,7 +209,7 @@ fn push_char(&s: str, ch: char) {\n         }\n \n         as_bytes(s) {|bytes|\n-            let mut mut_bytes: [u8] = ::unsafe::reinterpret_cast(bytes);\n+            let mut mut_bytes: [u8]/~ = ::unsafe::reinterpret_cast(bytes);\n             vec::unsafe::set_len(mut_bytes, new_len + 1u);\n             ::unsafe::forget(mut_bytes);\n         }\n@@ -322,10 +322,10 @@ Converts a string to a vector of bytes\n \n The result vector is not null-terminated.\n \"]\n-pure fn bytes(s: str) -> [u8] {\n+pure fn bytes(s: str) -> [u8]/~ {\n     unsafe {\n         let mut s_copy = s;\n-        let mut v: [u8] = ::unsafe::transmute(s_copy);\n+        let mut v: [u8]/~ = ::unsafe::transmute(s_copy);\n         vec::unsafe::set_len(v, len(s));\n         ret v;\n     }\n@@ -342,12 +342,12 @@ pure fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T {\n }\n \n #[doc = \"Convert a string to a vector of characters\"]\n-pure fn chars(s: str/&) -> [char] {\n-    let mut buf = [], i = 0u;\n+pure fn chars(s: str/&) -> [char]/~ {\n+    let mut buf = []/~, i = 0u;\n     let len = len(s);\n     while i < len {\n         let {ch, next} = char_range_at(s, i);\n-        buf += [ch];\n+        buf += [ch]/~;\n         i = next;\n     }\n     ret buf;\n@@ -378,7 +378,7 @@ pure fn slice(s: str/&, begin: uint, end: uint) -> str {\n #[doc = \"\n Splits a string into substrings at each occurrence of a given character\n \"]\n-pure fn split_char(s: str/&, sep: char) -> [str] {\n+pure fn split_char(s: str/&, sep: char) -> [str]/~ {\n     split_char_inner(s, sep, len(s), true)\n }\n \n@@ -388,35 +388,35 @@ character up to 'count' times\n \n The byte must be a valid UTF-8/ASCII byte\n \"]\n-pure fn splitn_char(s: str/&, sep: char, count: uint) -> [str] {\n+pure fn splitn_char(s: str/&, sep: char, count: uint) -> [str]/~ {\n     split_char_inner(s, sep, count, true)\n }\n \n #[doc = \"\n Like `split_char`, but omits empty strings from the returned vector\n \"]\n-pure fn split_char_nonempty(s: str/&, sep: char) -> [str] {\n+pure fn split_char_nonempty(s: str/&, sep: char) -> [str]/~ {\n     split_char_inner(s, sep, len(s), false)\n }\n \n pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n-    -> [str] {\n+    -> [str]/~ {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n-        let mut result = [], done = 0u;\n+        let mut result = []/~, done = 0u;\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i {\n-                    result += [unsafe { unsafe::slice_bytes(s, start, i) }];\n+                    result += [unsafe { unsafe::slice_bytes(s, start, i) }]/~;\n                 }\n                 start = i + 1u;\n                 done += 1u;\n             }\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            result += [unsafe { unsafe::slice_bytes(s, start, l) }];\n+            result += [unsafe { unsafe::slice_bytes(s, start, l) }]/~;\n         }\n         result\n     } else {\n@@ -426,40 +426,40 @@ pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n \n \n #[doc = \"Splits a string into substrings using a character function\"]\n-pure fn split(s: str/&, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split(s: str/&, sepfn: fn(char) -> bool) -> [str]/~ {\n     split_inner(s, sepfn, len(s), true)\n }\n \n #[doc = \"\n Splits a string into substrings using a character function, cutting at\n most `count` times.\n \"]\n-pure fn splitn(s: str/&, sepfn: fn(char) -> bool, count: uint) -> [str] {\n+pure fn splitn(s: str/&, sepfn: fn(char) -> bool, count: uint) -> [str]/~ {\n     split_inner(s, sepfn, count, true)\n }\n \n #[doc = \"Like `split`, but omits empty strings from the returned vector\"]\n-pure fn split_nonempty(s: str/&, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split_nonempty(s: str/&, sepfn: fn(char) -> bool) -> [str]/~ {\n     split_inner(s, sepfn, len(s), false)\n }\n \n pure fn split_inner(s: str/&, sepfn: fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool) -> [str] {\n+               allow_empty: bool) -> [str]/~ {\n     let l = len(s);\n-    let mut result = [], i = 0u, start = 0u, done = 0u;\n+    let mut result = []/~, i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n         let {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i {\n-                result += [unsafe { unsafe::slice_bytes(s, start, i) }];\n+                result += [unsafe { unsafe::slice_bytes(s, start, i) }]/~;\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_empty || start < l {\n-        result += [unsafe { unsafe::slice_bytes(s, start, l) }];\n+        result += [unsafe { unsafe::slice_bytes(s, start, l) }]/~;\n     }\n     result\n }\n@@ -510,19 +510,19 @@ Splits a string into a vector of the substrings separated by a given string\n assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n ~~~\n \"]\n-pure fn split_str(s: str/&a, sep: str/&b) -> [str] {\n-    let mut result = [];\n+pure fn split_str(s: str/&a, sep: str/&b) -> [str]/~ {\n+    let mut result = []/~;\n     iter_between_matches(s, sep) {|from, to|\n-        unsafe { result += [unsafe::slice_bytes(s, from, to)]; }\n+        unsafe { result += [unsafe::slice_bytes(s, from, to)]/~; }\n     }\n     result\n }\n \n-pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> [str] {\n-    let mut result = [];\n+pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> [str]/~ {\n+    let mut result = []/~;\n     iter_between_matches(s, sep) {|from, to|\n         if to > from {\n-            unsafe { result += [unsafe::slice_bytes(s, from, to)]; }\n+            unsafe { result += [unsafe::slice_bytes(s, from, to)]/~; }\n         }\n     }\n     result\n@@ -531,13 +531,13 @@ pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n \"]\n-pure fn lines(s: str/&) -> [str] { split_char(s, '\\n') }\n+pure fn lines(s: str/&) -> [str]/~ { split_char(s, '\\n') }\n \n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n and/or CR LF ('\\\\r\\\\n')\n \"]\n-pure fn lines_any(s: str/&) -> [str] {\n+pure fn lines_any(s: str/&) -> [str]/~ {\n     vec::map(lines(s), {|s|\n         let l = len(s);\n         let mut cp = s;\n@@ -551,7 +551,7 @@ pure fn lines_any(s: str/&) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by whitespace\n \"]\n-pure fn words(s: str/&) -> [str] {\n+pure fn words(s: str/&) -> [str]/~ {\n     split_nonempty(s, {|c| char::is_whitespace(c)})\n }\n \n@@ -1264,23 +1264,23 @@ pure fn is_utf16(v: [const u16]/&) -> bool {\n }\n \n #[doc = \"Converts to a vector of `u16` encoded as UTF-16\"]\n-pure fn to_utf16(s: str/&) -> [u16] {\n-    let mut u = [];\n+pure fn to_utf16(s: str/&) -> [u16]/~ {\n+    let mut u = []/~;\n     chars_iter(s) {|cch|\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = cch as u32;\n \n         if (ch & 0xFFFF_u32) == ch {\n             // The BMP falls through (assuming non-surrogate, as it should)\n             assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n-            u += [ch as u16]\n+            u += [ch as u16]/~\n         } else {\n             // Supplementary planes break into surrogates.\n             assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n             ch -= 0x1_0000_u32;\n             let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n             let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            u += [w1, w2]\n+            u += [w1, w2]/~\n         }\n     }\n     ret u;\n@@ -1568,9 +1568,9 @@ interop.\n let i = str::as_bytes(\\\"Hello World\\\") { |bytes| vec::len(bytes) };\n ~~~\n \"]\n-pure fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T {\n+pure fn as_bytes<T>(s: str, f: fn([u8]/~) -> T) -> T {\n     unsafe {\n-        let v: *[u8] = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        let v: *[u8]/~ = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n         f(*v)\n     }\n }\n@@ -1723,7 +1723,7 @@ mod unsafe {\n \n     #[doc = \"Create a Rust string from a *u8 buffer of the given length\"]\n     unsafe fn from_buf_len(buf: *u8, len: uint) -> str {\n-        let mut v: [u8] = [];\n+        let mut v: [u8]/~ = []/~;\n         vec::reserve(v, len + 1u);\n         vec::as_buf(v) {|b| ptr::memcpy(b, buf, len); }\n         vec::unsafe::set_len(v, len);\n@@ -1750,9 +1750,9 @@ mod unsafe {\n \n    Does not verify that the vector contains valid UTF-8.\n    \"]\n-   unsafe fn from_bytes(v: [const u8]) -> str {\n+   unsafe fn from_bytes(v: [const u8]/~) -> str {\n        unsafe {\n-           let mut vcopy : [u8] = ::unsafe::transmute(copy v);\n+           let mut vcopy = ::unsafe::transmute(copy v);\n            vec::push(vcopy, 0u8);\n            ::unsafe::transmute(vcopy)\n        }\n@@ -1763,7 +1763,7 @@ mod unsafe {\n \n    Does not verify that the byte is valid UTF-8.\n    \"]\n-   unsafe fn from_byte(u: u8) -> str { unsafe::from_bytes([u]) }\n+   unsafe fn from_byte(u: u8) -> str { unsafe::from_bytes([u]/~) }\n \n    #[doc = \"\n    Takes a bytewise (not UTF-8) slice from a string.\n@@ -1780,15 +1780,15 @@ mod unsafe {\n            assert (begin <= end);\n            assert (end <= n);\n \n-           let mut v = [];\n+           let mut v = []/~;\n            vec::reserve(v, end - begin + 1u);\n            unsafe {\n                vec::as_buf(v) { |vbuf|\n                    let src = ptr::offset(sbuf, begin);\n                    ptr::memcpy(vbuf, src, end - begin);\n                }\n                vec::unsafe::set_len(v, end - begin);\n-               v += [0u8];\n+               v += [0u8]/~;\n                ::unsafe::transmute(v)\n            }\n        }\n@@ -1800,7 +1800,7 @@ mod unsafe {\n    }\n \n    #[doc = \"Appends a vector of bytes to a string. (Not UTF-8 safe).\"]\n-   unsafe fn push_bytes(&s: str, bytes: [u8]) {\n+   unsafe fn push_bytes(&s: str, bytes: [u8]/~) {\n        for vec::each(bytes) {|byte| rustrt::rust_str_push(s, byte); }\n    }\n \n@@ -1839,7 +1839,7 @@ mod unsafe {\n     #[test]\n     fn test_from_buf_len() {\n         unsafe {\n-            let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8]/~;\n             let b = vec::unsafe::to_ptr(a);\n             let c = from_buf_len(b, 3u);\n             assert (c == \"AAA\");\n@@ -1920,18 +1920,18 @@ impl extensions/& for str/& {\n     fn slice(begin: uint, end: uint) -> str { slice(self, begin, end) }\n     #[doc = \"Splits a string into substrings using a character function\"]\n     #[inline]\n-    fn split(sepfn: fn(char) -> bool) -> [str] { split(self, sepfn) }\n+    fn split(sepfn: fn(char) -> bool) -> [str]/~ { split(self, sepfn) }\n     #[doc = \"\n     Splits a string into substrings at each occurrence of a given character\n     \"]\n     #[inline]\n-    fn split_char(sep: char) -> [str] { split_char(self, sep) }\n+    fn split_char(sep: char) -> [str]/~ { split_char(self, sep) }\n     #[doc = \"\n     Splits a string into a vector of the substrings separated by a given\n     string\n     \"]\n     #[inline]\n-    fn split_str(sep: str/&a) -> [str] { split_str(self, sep) }\n+    fn split_str(sep: str/&a) -> [str]/~ { split_str(self, sep) }\n     #[doc = \"Returns true if one string starts with another\"]\n     #[inline]\n     fn starts_with(needle: str/&a) -> bool { starts_with(self, needle) }\n@@ -2032,79 +2032,79 @@ mod tests {\n \n     #[test]\n     fn test_split_char() {\n-        fn t(s: str, c: char, u: [str]) {\n+        fn t(s: str, c: char, u: [str]/~) {\n             log(debug, \"split_byte: \" + s);\n             let v = split_char(s, c);\n             #debug(\"split_byte to: %?\", v);\n             assert vec::all2(v, u, { |a,b| a == b });\n         }\n-        t(\"abc.hello.there\", '.', [\"abc\", \"hello\", \"there\"]);\n-        t(\".hello.there\", '.', [\"\", \"hello\", \"there\"]);\n-        t(\"...hello.there.\", '.', [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n+        t(\"abc.hello.there\", '.', [\"abc\", \"hello\", \"there\"]/~);\n+        t(\".hello.there\", '.', [\"\", \"hello\", \"there\"]/~);\n+        t(\"...hello.there.\", '.', [\"\", \"\", \"\", \"hello\", \"there\", \"\"]/~);\n \n-        assert [\"\", \"\", \"\", \"hello\", \"there\", \"\"]\n+        assert [\"\", \"\", \"\", \"hello\", \"there\", \"\"]/~\n             == split_char(\"...hello.there.\", '.');\n \n-        assert [\"\"] == split_char(\"\", 'z');\n-        assert [\"\",\"\"] == split_char(\"z\", 'z');\n-        assert [\"ok\"] == split_char(\"ok\", 'z');\n+        assert [\"\"]/~ == split_char(\"\", 'z');\n+        assert [\"\",\"\"]/~ == split_char(\"z\", 'z');\n+        assert [\"ok\"]/~ == split_char(\"ok\", 'z');\n     }\n \n     #[test]\n     fn test_split_char_2() {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]/~\n             == split_char(data, 'V');\n-        assert [\"\u0e1b\u0e23\u0e30\u0e40\", \"\u0e28\u0e44\", \"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\", \"\u0e28\u0e44\", \"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]/~\n             == split_char(data, '\u0e17');\n     }\n \n     #[test]\n     fn test_splitn_char() {\n-        fn t(s: str, c: char, n: uint, u: [str]) {\n+        fn t(s: str, c: char, n: uint, u: [str]/~) {\n             log(debug, \"splitn_byte: \" + s);\n             let v = splitn_char(s, c, n);\n             #debug(\"split_byte to: %?\", v);\n             #debug(\"comparing vs. %?\", u);\n             assert vec::all2(v, u, { |a,b| a == b });\n         }\n-        t(\"abc.hello.there\", '.', 0u, [\"abc.hello.there\"]);\n-        t(\"abc.hello.there\", '.', 1u, [\"abc\", \"hello.there\"]);\n-        t(\"abc.hello.there\", '.', 2u, [\"abc\", \"hello\", \"there\"]);\n-        t(\"abc.hello.there\", '.', 3u, [\"abc\", \"hello\", \"there\"]);\n-        t(\".hello.there\", '.', 0u, [\".hello.there\"]);\n-        t(\".hello.there\", '.', 1u, [\"\", \"hello.there\"]);\n-        t(\"...hello.there.\", '.', 3u, [\"\", \"\", \"\", \"hello.there.\"]);\n-        t(\"...hello.there.\", '.', 5u, [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n+        t(\"abc.hello.there\", '.', 0u, [\"abc.hello.there\"]/~);\n+        t(\"abc.hello.there\", '.', 1u, [\"abc\", \"hello.there\"]/~);\n+        t(\"abc.hello.there\", '.', 2u, [\"abc\", \"hello\", \"there\"]/~);\n+        t(\"abc.hello.there\", '.', 3u, [\"abc\", \"hello\", \"there\"]/~);\n+        t(\".hello.there\", '.', 0u, [\".hello.there\"]/~);\n+        t(\".hello.there\", '.', 1u, [\"\", \"hello.there\"]/~);\n+        t(\"...hello.there.\", '.', 3u, [\"\", \"\", \"\", \"hello.there.\"]/~);\n+        t(\"...hello.there.\", '.', 5u, [\"\", \"\", \"\", \"hello\", \"there\", \"\"]/~);\n \n-        assert [\"\"] == splitn_char(\"\", 'z', 5u);\n-        assert [\"\",\"\"] == splitn_char(\"z\", 'z', 5u);\n-        assert [\"ok\"] == splitn_char(\"ok\", 'z', 5u);\n-        assert [\"z\"] == splitn_char(\"z\", 'z', 0u);\n-        assert [\"w.x.y\"] == splitn_char(\"w.x.y\", '.', 0u);\n-        assert [\"w\",\"x.y\"] == splitn_char(\"w.x.y\", '.', 1u);\n+        assert [\"\"]/~ == splitn_char(\"\", 'z', 5u);\n+        assert [\"\",\"\"]/~ == splitn_char(\"z\", 'z', 5u);\n+        assert [\"ok\"]/~ == splitn_char(\"ok\", 'z', 5u);\n+        assert [\"z\"]/~ == splitn_char(\"z\", 'z', 0u);\n+        assert [\"w.x.y\"]/~ == splitn_char(\"w.x.y\", '.', 0u);\n+        assert [\"w\",\"x.y\"]/~ == splitn_char(\"w.x.y\", '.', 1u);\n     }\n \n     #[test]\n     fn test_splitn_char_2 () {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]/~\n             == splitn_char(data, '\u534e', 1u);\n \n-        assert [\"\", \"\", \"XXX\", \"YYYzWWWz\"]\n+        assert [\"\", \"\", \"XXX\", \"YYYzWWWz\"]/~\n             == splitn_char(\"zzXXXzYYYzWWWz\", 'z', 3u);\n-        assert [\"\",\"\"] == splitn_char(\"z\", 'z', 5u);\n-        assert [\"\"] == splitn_char(\"\", 'z', 5u);\n-        assert [\"ok\"] == splitn_char(\"ok\", 'z', 5u);\n+        assert [\"\",\"\"]/~ == splitn_char(\"z\", 'z', 5u);\n+        assert [\"\"]/~ == splitn_char(\"\", 'z', 5u);\n+        assert [\"ok\"]/~ == splitn_char(\"ok\", 'z', 5u);\n     }\n \n \n     #[test]\n     fn test_splitn_char_3() {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]/~\n             == splitn_char(data, 'V', 1u);\n-        assert [\"\u0e1b\u0e23\u0e30\u0e40\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]/~\n             == splitn_char(data, '\u0e17', 1u);\n \n     }\n@@ -2125,75 +2125,75 @@ mod tests {\n         t(\"::hello::there::\", \"::\", 3, \"\");\n \n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]/~\n             == split_str (data, \"\u4e2d\u534e\");\n \n-        assert [\"\", \"XXX\", \"YYY\", \"\"]\n+        assert [\"\", \"XXX\", \"YYY\", \"\"]/~\n             == split_str(\"zzXXXzzYYYzz\", \"zz\");\n \n-        assert [\"zz\", \"zYYYz\"]\n+        assert [\"zz\", \"zYYYz\"]/~\n             == split_str(\"zzXXXzYYYz\", \"XXX\");\n \n \n-        assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\");\n-        assert [\"\"] == split_str(\"\", \".\");\n-        assert [\"\",\"\"] == split_str(\"zz\", \"zz\");\n-        assert [\"ok\"] == split_str(\"ok\", \"z\");\n-        assert [\"\",\"z\"] == split_str(\"zzz\", \"zz\");\n-        assert [\"\",\"\",\"z\"] == split_str(\"zzzzz\", \"zz\");\n+        assert [\"\", \"XXX\", \"YYY\", \"\"]/~ == split_str(\".XXX.YYY.\", \".\");\n+        assert [\"\"]/~ == split_str(\"\", \".\");\n+        assert [\"\",\"\"]/~ == split_str(\"zz\", \"zz\");\n+        assert [\"ok\"]/~ == split_str(\"ok\", \"z\");\n+        assert [\"\",\"z\"]/~ == split_str(\"zzz\", \"zz\");\n+        assert [\"\",\"\",\"z\"]/~ == split_str(\"zzzzz\", \"zz\");\n     }\n \n \n     #[test]\n     fn test_split() {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]/~\n             == split (data, {|cc| cc == '\u534e'});\n \n-        assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]\n+        assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]/~\n             == split(\"zzXXXzYYYz\", char::is_lowercase);\n \n-        assert [\"zz\", \"\", \"\", \"z\", \"\", \"\", \"z\"]\n+        assert [\"zz\", \"\", \"\", \"z\", \"\", \"\", \"z\"]/~\n             == split(\"zzXXXzYYYz\", char::is_uppercase);\n \n-        assert [\"\",\"\"] == split(\"z\", {|cc| cc == 'z'});\n-        assert [\"\"] == split(\"\", {|cc| cc == 'z'});\n-        assert [\"ok\"] == split(\"ok\", {|cc| cc == 'z'});\n+        assert [\"\",\"\"]/~ == split(\"z\", {|cc| cc == 'z'});\n+        assert [\"\"]/~ == split(\"\", {|cc| cc == 'z'});\n+        assert [\"ok\"]/~ == split(\"ok\", {|cc| cc == 'z'});\n     }\n \n     #[test]\n     fn test_lines() {\n         let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n         let crlf = \"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n-        assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+        assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]/~\n             == lines(lf);\n \n-        assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+        assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]/~\n             == lines_any(lf);\n \n-        assert [\"\\r\", \"Mary had a little lamb\\r\", \"Little lamb\\r\", \"\"]\n+        assert [\"\\r\", \"Mary had a little lamb\\r\", \"Little lamb\\r\", \"\"]/~\n             == lines(crlf);\n \n-        assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+        assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]/~\n             == lines_any(crlf);\n \n-        assert [\"\"] == lines    (\"\");\n-        assert [\"\"] == lines_any(\"\");\n-        assert [\"\",\"\"] == lines    (\"\\n\");\n-        assert [\"\",\"\"] == lines_any(\"\\n\");\n-        assert [\"banana\"] == lines    (\"banana\");\n-        assert [\"banana\"] == lines_any(\"banana\");\n+        assert [\"\"]/~ == lines    (\"\");\n+        assert [\"\"]/~ == lines_any(\"\");\n+        assert [\"\",\"\"]/~ == lines    (\"\\n\");\n+        assert [\"\",\"\"]/~ == lines_any(\"\\n\");\n+        assert [\"banana\"]/~ == lines    (\"banana\");\n+        assert [\"banana\"]/~ == lines_any(\"banana\");\n     }\n \n     #[test]\n     fn test_words () {\n         let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        assert [\"Mary\",\"had\",\"a\",\"little\",\"lamb\",\"Little\",\"lamb\"]\n+        assert [\"Mary\",\"had\",\"a\",\"little\",\"lamb\",\"Little\",\"lamb\"]/~\n             == words(data);\n \n-        assert [\"ok\"] == words(\"ok\");\n-        assert [] == words(\"\");\n+        assert [\"ok\"]/~ == words(\"ok\");\n+        assert []/~ == words(\"\");\n     }\n \n     #[test]\n@@ -2250,22 +2250,23 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        fn t(v: [str], s: str) { assert (eq(concat(v), s)); }\n-        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n-        let v: [str] = [];\n+        fn t(v: [str]/~, s: str) { assert (eq(concat(v), s)); }\n+        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"]/~, \"youknowI'mnogood\");\n+        let v: [str]/~ = []/~;\n         t(v, \"\");\n-        t([\"hi\"], \"hi\");\n+        t([\"hi\"]/~, \"hi\");\n     }\n \n     #[test]\n     fn test_connect() {\n-        fn t(v: [str], sep: str, s: str) {\n+        fn t(v: [str]/~, sep: str, s: str) {\n             assert (eq(connect(v, sep), s));\n         }\n-        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \" \", \"you know I'm no good\");\n-        let v: [str] = [];\n+        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"]/~,\n+          \" \", \"you know I'm no good\");\n+        let v: [str]/~ = []/~;\n         t(v, \" \", \"\");\n-        t([\"hi\"], \" \", \"hi\");\n+        t([\"hi\"]/~, \" \", \"hi\");\n     }\n \n     #[test]\n@@ -2517,7 +2518,7 @@ mod tests {\n \n     #[test]\n     fn test_unsafe_from_bytes() {\n-        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n+        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8]/~;\n         let b = unsafe { unsafe::from_bytes(a) };\n         assert (b == \"AAAAAAA\");\n     }\n@@ -2534,7 +2535,7 @@ mod tests {\n                   0x56_u8, 0x69_u8, 0xe1_u8,\n                   0xbb_u8, 0x87_u8, 0x74_u8,\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n-                  0x6d_u8];\n+                  0x6d_u8]/~;\n \n          assert ss == from_bytes(bb);\n     }\n@@ -2552,15 +2553,15 @@ mod tests {\n                   0x56_u8, 0x69_u8, 0xe1_u8,\n                   0xbb_u8, 0x87_u8, 0x74_u8,\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n-                  0x6d_u8];\n+                  0x6d_u8]/~;\n \n          let _x = from_bytes(bb);\n     }\n \n     #[test]\n     fn test_from_buf() {\n         unsafe {\n-            let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8]/~;\n             let b = vec::unsafe::to_ptr(a);\n             let c = unsafe::from_buf(b);\n             assert (c == \"AAAAAAA\");\n@@ -2609,7 +2610,7 @@ mod tests {\n     fn vec_str_conversions() {\n         let s1: str = \"All mimsy were the borogoves\";\n \n-        let v: [u8] = bytes(s1);\n+        let v: [u8]/~ = bytes(s1);\n         let s2: str = from_bytes(v);\n         let mut i: uint = 0u;\n         let n1: uint = len(s1);\n@@ -2774,7 +2775,7 @@ mod tests {\n     #[test]\n     fn test_chars() {\n         let ss = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m']\n+        assert ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m']/~\n             == chars(ss);\n     }\n \n@@ -2785,15 +2786,15 @@ mod tests {\n               [0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n                0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n                0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n-               0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n+               0xd800_u16, 0xdf30_u16, 0x000a_u16]/~),\n \n              (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\",\n               [0xd801_u16, 0xdc12_u16, 0xd801_u16,\n                0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n                0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n                0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n                0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n-               0x000a_u16]),\n+               0x000a_u16]/~),\n \n              (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\",\n               [0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n@@ -2802,7 +2803,7 @@ mod tests {\n                0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n                0xdf04_u16, 0xd800_u16, 0xdf15_u16, 0xd800_u16,\n                0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n-               0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n+               0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]/~),\n \n              (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\",\n               [0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n@@ -2815,7 +2816,7 @@ mod tests {\n                0xdc9c_u16, 0xd801_u16, 0xdc92_u16, 0xd801_u16,\n                0xdc96_u16, 0xd801_u16, 0xdc86_u16, 0x0020_u16,\n                0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n-               0x000a_u16 ]) ];\n+               0x000a_u16 ]/~) ]/~;\n \n         for vec::each(pairs) {|p|\n             let (s, u) = p;"}, {"sha": "229afc810e57011096cda55f180e998ba89e014f", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -56,7 +56,7 @@ impl <A: to_str copy, B: to_str copy, C: to_str copy> of to_str for (A, B, C){\n     }\n }\n \n-impl <A: to_str> of to_str for [A] {\n+impl <A: to_str> of to_str for [A]/~ {\n     fn to_str() -> str {\n         let mut acc = \"[\", first = true;\n         for vec::each(self) {|elt|\n@@ -98,11 +98,12 @@ mod tests {\n     }\n \n     fn test_vectors() {\n-        let x: [int] = [];\n-        assert x.to_str() == \"[]\";\n-        assert [1].to_str() == \"[1]\";\n-        assert [1, 2, 3].to_str() == \"[1, 2, 3]\";\n-        assert [[], [1], [1, 1]].to_str() == \"[[], [1], [1, 1]]\";\n+        let x: [int]/~ = []/~;\n+        assert x.to_str() == \"[]/~\";\n+        assert [1]/~.to_str() == \"[1]/~\";\n+        assert [1, 2, 3]/~.to_str() == \"[1, 2, 3]/~\";\n+        assert [[]/~, [1]/~, [1, 1]/~]/~.to_str() ==\n+               \"[[]/~, [1]/~, [1, 1]/~]/~\";\n     }\n \n     fn test_pointer_types() {"}, {"sha": "6ec8d2e8789717f1d69576146f3eb0b354ae5d47", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -88,7 +88,7 @@ Parse a buffer of bytes\n \n `buf` must not be empty\n \"]\n-fn parse_buf(buf: [u8], radix: uint) -> option<T> {\n+fn parse_buf(buf: [u8]/~, radix: uint) -> option<T> {\n     if vec::len(buf) == 0u { ret none; }\n     let mut i = vec::len(buf) - 1u;\n     let mut power = 1u as T;"}, {"sha": "3ebcde80281314e558fc13688ba59e008f5315d9", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -33,7 +33,7 @@ Both types must have the same size and alignment.\n \n # Example\n \n-    assert transmute(\\\"L\\\") == [76u8, 0u8];\n+    assert transmute(\\\"L\\\") == [76u8, 0u8]/~;\n \"]\n unsafe fn transmute<L, G>(-thing: L) -> G {\n     let newthing = reinterpret_cast(thing);\n@@ -62,7 +62,7 @@ mod tests {\n     #[test]\n     fn test_transmute2() {\n         unsafe {\n-            assert transmute(\"L\") == [76u8, 0u8];\n+            assert transmute(\"L\") == [76u8, 0u8]/~;\n         }\n     }\n }"}, {"sha": "0f9cedd84c65d1fb5e5c3d978ef0734fd2034ebf", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 247, "deletions": 243, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -126,7 +126,7 @@ capacity, then no action is taken.\n * v - A vector\n * n - The number of elements to reserve space for\n \"]\n-fn reserve<T>(&v: [const T], n: uint) {\n+fn reserve<T>(&v: [const T]/~, n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n     if capacity(v) < n {\n         let ptr = ptr::addr_of(v) as **unsafe::vec_repr;\n@@ -150,15 +150,15 @@ capacity, then no action is taken.\n * v - A vector\n * n - The number of elements to reserve space for\n \"]\n-fn reserve_at_least<T>(&v: [const T], n: uint) {\n+fn reserve_at_least<T>(&v: [const T]/~, n: uint) {\n     reserve(v, uint::next_power_of_two(n));\n }\n \n #[doc = \"\n Returns the number of elements the vector can hold without reallocating\n \"]\n #[inline(always)]\n-pure fn capacity<T>(&&v: [const T]) -> uint {\n+pure fn capacity<T>(&&v: [const T]/~) -> uint {\n     unsafe {\n         let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).alloc / sys::size_of::<T>()\n@@ -177,8 +177,8 @@ Creates and initializes an immutable vector.\n Creates an immutable vector of size `n_elts` and initializes the elements\n to the value returned by the function `op`.\n \"]\n-pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> [T] {\n-    let mut v = [];\n+pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> [T]/~ {\n+    let mut v = []/~;\n     unchecked{reserve(v, n_elts);}\n     let mut i: uint = 0u;\n     while i < n_elts unsafe { push(v, op(i)); i += 1u; }\n@@ -191,8 +191,8 @@ Creates and initializes an immutable vector.\n Creates an immutable vector of size `n_elts` and initializes the elements\n to the value `t`.\n \"]\n-pure fn from_elem<T: copy>(n_elts: uint, t: T) -> [T] {\n-    let mut v = [];\n+pure fn from_elem<T: copy>(n_elts: uint, t: T) -> [T]/~ {\n+    let mut v = []/~;\n     unchecked{reserve(v, n_elts)}\n     let mut i: uint = 0u;\n     unsafe { // because push is impure\n@@ -202,12 +202,12 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> [T] {\n }\n \n #[doc = \"Produces a mut vector from an immutable vector.\"]\n-fn to_mut<T>(+v: [T]) -> [mut T] {\n+fn to_mut<T>(+v: [T]/~) -> [mut T]/~ {\n     unsafe { ::unsafe::transmute(v) }\n }\n \n #[doc = \"Produces an immutable vector from a mut vector.\"]\n-fn from_mut<T>(+v: [mut T]) -> [T] {\n+fn from_mut<T>(+v: [mut T]/~) -> [T]/~ {\n     unsafe { ::unsafe::transmute(v) }\n }\n \n@@ -217,18 +217,18 @@ fn from_mut<T>(+v: [mut T]) -> [T] {\n pure fn head<T: copy>(v: [const T]/&) -> T { v[0] }\n \n #[doc = \"Returns a vector containing all but the first element of a slice\"]\n-pure fn tail<T: copy>(v: [const T]/&) -> [T] {\n+pure fn tail<T: copy>(v: [const T]/&) -> [T]/~ {\n     ret slice(v, 1u, len(v));\n }\n \n #[doc = \"Returns a vector containing all but the first `n` \\\n          elements of a slice\"]\n-pure fn tailn<T: copy>(v: [const T]/&, n: uint) -> [T] {\n+pure fn tailn<T: copy>(v: [const T]/&, n: uint) -> [T]/~ {\n     slice(v, n, len(v))\n }\n \n #[doc = \"Returns a vector containing all but the last element of a slice\"]\n-pure fn init<T: copy>(v: [const T]/&) -> [T] {\n+pure fn init<T: copy>(v: [const T]/&) -> [T]/~ {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n@@ -251,10 +251,10 @@ pure fn last_opt<T: copy>(v: [const T]/&) -> option<T> {\n }\n \n #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n-pure fn slice<T: copy>(v: [const T]/&, start: uint, end: uint) -> [T] {\n+pure fn slice<T: copy>(v: [const T]/&, start: uint, end: uint) -> [T]/~ {\n     assert (start <= end);\n     assert (end <= len(v));\n-    let mut result = [];\n+    let mut result = []/~;\n     unchecked {\n         push_all(result, view(v, start, end));\n     }\n@@ -276,12 +276,12 @@ pure fn view<T: copy>(v: [const T]/&, start: uint, end: uint) -> [T]/&a {\n #[doc = \"\n Split the vector `v` by applying each element against the predicate `f`.\n \"]\n-fn split<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]] {\n+fn split<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]/~]/~ {\n     let ln = len(v);\n-    if (ln == 0u) { ret [] }\n+    if (ln == 0u) { ret []/~ }\n \n     let mut start = 0u;\n-    let mut result = [];\n+    let mut result = []/~;\n     while start < ln {\n         alt position_between(v, start, ln, f) {\n           none { break }\n@@ -299,13 +299,13 @@ fn split<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]] {\n Split the vector `v` by applying each element against the predicate `f` up\n to `n` times.\n \"]\n-fn splitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn splitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]/~]/~ {\n     let ln = len(v);\n-    if (ln == 0u) { ret [] }\n+    if (ln == 0u) { ret []/~ }\n \n     let mut start = 0u;\n     let mut count = n;\n-    let mut result = [];\n+    let mut result = []/~;\n     while start < ln && count > 0u {\n         alt position_between(v, start, ln, f) {\n           none { break }\n@@ -325,12 +325,12 @@ fn splitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n Reverse split the vector `v` by applying each element against the predicate\n `f`.\n \"]\n-fn rsplit<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]] {\n+fn rsplit<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]/~]/~ {\n     let ln = len(v);\n-    if (ln == 0u) { ret [] }\n+    if (ln == 0u) { ret []/~ }\n \n     let mut end = ln;\n-    let mut result = [];\n+    let mut result = []/~;\n     while end > 0u {\n         alt rposition_between(v, 0u, end, f) {\n           none { break }\n@@ -348,13 +348,13 @@ fn rsplit<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]] {\n Reverse split the vector `v` by applying each element against the predicate\n `f` up to `n times.\n \"]\n-fn rsplitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn rsplitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]/~]/~ {\n     let ln = len(v);\n-    if (ln == 0u) { ret [] }\n+    if (ln == 0u) { ret []/~ }\n \n     let mut end = ln;\n     let mut count = n;\n-    let mut result = [];\n+    let mut result = []/~;\n     while end > 0u && count > 0u {\n         alt rposition_between(v, 0u, end, f) {\n           none { break }\n@@ -373,11 +373,11 @@ fn rsplitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n // Mutators\n \n #[doc = \"Removes the first element from a vector and return it\"]\n-fn shift<T>(&v: [T]) -> T {\n+fn shift<T>(&v: [T]/~) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n \n-    let mut vv = [];\n+    let mut vv = []/~;\n     v <-> vv;\n \n     unsafe {\n@@ -399,16 +399,16 @@ fn shift<T>(&v: [T]) -> T {\n }\n \n #[doc = \"Prepend an element to the vector\"]\n-fn unshift<T>(&v: [T], +x: T) {\n-    let mut vv = [x];\n+fn unshift<T>(&v: [T]/~, +x: T) {\n+    let mut vv = [x]/~;\n     v <-> vv;\n     while len(vv) > 0 {\n         push(v, shift(vv));\n     }\n }\n \n #[doc = \"Remove the last element from a vector and return it\"]\n-fn pop<T>(&v: [const T]) -> T {\n+fn pop<T>(&v: [const T]/~) -> T {\n     let ln = len(v);\n     assert ln > 0u;\n     let valptr = ptr::mut_addr_of(v[ln - 1u]);\n@@ -421,7 +421,7 @@ fn pop<T>(&v: [const T]) -> T {\n \n #[doc = \"Append an element to a vector\"]\n #[inline(always)]\n-fn push<T>(&v: [const T], +initval: T) {\n+fn push<T>(&v: [const T]/~, +initval: T) {\n     unsafe {\n         let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         let fill = (**repr).fill;\n@@ -438,7 +438,7 @@ fn push<T>(&v: [const T], +initval: T) {\n     }\n }\n \n-fn push_slow<T>(&v: [const T], +initval: T) {\n+fn push_slow<T>(&v: [const T]/~, +initval: T) {\n     unsafe {\n         let ln = v.len();\n         reserve_at_least(v, ln + 1u);\n@@ -453,17 +453,18 @@ fn push_slow<T>(&v: [const T], +initval: T) {\n }\n \n #[inline(always)]\n-fn push_all<T: copy>(&v: [const T], rhs: [const T]/&) {\n+fn push_all<T: copy>(&v: [const T]/~, rhs: [const T]/&) {\n     reserve(v, v.len() + rhs.len());\n+\n     for uint::range(0u, rhs.len()) {|i|\n         push(v, rhs[i]);\n     }\n }\n \n // Appending\n #[inline(always)]\n-pure fn append<T: copy>(lhs: [T]/&, rhs: [const T]/&) -> [T] {\n-    let mut v = [];\n+pure fn append<T: copy>(lhs: [T]/&, rhs: [const T]/&) -> [T]/~ {\n+    let mut v = []/~;\n     let mut i = 0u;\n     while i < lhs.len() {\n         unsafe { // This is impure, but it appears pure to the caller.\n@@ -482,8 +483,8 @@ pure fn append<T: copy>(lhs: [T]/&, rhs: [const T]/&) -> [T] {\n }\n \n #[inline(always)]\n-pure fn append_mut<T: copy>(lhs: [mut T]/&, rhs: [const T]/&) -> [mut T] {\n-    let mut v = [mut];\n+pure fn append_mut<T: copy>(lhs: [mut T]/&, rhs: [const T]/&) -> [mut T]/~ {\n+    let mut v = [mut]/~;\n     let mut i = 0u;\n     while i < lhs.len() {\n         unsafe { // This is impure, but it appears pure to the caller.\n@@ -510,7 +511,7 @@ Expands a vector in place, initializing the new elements to a given value\n * n - The number of elements to add\n * initval - The value for the new elements\n \"]\n-fn grow<T: copy>(&v: [const T], n: uint, initval: T) {\n+fn grow<T: copy>(&v: [const T]/~, n: uint, initval: T) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n \n@@ -530,7 +531,7 @@ Function `init_op` is called `n` times with the values [0..`n`)\n * init_op - A function to call to retreive each appended element's\n             value\n \"]\n-fn grow_fn<T>(&v: [const T], n: uint, op: init_op<T>) {\n+fn grow_fn<T>(&v: [const T]/~, n: uint, op: init_op<T>) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n     while i < n { push(v, op(i)); i += 1u; }\n@@ -545,7 +546,7 @@ of the vector, expands the vector by replicating `initval` to fill the\n intervening space.\n \"]\n #[inline(always)]\n-fn grow_set<T: copy>(&v: [mut T], index: uint, initval: T, val: T) {\n+fn grow_set<T: copy>(&v: [mut T]/~, index: uint, initval: T, val: T) {\n     if index >= len(v) { grow(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n }\n@@ -556,8 +557,8 @@ fn grow_set<T: copy>(&v: [mut T], index: uint, initval: T, val: T) {\n #[doc = \"\n Apply a function to each element of a vector and return the results\n \"]\n-pure fn map<T, U>(v: [T]/&, f: fn(T) -> U) -> [U] {\n-    let mut result = [];\n+pure fn map<T, U>(v: [T]/&, f: fn(T) -> U) -> [U]/~ {\n+    let mut result = []/~;\n     unchecked{reserve(result, len(v));}\n     for each(v) {|elem| unsafe { push(result, f(elem)); } }\n     ret result;\n@@ -566,8 +567,8 @@ pure fn map<T, U>(v: [T]/&, f: fn(T) -> U) -> [U] {\n #[doc = \"\n Apply a function to each element of a vector and return the results\n \"]\n-pure fn mapi<T, U>(v: [T]/&, f: fn(uint, T) -> U) -> [U] {\n-    let mut result = [];\n+pure fn mapi<T, U>(v: [T]/&, f: fn(uint, T) -> U) -> [U]/~ {\n+    let mut result = []/~;\n     unchecked{reserve(result, len(v));}\n     for eachi(v) {|i, elem| unsafe { push(result, f(i, elem)); } }\n     ret result;\n@@ -577,8 +578,8 @@ pure fn mapi<T, U>(v: [T]/&, f: fn(uint, T) -> U) -> [U] {\n Apply a function to each element of a vector and return a concatenation\n of each result vector\n \"]\n-pure fn flat_map<T, U>(v: [T]/&, f: fn(T) -> [U]) -> [U] {\n-    let mut result = [];\n+pure fn flat_map<T, U>(v: [T]/&, f: fn(T) -> [U]/~) -> [U]/~ {\n+    let mut result = []/~;\n     for each(v) {|elem| result += f(elem); }\n     ret result;\n }\n@@ -587,10 +588,10 @@ pure fn flat_map<T, U>(v: [T]/&, f: fn(T) -> [U]) -> [U] {\n Apply a function to each pair of elements and return the results\n \"]\n pure fn map2<T: copy, U: copy, V>(v0: [T]/&, v1: [U]/&,\n-                                  f: fn(T, U) -> V) -> [V] {\n+                                  f: fn(T, U) -> V) -> [V]/~ {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n-    let mut u: [V] = [];\n+    let mut u: [V]/~ = []/~;\n     let mut i = 0u;\n     while i < v0_len {\n         unsafe { push(u, f(copy v0[i], copy v1[i])) };\n@@ -606,8 +607,8 @@ If function `f` returns `none` then that element is excluded from\n the resulting vector.\n \"]\n pure fn filter_map<T, U: copy>(v: [T]/&, f: fn(T) -> option<U>)\n-    -> [U] {\n-    let mut result = [];\n+    -> [U]/~ {\n+    let mut result = []/~;\n     for each(v) {|elem|\n         alt f(elem) {\n           none {/* no-op */ }\n@@ -624,8 +625,8 @@ holds.\n Apply function `f` to each element of `v` and return a vector containing\n only those elements for which `f` returned true.\n \"]\n-pure fn filter<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [T] {\n-    let mut result = [];\n+pure fn filter<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [T]/~ {\n+    let mut result = []/~;\n     for each(v) {|elem|\n         if f(elem) { unsafe { push(result, elem); } }\n     }\n@@ -637,17 +638,17 @@ Concatenate a vector of vectors.\n \n Flattens a vector of vectors of T into a single vector of T.\n \"]\n-pure fn concat<T: copy>(v: [[T]]/&) -> [T] {\n-    let mut r = [];\n+pure fn concat<T: copy>(v: [[T]/~]/&) -> [T]/~ {\n+    let mut r = []/~;\n     for each(v) {|inner| unsafe { push_all(r, inner); } }\n     ret r;\n }\n \n #[doc = \"\n Concatenate a vector of vectors, placing a given separator between each\n \"]\n-pure fn connect<T: copy>(v: [[T]]/&, sep: T) -> [T] {\n-    let mut r: [T] = [];\n+pure fn connect<T: copy>(v: [[T]/~]/&, sep: T) -> [T]/~ {\n+    let mut r: [T]/~ = []/~;\n     let mut first = true;\n     for each(v) {|inner|\n         if first { first = false; } else { unsafe { push(r, sep); } }\n@@ -873,9 +874,9 @@ vector contains the first element of the i-th tuple of the input vector,\n and the i-th element of the second vector contains the second element\n of the i-th tuple of the input vector.\n \"]\n-pure fn unzip<T: copy, U: copy>(v: [(T, U)]/&) -> ([T], [U]) {\n-    let mut as = [], bs = [];\n-    for each(v) {|p| let (a, b) = p; as += [a]; bs += [b]; }\n+pure fn unzip<T: copy, U: copy>(v: [(T, U)]/&) -> ([T]/~, [U]/~) {\n+    let mut as = []/~, bs = []/~;\n+    for each(v) {|p| let (a, b) = p; as += [a]/~; bs += [b]/~; }\n     ret (as, bs);\n }\n \n@@ -885,12 +886,12 @@ Convert two vectors to a vector of pairs\n Returns a vector of tuples, where the i-th tuple contains contains the\n i-th elements from each of the input vectors.\n \"]\n-pure fn zip<T: copy, U: copy>(v: [const T]/&, u: [const U]/&) -> [(T, U)] {\n-    let mut zipped = [];\n+pure fn zip<T: copy, U: copy>(v: [const T]/&, u: [const U]/&) -> [(T, U)]/~ {\n+    let mut zipped = []/~;\n     let sz = len(v);\n     let mut i = 0u;\n     assert sz == len(u);\n-    while i < sz { zipped += [(v[i], u[i])]; i += 1u; }\n+    while i < sz { zipped += [(v[i], u[i])]/~; i += 1u; }\n     ret zipped;\n }\n \n@@ -903,25 +904,25 @@ Swaps two elements in a vector\n * a - The index of the first element\n * b - The index of the second element\n \"]\n-fn swap<T>(&&v: [mut T], a: uint, b: uint) {\n+fn swap<T>(&&v: [mut T]/~, a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n #[doc = \"Reverse the order of elements in a vector, in place\"]\n-fn reverse<T>(v: [mut T]) {\n+fn reverse<T>(v: [mut T]/~) {\n     let mut i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n }\n \n \n #[doc = \"Returns a vector with the order of elements reversed\"]\n-fn reversed<T: copy>(v: [const T]/&) -> [T] {\n-    let mut rs: [T] = [];\n+fn reversed<T: copy>(v: [const T]/&) -> [T]/~ {\n+    let mut rs: [T]/~ = []/~;\n     let mut i = len::<T>(v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n-    while i != 0u { rs += [v[i]]; i -= 1u; }\n-    rs += [v[0]];\n+    while i != 0u { rs += [v[i]]/~; i -= 1u; }\n+    rs += [v[0]]/~;\n     ret rs;\n }\n \n@@ -1064,28 +1065,28 @@ lexicographically sorted).\n The total number of permutations produced is `len(v)!`.  If `v` contains\n repeated elements, then some permutations are repeated.\n \"]\n-pure fn permute<T: copy>(v: [T]/&, put: fn([T])) {\n+pure fn permute<T: copy>(v: [T]/&, put: fn([T]/~)) {\n   let ln = len(v);\n   if ln == 0u {\n-    put([]);\n+    put([]/~);\n   } else {\n     let mut i = 0u;\n     while i < ln {\n       let elt = v[i];\n       let rest = slice(v, 0u, i) + slice(v, i+1u, ln);\n-      permute(rest) {|permutation| put([elt] + permutation)}\n+      permute(rest) {|permutation| put([elt]/~ + permutation)}\n       i += 1u;\n     }\n   }\n }\n \n-pure fn windowed<TT: copy>(nn: uint, xx: [TT]/&) -> [[TT]] {\n-    let mut ww = [];\n+pure fn windowed<TT: copy>(nn: uint, xx: [TT]/&) -> [[TT]/~]/~ {\n+    let mut ww = []/~;\n     assert 1u <= nn;\n     vec::iteri (xx, {|ii, _x|\n         let len = vec::len(xx);\n         if ii+nn <= len {\n-            ww += [vec::slice(xx, ii, ii+nn)];\n+            ww += [vec::slice(xx, ii, ii+nn)]/~;\n         }\n     });\n     ret ww;\n@@ -1146,16 +1147,16 @@ pure fn unpack_mut_slice<T,U>(s: [mut T]/&,\n     }\n }\n \n-impl extensions<T: copy> for [T] {\n+impl extensions<T: copy> for [T]/~ {\n     #[inline(always)]\n-    pure fn +(rhs: [T]/&) -> [T] {\n+    pure fn +(rhs: [T]/&) -> [T]/~ {\n         append(self, rhs)\n     }\n }\n \n-impl extensions<T: copy> for [mut T] {\n+impl extensions<T: copy> for [mut T]/~ {\n     #[inline(always)]\n-    pure fn +(rhs: [mut T]/&) -> [mut T] {\n+    pure fn +(rhs: [mut T]/&) -> [mut T]/~ {\n         append_mut(self, rhs)\n     }\n }\n@@ -1180,18 +1181,18 @@ impl extensions/&<T: copy> for [const T]/& {\n     pure fn head() -> T { head(self) }\n     #[doc = \"Returns all but the last elemnt of a vector\"]\n     #[inline]\n-    pure fn init() -> [T] { init(self) }\n+    pure fn init() -> [T]/~ { init(self) }\n     #[doc = \"\n     Returns the last element of a `v`, failing if the vector is empty.\n     \"]\n     #[inline]\n     pure fn last() -> T { last(self) }\n     #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n     #[inline]\n-    pure fn slice(start: uint, end: uint) -> [T] { slice(self, start, end) }\n+    pure fn slice(start: uint, end: uint) -> [T]/~ { slice(self, start, end) }\n     #[doc = \"Returns all but the first element of a vector\"]\n     #[inline]\n-    pure fn tail() -> [T] { tail(self) }\n+    pure fn tail() -> [T]/~ { tail(self) }\n }\n \n #[doc = \"Extension methods for vectors\"]\n@@ -1259,12 +1260,12 @@ impl extensions/&<T> for [T]/& {\n     Apply a function to each element of a vector and return the results\n     \"]\n     #[inline]\n-    pure fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n+    pure fn map<U>(f: fn(T) -> U) -> [U]/~ { map(self, f) }\n     #[doc = \"\n     Apply a function to the index and value of each element in the vector\n     and return the results\n     \"]\n-    pure fn mapi<U>(f: fn(uint, T) -> U) -> [U] {\n+    pure fn mapi<U>(f: fn(uint, T) -> U) -> [U]/~ {\n         mapi(self, f)\n     }\n     #[doc = \"Returns true if the function returns true for all elements.\n@@ -1278,15 +1279,15 @@ impl extensions/&<T> for [T]/& {\n     of each result vector\n     \"]\n     #[inline]\n-    pure fn flat_map<U>(f: fn(T) -> [U]) -> [U] { flat_map(self, f) }\n+    pure fn flat_map<U>(f: fn(T) -> [U]/~) -> [U]/~ { flat_map(self, f) }\n     #[doc = \"\n     Apply a function to each element of a vector and return the results\n \n     If function `f` returns `none` then that element is excluded from\n     the resulting vector.\n     \"]\n     #[inline]\n-    pure fn filter_map<U: copy>(f: fn(T) -> option<U>) -> [U] {\n+    pure fn filter_map<U: copy>(f: fn(T) -> option<U>) -> [U]/~ {\n         filter_map(self, f)\n     }\n }\n@@ -1301,7 +1302,7 @@ impl extensions/&<T: copy> for [T]/& {\n     only those elements for which `f` returned true.\n     \"]\n     #[inline]\n-    pure fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n+    pure fn filter(f: fn(T) -> bool) -> [T]/~ { filter(self, f) }\n     #[doc = \"\n     Search for the first element that matches a given predicate\n \n@@ -1342,7 +1343,7 @@ mod unsafe {\n     * elts - The number of elements in the buffer\n     \"]\n     #[inline(always)]\n-    unsafe fn from_buf<T>(ptr: *T, elts: uint) -> [T] {\n+    unsafe fn from_buf<T>(ptr: *T, elts: uint) -> [T]/~ {\n         ret ::unsafe::reinterpret_cast(\n             rustrt::vec_from_buf_shared(sys::get_type_desc::<T>(),\n                                         ptr as *(),\n@@ -1357,7 +1358,7 @@ mod unsafe {\n     the vector is actually the specified size.\n     \"]\n     #[inline(always)]\n-    unsafe fn set_len<T>(&&v: [const T], new_len: uint) {\n+    unsafe fn set_len<T>(&&v: [const T]/~, new_len: uint) {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }\n@@ -1372,7 +1373,7 @@ mod unsafe {\n     would also make any pointers to it invalid.\n     \"]\n     #[inline(always)]\n-    unsafe fn to_ptr<T>(v: [const T]) -> *T {\n+    unsafe fn to_ptr<T>(v: [const T]/~) -> *T {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n@@ -1397,7 +1398,7 @@ mod u8 {\n     export hash;\n \n     #[doc = \"Bytewise string comparison\"]\n-    pure fn cmp(&&a: [u8], &&b: [u8]) -> int {\n+    pure fn cmp(&&a: [u8]/~, &&b: [u8]/~) -> int {\n         let a_len = len(a);\n         let b_len = len(b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n@@ -1418,25 +1419,25 @@ mod u8 {\n     }\n \n     #[doc = \"Bytewise less than or equal\"]\n-    pure fn lt(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) < 0 }\n+    pure fn lt(&&a: [u8]/~, &&b: [u8]/~) -> bool { cmp(a, b) < 0 }\n \n     #[doc = \"Bytewise less than or equal\"]\n-    pure fn le(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) <= 0 }\n+    pure fn le(&&a: [u8]/~, &&b: [u8]/~) -> bool { cmp(a, b) <= 0 }\n \n     #[doc = \"Bytewise equality\"]\n-    pure fn eq(&&a: [u8], &&b: [u8]) -> bool { unsafe { cmp(a, b) == 0 } }\n+    pure fn eq(&&a: [u8]/~, &&b: [u8]/~) -> bool { unsafe { cmp(a, b) == 0 } }\n \n     #[doc = \"Bytewise inequality\"]\n-    pure fn ne(&&a: [u8], &&b: [u8]) -> bool { unsafe { cmp(a, b) != 0 } }\n+    pure fn ne(&&a: [u8]/~, &&b: [u8]/~) -> bool { unsafe { cmp(a, b) != 0 } }\n \n     #[doc =\"Bytewise greater than or equal\"]\n-    pure fn ge(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) >= 0 }\n+    pure fn ge(&&a: [u8]/~, &&b: [u8]/~) -> bool { cmp(a, b) >= 0 }\n \n     #[doc = \"Bytewise greater than\"]\n-    pure fn gt(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) > 0 }\n+    pure fn gt(&&a: [u8]/~, &&b: [u8]/~) -> bool { cmp(a, b) > 0 }\n \n     #[doc = \"String hash function\"]\n-    fn hash(&&s: [u8]) -> uint {\n+    fn hash(&&s: [u8]/~) -> uint {\n         /* Seems to have been tragically copy/pasted from str.rs,\n            or vice versa. But I couldn't figure out how to abstract\n            it out. -- tjc */\n@@ -1465,14 +1466,14 @@ impl extensions/&<A> of iter::base_iter<A> for [const A]/& {\n     fn count(x: A) -> uint { iter::count(self, x) }\n }\n impl extensions/&<A:copy> for [const A]/& {\n-    fn filter_to_vec(pred: fn(A) -> bool) -> [A] {\n+    fn filter_to_vec(pred: fn(A) -> bool) -> [A]/~ {\n         iter::filter_to_vec(self, pred)\n     }\n-    fn map_to_vec<B>(op: fn(A) -> B) -> [B] { iter::map_to_vec(self, op) }\n-    fn to_vec() -> [A] { iter::to_vec(self) }\n+    fn map_to_vec<B>(op: fn(A) -> B) -> [B]/~ { iter::map_to_vec(self, op) }\n+    fn to_vec() -> [A]/~ { iter::to_vec(self) }\n \n     // FIXME--bug in resolve prevents this from working (#2611)\n-    // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> [B] {\n+    // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> [B]/~ {\n     //     iter::flat_map_to_vec(self, op)\n     // }\n \n@@ -1504,7 +1505,7 @@ mod tests {\n     fn test_unsafe_ptrs() {\n         unsafe {\n             // Test on-stack copy-from-buf.\n-            let a = [1, 2, 3];\n+            let a = [1, 2, 3]/~;\n             let mut ptr = unsafe::to_ptr(a);\n             let b = unsafe::from_buf(ptr, 3u);\n             assert (len(b) == 3u);\n@@ -1513,7 +1514,7 @@ mod tests {\n             assert (b[2] == 3);\n \n             // Test on-heap copy-from-buf.\n-            let c = [1, 2, 3, 4, 5];\n+            let c = [1, 2, 3, 4, 5]/~;\n             ptr = unsafe::to_ptr(c);\n             let d = unsafe::from_buf(ptr, 5u);\n             assert (len(d) == 5u);\n@@ -1564,58 +1565,58 @@ mod tests {\n \n     #[test]\n     fn test_is_empty() {\n-        assert (is_empty::<int>([]));\n-        assert (!is_empty([0]));\n+        assert (is_empty::<int>([]/~));\n+        assert (!is_empty([0]/~));\n     }\n \n     #[test]\n     fn test_is_not_empty() {\n-        assert (is_not_empty([0]));\n-        assert (!is_not_empty::<int>([]));\n+        assert (is_not_empty([0]/~));\n+        assert (!is_not_empty::<int>([]/~));\n     }\n \n     #[test]\n     fn test_head() {\n-        let a = [11, 12];\n+        let a = [11, 12]/~;\n         assert (head(a) == 11);\n     }\n \n     #[test]\n     fn test_tail() {\n-        let mut a = [11];\n-        assert (tail(a) == []);\n+        let mut a = [11]/~;\n+        assert (tail(a) == []/~);\n \n-        a = [11, 12];\n-        assert (tail(a) == [12]);\n+        a = [11, 12]/~;\n+        assert (tail(a) == [12]/~);\n     }\n \n     #[test]\n     fn test_last() {\n-        let mut n = last_opt([]);\n+        let mut n = last_opt([]/~);\n         assert (n == none);\n-        n = last_opt([1, 2, 3]);\n+        n = last_opt([1, 2, 3]/~);\n         assert (n == some(3));\n-        n = last_opt([1, 2, 3, 4, 5]);\n+        n = last_opt([1, 2, 3, 4, 5]/~);\n         assert (n == some(5));\n     }\n \n     #[test]\n     fn test_slice() {\n         // Test on-stack -> on-stack slice.\n-        let mut v = slice([1, 2, 3], 1u, 3u);\n+        let mut v = slice([1, 2, 3]/~, 1u, 3u);\n         assert (len(v) == 2u);\n         assert (v[0] == 2);\n         assert (v[1] == 3);\n \n         // Test on-heap -> on-stack slice.\n-        v = slice([1, 2, 3, 4, 5], 0u, 3u);\n+        v = slice([1, 2, 3, 4, 5]/~, 0u, 3u);\n         assert (len(v) == 3u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n         assert (v[2] == 3);\n \n         // Test on-heap -> on-heap slice.\n-        v = slice([1, 2, 3, 4, 5, 6], 1u, 6u);\n+        v = slice([1, 2, 3, 4, 5, 6]/~, 1u, 6u);\n         assert (len(v) == 5u);\n         assert (v[0] == 2);\n         assert (v[1] == 3);\n@@ -1627,15 +1628,15 @@ mod tests {\n     #[test]\n     fn test_pop() {\n         // Test on-stack pop.\n-        let mut v = [1, 2, 3];\n+        let mut v = [1, 2, 3]/~;\n         let mut e = pop(v);\n         assert (len(v) == 2u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n         assert (e == 3);\n \n         // Test on-heap pop.\n-        v = [1, 2, 3, 4, 5];\n+        v = [1, 2, 3, 4, 5]/~;\n         e = pop(v);\n         assert (len(v) == 4u);\n         assert (v[0] == 1);\n@@ -1648,7 +1649,7 @@ mod tests {\n     #[test]\n     fn test_push() {\n         // Test on-stack push().\n-        let mut v = [];\n+        let mut v = []/~;\n         push(v, 1);\n         assert (len(v) == 1u);\n         assert (v[0] == 1);\n@@ -1663,7 +1664,7 @@ mod tests {\n     #[test]\n     fn test_grow() {\n         // Test on-stack grow().\n-        let mut v = [];\n+        let mut v = []/~;\n         grow(v, 2u, 1);\n         assert (len(v) == 2u);\n         assert (v[0] == 1);\n@@ -1681,7 +1682,7 @@ mod tests {\n \n     #[test]\n     fn test_grow_fn() {\n-        let mut v = [];\n+        let mut v = []/~;\n         grow_fn(v, 3u, square);\n         assert (len(v) == 3u);\n         assert (v[0] == 0u);\n@@ -1691,7 +1692,7 @@ mod tests {\n \n     #[test]\n     fn test_grow_set() {\n-        let mut v = [mut 1, 2, 3];\n+        let mut v = [mut 1, 2, 3]/~;\n         grow_set(v, 4u, 4, 5);\n         assert (len(v) == 5u);\n         assert (v[0] == 1);\n@@ -1704,15 +1705,15 @@ mod tests {\n     #[test]\n     fn test_map() {\n         // Test on-stack map.\n-        let mut v = [1u, 2u, 3u];\n+        let mut v = [1u, 2u, 3u]/~;\n         let mut w = map(v, square_ref);\n         assert (len(w) == 3u);\n         assert (w[0] == 1u);\n         assert (w[1] == 4u);\n         assert (w[2] == 9u);\n \n         // Test on-heap map.\n-        v = [1u, 2u, 3u, 4u, 5u];\n+        v = [1u, 2u, 3u, 4u, 5u]/~;\n         w = map(v, square_ref);\n         assert (len(w) == 5u);\n         assert (w[0] == 1u);\n@@ -1726,8 +1727,8 @@ mod tests {\n     fn test_map2() {\n         fn times(&&x: int, &&y: int) -> int { ret x * y; }\n         let f = times;\n-        let v0 = [1, 2, 3, 4, 5];\n-        let v1 = [5, 4, 3, 2, 1];\n+        let v0 = [1, 2, 3, 4, 5]/~;\n+        let v1 = [5, 4, 3, 2, 1]/~;\n         let u = map2::<int, int, int>(v0, v1, f);\n         let mut i = 0;\n         while i < 5 { assert (v0[i] * v1[i] == u[i]); i += 1; }\n@@ -1736,14 +1737,14 @@ mod tests {\n     #[test]\n     fn test_filter_map() {\n         // Test on-stack filter-map.\n-        let mut v = [1u, 2u, 3u];\n+        let mut v = [1u, 2u, 3u]/~;\n         let mut w = filter_map(v, square_if_odd);\n         assert (len(w) == 2u);\n         assert (w[0] == 1u);\n         assert (w[1] == 9u);\n \n         // Test on-heap filter-map.\n-        v = [1u, 2u, 3u, 4u, 5u];\n+        v = [1u, 2u, 3u, 4u, 5u]/~;\n         w = filter_map(v, square_if_odd);\n         assert (len(w) == 3u);\n         assert (w[0] == 1u);\n@@ -1756,32 +1757,32 @@ mod tests {\n             } else { ret option::none::<int>; }\n         }\n         fn halve_for_sure(&&i: int) -> int { ret i / 2; }\n-        let all_even: [int] = [0, 2, 8, 6];\n-        let all_odd1: [int] = [1, 7, 3];\n-        let all_odd2: [int] = [];\n-        let mix: [int] = [9, 2, 6, 7, 1, 0, 0, 3];\n-        let mix_dest: [int] = [1, 3, 0, 0];\n+        let all_even: [int]/~ = [0, 2, 8, 6]/~;\n+        let all_odd1: [int]/~ = [1, 7, 3]/~;\n+        let all_odd2: [int]/~ = []/~;\n+        let mix: [int]/~ = [9, 2, 6, 7, 1, 0, 0, 3]/~;\n+        let mix_dest: [int]/~ = [1, 3, 0, 0]/~;\n         assert (filter_map(all_even, halve) == map(all_even, halve_for_sure));\n-        assert (filter_map(all_odd1, halve) == []);\n-        assert (filter_map(all_odd2, halve) == []);\n+        assert (filter_map(all_odd1, halve) == []/~);\n+        assert (filter_map(all_odd2, halve) == []/~);\n         assert (filter_map(mix, halve) == mix_dest);\n     }\n \n     #[test]\n     fn test_filter() {\n-        assert filter([1u, 2u, 3u], is_odd) == [1u, 3u];\n-        assert filter([1u, 2u, 4u, 8u, 16u], is_three) == [];\n+        assert filter([1u, 2u, 3u]/~, is_odd) == [1u, 3u]/~;\n+        assert filter([1u, 2u, 4u, 8u, 16u]/~, is_three) == []/~;\n     }\n \n     #[test]\n     fn test_foldl() {\n         // Test on-stack fold.\n-        let mut v = [1u, 2u, 3u];\n+        let mut v = [1u, 2u, 3u]/~;\n         let mut sum = foldl(0u, v, add);\n         assert (sum == 6u);\n \n         // Test on-heap fold.\n-        v = [1u, 2u, 3u, 4u, 5u];\n+        v = [1u, 2u, 3u, 4u, 5u]/~;\n         sum = foldl(0u, v, add);\n         assert (sum == 15u);\n     }\n@@ -1791,7 +1792,7 @@ mod tests {\n         fn sub(&&a: int, &&b: int) -> int {\n             a - b\n         }\n-        let mut v = [1, 2, 3, 4];\n+        let mut v = [1, 2, 3, 4]/~;\n         let sum = foldl(0, v, sub);\n         assert sum == -10;\n     }\n@@ -1801,29 +1802,29 @@ mod tests {\n         fn sub(&&a: int, &&b: int) -> int {\n             a - b\n         }\n-        let mut v = [1, 2, 3, 4];\n+        let mut v = [1, 2, 3, 4]/~;\n         let sum = foldr(v, 0, sub);\n         assert sum == -2;\n     }\n \n     #[test]\n     fn test_iter_empty() {\n         let mut i = 0;\n-        iter::<int>([], { |_v| i += 1 });\n+        iter::<int>([]/~, { |_v| i += 1 });\n         assert i == 0;\n     }\n \n     #[test]\n     fn test_iter_nonempty() {\n         let mut i = 0;\n-        iter([1, 2, 3], { |v| i += v });\n+        iter([1, 2, 3]/~, { |v| i += v });\n         assert i == 6;\n     }\n \n     #[test]\n     fn test_iteri() {\n         let mut i = 0;\n-        iteri([1, 2, 3], { |j, v|\n+        iteri([1, 2, 3]/~, { |j, v|\n             if i == 0 { assert v == 1; }\n             assert j + 1u == v as uint;\n             i += v;\n@@ -1834,14 +1835,14 @@ mod tests {\n     #[test]\n     fn test_riter_empty() {\n         let mut i = 0;\n-        riter::<int>([], { |_v| i += 1 });\n+        riter::<int>([]/~, { |_v| i += 1 });\n         assert i == 0;\n     }\n \n     #[test]\n     fn test_riter_nonempty() {\n         let mut i = 0;\n-        riter([1, 2, 3], { |v|\n+        riter([1, 2, 3]/~, { |v|\n             if i == 0 { assert v == 3; }\n             i += v\n         });\n@@ -1851,7 +1852,7 @@ mod tests {\n     #[test]\n     fn test_riteri() {\n         let mut i = 0;\n-        riteri([0, 1, 2], { |j, v|\n+        riteri([0, 1, 2]/~, { |j, v|\n             if i == 0 { assert v == 2; }\n             assert j == v as uint;\n             i += v;\n@@ -1861,56 +1862,57 @@ mod tests {\n \n     #[test]\n     fn test_permute() {\n-        let mut results: [[int]];\n+        let mut results: [[int]/~]/~;\n \n-        results = [];\n-        permute([]) {|v| results += [v]; }\n-        assert results == [[]];\n+        results = []/~;\n+        permute([]/~) {|v| results += [v]/~; }\n+        assert results == [[]/~]/~;\n \n-        results = [];\n-        permute([7]) {|v| results += [v]; }\n-        assert results == [[7]];\n+        results = []/~;\n+        permute([7]/~) {|v| results += [v]/~; }\n+        assert results == [[7]/~]/~;\n \n-        results = [];\n-        permute([1,1]) {|v| results += [v]; }\n-        assert results == [[1,1],[1,1]];\n+        results = []/~;\n+        permute([1,1]/~) {|v| results += [v]/~; }\n+        assert results == [[1,1]/~,[1,1]/~]/~;\n \n-        results = [];\n-        permute([5,2,0]) {|v| results += [v]; }\n-        assert results == [[5,2,0],[5,0,2],[2,5,0],[2,0,5],[0,5,2],[0,2,5]];\n+        results = []/~;\n+        permute([5,2,0]/~) {|v| results += [v]/~; }\n+        assert results ==\n+            [[5,2,0]/~,[5,0,2]/~,[2,5,0]/~,[2,0,5]/~,[0,5,2]/~,[0,2,5]/~]/~;\n     }\n \n     #[test]\n     fn test_any_and_all() {\n-        assert (any([1u, 2u, 3u], is_three));\n-        assert (!any([0u, 1u, 2u], is_three));\n-        assert (any([1u, 2u, 3u, 4u, 5u], is_three));\n-        assert (!any([1u, 2u, 4u, 5u, 6u], is_three));\n+        assert (any([1u, 2u, 3u]/~, is_three));\n+        assert (!any([0u, 1u, 2u]/~, is_three));\n+        assert (any([1u, 2u, 3u, 4u, 5u]/~, is_three));\n+        assert (!any([1u, 2u, 4u, 5u, 6u]/~, is_three));\n \n-        assert (all([3u, 3u, 3u], is_three));\n-        assert (!all([3u, 3u, 2u], is_three));\n-        assert (all([3u, 3u, 3u, 3u, 3u], is_three));\n-        assert (!all([3u, 3u, 0u, 1u, 2u], is_three));\n+        assert (all([3u, 3u, 3u]/~, is_three));\n+        assert (!all([3u, 3u, 2u]/~, is_three));\n+        assert (all([3u, 3u, 3u, 3u, 3u]/~, is_three));\n+        assert (!all([3u, 3u, 0u, 1u, 2u]/~, is_three));\n     }\n \n     #[test]\n     fn test_any2_and_all2() {\n \n-        assert (any2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n-        assert (any2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n-        assert (!any2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n-        assert (any2([2u, 4u, 6u], [2u, 4u], is_equal));\n+        assert (any2([2u, 4u, 6u]/~, [2u, 4u, 6u]/~, is_equal));\n+        assert (any2([1u, 2u, 3u]/~, [4u, 5u, 3u]/~, is_equal));\n+        assert (!any2([1u, 2u, 3u]/~, [4u, 5u, 6u]/~, is_equal));\n+        assert (any2([2u, 4u, 6u]/~, [2u, 4u]/~, is_equal));\n \n-        assert (all2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n-        assert (!all2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n-        assert (!all2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n-        assert (!all2([2u, 4u, 6u], [2u, 4u], is_equal));\n+        assert (all2([2u, 4u, 6u]/~, [2u, 4u, 6u]/~, is_equal));\n+        assert (!all2([1u, 2u, 3u]/~, [4u, 5u, 3u]/~, is_equal));\n+        assert (!all2([1u, 2u, 3u]/~, [4u, 5u, 6u]/~, is_equal));\n+        assert (!all2([2u, 4u, 6u]/~, [2u, 4u]/~, is_equal));\n     }\n \n     #[test]\n     fn test_zip_unzip() {\n-        let v1 = [1, 2, 3];\n-        let v2 = [4, 5, 6];\n+        let v1 = [1, 2, 3]/~;\n+        let v2 = [4, 5, 6]/~;\n \n         let z1 = zip(v1, v2);\n \n@@ -1927,9 +1929,9 @@ mod tests {\n \n     #[test]\n     fn test_position_elem() {\n-        assert position_elem([], 1) == none;\n+        assert position_elem([]/~, 1) == none;\n \n-        let v1 = [1, 2, 3, 3, 2, 5];\n+        let v1 = [1, 2, 3, 3, 2, 5]/~;\n         assert position_elem(v1, 1) == some(0u);\n         assert position_elem(v1, 2) == some(1u);\n         assert position_elem(v1, 5) == some(5u);\n@@ -1941,19 +1943,19 @@ mod tests {\n         fn less_than_three(&&i: int) -> bool { ret i < 3; }\n         fn is_eighteen(&&i: int) -> bool { ret i == 18; }\n \n-        assert position([], less_than_three) == none;\n+        assert position([]/~, less_than_three) == none;\n \n-        let v1 = [5, 4, 3, 2, 1];\n+        let v1 = [5, 4, 3, 2, 1]/~;\n         assert position(v1, less_than_three) == some(3u);\n         assert position(v1, is_eighteen) == none;\n     }\n \n     #[test]\n     fn test_position_between() {\n-        assert position_between([], 0u, 0u, f) == none;\n+        assert position_between([]/~, 0u, 0u, f) == none;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')]/~;\n \n         assert position_between(v, 0u, 0u, f) == none;\n         assert position_between(v, 0u, 1u, f) == none;\n@@ -1978,22 +1980,22 @@ mod tests {\n \n     #[test]\n     fn test_find() {\n-        assert find([], f) == none;\n+        assert find([]/~, f) == none;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n-        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')]/~;\n \n         assert find(v, f) == some((1, 'b'));\n         assert find(v, g) == none;\n     }\n \n     #[test]\n     fn test_find_between() {\n-        assert find_between([], 0u, 0u, f) == none;\n+        assert find_between([]/~, 0u, 0u, f) == none;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')]/~;\n \n         assert find_between(v, 0u, 0u, f) == none;\n         assert find_between(v, 0u, 1u, f) == none;\n@@ -2018,22 +2020,22 @@ mod tests {\n \n     #[test]\n     fn test_rposition() {\n-        assert find([], f) == none;\n+        assert find([]/~, f) == none;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n-        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')]/~;\n \n         assert position(v, f) == some(1u);\n         assert position(v, g) == none;\n     }\n \n     #[test]\n     fn test_rposition_between() {\n-        assert rposition_between([], 0u, 0u, f) == none;\n+        assert rposition_between([]/~, 0u, 0u, f) == none;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')]/~;\n \n         assert rposition_between(v, 0u, 0u, f) == none;\n         assert rposition_between(v, 0u, 1u, f) == none;\n@@ -2058,22 +2060,22 @@ mod tests {\n \n     #[test]\n     fn test_rfind() {\n-        assert rfind([], f) == none;\n+        assert rfind([]/~, f) == none;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n         fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n-        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')]/~;\n \n         assert rfind(v, f) == some((3, 'b'));\n         assert rfind(v, g) == none;\n     }\n \n     #[test]\n     fn test_rfind_between() {\n-        assert rfind_between([], 0u, 0u, f) == none;\n+        assert rfind_between([]/~, 0u, 0u, f) == none;\n \n         fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let mut v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')]/~;\n \n         assert rfind_between(v, 0u, 0u, f) == none;\n         assert rfind_between(v, 0u, 1u, f) == none;\n@@ -2098,121 +2100,123 @@ mod tests {\n \n     #[test]\n     fn reverse_and_reversed() {\n-        let v: [mut int] = [mut 10, 20];\n+        let v: [mut int]/~ = [mut 10, 20]/~;\n         assert (v[0] == 10);\n         assert (v[1] == 20);\n         reverse(v);\n         assert (v[0] == 20);\n         assert (v[1] == 10);\n-        let v2 = reversed::<int>([10, 20]);\n+        let v2 = reversed::<int>([10, 20]/~);\n         assert (v2[0] == 20);\n         assert (v2[1] == 10);\n         v[0] = 30;\n         assert (v2[0] == 20);\n         // Make sure they work with 0-length vectors too.\n \n-        let v4 = reversed::<int>([]);\n-        assert (v4 == []);\n-        let v3: [mut int] = [mut];\n+        let v4 = reversed::<int>([]/~);\n+        assert (v4 == []/~);\n+        let v3: [mut int]/~ = [mut]/~;\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n-        let v2 = reversed::<int>([mut 10, 20]);\n+        let v2 = reversed::<int>([mut 10, 20]/~);\n         assert (v2[0] == 20);\n         assert (v2[1] == 10);\n     }\n \n     #[test]\n     fn test_init() {\n-        let v = init([1, 2, 3]);\n-        assert v == [1, 2];\n+        let v = init([1, 2, 3]/~);\n+        assert v == [1, 2]/~;\n     }\n \n     #[test]\n     fn test_split() {\n         fn f(&&x: int) -> bool { x == 3 }\n \n-        assert split([], f) == [];\n-        assert split([1, 2], f) == [[1, 2]];\n-        assert split([3, 1, 2], f) == [[], [1, 2]];\n-        assert split([1, 2, 3], f) == [[1, 2], []];\n-        assert split([1, 2, 3, 4, 3, 5], f) == [[1, 2], [4], [5]];\n+        assert split([]/~, f) == []/~;\n+        assert split([1, 2]/~, f) == [[1, 2]/~]/~;\n+        assert split([3, 1, 2]/~, f) == [[]/~, [1, 2]/~]/~;\n+        assert split([1, 2, 3]/~, f) == [[1, 2]/~, []/~]/~;\n+        assert split([1, 2, 3, 4, 3, 5]/~, f) == [[1, 2]/~, [4]/~, [5]/~]/~;\n     }\n \n     #[test]\n     fn test_splitn() {\n         fn f(&&x: int) -> bool { x == 3 }\n \n-        assert splitn([], 1u, f) == [];\n-        assert splitn([1, 2], 1u, f) == [[1, 2]];\n-        assert splitn([3, 1, 2], 1u, f) == [[], [1, 2]];\n-        assert splitn([1, 2, 3], 1u, f) == [[1, 2], []];\n-        assert splitn([1, 2, 3, 4, 3, 5], 1u, f) == [[1, 2], [4, 3, 5]];\n+        assert splitn([]/~, 1u, f) == []/~;\n+        assert splitn([1, 2]/~, 1u, f) == [[1, 2]/~]/~;\n+        assert splitn([3, 1, 2]/~, 1u, f) == [[]/~, [1, 2]/~]/~;\n+        assert splitn([1, 2, 3]/~, 1u, f) == [[1, 2]/~, []/~]/~;\n+        assert splitn([1, 2, 3, 4, 3, 5]/~, 1u, f) ==\n+                      [[1, 2]/~, [4, 3, 5]/~]/~;\n     }\n \n     #[test]\n     fn test_rsplit() {\n         fn f(&&x: int) -> bool { x == 3 }\n \n-        assert rsplit([], f) == [];\n-        assert rsplit([1, 2], f) == [[1, 2]];\n-        assert rsplit([1, 2, 3], f) == [[1, 2], []];\n-        assert rsplit([1, 2, 3, 4, 3, 5], f) == [[1, 2], [4], [5]];\n+        assert rsplit([]/~, f) == []/~;\n+        assert rsplit([1, 2]/~, f) == [[1, 2]/~]/~;\n+        assert rsplit([1, 2, 3]/~, f) == [[1, 2]/~, []/~]/~;\n+        assert rsplit([1, 2, 3, 4, 3, 5]/~, f) == [[1, 2]/~, [4]/~, [5]/~]/~;\n     }\n \n     #[test]\n     fn test_rsplitn() {\n         fn f(&&x: int) -> bool { x == 3 }\n \n-        assert rsplitn([], 1u, f) == [];\n-        assert rsplitn([1, 2], 1u, f) == [[1, 2]];\n-        assert rsplitn([1, 2, 3], 1u, f) == [[1, 2], []];\n-        assert rsplitn([1, 2, 3, 4, 3, 5], 1u, f) == [[1, 2, 3, 4], [5]];\n+        assert rsplitn([]/~, 1u, f) == []/~;\n+        assert rsplitn([1, 2]/~, 1u, f) == [[1, 2]/~]/~;\n+        assert rsplitn([1, 2, 3]/~, 1u, f) == [[1, 2]/~, []/~]/~;\n+        assert rsplitn([1, 2, 3, 4, 3, 5]/~, 1u, f) ==\n+                       [[1, 2, 3, 4]/~, [5]/~]/~;\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_init_empty() {\n-        init::<int>([]);\n+        init::<int>([]/~);\n     }\n \n     #[test]\n     fn test_concat() {\n-        assert concat([[1], [2,3]]) == [1, 2, 3];\n+        assert concat([[1]/~, [2,3]/~]/~) == [1, 2, 3]/~;\n     }\n \n     #[test]\n     fn test_connect() {\n-        assert connect([], 0) == [];\n-        assert connect([[1], [2, 3]], 0) == [1, 0, 2, 3];\n-        assert connect([[1], [2], [3]], 0) == [1, 0, 2, 0, 3];\n+        assert connect([]/~, 0) == []/~;\n+        assert connect([[1]/~, [2, 3]/~]/~, 0) == [1, 0, 2, 3]/~;\n+        assert connect([[1]/~, [2]/~, [3]/~]/~, 0) == [1, 0, 2, 0, 3]/~;\n     }\n \n     #[test]\n     fn test_windowed () {\n-        assert [[1u,2u,3u],[2u,3u,4u],[3u,4u,5u],[4u,5u,6u]]\n-              == windowed (3u, [1u,2u,3u,4u,5u,6u]);\n+        assert [[1u,2u,3u]/~,[2u,3u,4u]/~,[3u,4u,5u]/~,[4u,5u,6u]/~]/~\n+              == windowed (3u, [1u,2u,3u,4u,5u,6u]/~);\n \n-        assert [[1u,2u,3u,4u],[2u,3u,4u,5u],[3u,4u,5u,6u]]\n-              == windowed (4u, [1u,2u,3u,4u,5u,6u]);\n+        assert [[1u,2u,3u,4u]/~,[2u,3u,4u,5u]/~,[3u,4u,5u,6u]/~]/~\n+              == windowed (4u, [1u,2u,3u,4u,5u,6u]/~);\n \n-        assert [] == windowed (7u, [1u,2u,3u,4u,5u,6u]);\n+        assert []/~ == windowed (7u, [1u,2u,3u,4u,5u,6u]/~);\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_windowed_() {\n-        let _x = windowed (0u, [1u,2u,3u,4u,5u,6u]);\n+        let _x = windowed (0u, [1u,2u,3u,4u,5u,6u]/~);\n     }\n \n     #[test]\n     fn to_mut_no_copy() {\n         unsafe {\n-            let x = [1, 2, 3];\n+            let x = [1, 2, 3]/~;\n             let addr = unsafe::to_ptr(x);\n             let x_mut = to_mut(x);\n             let addr_mut = unsafe::to_ptr(x_mut);\n@@ -2223,7 +2227,7 @@ mod tests {\n     #[test]\n     fn from_mut_no_copy() {\n         unsafe {\n-            let x = [mut 1, 2, 3];\n+            let x = [mut 1, 2, 3]/~;\n             let addr = unsafe::to_ptr(x);\n             let x_imm = from_mut(x);\n             let addr_imm = unsafe::to_ptr(x_imm);\n@@ -2233,24 +2237,24 @@ mod tests {\n \n     #[test]\n     fn test_unshift() {\n-        let mut x = [1, 2, 3];\n+        let mut x = [1, 2, 3]/~;\n         unshift(x, 0);\n-        assert x == [0, 1, 2, 3];\n+        assert x == [0, 1, 2, 3]/~;\n     }\n \n     #[test]\n     fn test_capacity() {\n-        let mut v = [0u64];\n+        let mut v = [0u64]/~;\n         reserve(v, 10u);\n         assert capacity(v) == 10u;\n-        let mut v = [0u32];\n+        let mut v = [0u32]/~;\n         reserve(v, 10u);\n         assert capacity(v) == 10u;\n     }\n \n     #[test]\n     fn test_view() {\n-        let v = [1, 2, 3, 4, 5];\n+        let v = [1, 2, 3, 4, 5]/~;\n         let v = view(v, 1u, 3u);\n         assert(len(v) == 2u);\n         assert(v[0] == 2);"}, {"sha": "ede119bb45966dc44cf90fc192f35e9405106e49", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -5,11 +5,11 @@ export arena, arena_with_size;\n import list;\n import list::{list, cons, nil};\n \n-type chunk = {data: [u8], mut fill: uint};\n+type chunk = {data: [u8]/~, mut fill: uint};\n type arena = {mut chunks: @list<@chunk>};\n \n fn chunk(size: uint) -> @chunk {\n-    let mut v = [];\n+    let mut v = []/~;\n     vec::reserve(v, size);\n     @{ data: v, mut fill: 0u }\n }"}, {"sha": "2cbc9ae018777488bdb850a506987b80a6303953", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -22,7 +22,7 @@ export eq_vec;\n // for the case where nbits <= 32.\n \n #[doc = \"The bitvector type\"]\n-type bitv = @{storage: [mut uint], nbits: uint};\n+type bitv = @{storage: [mut uint]/~, nbits: uint};\n \n const uint_bits: uint = 32u + (1u << 32u >> 27u);\n \n@@ -183,7 +183,7 @@ Converts the bitvector to a vector of uint with the same length.\n \n Each uint in the resulting vector has either value 0u or 1u.\n \"]\n-fn to_vec(v: bitv) -> [uint] {\n+fn to_vec(v: bitv) -> [uint]/~ {\n     let sub = {|x|init_to_vec(v, x)};\n     ret vec::from_fn::<uint>(v.nbits, sub);\n }\n@@ -225,7 +225,7 @@ Compare a bitvector to a vector of uint\n The uint vector is expected to only contain the values 0u and 1u. Both the\n bitvector and vector must have the same length\n \"]\n-fn eq_vec(v0: bitv, v1: [uint]) -> bool {\n+fn eq_vec(v0: bitv, v1: [uint]/~) -> bool {\n     assert (v0.nbits == vec::len::<uint>(v1));\n     let len = v0.nbits;\n     let mut i = 0u;\n@@ -262,9 +262,9 @@ mod tests {\n     fn test_1_element() {\n         let mut act;\n         act = bitv(1u, false);\n-        assert (eq_vec(act, [0u]));\n+        assert (eq_vec(act, [0u]/~));\n         act = bitv(1u, true);\n-        assert (eq_vec(act, [1u]));\n+        assert (eq_vec(act, [1u]/~));\n     }\n \n     #[test]\n@@ -273,11 +273,11 @@ mod tests {\n         // all 0\n \n         act = bitv(10u, false);\n-        assert (eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+        assert (eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]/~));\n         // all 1\n \n         act = bitv(10u, true);\n-        assert (eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n+        assert (eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]/~));\n         // mixed\n \n         act = bitv(10u, false);\n@@ -286,7 +286,7 @@ mod tests {\n         set(act, 2u, true);\n         set(act, 3u, true);\n         set(act, 4u, true);\n-        assert (eq_vec(act, [1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n+        assert (eq_vec(act, [1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]/~));\n         // mixed\n \n         act = bitv(10u, false);\n@@ -295,15 +295,15 @@ mod tests {\n         set(act, 7u, true);\n         set(act, 8u, true);\n         set(act, 9u, true);\n-        assert (eq_vec(act, [0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n+        assert (eq_vec(act, [0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]/~));\n         // mixed\n \n         act = bitv(10u, false);\n         set(act, 0u, true);\n         set(act, 3u, true);\n         set(act, 6u, true);\n         set(act, 9u, true);\n-        assert (eq_vec(act, [1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]));\n+        assert (eq_vec(act, [1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]/~));\n     }\n \n     #[test]\n@@ -315,14 +315,14 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 0u]));\n+                        0u, 0u, 0u, 0u, 0u]/~));\n         // all 1\n \n         act = bitv(31u, true);\n         assert (eq_vec(act,\n                        [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                        1u, 1u, 1u, 1u, 1u]));\n+                        1u, 1u, 1u, 1u, 1u]/~));\n         // mixed\n \n         act = bitv(31u, false);\n@@ -337,7 +337,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 0u]));\n+                        0u, 0u, 0u, 0u, 0u]/~));\n         // mixed\n \n         act = bitv(31u, false);\n@@ -352,7 +352,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 0u]));\n+                        0u, 0u, 0u, 0u, 0u]/~));\n         // mixed\n \n         act = bitv(31u, false);\n@@ -366,7 +366,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n-                        1u, 1u, 1u, 1u, 1u]));\n+                        1u, 1u, 1u, 1u, 1u]/~));\n         // mixed\n \n         act = bitv(31u, false);\n@@ -376,7 +376,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 1u]));\n+                        0u, 0u, 0u, 0u, 1u]/~));\n     }\n \n     #[test]\n@@ -388,14 +388,14 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 0u, 0u]));\n+                        0u, 0u, 0u, 0u, 0u, 0u]/~));\n         // all 1\n \n         act = bitv(32u, true);\n         assert (eq_vec(act,\n                        [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                        1u, 1u, 1u, 1u, 1u, 1u]));\n+                        1u, 1u, 1u, 1u, 1u, 1u]/~));\n         // mixed\n \n         act = bitv(32u, false);\n@@ -410,7 +410,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 0u, 0u]));\n+                        0u, 0u, 0u, 0u, 0u, 0u]/~));\n         // mixed\n \n         act = bitv(32u, false);\n@@ -425,7 +425,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 0u, 0u]));\n+                        0u, 0u, 0u, 0u, 0u, 0u]/~));\n         // mixed\n \n         act = bitv(32u, false);\n@@ -440,7 +440,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n-                        1u, 1u, 1u, 1u, 1u, 1u]));\n+                        1u, 1u, 1u, 1u, 1u, 1u]/~));\n         // mixed\n \n         act = bitv(32u, false);\n@@ -451,7 +451,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 1u, 1u]));\n+                        0u, 0u, 0u, 0u, 1u, 1u]/~));\n     }\n \n     #[test]\n@@ -463,14 +463,14 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u]/~));\n         // all 1\n \n         act = bitv(33u, true);\n         assert (eq_vec(act,\n                        [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                        1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n+                        1u, 1u, 1u, 1u, 1u, 1u, 1u]/~));\n         // mixed\n \n         act = bitv(33u, false);\n@@ -485,7 +485,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u]/~));\n         // mixed\n \n         act = bitv(33u, false);\n@@ -500,7 +500,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u]/~));\n         // mixed\n \n         act = bitv(33u, false);\n@@ -515,7 +515,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n-                        1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n+                        1u, 1u, 1u, 1u, 1u, 1u, 0u]/~));\n         // mixed\n \n         act = bitv(33u, false);\n@@ -527,7 +527,7 @@ mod tests {\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                        0u, 0u, 0u, 0u, 1u, 1u, 1u]));\n+                        0u, 0u, 0u, 0u, 1u, 1u, 1u]/~));\n     }\n \n     #[test]"}, {"sha": "2a9e663a08ce4eb5041c2b4f649c01ab8df4f699", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -24,10 +24,10 @@ fn create<T: copy>() -> t<T> {\n       * Grow is only called on full elts, so nelts is also len(elts), unlike\n       * elsewhere.\n       */\n-    fn grow<T: copy>(nelts: uint, lo: uint, -elts: [mut cell<T>]) ->\n-       [mut cell<T>] {\n+    fn grow<T: copy>(nelts: uint, lo: uint, -elts: [mut cell<T>]/~) ->\n+       [mut cell<T>]/~ {\n         assert (nelts == vec::len(elts));\n-        let mut rv = [mut];\n+        let mut rv = [mut]/~;\n \n         let mut i = 0u;\n         let nalloc = uint::next_power_of_two(nelts + 1u);"}, {"sha": "3a7b88ae7a900bd8915ebf32ce7563332a049136", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -35,7 +35,7 @@ type ebml_state = {ebml_tag: ebml_tag, tag_pos: uint, data_pos: uint};\n // modules within this file.\n \n // ebml reading\n-type doc = {data: @[u8], start: uint, end: uint};\n+type doc = {data: @[u8]/~, start: uint, end: uint};\n \n type tagged_doc = {tag: uint, doc: doc};\n \n@@ -62,11 +62,11 @@ fn vuint_at(data: [u8]/&, start: uint) -> {val: uint, next: uint} {\n     } else { #error(\"vint too big\"); fail; }\n }\n \n-fn doc(data: @[u8]) -> doc {\n+fn doc(data: @[u8]/~) -> doc {\n     ret {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n \n-fn doc_at(data: @[u8], start: uint) -> tagged_doc {\n+fn doc_at(data: @[u8]/~, start: uint) -> tagged_doc {\n     let elt_tag = vuint_at(*data, start);\n     let elt_size = vuint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n@@ -119,7 +119,7 @@ fn tagged_docs(d: doc, tg: uint, it: fn(doc)) {\n     }\n }\n \n-fn doc_data(d: doc) -> [u8] { ret vec::slice::<u8>(*d.data, d.start, d.end); }\n+fn doc_data(d: doc) -> [u8]/~ { vec::slice::<u8>(*d.data, d.start, d.end) }\n \n fn doc_as_str(d: doc) -> str { ret str::from_bytes(doc_data(d)); }\n \n@@ -149,7 +149,7 @@ fn doc_as_i32(d: doc) -> i32 { doc_as_u32(d) as i32 }\n fn doc_as_i64(d: doc) -> i64 { doc_as_u64(d) as i64 }\n \n // ebml writing\n-type writer = {writer: io::writer, mut size_positions: [uint]};\n+type writer = {writer: io::writer, mut size_positions: [uint]/~};\n \n fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n     alt size {\n@@ -180,7 +180,7 @@ fn write_vuint(w: io::writer, n: uint) {\n }\n \n fn writer(w: io::writer) -> writer {\n-    let size_positions: [uint] = [];\n+    let size_positions: [uint]/~ = []/~;\n     ret {writer: w, mut size_positions: size_positions};\n }\n "}, {"sha": "351542111ef75ad9249e3170ff403285081da553", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 110, "deletions": 109, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -28,12 +28,12 @@ name following -o, and accepts both -h and --help as optional flags.\n     }\n \n     fn print_usage(program: str) {\n-        io::println(\\\"Usage: \\\" + program + \\\" [options]\\\");\n+        io::println(\\\"Usage: \\\" + program + \\\" [options]/~\\\");\n         io::println(\\\"-o\\t\\tOutput\\\");\n         io::println(\\\"-h --help\\tUsage\\\");\n     }\n \n-    fn main(args: [str]) {\n+    fn main(args: [str]/~) {\n         check vec::is_not_empty(args);\n \n         let program : str = vec::head(args);\n@@ -42,7 +42,7 @@ name following -o, and accepts both -h and --help as optional flags.\n             optopt(\\\"o\\\"),\n             optflag(\\\"h\\\"),\n             optflag(\\\"help\\\")\n-        ];\n+        ]/~;\n         let match = alt getopts(vec::tail(args), opts) {\n             result::ok(m) { m }\n             result::err(f) { fail fail_str(f) }\n@@ -134,7 +134,7 @@ enum optval { val(str), given, }\n The result of checking command line arguments. Contains a vector\n of matches and a vector of free strings.\n \"]\n-type match = {opts: [opt], vals: [[optval]], free: [str]};\n+type match = {opts: [opt]/~, vals: [[optval]/~]/~, free: [str]/~};\n \n fn is_arg(arg: str) -> bool {\n     ret str::len(arg) > 1u && arg[0] == '-' as u8;\n@@ -144,7 +144,7 @@ fn name_str(nm: name) -> str {\n     ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n }\n \n-fn find_opt(opts: [opt], nm: name) -> option<uint> {\n+fn find_opt(opts: [opt]/~, nm: name) -> option<uint> {\n     vec::position(opts, { |opt| opt.name == nm })\n }\n \n@@ -188,21 +188,21 @@ On success returns `ok(opt)`. Use functions such as `opt_present` `opt_str`,\n etc. to interrogate results.  Returns `err(fail_)` on failure. Use <fail_str>\n to get an error message.\n \"]\n-fn getopts(args: [str], opts: [opt]) -> result unsafe {\n+fn getopts(args: [str]/~, opts: [opt]/~) -> result unsafe {\n     let n_opts = vec::len::<opt>(opts);\n-    fn f(_x: uint) -> [optval] { ret []; }\n+    fn f(_x: uint) -> [optval]/~ { ret []/~; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n-    let mut free: [str] = [];\n+    let mut free: [str]/~ = []/~;\n     let l = vec::len(args);\n     let mut i = 0u;\n     while i < l {\n         let cur = args[i];\n         let curlen = str::len(cur);\n         if !is_arg(cur) {\n-            free += [cur];\n+            free += [cur]/~;\n         } else if str::eq(cur, \"--\") {\n             let mut j = i + 1u;\n-            while j < l { free += [args[j]]; j += 1u; }\n+            while j < l { vec::push(free, args[j]); j += 1u; }\n             break;\n         } else {\n             let mut names;\n@@ -211,19 +211,19 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n                 let tail = str::slice(cur, 2u, curlen);\n                 let tail_eq = str::splitn_char(tail, '=', 1u);\n                 if vec::len(tail_eq) <= 1u {\n-                    names = [long(tail)];\n+                    names = [long(tail)]/~;\n                 } else {\n                     names =\n-                        [long(tail_eq[0])];\n+                        [long(tail_eq[0])]/~;\n                     i_arg =\n                         option::some::<str>(tail_eq[1]);\n                 }\n             } else {\n                 let mut j = 1u;\n-                names = [];\n+                names = []/~;\n                 while j < curlen {\n                     let range = str::char_range_at(cur, j);\n-                    names += [short(range.ch)];\n+                    names += [short(range.ch)]/~;\n                     j = range.next;\n                 }\n             }\n@@ -239,22 +239,23 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n                     if !option::is_none::<str>(i_arg) {\n                         ret err(unexpected_argument(name_str(nm)));\n                     }\n-                    vals[optid] += [given];\n+                    vec::push(vals[optid], given);\n                   }\n                   maybe {\n                     if !option::is_none::<str>(i_arg) {\n-                        vals[optid] += [val(option::get(i_arg))];\n+                        vec::push(vals[optid], val(option::get(i_arg)));\n                     } else if name_pos < vec::len::<name>(names) ||\n                                   i + 1u == l || is_arg(args[i + 1u]) {\n-                        vals[optid] += [given];\n-                    } else { i += 1u; vals[optid] += [val(args[i])]; }\n+                        vec::push(vals[optid], given);\n+                    } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n                   }\n                   yes {\n                     if !option::is_none::<str>(i_arg) {\n-                        vals[optid] += [val(option::get::<str>(i_arg))];\n+                        vec::push(vals[optid],\n+                                  val(option::get::<str>(i_arg)));\n                     } else if i + 1u == l {\n                         ret err(argument_missing(name_str(nm)));\n-                    } else { i += 1u; vals[optid] += [val(args[i])]; }\n+                    } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n                   }\n                 }\n             }\n@@ -280,7 +281,7 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n     ret ok({opts: opts, vals: vec::from_mut(vals), free: free});\n }\n \n-fn opt_vals(m: match, nm: str) -> [optval] {\n+fn opt_vals(m: match, nm: str) -> [optval]/~ {\n     ret alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals[id] }\n           none { #error(\"No option '%s' defined\", nm); fail }\n@@ -295,7 +296,7 @@ fn opt_present(m: match, nm: str) -> bool {\n }\n \n #[doc = \"Returns true if any of several options were matched\"]\n-fn opts_present(m: match, names: [str]) -> bool {\n+fn opts_present(m: match, names: [str]/~) -> bool {\n     for vec::each(names) {|nm|\n         alt find_opt(m.opts, mkname(nm)) {\n           some(_) { ret true; }\n@@ -321,7 +322,7 @@ Returns the string argument supplied to one of several matching options\n Fails if the no option was provided from the given list, or if the no such\n option took an argument\n \"]\n-fn opts_str(m: match, names: [str]) -> str {\n+fn opts_str(m: match, names: [str]/~) -> str {\n     for vec::each(names) {|nm|\n         alt opt_val(m, nm) {\n           val(s) { ret s }\n@@ -337,10 +338,10 @@ Returns a vector of the arguments provided to all matches of the given option.\n \n Used when an option accepts multiple values.\n \"]\n-fn opt_strs(m: match, nm: str) -> [str] {\n-    let mut acc: [str] = [];\n+fn opt_strs(m: match, nm: str) -> [str]/~ {\n+    let mut acc: [str]/~ = []/~;\n     for vec::each(opt_vals(m, nm)) {|v|\n-        alt v { val(s) { acc += [s]; } _ { } }\n+        alt v { val(s) { acc += [s]/~; } _ { } }\n     }\n     ret acc;\n }\n@@ -395,8 +396,8 @@ mod tests {\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt_long() {\n-        let args = [\"--test=20\"];\n-        let opts = [reqopt(\"test\")];\n+        let args = [\"--test=20\"]/~;\n+        let opts = [reqopt(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt check rs {\n           ok(m) {\n@@ -408,8 +409,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_long_missing() {\n-        let args = [\"blah\"];\n-        let opts = [reqopt(\"test\")];\n+        let args = [\"blah\"]/~;\n+        let opts = [reqopt(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_missing_); }\n@@ -419,8 +420,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_long_no_arg() {\n-        let args = [\"--test\"];\n-        let opts = [reqopt(\"test\")];\n+        let args = [\"--test\"]/~;\n+        let opts = [reqopt(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -430,8 +431,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_long_multi() {\n-        let args = [\"--test=20\", \"--test=30\"];\n-        let opts = [reqopt(\"test\")];\n+        let args = [\"--test=20\", \"--test=30\"]/~;\n+        let opts = [reqopt(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -441,8 +442,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_short() {\n-        let args = [\"-t\", \"20\"];\n-        let opts = [reqopt(\"t\")];\n+        let args = [\"-t\", \"20\"]/~;\n+        let opts = [reqopt(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n@@ -455,8 +456,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_short_missing() {\n-        let args = [\"blah\"];\n-        let opts = [reqopt(\"t\")];\n+        let args = [\"blah\"]/~;\n+        let opts = [reqopt(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_missing_); }\n@@ -466,8 +467,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_short_no_arg() {\n-        let args = [\"-t\"];\n-        let opts = [reqopt(\"t\")];\n+        let args = [\"-t\"]/~;\n+        let opts = [reqopt(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -477,8 +478,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_short_multi() {\n-        let args = [\"-t\", \"20\", \"-t\", \"30\"];\n-        let opts = [reqopt(\"t\")];\n+        let args = [\"-t\", \"20\", \"-t\", \"30\"]/~;\n+        let opts = [reqopt(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -490,8 +491,8 @@ mod tests {\n     // Tests for optopt\n     #[test]\n     fn test_optopt_long() {\n-        let args = [\"--test=20\"];\n-        let opts = [optopt(\"test\")];\n+        let args = [\"--test=20\"]/~;\n+        let opts = [optopt(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n@@ -504,8 +505,8 @@ mod tests {\n \n     #[test]\n     fn test_optopt_long_missing() {\n-        let args = [\"blah\"];\n-        let opts = [optopt(\"test\")];\n+        let args = [\"blah\"]/~;\n+        let opts = [optopt(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) { assert (!opt_present(m, \"test\")); }\n@@ -515,8 +516,8 @@ mod tests {\n \n     #[test]\n     fn test_optopt_long_no_arg() {\n-        let args = [\"--test\"];\n-        let opts = [optopt(\"test\")];\n+        let args = [\"--test\"]/~;\n+        let opts = [optopt(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -526,8 +527,8 @@ mod tests {\n \n     #[test]\n     fn test_optopt_long_multi() {\n-        let args = [\"--test=20\", \"--test=30\"];\n-        let opts = [optopt(\"test\")];\n+        let args = [\"--test=20\", \"--test=30\"]/~;\n+        let opts = [optopt(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -537,8 +538,8 @@ mod tests {\n \n     #[test]\n     fn test_optopt_short() {\n-        let args = [\"-t\", \"20\"];\n-        let opts = [optopt(\"t\")];\n+        let args = [\"-t\", \"20\"]/~;\n+        let opts = [optopt(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n@@ -551,8 +552,8 @@ mod tests {\n \n     #[test]\n     fn test_optopt_short_missing() {\n-        let args = [\"blah\"];\n-        let opts = [optopt(\"t\")];\n+        let args = [\"blah\"]/~;\n+        let opts = [optopt(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) { assert (!opt_present(m, \"t\")); }\n@@ -562,8 +563,8 @@ mod tests {\n \n     #[test]\n     fn test_optopt_short_no_arg() {\n-        let args = [\"-t\"];\n-        let opts = [optopt(\"t\")];\n+        let args = [\"-t\"]/~;\n+        let opts = [optopt(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -573,8 +574,8 @@ mod tests {\n \n     #[test]\n     fn test_optopt_short_multi() {\n-        let args = [\"-t\", \"20\", \"-t\", \"30\"];\n-        let opts = [optopt(\"t\")];\n+        let args = [\"-t\", \"20\", \"-t\", \"30\"]/~;\n+        let opts = [optopt(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -586,8 +587,8 @@ mod tests {\n     // Tests for optflag\n     #[test]\n     fn test_optflag_long() {\n-        let args = [\"--test\"];\n-        let opts = [optflag(\"test\")];\n+        let args = [\"--test\"]/~;\n+        let opts = [optflag(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) { assert (opt_present(m, \"test\")); }\n@@ -597,8 +598,8 @@ mod tests {\n \n     #[test]\n     fn test_optflag_long_missing() {\n-        let args = [\"blah\"];\n-        let opts = [optflag(\"test\")];\n+        let args = [\"blah\"]/~;\n+        let opts = [optflag(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) { assert (!opt_present(m, \"test\")); }\n@@ -608,8 +609,8 @@ mod tests {\n \n     #[test]\n     fn test_optflag_long_arg() {\n-        let args = [\"--test=20\"];\n-        let opts = [optflag(\"test\")];\n+        let args = [\"--test=20\"]/~;\n+        let opts = [optflag(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) {\n@@ -622,8 +623,8 @@ mod tests {\n \n     #[test]\n     fn test_optflag_long_multi() {\n-        let args = [\"--test\", \"--test\"];\n-        let opts = [optflag(\"test\")];\n+        let args = [\"--test\", \"--test\"]/~;\n+        let opts = [optflag(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -633,8 +634,8 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short() {\n-        let args = [\"-t\"];\n-        let opts = [optflag(\"t\")];\n+        let args = [\"-t\"]/~;\n+        let opts = [optflag(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) { assert (opt_present(m, \"t\")); }\n@@ -644,8 +645,8 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short_missing() {\n-        let args = [\"blah\"];\n-        let opts = [optflag(\"t\")];\n+        let args = [\"blah\"]/~;\n+        let opts = [optflag(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) { assert (!opt_present(m, \"t\")); }\n@@ -655,8 +656,8 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short_arg() {\n-        let args = [\"-t\", \"20\"];\n-        let opts = [optflag(\"t\")];\n+        let args = [\"-t\", \"20\"]/~;\n+        let opts = [optflag(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n@@ -670,8 +671,8 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short_multi() {\n-        let args = [\"-t\", \"-t\"];\n-        let opts = [optflag(\"t\")];\n+        let args = [\"-t\", \"-t\"]/~;\n+        let opts = [optflag(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -683,8 +684,8 @@ mod tests {\n     // Tests for optmulti\n     #[test]\n     fn test_optmulti_long() {\n-        let args = [\"--test=20\"];\n-        let opts = [optmulti(\"test\")];\n+        let args = [\"--test=20\"]/~;\n+        let opts = [optmulti(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n@@ -697,8 +698,8 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_long_missing() {\n-        let args = [\"blah\"];\n-        let opts = [optmulti(\"test\")];\n+        let args = [\"blah\"]/~;\n+        let opts = [optmulti(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) { assert (!opt_present(m, \"test\")); }\n@@ -708,8 +709,8 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_long_no_arg() {\n-        let args = [\"--test\"];\n-        let opts = [optmulti(\"test\")];\n+        let args = [\"--test\"]/~;\n+        let opts = [optmulti(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -719,8 +720,8 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_long_multi() {\n-        let args = [\"--test=20\", \"--test=30\"];\n-        let opts = [optmulti(\"test\")];\n+        let args = [\"--test=20\", \"--test=30\"]/~;\n+        let opts = [optmulti(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n@@ -735,8 +736,8 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_short() {\n-        let args = [\"-t\", \"20\"];\n-        let opts = [optmulti(\"t\")];\n+        let args = [\"-t\", \"20\"]/~;\n+        let opts = [optmulti(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n@@ -749,8 +750,8 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_short_missing() {\n-        let args = [\"blah\"];\n-        let opts = [optmulti(\"t\")];\n+        let args = [\"blah\"]/~;\n+        let opts = [optmulti(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) { assert (!opt_present(m, \"t\")); }\n@@ -760,8 +761,8 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_short_no_arg() {\n-        let args = [\"-t\"];\n-        let opts = [optmulti(\"t\")];\n+        let args = [\"-t\"]/~;\n+        let opts = [optmulti(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -771,8 +772,8 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_short_multi() {\n-        let args = [\"-t\", \"20\", \"-t\", \"30\"];\n-        let opts = [optmulti(\"t\")];\n+        let args = [\"-t\", \"20\", \"-t\", \"30\"]/~;\n+        let opts = [optmulti(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n@@ -787,8 +788,8 @@ mod tests {\n \n     #[test]\n     fn test_unrecognized_option_long() {\n-        let args = [\"--untest\"];\n-        let opts = [optmulti(\"t\")];\n+        let args = [\"--untest\"]/~;\n+        let opts = [optmulti(\"t\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, unrecognized_option_); }\n@@ -798,8 +799,8 @@ mod tests {\n \n     #[test]\n     fn test_unrecognized_option_short() {\n-        let args = [\"-t\"];\n-        let opts = [optmulti(\"test\")];\n+        let args = [\"-t\"]/~;\n+        let opts = [optmulti(\"test\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, unrecognized_option_); }\n@@ -811,11 +812,11 @@ mod tests {\n     fn test_combined() {\n         let args =\n             [\"prog\", \"free1\", \"-s\", \"20\", \"free2\", \"--flag\", \"--long=30\",\n-             \"-f\", \"-m\", \"40\", \"-m\", \"50\", \"-n\", \"-A B\", \"-n\", \"-60 70\"];\n+             \"-f\", \"-m\", \"40\", \"-m\", \"50\", \"-n\", \"-A B\", \"-n\", \"-60 70\"]/~;\n         let opts =\n             [optopt(\"s\"), optflag(\"flag\"), reqopt(\"long\"),\n              optflag(\"f\"), optmulti(\"m\"), optmulti(\"n\"),\n-             optopt(\"notpresent\")];\n+             optopt(\"notpresent\")]/~;\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n@@ -838,23 +839,23 @@ mod tests {\n \n     #[test]\n     fn test_multi() {\n-        let args = [\"-e\", \"foo\", \"--encrypt\", \"foo\"];\n-        let opts = [optopt(\"e\"), optopt(\"encrypt\")];\n+        let args = [\"-e\", \"foo\", \"--encrypt\", \"foo\"]/~;\n+        let opts = [optopt(\"e\"), optopt(\"encrypt\")]/~;\n         let match = alt getopts(args, opts) {\n           result::ok(m) { m }\n           result::err(f) { fail; }\n         };\n-        assert opts_present(match, [\"e\"]);\n-        assert opts_present(match, [\"encrypt\"]);\n-        assert opts_present(match, [\"encrypt\", \"e\"]);\n-        assert opts_present(match, [\"e\", \"encrypt\"]);\n-        assert !opts_present(match, [\"thing\"]);\n-        assert !opts_present(match, []);\n-\n-        assert opts_str(match, [\"e\"]) == \"foo\";\n-        assert opts_str(match, [\"encrypt\"]) == \"foo\";\n-        assert opts_str(match, [\"e\", \"encrypt\"]) == \"foo\";\n-        assert opts_str(match, [\"encrypt\", \"e\"]) == \"foo\";\n+        assert opts_present(match, [\"e\"]/~);\n+        assert opts_present(match, [\"encrypt\"]/~);\n+        assert opts_present(match, [\"encrypt\", \"e\"]/~);\n+        assert opts_present(match, [\"e\", \"encrypt\"]/~);\n+        assert !opts_present(match, [\"thing\"]/~);\n+        assert !opts_present(match, []/~);\n+\n+        assert opts_str(match, [\"e\"]/~) == \"foo\";\n+        assert opts_str(match, [\"encrypt\"]/~) == \"foo\";\n+        assert opts_str(match, [\"e\", \"encrypt\"]/~) == \"foo\";\n+        assert opts_str(match, [\"encrypt\", \"e\"]/~) == \"foo\";\n     }\n }\n "}, {"sha": "947b037841eafb5b29996a2389e6e633ec902649", "filename": "src/libstd/json.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -30,7 +30,7 @@ enum json {\n     num(float),\n     string(@str),\n     boolean(bool),\n-    list(@[json]),\n+    list(@[json]/~),\n     dict(map::hashmap<str, json>),\n     null,\n }\n@@ -383,7 +383,7 @@ impl parser for parser {\n         self.bump();\n         self.parse_whitespace();\n \n-        let mut values = [];\n+        let mut values = []/~;\n \n         if self.ch == ']' {\n             self.bump();\n@@ -585,19 +585,19 @@ impl of to_json for @str {\n impl <A: to_json copy, B: to_json copy> of to_json for (A, B) {\n     fn to_json() -> json {\n         let (a, b) = self;\n-        list(@[a.to_json(), b.to_json()])\n+        list(@[a.to_json(), b.to_json()]/~)\n     }\n }\n \n impl <A: to_json copy, B: to_json copy, C: to_json copy>\n   of to_json for (A, B, C) {\n     fn to_json() -> json {\n         let (a, b, c) = self;\n-        list(@[a.to_json(), b.to_json(), c.to_json()])\n+        list(@[a.to_json(), b.to_json(), c.to_json()]/~)\n     }\n }\n \n-impl <A: to_json> of to_json for [A] {\n+impl <A: to_json> of to_json for [A]/~ {\n     fn to_json() -> json { list(@self.map { |elt| elt.to_json() }) }\n }\n \n@@ -632,7 +632,7 @@ impl of to_str::to_str for error {\n \n #[cfg(test)]\n mod tests {\n-    fn mk_dict(items: [(str, json)]) -> json {\n+    fn mk_dict(items: [(str, json)]/~) -> json {\n         let d = map::str_hash();\n \n         vec::iter(items) { |item|\n@@ -670,26 +670,26 @@ mod tests {\n \n     #[test]\n     fn test_write_list() {\n-        assert to_str(list(@[])) == \"[]\";\n-        assert to_str(list(@[boolean(true)])) == \"[true]\";\n+        assert to_str(list(@[]/~)) == \"[]\";\n+        assert to_str(list(@[boolean(true)]/~)) == \"[true]\";\n         assert to_str(list(@[\n             boolean(false),\n             null,\n-            list(@[string(@\"foo\\nbar\"), num(3.5f)])\n-        ])) == \"[false, null, [\\\"foo\\\\nbar\\\", 3.5]]\";\n+            list(@[string(@\"foo\\nbar\"), num(3.5f)]/~)\n+        ]/~)) == \"[false, null, [\\\"foo\\\\nbar\\\", 3.5]]\";\n     }\n \n     #[test]\n     fn test_write_dict() {\n-        assert to_str(mk_dict([])) == \"{}\";\n-        assert to_str(mk_dict([(\"a\", boolean(true))])) == \"{ \\\"a\\\": true }\";\n+        assert to_str(mk_dict([]/~)) == \"{}\";\n+        assert to_str(mk_dict([(\"a\", boolean(true))]/~)) == \"{ \\\"a\\\": true }\";\n         assert to_str(mk_dict([\n             (\"a\", boolean(true)),\n             (\"b\", list(@[\n-                mk_dict([(\"c\", string(@\"\\x0c\\r\"))]),\n-                mk_dict([(\"d\", string(@\"\"))])\n-            ]))\n-        ])) ==\n+                mk_dict([(\"c\", string(@\"\\x0c\\r\"))]/~),\n+                mk_dict([(\"d\", string(@\"\"))]/~)\n+            ]/~))\n+        ]/~)) ==\n             \"{ \" +\n                 \"\\\"a\\\": true, \" +\n                 \"\\\"b\\\": [\" +\n@@ -709,7 +709,7 @@ mod tests {\n             err({line: 1u, col: 6u, msg: @\"trailing characters\"});\n         assert from_str(\"1a\") ==\n             err({line: 1u, col: 2u, msg: @\"trailing characters\"});\n-        assert from_str(\"[]a\") ==\n+        assert from_str(\"[]/~a\") ==\n             err({line: 1u, col: 3u, msg: @\"trailing characters\"});\n         assert from_str(\"{}a\") ==\n             err({line: 1u, col: 3u, msg: @\"trailing characters\"});\n@@ -798,15 +798,15 @@ mod tests {\n         assert from_str(\"[6 7]\") ==\n             err({line: 1u, col: 4u, msg: @\"expecting ',' or ']'\"});\n \n-        assert from_str(\"[]\") == ok(list(@[]));\n-        assert from_str(\"[ ]\") == ok(list(@[]));\n-        assert from_str(\"[true]\") == ok(list(@[boolean(true)]));\n-        assert from_str(\"[ false ]\") == ok(list(@[boolean(false)]));\n-        assert from_str(\"[null]\") == ok(list(@[null]));\n-        assert from_str(\"[3, 1]\") == ok(list(@[num(3f), num(1f)]));\n-        assert from_str(\"\\n[3, 2]\\n\") == ok(list(@[num(3f), num(2f)]));\n+        assert from_str(\"[]\") == ok(list(@[]/~));\n+        assert from_str(\"[ ]\") == ok(list(@[]/~));\n+        assert from_str(\"[true]\") == ok(list(@[boolean(true)]/~));\n+        assert from_str(\"[ false ]\") == ok(list(@[boolean(false)]/~));\n+        assert from_str(\"[null]\") == ok(list(@[null]/~));\n+        assert from_str(\"[3, 1]\") == ok(list(@[num(3f), num(1f)]/~));\n+        assert from_str(\"\\n[3, 2]\\n\") == ok(list(@[num(3f), num(2f)]/~));\n         assert from_str(\"[2, [4, 1]]\") ==\n-               ok(list(@[num(2f), list(@[num(4f), num(1f)])]));\n+               ok(list(@[num(2f), list(@[num(4f), num(1f)]/~)]/~));\n     }\n \n     #[test]\n@@ -835,23 +835,23 @@ mod tests {\n         assert from_str(\"{\\\"a\\\":1,\") ==\n             err({line: 1u, col: 8u, msg: @\"EOF while parsing object\"});\n \n-        assert eq(result::get(from_str(\"{}\")), mk_dict([]));\n+        assert eq(result::get(from_str(\"{}\")), mk_dict([]/~));\n         assert eq(result::get(from_str(\"{\\\"a\\\": 3}\")),\n-                  mk_dict([(\"a\", num(3.0f))]));\n+                  mk_dict([(\"a\", num(3.0f))]/~));\n \n         assert eq(result::get(from_str(\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n                   mk_dict([\n                       (\"a\", null),\n-                      (\"b\", boolean(true))]));\n+                      (\"b\", boolean(true))]/~));\n         assert eq(result::get(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n                   mk_dict([\n                       (\"a\", null),\n-                      (\"b\", boolean(true))]));\n+                      (\"b\", boolean(true))]/~));\n         assert eq(result::get(from_str(\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n                   mk_dict([\n                       (\"a\", num(1.0)),\n-                      (\"b\", list(@[boolean(true)]))\n-                  ]));\n+                      (\"b\", list(@[boolean(true)]/~))\n+                  ]/~));\n         assert eq(result::get(from_str(\n                       \"{\" +\n                           \"\\\"a\\\": 1.0, \" +\n@@ -867,10 +867,10 @@ mod tests {\n                           boolean(true),\n                           string(@\"foo\\nbar\"),\n                           mk_dict([\n-                              (\"c\", mk_dict([(\"d\", null)]))\n-                          ])\n-                      ]))\n-                  ]));\n+                              (\"c\", mk_dict([(\"d\", null)]/~))\n+                          ]/~)\n+                      ]/~))\n+                  ]/~));\n     }\n \n     #[test]"}, {"sha": "ad7828da8c6d47b69e8798fd4bf1040c7aaa8bf7", "filename": "src/libstd/list.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -10,7 +10,7 @@ enum list<T> {\n }\n \n #[doc = \"Create a list from a vector\"]\n-fn from_vec<T: copy>(v: [T]) -> @list<T> {\n+fn from_vec<T: copy>(v: [T]/~) -> @list<T> {\n     vec::foldr(v, @nil::<T>, { |h, t| @cons(h, t) })\n }\n \n@@ -135,9 +135,9 @@ mod tests {\n \n     #[test]\n     fn test_is_empty() {\n-        let empty : @list::list<int> = from_vec([]);\n-        let full1 = from_vec([1]);\n-        let full2 = from_vec(['r', 'u']);\n+        let empty : @list::list<int> = from_vec([]/~);\n+        let full1 = from_vec([1]/~);\n+        let full2 = from_vec(['r', 'u']/~);\n \n         assert is_empty(empty);\n         assert !is_empty(full1);\n@@ -150,7 +150,7 @@ mod tests {\n \n     #[test]\n     fn test_from_vec() {\n-        let l = from_vec([0, 1, 2]);\n+        let l = from_vec([0, 1, 2]/~);\n \n         assert (head(l) == 0);\n \n@@ -163,14 +163,14 @@ mod tests {\n \n     #[test]\n     fn test_from_vec_empty() {\n-        let empty : @list::list<int> = from_vec([]);\n+        let empty : @list::list<int> = from_vec([]/~);\n         assert (empty == @list::nil::<int>);\n     }\n \n     #[test]\n     fn test_foldl() {\n         fn add(&&a: uint, &&b: int) -> uint { ret a + (b as uint); }\n-        let l = from_vec([0, 1, 2, 3, 4]);\n+        let l = from_vec([0, 1, 2, 3, 4]/~);\n         let empty = @list::nil::<int>;\n         assert (list::foldl(0u, l, add) == 10u);\n         assert (list::foldl(0u, empty, add) == 0u);\n@@ -181,29 +181,29 @@ mod tests {\n         fn sub(&&a: int, &&b: int) -> int {\n             a - b\n         }\n-        let l = from_vec([1, 2, 3, 4]);\n+        let l = from_vec([1, 2, 3, 4]/~);\n         assert (list::foldl(0, l, sub) == -10);\n     }\n \n     #[test]\n     fn test_find_success() {\n         fn match(&&i: int) -> bool { ret i == 2; }\n-        let l = from_vec([0, 1, 2]);\n+        let l = from_vec([0, 1, 2]/~);\n         assert (list::find(l, match) == option::some(2));\n     }\n \n     #[test]\n     fn test_find_fail() {\n         fn match(&&_i: int) -> bool { ret false; }\n-        let l = from_vec([0, 1, 2]);\n+        let l = from_vec([0, 1, 2]/~);\n         let empty = @list::nil::<int>;\n         assert (list::find(l, match) == option::none::<int>);\n         assert (list::find(empty, match) == option::none::<int>);\n     }\n \n     #[test]\n     fn test_has() {\n-        let l = from_vec([5, 8, 6]);\n+        let l = from_vec([5, 8, 6]/~);\n         let empty = @list::nil::<int>;\n         assert (list::has(l, 5));\n         assert (!list::has(l, 7));\n@@ -213,7 +213,7 @@ mod tests {\n \n     #[test]\n     fn test_len() {\n-        let l = from_vec([0, 1, 2]);\n+        let l = from_vec([0, 1, 2]/~);\n         let empty = @list::nil::<int>;\n         assert (list::len(l) == 3u);\n         assert (list::len(empty) == 0u);"}, {"sha": "7d1e7b599a0cf04f1f0b683906b0f297acf6db37", "filename": "src/libstd/map.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -86,7 +86,7 @@ mod chained {\n \n     type t<K, V> = @{\n         mut count: uint,\n-        mut chains: [mut chain<K,V>],\n+        mut chains: [mut chain<K,V>]/~,\n         hasher: hashfn<K>,\n         eqer: eqfn<K>\n     };\n@@ -259,7 +259,7 @@ mod chained {\n         fn each_value(blk: fn(V) -> bool) { self.each { |_k, v| blk(v)} }\n     }\n \n-    fn chains<K,V>(nchains: uint) -> [mut chain<K,V>] {\n+    fn chains<K,V>(nchains: uint) -> [mut chain<K,V>]/~ {\n         ret vec::to_mut(vec::from_elem(nchains, absent));\n     }\n \n@@ -299,7 +299,7 @@ fn box_str_hash<V: copy>() -> hashmap<@str, V> {\n }\n \n #[doc = \"Construct a hashmap for byte string keys\"]\n-fn bytes_hash<V: copy>() -> hashmap<[u8], V> {\n+fn bytes_hash<V: copy>() -> hashmap<[u8]/~, V> {\n     ret hashmap(vec::u8::hash, vec::u8::eq);\n }\n \n@@ -323,18 +323,18 @@ fn set_add<K: const copy>(set: set<K>, key: K) -> bool {\n #[doc = \"\n Convert a set into a vector.\n \"]\n-fn vec_from_set<T: copy>(s: set<T>) -> [T] {\n-    let mut v = [];\n+fn vec_from_set<T: copy>(s: set<T>) -> [T]/~ {\n+    let mut v = []/~;\n     s.each_key() {|k|\n-        v += [k];\n+        v += [k]/~;\n         true\n     };\n     v\n }\n \n #[doc = \"Construct a hashmap from a vector\"]\n fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                                         items: [(K, V)]) -> hashmap<K, V> {\n+                                         items: [(K, V)]/~) -> hashmap<K, V> {\n     let map = hashmap(hasher, eqer);\n     vec::iter(items) { |item|\n         let (key, value) = item;\n@@ -344,22 +344,22 @@ fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n }\n \n #[doc = \"Construct a hashmap from a vector with string keys\"]\n-fn hash_from_strs<V: copy>(items: [(str, V)]) -> hashmap<str, V> {\n+fn hash_from_strs<V: copy>(items: [(str, V)]/~) -> hashmap<str, V> {\n     hash_from_vec(str::hash, str::eq, items)\n }\n \n #[doc = \"Construct a hashmap from a vector with byte keys\"]\n-fn hash_from_bytes<V: copy>(items: [([u8], V)]) -> hashmap<[u8], V> {\n+fn hash_from_bytes<V: copy>(items: [([u8]/~, V)]/~) -> hashmap<[u8]/~, V> {\n     hash_from_vec(vec::u8::hash, vec::u8::eq, items)\n }\n \n #[doc = \"Construct a hashmap from a vector with int keys\"]\n-fn hash_from_ints<V: copy>(items: [(int, V)]) -> hashmap<int, V> {\n+fn hash_from_ints<V: copy>(items: [(int, V)]/~) -> hashmap<int, V> {\n     hash_from_vec(int::hash, int::eq, items)\n }\n \n #[doc = \"Construct a hashmap from a vector with uint keys\"]\n-fn hash_from_uints<V: copy>(items: [(uint, V)]) -> hashmap<uint, V> {\n+fn hash_from_uints<V: copy>(items: [(uint, V)]/~) -> hashmap<uint, V> {\n     hash_from_vec(uint::hash, uint::eq, items)\n }\n \n@@ -612,7 +612,7 @@ mod tests {\n             (\"a\", 1),\n             (\"b\", 2),\n             (\"c\", 3)\n-        ]);\n+        ]/~);\n         assert map.size() == 3u;\n         assert map.get(\"a\") == 1;\n         assert map.get(\"b\") == 2;"}, {"sha": "08fa6f8597a97e9a6d5575f60c8c8c85eb19307b", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -1,21 +1,21 @@\n-fn md4(msg: [u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n+fn md4(msg: [u8]/~) -> {a: u32, b: u32, c: u32, d: u32} {\n     // subtle: if orig_len is merely uint, then the code below\n     // which performs shifts by 32 bits or more has undefined\n     // results.\n     let orig_len: u64 = (vec::len(msg) * 8u) as u64;\n \n     // pad message\n-    let mut msg = msg + [0x80u8];\n+    let mut msg = msg + [0x80u8]/~;\n     let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n-        msg += [0u8];\n+        msg += [0u8]/~;\n         bitlen += 8u64;\n     }\n \n     // append length\n     let mut i = 0u64;\n     while i < 8u64 {\n-        msg += [(orig_len >> (i * 8u64)) as u8];\n+        msg += [(orig_len >> (i * 8u64)) as u8]/~;\n         i += 1u64;\n     }\n \n@@ -82,7 +82,7 @@ fn md4(msg: [u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     ret {a: a, b: b, c: c, d: d};\n }\n \n-fn md4_str(msg: [u8]) -> str {\n+fn md4_str(msg: [u8]/~) -> str {\n     let {a, b, c, d} = md4(msg);\n     fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n         f(a); f(b); f(c); f(d);"}, {"sha": "386e869d98325c9ffe0b0ee188f812048736b531", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -113,7 +113,7 @@ fn connect(input_ip: ip::ip_addr, port: uint,\n         closed_signal_ch: comm::chan(closed_signal_po)\n     };\n     let conn_data_ptr = ptr::addr_of(conn_data);\n-    let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n+    let reader_po = comm::port::<result::result<[u8]/~, tcp_err_data>>();\n     let stream_handle_ptr = malloc_uv_tcp_t();\n     *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n     let socket_data = @{\n@@ -206,15 +206,15 @@ Write binary data to a tcp stream; Blocks until operation completes\n # Arguments\n \n * sock - a `tcp_socket` to write to\n-* raw_write_data - a vector of `[u8]` that will be written to the stream.\n+* raw_write_data - a vector of `[u8]/~` that will be written to the stream.\n This value must remain valid for the duration of the `write` call\n \n # Returns\n \n A `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n value as the `err` variant\n \"]\n-fn write(sock: tcp_socket, raw_write_data: [u8])\n+fn write(sock: tcp_socket, raw_write_data: [u8]/~)\n     -> result::result<(), tcp_err_data> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     write_common_impl(socket_data_ptr, raw_write_data)\n@@ -238,7 +238,7 @@ Otherwise, use the blocking `tcp::write` function instead.\n # Arguments\n \n * sock - a `tcp_socket` to write to\n-* raw_write_data - a vector of `[u8]` that will be written to the stream.\n+* raw_write_data - a vector of `[u8]/~` that will be written to the stream.\n This value must remain valid for the duration of the `write` call\n \n # Returns\n@@ -247,7 +247,7 @@ A `future` value that, once the `write` operation completes, resolves to a\n `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n value as the `err` variant\n \"]\n-fn write_future(sock: tcp_socket, raw_write_data: [u8])\n+fn write_future(sock: tcp_socket, raw_write_data: [u8]/~)\n     -> future::future<result::result<(), tcp_err_data>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     future::spawn {||\n@@ -270,7 +270,7 @@ on) from until `read_stop` is called, or a `tcp_err_data` record\n \"]\n fn read_start(sock: tcp_socket)\n     -> result::result<comm::port<\n-        result::result<[u8], tcp_err_data>>, tcp_err_data> unsafe {\n+        result::result<[u8]/~, tcp_err_data>>, tcp_err_data> unsafe {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_start_common_impl(socket_data)\n }\n@@ -303,13 +303,13 @@ data received.\n read attempt. Pass `0u` to wait indefinitely\n \"]\n fn read(sock: tcp_socket, timeout_msecs: uint)\n-    -> result::result<[u8],tcp_err_data> {\n+    -> result::result<[u8]/~,tcp_err_data> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_common_impl(socket_data, timeout_msecs)\n }\n \n #[doc=\"\n-Reads a single chunk of data; returns a `future::future<[u8]>` immediately\n+Reads a single chunk of data; returns a `future::future<[u8]/~>` immediately\n \n Does a non-blocking read operation for a single chunk of data from a\n `tcp_socket` and immediately returns a `future` value representing the\n@@ -337,7 +337,7 @@ Otherwise, use the blocking `tcp::read` function instead.\n read attempt. Pass `0u` to wait indefinitely\n \"]\n fn read_future(sock: tcp_socket, timeout_msecs: uint)\n-    -> future::future<result::result<[u8],tcp_err_data>> {\n+    -> future::future<result::result<[u8]/~,tcp_err_data>> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     future::spawn {||\n         read_common_impl(socket_data, timeout_msecs)\n@@ -590,7 +590,7 @@ fn accept(new_conn: tcp_new_connection)\n       new_tcp_conn(server_handle_ptr) {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n             server_handle_ptr) as *tcp_listen_fc_data;\n-        let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n+        let reader_po = comm::port::<result::result<[u8]/~, tcp_err_data>>();\n         let iotask = (*server_data_ptr).iotask;\n         let stream_handle_ptr = malloc_uv_tcp_t();\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n@@ -790,26 +790,26 @@ Convenience methods extending `net::tcp::tcp_socket`\n \"]\n impl sock_methods for tcp_socket {\n     fn read_start() -> result::result<comm::port<\n-        result::result<[u8], tcp_err_data>>, tcp_err_data> {\n+        result::result<[u8]/~, tcp_err_data>>, tcp_err_data> {\n         read_start(self)\n     }\n     fn read_stop() ->\n         result::result<(), tcp_err_data> {\n         read_stop(self)\n     }\n     fn read(timeout_msecs: uint) ->\n-        result::result<[u8], tcp_err_data> {\n+        result::result<[u8]/~, tcp_err_data> {\n         read(self, timeout_msecs)\n     }\n     fn read_future(timeout_msecs: uint) ->\n-        future::future<result::result<[u8], tcp_err_data>> {\n+        future::future<result::result<[u8]/~, tcp_err_data>> {\n         read_future(self, timeout_msecs)\n     }\n-    fn write(raw_write_data: [u8])\n+    fn write(raw_write_data: [u8]/~)\n         -> result::result<(), tcp_err_data> {\n         write(self, raw_write_data)\n     }\n-    fn write_future(raw_write_data: [u8])\n+    fn write_future(raw_write_data: [u8]/~)\n         -> future::future<result::result<(), tcp_err_data>> {\n         write_future(self, raw_write_data)\n     }\n@@ -818,7 +818,7 @@ impl sock_methods for tcp_socket {\n \n // shared implementation for tcp::read\n fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n-    -> result::result<[u8],tcp_err_data> unsafe {\n+    -> result::result<[u8]/~,tcp_err_data> unsafe {\n     log(debug, \"starting tcp::read\");\n     let iotask = (*socket_data).iotask;\n     let rs_result = read_start_common_impl(socket_data);\n@@ -887,7 +887,7 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n // shared impl for read_start\n fn read_start_common_impl(socket_data: *tcp_socket_data)\n     -> result::result<comm::port<\n-        result::result<[u8], tcp_err_data>>, tcp_err_data> unsafe {\n+        result::result<[u8]/~, tcp_err_data>>, tcp_err_data> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n     let start_ch = comm::chan(start_po);\n@@ -920,14 +920,14 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n \n // shared implementation used by write and write_future\n fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n-                     raw_write_data: [u8])\n+                     raw_write_data: [u8]/~)\n     -> result::result<(), tcp_err_data> unsafe {\n     let write_req_ptr = ptr::addr_of((*socket_data_ptr).write_req);\n     let stream_handle_ptr =\n         (*socket_data_ptr).stream_handle_ptr;\n     let write_buf_vec =  [ uv::ll::buf_init(\n         vec::unsafe::to_ptr(raw_write_data),\n-        vec::len(raw_write_data)) ];\n+        vec::len(raw_write_data)) ]/~;\n     let write_buf_vec_ptr = ptr::addr_of(write_buf_vec);\n     let result_po = comm::port::<tcp_write_result>();\n     let write_data = {\n@@ -968,7 +968,7 @@ fn conn_port_new_tcp_socket(\n     iotask: iotask)\n     -> result::result<tcp_socket,tcp_err_data> unsafe {\n     // tcp_nl_on_connection_cb\n-    let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n+    let reader_po = comm::port::<result::result<[u8]/~, tcp_err_data>>();\n     let client_socket_data = @{\n         reader_po : reader_po,\n         reader_ch : comm::chan(reader_po),\n@@ -1120,7 +1120,7 @@ enum tcp_read_start_result {\n }\n \n enum tcp_read_result {\n-    tcp_read_data([u8]),\n+    tcp_read_data([u8]/~),\n     tcp_read_done,\n     tcp_read_err(tcp_err_data)\n }\n@@ -1264,8 +1264,8 @@ enum conn_attempt {\n }\n \n type tcp_socket_data = {\n-    reader_po: comm::port<result::result<[u8], tcp_err_data>>,\n-    reader_ch: comm::chan<result::result<[u8], tcp_err_data>>,\n+    reader_po: comm::port<result::result<[u8]/~, tcp_err_data>>,\n+    reader_ch: comm::chan<result::result<[u8]/~, tcp_err_data>>,\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n@@ -1570,7 +1570,7 @@ mod test {\n         }\n     }\n \n-    fn tcp_write_single(sock: tcp_socket, val: [u8]) {\n+    fn tcp_write_single(sock: tcp_socket, val: [u8]/~) {\n         let write_result_future = sock.write_future(val);\n         let write_result = write_result_future.get();\n         if result::is_err(write_result) {"}, {"sha": "156f21216e58d76fc772a74d69a1f975198d63e9", "filename": "src/libstd/par.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -19,22 +19,22 @@ return the intermediate results.\n This is used to build most of the other parallel vector functions,\n like map or alli.\"]\n fn map_slices<A: copy send, B: copy send>(\n-    xs: [A],\n+    xs: [A]/~,\n     f: fn() -> fn~(uint, [A]/&) -> B)\n-    -> [B] {\n+    -> [B]/~ {\n \n     let len = xs.len();\n     if len < min_granularity {\n         log(info, \"small slice\");\n         // This is a small vector, fall back on the normal map.\n-        [f()(0u, xs)]\n+        [f()(0u, xs)]/~\n     }\n     else {\n         let num_tasks = uint::min(max_tasks, len / min_granularity);\n \n         let items_per_task = len / num_tasks;\n \n-        let mut futures = [];\n+        let mut futures = []/~;\n         let mut base = 0u;\n         log(info, \"spawning tasks\");\n         while base < len {\n@@ -74,18 +74,19 @@ fn map_slices<A: copy send, B: copy send>(\n }\n \n #[doc=\"A parallel version of map.\"]\n-fn map<A: copy send, B: copy send>(xs: [A], f: fn~(A) -> B) -> [B] {\n+fn map<A: copy send, B: copy send>(xs: [A]/~, f: fn~(A) -> B) -> [B]/~ {\n     vec::concat(map_slices(xs) {||\n-        fn~(_base: uint, slice : [A]/&, copy f) -> [B] {\n+        fn~(_base: uint, slice : [A]/&, copy f) -> [B]/~ {\n             vec::map(slice, f)\n         }\n     })\n }\n \n #[doc=\"A parallel version of mapi.\"]\n-fn mapi<A: copy send, B: copy send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n+fn mapi<A: copy send, B: copy send>(xs: [A]/~,\n+                                    f: fn~(uint, A) -> B) -> [B]/~ {\n     let slices = map_slices(xs) {||\n-        fn~(base: uint, slice : [A]/&, copy f) -> [B] {\n+        fn~(base: uint, slice : [A]/&, copy f) -> [B]/~ {\n             vec::mapi(slice) {|i, x|\n                 f(i + base, x)\n             }\n@@ -102,10 +103,10 @@ fn mapi<A: copy send, B: copy send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n In this case, f is a function that creates functions to run over the\n inner elements. This is to skirt the need for copy constructors.\"]\n fn mapi_factory<A: copy send, B: copy send>(\n-    xs: [A], f: fn() -> fn~(uint, A) -> B) -> [B] {\n+    xs: [A]/~, f: fn() -> fn~(uint, A) -> B) -> [B]/~ {\n     let slices = map_slices(xs) {||\n         let f = f();\n-        fn~(base: uint, slice : [A]/&, move f) -> [B] {\n+        fn~(base: uint, slice : [A]/&, move f) -> [B]/~ {\n             vec::mapi(slice) {|i, x|\n                 f(i + base, x)\n             }\n@@ -118,7 +119,7 @@ fn mapi_factory<A: copy send, B: copy send>(\n }\n \n #[doc=\"Returns true if the function holds for all elements in the vector.\"]\n-fn alli<A: copy send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n+fn alli<A: copy send>(xs: [A]/~, f: fn~(uint, A) -> bool) -> bool {\n     vec::all(map_slices(xs) {||\n         fn~(base: uint, slice : [A]/&, copy f) -> bool {\n             vec::alli(slice) {|i, x|\n@@ -129,7 +130,7 @@ fn alli<A: copy send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n }\n \n #[doc=\"Returns true if the function holds for any elements in the vector.\"]\n-fn any<A: copy send>(xs: [A], f: fn~(A) -> bool) -> bool {\n+fn any<A: copy send>(xs: [A]/~, f: fn~(A) -> bool) -> bool {\n     vec::any(map_slices(xs) {||\n         fn~(_base : uint, slice: [A]/&, copy f) -> bool {\n             vec::any(slice, f)"}, {"sha": "3799e7cdd28e33dc5959b5dbbd603d540a613702", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -97,7 +97,7 @@ Add one char to the end of the rope\n * this function executes in near-constant time\n \"]\n fn append_char(rope: rope, char: char) -> rope {\n-    ret append_str(rope, @str::from_chars([char]));\n+    ret append_str(rope, @str::from_chars([char]/~));\n }\n \n #[doc = \"\n@@ -118,7 +118,7 @@ Add one char to the beginning of the rope\n * this function executes in near-constant time\n \"]\n fn prepend_char(rope: rope, char: char) -> rope {\n-    ret prepend_str(rope, @str::from_chars([char]));\n+    ret prepend_str(rope, @str::from_chars([char]/~));\n }\n \n #[doc = \"\n@@ -153,7 +153,7 @@ If the ropes are balanced initially and have the same height, the resulting\n rope remains balanced. However, this function does not take any further\n measure to ensure that the result is balanced.\n \"]\n-fn concat(v: [rope]) -> rope {\n+fn concat(v: [rope]/~) -> rope {\n     //Copy `v` into a mut vector\n     let mut len = vec::len(v);\n     if len == 0u { ret node::empty; }\n@@ -752,7 +752,7 @@ mod node {\n     * forest - The forest. This vector is progressively rewritten during\n                execution and should be discarded as meaningless afterwards.\n     \"]\n-    fn tree_from_forest_destructive(forest: [mut @node]) -> @node {\n+    fn tree_from_forest_destructive(forest: [mut @node]/~) -> @node {\n         let mut i;\n         let mut len = vec::len(forest);\n         while len > 1u {\n@@ -805,7 +805,7 @@ mod node {\n               option::none { break; }\n               option::some(x) {\n                 //TODO: Replace with memcpy or something similar\n-                let mut local_buf: [u8] =\n+                let mut local_buf: [u8]/~ =\n                     unsafe::reinterpret_cast(*x.content);\n                 let mut i = x.byte_offset;\n                 while i < x.byte_len {\n@@ -859,7 +859,7 @@ mod node {\n     fn bal(node: @node) -> option<@node> {\n         if height(node) < hint_max_node_height { ret option::none; }\n         //1. Gather all leaves as a forest\n-        let mut forest = [mut];\n+        let mut forest = [mut]/~;\n         let it = leaf_iterator::start(node);\n         loop {\n             alt (leaf_iterator::next(it)) {\n@@ -1113,12 +1113,12 @@ mod node {\n \n     mod leaf_iterator {\n         type t = {\n-            stack:            [mut @node],\n+            stack:            [mut @node]/~,\n             mut stackpos: int\n         };\n \n         fn empty() -> t {\n-            let stack : [mut @node] = [mut];\n+            let stack : [mut @node]/~ = [mut]/~;\n             ret {stack: stack, mut stackpos: -1}\n         }\n "}, {"sha": "5c1d7f00b62b81632f4f5489fabb126fa539415d", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -83,7 +83,7 @@ iface deserializer {\n //\n // In some cases, these should eventually be coded as traits.\n \n-fn emit_from_vec<S: serializer, T>(s: S, v: [T], f: fn(T)) {\n+fn emit_from_vec<S: serializer, T>(s: S, v: [T]/~, f: fn(T)) {\n     s.emit_vec(vec::len(v)) {||\n         vec::iteri(v) {|i,e|\n             s.emit_vec_elt(i) {||\n@@ -93,7 +93,7 @@ fn emit_from_vec<S: serializer, T>(s: S, v: [T], f: fn(T)) {\n     }\n }\n \n-fn read_to_vec<D: deserializer, T: copy>(d: D, f: fn() -> T) -> [T] {\n+fn read_to_vec<D: deserializer, T: copy>(d: D, f: fn() -> T) -> [T]/~ {\n     d.read_vec {|len|\n         vec::from_fn(len) {|i|\n             d.read_vec_elt(i) {|| f() }\n@@ -102,13 +102,13 @@ fn read_to_vec<D: deserializer, T: copy>(d: D, f: fn() -> T) -> [T] {\n }\n \n impl serializer_helpers<S: serializer> for S {\n-    fn emit_from_vec<T>(v: [T], f: fn(T)) {\n+    fn emit_from_vec<T>(v: [T]/~, f: fn(T)) {\n         emit_from_vec(self, v, f)\n     }\n }\n \n impl deserializer_helpers<D: deserializer> for D {\n-    fn read_to_vec<T: copy>(f: fn() -> T) -> [T] {\n+    fn read_to_vec<T: copy>(f: fn() -> T) -> [T]/~ {\n         read_to_vec(self, f)\n     }\n }"}, {"sha": "a492facb1a3e017cf76fed75dd22e84d0269cc40", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -22,14 +22,14 @@ export sha1;\n #[doc = \"The SHA-1 interface\"]\n iface sha1 {\n     #[doc = \"Provide message input as bytes\"]\n-    fn input([u8]);\n+    fn input([u8]/~);\n     #[doc = \"Provide message input as string\"]\n     fn input_str(str);\n     #[doc = \"\n     Read the digest as a vector of 20 bytes. After calling this no further\n     input may be provided until reset is called.\n     \"]\n-    fn result() -> [u8];\n+    fn result() -> [u8]/~;\n     #[doc = \"\n     Read the digest as a hex string. After calling this no further\n     input may be provided until reset is called.\n@@ -52,15 +52,15 @@ const k3: u32 = 0xCA62C1D6u32;\n #[doc = \"Construct a `sha` object\"]\n fn sha1() -> sha1 {\n     type sha1state =\n-        {h: [mut u32],\n+        {h: [mut u32]/~,\n          mut len_low: u32,\n          mut len_high: u32,\n-         msg_block: [mut u8],\n+         msg_block: [mut u8]/~,\n          mut msg_block_idx: uint,\n          mut computed: bool,\n-         work_buf: @[mut u32]};\n+         work_buf: @[mut u32]/~};\n \n-    fn add_input(st: sha1state, msg: [u8]) {\n+    fn add_input(st: sha1state, msg: [u8]/~) {\n         /* FIXME: Should be typestate precondition (#2345) */\n         assert (!st.computed);\n         for vec::each(msg) {|element|\n@@ -157,15 +157,15 @@ fn sha1() -> sha1 {\n     fn circular_shift(bits: u32, word: u32) -> u32 {\n         ret word << bits | word >> 32u32 - bits;\n     }\n-    fn mk_result(st: sha1state) -> [u8] {\n+    fn mk_result(st: sha1state) -> [u8]/~ {\n         if !st.computed { pad_msg(st); st.computed = true; }\n-        let mut rs: [u8] = [];\n+        let mut rs: [u8]/~ = []/~;\n         for vec::each(st.h) {|hpart|\n             let a = (hpart >> 24u32 & 0xFFu32) as u8;\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n             let c = (hpart >> 8u32 & 0xFFu32) as u8;\n             let d = (hpart & 0xFFu32) as u8;\n-            rs += [a, b, c, d];\n+            rs += [a, b, c, d]/~;\n         }\n         ret rs;\n     }\n@@ -231,9 +231,9 @@ fn sha1() -> sha1 {\n             self.h[4] = 0xC3D2E1F0u32;\n             self.computed = false;\n         }\n-        fn input(msg: [u8]) { add_input(self, msg); }\n+        fn input(msg: [u8]/~) { add_input(self, msg); }\n         fn input_str(msg: str) { add_input(self, str::bytes(msg)); }\n-        fn result() -> [u8] { ret mk_result(self); }\n+        fn result() -> [u8]/~ { ret mk_result(self); }\n         fn result_str() -> str {\n             let r = mk_result(self);\n             let mut s = \"\";\n@@ -260,7 +260,7 @@ mod tests {\n \n     #[test]\n     fn test() unsafe {\n-        type test = {input: str, output: [u8]};\n+        type test = {input: str, output: [u8]/~};\n \n         fn a_million_letter_a() -> str {\n             let mut i = 0;\n@@ -270,14 +270,14 @@ mod tests {\n         }\n         // Test messages from FIPS 180-1\n \n-        let fips_180_1_tests: [test] =\n+        let fips_180_1_tests: [test]/~ =\n             [{input: \"abc\",\n               output:\n                   [0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                   0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]},\n+                   0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]/~},\n              {input:\n                   \"abcdbcdecdefdefgefghfghighij\" +\n                   \"hijkijkljklmklmnlmnomnopnopq\",\n@@ -286,33 +286,33 @@ mod tests {\n                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                   0xE5u8, 0x46u8, 0x70u8, 0xF1u8]},\n+                   0xE5u8, 0x46u8, 0x70u8, 0xF1u8]/~},\n              {input: a_million_letter_a(),\n               output:\n                   [0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n                    0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n                    0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n                    0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-                   0x65u8, 0x34u8, 0x01u8, 0x6Fu8]}];\n+                   0x65u8, 0x34u8, 0x01u8, 0x6Fu8]/~}]/~;\n         // Examples from wikipedia\n \n-        let wikipedia_tests: [test] =\n+        let wikipedia_tests: [test]/~ =\n             [{input: \"The quick brown fox jumps over the lazy dog\",\n               output:\n                   [0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                   0x1bu8, 0x93u8, 0xebu8, 0x12u8]},\n+                   0x1bu8, 0x93u8, 0xebu8, 0x12u8]/~},\n              {input: \"The quick brown fox jumps over the lazy cog\",\n               output:\n                   [0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                   0x10u8, 0x0du8, 0xb4u8, 0xb3u8]}];\n+                   0x10u8, 0x0du8, 0xb4u8, 0xb3u8]/~}]/~;\n         let tests = fips_180_1_tests + wikipedia_tests;\n-        fn check_vec_eq(v0: [u8], v1: [u8]) {\n+        fn check_vec_eq(v0: [u8]/~, v1: [u8]/~) {\n             assert (vec::len::<u8>(v0) == vec::len::<u8>(v1));\n             let len = vec::len::<u8>(v0);\n             let mut i = 0u;"}, {"sha": "e3ab3b09707a1ac5e998cb3919bd62508828247f", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -1,5 +1,5 @@\n #[doc = \"Sorting methods\"];\n-import vec::len;\n+import vec::{len, push};\n import int::{eq, ord};\n \n export le;\n@@ -15,27 +15,28 @@ Merge sort. Returns a new vector containing the sorted list.\n Has worst case O(n log n) performance, best case O(n), but\n is not space efficient. This is a stable sort.\n \"]\n-fn merge_sort<T: copy>(le: le<T>, v: [const T]) -> [T] {\n+fn merge_sort<T: copy>(le: le<T>, v: [const T]/~) -> [T]/~ {\n     type slice = (uint, uint);\n \n     ret merge_sort_(le, v, (0u, len(v)));\n \n-    fn merge_sort_<T: copy>(le: le<T>, v: [const T], slice: slice) -> [T] {\n+    fn merge_sort_<T: copy>(le: le<T>, v: [const T]/~, slice: slice)\n+        -> [T]/~ {\n         let begin = tuple::first(slice);\n         let end = tuple::second(slice);\n \n         let v_len = end - begin;\n-        if v_len == 0u { ret []; }\n-        if v_len == 1u { ret [v[begin]]; }\n+        if v_len == 0u { ret []/~; }\n+        if v_len == 1u { ret [v[begin]]/~; }\n \n         let mid = v_len / 2u + begin;\n         let a = (begin, mid);\n         let b = (mid, end);\n         ret merge(le, merge_sort_(le, v, a), merge_sort_(le, v, b));\n     }\n \n-    fn merge<T: copy>(le: le<T>, a: [T], b: [T]) -> [T] {\n-        let mut rs = [];\n+    fn merge<T: copy>(le: le<T>, a: [T]/~, b: [T]/~) -> [T]/~ {\n+        let mut rs = []/~;\n         vec::reserve(rs, len(a) + len(b));\n         let a_len = len(a);\n         let mut a_ix = 0u;\n@@ -53,7 +54,7 @@ fn merge_sort<T: copy>(le: le<T>, v: [const T]) -> [T] {\n     }\n }\n \n-fn part<T: copy>(compare_func: le<T>, arr: [mut T], left: uint,\n+fn part<T: copy>(compare_func: le<T>, arr: [mut T]/~, left: uint,\n                 right: uint, pivot: uint) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n@@ -70,7 +71,7 @@ fn part<T: copy>(compare_func: le<T>, arr: [mut T], left: uint,\n     ret storage_index;\n }\n \n-fn qsort<T: copy>(compare_func: le<T>, arr: [mut T], left: uint,\n+fn qsort<T: copy>(compare_func: le<T>, arr: [mut T]/~, left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -89,13 +90,13 @@ Quicksort. Sorts a mut vector in place.\n Has worst case O(n^2) performance, average case O(n log n).\n This is an unstable sort.\n \"]\n-fn quick_sort<T: copy>(compare_func: le<T>, arr: [mut T]) {\n+fn quick_sort<T: copy>(compare_func: le<T>, arr: [mut T]/~) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n \n fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n-                  arr: [mut T], left: int, right: int) {\n+                  arr: [mut T]/~, left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n@@ -145,22 +146,22 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n #[doc = \"\n Fancy quicksort. Sorts a mut vector in place.\n \n-Based on algorithm presented by [Sedgewick and Bentley]\n+Based on algorithm presented by [Sedgewick and Bentley]/~\n (http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n According to these slides this is the algorithm of choice for\n 'randomly ordered keys, abstract compare' & 'small number of key values'.\n \n This is an unstable sort.\n \"]\n-fn quick_sort3<T: copy ord eq>(arr: [mut T]) {\n+fn quick_sort3<T: copy ord eq>(arr: [mut T]/~) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort3::<T>({ |x, y| x.lt(y) }, { |x, y| x.eq(y) }, arr, 0,\n                 (len::<T>(arr) as int) - 1);\n }\n \n #[cfg(test)]\n mod test_qsort3 {\n-    fn check_sort(v1: [mut int], v2: [mut int]) {\n+    fn check_sort(v1: [mut int]/~, v2: [mut int]/~) {\n         let len = vec::len::<int>(v1);\n         quick_sort3::<int>(v1);\n         let mut i = 0u;\n@@ -174,32 +175,32 @@ mod test_qsort3 {\n     #[test]\n     fn test() {\n         {\n-            let v1 = [mut 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = [mut 2, 3, 4, 5, 5, 7, 8, 9];\n+            let v1 = [mut 3, 7, 4, 5, 2, 9, 5, 8]/~;\n+            let v2 = [mut 2, 3, 4, 5, 5, 7, 8, 9]/~;\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = [mut 1, 1, 1];\n-            let v2 = [mut 1, 1, 1];\n+            let v1 = [mut 1, 1, 1]/~;\n+            let v2 = [mut 1, 1, 1]/~;\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: [mut int] = [mut];\n-            let v2: [mut int] = [mut];\n+            let v1: [mut int]/~ = [mut]/~;\n+            let v2: [mut int]/~ = [mut]/~;\n             check_sort(v1, v2);\n         }\n-        { let v1 = [mut 9]; let v2 = [mut 9]; check_sort(v1, v2); }\n+        { let v1 = [mut 9]/~; let v2 = [mut 9]/~; check_sort(v1, v2); }\n         {\n-            let v1 = [mut 9, 3, 3, 3, 9];\n-            let v2 = [mut 3, 3, 3, 9, 9];\n+            let v1 = [mut 9, 3, 3, 3, 9]/~;\n+            let v2 = [mut 3, 3, 3, 9, 9]/~;\n             check_sort(v1, v2);\n         }\n     }\n }\n \n #[cfg(test)]\n mod test_qsort {\n-    fn check_sort(v1: [mut int], v2: [mut int]) {\n+    fn check_sort(v1: [mut int]/~, v2: [mut int]/~) {\n         let len = vec::len::<int>(v1);\n         fn leual(&&a: int, &&b: int) -> bool { ret a <= b; }\n         let f = leual;\n@@ -215,34 +216,34 @@ mod test_qsort {\n     #[test]\n     fn test() {\n         {\n-            let v1 = [mut 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = [mut 2, 3, 4, 5, 5, 7, 8, 9];\n+            let v1 = [mut 3, 7, 4, 5, 2, 9, 5, 8]/~;\n+            let v2 = [mut 2, 3, 4, 5, 5, 7, 8, 9]/~;\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = [mut 1, 1, 1];\n-            let v2 = [mut 1, 1, 1];\n+            let v1 = [mut 1, 1, 1]/~;\n+            let v2 = [mut 1, 1, 1]/~;\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: [mut int] = [mut];\n-            let v2: [mut int] = [mut];\n+            let v1: [mut int]/~ = [mut]/~;\n+            let v2: [mut int]/~ = [mut]/~;\n             check_sort(v1, v2);\n         }\n-        { let v1 = [mut 9]; let v2 = [mut 9]; check_sort(v1, v2); }\n+        { let v1 = [mut 9]/~; let v2 = [mut 9]/~; check_sort(v1, v2); }\n         {\n-            let v1 = [mut 9, 3, 3, 3, 9];\n-            let v2 = [mut 3, 3, 3, 9, 9];\n+            let v1 = [mut 9, 3, 3, 3, 9]/~;\n+            let v2 = [mut 3, 3, 3, 9, 9]/~;\n             check_sort(v1, v2);\n         }\n     }\n \n     // Regression test for #750\n     #[test]\n     fn test_simple() {\n-        let names = [mut 2, 1, 3];\n+        let names = [mut 2, 1, 3]/~;\n \n-        let expected = [1, 2, 3];\n+        let expected = [1, 2, 3]/~;\n \n         fn le(&&a: int, &&b: int) -> bool { int::le(a, b) }\n         sort::quick_sort(le, names);\n@@ -261,7 +262,7 @@ mod test_qsort {\n #[cfg(test)]\n mod tests {\n \n-    fn check_sort(v1: [int], v2: [int]) {\n+    fn check_sort(v1: [int]/~, v2: [int]/~) {\n         let len = vec::len::<int>(v1);\n         fn le(&&a: int, &&b: int) -> bool { ret a <= b; }\n         let f = le;\n@@ -277,26 +278,26 @@ mod tests {\n     #[test]\n     fn test() {\n         {\n-            let v1 = [3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = [2, 3, 4, 5, 5, 7, 8, 9];\n+            let v1 = [3, 7, 4, 5, 2, 9, 5, 8]/~;\n+            let v2 = [2, 3, 4, 5, 5, 7, 8, 9]/~;\n             check_sort(v1, v2);\n         }\n-        { let v1 = [1, 1, 1]; let v2 = [1, 1, 1]; check_sort(v1, v2); }\n-        { let v1: [int] = []; let v2: [int] = []; check_sort(v1, v2); }\n-        { let v1 = [9]; let v2 = [9]; check_sort(v1, v2); }\n+        { let v1 = [1, 1, 1]/~; let v2 = [1, 1, 1]/~; check_sort(v1, v2); }\n+        { let v1:[int]/~ = []/~; let v2:[int]/~ = []/~; check_sort(v1, v2); }\n+        { let v1 = [9]/~; let v2 = [9]/~; check_sort(v1, v2); }\n         {\n-            let v1 = [9, 3, 3, 3, 9];\n-            let v2 = [3, 3, 3, 9, 9];\n+            let v1 = [9, 3, 3, 3, 9]/~;\n+            let v2 = [3, 3, 3, 9, 9]/~;\n             check_sort(v1, v2);\n         }\n     }\n \n     #[test]\n     fn test_merge_sort_mutable() {\n         fn le(&&a: int, &&b: int) -> bool { ret a <= b; }\n-        let v1 = [mut 3, 2, 1];\n+        let v1 = [mut 3, 2, 1]/~;\n         let v2 = merge_sort(le, v1);\n-        assert v2 == [1, 2, 3];\n+        assert v2 == [1, 2, 3]/~;\n     }\n }\n "}, {"sha": "fdbdc7205daeb86b7c27c0eaeb01328c058242af", "filename": "src/libstd/term.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -23,18 +23,18 @@ const color_bright_magenta: u8 = 13u8;\n const color_bright_cyan: u8 = 14u8;\n const color_bright_white: u8 = 15u8;\n \n-fn esc(writer: io::writer) { writer.write([0x1bu8, '[' as u8]); }\n+fn esc(writer: io::writer) { writer.write([0x1bu8, '[' as u8]/~); }\n \n #[doc = \"Reset the foreground and background colors to default\"]\n fn reset(writer: io::writer) {\n     esc(writer);\n-    writer.write(['0' as u8, 'm' as u8]);\n+    writer.write(['0' as u8, 'm' as u8]/~);\n }\n \n #[doc = \"Returns true if the terminal supports color\"]\n fn color_supported() -> bool {\n     let supported_terms = [\"xterm-color\", \"xterm\",\n-                           \"screen-bce\", \"xterm-256color\"];\n+                           \"screen-bce\", \"xterm-256color\"]/~;\n     ret alt os::getenv(\"TERM\") {\n           option::some(env) {\n             for vec::each(supported_terms) {|term|\n@@ -50,8 +50,8 @@ fn set_color(writer: io::writer, first_char: u8, color: u8) {\n     assert (color < 16u8);\n     esc(writer);\n     let mut color = color;\n-    if color >= 8u8 { writer.write(['1' as u8, ';' as u8]); color -= 8u8; }\n-    writer.write([first_char, ('0' as u8) + color, 'm' as u8]);\n+    if color >= 8u8 { writer.write(['1' as u8, ';' as u8]/~); color -= 8u8; }\n+    writer.write([first_char, ('0' as u8) + color, 'm' as u8]/~);\n }\n \n #[doc = \"Set the foreground color\"]"}, {"sha": "beefdd0638592799ef4ff0bcc91ffdb130ab047f", "filename": "src/libstd/test.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -49,7 +49,7 @@ type test_desc = {\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-fn test_main(args: [str], tests: [test_desc]) {\n+fn test_main(args: [str]/~, tests: [test_desc]/~) {\n     let opts =\n         alt parse_opts(args) {\n           either::left(o) { o }\n@@ -64,9 +64,9 @@ type test_opts = {filter: option<str>, run_ignored: bool,\n type opt_res = either<test_opts, str>;\n \n // Parses command line arguments into test options\n-fn parse_opts(args: [str]) -> opt_res {\n+fn parse_opts(args: [str]/~) -> opt_res {\n     let args_ = vec::tail(args);\n-    let opts = [getopts::optflag(\"ignored\"), getopts::optopt(\"logfile\")];\n+    let opts = [getopts::optflag(\"ignored\"), getopts::optopt(\"logfile\")]/~;\n     let match =\n         alt getopts::getopts(args_, opts) {\n           ok(m) { m }\n@@ -97,11 +97,11 @@ type console_test_state =\n       mut passed: uint,\n       mut failed: uint,\n       mut ignored: uint,\n-      mut failures: [test_desc]};\n+      mut failures: [test_desc]/~};\n \n // A simple console test runner\n fn run_tests_console(opts: test_opts,\n-                     tests: [test_desc]) -> bool {\n+                     tests: [test_desc]/~) -> bool {\n \n     fn callback(event: testevent, st: console_test_state) {\n         alt event {\n@@ -128,7 +128,7 @@ fn run_tests_console(opts: test_opts,\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(\"\");\n-                st.failures += [copy test];\n+                st.failures += [copy test]/~;\n               }\n               tr_ignored {\n                 st.ignored += 1u;\n@@ -142,7 +142,7 @@ fn run_tests_console(opts: test_opts,\n \n     let log_out = alt opts.logfile {\n         some(path) {\n-            alt io::file_writer(path, [io::create, io::truncate]) {\n+            alt io::file_writer(path, [io::create, io::truncate]/~) {\n                 result::ok(w) { some(w) }\n                 result::err(s) {\n                     fail(#fmt(\"can't open output file: %s\", s))\n@@ -160,7 +160,7 @@ fn run_tests_console(opts: test_opts,\n           mut passed: 0u,\n           mut failed: 0u,\n           mut ignored: 0u,\n-          mut failures: []};\n+          mut failures: []/~};\n \n     run_tests(opts, tests, {|x|callback(x, st)});\n \n@@ -250,7 +250,7 @@ fn should_sort_failures_before_printing_them() {\n           mut passed: 0u,\n           mut failed: 0u,\n           mut ignored: 0u,\n-          mut failures: [test_b, test_a]};\n+          mut failures: [test_b, test_a]/~};\n \n     print_failures(st);\n \n@@ -264,14 +264,14 @@ fn should_sort_failures_before_printing_them() {\n fn use_color() -> bool { ret get_concurrency() == 1u; }\n \n enum testevent {\n-    te_filtered([test_desc]),\n+    te_filtered([test_desc]/~),\n     te_wait(test_desc),\n     te_result(test_desc, test_result),\n }\n \n type monitor_msg = (test_desc, test_result);\n \n-fn run_tests(opts: test_opts, tests: [test_desc],\n+fn run_tests(opts: test_opts, tests: [test_desc]/~,\n              callback: fn@(testevent)) {\n \n     let mut filtered_tests = filter_tests(opts, tests);\n@@ -329,7 +329,7 @@ fn get_concurrency() -> uint {\n \n #[warn(no_non_implicitly_copyable_typarams)]\n fn filter_tests(opts: test_opts,\n-                tests: [test_desc]) -> [test_desc] {\n+                tests: [test_desc]/~) -> [test_desc]/~ {\n     let mut filtered = copy tests;\n \n     // Remove tests that don't match the test filter\n@@ -482,15 +482,15 @@ mod tests {\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n-        let args = [\"progname\", \"filter\"];\n+        let args = [\"progname\", \"filter\"]/~;\n         let opts = alt parse_opts(args) { either::left(o) { o }\n           _ { fail \"Malformed arg in first_free_arg_should_be_a_filter\"; } };\n         assert (str::eq(\"filter\", option::get(opts.filter)));\n     }\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = [\"progname\", \"filter\", \"--ignored\"];\n+        let args = [\"progname\", \"filter\", \"--ignored\"]/~;\n         let opts = alt parse_opts(args) { either::left(o) { o }\n           _ { fail \"Malformed arg in parse_ignored_flag\"; } };\n         assert (opts.run_ignored);\n@@ -505,7 +505,7 @@ mod tests {\n             logfile: option::none};\n         let tests =\n             [{name: \"1\", fn: fn~() { }, ignore: true, should_fail: false},\n-             {name: \"2\", fn: fn~() { }, ignore: false, should_fail: false}];\n+             {name: \"2\", fn: fn~() { }, ignore: false, should_fail: false}]/~;\n         let filtered = filter_tests(opts, tests);\n \n         assert (vec::len(filtered) == 1u);\n@@ -524,15 +524,15 @@ mod tests {\n              \"test::ignored_tests_result_in_ignored\",\n              \"test::first_free_arg_should_be_a_filter\",\n              \"test::parse_ignored_flag\", \"test::filter_for_ignored_option\",\n-             \"test::sort_tests\"];\n+             \"test::sort_tests\"]/~;\n         let tests =\n         {\n         let testfn = fn~() { };\n-        let mut tests = [];\n+        let mut tests = []/~;\n         for vec::each(names) {|name|\n             let test = {name: name, fn: copy testfn, ignore: false,\n                         should_fail: false};\n-            tests += [test];\n+            tests += [test]/~;\n         }\n         tests\n     };\n@@ -543,7 +543,7 @@ mod tests {\n          \"test::do_not_run_ignored_tests\", \"test::filter_for_ignored_option\",\n          \"test::first_free_arg_should_be_a_filter\",\n          \"test::ignored_tests_result_in_ignored\", \"test::parse_ignored_flag\",\n-         \"test::sort_tests\"];\n+         \"test::sort_tests\"]/~;\n \n     let pairs = vec::zip(expected, filtered);\n "}, {"sha": "b2d5ea64a98f0d134c1a0e65ea72a2aedeb9a19e", "filename": "src/libstd/time.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -66,14 +66,14 @@ fn tzset() {\n }\n \n type tm = {\n-    tm_sec: i32, // seconds after the minute [0-60]\n-    tm_min: i32, // minutes after the hour [0-59]\n-    tm_hour: i32, // hours after midnight [0-23]\n-    tm_mday: i32, // days of the month [1-31]\n-    tm_mon: i32, // months since January [0-11]\n+    tm_sec: i32, // seconds after the minute [0-60]/~\n+    tm_min: i32, // minutes after the hour [0-59]/~\n+    tm_hour: i32, // hours after midnight [0-23]/~\n+    tm_mday: i32, // days of the month [1-31]/~\n+    tm_mon: i32, // months since January [0-11]/~\n     tm_year: i32, // years since 1900\n-    tm_wday: i32, // days since Sunday [0-6]\n-    tm_yday: i32, // days since January 1 [0-365]\n+    tm_wday: i32, // days since Sunday [0-6]/~\n+    tm_yday: i32, // days since January 1 [0-365]/~\n     tm_isdst: i32, // Daylight Savings Time flag\n     tm_gmtoff: i32, // offset from UTC in seconds\n     tm_zone: str, // timezone abbreviation\n@@ -151,7 +151,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n         ret true;\n     }\n \n-    fn match_strs(s: str, pos: uint, strs: [(str, i32)])\n+    fn match_strs(s: str, pos: uint, strs: [(str, i32)]/~)\n       -> option<(i32, uint)> {\n         let mut i = 0u;\n         let len = vec::len(strs);\n@@ -214,7 +214,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 (\"Thursday\", 4_i32),\n                 (\"Friday\", 5_i32),\n                 (\"Saturday\", 6_i32)\n-            ]) {\n+            ]/~) {\n               some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n               none { err(\"Invalid day\") }\n             }\n@@ -228,7 +228,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 (\"Thu\", 4_i32),\n                 (\"Fri\", 5_i32),\n                 (\"Sat\", 6_i32)\n-            ]) {\n+            ]/~) {\n               some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n               none { err(\"Invalid day\") }\n             }\n@@ -247,7 +247,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 (\"October\", 9_i32),\n                 (\"November\", 10_i32),\n                 (\"December\", 11_i32)\n-            ]) {\n+            ]/~) {\n               some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n               none { err(\"Invalid month\") }\n             }\n@@ -266,7 +266,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 (\"Oct\", 9_i32),\n                 (\"Nov\", 10_i32),\n                 (\"Dec\", 11_i32)\n-            ]) {\n+            ]/~) {\n               some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n               none { err(\"Invalid month\") }\n             }\n@@ -385,13 +385,13 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           'n' { parse_char(s, pos, '\\n') }\n           'P' {\n-            alt match_strs(s, pos, [(\"am\", 0_i32), (\"pm\", 12_i32)]) {\n+            alt match_strs(s, pos, [(\"am\", 0_i32), (\"pm\", 12_i32)]/~) {\n               some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n               none { err(\"Invalid hour\") }\n             }\n           }\n           'p' {\n-            alt match_strs(s, pos, [(\"AM\", 0_i32), (\"PM\", 12_i32)]) {\n+            alt match_strs(s, pos, [(\"AM\", 0_i32), (\"PM\", 12_i32)]/~) {\n               some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n               none { err(\"Invalid hour\") }\n             }\n@@ -1010,7 +1010,7 @@ mod tests {\n             \"Thursday\",\n             \"Friday\",\n             \"Saturday\"\n-        ].iter { |day| assert test(day, \"%A\"); }\n+        ]/~.iter { |day| assert test(day, \"%A\"); }\n \n         [\n             \"Sun\",\n@@ -1020,7 +1020,7 @@ mod tests {\n             \"Thu\",\n             \"Fri\",\n             \"Sat\"\n-        ].iter { |day| assert test(day, \"%a\"); }\n+        ]/~.iter { |day| assert test(day, \"%a\"); }\n \n         [\n             \"January\",\n@@ -1035,7 +1035,7 @@ mod tests {\n             \"October\",\n             \"November\",\n             \"December\"\n-        ].iter { |day| assert test(day, \"%B\"); }\n+        ]/~.iter { |day| assert test(day, \"%B\"); }\n \n         [\n             \"Jan\",\n@@ -1050,7 +1050,7 @@ mod tests {\n             \"Oct\",\n             \"Nov\",\n             \"Dec\"\n-        ].iter { |day| assert test(day, \"%b\"); }\n+        ]/~.iter { |day| assert test(day, \"%b\"); }\n \n         assert test(\"19\", \"%C\");\n         assert test(\"Fri Feb 13 23:31:30 2009\", \"%c\");"}, {"sha": "f6981ce39e0aeef57b374a940eea54747801fd9b", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -167,7 +167,7 @@ mod test {\n \n             [(1u,  20u),\n              (10u, 10u),\n-             (20u, 2u)]\n+             (20u, 2u)]/~\n \n         };\n "}, {"sha": "8011d816fea1d4709ad66a045cf90976004b82c3", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -24,7 +24,7 @@ import libc::size_t;\n \n // libuv struct mappings\n type uv_ip4_addr = {\n-    ip: [u8],\n+    ip: [u8]/~,\n     port: int\n };\n type uv_ip6_addr = uv_ip4_addr;\n@@ -616,7 +616,7 @@ unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n }\n \n unsafe fn write<T>(req: *uv_write_t, stream: *T,\n-         buf_in: *[uv_buf_t], cb: *u8) -> libc::c_int {\n+         buf_in: *[uv_buf_t]/~, cb: *u8) -> libc::c_int {\n     let buf_ptr = vec::unsafe::to_ptr(*buf_in);\n     let buf_cnt = vec::len(*buf_in) as i32;\n     ret rustrt::rust_uv_write(req as *libc::c_void,\n@@ -678,7 +678,7 @@ unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n unsafe fn ip4_addr(ip: str, port: int)\n -> sockaddr_in {\n     let mut addr_vec = str::bytes(ip);\n-    addr_vec += [0u8]; // add null terminator\n+    addr_vec += [0u8]/~; // add null terminator\n     let addr_vec_ptr = vec::unsafe::to_ptr(addr_vec);\n     let ip_back = str::from_bytes(addr_vec);\n     log(debug, #fmt(\"vec val: '%s' length: %u\",\n@@ -795,13 +795,13 @@ type uv_err_data = {\n mod test {\n     enum tcp_read_data {\n         tcp_read_eof,\n-        tcp_read_more([u8]),\n+        tcp_read_more([u8]/~),\n         tcp_read_error\n     }\n \n     type request_wrapper = {\n         write_req: *uv_write_t,\n-        req_buf: *[uv_buf_t],\n+        req_buf: *[uv_buf_t]/~,\n         read_chan: *comm::chan<str>\n     };\n \n@@ -917,7 +917,7 @@ mod test {\n         log(debug, #fmt(\"req_msg ptr: %u\", req_msg_ptr as uint));\n         let req_msg = [\n             buf_init(req_msg_ptr, vec::len(req_str_bytes))\n-        ];\n+        ]/~;\n         // this is the enclosing record, we'll pass a ptr to\n         // this to C..\n         let write_handle = write_t();\n@@ -1115,7 +1115,7 @@ mod test {\n         client: *uv_tcp_t,\n         server: *uv_tcp_t,\n         server_kill_msg: str,\n-        server_resp_buf: *[uv_buf_t],\n+        server_resp_buf: *[uv_buf_t]/~,\n         server_chan: *comm::chan<str>,\n         server_write_req: *uv_write_t\n     };\n@@ -1164,7 +1164,7 @@ mod test {\n         log(debug, #fmt(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n         let resp_msg = [\n             buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n-        ];\n+        ]/~;\n \n         let continue_async_handle = async_t();\n         let continue_async_handle_ptr ="}, {"sha": "936718dd0a7ae8554790604d5f5f00ad537e4e1a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -41,9 +41,9 @@ type fn_ident = option<ident>;\n #[auto_serialize]\n type path = {span: span,\n              global: bool,\n-             idents: [ident],\n+             idents: [ident]/~,\n              rp: option<@region>,\n-             types: [@ty]};\n+             types: [@ty]/~};\n \n #[auto_serialize]\n type crate_num = int;\n@@ -66,7 +66,7 @@ enum ty_param_bound {\n }\n \n #[auto_serialize]\n-type ty_param = {ident: ident, id: node_id, bounds: @[ty_param_bound]};\n+type ty_param = {ident: ident, id: node_id, bounds: @[ty_param_bound]/~};\n \n #[auto_serialize]\n enum def {\n@@ -92,19 +92,19 @@ enum def {\n \n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n-type crate_cfg = [@meta_item];\n+type crate_cfg = [@meta_item]/~;\n \n type crate = spanned<crate_>;\n \n type crate_ =\n-    {directives: [@crate_directive],\n+    {directives: [@crate_directive]/~,\n      module: _mod,\n-     attrs: [attribute],\n+     attrs: [attribute]/~,\n      config: crate_cfg};\n \n enum crate_directive_ {\n-    cdir_src_mod(ident, [attribute]),\n-    cdir_dir_mod(ident, [@crate_directive], [attribute]),\n+    cdir_src_mod(ident, [attribute]/~),\n+    cdir_dir_mod(ident, [@crate_directive]/~, [attribute]/~),\n \n     // NB: cdir_view_item is *not* processed by the rest of the compiler, the\n     // attached view_items are sunk into the crate's module during parsing,\n@@ -124,16 +124,19 @@ type meta_item = spanned<meta_item_>;\n #[auto_serialize]\n enum meta_item_ {\n     meta_word(ident),\n-    meta_list(ident, [@meta_item]),\n+    meta_list(ident, [@meta_item]/~),\n     meta_name_value(ident, lit),\n }\n \n #[auto_serialize]\n type blk = spanned<blk_>;\n \n #[auto_serialize]\n-type blk_ = {view_items: [@view_item], stmts: [@stmt], expr: option<@expr>,\n-             id: node_id, rules: blk_check_mode};\n+type blk_ = {view_items: [@view_item]/~,\n+             stmts: [@stmt]/~,\n+             expr: option<@expr>,\n+             id: node_id,\n+             rules: blk_check_mode};\n \n #[auto_serialize]\n type pat = {id: node_id, node: pat_, span: span};\n@@ -152,10 +155,10 @@ enum pat_ {\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n     pat_ident(@path, option<@pat>),\n-    pat_enum(@path, option<[@pat]>), // \"none\" means a * pattern where\n+    pat_enum(@path, option<[@pat]/~>), // \"none\" means a * pattern where\n                                   // we don't bind the fields to names\n-    pat_rec([field_pat], bool),\n-    pat_tup([@pat]),\n+    pat_rec([field_pat]/~, bool),\n+    pat_tup([@pat]/~),\n     pat_box(@pat),\n     pat_uniq(@pat),\n     pat_lit(@expr),\n@@ -267,10 +270,10 @@ type local = spanned<local_>;\n type decl = spanned<decl_>;\n \n #[auto_serialize]\n-enum decl_ { decl_local([@local]), decl_item(@item), }\n+enum decl_ { decl_local([@local]/~), decl_item(@item), }\n \n #[auto_serialize]\n-type arm = {pats: [@pat], guard: option<@expr>, body: blk};\n+type arm = {pats: [@pat]/~, guard: option<@expr>, body: blk};\n \n #[auto_serialize]\n type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n@@ -293,10 +296,10 @@ enum alt_mode { alt_check, alt_exhaustive, }\n #[auto_serialize]\n enum expr_ {\n     expr_vstore(@expr, vstore),\n-    expr_vec([@expr], mutability),\n-    expr_rec([field], option<@expr>),\n-    expr_call(@expr, [@expr], bool), // True iff last argument is a block\n-    expr_tup([@expr]),\n+    expr_vec([@expr]/~, mutability),\n+    expr_rec([field]/~, option<@expr>),\n+    expr_call(@expr, [@expr]/~, bool), // True iff last argument is a block\n+    expr_tup([@expr]/~),\n     expr_binary(binop, @expr, @expr),\n     expr_unary(unop, @expr),\n     expr_lit(@lit),\n@@ -307,7 +310,7 @@ enum expr_ {\n        Same semantics as while(true) { body }, but typestate knows that the\n        (implicit) condition is always true. */\n     expr_loop(blk),\n-    expr_alt(@expr, [arm], alt_mode),\n+    expr_alt(@expr, [arm]/~, alt_mode),\n     expr_fn(proto, fn_decl, blk, capture_clause),\n     expr_fn_block(fn_decl, blk, capture_clause),\n     // Inner expr is always an expr_fn_block. We need the wrapping node to\n@@ -327,7 +330,7 @@ enum expr_ {\n     expr_assign(@expr, @expr),\n     expr_swap(@expr, @expr),\n     expr_assign_op(binop, @expr, @expr),\n-    expr_field(@expr, ident, [@ty]),\n+    expr_field(@expr, ident, [@ty]/~),\n     expr_index(@expr, @expr),\n     expr_path(@path),\n     expr_addr_of(mutability, @expr),\n@@ -359,7 +362,7 @@ type capture_item = @{\n };\n \n #[auto_serialize]\n-type capture_clause = @[capture_item];\n+type capture_clause = @[capture_item]/~;\n \n /*\n // Says whether this is a block the user marked as\n@@ -373,7 +376,7 @@ enum blk_sort {\n #[auto_serialize]\n enum token_tree {\n     /* for macro invocations; parsing is the macro's job */\n-    tt_delim([token_tree]),\n+    tt_delim([token_tree]/~),\n     tt_flat(span, token::token)\n }\n \n@@ -384,7 +387,7 @@ type matcher = spanned<matcher_>;\n enum matcher_ {\n     mtc_tok(token::token),\n     /* body, separator, zero ok? : */\n-    mtc_rep([matcher], option<token::token>, bool),\n+    mtc_rep([matcher]/~, option<token::token>, bool),\n     mtc_bb(ident, ident, uint)\n }\n \n@@ -438,8 +441,8 @@ type ty_field_ = {ident: ident, mt: mt};\n type ty_field = spanned<ty_field_>;\n \n #[auto_serialize]\n-type ty_method = {ident: ident, attrs: [attribute],\n-                  decl: fn_decl, tps: [ty_param], span: span};\n+type ty_method = {ident: ident, attrs: [attribute]/~,\n+                  decl: fn_decl, tps: [ty_param]/~, span: span};\n \n #[auto_serialize]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n@@ -478,11 +481,11 @@ enum ty_ {\n     ty_vec(mt),\n     ty_ptr(mt),\n     ty_rptr(@region, mt),\n-    ty_rec([ty_field]),\n+    ty_rec([ty_field]/~),\n     ty_fn(proto, fn_decl),\n-    ty_tup([@ty]),\n+    ty_tup([@ty]/~),\n     ty_path(@path, node_id),\n-    ty_constr(@ty, [@ty_constr]),\n+    ty_constr(@ty, [@ty_constr]/~),\n     ty_vstore(@ty, vstore),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n@@ -522,7 +525,7 @@ type constr_arg = spanned<fn_constr_arg>;\n \n #[auto_serialize]\n type constr_general_<ARG, ID> =\n-    {path: @path, args: [@sp_constr_arg<ARG>], id: ID};\n+    {path: @path, args: [@sp_constr_arg<ARG>]/~, id: ID};\n \n // In the front end, constraints have a node ID attached.\n // Typeck turns this to a def_id, using the output of resolve.\n@@ -549,11 +552,11 @@ type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n #[auto_serialize]\n type fn_decl =\n-    {inputs: [arg],\n+    {inputs: [arg]/~,\n      output: @ty,\n      purity: purity,\n      cf: ret_style,\n-     constraints: [@constr]};\n+     constraints: [@constr]/~};\n \n #[auto_serialize]\n enum purity {\n@@ -571,14 +574,14 @@ enum ret_style {\n }\n \n #[auto_serialize]\n-type method = {ident: ident, attrs: [attribute],\n-               tps: [ty_param], decl: fn_decl, body: blk,\n+type method = {ident: ident, attrs: [attribute]/~,\n+               tps: [ty_param]/~, decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id,\n                vis: visibility};  // always public, unless it's a\n                                   // class method\n \n #[auto_serialize]\n-type _mod = {view_items: [@view_item], items: [@item]};\n+type _mod = {view_items: [@view_item]/~, items: [@item]/~};\n \n #[auto_serialize]\n enum native_abi {\n@@ -589,14 +592,14 @@ enum native_abi {\n \n #[auto_serialize]\n type native_mod =\n-    {view_items: [@view_item],\n-     items: [@native_item]};\n+    {view_items: [@view_item]/~,\n+     items: [@native_item]/~};\n \n #[auto_serialize]\n type variant_arg = {ty: @ty, id: node_id};\n \n #[auto_serialize]\n-type variant_ = {name: ident, attrs: [attribute], args: [variant_arg],\n+type variant_ = {name: ident, attrs: [attribute]/~, args: [variant_arg]/~,\n                  id: node_id, disr_expr: option<@expr>, vis: visibility};\n \n #[auto_serialize]\n@@ -625,18 +628,18 @@ enum view_path_ {\n     view_path_glob(@path, node_id),\n \n     // foo::bar::{a,b,c}\n-    view_path_list(@path, [path_list_ident], node_id)\n+    view_path_list(@path, [path_list_ident]/~, node_id)\n }\n \n #[auto_serialize]\n-type view_item = {node: view_item_, attrs: [attribute],\n+type view_item = {node: view_item_, attrs: [attribute]/~,\n                   vis: visibility, span: span};\n \n #[auto_serialize]\n enum view_item_ {\n-    view_item_use(ident, [@meta_item], node_id),\n-    view_item_import([@view_path]),\n-    view_item_export([@view_path])\n+    view_item_use(ident, [@meta_item]/~, node_id),\n+    view_item_import([@view_path]/~),\n+    view_item_export([@view_path]/~)\n }\n \n // Meta-data associated with an item\n@@ -663,7 +666,7 @@ type iface_ref = {path: @path, id: node_id};\n enum visibility { public, private }\n \n #[auto_serialize]\n-type item = {ident: ident, attrs: [attribute],\n+type item = {ident: ident, attrs: [attribute]/~,\n              id: node_id, node: item_,\n              vis: visibility, span: span};\n \n@@ -676,23 +679,23 @@ enum region_param {\n #[auto_serialize]\n enum item_ {\n     item_const(@ty, @expr),\n-    item_fn(fn_decl, [ty_param], blk),\n+    item_fn(fn_decl, [ty_param]/~, blk),\n     item_mod(_mod),\n     item_native_mod(native_mod),\n-    item_ty(@ty, [ty_param], region_param),\n-    item_enum([variant], [ty_param], region_param),\n-    item_class([ty_param], /* ty params for class */\n-               [@iface_ref],   /* ifaces this class implements */\n-               [@class_member], /* methods, etc. */\n+    item_ty(@ty, [ty_param]/~, region_param),\n+    item_enum([variant]/~, [ty_param]/~, region_param),\n+    item_class([ty_param]/~, /* ty params for class */\n+               [@iface_ref]/~,   /* ifaces this class implements */\n+               [@class_member]/~, /* methods, etc. */\n                                /* (not including ctor or dtor) */\n                class_ctor,\n                /* dtor is optional */\n                option<class_dtor>,\n                region_param\n                ),\n-    item_iface([ty_param], region_param, [ty_method]),\n-    item_impl([ty_param], region_param, option<@iface_ref> /* iface */,\n-              @ty /* self */, [@method]),\n+    item_iface([ty_param]/~, region_param, [ty_method]/~),\n+    item_impl([ty_param]/~, region_param, option<@iface_ref> /* iface */,\n+              @ty /* self */, [@method]/~),\n }\n \n #[auto_serialize]\n@@ -727,14 +730,14 @@ type class_dtor_ = {id: node_id,\n #[auto_serialize]\n type native_item =\n     {ident: ident,\n-     attrs: [attribute],\n+     attrs: [attribute]/~,\n      node: native_item_,\n      id: node_id,\n      span: span};\n \n #[auto_serialize]\n enum native_item_ {\n-    native_item_fn(fn_decl, [ty_param]),\n+    native_item_fn(fn_decl, [ty_param]/~),\n }\n \n // The data we save and restore about an inlined item or method.  This is not\n@@ -745,8 +748,8 @@ enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_native(@native_item),\n-    ii_ctor(class_ctor, ident, [ty_param], def_id /* parent id */),\n-    ii_dtor(class_dtor, ident, [ty_param], def_id /* parent id */)\n+    ii_ctor(class_ctor, ident, [ty_param]/~, def_id /* parent id */),\n+    ii_dtor(class_dtor, ident, [ty_param]/~, def_id /* parent id */)\n }\n \n //"}, {"sha": "96ecadc2be3955b7102127c496f7f65454738351", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -7,7 +7,7 @@ import ast_util::inlined_item_methods;\n import diagnostic::span_handler;\n \n enum path_elt { path_mod(ident), path_name(ident) }\n-type path = [path_elt];\n+type path = [path_elt]/~;\n \n /* FIXMEs that say \"bad\" are as per #2543 */\n fn path_to_str_with_sep(p: path, sep: str) -> str {\n@@ -45,9 +45,9 @@ enum ast_node {\n     node_local(uint),\n     // Constructor for a class\n     // def_id is parent id\n-    node_ctor(ident, [ty_param], @class_ctor, def_id, @path),\n+    node_ctor(ident, [ty_param]/~, @class_ctor, def_id, @path),\n     // Destructor for a class\n-    node_dtor([ty_param], @class_dtor, def_id, @path),\n+    node_dtor([ty_param]/~, @class_dtor, def_id, @path),\n     node_block(blk),\n }\n \n@@ -57,7 +57,7 @@ type ctx = {map: map, mut path: path,\n type vt = visit::vt<ctx>;\n \n fn extend(cx: ctx, +elt: ident) -> @path {\n-    @(cx.path + [path_name(elt)])\n+    @(cx.path + [path_name(elt)]/~)\n }\n \n fn mk_ast_map_visitor() -> vt {\n@@ -75,7 +75,7 @@ fn mk_ast_map_visitor() -> vt {\n \n fn map_crate(diag: span_handler, c: crate) -> map {\n     let cx = {map: std::map::int_hash(),\n-              mut path: [],\n+              mut path: []/~,\n               mut local_id: 0u,\n               diag: diag};\n     visit::visit_crate(c, cx, mk_ast_map_visitor());\n@@ -229,9 +229,9 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     }\n     alt i.node {\n       item_mod(_) | item_native_mod(_) {\n-        cx.path += [path_mod(i.ident)];\n+        cx.path += [path_mod(i.ident)]/~;\n       }\n-      _ { cx.path += [path_name(i.ident)]; }\n+      _ { cx.path += [path_name(i.ident)]/~; }\n     }\n     visit::visit_item(i, cx, v);\n     vec::pop(cx.path);"}, {"sha": "7c0a7158c179ac67f9330b248e4cf4707e6c3f98", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -23,7 +23,7 @@ pure fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n pure fn path_name(p: @path) -> str { path_name_i(p.idents) }\n \n-pure fn path_name_i(idents: [ident]) -> str {\n+pure fn path_name_i(idents: [ident]/~) -> str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     str::connect(idents.map({|i|*i}), \"::\")\n }\n@@ -246,18 +246,19 @@ fn new_def_hash<V: copy>() -> std::map::hashmap<ast::def_id, V> {\n }\n \n fn block_from_expr(e: @expr) -> blk {\n-    let blk_ = default_block([], option::some::<@expr>(e), e.id);\n+    let blk_ = default_block([]/~, option::some::<@expr>(e), e.id);\n     ret {node: blk_, span: e.span};\n }\n \n-fn default_block(+stmts1: [@stmt], expr1: option<@expr>, id1: node_id) ->\n+fn default_block(+stmts1: [@stmt]/~, expr1: option<@expr>, id1: node_id) ->\n    blk_ {\n-    {view_items: [], stmts: stmts1, expr: expr1, id: id1, rules: default_blk}\n+    {view_items: []/~, stmts: stmts1,\n+     expr: expr1, id: id1, rules: default_blk}\n }\n \n fn ident_to_path(s: span, +i: ident) -> @path {\n-    @{span: s, global: false, idents: [i],\n-      rp: none, types: []}\n+    @{span: s, global: false, idents: [i]/~,\n+      rp: none, types: []/~}\n }\n \n pure fn is_unguarded(&&a: arm) -> bool {\n@@ -267,7 +268,7 @@ pure fn is_unguarded(&&a: arm) -> bool {\n     }\n }\n \n-pure fn unguarded_pat(a: arm) -> option<[@pat]> {\n+pure fn unguarded_pat(a: arm) -> option<[@pat]/~> {\n     if is_unguarded(a) { some(/* FIXME (#2543) */ copy a.pats) } else { none }\n }\n \n@@ -286,24 +287,24 @@ pure fn class_item_ident(ci: @class_member) -> ident {\n type ivar = {ident: ident, ty: @ty, cm: class_mutability,\n              id: node_id, vis: visibility};\n \n-fn public_methods(ms: [@method]) -> [@method] {\n+fn public_methods(ms: [@method]/~) -> [@method]/~ {\n     vec::filter(ms, {|m| alt m.vis {\n                     public { true }\n                     _   { false }}})\n }\n \n-fn split_class_items(cs: [@class_member]) -> ([ivar], [@method]) {\n-    let mut vs = [], ms = [];\n+fn split_class_items(cs: [@class_member]/~) -> ([ivar]/~, [@method]/~) {\n+    let mut vs = []/~, ms = []/~;\n     for cs.each {|c|\n       alt c.node {\n         instance_var(i, t, cm, id, vis) {\n           vs += [{ident: /* FIXME (#2543) */ copy i,\n                   ty: t,\n                   cm: cm,\n                   id: id,\n-                  vis: vis}];\n+                  vis: vis}]/~;\n         }\n-        class_method(m) { ms += [m]; }\n+        class_method(m) { ms += [m]/~; }\n       }\n     };\n     (vs, ms)\n@@ -383,8 +384,8 @@ fn dtor_dec() -> fn_decl {\n     let nil_t = @{id: 0, node: ty_nil, span: dummy_sp()};\n     // dtor has one argument, of type ()\n     {inputs: [{mode: ast::expl(ast::by_ref),\n-               ty: nil_t, ident: @\"_\", id: 0}],\n-     output: nil_t, purity: impure_fn, cf: return_val, constraints: []}\n+               ty: nil_t, ident: @\"_\", id: 0}]/~,\n+     output: nil_t, purity: impure_fn, cf: return_val, constraints: []/~}\n }\n \n // ______________________________________________________________________\n@@ -471,7 +472,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             }\n         },\n \n-        visit_ty_params: fn@(ps: [ty_param]) {\n+        visit_ty_params: fn@(ps: [ty_param]/~) {\n             vec::iter(ps) {|p| vfn(p.id) }\n         },\n "}, {"sha": "af808222f114b24ef595edfdd851543a2988bb3b", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -56,7 +56,7 @@ fn mk_name_value_item(+name: ast::ident, +value: ast::lit)\n     ret @dummy_spanned(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(+name: ast::ident, +items: [@ast::meta_item]) ->\n+fn mk_list_item(+name: ast::ident, +items: [@ast::meta_item]/~) ->\n    @ast::meta_item {\n     ret @dummy_spanned(ast::meta_list(name, items));\n }\n@@ -75,9 +75,9 @@ fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n-fn attr_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n-    let mut mitems = [];\n-    for attrs.each {|a| mitems += [attr_meta(a)]; }\n+fn attr_metas(attrs: [ast::attribute]/~) -> [@ast::meta_item]/~ {\n+    let mut mitems = []/~;\n+    for attrs.each {|a| mitems += [attr_meta(a)]/~; }\n     ret mitems;\n }\n \n@@ -118,7 +118,7 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@str> {\n }\n \n #[doc = \"Gets a list of inner meta items from a list meta_item type\"]\n-fn get_meta_item_list(meta: @ast::meta_item) -> option<[@ast::meta_item]> {\n+fn get_meta_item_list(meta: @ast::meta_item) -> option<[@ast::meta_item]/~> {\n     alt meta.node {\n       ast::meta_list(_, l) { option::some(/* FIXME (#2543) */ copy l) }\n       _ { option::none }\n@@ -147,8 +147,8 @@ fn get_name_value_str_pair(\n #[doc = \"\n Search a list of attributes and return only those with a specific name\n \"]\n-fn find_attrs_by_name(attrs: [ast::attribute], +name: str) ->\n-   [ast::attribute] {\n+fn find_attrs_by_name(attrs: [ast::attribute]/~, +name: str) ->\n+   [ast::attribute]/~ {\n     let filter = (\n         fn@(a: ast::attribute) -> option<ast::attribute> {\n             if *get_attr_name(a) == name {\n@@ -162,8 +162,8 @@ fn find_attrs_by_name(attrs: [ast::attribute], +name: str) ->\n #[doc = \"\n Searcha list of meta items and return only those with a specific name\n \"]\n-fn find_meta_items_by_name(metas: [@ast::meta_item], +name: str) ->\n-   [@ast::meta_item] {\n+fn find_meta_items_by_name(metas: [@ast::meta_item]/~, +name: str) ->\n+   [@ast::meta_item]/~ {\n     let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n         if *get_meta_item_name(m) == name {\n             option::some(m)\n@@ -176,7 +176,7 @@ fn find_meta_items_by_name(metas: [@ast::meta_item], +name: str) ->\n Returns true if a list of meta items contains another meta item. The\n comparison is performed structurally.\n \"]\n-fn contains(haystack: [@ast::meta_item], needle: @ast::meta_item) -> bool {\n+fn contains(haystack: [@ast::meta_item]/~, needle: @ast::meta_item) -> bool {\n     #debug(\"looking for %s\",\n            print::pprust::meta_item_to_str(*needle));\n     for haystack.each {|item|\n@@ -201,7 +201,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n           }\n           ast::meta_list(na, la) {\n \n-            // [Fixme-sorting]\n+            // [Fixme-sorting]/~\n             // FIXME (#607): Needs implementing\n             // This involves probably sorting the list by name and\n             // meta_item variant\n@@ -210,16 +210,16 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains_name(metas: [@ast::meta_item], +name: str) -> bool {\n+fn contains_name(metas: [@ast::meta_item]/~, +name: str) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     ret vec::len(matches) > 0u;\n }\n \n-fn attrs_contains_name(attrs: [ast::attribute], +name: str) -> bool {\n+fn attrs_contains_name(attrs: [ast::attribute]/~, +name: str) -> bool {\n     vec::is_not_empty(find_attrs_by_name(attrs, name))\n }\n \n-fn first_attr_value_str_by_name(attrs: [ast::attribute], +name: str)\n+fn first_attr_value_str_by_name(attrs: [ast::attribute]/~, +name: str)\n     -> option<@str> {\n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n@@ -229,15 +229,15 @@ fn first_attr_value_str_by_name(attrs: [ast::attribute], +name: str)\n }\n \n fn last_meta_item_by_name(\n-    items: [@ast::meta_item],\n+    items: [@ast::meta_item]/~,\n     +name: str\n ) -> option<@ast::meta_item> {\n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n fn last_meta_item_value_str_by_name(\n-    items: [@ast::meta_item],\n+    items: [@ast::meta_item]/~,\n     +name: str\n ) -> option<@str> {\n     alt last_meta_item_by_name(items, name) {\n@@ -252,9 +252,9 @@ fn last_meta_item_value_str_by_name(\n }\n \n fn last_meta_item_list_by_name(\n-    items: [@ast::meta_item],\n+    items: [@ast::meta_item]/~,\n     +name: str\n-) -> option<[@ast::meta_item]> {\n+) -> option<[@ast::meta_item]/~> {\n     alt last_meta_item_by_name(items, name) {\n       some(item) {\n         attr::get_meta_item_list(item)\n@@ -268,7 +268,7 @@ fn last_meta_item_list_by_name(\n \n // FIXME (#607): This needs to sort by meta_item variant in addition to\n // the item name (See [Fixme-sorting])\n-fn sort_meta_items(+items: [@ast::meta_item]) -> [@ast::meta_item] {\n+fn sort_meta_items(+items: [@ast::meta_item]/~) -> [@ast::meta_item]/~ {\n     fn lteq(&&ma: @ast::meta_item, &&mb: @ast::meta_item) -> bool {\n         fn key(m: @ast::meta_item) -> ast::ident {\n             alt m.node {\n@@ -281,13 +281,13 @@ fn sort_meta_items(+items: [@ast::meta_item]) -> [@ast::meta_item] {\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let v: [mut @ast::meta_item] = vec::to_mut(items);\n+    let v: [mut @ast::meta_item]/~ = vec::to_mut(items);\n     std::sort::quick_sort(lteq, v);\n     ret vec::from_mut(v);\n }\n \n-fn remove_meta_items_by_name(items: [@ast::meta_item], name: ast::ident) ->\n-   [@ast::meta_item] {\n+fn remove_meta_items_by_name(items: [@ast::meta_item]/~, name: ast::ident) ->\n+   [@ast::meta_item]/~ {\n \n     ret vec::filter_map(items, {\n         |item|\n@@ -299,11 +299,11 @@ fn remove_meta_items_by_name(items: [@ast::meta_item], name: ast::ident) ->\n     });\n }\n \n-fn find_linkage_attrs(attrs: [ast::attribute]) -> [ast::attribute] {\n-    let mut found = [];\n+fn find_linkage_attrs(attrs: [ast::attribute]/~) -> [ast::attribute]/~ {\n+    let mut found = []/~;\n     for find_attrs_by_name(attrs, \"link\").each {|attr|\n         alt attr.node.value.node {\n-          ast::meta_list(_, _) { found += [attr] }\n+          ast::meta_list(_, _) { found += [attr]/~ }\n           _ { #debug(\"ignoring link attribute that has incorrect type\"); }\n         }\n     }\n@@ -314,15 +314,15 @@ fn find_linkage_attrs(attrs: [ast::attribute]) -> [ast::attribute] {\n From a list of crate attributes get only the meta_items that impact crate\n linkage\n \"]\n-fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n+fn find_linkage_metas(attrs: [ast::attribute]/~) -> [@ast::meta_item]/~ {\n     find_linkage_attrs(attrs).flat_map {|attr|\n         alt check attr.node.value.node {\n           ast::meta_list(_, items) { /* FIXME (#2543) */ copy items }\n         }\n     }\n }\n \n-fn native_abi(attrs: [ast::attribute]) -> either<str, ast::native_abi> {\n+fn native_abi(attrs: [ast::attribute]/~) -> either<str, ast::native_abi> {\n     ret alt attr::first_attr_value_str_by_name(attrs, \"abi\") {\n       option::none {\n         either::right(ast::native_abi_cdecl)\n@@ -349,7 +349,7 @@ enum inline_attr {\n }\n \n #[doc = \"True if something like #[inline] is found in the list of attrs.\"]\n-fn find_inline_attr(attrs: [ast::attribute]) -> inline_attr {\n+fn find_inline_attr(attrs: [ast::attribute]/~) -> inline_attr {\n     // TODO---validate the usage of #[inline] and #[inline(always)]\n     vec::foldl(ia_none, attrs) {|ia,attr|\n         alt attr.node.value.node {\n@@ -368,7 +368,7 @@ fn find_inline_attr(attrs: [ast::attribute]) -> inline_attr {\n \n \n fn require_unique_names(diagnostic: span_handler,\n-                        metas: [@ast::meta_item]) {\n+                        metas: [@ast::meta_item]/~) {\n     let map = map::str_hash();\n     for metas.each {|meta|\n         let name = get_meta_item_name(meta);"}, {"sha": "83085c2cc0f3dbe97fd9bebc10f799538ed2bb74", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -43,7 +43,7 @@ enum file_substr {\n \n type filemap =\n     @{name: filename, substr: file_substr, src: @str,\n-      start_pos: file_pos, mut lines: [file_pos]};\n+      start_pos: file_pos, mut lines: [file_pos]/~};\n \n type codemap = @{files: dvec<filemap>};\n \n@@ -57,7 +57,7 @@ fn new_filemap_w_substr(+filename: filename, +substr: file_substr,\n    -> filemap {\n     ret @{name: filename, substr: substr, src: src,\n           start_pos: {ch: start_pos_ch, byte: start_pos_byte},\n-          mut lines: [{ch: start_pos_ch, byte: start_pos_byte}]};\n+          mut lines: [{ch: start_pos_ch, byte: start_pos_byte}]/~};\n }\n \n fn new_filemap(+filename: filename, src: @str,\n@@ -74,7 +74,7 @@ fn mk_substr_filename(cm: codemap, sp: span) -> str\n }\n \n fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n-    file.lines += [{ch: chpos, byte: byte_pos + file.start_pos.byte}];\n+    file.lines += [{ch: chpos, byte: byte_pos + file.start_pos.byte}]/~;\n }\n \n type lookup_fn = pure fn(file_pos) -> uint;\n@@ -174,7 +174,7 @@ fn span_to_str(sp: span, cm: codemap) -> str {\n              lo.line, lo.col, hi.line, hi.col)\n }\n \n-type file_lines = {file: filemap, lines: [uint]};\n+type file_lines = {file: filemap, lines: [uint]/~};\n \n fn span_to_filename(sp: span, cm: codemap::codemap) -> filename {\n     let lo = lookup_char_pos(cm, sp.lo);\n@@ -184,8 +184,8 @@ fn span_to_filename(sp: span, cm: codemap::codemap) -> filename {\n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n-    let mut lines = [];\n-    for uint::range(lo.line - 1u, hi.line as uint) {|i| lines += [i]; };\n+    let mut lines = []/~;\n+    for uint::range(lo.line - 1u, hi.line as uint) {|i| lines += [i]/~; };\n     ret @{file: lo.file, lines: lines};\n }\n "}, {"sha": "f3c356923f2ecf0b0f5c362ca7259fd99d7e2ba3", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 93, "deletions": 88, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -84,13 +84,13 @@ mod syntax {\n     export parse;\n }\n \n-type ser_tps_map = map::hashmap<str, fn@(@ast::expr) -> [@ast::stmt]>;\n+type ser_tps_map = map::hashmap<str, fn@(@ast::expr) -> [@ast::stmt]/~>;\n type deser_tps_map = map::hashmap<str, fn@() -> @ast::expr>;\n \n fn expand(cx: ext_ctxt,\n           span: span,\n           _mitem: ast::meta_item,\n-          in_items: [@ast::item]) -> [@ast::item] {\n+          in_items: [@ast::item]/~) -> [@ast::item]/~ {\n     fn not_auto_serialize(a: ast::attribute) -> bool {\n         attr::get_attr_name(a) != @\"auto_serialize\"\n     }\n@@ -103,19 +103,19 @@ fn expand(cx: ext_ctxt,\n     vec::flat_map(in_items) {|in_item|\n         alt in_item.node {\n           ast::item_ty(ty, tps, _) {\n-            [filter_attrs(in_item)] + ty_fns(cx, in_item.ident, ty, tps)\n+            [filter_attrs(in_item)]/~ + ty_fns(cx, in_item.ident, ty, tps)\n           }\n \n           ast::item_enum(variants, tps, _) {\n-            [filter_attrs(in_item)] + enum_fns(cx, in_item.ident,\n+            [filter_attrs(in_item)]/~ + enum_fns(cx, in_item.ident,\n                                                in_item.span, variants, tps)\n           }\n \n           _ {\n             cx.span_err(span, \"#[auto_serialize] can only be \\\n                                applied to type and enum \\\n                                definitions\");\n-            [in_item]\n+            [in_item]/~\n           }\n         }\n     }\n@@ -126,26 +126,27 @@ impl helpers for ext_ctxt {\n                    helper_name: str) -> @ast::path {\n         let head = vec::init(base_path.idents);\n         let tail = vec::last(base_path.idents);\n-        self.path(base_path.span, head + [@(helper_name + \"_\" + *tail)])\n+        self.path(base_path.span, head + [@(helper_name + \"_\" + *tail)]/~)\n     }\n \n-    fn path(span: span, strs: [ast::ident]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: none, types: []}\n+    fn path(span: span, strs: [ast::ident]/~) -> @ast::path {\n+        @{span: span, global: false, idents: strs, rp: none, types: []/~}\n     }\n \n-    fn path_tps(span: span, strs: [ast::ident],\n-                tps: [@ast::ty]) -> @ast::path {\n+    fn path_tps(span: span, strs: [ast::ident]/~,\n+                tps: [@ast::ty]/~) -> @ast::path {\n         @{span: span, global: false, idents: strs, rp: none, types: tps}\n     }\n \n-    fn ty_path(span: span, strs: [ast::ident], tps: [@ast::ty]) -> @ast::ty {\n+    fn ty_path(span: span, strs: [ast::ident]/~,\n+               tps: [@ast::ty]/~) -> @ast::ty {\n         @{id: self.next_id(),\n           node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n           span: span}\n     }\n \n     fn ty_fn(span: span,\n-             -input_tys: [@ast::ty],\n+             -input_tys: [@ast::ty]/~,\n              -output: @ast::ty) -> @ast::ty {\n         let args = vec::map(input_tys) {|ty|\n             {mode: ast::expl(ast::by_ref),\n@@ -159,7 +160,7 @@ impl helpers for ext_ctxt {\n                                             output: output,\n                                             purity: ast::impure_fn,\n                                             cf: ast::return_val,\n-                                            constraints: []}),\n+                                            constraints: []/~}),\n           span: span}\n     }\n \n@@ -172,11 +173,11 @@ impl helpers for ext_ctxt {\n     }\n \n     fn var_ref(span: span, name: ast::ident) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path(span, [name])))\n+        self.expr(span, ast::expr_path(self.path(span, [name]/~)))\n     }\n \n-    fn blk(span: span, stmts: [@ast::stmt]) -> ast::blk {\n-        {node: {view_items: [],\n+    fn blk(span: span, stmts: [@ast::stmt]/~) -> ast::blk {\n+        {node: {view_items: []/~,\n                 stmts: stmts,\n                 expr: none,\n                 id: self.next_id(),\n@@ -185,17 +186,17 @@ impl helpers for ext_ctxt {\n     }\n \n     fn expr_blk(expr: @ast::expr) -> ast::blk {\n-        {node: {view_items: [],\n-                stmts: [],\n+        {node: {view_items: []/~,\n+                stmts: []/~,\n                 expr: some(expr),\n                 id: self.next_id(),\n                 rules: ast::default_blk},\n          span: expr.span}\n     }\n \n     fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n-        let path = @{span: span, global: false, idents: [nm],\n-                     rp: none, types: []};\n+        let path = @{span: span, global: false, idents: [nm]/~,\n+                     rp: none, types: []/~};\n         @{id: self.next_id(),\n           node: ast::pat_ident(path, none),\n           span: span}\n@@ -206,7 +207,8 @@ impl helpers for ext_ctxt {\n           span: expr.span}\n     }\n \n-    fn alt_stmt(arms: [ast::arm], span: span, -v: @ast::expr) -> @ast::stmt {\n+    fn alt_stmt(arms: [ast::arm]/~,\n+                span: span, -v: @ast::expr) -> @ast::stmt {\n         self.stmt(\n             self.expr(\n                 span,\n@@ -277,7 +279,7 @@ impl helpers for ext_ctxt {\n \n fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n                   -s: @ast::expr, -v: @ast::expr)\n-    -> [@ast::stmt] {\n+    -> [@ast::stmt]/~ {\n     let ext_cx = cx; // required for #ast{}\n \n     // We want to take a path like a::b::c<...> and generate a call\n@@ -299,15 +301,15 @@ fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n     [cx.stmt(\n         cx.expr(\n             path.span,\n-            ast::expr_call(callee, [s, v] + ty_args, false)))]\n+            ast::expr_call(callee, [s, v]/~ + ty_args, false)))]/~\n }\n \n fn ser_variant(cx: ext_ctxt,\n                tps: ser_tps_map,\n-               tys: [@ast::ty],\n+               tys: [@ast::ty]/~,\n                span: span,\n                -s: @ast::expr,\n-               pfn: fn([@ast::pat]) -> ast::pat_,\n+               pfn: fn([@ast::pat]/~) -> ast::pat_,\n                bodyfn: fn(-@ast::expr, ast::blk) -> @ast::expr,\n                argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n     -> ast::arm {\n@@ -326,9 +328,9 @@ fn ser_variant(cx: ext_ctxt,\n     };\n \n     let body_blk = cx.blk(span, stmts);\n-    let body = cx.blk(span, [cx.stmt(bodyfn(s, body_blk))]);\n+    let body = cx.blk(span, [cx.stmt(bodyfn(s, body_blk))]/~);\n \n-    {pats: [pat], guard: none, body: body}\n+    {pats: [pat]/~, guard: none, body: body}\n }\n \n fn ser_lambda(cx: ext_ctxt, tps: ser_tps_map, ty: @ast::ty,\n@@ -338,34 +340,34 @@ fn ser_lambda(cx: ext_ctxt, tps: ser_tps_map, ty: @ast::ty,\n \n fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n                 ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n-    -> [@ast::stmt] {\n+    -> [@ast::stmt]/~ {\n \n     let ext_cx = cx; // required for #ast{}\n \n     alt ty.node {\n       ast::ty_nil {\n-        [#ast[stmt]{$(s).emit_nil()}]\n+        [#ast[stmt]{$(s).emit_nil()}]/~\n       }\n \n       ast::ty_bot {\n         cx.span_err(\n             ty.span, #fmt[\"Cannot serialize bottom type\"]);\n-        []\n+        []/~\n       }\n \n       ast::ty_box(mt) {\n         let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n-        [#ast(stmt){$(s).emit_box($(l));}]\n+        [#ast(stmt){$(s).emit_box($(l));}]/~\n       }\n \n       ast::ty_uniq(mt) {\n         let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n-        [#ast(stmt){$(s).emit_uniq($(l));}]\n+        [#ast(stmt){$(s).emit_uniq($(l));}]/~\n       }\n \n       ast::ty_ptr(_) | ast::ty_rptr(_, _) {\n         cx.span_err(ty.span, \"cannot serialize pointer types\");\n-        []\n+        []/~\n       }\n \n       ast::ty_rec(flds) {\n@@ -374,20 +376,20 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n             let vf = cx.expr(fld.span,\n                              ast::expr_field(cx.clone(v),\n                                              fld.node.ident,\n-                                             []));\n+                                             []/~));\n             let s = cx.clone(s);\n             let f = cx.lit_str(fld.span, fld.node.ident);\n             let i = cx.lit_uint(fld.span, fidx);\n             let l = ser_lambda(cx, tps, fld.node.mt.ty, cx.clone(s), vf);\n             #ast(stmt){$(s).emit_rec_field($(f), $(i), $(l));}\n         };\n         let fld_lambda = cx.lambda(cx.blk(ty.span, fld_stmts));\n-        [#ast(stmt){$(s).emit_rec($(fld_lambda));}]\n+        [#ast(stmt){$(s).emit_rec($(fld_lambda));}]/~\n       }\n \n       ast::ty_fn(_, _) {\n         cx.span_err(ty.span, \"cannot serialize function types\");\n-        []\n+        []/~\n       }\n \n       ast::ty_tup(tys) {\n@@ -420,8 +422,8 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n                     let body = cx.lambda(blk);\n                     #ast{ $(s).emit_tup_elt($(idx), $(body)) }\n                 })\n-        ];\n-        [cx.alt_stmt(arms, ty.span, v)]\n+        ]/~;\n+        [cx.alt_stmt(arms, ty.span, v)]/~\n       }\n \n       ast::ty_path(path, _) {\n@@ -444,12 +446,12 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n \n       ast::ty_mac(_) {\n         cx.span_err(ty.span, \"cannot serialize macro types\");\n-        []\n+        []/~\n       }\n \n       ast::ty_infer {\n         cx.span_err(ty.span, \"cannot serialize inferred types\");\n-        []\n+        []/~\n       }\n \n       ast::ty_vstore(@{node: ast::ty_vec(mt),_}, ast::vstore_uniq) |\n@@ -467,7 +469,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n \n         [#ast(stmt){\n             std::serialization::emit_from_vec($(s), $(v), {|__e| $(ser_e) })\n-        }]\n+        }]/~\n       }\n \n       ast::ty_vstore(_, _) {\n@@ -477,59 +479,61 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n     }\n }\n \n-fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident, tps: [ast::ty_param],\n+fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n+             tps: [ast::ty_param]/~,\n              f: fn(ext_ctxt, ser_tps_map,\n-                   -@ast::expr, -@ast::expr) -> [@ast::stmt])\n+                   -@ast::expr, -@ast::expr) -> [@ast::stmt]/~)\n     -> @ast::item {\n     let ext_cx = cx; // required for #ast\n \n-    let tp_types = vec::map(tps, {|tp| cx.ty_path(span, [tp.ident], [])});\n-    let v_ty = cx.ty_path(span, [name], tp_types);\n+    let tp_types = vec::map(tps, {|tp| cx.ty_path(span, [tp.ident]/~, []/~)});\n+    let v_ty = cx.ty_path(span, [name]/~, tp_types);\n \n     let tp_inputs =\n         vec::map(tps, {|tp|\n             {mode: ast::expl(ast::by_ref),\n              ty: cx.ty_fn(span,\n-                          [cx.ty_path(span, [tp.ident], [])],\n+                          [cx.ty_path(span, [tp.ident]/~, []/~)]/~,\n                           cx.ty_nil(span)),\n              ident: @(\"__s\" + *tp.ident),\n              id: cx.next_id()}});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n \n-    let ser_inputs: [ast::arg] =\n+    let ser_inputs: [ast::arg]/~ =\n         [{mode: ast::expl(ast::by_ref),\n-          ty: cx.ty_path(span, [@\"__S\"], []),\n+          ty: cx.ty_path(span, [@\"__S\"]/~, []/~),\n           ident: @\"__s\",\n           id: cx.next_id()},\n          {mode: ast::expl(ast::by_ref),\n           ty: v_ty,\n           ident: @\"__v\",\n-          id: cx.next_id()}]\n+          id: cx.next_id()}]/~\n         + tp_inputs;\n \n     let tps_map = map::str_hash();\n     vec::iter2(tps, tp_inputs) {|tp, arg|\n         let arg_ident = arg.ident;\n         tps_map.insert(\n             *tp.ident,\n-            fn@(v: @ast::expr) -> [@ast::stmt] {\n+            fn@(v: @ast::expr) -> [@ast::stmt]/~ {\n                 let f = cx.var_ref(span, arg_ident);\n                 #debug[\"serializing type arg %s\", *arg_ident];\n-                [#ast(stmt){$(f)($(v));}]\n+                [#ast(stmt){$(f)($(v));}]/~\n             });\n     }\n \n     let ser_bnds = @[\n         ast::bound_iface(cx.ty_path(span,\n-                                    [@\"std\", @\"serialization\", @\"serializer\"],\n-                                    []))];\n+                                    [@\"std\", @\"serialization\",\n+                                     @\"serializer\"]/~,\n+                                    []/~))]/~;\n \n-    let ser_tps: [ast::ty_param] =\n+    let ser_tps: [ast::ty_param]/~ =\n         [{ident: @\"__S\",\n           id: cx.next_id(),\n-          bounds: ser_bnds}] +\n+          bounds: ser_bnds}]/~ +\n         vec::map(tps) {|tp| cx.clone_ty_param(tp) };\n \n     let ser_output: @ast::ty = @{id: cx.next_id(),\n@@ -540,13 +544,13 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident, tps: [ast::ty_param],\n                          f(cx, tps_map, #ast{ __s }, #ast{ __v }));\n \n     @{ident: @(\"serialize_\" + *name),\n-      attrs: [],\n+      attrs: []/~,\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: ser_inputs,\n                           output: ser_output,\n                           purity: ast::impure_fn,\n                           cf: ast::return_val,\n-                          constraints: []},\n+                          constraints: []/~},\n                          ser_tps,\n                          ser_blk),\n       vis: ast::public,\n@@ -571,7 +575,7 @@ fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n         cx.lambda(cx.expr_blk(dv_expr))\n     };\n \n-    cx.expr(path.span, ast::expr_call(callee, [d] + ty_args, false))\n+    cx.expr(path.span, ast::expr_call(callee, [d]/~ + ty_args, false))\n }\n \n fn deser_lambda(cx: ext_ctxt, tps: deser_tps_map, ty: @ast::ty,\n@@ -688,30 +692,30 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n }\n \n fn mk_deser_fn(cx: ext_ctxt, span: span,\n-               name: ast::ident, tps: [ast::ty_param],\n+               name: ast::ident, tps: [ast::ty_param]/~,\n                f: fn(ext_ctxt, deser_tps_map, -@ast::expr) -> @ast::expr)\n     -> @ast::item {\n     let ext_cx = cx; // required for #ast\n \n-    let tp_types = vec::map(tps, {|tp| cx.ty_path(span, [tp.ident], [])});\n-    let v_ty = cx.ty_path(span, [name], tp_types);\n+    let tp_types = vec::map(tps, {|tp| cx.ty_path(span, [tp.ident]/~, []/~)});\n+    let v_ty = cx.ty_path(span, [name]/~, tp_types);\n \n     let tp_inputs =\n         vec::map(tps, {|tp|\n             {mode: ast::expl(ast::by_ref),\n              ty: cx.ty_fn(span,\n-                          [],\n-                          cx.ty_path(span, [tp.ident], [])),\n+                          []/~,\n+                          cx.ty_path(span, [tp.ident]/~, []/~)),\n              ident: @(\"__d\" + *tp.ident),\n              id: cx.next_id()}});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n-    let deser_inputs: [ast::arg] =\n+    let deser_inputs: [ast::arg]/~ =\n         [{mode: ast::expl(ast::by_ref),\n-          ty: cx.ty_path(span, [@\"__D\"], []),\n+          ty: cx.ty_path(span, [@\"__D\"]/~, []/~),\n           ident: @\"__d\",\n-          id: cx.next_id()}]\n+          id: cx.next_id()}]/~\n         + tp_inputs;\n \n     let tps_map = map::str_hash();\n@@ -728,46 +732,47 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n     let deser_bnds = @[\n         ast::bound_iface(cx.ty_path(\n             span,\n-            [@\"std\", @\"serialization\", @\"deserializer\"],\n-            []))];\n+            [@\"std\", @\"serialization\", @\"deserializer\"]/~,\n+            []/~))]/~;\n \n-    let deser_tps: [ast::ty_param] =\n+    let deser_tps: [ast::ty_param]/~ =\n         [{ident: @\"__D\",\n           id: cx.next_id(),\n-          bounds: deser_bnds}] + vec::map(tps) {|tp|\n+          bounds: deser_bnds}]/~ + vec::map(tps) {|tp|\n         let cloned = cx.clone_ty_param(tp);\n-        {bounds: @(*cloned.bounds + [ast::bound_copy]) with cloned}\n+        {bounds: @(*cloned.bounds + [ast::bound_copy]/~) with cloned}\n     };\n \n     let deser_blk = cx.expr_blk(f(cx, tps_map, #ast(expr){__d}));\n \n     @{ident: @(\"deserialize_\" + *name),\n-      attrs: [],\n+      attrs: []/~,\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: deser_inputs,\n                           output: v_ty,\n                           purity: ast::impure_fn,\n                           cf: ast::return_val,\n-                          constraints: []},\n+                          constraints: []/~},\n                          deser_tps,\n                          deser_blk),\n       vis: ast::public,\n       span: span}\n }\n \n-fn ty_fns(cx: ext_ctxt, name: ast::ident, ty: @ast::ty, tps: [ast::ty_param])\n-    -> [@ast::item] {\n+fn ty_fns(cx: ext_ctxt, name: ast::ident,\n+          ty: @ast::ty, tps: [ast::ty_param]/~)\n+    -> [@ast::item]/~ {\n \n     let span = ty.span;\n     [\n         mk_ser_fn(cx, span, name, tps, {|a,b,c,d|ser_ty(a, b, ty, c, d)}),\n         mk_deser_fn(cx, span, name, tps, {|a,b,c|deser_ty(a, b, ty, c)})\n-    ]\n+    ]/~\n }\n \n fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n-            e_span: span, variants: [ast::variant],\n-            -s: @ast::expr, -v: @ast::expr) -> [@ast::stmt] {\n+            e_span: span, variants: [ast::variant]/~,\n+            -s: @ast::expr, -v: @ast::expr) -> [@ast::stmt]/~ {\n     let ext_cx = cx;\n     let arms = vec::from_fn(vec::len(variants)) {|vidx|\n         let variant = variants[vidx];\n@@ -781,9 +786,9 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n             // Generate pattern var(v1, v2, v3)\n             {|pats|\n                 if vec::is_empty(pats) {\n-                    ast::pat_ident(cx.path(v_span, [v_name]), none)\n+                    ast::pat_ident(cx.path(v_span, [v_name]/~), none)\n                 } else {\n-                    ast::pat_enum(cx.path(v_span, [v_name]), some(pats))\n+                    ast::pat_enum(cx.path(v_span, [v_name]/~), some(pats))\n                 }\n             },\n \n@@ -809,16 +814,16 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n                 }\n             })\n     };\n-    let lam = cx.lambda(cx.blk(e_span, [cx.alt_stmt(arms, e_span, v)]));\n+    let lam = cx.lambda(cx.blk(e_span, [cx.alt_stmt(arms, e_span, v)]/~));\n     let e_name = cx.lit_str(e_span, e_name);\n-    [#ast(stmt){ $(s).emit_enum($(e_name), $(lam)) }]\n+    [#ast(stmt){ $(s).emit_enum($(e_name), $(lam)) }]/~\n }\n \n fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n-              e_span: span, variants: [ast::variant],\n+              e_span: span, variants: [ast::variant]/~,\n               -d: @ast::expr) -> @ast::expr {\n     let ext_cx = cx;\n-    let arms: [ast::arm] = vec::from_fn(vec::len(variants)) {|vidx|\n+    let arms: [ast::arm]/~ = vec::from_fn(vec::len(variants)) {|vidx|\n         let variant = variants[vidx];\n         let v_span = variant.span;\n         let v_name = variant.node.name;\n@@ -843,7 +848,7 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n \n         {pats: [@{id: cx.next_id(),\n                   node: ast::pat_lit(cx.lit_uint(v_span, vidx)),\n-                  span: v_span}],\n+                  span: v_span}]/~,\n          guard: none,\n          body: cx.expr_blk(body)}\n     };\n@@ -859,12 +864,12 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n }\n \n fn enum_fns(cx: ext_ctxt, e_name: ast::ident, e_span: span,\n-               variants: [ast::variant], tps: [ast::ty_param])\n-    -> [@ast::item] {\n+               variants: [ast::variant]/~, tps: [ast::ty_param]/~)\n+    -> [@ast::item]/~ {\n     [\n         mk_ser_fn(cx, e_span, e_name, tps,\n                   {|a,b,c,d|ser_enum(a, b, e_name, e_span, variants, c, d)}),\n         mk_deser_fn(cx, e_span, e_name, tps,\n                     {|a,b,c|deser_enum(a, b, e_name, e_span, variants, c)})\n-    ]\n+    ]/~\n }"}, {"sha": "96a1efdfe7a1f326881c98d7ebd3ca1b5c7ccb19", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -12,7 +12,7 @@ type macro_def = {ident: ast::ident, ext: syntax_extension};\n type macro_definer =\n     fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> macro_def;\n type item_decorator =\n-    fn@(ext_ctxt, span, ast::meta_item, [@ast::item]) -> [@ast::item];\n+    fn@(ext_ctxt, span, ast::meta_item, [@ast::item]/~) -> [@ast::item]/~;\n \n type syntax_expander_tt = {expander: syntax_expander_tt_, span: option<span>};\n type syntax_expander_tt_ = fn@(ext_ctxt, span, ast::token_tree) -> @ast::expr;\n@@ -72,7 +72,7 @@ iface ext_ctxt {\n     fn backtrace() -> expn_info;\n     fn mod_push(mod_name: ast::ident);\n     fn mod_pop();\n-    fn mod_path() -> [ast::ident];\n+    fn mod_path() -> [ast::ident]/~;\n     fn bt_push(ei: codemap::expn_info_);\n     fn bt_pop();\n     fn span_fatal(sp: span, msg: str) -> !;\n@@ -88,7 +88,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n     type ctxt_repr = {parse_sess: parse::parse_sess,\n                       cfg: ast::crate_cfg,\n                       mut backtrace: expn_info,\n-                      mut mod_path: [ast::ident]};\n+                      mut mod_path: [ast::ident]/~};\n     impl of ext_ctxt for ctxt_repr {\n         fn codemap() -> codemap { self.parse_sess.cm }\n         fn parse_sess() -> parse::parse_sess { self.parse_sess }\n@@ -97,7 +97,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn backtrace() -> expn_info { self.backtrace }\n         fn mod_push(i: ast::ident) { vec::push(self.mod_path, i); }\n         fn mod_pop() { vec::pop(self.mod_path); }\n-        fn mod_path() -> [ast::ident] { ret self.mod_path; }\n+        fn mod_path() -> [ast::ident]/~ { ret self.mod_path; }\n         fn bt_push(ei: codemap::expn_info_) {\n             alt ei {\n               expanded_from({call_site: cs, callie: callie}) {\n@@ -145,7 +145,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         parse_sess: parse_sess,\n         cfg: cfg,\n         mut backtrace: none,\n-        mut mod_path: []\n+        mut mod_path: []/~\n     };\n     ret imp as ext_ctxt\n }\n@@ -185,12 +185,12 @@ fn make_new_expr(cx: ext_ctxt, sp: codemap::span, expr: ast::expr_) ->\n }\n \n fn get_mac_args_no_max(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                       min: uint, name: str) -> [@ast::expr] {\n+                       min: uint, name: str) -> [@ast::expr]/~ {\n     ret get_mac_args(cx, sp, arg, min, none, name);\n }\n \n fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                min: uint, max: option<uint>, name: str) -> [@ast::expr] {\n+                min: uint, max: option<uint>, name: str) -> [@ast::expr]/~ {\n     alt arg {\n       some(expr) {\n         alt expr.node {"}, {"sha": "2e5fe63eb5ab25feab07a51f34f3461e832fb935", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -28,35 +28,35 @@ fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n     let expr = ast::expr_unary(op, e);\n     ret @{id: cx.next_id(), node: expr, span: sp};\n }\n-fn mk_path(cx: ext_ctxt, sp: span, idents: [ast::ident]) ->\n+fn mk_path(cx: ext_ctxt, sp: span, idents: [ast::ident]/~) ->\n     @ast::expr {\n     let path = @{span: sp, global: false, idents: idents,\n-                 rp: none, types: []};\n+                 rp: none, types: []/~};\n     let pathexpr = ast::expr_path(path);\n     ret @{id: cx.next_id(), node: pathexpr, span: sp};\n }\n fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n     -> @ast::expr {\n-    let expr = ast::expr_field(p, m, []);\n+    let expr = ast::expr_field(p, m, []/~);\n     ret @{id: cx.next_id(), node: expr, span: sp};\n }\n-fn mk_access(cx: ext_ctxt, sp: span, p: [ast::ident], m: ast::ident)\n+fn mk_access(cx: ext_ctxt, sp: span, p: [ast::ident]/~, m: ast::ident)\n     -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, p);\n     ret mk_access_(cx, sp, pathexpr, m);\n }\n fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n-            args: [@ast::expr]) -> @ast::expr {\n+            args: [@ast::expr]/~) -> @ast::expr {\n     let callexpr = ast::expr_call(fn_expr, args, false);\n     ret @{id: cx.next_id(), node: callexpr, span: sp};\n }\n-fn mk_call(cx: ext_ctxt, sp: span, fn_path: [ast::ident],\n-             args: [@ast::expr]) -> @ast::expr {\n+fn mk_call(cx: ext_ctxt, sp: span, fn_path: [ast::ident]/~,\n+             args: [@ast::expr]/~) -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, fn_path);\n     ret mk_call_(cx, sp, pathexpr, args);\n }\n // e = expr, t = type\n-fn mk_vec_e(cx: ext_ctxt, sp: span, exprs: [@ast::expr]) ->\n+fn mk_vec_e(cx: ext_ctxt, sp: span, exprs: [@ast::expr]/~) ->\n    @ast::expr {\n     let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     ret @{id: cx.next_id(), node: vecexpr, span: sp};\n@@ -72,15 +72,15 @@ fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, exprs: [@ast::expr]/~) ->\n }\n \n fn mk_rec_e(cx: ext_ctxt, sp: span,\n-            fields: [{ident: ast::ident, ex: @ast::expr}]) ->\n+            fields: [{ident: ast::ident, ex: @ast::expr}]/~) ->\n     @ast::expr {\n-    let mut astfields: [ast::field] = [];\n+    let mut astfields: [ast::field]/~ = []/~;\n     for fields.each {|field|\n         let ident = field.ident;\n         let val = field.ex;\n         let astfield =\n             {node: {mutbl: ast::m_imm, ident: ident, expr: val}, span: sp};\n-        astfields += [astfield];\n+        astfields += [astfield]/~;\n     }\n     let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n     ret @{id: cx.next_id(), node: recexpr, span: sp};"}, {"sha": "9f445218007ea974d0a380cd38fabd050814c0e1", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -9,7 +9,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     }\n \n     ret @{id: cx.next_id(),\n-          node: ast::expr_path(@{span: sp, global: false, idents: [@res],\n-                                 rp: none, types: []}),\n+          node: ast::expr_path(@{span: sp, global: false, idents: [@res]/~,\n+                                 rp: none, types: []/~}),\n           span: sp};\n }"}, {"sha": "223cca25694b93d824ef6b9862502ca8e3e2934a", "filename": "src/libsyntax/ext/earley_parser.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fearley_parser.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -32,11 +32,11 @@ fn is_some(&&mpu: matcher_pos_up) -> bool {\n }\n \n type matcher_pos = ~{\n-    elts: [ast::matcher], // maybe should be /& ? Need to understand regions.\n+    elts: [ast::matcher]/~, // maybe should be /&? Need to understand regions.\n     sep: option<token>,\n     mut idx: uint,\n     mut up: matcher_pos_up, // mutable for swapping only\n-    matches: [dvec<@arb_depth>]\n+    matches: [dvec<@arb_depth>]/~\n };\n \n fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n@@ -55,26 +55,26 @@ fn count_names(ms: [matcher]/&) -> uint {\n         }})\n }\n \n-fn new_matcher_pos(ms: [matcher], sep: option<token>) -> matcher_pos {\n+fn new_matcher_pos(ms: [matcher]/~, sep: option<token>) -> matcher_pos {\n     ~{elts: ms, sep: sep, mut idx: 0u, mut up: matcher_pos_up(none),\n       matches: copy vec::from_fn(count_names(ms), {|_i| dvec::dvec()}) }\n }\n \n /* logically, an arb_depth should contain only one kind of nonterminal */\n-enum arb_depth { leaf(whole_nt), seq([@arb_depth]) }\n+enum arb_depth { leaf(whole_nt), seq([@arb_depth]/~) }\n \n type earley_item = matcher_pos;\n \n \n-fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: [matcher])\n-    -> [@arb_depth] {\n-    let mut cur_eis = [];\n+fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: [matcher]/~)\n+    -> [@arb_depth]/~ {\n+    let mut cur_eis = []/~;\n     vec::push(cur_eis, new_matcher_pos(ms, none));\n \n     loop {\n-        let mut bb_eis = []; // black-box parsed by parser.rs\n-        let mut next_eis = []; // or proceed normally\n-        let mut eof_eis = [];\n+        let mut bb_eis = []/~; // black-box parsed by parser.rs\n+        let mut next_eis = []/~; // or proceed normally\n+        let mut eof_eis = []/~;\n \n         let {tok: tok, sp: _} = rdr.peek();\n \n@@ -218,12 +218,12 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: [matcher])\n \n fn parse_nt(p: parser, name: str) -> whole_nt {\n     alt name {\n-      \"item\" { alt p.parse_item([], ast::public) {\n+      \"item\" { alt p.parse_item([]/~, ast::public) {\n         some(i) { token::w_item(i) }\n         none { p.fatal(\"expected an item keyword\") }\n       }}\n       \"block\" { token::w_block(p.parse_block()) }\n-      \"stmt\" { token::w_stmt(p.parse_stmt([])) }\n+      \"stmt\" { token::w_stmt(p.parse_stmt([]/~)) }\n       \"pat\" { token::w_pat(p.parse_pat()) }\n       \"expr\" { token::w_expr(p.parse_expr()) }\n       \"ty\" { token::w_ty(p.parse_ty(false /* no need to disambiguate*/)) }"}, {"sha": "ca5d7f6bab33d1d30bf82229da5c6f44d96adaf3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -45,7 +45,7 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n                   some(macro_defining(ext)) {\n                     let named_extension = ext(cx, pth.span, args, body);\n                     exts.insert(*named_extension.ident, named_extension.ext);\n-                    (ast::expr_rec([], none), s)\n+                    (ast::expr_rec([]/~, none), s)\n                   }\n                   some(normal_tt(_)) {\n                     cx.span_fatal(pth.span,\n@@ -101,7 +101,7 @@ fn expand_mod_items(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n     // decorated with \"item decorators\", then use that function to transform\n     // the item into a new set of items.\n     let new_items = vec::flat_map(module.items) {|item|\n-        vec::foldr(item.attrs, [item]) {|attr, items|\n+        vec::foldr(item.attrs, [item]/~) {|attr, items|\n             let mname = alt attr.node.value.node {\n               ast::meta_word(n) { n }\n               ast::meta_name_value(n, _) { n }"}, {"sha": "43408dec7395300307e09d6cfd99ddfa60747d79", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -34,10 +34,11 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n // probably be factored out in common with other code that builds\n // expressions.  Also: Cleanup the naming of these functions.\n // NOTE: Moved many of the common ones to build.rs --kevina\n-fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n+fn pieces_to_expr(cx: ext_ctxt, sp: span,\n+                  pieces: [piece]/~, args: [@ast::expr]/~)\n    -> @ast::expr {\n-    fn make_path_vec(_cx: ext_ctxt, ident: ast::ident) -> [ast::ident] {\n-        ret [@\"extfmt\", @\"rt\", ident];\n+    fn make_path_vec(_cx: ext_ctxt, ident: ast::ident) -> [ast::ident]/~ {\n+        ret [@\"extfmt\", @\"rt\", ident]/~;\n     }\n     fn make_rt_path_expr(cx: ext_ctxt, sp: span,\n                          ident: ast::ident) -> @ast::expr {\n@@ -48,8 +49,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n     // which tells the RT::conv* functions how to perform the conversion\n \n     fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: conv) -> @ast::expr {\n-        fn make_flags(cx: ext_ctxt, sp: span, flags: [flag]) -> @ast::expr {\n-            let mut flagexprs: [@ast::expr] = [];\n+        fn make_flags(cx: ext_ctxt, sp: span, flags: [flag]/~) -> @ast::expr {\n+            let mut flagexprs: [@ast::expr]/~ = []/~;\n             for flags.each {|f|\n                 let mut fstr;\n                 alt f {\n@@ -59,7 +60,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n                   flag_sign_always { fstr = \"flag_sign_always\"; }\n                   flag_alternate { fstr = \"flag_alternate\"; }\n                 }\n-                flagexprs += [make_rt_path_expr(cx, sp, @fstr)];\n+                flagexprs += [make_rt_path_expr(cx, sp, @fstr)]/~;\n             }\n             ret mk_uniq_vec_e(cx, sp, flagexprs);\n         }\n@@ -71,7 +72,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n               count_is(c) {\n                 let count_lit = mk_int(cx, sp, c);\n                 let count_is_path = make_path_vec(cx, @\"count_is\");\n-                let count_is_args = [count_lit];\n+                let count_is_args = [count_lit]/~;\n                 ret mk_call(cx, sp, count_is_path, count_is_args);\n               }\n               _ { cx.span_unimpl(sp, \"unimplemented #fmt conversion\"); }\n@@ -99,7 +100,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n                          [{ident: @\"flags\", ex: flags_expr},\n                           {ident: @\"width\", ex: width_expr},\n                           {ident: @\"precision\", ex: precision_expr},\n-                          {ident: @\"ty\", ex: ty_expr}]);\n+                          {ident: @\"ty\", ex: ty_expr}]/~);\n         }\n         let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n@@ -113,7 +114,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n         let fname = \"conv_\" + conv_type;\n         let path = make_path_vec(cx, @fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n-        let args = [cnv_expr, arg];\n+        let args = [cnv_expr, arg]/~;\n         ret mk_call(cx, arg.span, path, args);\n     }\n     fn make_new_conv(cx: ext_ctxt, sp: span, cnv: conv, arg: @ast::expr) ->"}, {"sha": "50fac765483dc525eec919f13006c1e3e3c37516", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -11,5 +11,6 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     );\n \n     //trivial expression\n-    ret @{id: cx.next_id(), node: ast::expr_rec([], option::none), span: sp};\n+    ret @{id: cx.next_id(), node: ast::expr_rec([]/~, option::none),\n+          span: sp};\n }"}, {"sha": "648532d30245598645bf8fb73d970ae19fa24d09", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -35,7 +35,7 @@ impl of qq_helper for @ast::crate {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_crate(*self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_crate\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_crate\"]/~)\n     }\n     fn get_fold_fn() -> str {\"fold_crate\"}\n }\n@@ -49,7 +49,7 @@ impl of qq_helper for @ast::expr {\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_expr\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_expr\"]/~)\n     }\n     fn get_fold_fn() -> str {\"fold_expr\"}\n }\n@@ -63,7 +63,7 @@ impl of qq_helper for @ast::ty {\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_ty\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_ty\"]/~)\n     }\n     fn get_fold_fn() -> str {\"fold_ty\"}\n }\n@@ -72,7 +72,7 @@ impl of qq_helper for @ast::item {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_item(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_item\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_item\"]/~)\n     }\n     fn get_fold_fn() -> str {\"fold_item\"}\n }\n@@ -81,7 +81,7 @@ impl of qq_helper for @ast::stmt {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_stmt(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_stmt\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_stmt\"]/~)\n     }\n     fn get_fold_fn() -> str {\"fold_stmt\"}\n }\n@@ -90,7 +90,7 @@ impl of qq_helper for @ast::pat {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_pat(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_pat\"])\n+        mk_path(cx, sp, [@\"syntax\", @\"ext\", @\"qquote\", @\"parse_pat\"]/~)\n     }\n     fn get_fold_fn() -> str {\"fold_pat\"}\n }\n@@ -133,12 +133,12 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n {\n     let mut what = \"expr\";\n     option::iter(arg) {|arg|\n-        let args: [@ast::expr] =\n+        let args: [@ast::expr]/~ =\n             alt arg.node {\n               ast::expr_vec(elts, _) { elts }\n               _ {\n                 ecx.span_fatal\n-                    (_sp, \"#ast requires arguments of the form `[...]`.\")\n+                    (_sp, \"#ast requires arguments of the form `[...]/~`.\")\n               }\n             };\n         if vec::len::<@ast::expr>(args) != 1u {\n@@ -163,14 +163,14 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n     };\n }\n \n-fn parse_crate(p: parser) -> @ast::crate { p.parse_crate_mod([]) }\n+fn parse_crate(p: parser) -> @ast::crate { p.parse_crate_mod([]/~) }\n fn parse_ty(p: parser) -> @ast::ty { p.parse_ty(false) }\n-fn parse_stmt(p: parser) -> @ast::stmt { p.parse_stmt([]) }\n+fn parse_stmt(p: parser) -> @ast::stmt { p.parse_stmt([]/~) }\n fn parse_expr(p: parser) -> @ast::expr { p.parse_expr() }\n fn parse_pat(p: parser) -> @ast::pat { p.parse_pat() }\n \n fn parse_item(p: parser) -> @ast::item {\n-    alt p.parse_item([], ast::public) {\n+    alt p.parse_item([]/~, ast::public) {\n       some(item) { item }\n       none       { fail \"parse_item: parsing an item failed\"; }\n     }\n@@ -230,47 +230,48 @@ fn finish<T: qq_helper>\n     let cx = ecx;\n \n     let cfg_call = {||\n-        mk_call_(cx, sp, mk_access(cx, sp, [@\"ext_cx\"], @\"cfg\"), [])\n+        mk_call_(cx, sp, mk_access(cx, sp, [@\"ext_cx\"]/~, @\"cfg\"), []/~)\n     };\n \n     let parse_sess_call = {||\n-        mk_call_(cx, sp, mk_access(cx, sp, [@\"ext_cx\"], @\"parse_sess\"), [])\n+        mk_call_(cx, sp,\n+                 mk_access(cx, sp, [@\"ext_cx\"]/~, @\"parse_sess\"), []/~)\n     };\n \n     let pcall = mk_call(cx,sp,\n                        [@\"syntax\", @\"parse\", @\"parser\",\n-                        @\"parse_from_source_str\"],\n+                        @\"parse_from_source_str\"]/~,\n                        [node.mk_parse_fn(cx,sp),\n                         mk_str(cx,sp, fname),\n                         mk_call(cx,sp,\n                                 [@\"syntax\",@\"ext\",\n-                                 @\"qquote\", @\"mk_file_substr\"],\n+                                 @\"qquote\", @\"mk_file_substr\"]/~,\n                                 [mk_str(cx,sp, loc.file.name),\n                                  mk_uint(cx,sp, loc.line),\n-                                 mk_uint(cx,sp, loc.col)]),\n+                                 mk_uint(cx,sp, loc.col)]/~),\n                         mk_unary(cx,sp, ast::box(ast::m_imm),\n                                  mk_str(cx,sp, str2)),\n                         cfg_call(),\n-                        parse_sess_call()]\n+                        parse_sess_call()]/~\n                       );\n     let mut rcall = pcall;\n     if (g_len > 0u) {\n         rcall = mk_call(cx,sp,\n-                        [@\"syntax\", @\"ext\", @\"qquote\", @\"replace\"],\n+                        [@\"syntax\", @\"ext\", @\"qquote\", @\"replace\"]/~,\n                         [pcall,\n                          mk_uniq_vec_e(cx,sp, qcx.gather.map_to_vec {|g|\n                              mk_call(cx,sp,\n                                      [@\"syntax\", @\"ext\",\n-                                      @\"qquote\", @g.constr],\n-                                     [g.e])}),\n+                                      @\"qquote\", @g.constr]/~,\n+                                     [g.e]/~)}),\n                          mk_path(cx,sp,\n                                  [@\"syntax\", @\"ext\", @\"qquote\",\n-                                  @node.get_fold_fn()])]);\n+                                  @node.get_fold_fn()]/~)]/~);\n     }\n     ret rcall;\n }\n \n-fn replace<T>(node: T, repls: [fragment], ff: fn (ast_fold, T) -> T)\n+fn replace<T>(node: T, repls: [fragment]/~, ff: fn (ast_fold, T) -> T)\n     -> T\n {\n     let aft = default_ast_fold();\n@@ -290,7 +291,7 @@ fn fold_item(f: ast_fold, &&n: @ast::item) -> @ast::item {f.fold_item(n)}\n fn fold_stmt(f: ast_fold, &&n: @ast::stmt) -> @ast::stmt {f.fold_stmt(n)}\n fn fold_pat(f: ast_fold, &&n: @ast::pat) -> @ast::pat {f.fold_pat(n)}\n \n-fn replace_expr(repls: [fragment],\n+fn replace_expr(repls: [fragment]/~,\n                 e: ast::expr_, s: span, fld: ast_fold,\n                 orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n     -> (ast::expr_, span)\n@@ -304,7 +305,7 @@ fn replace_expr(repls: [fragment],\n     }\n }\n \n-fn replace_ty(repls: [fragment],\n+fn replace_ty(repls: [fragment]/~,\n                 e: ast::ty_, s: span, fld: ast_fold,\n                 orig: fn@(ast::ty_, span, ast_fold)->(ast::ty_, span))\n     -> (ast::ty_, span)"}, {"sha": "c29b2246993f2bcb75f681ca33261491476370d2", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -22,7 +22,7 @@ fn path_to_ident(pth: @path) -> option<ident> {\n type clause = {params: binders, body: @expr};\n \n /* logically, an arb_depth should contain only one kind of matchable */\n-enum arb_depth<T> { leaf(T), seq(@[arb_depth<T>], span), }\n+enum arb_depth<T> { leaf(T), seq(@[arb_depth<T>]/~, span), }\n \n \n enum matchable {\n@@ -70,8 +70,8 @@ fn match_error(cx: ext_ctxt, m: matchable, expected: str) -> ! {\n type match_result = option<arb_depth<matchable>>;\n type selector = fn@(matchable) -> match_result;\n \n-fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n-   {pre: [@expr], rep: option<@expr>, post: [@expr]} {\n+fn elts_to_ell(cx: ext_ctxt, elts: [@expr]/~) ->\n+   {pre: [@expr]/~, rep: option<@expr>, post: [@expr]/~} {\n     let mut idx: uint = 0u;\n     let mut res = none;\n     for elts.each {|elt|\n@@ -96,15 +96,15 @@ fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n     }\n     ret alt res {\n           some(val) { val }\n-          none { {pre: elts, rep: none, post: []} }\n+          none { {pre: elts, rep: none, post: []/~} }\n         }\n }\n \n-fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: [T]) ->\n-   option<[U]> {\n-    let mut res = [];\n+fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: [T]/~) ->\n+   option<[U]/~> {\n+    let mut res = []/~;\n     for v.each {|elem|\n-        alt f(elem) { none { ret none; } some(fv) { res += [fv]; } }\n+        alt f(elem) { none { ret none; } some(fv) { res += [fv]/~; } }\n     }\n     ret some(res);\n }\n@@ -182,7 +182,7 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n /* use the bindings on the body to generate the expanded code */\n \n fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n-    let idx_path: @mut [uint] = @mut [];\n+    let idx_path: @mut [uint]/~ = @mut []/~;\n     fn new_id(_old: node_id, cx: ext_ctxt) -> node_id { ret cx.next_id(); }\n     fn new_span(cx: ext_ctxt, sp: span) -> span {\n         /* this discards information in the case of macro-defining macros */\n@@ -214,7 +214,7 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n \n \n /* helper: descend into a matcher */\n-fn follow(m: arb_depth<matchable>, idx_path: @mut [uint]) ->\n+fn follow(m: arb_depth<matchable>, idx_path: @mut [uint]/~) ->\n    arb_depth<matchable> {\n     let mut res: arb_depth<matchable> = m;\n     for vec::each(*idx_path) {|idx|\n@@ -227,7 +227,7 @@ fn follow(m: arb_depth<matchable>, idx_path: @mut [uint]) ->\n }\n \n fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n-                    idx_path: @mut [uint]) -> option<matchable> {\n+                    idx_path: @mut [uint]/~) -> option<matchable> {\n     alt mmaybe {\n       none { ret none }\n       some(m) {\n@@ -264,8 +264,9 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n \n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n-fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n-                    recur: fn@(&&@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n+fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut [uint]/~,\n+                    recur: fn@(&&@expr) -> @expr,\n+                    exprs: [@expr]/~) -> [@expr]/~ {\n     alt elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n         let mut res = vec::map(pre, recur);\n@@ -308,8 +309,8 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n                 /* Whew, we now know how how many times to repeat */\n                 let mut idx: uint = 0u;\n                 while idx < rc {\n-                    *idx_path += [idx];\n-                    res += [recur(repeat_me)]; // whew!\n+                    *idx_path += [idx]/~;\n+                    res += [recur(repeat_me)]/~; // whew!\n                     vec::pop(*idx_path);\n                     idx += 1u;\n                 }\n@@ -326,7 +327,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n \n \n // substitute, in a position that's required to be an ident\n-fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n+fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut [uint]/~,\n                     &&i: ident, _fld: ast_fold) -> ident {\n     ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n@@ -336,14 +337,14 @@ fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n }\n \n \n-fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n+fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut [uint]/~,\n                    p: path, _fld: ast_fold) -> path {\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n     alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n       some(match_ident(id)) {\n-        {span: id.span, global: false, idents: [id.node],\n-         rp: none, types: []}\n+        {span: id.span, global: false, idents: [id.node]/~,\n+         rp: none, types: []/~}\n       }\n       some(match_path(a_pth)) { *a_pth }\n       some(m) { match_error(cx, m, \"a path\") }\n@@ -352,7 +353,7 @@ fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n }\n \n \n-fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n+fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut [uint]/~,\n                    e: ast::expr_, s: span, fld: ast_fold,\n                    orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n     -> (ast::expr_, span)\n@@ -367,9 +368,9 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n               some(match_ident(id)) {\n                 (expr_path(@{span: id.span,\n                              global: false,\n-                             idents: [id.node],\n+                             idents: [id.node]/~,\n                              rp: none,\n-                             types: []}), id.span)\n+                             types: []/~}), id.span)\n               }\n               some(match_path(a_pth)) { (expr_path(a_pth), s) }\n               some(match_expr(a_exp)) { (a_exp.node, a_exp.span) }\n@@ -381,7 +382,7 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n         }\n }\n \n-fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n+fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut [uint]/~,\n                    t: ast::ty_, s: span, fld: ast_fold,\n                    orig: fn@(ast::ty_, span, ast_fold) -> (ast::ty_, span))\n     -> (ast::ty_, span)\n@@ -407,7 +408,7 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n /* for parsing reasons, syntax variables bound to blocks must be used like\n `{v}` */\n \n-fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n+fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut [uint]/~,\n                     blk: blk_, s: span, fld: ast_fold,\n                     orig: fn@(blk_, span, ast_fold) -> (blk_, span))\n     -> (blk_, span)\n@@ -458,7 +459,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                 }\n               }\n               {pre: pre, rep: none, post: post} {\n-                if post != [] {\n+                if post != []/~ {\n                     cx.bug(\"elts_to_ell provided an invalid result\");\n                 }\n                 p_t_s_r_length(cx, vec::len(pre), false, s, b);\n@@ -606,10 +607,10 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _) {\n-                    let mut elts = [];\n+                    let mut elts = []/~;\n                     let mut idx = offset;\n                     while idx < vec::len(arg_elts) {\n-                        elts += [leaf(match_expr(arg_elts[idx]))];\n+                        vec::push(elts, leaf(match_expr(arg_elts[idx])));\n                         idx += 1u;\n                     }\n \n@@ -651,7 +652,7 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n         compose_sels(s, {|x|len_select(cx, x, at_least, len)}));\n }\n \n-fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: [@expr], _repeat_after: bool,\n+fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: [@expr]/~, _repeat_after: bool,\n                          s: selector, b: binders) {\n     let mut idx: uint = 0u;\n     while idx < vec::len(elts) {\n@@ -679,14 +680,14 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     let args = get_mac_args_no_max(cx, sp, arg, 0u, \"macro\");\n \n     let mut macro_name: option<@str> = none;\n-    let mut clauses: [@clause] = [];\n+    let mut clauses: [@clause]/~ = []/~;\n     for args.each {|arg|\n         alt arg.node {\n           expr_vec(elts, mutbl) {\n             if vec::len(elts) != 2u {\n                 cx.span_fatal((*arg).span,\n                               \"extension clause must consist of [\" +\n-                                  \"macro invocation, expansion body]\");\n+                                  \"macro invocation, expansion body]/~\");\n             }\n \n \n@@ -719,7 +720,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     };\n                     clauses +=\n                         [@{params: pattern_to_selectors(cx, arg),\n-                           body: elts[1u]}];\n+                           body: elts[1u]}]/~;\n \n                     // FIXME (#2251): check duplicates (or just simplify\n                     // the macro arg situation)\n@@ -739,7 +740,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n           }\n           _ {\n             cx.span_fatal((*arg).span,\n-                          \"extension must be [clause, \" + \" ...]\");\n+                          \"extension must be [clause, \" + \" ...]/~\");\n           }\n         }\n     }\n@@ -759,7 +760,8 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n          ext: normal({expander: ext, span: some(option::get(arg).span)})};\n \n     fn generic_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                         _body: ast::mac_body, clauses: [@clause]) -> @expr {\n+                         _body: ast::mac_body,\n+                         clauses: [@clause]/~) -> @expr {\n         let arg = alt arg {\n           some(arg) { arg }\n           none { cx.span_fatal(sp, \"macro must have arguments\")}"}, {"sha": "d1ee7a16a47f1e83a0fdbf5e7fb88a57ff9fcadc", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -41,7 +41,7 @@ iface ast_fold {\n     fn fold_ident(&&ident) -> ident;\n     fn fold_path(&&@path) -> @path;\n     fn fold_local(&&@local) -> @local;\n-    fn map_exprs(fn@(&&@expr) -> @expr, [@expr]) -> [@expr];\n+    fn map_exprs(fn@(&&@expr) -> @expr, [@expr]/~) -> [@expr]/~;\n     fn new_id(node_id) -> node_id;\n     fn new_span(span) -> span;\n }\n@@ -75,7 +75,7 @@ type ast_fold_precursor = @{\n     fold_ident: fn@(&&ident, ast_fold) -> ident,\n     fold_path: fn@(path, ast_fold) -> path,\n     fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n-    map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n+    map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]/~) -> [@expr]/~,\n     new_id: fn@(node_id) -> node_id,\n     new_span: fn@(span) -> span};\n \n@@ -151,7 +151,7 @@ fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n      bounds: @vec::map(*tp.bounds, {|x|fold_ty_param_bound(x, fld)})}\n }\n \n-fn fold_ty_params(tps: [ty_param], fld: ast_fold) -> [ty_param] {\n+fn fold_ty_params(tps: [ty_param]/~, fld: ast_fold) -> [ty_param]/~ {\n     vec::map(tps, {|x|fold_ty_param(x, fld)})\n }\n \n@@ -335,10 +335,11 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n                        {|pats| vec::map(pats, fld.fold_pat)})\n           }\n           pat_rec(fields, etc) {\n-            let mut fs = [];\n+            let mut fs = []/~;\n             for fields.each {|f|\n-                fs += [{ident: /* FIXME (#2543) */ copy f.ident,\n-                        pat: fld.fold_pat(f.pat)}];\n+                vec::push(fs,\n+                          {ident: /* FIXME (#2543) */ copy f.ident,\n+                           pat: fld.fold_pat(f.pat)});\n             }\n             pat_rec(fs, etc)\n           }\n@@ -570,7 +571,7 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n-fn noop_map_exprs(f: fn@(&&@expr) -> @expr, es: [@expr]) -> [@expr] {\n+fn noop_map_exprs(f: fn@(&&@expr) -> @expr, es: [@expr]/~) -> [@expr]/~ {\n     ret vec::map(es, f);\n }\n \n@@ -717,7 +718,7 @@ impl of ast_fold for ast_fold_precursor {\n         let (n, s) = self.fold_local(x.node, x.span, self as ast_fold);\n         ret @{node: n, span: self.new_span(s)};\n     }\n-    fn map_exprs(f: fn@(&&@expr) -> @expr, e: [@expr]) -> [@expr] {\n+    fn map_exprs(f: fn@(&&@expr) -> @expr, e: [@expr]/~) -> [@expr]/~ {\n         self.map_exprs(f, e)\n     }\n     fn new_id(node_id: ast::node_id) -> node_id {"}, {"sha": "2e309f2bd1496a514e6c46a747f7b704abe718e9", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -119,7 +119,8 @@ fn parse_expr_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n }\n \n fn parse_item_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n-                              +attrs: [ast::attribute], vis: ast::visibility,\n+                              +attrs: [ast::attribute]/~,\n+                              vis: ast::visibility,\n                               sess: parse_sess) -> option<@ast::item> {\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n@@ -197,7 +198,7 @@ fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, +path: str,\n }\n \n fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,\n-                      tt: [ast::token_tree]) -> parser {\n+                      tt: [ast::token_tree]/~) -> parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, sess.interner, tt);\n     ret parser(sess, cfg, trdr as reader, parser::SOURCE_FILE)\n }"}, {"sha": "4d78bcdc0a9e2f13165943547ae35c4e4e5adce9", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -7,11 +7,11 @@ export parser_attr;\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n-type attr_or_ext = option<either<[ast::attribute], @ast::expr>>;\n+type attr_or_ext = option<either<[ast::attribute]/~, @ast::expr>>;\n \n impl parser_attr for parser {\n \n-    fn parse_outer_attrs_or_ext(first_item_attrs: [ast::attribute])\n+    fn parse_outer_attrs_or_ext(first_item_attrs: [ast::attribute]/~)\n         -> attr_or_ext\n     {\n         let expect_item_next = vec::is_not_empty(first_item_attrs);\n@@ -21,7 +21,8 @@ impl parser_attr for parser {\n                 self.bump();\n                 let first_attr =\n                     self.parse_attribute_naked(ast::attr_outer, lo);\n-                ret some(left([first_attr] + self.parse_outer_attributes()));\n+                ret some(left([first_attr]/~ +\n+                              self.parse_outer_attributes()));\n             } else if !(self.look_ahead(1u) == token::LT\n                         || self.look_ahead(1u) == token::LBRACKET\n                         || self.look_ahead(1u) == token::POUND\n@@ -33,11 +34,11 @@ impl parser_attr for parser {\n     }\n \n     // Parse attributes that appear before an item\n-    fn parse_outer_attributes() -> [ast::attribute] {\n-        let mut attrs: [ast::attribute] = [];\n+    fn parse_outer_attributes() -> [ast::attribute]/~ {\n+        let mut attrs: [ast::attribute]/~ = []/~;\n         while self.token == token::POUND\n             && self.look_ahead(1u) == token::LBRACKET {\n-            attrs += [self.parse_attribute(ast::attr_outer)];\n+            attrs += [self.parse_attribute(ast::attr_outer)]/~;\n         }\n         ret attrs;\n     }\n@@ -64,9 +65,9 @@ impl parser_attr for parser {\n     // is an inner attribute of the containing item or an outer attribute of\n     // the first contained item until we see the semi).\n     fn parse_inner_attrs_and_next() ->\n-        {inner: [ast::attribute], next: [ast::attribute]} {\n-        let mut inner_attrs: [ast::attribute] = [];\n-        let mut next_outer_attrs: [ast::attribute] = [];\n+        {inner: [ast::attribute]/~, next: [ast::attribute]/~} {\n+        let mut inner_attrs: [ast::attribute]/~ = []/~;\n+        let mut next_outer_attrs: [ast::attribute]/~ = []/~;\n         while self.token == token::POUND {\n             if self.look_ahead(1u) != token::LBRACKET {\n                 // This is an extension\n@@ -75,13 +76,13 @@ impl parser_attr for parser {\n             let attr = self.parse_attribute(ast::attr_inner);\n             if self.token == token::SEMI {\n                 self.bump();\n-                inner_attrs += [attr];\n+                inner_attrs += [attr]/~;\n             } else {\n                 // It's not really an inner attribute\n                 let outer_attr =\n                     spanned(attr.span.lo, attr.span.hi,\n                             {style: ast::attr_outer, value: attr.node.value});\n-                next_outer_attrs += [outer_attr];\n+                next_outer_attrs += [outer_attr]/~;\n                 break;\n             }\n         }\n@@ -110,15 +111,15 @@ impl parser_attr for parser {\n         }\n     }\n \n-    fn parse_meta_seq() -> [@ast::meta_item] {\n+    fn parse_meta_seq() -> [@ast::meta_item]/~ {\n         ret self.parse_seq(token::LPAREN, token::RPAREN,\n                            seq_sep_trailing_disallowed(token::COMMA),\n                            {|p| p.parse_meta_item()}).node;\n     }\n \n-    fn parse_optional_meta() -> [@ast::meta_item] {\n+    fn parse_optional_meta() -> [@ast::meta_item]/~ {\n         alt self.token { token::LPAREN { ret self.parse_meta_seq(); }\n-                         _ { ret []; } }\n+                         _ { ret []/~; } }\n     }\n }\n "}, {"sha": "2f10a30bd551dd6fb9f3253290f5962f681aabff", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -16,7 +16,7 @@ enum cmnt_style {\n     blank_line, // Just a manual blank line \"\\n\\n\", for layout\n }\n \n-type cmnt = {style: cmnt_style, lines: [str], pos: uint};\n+type cmnt = {style: cmnt_style, lines: [str]/~, pos: uint};\n \n fn read_to_eol(rdr: string_reader) -> str {\n     let mut val = \"\";\n@@ -41,14 +41,14 @@ fn consume_non_eol_whitespace(rdr: string_reader) {\n     }\n }\n \n-fn push_blank_line_comment(rdr: string_reader, &comments: [cmnt]) {\n+fn push_blank_line_comment(rdr: string_reader, &comments: [cmnt]/~) {\n     #debug(\">>> blank-line comment\");\n-    let v: [str] = [];\n-    comments += [{style: blank_line, lines: v, pos: rdr.chpos}];\n+    let v: [str]/~ = []/~;\n+    comments += [{style: blank_line, lines: v, pos: rdr.chpos}]/~;\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n-                                           &comments: [cmnt]) {\n+                                           &comments: [cmnt]/~) {\n     while is_whitespace(rdr.curr) && !is_eof(rdr) {\n         if rdr.col == 0u && rdr.curr == '\\n' {\n             push_blank_line_comment(rdr, comments);\n@@ -62,18 +62,18 @@ fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool) -> cmnt {\n     let p = rdr.chpos;\n     #debug(\"<<< shebang comment\");\n     ret {style: if code_to_the_left { trailing } else { isolated },\n-         lines: [read_one_line_comment(rdr)],\n+         lines: [read_one_line_comment(rdr)]/~,\n          pos: p};\n }\n \n fn read_line_comments(rdr: string_reader, code_to_the_left: bool) -> cmnt {\n     #debug(\">>> line comments\");\n     let p = rdr.chpos;\n-    let mut lines: [str] = [];\n+    let mut lines: [str]/~ = []/~;\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n         log(debug, line);\n-        lines += [line];\n+        lines += [line]/~;\n         consume_non_eol_whitespace(rdr);\n     }\n     #debug(\"<<< line comments\");\n@@ -88,7 +88,7 @@ fn all_whitespace(s: str, begin: uint, end: uint) -> bool {\n     ret true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(&lines: [str],\n+fn trim_whitespace_prefix_and_push_line(&lines: [str]/~,\n                                         s: str, col: uint) unsafe {\n     let mut s1;\n     let len = str::len(s);\n@@ -98,13 +98,13 @@ fn trim_whitespace_prefix_and_push_line(&lines: [str],\n         } else { s1 = \"\"; }\n     } else { s1 = s; }\n     log(debug, \"pushing line: \" + s1);\n-    lines += [s1];\n+    lines += [s1]/~;\n }\n \n fn read_block_comment(rdr: string_reader, code_to_the_left: bool) -> cmnt {\n     #debug(\">>> block comment\");\n     let p = rdr.chpos;\n-    let mut lines: [str] = [];\n+    let mut lines: [str]/~ = []/~;\n     let mut col: uint = rdr.col;\n     bump(rdr);\n     bump(rdr);\n@@ -153,14 +153,14 @@ fn peeking_at_comment(rdr: string_reader) -> bool {\n }\n \n fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n-                   &comments: [cmnt]) {\n+                   &comments: [cmnt]/~) {\n     #debug(\">>> consume comment\");\n     if rdr.curr == '/' && nextch(rdr) == '/' {\n-        comments += [read_line_comments(rdr, code_to_the_left)];\n+        comments += [read_line_comments(rdr, code_to_the_left)]/~;\n     } else if rdr.curr == '/' && nextch(rdr) == '*' {\n-        comments += [read_block_comment(rdr, code_to_the_left)];\n+        comments += [read_block_comment(rdr, code_to_the_left)]/~;\n     } else if rdr.curr == '#' && nextch(rdr) == '!' {\n-        comments += [read_shebang_comment(rdr, code_to_the_left)];\n+        comments += [read_shebang_comment(rdr, code_to_the_left)]/~;\n     } else { fail; }\n     #debug(\"<<< consume comment\");\n }\n@@ -170,7 +170,7 @@ type lit = {lit: str, pos: uint};\n fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n                                 path: str,\n                                 srdr: io::reader) ->\n-   {cmnts: [cmnt], lits: [lit]} {\n+   {cmnts: [cmnt]/~, lits: [lit]/~} {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = @interner::mk::<@str>(\n         {|x|str::hash(*x)},\n@@ -179,8 +179,8 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n     let rdr = lexer::new_low_level_string_reader\n         (span_diagnostic, codemap::new_filemap(path, src, 0u, 0u), itr);\n \n-    let mut comments: [cmnt] = [];\n-    let mut literals: [lit] = [];\n+    let mut comments: [cmnt]/~ = []/~;\n+    let mut literals: [lit]/~ = []/~;\n     let mut first_read: bool = true;\n     while !is_eof(rdr) {\n         loop {"}, {"sha": "8cc6f3d648448c3e0c21ac59d0373ce2a785bb9c", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -149,9 +149,9 @@ impl parser_common for parser {\n     }\n \n     fn parse_seq_to_before_gt<T: copy>(sep: option<token::token>,\n-                                       f: fn(parser) -> T) -> [T] {\n+                                       f: fn(parser) -> T) -> [T]/~ {\n         let mut first = true;\n-        let mut v = [];\n+        let mut v = []/~;\n         while self.token != token::GT\n             && self.token != token::BINOP(token::SHR) {\n             alt sep {\n@@ -166,15 +166,15 @@ impl parser_common for parser {\n     }\n \n     fn parse_seq_to_gt<T: copy>(sep: option<token::token>,\n-                                f: fn(parser) -> T) -> [T] {\n+                                f: fn(parser) -> T) -> [T]/~ {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n \n         ret v;\n     }\n \n     fn parse_seq_lt_gt<T: copy>(sep: option<token::token>,\n-                                f: fn(parser) -> T) -> spanned<[T]> {\n+                                f: fn(parser) -> T) -> spanned<[T]/~> {\n         let lo = self.span.lo;\n         self.expect(token::LT);\n         let result = self.parse_seq_to_before_gt::<T>(sep, f);\n@@ -184,17 +184,17 @@ impl parser_common for parser {\n     }\n \n     fn parse_seq_to_end<T: copy>(ket: token::token, sep: seq_sep,\n-                                 f: fn(parser) -> T) -> [T] {\n+                                 f: fn(parser) -> T) -> [T]/~ {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         ret val;\n     }\n \n \n     fn parse_seq_to_before_end<T: copy>(ket: token::token, sep: seq_sep,\n-                                        f: fn(parser) -> T) -> [T] {\n+                                        f: fn(parser) -> T) -> [T]/~ {\n         let mut first: bool = true;\n-        let mut v: [T] = [];\n+        let mut v: [T]/~ = []/~;\n         while self.token != ket {\n             alt sep.sep {\n               some(t) { if first { first = false; }\n@@ -207,8 +207,10 @@ impl parser_common for parser {\n         ret v;\n     }\n \n-    fn parse_unspanned_seq<T: copy>(bra: token::token, ket: token::token,\n-                                    sep: seq_sep, f: fn(parser) -> T) -> [T] {\n+    fn parse_unspanned_seq<T: copy>(bra: token::token,\n+                                    ket: token::token,\n+                                    sep: seq_sep,\n+                                    f: fn(parser) -> T) -> [T]/~ {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n         self.bump();\n@@ -218,7 +220,7 @@ impl parser_common for parser {\n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n     fn parse_seq<T: copy>(bra: token::token, ket: token::token, sep: seq_sep,\n-                          f: fn(parser) -> T) -> spanned<[T]> {\n+                          f: fn(parser) -> T) -> spanned<[T]/~> {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);"}, {"sha": "f1dd8d69cc1c37aac857d8775b45f13b96dc7dbd", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -7,24 +7,26 @@ type ctx =\n     @{sess: parse::parse_sess,\n       cfg: ast::crate_cfg};\n \n-fn eval_crate_directives(cx: ctx, cdirs: [@ast::crate_directive], prefix: str,\n-                         &view_items: [@ast::view_item],\n-                         &items: [@ast::item]) {\n+fn eval_crate_directives(cx: ctx,\n+                         cdirs: [@ast::crate_directive]/~,\n+                         prefix: str,\n+                         &view_items: [@ast::view_item]/~,\n+                         &items: [@ast::item]/~) {\n     for cdirs.each {|sub_cdir|\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }\n \n-fn eval_crate_directives_to_mod(cx: ctx, cdirs: [@ast::crate_directive],\n+fn eval_crate_directives_to_mod(cx: ctx, cdirs: [@ast::crate_directive]/~,\n                                 prefix: str, suffix: option<str>)\n-    -> (ast::_mod, [ast::attribute]) {\n+    -> (ast::_mod, [ast::attribute]/~) {\n     #debug(\"eval crate prefix: %s\", prefix);\n     #debug(\"eval crate suffix: %s\",\n            option::get_default(suffix, \"none\"));\n     let (cview_items, citems, cattrs)\n         = parse_companion_mod(cx, prefix, suffix);\n-    let mut view_items: [@ast::view_item] = [];\n-    let mut items: [@ast::item] = [];\n+    let mut view_items: [@ast::view_item]/~ = []/~;\n+    let mut items: [@ast::item]/~ = []/~;\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);\n     ret ({view_items: view_items + cview_items,\n           items: items + citems},\n@@ -42,7 +44,7 @@ We build the path to the companion mod by combining the prefix and the\n optional suffix then adding the .rs extension.\n */\n fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n-    -> ([@ast::view_item], [@ast::item], [ast::attribute]) {\n+    -> ([@ast::view_item]/~, [@ast::item]/~, [ast::attribute]/~) {\n \n     fn companion_file(+prefix: str, suffix: option<str>) -> str {\n         ret alt suffix {\n@@ -72,11 +74,11 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n         cx.sess.byte_pos = cx.sess.byte_pos + r0.pos;\n         ret (m0.view_items, m0.items, inner_attrs.inner);\n     } else {\n-        ret ([], [], []);\n+        ret ([]/~, []/~, []/~);\n     }\n }\n \n-fn cdir_path_opt(id: ast::ident, attrs: [ast::attribute]) -> @str {\n+fn cdir_path_opt(id: ast::ident, attrs: [ast::attribute]/~) -> @str {\n     alt ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n       some(d) {\n         ret d;\n@@ -86,8 +88,8 @@ fn cdir_path_opt(id: ast::ident, attrs: [ast::attribute]) -> @str {\n }\n \n fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n-                        &view_items: [@ast::view_item],\n-                        &items: [@ast::item]) {\n+                        &view_items: [@ast::view_item]/~,\n+                        &items: [@ast::item]/~) {\n     alt cdir.node {\n       ast::cdir_src_mod(id, attrs) {\n         let file_path = cdir_path_opt(@(*id + \".rs\"), attrs);\n@@ -108,7 +110,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         // Thread defids, chpos and byte_pos through the parsers\n         cx.sess.chpos = r0.chpos;\n         cx.sess.byte_pos = cx.sess.byte_pos + r0.pos;\n-        items += [i];\n+        items += [i]/~;\n       }\n       ast::cdir_dir_mod(id, cdirs, attrs) {\n         let path = cdir_path_opt(id, attrs);\n@@ -126,9 +128,9 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n               vis: ast::public,\n               span: cdir.span};\n         cx.sess.next_id += 1;\n-        items += [i];\n+        items += [i]/~;\n       }\n-      ast::cdir_view_item(vi) { view_items += [vi]; }\n+      ast::cdir_view_item(vi) { view_items += [vi]/~; }\n       ast::cdir_syntax(pth) { }\n     }\n }"}, {"sha": "8687e011635a8f1583ffcb2dd34d4434eb7bd721", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -26,7 +26,7 @@ enum tt_frame_up { /* to break a circularity */\n /* TODO: figure out how to have a uniquely linked stack, and change to `~` */\n #[doc = \"an unzipping of `token_tree`s\"]\n type tt_frame = @{\n-    readme: [ast::token_tree],\n+    readme: [ast::token_tree]/~,\n     mut idx: uint,\n     up: tt_frame_up\n };\n@@ -41,7 +41,7 @@ type tt_reader = @{\n };\n \n fn new_tt_reader(span_diagnostic: diagnostic::span_handler,\n-                 itr: @interner::interner<@str>, src: [ast::token_tree])\n+                 itr: @interner::interner<@str>, src: [ast::token_tree]/~)\n     -> tt_reader {\n     let r = @{span_diagnostic: span_diagnostic, interner: itr,\n               mut cur: @{readme: src, mut idx: 0u,"}, {"sha": "d0847a974b749def9fcc7aee2c5c21d887ad10ac", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 128, "deletions": 123, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -13,6 +13,7 @@ import common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n                 seq_sep_none, token_to_str};\n import common::*;//{parser_common};\n import dvec::{dvec, extensions};\n+import vec::{push};\n \n export file_type;\n export parser;\n@@ -51,10 +52,10 @@ enum pexpr {\n  */\n enum class_contents { ctor_decl(fn_decl, blk, codemap::span),\n                       dtor_decl(blk, codemap::span),\n-                      members([@class_member]) }\n+                      members([@class_member]/~) }\n \n type arg_or_capture_item = either<arg, capture_item>;\n-type item_info = (ident, item_, option<[attribute]>);\n+type item_info = (ident, item_, option<[attribute]/~>);\n \n class parser {\n     let sess: parse_sess;\n@@ -176,14 +177,14 @@ class parser {\n         // functions can't have constrained types. Not sure whether\n         // that would be desirable anyway. See bug for the story on\n         // constrained types.\n-        let constrs: [@constr] = [];\n+        let constrs: [@constr]/~ = []/~;\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ret {inputs: inputs, output: ret_ty,\n              purity: purity, cf: ret_style,\n              constraints: constrs};\n     }\n \n-    fn parse_ty_methods() -> [ty_method] {\n+    fn parse_ty_methods() -> [ty_method]/~ {\n         self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n                                  seq_sep_none()) { |p|\n             let attrs = p.parse_outer_attributes();\n@@ -215,7 +216,7 @@ class parser {\n \n     // if i is the jth ident in args, return j\n     // otherwise, fail\n-    fn ident_index(args: [arg], i: ident) -> uint {\n+    fn ident_index(args: [arg]/~, i: ident) -> uint {\n         let mut j = 0u;\n         for args.each {|a| if a.ident == i { ret j; } j += 1u; }\n         self.fatal(\"unbound variable `\" + *i + \"` in constraint arg\");\n@@ -235,7 +236,7 @@ class parser {\n         ret @{node: carg, span: sp};\n     }\n \n-    fn parse_constr_arg(args: [arg]) -> @constr_arg {\n+    fn parse_constr_arg(args: [arg]/~) -> @constr_arg {\n         let sp = self.span;\n         let mut carg = carg_base;\n         if self.token == token::BINOP(token::STAR) {\n@@ -247,7 +248,7 @@ class parser {\n         ret @{node: carg, span: sp};\n     }\n \n-    fn parse_ty_constr(fn_args: [arg]) -> @constr {\n+    fn parse_ty_constr(fn_args: [arg]/~) -> @constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n         let args = self.parse_unspanned_seq(\n@@ -261,7 +262,7 @@ class parser {\n     fn parse_constr_in_type() -> @ty_constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n-        let args: [@ty_constr_arg] = self.parse_unspanned_seq(\n+        let args: [@ty_constr_arg]/~ = self.parse_unspanned_seq(\n             token::LPAREN, token::RPAREN,\n             seq_sep_trailing_disallowed(token::COMMA),\n             {|p| p.parse_type_constr_arg()});\n@@ -272,17 +273,17 @@ class parser {\n \n \n     fn parse_constrs<T: copy>(pser: fn(parser) -> @constr_general<T>) ->\n-        [@constr_general<T>] {\n-        let mut constrs: [@constr_general<T>] = [];\n+        [@constr_general<T>]/~ {\n+        let mut constrs: [@constr_general<T>]/~ = []/~;\n         loop {\n             let constr = pser(self);\n-            constrs += [constr];\n+            constrs += [constr]/~;\n             if self.token == token::COMMA { self.bump(); }\n             else { ret constrs; }\n         };\n     }\n \n-    fn parse_type_constraints() -> [@ty_constr] {\n+    fn parse_type_constraints() -> [@ty_constr]/~ {\n         ret self.parse_constrs({|p| p.parse_constr_in_type()});\n     }\n \n@@ -359,10 +360,10 @@ class parser {\n                 self.bump();\n                 ty_nil\n             } else {\n-                let mut ts = [self.parse_ty(false)];\n+                let mut ts = [self.parse_ty(false)]/~;\n                 while self.token == token::COMMA {\n                     self.bump();\n-                    ts += [self.parse_ty(false)];\n+                    ts += [self.parse_ty(false)]/~;\n                 }\n                 let t = if vec::len(ts) == 1u { ts[0].node }\n                 else { ty_tup(ts) };\n@@ -583,22 +584,22 @@ class parser {\n \n         let lo = self.span.lo;\n         let global = self.eat(token::MOD_SEP);\n-        let mut ids = [];\n+        let mut ids = []/~;\n         loop {\n             let is_not_last =\n                 self.look_ahead(2u) != token::LT\n                 && self.look_ahead(1u) == token::MOD_SEP;\n \n             if is_not_last {\n-                ids += [parse_ident(self)];\n+                ids += [parse_ident(self)]/~;\n                 self.expect(token::MOD_SEP);\n             } else {\n-                ids += [parse_last_ident(self)];\n+                ids += [parse_last_ident(self)]/~;\n                 break;\n             }\n         }\n         @{span: mk_sp(lo, self.last_span.hi), global: global,\n-          idents: ids, rp: none, types: []}\n+          idents: ids, rp: none, types: []/~}\n     }\n \n     fn parse_value_path() -> @path {\n@@ -639,7 +640,7 @@ class parser {\n                 self.parse_seq_lt_gt(some(token::COMMA),\n                                      {|p| p.parse_ty(false)})\n             } else {\n-                {node: [], span: path.span}\n+                {node: []/~, span: path.span}\n             }\n         };\n \n@@ -715,9 +716,9 @@ class parser {\n                 let lit = @spanned(lo, hi, lit_nil);\n                 ret self.mk_pexpr(lo, hi, expr_lit(lit));\n             }\n-            let mut es = [self.parse_expr()];\n+            let mut es = [self.parse_expr()]/~;\n             while self.token == token::COMMA {\n-                self.bump(); es += [self.parse_expr()];\n+                self.bump(); es += [self.parse_expr()]/~;\n             }\n             hi = self.span.hi;\n             self.expect(token::RPAREN);\n@@ -733,7 +734,7 @@ class parser {\n             if self.is_keyword(\"mut\") ||\n                 is_plain_ident(self.token)\n                 && self.look_ahead(1u) == token::COLON {\n-                let mut fields = [self.parse_field(token::COLON)];\n+                let mut fields = [self.parse_field(token::COLON)]/~;\n                 let mut base = none;\n                 while self.token != token::RBRACE {\n                     // optional comma before \"with\"\n@@ -750,7 +751,7 @@ class parser {\n                         // record ends by an optional trailing comma\n                         break;\n                     }\n-                    fields += [self.parse_field(token::COLON)];\n+                    fields += [self.parse_field(token::COLON)]/~;\n                 }\n                 hi = self.span.hi;\n                 self.expect(token::RBRACE);\n@@ -997,7 +998,7 @@ class parser {\n                         self.expect(token::LT);\n                         self.parse_seq_to_gt(some(token::COMMA),\n                                              {|p| p.parse_ty(false)})\n-                    } else { [] };\n+                    } else { []/~ };\n                     e = self.mk_pexpr(lo, hi, expr_field(self.to_expr(e),\n                                                          self.get_str(i),\n                                                          tys));\n@@ -1027,13 +1028,13 @@ class parser {\n                 let blk = self.parse_fn_block_expr();\n                 alt e.node {\n                   expr_call(f, args, false) {\n-                    e = pexpr(@{node: expr_call(f, args + [blk], true)\n+                    e = pexpr(@{node: expr_call(f, args + [blk]/~, true)\n                                 with *self.to_expr(e)});\n                   }\n                   _ {\n                     e = self.mk_pexpr(lo, self.last_span.hi,\n                                       expr_call(self.to_expr(e),\n-                                                [blk], true));\n+                                                [blk]/~, true));\n                   }\n                 }\n               }\n@@ -1085,10 +1086,10 @@ class parser {\n         ret alt self.token {\n           token::LPAREN | token::LBRACE | token::LBRACKET {\n             let ket = flip(self.token);\n-            tt_delim([parse_tt_flat(self, true)] +\n+            tt_delim([parse_tt_flat(self, true)]/~ +\n                      self.parse_seq_to_before_end(ket, seq_sep_none(),\n                                                   {|p| p.parse_token_tree()})\n-                     + [parse_tt_flat(self, true)])\n+                     + [parse_tt_flat(self, true)]/~)\n           }\n           _ { parse_tt_flat(self, false) }\n         };\n@@ -1354,7 +1355,7 @@ class parser {\n             let b_arg = vec::last(args);\n             let last = self.mk_expr(b_arg.span.lo, b_arg.span.hi,\n                                     ctor(b_arg));\n-            @{node: expr_call(f, vec::init(args) + [last], true)\n+            @{node: expr_call(f, vec::init(args) + [last]/~, true)\n               with *call}\n           }\n           _ {\n@@ -1385,14 +1386,14 @@ class parser {\n         else { alt_exhaustive };\n         let discriminant = self.parse_expr();\n         self.expect(token::LBRACE);\n-        let mut arms: [arm] = [];\n+        let mut arms: [arm]/~ = []/~;\n         while self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = none;\n             if self.eat_keyword(\"if\") { guard = some(self.parse_expr()); }\n             if self.token == token::FAT_ARROW { self.bump(); }\n             let blk = self.parse_block();\n-            arms += [{pats: pats, guard: guard, body: blk}];\n+            arms += [{pats: pats, guard: guard, body: blk}]/~;\n         }\n         let mut hi = self.span.hi;\n         self.bump();\n@@ -1434,10 +1435,10 @@ class parser {\n         }\n     }\n \n-    fn parse_pats() -> [@pat] {\n-        let mut pats = [];\n+    fn parse_pats() -> [@pat]/~ {\n+        let mut pats = []/~;\n         loop {\n-            pats += [self.parse_pat()];\n+            pats += [self.parse_pat()]/~;\n             if self.token == token::BINOP(token::OR) { self.bump(); }\n             else { ret pats; }\n         };\n@@ -1463,7 +1464,7 @@ class parser {\n           }\n           token::LBRACE {\n             self.bump();\n-            let mut fields = [];\n+            let mut fields = []/~;\n             let mut etc = false;\n             let mut first = true;\n             while self.token != token::RBRACE {\n@@ -1498,7 +1499,7 @@ class parser {\n                                node: pat_ident(fieldpath, none),\n                                span: mk_sp(lo, hi)};\n                 }\n-                fields += [{ident: fieldname, pat: subpat}];\n+                fields += [{ident: fieldname, pat: subpat}]/~;\n             }\n             hi = self.span.hi;\n             self.bump();\n@@ -1513,10 +1514,10 @@ class parser {\n                 let expr = self.mk_expr(lo, hi, expr_lit(lit));\n                 pat = pat_lit(expr);\n             } else {\n-                let mut fields = [self.parse_pat()];\n+                let mut fields = [self.parse_pat()]/~;\n                 while self.token == token::COMMA {\n                     self.bump();\n-                    fields += [self.parse_pat()];\n+                    fields += [self.parse_pat()]/~;\n                 }\n                 if vec::len(fields) == 1u { self.expect(token::COMMA); }\n                 hi = self.span.hi;\n@@ -1548,7 +1549,7 @@ class parser {\n             } else {\n                 let enum_path = self.parse_path_with_tps(true);\n                 hi = enum_path.span.hi;\n-                let mut args: [@pat] = [];\n+                let mut args: [@pat]/~ = []/~;\n                 let mut star_pat = false;\n                 alt self.token {\n                   token::LPAREN {\n@@ -1604,9 +1605,9 @@ class parser {\n     fn parse_let() -> @decl {\n         let is_mutbl = self.eat_keyword(\"mut\");\n         let lo = self.span.lo;\n-        let mut locals = [self.parse_local(is_mutbl, true)];\n+        let mut locals = [self.parse_local(is_mutbl, true)]/~;\n         while self.eat(token::COMMA) {\n-            locals += [self.parse_local(is_mutbl, true)];\n+            locals += [self.parse_local(is_mutbl, true)]/~;\n         }\n         ret @spanned(lo, self.last_span.hi, decl_local(locals));\n     }\n@@ -1628,8 +1629,8 @@ class parser {\n               span: mk_sp(lo, self.last_span.hi)};\n     }\n \n-    fn parse_stmt(+first_item_attrs: [attribute]) -> @stmt {\n-        fn check_expected_item(p: parser, current_attrs: [attribute]) {\n+    fn parse_stmt(+first_item_attrs: [attribute]/~) -> @stmt {\n+        fn check_expected_item(p: parser, current_attrs: [attribute]/~) {\n             // If we have attributes then we should have an item\n             if vec::is_not_empty(current_attrs) {\n                 p.fatal(\"expected item\");\n@@ -1645,7 +1646,7 @@ class parser {\n         } else {\n             let mut item_attrs;\n             alt self.parse_outer_attrs_or_ext(first_item_attrs) {\n-              none { item_attrs = []; }\n+              none { item_attrs = []/~; }\n               some(left(attrs)) { item_attrs = attrs; }\n               some(right(ext)) {\n                 ret @spanned(lo, ext.span.hi, stmt_expr(ext, self.get_id()));\n@@ -1685,14 +1686,15 @@ class parser {\n         ret blk;\n     }\n \n-    fn parse_inner_attrs_and_block(parse_attrs: bool) -> ([attribute], blk) {\n+    fn parse_inner_attrs_and_block(parse_attrs: bool)\n+        -> ([attribute]/~, blk) {\n \n         fn maybe_parse_inner_attrs_and_next(p: parser, parse_attrs: bool) ->\n-            {inner: [attribute], next: [attribute]} {\n+            {inner: [attribute]/~, next: [attribute]/~} {\n             if parse_attrs {\n                 p.parse_inner_attrs_and_next()\n             } else {\n-                {inner: [], next: []}\n+                {inner: []/~, next: []/~}\n             }\n         }\n \n@@ -1727,12 +1729,12 @@ class parser {\n     // necessary, and this should take a qualifier.\n     // some blocks start with \"#{\"...\n     fn parse_block_tail(lo: uint, s: blk_check_mode) -> blk {\n-        self.parse_block_tail_(lo, s, [])\n+        self.parse_block_tail_(lo, s, []/~)\n     }\n \n     fn parse_block_tail_(lo: uint, s: blk_check_mode,\n-                         +first_item_attrs: [attribute]) -> blk {\n-        let mut stmts = [];\n+                         +first_item_attrs: [attribute]/~) -> blk {\n+        let mut stmts = []/~;\n         let mut expr = none;\n         let {attrs_remaining, view_items} =\n             self.parse_view(first_item_attrs, true);\n@@ -1749,13 +1751,14 @@ class parser {\n               }\n               _ {\n                 let stmt = self.parse_stmt(initial_attrs);\n-                initial_attrs = [];\n+                initial_attrs = []/~;\n                 alt stmt.node {\n                   stmt_expr(e, stmt_id) { // Expression without semicolon:\n                     alt self.token {\n                       token::SEMI {\n                         self.bump();\n-                        stmts += [@{node: stmt_semi(e, stmt_id) with *stmt}];\n+                        push(stmts,\n+                             @{node: stmt_semi(e, stmt_id) with *stmt});\n                       }\n                       token::RBRACE {\n                         expr = some(e);\n@@ -1766,13 +1769,13 @@ class parser {\n                                         but found '\"\n                                        + token_to_str(self.reader, t) + \"'\");\n                         }\n-                        stmts += [stmt];\n+                        stmts += [stmt]/~;\n                       }\n                     }\n                   }\n \n                   _ { // All other kinds of statements:\n-                    stmts += [stmt];\n+                    stmts += [stmt]/~;\n \n                     if classify::stmt_ends_with_semi(*stmt) {\n                         self.expect(token::SEMI);\n@@ -1790,30 +1793,32 @@ class parser {\n     }\n \n     fn parse_ty_param() -> ty_param {\n-        let mut bounds = [];\n+        let mut bounds = []/~;\n         let ident = self.parse_ident();\n         if self.eat(token::COLON) {\n             while self.token != token::COMMA && self.token != token::GT {\n-                if self.eat_keyword(\"send\") { bounds += [bound_send]; }\n-                else if self.eat_keyword(\"copy\") { bounds += [bound_copy]; }\n-                else if self.eat_keyword(\"const\") { bounds += [bound_const]; }\n-                else { bounds += [bound_iface(self.parse_ty(false))]; }\n+                if self.eat_keyword(\"send\") { push(bounds, bound_send); }\n+                else if self.eat_keyword(\"copy\") { push(bounds, bound_copy) }\n+                else if self.eat_keyword(\"const\") {\n+                    push(bounds, bound_const)\n+                }\n+                else { push(bounds, bound_iface(self.parse_ty(false))); }\n             }\n         }\n         ret {ident: ident, id: self.get_id(), bounds: @bounds};\n     }\n \n-    fn parse_ty_params() -> [ty_param] {\n+    fn parse_ty_params() -> [ty_param]/~ {\n         if self.eat(token::LT) {\n             self.parse_seq_to_gt(some(token::COMMA), {|p| p.parse_ty_param()})\n-        } else { [] }\n+        } else { []/~ }\n     }\n \n     fn parse_fn_decl(purity: purity,\n                      parse_arg_fn: fn(parser) -> arg_or_capture_item)\n         -> (fn_decl, capture_clause) {\n \n-        let args_or_capture_items: [arg_or_capture_item] =\n+        let args_or_capture_items: [arg_or_capture_item]/~ =\n             self.parse_unspanned_seq(\n                 token::LPAREN, token::RPAREN,\n                 seq_sep_trailing_disallowed(token::COMMA), parse_arg_fn);\n@@ -1824,7 +1829,7 @@ class parser {\n         // Use the args list to translate each bound variable\n         // mentioned in a constraint to an arg index.\n         // Seems weird to do this in the parser, but I'm not sure how else to.\n-        let mut constrs = [];\n+        let mut constrs = []/~;\n         if self.token == token::COLON {\n             self.bump();\n             constrs = self.parse_constrs({|p| p.parse_ty_constr(inputs) });\n@@ -1840,7 +1845,7 @@ class parser {\n     fn parse_fn_block_decl() -> (fn_decl, capture_clause) {\n         let inputs_captures = {\n             if self.eat(token::OROR) {\n-                []\n+                []/~\n             } else {\n                 self.parse_unspanned_seq(\n                     token::BINOP(token::OR), token::BINOP(token::OR),\n@@ -1857,19 +1862,19 @@ class parser {\n               output: output,\n               purity: impure_fn,\n               cf: return_val,\n-              constraints: []},\n+              constraints: []/~},\n              @either::rights(inputs_captures));\n     }\n \n-    fn parse_fn_header() -> {ident: ident, tps: [ty_param]} {\n+    fn parse_fn_header() -> {ident: ident, tps: [ty_param]/~} {\n         let id = self.parse_value_ident();\n         let ty_params = self.parse_ty_params();\n         ret {ident: id, tps: ty_params};\n     }\n \n     fn mk_item(lo: uint, hi: uint, +ident: ident,\n                +node: item_, vis: visibility,\n-               +attrs: [attribute]) -> @item {\n+               +attrs: [attribute]/~) -> @item {\n         ret @{ident: ident,\n               attrs: attrs,\n               id: self.get_id(),\n@@ -1922,9 +1927,9 @@ class parser {\n     }\n \n     // Parses three variants (with the region/type params always optional):\n-    //    impl /&<T: copy> of to_str for [T] { ... }\n-    //    impl name/&<T> of to_str for [T] { ... }\n-    //    impl name/&<T> for [T] { ... }\n+    //    impl /&<T: copy> of to_str for [T]/~ { ... }\n+    //    impl name/&<T> of to_str for [T]/~ { ... }\n+    //    impl name/&<T> for [T]/~ { ... }\n     fn parse_item_impl() -> item_info {\n         fn wrap_path(p: parser, pt: @path) -> @ty {\n             @{id: p.get_id(), node: ty_path(pt, p.get_id()), span: pt.span}\n@@ -1936,7 +1941,7 @@ class parser {\n                 (none, self.parse_region_param(), self.parse_ty_params())\n             }\n             else if self.is_keyword(\"of\") {\n-                (none, rp_none, [])\n+                (none, rp_none, []/~)\n             } else {\n                 let id = self.parse_ident();\n                 let rp = self.parse_region_param();\n@@ -1956,10 +1961,10 @@ class parser {\n         };\n         self.expect_keyword(\"for\");\n         let ty = self.parse_ty(false);\n-        let mut meths = [];\n+        let mut meths = []/~;\n         self.expect(token::LBRACE);\n         while !self.eat(token::RBRACE) {\n-            meths += [self.parse_method(public)];\n+            meths += [self.parse_method(public)]/~;\n         }\n         (ident, item_impl(tps, rp, ifce, ty, meths), none)\n     }\n@@ -1969,7 +1974,7 @@ class parser {\n     // the return type of the ctor function.\n     fn ident_to_path_tys(i: ident,\n                          rp: region_param,\n-                         typarams: [ty_param]) -> @path {\n+                         typarams: [ty_param]/~) -> @path {\n         let s = self.last_span;\n \n         // Hack.  But then, this whole function is in service of a hack.\n@@ -1978,7 +1983,7 @@ class parser {\n           rp_self { some(self.region_from_name(some(@\"self\"))) }\n         };\n \n-        @{span: s, global: false, idents: [i],\n+        @{span: s, global: false, idents: [i]/~,\n           rp: a_r,\n           types: vec::map(typarams, {|tp|\n               @{id: self.get_id(),\n@@ -1992,7 +1997,7 @@ class parser {\n           id: self.get_id()}\n     }\n \n-    fn parse_iface_ref_list() -> [@iface_ref] {\n+    fn parse_iface_ref_list() -> [@iface_ref]/~ {\n         self.parse_seq_to_before_end(\n             token::LBRACE, seq_sep_trailing_disallowed(token::COMMA),\n             {|p| p.parse_iface_ref()})\n@@ -2003,11 +2008,11 @@ class parser {\n         let rp = self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n         let class_path = self.ident_to_path_tys(class_name, rp, ty_params);\n-        let ifaces : [@iface_ref] = if self.eat(token::COLON)\n+        let ifaces : [@iface_ref]/~ = if self.eat(token::COLON)\n             { self.parse_iface_ref_list() }\n-        else { [] };\n+        else { []/~ };\n         self.expect(token::LBRACE);\n-        let mut ms: [@class_member] = [];\n+        let mut ms: [@class_member]/~ = []/~;\n         let ctor_id = self.get_id();\n         let mut the_ctor : option<(fn_decl, blk, codemap::span)> = none;\n         let mut the_dtor : option<(blk, codemap::span)> = none;\n@@ -2092,16 +2097,16 @@ class parser {\n         }\n         else if self.eat_keyword(\"priv\") {\n             self.expect(token::LBRACE);\n-            let mut results = [];\n+            let mut results = []/~;\n             while self.token != token::RBRACE {\n-                results += [self.parse_single_class_item(private)];\n+                results += [self.parse_single_class_item(private)]/~;\n             }\n             self.bump();\n             ret members(results);\n         }\n         else {\n             // Probably need to parse attrs\n-            ret members([self.parse_single_class_item(public)]);\n+            ret members([self.parse_single_class_item(public)]/~);\n         }\n     }\n \n@@ -2112,19 +2117,19 @@ class parser {\n     }\n \n     fn parse_mod_items(term: token::token,\n-                       +first_item_attrs: [attribute]) -> _mod {\n+                       +first_item_attrs: [attribute]/~) -> _mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n         let {attrs_remaining, view_items} =\n             self.parse_view(first_item_attrs, false);\n-        let mut items: [@item] = [];\n+        let mut items: [@item]/~ = []/~;\n         let mut first = true;\n         while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n             if first { attrs = attrs_remaining + attrs; first = false; }\n             #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n             let vis = self.parse_visibility(private);\n             alt self.parse_item(attrs, vis) {\n-              some(i) { items += [i]; }\n+              some(i) { items += [i]/~; }\n               _ {\n                 self.fatal(\"expected item but found '\" +\n                            token_to_str(self.reader, self.token) + \"'\");\n@@ -2160,7 +2165,7 @@ class parser {\n         (id, item_mod(m), some(inner_attrs.inner))\n     }\n \n-    fn parse_item_native_fn(+attrs: [attribute],\n+    fn parse_item_native_fn(+attrs: [attribute]/~,\n                             purity: purity) -> @native_item {\n         let lo = self.last_span.lo;\n         let t = self.parse_fn_header();\n@@ -2186,22 +2191,22 @@ class parser {\n         else { self.unexpected(); }\n     }\n \n-    fn parse_native_item(+attrs: [attribute]) ->\n+    fn parse_native_item(+attrs: [attribute]/~) ->\n         @native_item {\n         self.parse_item_native_fn(attrs, self.parse_fn_purity())\n     }\n \n-    fn parse_native_mod_items(+first_item_attrs: [attribute]) ->\n+    fn parse_native_mod_items(+first_item_attrs: [attribute]/~) ->\n         native_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n         let {attrs_remaining, view_items} =\n             self.parse_view(first_item_attrs, false);\n-        let mut items: [@native_item] = [];\n+        let mut items: [@native_item]/~ = []/~;\n         let mut initial_attrs = attrs_remaining;\n         while self.token != token::RBRACE {\n             let attrs = initial_attrs + self.parse_outer_attributes();\n-            initial_attrs = [];\n-            items += [self.parse_native_item(attrs)];\n+            initial_attrs = []/~;\n+            items += [self.parse_native_item(attrs)]/~;\n         }\n         ret {view_items: view_items,\n              items: items};\n@@ -2246,7 +2251,7 @@ class parser {\n         let id = self.parse_ident();\n         let rp = self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n-        let mut variants: [variant] = [];\n+        let mut variants: [variant]/~ = []/~;\n         // Newtype syntax\n         if self.token == token::EQ {\n             self.check_restricted_keywords_(*id);\n@@ -2256,12 +2261,12 @@ class parser {\n             let variant =\n                 spanned(ty.span.lo, ty.span.hi,\n                         {name: id,\n-                         attrs: [],\n-                         args: [{ty: ty, id: self.get_id()}],\n+                         attrs: []/~,\n+                         args: [{ty: ty, id: self.get_id()}]/~,\n                          id: self.get_id(),\n                          disr_expr: none,\n                          vis: public});\n-            ret (id, item_enum([variant], ty_params, rp), none);\n+            ret (id, item_enum([variant]/~, ty_params, rp), none);\n         }\n         self.expect(token::LBRACE);\n \n@@ -2272,15 +2277,15 @@ class parser {\n             let vlo = self.span.lo;\n             let vis = self.parse_visibility(default_vis);\n             let ident = self.parse_value_ident();\n-            let mut args = [], disr_expr = none;\n+            let mut args = []/~, disr_expr = none;\n             if self.token == token::LPAREN {\n                 all_nullary = false;\n                 let arg_tys = self.parse_unspanned_seq(\n                     token::LPAREN, token::RPAREN,\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     {|p| p.parse_ty(false)});\n                 for arg_tys.each {|ty|\n-                    args += [{ty: ty, id: self.get_id()}];\n+                    args += [{ty: ty, id: self.get_id()}]/~;\n                 }\n             } else if self.eat(token::EQ) {\n                 have_disr = true;\n@@ -2290,7 +2295,7 @@ class parser {\n             let vr = {name: ident, attrs: variant_attrs,\n                       args: args, id: self.get_id(),\n                       disr_expr: disr_expr, vis: vis};\n-            variants += [spanned(vlo, self.last_span.hi, vr)];\n+            variants += [spanned(vlo, self.last_span.hi, vr)]/~;\n \n             if !self.eat(token::COMMA) { break; }\n         }\n@@ -2333,7 +2338,7 @@ class parser {\n         }\n     }\n \n-    fn parse_item(+attrs: [attribute], vis: visibility)\n+    fn parse_item(+attrs: [attribute]/~, vis: visibility)\n         -> option<@item> {\n         let lo = self.span.lo;\n         let (ident, item_, extra_attrs) = if self.eat_keyword(\"const\") {\n@@ -2384,20 +2389,20 @@ class parser {\n     fn parse_view_path() -> @view_path {\n         let lo = self.span.lo;\n         let first_ident = self.parse_ident();\n-        let mut path = [first_ident];\n+        let mut path = [first_ident]/~;\n         #debug(\"parsed view_path: %s\", *first_ident);\n         alt self.token {\n           token::EQ {\n             // x = foo::bar\n             self.bump();\n-            path = [self.parse_ident()];\n+            path = [self.parse_ident()]/~;\n             while self.token == token::MOD_SEP {\n                 self.bump();\n                 let id = self.parse_ident();\n-                path += [id];\n+                path += [id]/~;\n             }\n             let path = @{span: mk_sp(lo, self.span.hi), global: false,\n-                         idents: path, rp: none, types: []};\n+                         idents: path, rp: none, types: []/~};\n             ret @spanned(lo, self.span.hi,\n                          view_path_simple(first_ident, path, self.get_id()));\n           }\n@@ -2411,7 +2416,7 @@ class parser {\n \n                   token::IDENT(i, _) {\n                     self.bump();\n-                    path += [self.get_str(i)];\n+                    path += [self.get_str(i)]/~;\n                   }\n \n                   // foo::bar::{a,b,c}\n@@ -2422,7 +2427,7 @@ class parser {\n                         {|p| p.parse_path_list_ident()});\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n-                                 rp: none, types: []};\n+                                 rp: none, types: []/~};\n                     ret @spanned(lo, self.span.hi,\n                                  view_path_list(path, idents, self.get_id()));\n                   }\n@@ -2432,7 +2437,7 @@ class parser {\n                     self.bump();\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n-                                 rp: none, types: []};\n+                                 rp: none, types: []/~};\n                     ret @spanned(lo, self.span.hi,\n                                  view_path_glob(path, self.get_id()));\n                   }\n@@ -2445,16 +2450,16 @@ class parser {\n         }\n         let last = path[vec::len(path) - 1u];\n         let path = @{span: mk_sp(lo, self.span.hi), global: false,\n-                     idents: path, rp: none, types: []};\n+                     idents: path, rp: none, types: []/~};\n         ret @spanned(lo, self.span.hi,\n                      view_path_simple(last, path, self.get_id()));\n     }\n \n-    fn parse_view_paths() -> [@view_path] {\n-        let mut vp = [self.parse_view_path()];\n+    fn parse_view_paths() -> [@view_path]/~ {\n+        let mut vp = [self.parse_view_path()]/~;\n         while self.token == token::COMMA {\n             self.bump();\n-            vp += [self.parse_view_path()];\n+            vp += [self.parse_view_path()]/~;\n         }\n         ret vp;\n     }\n@@ -2468,7 +2473,7 @@ class parser {\n             || self.token_is_keyword(\"export\", tok)\n     }\n \n-    fn parse_view_item(+attrs: [attribute]) -> @view_item {\n+    fn parse_view_item(+attrs: [attribute]/~) -> @view_item {\n         let lo = self.span.lo, vis = self.parse_visibility(private);\n         let node = if self.eat_keyword(\"use\") {\n             self.parse_use()\n@@ -2482,14 +2487,14 @@ class parser {\n           vis: vis, span: mk_sp(lo, self.last_span.hi)}\n     }\n \n-    fn parse_view(+first_item_attrs: [attribute],\n-                  only_imports: bool) -> {attrs_remaining: [attribute],\n-                                          view_items: [@view_item]} {\n+    fn parse_view(+first_item_attrs: [attribute]/~,\n+                  only_imports: bool) -> {attrs_remaining: [attribute]/~,\n+                                          view_items: [@view_item]/~} {\n         let mut attrs = first_item_attrs + self.parse_outer_attributes();\n-        let mut items = [];\n+        let mut items = []/~;\n         while if only_imports { self.is_keyword(\"import\") }\n         else { self.is_view_item() } {\n-            items += [self.parse_view_item(attrs)];\n+            items += [self.parse_view_item(attrs)]/~;\n             attrs = self.parse_outer_attributes();\n         }\n         {attrs_remaining: attrs, view_items: items}\n@@ -2502,7 +2507,7 @@ class parser {\n         let first_item_outer_attrs = crate_attrs.next;\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n         ret @spanned(lo, self.span.lo,\n-                     {directives: [],\n+                     {directives: []/~,\n                       module: m,\n                       attrs: crate_attrs.inner,\n                       config: self.cfg});\n@@ -2523,7 +2528,7 @@ class parser {\n     //\n     // Each directive imperatively extends its environment with 0 or more\n     // items.\n-    fn parse_crate_directive(first_outer_attr: [attribute]) ->\n+    fn parse_crate_directive(first_outer_attr: [attribute]/~) ->\n         crate_directive {\n \n         // Collect the next attributes\n@@ -2564,8 +2569,8 @@ class parser {\n     }\n \n     fn parse_crate_directives(term: token::token,\n-                              first_outer_attr: [attribute]) ->\n-        [@crate_directive] {\n+                              first_outer_attr: [attribute]/~) ->\n+        [@crate_directive]/~ {\n \n         // This is pretty ugly. If we have an outer attribute then we can't\n         // accept seeing the terminator next, so if we do see it then fail the\n@@ -2574,12 +2579,12 @@ class parser {\n             self.expect_keyword(\"mod\");\n         }\n \n-        let mut cdirs: [@crate_directive] = [];\n+        let mut cdirs: [@crate_directive]/~ = []/~;\n         let mut first_outer_attr = first_outer_attr;\n         while self.token != term {\n             let cdir = @self.parse_crate_directive(first_outer_attr);\n-            cdirs += [cdir];\n-            first_outer_attr = [];\n+            cdirs += [cdir]/~;\n+            first_outer_attr = []/~;\n         }\n         ret cdirs;\n     }"}, {"sha": "feffbd4020cf1a6f0f4aeff8b93261a657c2a6db", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -260,7 +260,7 @@ fn contextual_keyword_table() -> hashmap<str, ()> {\n         \"with\",\n         /* temp */\n         \"sep\", \"many\", \"at_least_one\", \"parse\"\n-    ];\n+    ]/~;\n     for keys.each {|word|\n         words.insert(word, ());\n     }\n@@ -298,7 +298,7 @@ fn restricted_keyword_table() -> hashmap<str, ()> {\n         \"true\", \"trait\", \"type\",\n         \"unchecked\", \"unsafe\",\n         \"while\"\n-    ];\n+    ]/~;\n     for keys.each {|word|\n         words.insert(word, ());\n     }"}, {"sha": "5f10fe0eb4761448a2acc1acfbb7c5595f34d2d8", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -71,7 +71,7 @@ fn tok_str(++t: token) -> str {\n     }\n }\n \n-fn buf_str(toks: [mut token], szs: [mut int], left: uint, right: uint,\n+fn buf_str(toks: [mut token]/~, szs: [mut int]/~, left: uint, right: uint,\n            lim: uint) -> str {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n@@ -100,9 +100,9 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     // fall behind.\n     let n: uint = 3u * linewidth;\n     #debug(\"mk_printer %u\", linewidth);\n-    let token: [mut token] = vec::to_mut(vec::from_elem(n, EOF));\n-    let size: [mut int] = vec::to_mut(vec::from_elem(n, 0));\n-    let scan_stack: [mut uint] = vec::to_mut(vec::from_elem(n, 0u));\n+    let token: [mut token]/~ = vec::to_mut(vec::from_elem(n, EOF));\n+    let size: [mut int]/~ = vec::to_mut(vec::from_elem(n, 0));\n+    let scan_stack: [mut uint]/~ = vec::to_mut(vec::from_elem(n, 0u));\n     @{out: out,\n       buf_len: n,\n       mut margin: linewidth as int,\n@@ -206,8 +206,8 @@ type printer = @{\n     mut space: int, // number of spaces left on line\n     mut left: uint, // index of left side of input stream\n     mut right: uint, // index of right side of input stream\n-    token: [mut token], // ring-buffr stream goes through\n-    size: [mut int], // ring-buffer of calculated sizes\n+    token: [mut token]/~, // ring-buffr stream goes through\n+    size: [mut int]/~, // ring-buffer of calculated sizes\n     mut left_total: int, // running size of stream \"...left\"\n     mut right_total: int, // running size of stream \"...right\"\n     // pseudo-stack, really a ring too. Holds the\n@@ -216,7 +216,7 @@ type printer = @{\n     // BEGIN (if there is any) on top of it. Stuff is flushed off the\n     // bottom as it becomes irrelevant due to the primary ring-buffer\n     // advancing.\n-    mut scan_stack: [mut uint],\n+    mut scan_stack: [mut uint]/~,\n     mut scan_stack_empty: bool, // top==bottom disambiguator\n     mut top: uint, // index of top of scan_stack\n     mut bottom: uint, // index of bottom of scan_stack\n@@ -231,7 +231,7 @@ impl printer for printer {\n     // be very careful with this!\n     fn replace_last_token(t: token) { self.token[self.right] = t; }\n     fn pretty_print(t: token) {\n-        #debug(\"pp [%u,%u]\", self.left, self.right);\n+        #debug(\"pp [%u,%u]/~\", self.left, self.right);\n         alt t {\n           EOF {\n             if !self.scan_stack_empty {\n@@ -248,17 +248,17 @@ impl printer for printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            #debug(\"pp BEGIN/buffer [%u,%u]\", self.left, self.right);\n+            #debug(\"pp BEGIN/buffer [%u,%u]/~\", self.left, self.right);\n             self.token[self.right] = t;\n             self.size[self.right] = -self.right_total;\n             self.scan_push(self.right);\n           }\n           END {\n             if self.scan_stack_empty {\n-                #debug(\"pp END/print [%u,%u]\", self.left, self.right);\n+                #debug(\"pp END/print [%u,%u]/~\", self.left, self.right);\n                 self.print(t, 0);\n             } else {\n-                #debug(\"pp END/buffer [%u,%u]\", self.left, self.right);\n+                #debug(\"pp END/buffer [%u,%u]/~\", self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = -1;\n@@ -272,7 +272,7 @@ impl printer for printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            #debug(\"pp BREAK/buffer [%u,%u]\", self.left, self.right);\n+            #debug(\"pp BREAK/buffer [%u,%u]/~\", self.left, self.right);\n             self.check_stack(0);\n             self.scan_push(self.right);\n             self.token[self.right] = t;\n@@ -281,10 +281,10 @@ impl printer for printer {\n           }\n           STRING(s, len) {\n             if self.scan_stack_empty {\n-                #debug(\"pp STRING/print [%u,%u]\", self.left, self.right);\n+                #debug(\"pp STRING/print [%u,%u]/~\", self.left, self.right);\n                 self.print(t, len);\n             } else {\n-                #debug(\"pp STRING/buffer [%u,%u]\", self.left, self.right);\n+                #debug(\"pp STRING/buffer [%u,%u]/~\", self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = len;\n@@ -295,7 +295,7 @@ impl printer for printer {\n         }\n     }\n     fn check_stream() {\n-        #debug(\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n+        #debug(\"check_stream [%u, %u]/~ with left_total=%d, right_total=%d\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n             #debug(\"scan window is %d, longer than space on line (%d)\",\n@@ -347,7 +347,7 @@ impl printer for printer {\n         assert (self.right != self.left);\n     }\n     fn advance_left(++x: token, L: int) {\n-        #debug(\"advnce_left [%u,%u], sizeof(%u)=%d\", self.left, self.right,\n+        #debug(\"advnce_left [%u,%u]/~, sizeof(%u)=%d\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n             self.print(x, L);"}, {"sha": "0d3855b4f93c3c4ec5d613c0947e306430013aa3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -26,8 +26,8 @@ fn no_ann() -> pp_ann {\n type ps =\n     @{s: pp::printer,\n       cm: option<codemap>,\n-      comments: option<[comments::cmnt]>,\n-      literals: option<[comments::lit]>,\n+      comments: option<[comments::cmnt]/~>,\n+      literals: option<[comments::lit]/~>,\n       mut cur_cmnt: uint,\n       mut cur_lit: uint,\n       boxes: dvec<pp::breaks>,\n@@ -46,8 +46,8 @@ fn end(s: ps) {\n fn rust_printer(writer: io::writer) -> ps {\n     ret @{s: pp::mk_printer(writer, default_columns),\n           cm: none::<codemap>,\n-          comments: none::<[comments::cmnt]>,\n-          literals: none::<[comments::lit]>,\n+          comments: none::<[comments::cmnt]/~>,\n+          literals: none::<[comments::lit]/~>,\n           mut cur_cmnt: 0u,\n           mut cur_lit: 0u,\n           boxes: dvec(),\n@@ -97,7 +97,7 @@ fn item_to_str(i: @ast::item) -> str { ret to_str(i, print_item); }\n \n fn attr_to_str(i: ast::attribute) -> str { ret to_str(i, print_attribute); }\n \n-fn typarams_to_str(tps: [ast::ty_param]) -> str {\n+fn typarams_to_str(tps: [ast::ty_param]/~) -> str {\n     ret to_str(tps, print_type_params)\n }\n \n@@ -106,7 +106,7 @@ fn path_to_str(&&p: @ast::path) -> str {\n }\n \n fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n-              params: [ast::ty_param]) -> str {\n+              params: [ast::ty_param]/~) -> str {\n     let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer));\n     print_fn(s, decl, name, params);\n@@ -119,15 +119,15 @@ fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n #[test]\n fn test_fun_to_str() {\n     let decl: ast::fn_decl = {\n-        inputs: [],\n+        inputs: []/~,\n         output: @{id: 0,\n                   node: ast::ty_nil,\n                   span: ast_util::dummy_sp()},\n         purity: ast::impure_fn,\n         cf: ast::return_val,\n-        constraints: []\n+        constraints: []/~\n     };\n-    assert fun_to_str(decl, \"a\", []) == \"fn a()\";\n+    assert fun_to_str(decl, \"a\", []/~) == \"fn a()\";\n }\n \n fn block_to_str(blk: ast::blk) -> str {\n@@ -158,8 +158,8 @@ fn variant_to_str(var: ast::variant) -> str {\n fn test_variant_to_str() {\n     let var = ast_util::respan(ast_util::dummy_sp(), {\n         name: \"principle_skinner\",\n-        attrs: [],\n-        args: [],\n+        attrs: []/~,\n+        args: []/~,\n         id: 0,\n         disr_expr: none\n     });\n@@ -254,7 +254,7 @@ fn synth_comment(s: ps, text: str) {\n     word(s.s, \"*/\");\n }\n \n-fn commasep<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN)) {\n+fn commasep<IN>(s: ps, b: breaks, elts: [IN]/~, op: fn(ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each {|elt|\n@@ -265,7 +265,7 @@ fn commasep<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN)) {\n }\n \n \n-fn commasep_cmnt<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN),\n+fn commasep_cmnt<IN>(s: ps, b: breaks, elts: [IN]/~, op: fn(ps, IN),\n                      get_span: fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n@@ -284,20 +284,20 @@ fn commasep_cmnt<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN),\n     end(s);\n }\n \n-fn commasep_exprs(s: ps, b: breaks, exprs: [@ast::expr]) {\n+fn commasep_exprs(s: ps, b: breaks, exprs: [@ast::expr]/~) {\n     fn expr_span(&&expr: @ast::expr) -> codemap::span { ret expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-fn print_mod(s: ps, _mod: ast::_mod, attrs: [ast::attribute]) {\n+fn print_mod(s: ps, _mod: ast::_mod, attrs: [ast::attribute]/~) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.each {|vitem|\n         print_view_item(s, vitem);\n     }\n     for _mod.items.each {|item| print_item(s, item); }\n }\n \n-fn print_native_mod(s: ps, nmod: ast::native_mod, attrs: [ast::attribute]) {\n+fn print_native_mod(s: ps, nmod: ast::native_mod, attrs: [ast::attribute]/~) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.each {|vitem|\n         print_view_item(s, vitem);\n@@ -504,7 +504,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n           hardbreak_if_not_bol(s);\n           maybe_print_comment(s, ctor.span.lo);\n           head(s, \"new\");\n-          print_fn_args_and_ret(s, ctor.node.dec, []);\n+          print_fn_args_and_ret(s, ctor.node.dec, []/~);\n           space(s.s);\n           print_block(s, ctor.node.body);\n           option::iter(m_dtor) {|dtor|\n@@ -626,7 +626,7 @@ fn print_method(s: ps, meth: @ast::method) {\n     print_block_with_attrs(s, meth.body, meth.attrs);\n }\n \n-fn print_outer_attributes(s: ps, attrs: [ast::attribute]) {\n+fn print_outer_attributes(s: ps, attrs: [ast::attribute]/~) {\n     let mut count = 0;\n     for attrs.each {|attr|\n         alt attr.node.style {\n@@ -637,7 +637,7 @@ fn print_outer_attributes(s: ps, attrs: [ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-fn print_inner_attributes(s: ps, attrs: [ast::attribute]) {\n+fn print_inner_attributes(s: ps, attrs: [ast::attribute]/~) {\n     let mut count = 0;\n     for attrs.each {|attr|\n         alt attr.node.style {\n@@ -685,7 +685,7 @@ fn print_block(s: ps, blk: ast::blk) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n-fn print_block_with_attrs(s: ps, blk: ast::blk, attrs: [ast::attribute]) {\n+fn print_block_with_attrs(s: ps, blk: ast::blk, attrs: [ast::attribute]/~) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs);\n }\n \n@@ -694,11 +694,11 @@ enum embed_type { block_macro, block_block_fn, block_normal, }\n fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n                                  indented: uint) {\n     print_possibly_embedded_block_(\n-        s, blk, embedded, indented, []);\n+        s, blk, embedded, indented, []/~);\n }\n \n fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n-                                  indented: uint, attrs: [ast::attribute]) {\n+                                  indented: uint, attrs: [ast::attribute]/~) {\n     alt blk.node.rules {\n       ast::unchecked_blk { word(s.s, \"unchecked\"); }\n       ast::unsafe_blk { word(s.s, \"unsafe\"); }\n@@ -811,10 +811,10 @@ fn print_mac(s: ps, m: ast::mac) {\n \n fn print_vstore(s: ps, t: ast::vstore) {\n     alt t {\n-      ast::vstore_fixed(some(i)) { word_space(s, #fmt(\"/%u\", i)); }\n-      ast::vstore_fixed(none) { word_space(s, \"/_\"); }\n-      ast::vstore_uniq { word_space(s, \"/~\"); }\n-      ast::vstore_box { word_space(s, \"/@\"); }\n+      ast::vstore_fixed(some(i)) { word(s.s, #fmt(\"/%u\", i)); }\n+      ast::vstore_fixed(none) { word(s.s, \"/_\"); }\n+      ast::vstore_uniq { word(s.s, \"/~\"); }\n+      ast::vstore_box { word(s.s, \"/@\"); }\n       ast::vstore_slice(r) { word(s.s, \"/\"); print_region(s, r); }\n     }\n }\n@@ -1259,18 +1259,18 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n }\n \n fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n-            typarams: [ast::ty_param]) {\n+            typarams: [ast::ty_param]/~) {\n     alt decl.purity {\n       ast::impure_fn { head(s, \"fn\") }\n       _ { head(s, purity_to_str(decl.purity) + \" fn\") }\n     }\n     word(s.s, *name);\n     print_type_params(s, typarams);\n-    print_fn_args_and_ret(s, decl, []);\n+    print_fn_args_and_ret(s, decl, []/~);\n }\n \n fn print_fn_args(s: ps, decl: ast::fn_decl,\n-                 cap_items: [ast::capture_item]) {\n+                 cap_items: [ast::capture_item]/~) {\n     commasep(s, inconsistent, decl.inputs, print_arg);\n     if cap_items.is_not_empty() {\n         let mut first = decl.inputs.is_empty();\n@@ -1284,7 +1284,7 @@ fn print_fn_args(s: ps, decl: ast::fn_decl,\n }\n \n fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n-                         cap_items: [ast::capture_item]) {\n+                         cap_items: [ast::capture_item]/~) {\n     popen(s);\n     print_fn_args(s, decl, cap_items);\n     pclose(s);\n@@ -1301,7 +1301,7 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n }\n \n fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n-                       cap_items: [ast::capture_item]) {\n+                       cap_items: [ast::capture_item]/~) {\n     word(s.s, \"|\");\n     print_fn_args(s, decl, cap_items);\n     word(s.s, \"|\");\n@@ -1329,7 +1329,7 @@ fn print_arg_mode(s: ps, m: ast::mode) {\n     if ms != \"\" { word(s.s, ms); }\n }\n \n-fn print_bounds(s: ps, bounds: @[ast::ty_param_bound]) {\n+fn print_bounds(s: ps, bounds: @[ast::ty_param_bound]/~) {\n     if vec::len(*bounds) > 0u {\n         word(s.s, \":\");\n         for vec::each(*bounds) {|bound|\n@@ -1351,7 +1351,7 @@ fn print_region_param(s: ps, rp: ast::region_param) {\n     }\n }\n \n-fn print_type_params(s: ps, &&params: [ast::ty_param]) {\n+fn print_type_params(s: ps, &&params: [ast::ty_param]/~) {\n     if vec::len(params) > 0u {\n         word(s.s, \"<\");\n         fn printParam(s: ps, param: ast::ty_param) {\n@@ -1408,7 +1408,7 @@ fn print_view_path(s: ps, &&vp: @ast::view_path) {\n     }\n }\n \n-fn print_view_paths(s: ps, vps: [@ast::view_path]) {\n+fn print_view_paths(s: ps, vps: [@ast::view_path]/~) {\n     commasep(s, inconsistent, vps, print_view_path);\n }\n \n@@ -1480,7 +1480,7 @@ fn print_arg(s: ps, input: ast::arg) {\n \n fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n                decl: ast::fn_decl, id: option<ast::ident>,\n-               tps: option<[ast::ty_param]>) {\n+               tps: option<[ast::ty_param]/~>) {\n     ibox(s, indent_unit);\n     word(s.s, opt_proto_to_str(opt_proto));\n     alt id { some(id) { word(s.s, \" \"); word(s.s, *id); } _ { } }\n@@ -1682,7 +1682,8 @@ fn next_comment(s: ps) -> option<comments::cmnt> {\n     }\n }\n \n-fn constr_args_to_str<T>(f: fn@(T) -> str, args: [@ast::sp_constr_arg<T>]) ->\n+fn constr_args_to_str<T>(f: fn@(T) -> str,\n+                         args: [@ast::sp_constr_arg<T>]/~) ->\n    str {\n     let mut comma = false;\n     let mut s = \"(\";\n@@ -1727,7 +1728,7 @@ fn ty_constr_to_str(&&c: @ast::ty_constr) -> str {\n                                              c.node.args);\n }\n \n-fn constrs_str<T>(constrs: [T], elt: fn(T) -> str) -> str {\n+fn constrs_str<T>(constrs: [T]/~, elt: fn(T) -> str) -> str {\n     let mut s = \"\", colon = true;\n     for constrs.each {|c|\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }"}, {"sha": "6a07d7f62cac2def396c2c790f0e38fc84c2fad8", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -13,13 +13,13 @@ import codemap::span;\n enum vt<E> { mk_vt(visitor<E>), }\n \n enum fn_kind {\n-    fk_item_fn(ident, [ty_param]), //< an item declared with fn()\n-    fk_method(ident, [ty_param], @method),\n+    fk_item_fn(ident, [ty_param]/~), //< an item declared with fn()\n+    fk_method(ident, [ty_param]/~, @method),\n     fk_anon(proto, capture_clause),  //< an anonymous function like fn@(...)\n     fk_fn_block(capture_clause),     //< a block {||...}\n-    fk_ctor(ident, [ty_param], node_id /* self id */,\n+    fk_ctor(ident, [ty_param]/~, node_id /* self id */,\n             def_id /* parent class id */), // class constructor\n-    fk_dtor([ty_param], node_id /* self id */,\n+    fk_dtor([ty_param]/~, node_id /* self id */,\n             def_id /* parent class id */) // class destructor\n \n }\n@@ -33,13 +33,13 @@ fn name_of_fn(fk: fn_kind) -> ident {\n     }\n }\n \n-fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n+fn tps_of_fn(fk: fn_kind) -> [ty_param]/~ {\n     alt fk {\n       fk_item_fn(_, tps) | fk_method(_, tps, _)\n               | fk_ctor(_, tps, _, _) | fk_dtor(tps, _, _) {\n           /* FIXME (#2543) */ copy tps\n       }\n-      fk_anon(*) | fk_fn_block(*) { [] }\n+      fk_anon(*) | fk_fn_block(*) { []/~ }\n     }\n }\n \n@@ -58,7 +58,7 @@ type visitor<E> =\n       visit_decl: fn@(@decl, E, vt<E>),\n       visit_expr: fn@(@expr, E, vt<E>),\n       visit_ty: fn@(@ty, E, vt<E>),\n-      visit_ty_params: fn@([ty_param], E, vt<E>),\n+      visit_ty_params: fn@([ty_param]/~, E, vt<E>),\n       visit_constr: fn@(@path, span, node_id, E, vt<E>),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n       visit_class_item: fn@(@class_member, E, vt<E>)};\n@@ -256,7 +256,7 @@ fn visit_native_item<E>(ni: @native_item, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_ty_params<E>(tps: [ty_param], e: E, v: vt<E>) {\n+fn visit_ty_params<E>(tps: [ty_param]/~, e: E, v: vt<E>) {\n     for tps.each {|tp|\n         for vec::each(*tp.bounds) {|bound|\n             alt bound {\n@@ -286,7 +286,7 @@ fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n }\n \n // Similar logic to the comment on visit_method_helper - Tim\n-fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: [ty_param],\n+fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: [ty_param]/~,\n                               parent_id: def_id, e: E, v: vt<E>) {\n     v.visit_fn(fk_ctor(/* FIXME (#2543) */ copy nm,\n                        /* FIXME (#2543) */ copy tps,\n@@ -295,7 +295,7 @@ fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: [ty_param],\n \n }\n \n-fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: [ty_param],\n+fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: [ty_param]/~,\n                               parent_id: def_id, e: E, v: vt<E>) {\n     v.visit_fn(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.self_id,\n                        parent_id), ast_util::dtor_dec(),\n@@ -337,7 +337,7 @@ fn visit_expr_opt<E>(eo: option<@expr>, e: E, v: vt<E>) {\n     alt eo { none { } some(ex) { v.visit_expr(ex, e, v); } }\n }\n \n-fn visit_exprs<E>(exprs: [@expr], e: E, v: vt<E>) {\n+fn visit_exprs<E>(exprs: [@expr]/~, e: E, v: vt<E>) {\n     for exprs.each {|ex| v.visit_expr(ex, e, v); }\n }\n \n@@ -454,7 +454,7 @@ type simple_visitor =\n       visit_decl: fn@(@decl),\n       visit_expr: fn@(@expr),\n       visit_ty: fn@(@ty),\n-      visit_ty_params: fn@([ty_param]),\n+      visit_ty_params: fn@([ty_param]/~),\n       visit_constr: fn@(@path, span, node_id),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n       visit_class_item: fn@(@class_member)};\n@@ -474,7 +474,7 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_decl: fn@(_d: @decl) { },\n           visit_expr: fn@(_e: @expr) { },\n           visit_ty: simple_ignore_ty,\n-          visit_ty_params: fn@(_ps: [ty_param]) {},\n+          visit_ty_params: fn@(_ps: [ty_param]/~) {},\n           visit_constr: fn@(_p: @path, _sp: span, _id: node_id) { },\n           visit_fn: fn@(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n                         _id: node_id) { },\n@@ -533,7 +533,9 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n-    fn v_ty_params(f: fn@([ty_param]), ps: [ty_param], &&e: (), v: vt<()>) {\n+    fn v_ty_params(f: fn@([ty_param]/~),\n+                   ps: [ty_param]/~,\n+                   &&e: (), v: vt<()>) {\n         f(ps);\n         visit_ty_params(ps, e, v);\n     }"}, {"sha": "44c801fb6a548f44ccf5e6c83d2afa77cc8616ce", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -292,35 +292,35 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n     type provided_metas =\n         {name: option<@str>,\n          vers: option<@str>,\n-         cmh_items: [@ast::meta_item]};\n+         cmh_items: [@ast::meta_item]/~};\n \n     fn provided_link_metas(sess: session, c: ast::crate) ->\n        provided_metas {\n         let mut name: option<@str> = none;\n         let mut vers: option<@str> = none;\n-        let mut cmh_items: [@ast::meta_item] = [];\n+        let mut cmh_items: [@ast::meta_item]/~ = []/~;\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each {|meta|\n             if *attr::get_meta_item_name(meta) == \"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n-                  none { cmh_items += [meta]; }\n+                  none { cmh_items += [meta]/~; }\n                 }\n             } else if *attr::get_meta_item_name(meta) == \"vers\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { vers = some(v); }\n-                  none { cmh_items += [meta]; }\n+                  none { cmh_items += [meta]/~; }\n                 }\n-            } else { cmh_items += [meta]; }\n+            } else { cmh_items += [meta]/~; }\n         }\n         ret {name: name, vers: vers, cmh_items: cmh_items};\n     }\n \n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(sha: sha1, _crate: ast::crate,\n                               metas: provided_metas,\n-                              dep_hashes: [@str]) -> str {\n+                              dep_hashes: [@str]/~) -> str {\n         fn len_and_str(s: str) -> str {\n             ret #fmt[\"%u_%s\", str::len(s), s];\n         }\n@@ -490,7 +490,7 @@ fn mangle(ss: path) -> str {\n }\n \n fn exported_name(path: path, hash: @str, vers: @str) -> str {\n-    ret mangle(path + [path_name(hash)] + [path_name(vers)]);\n+    ret mangle(path + [path_name(hash)]/~ + [path_name(vers)]/~);\n }\n \n fn mangle_exported_name(ccx: @crate_ctxt, path: path, t: ty::t) -> str {\n@@ -503,12 +503,12 @@ fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n    str {\n     let s = @util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n-    ret mangle([path_name(name), path_name(s), path_name(@hash)]);\n+    ret mangle([path_name(name), path_name(s), path_name(@hash)]/~);\n }\n \n fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n                                         flav: @str) -> str {\n-    ret mangle(path + [path_name(@ccx.names(*flav))]);\n+    ret mangle(path + [path_name(@ccx.names(*flav))]/~);\n }\n \n fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: path) -> str {\n@@ -577,8 +577,8 @@ fn link_binary(sess: session,\n     // The invocations of cc share some flags across platforms\n \n     let mut cc_args =\n-        [stage] + sess.targ_cfg.target_strs.cc_args +\n-        [\"-o\", output, obj_filename];\n+        [stage]/~ + sess.targ_cfg.target_strs.cc_args +\n+        [\"-o\", output, obj_filename]/~;\n \n     let mut lib_cmd;\n     let os = sess.targ_cfg.os;\n@@ -591,18 +591,18 @@ fn link_binary(sess: session,\n     let cstore = sess.cstore;\n     for cstore::get_used_crate_files(cstore).each {|cratepath|\n         if str::ends_with(cratepath, \".rlib\") {\n-            cc_args += [cratepath];\n+            cc_args += [cratepath]/~;\n             cont;\n         }\n         let cratepath = cratepath;\n         let dir = path::dirname(cratepath);\n-        if dir != \"\" { cc_args += [\"-L\" + dir]; }\n+        if dir != \"\" { cc_args += [\"-L\" + dir]/~; }\n         let libarg = unlib(sess.targ_cfg, path::basename(cratepath));\n-        cc_args += [\"-l\" + libarg];\n+        cc_args += [\"-l\" + libarg]/~;\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each {|arg| cc_args += [arg]; }\n+    for ula.each {|arg| cc_args += [arg]/~; }\n \n     // # Native library linking\n \n@@ -613,37 +613,37 @@ fn link_binary(sess: session,\n     // forces to make sure that library can be found at runtime.\n \n     let addl_paths = sess.opts.addl_lib_search_paths;\n-    for addl_paths.each {|path| cc_args += [\"-L\" + path]; }\n+    for addl_paths.each {|path| cc_args += [\"-L\" + path]/~; }\n \n     // The names of the native libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.each {|l| cc_args += [\"-l\" + l]; }\n+    for used_libs.each {|l| cc_args += [\"-l\" + l]/~; }\n \n     if sess.building_library {\n-        cc_args += [lib_cmd];\n+        cc_args += [lib_cmd]/~;\n \n         // On mac we need to tell the linker to let this library\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n             cc_args += [\"-Wl,-install_name,@rpath/\"\n-                        + path::basename(output)];\n+                        + path::basename(output)]/~;\n         }\n     }\n \n     if !sess.debugging_opt(session::no_rt) {\n         // Always want the runtime linked in\n-        cc_args += [\"-lrustrt\"];\n+        cc_args += [\"-lrustrt\"]/~;\n     }\n \n     // On linux librt and libdl are an indirect dependencies via rustrt,\n     // and binutils 2.22+ won't add them automatically\n     if sess.targ_cfg.os == session::os_linux {\n-        cc_args += [\"-lrt\", \"-ldl\"];\n+        cc_args += [\"-lrt\", \"-ldl\"]/~;\n \n         // LLVM implements the `frem` instruction as a call to `fmod`,\n         // which lives in libm. Similar to above, on some linuxes we\n         // have to be explicit about linking to it. See #2510\n-        cc_args += [\"-lm\"];\n+        cc_args += [\"-lm\"]/~;\n     }\n \n     if sess.targ_cfg.os == session::os_freebsd {\n@@ -653,19 +653,19 @@ fn link_binary(sess: session,\n                     \"-L/usr/local/lib/gcc44\", \"-lstdc++\",\n                     \"-Wl,-z,origin\",\n                     \"-Wl,-rpath,/usr/local/lib/gcc46\",\n-                    \"-Wl,-rpath,/usr/local/lib/gcc44\"];\n+                    \"-Wl,-rpath,/usr/local/lib/gcc44\"]/~;\n     }\n \n     // OS X 10.6 introduced 'compact unwind info', which is produced by the\n     // linker from the dwarf unwind info. Unfortunately, it does not seem to\n     // understand how to unwind our __morestack frame, so we have to turn it\n     // off. This has impacted some other projects like GHC.\n     if sess.targ_cfg.os == session::os_macos {\n-        cc_args += [\"-Wl,-no_compact_unwind\"];\n+        cc_args += [\"-Wl,-no_compact_unwind\"]/~;\n     }\n \n     // Stack growth requires statically linking a __morestack function\n-    cc_args += [\"-lmorestack\"];\n+    cc_args += [\"-lmorestack\"]/~;\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to where\n     // native libraries might live, based on the addl_lib_search_paths\n@@ -685,7 +685,7 @@ fn link_binary(sess: session,\n \n     // Clean up on Darwin\n     if sess.targ_cfg.os == session::os_macos {\n-        run::run_program(\"dsymutil\", [output]);\n+        run::run_program(\"dsymutil\", [output]/~);\n     }\n \n     // Remove the temporary object file if we aren't saving temps"}, {"sha": "dbe70a8085fd847b27b1a98eb7920b0b3e03a786", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -13,12 +13,12 @@ pure fn not_win32(os: session::os) -> bool {\n   }\n }\n \n-fn get_rpath_flags(sess: session::session, out_filename: str) -> [str] {\n+fn get_rpath_flags(sess: session::session, out_filename: str) -> [str]/~ {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n     if os == session::os_win32 {\n-        ret [];\n+        ret []/~;\n     }\n \n     #debug(\"preparing the RPATH!\");\n@@ -29,28 +29,28 @@ fn get_rpath_flags(sess: session::session, out_filename: str) -> [str] {\n     let libs = cstore::get_used_crate_files(sess.cstore);\n     // We don't currently rpath native libraries, but we know\n     // where rustrt is and we know every rust program needs it\n-    let libs = libs + [get_sysroot_absolute_rt_lib(sess)];\n+    let libs = libs + [get_sysroot_absolute_rt_lib(sess)]/~;\n \n     let target_triple = sess.opts.target_triple;\n     let rpaths = get_rpaths(os, cwd, sysroot, output, libs, target_triple);\n     rpaths_to_flags(rpaths)\n }\n \n fn get_sysroot_absolute_rt_lib(sess: session::session) -> path::path {\n-    let path = [sess.filesearch.sysroot()]\n+    let path = [sess.filesearch.sysroot()]/~\n         + filesearch::relative_target_lib_path(\n             sess.opts.target_triple)\n-        + [os::dll_filename(\"rustrt\")];\n+        + [os::dll_filename(\"rustrt\")]/~;\n     path::connect_many(path)\n }\n \n-fn rpaths_to_flags(rpaths: [str]) -> [str] {\n+fn rpaths_to_flags(rpaths: [str]/~) -> [str]/~ {\n     vec::map(rpaths, { |rpath| #fmt(\"-Wl,-rpath,%s\",rpath)})\n }\n \n fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n-              output: path::path, libs: [path::path],\n-              target_triple: str) -> [str] {\n+              output: path::path, libs: [path::path]/~,\n+              target_triple: str) -> [str]/~ {\n     #debug(\"cwd: %s\", cwd);\n     #debug(\"sysroot: %s\", sysroot);\n     #debug(\"output: %s\", output);\n@@ -70,9 +70,9 @@ fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n     let abs_rpaths = get_absolute_rpaths(cwd, libs);\n \n     // And a final backup rpath to the global library location.\n-    let fallback_rpaths = [get_install_prefix_rpath(cwd, target_triple)];\n+    let fallback_rpaths = [get_install_prefix_rpath(cwd, target_triple)]/~;\n \n-    fn log_rpaths(desc: str, rpaths: [str]) {\n+    fn log_rpaths(desc: str, rpaths: [str]/~) {\n         #debug(\"%s rpaths:\", desc);\n         for rpaths.each {|rpath|\n             #debug(\"    %s\", rpath);\n@@ -93,7 +93,7 @@ fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n fn get_rpaths_relative_to_output(os: session::os,\n                                  cwd: path::path,\n                                  output: path::path,\n-                                 libs: [path::path]) -> [str] {\n+                                 libs: [path::path]/~) -> [str]/~ {\n     vec::map(libs, {|a|\n         check not_win32(os);\n         get_rpath_relative_to_output(os, cwd, output, a)\n@@ -139,8 +139,8 @@ fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n         start_idx += 1u;\n     }\n \n-    let mut path = [];\n-    for uint::range(start_idx, len1 - 1u) {|_i| path += [\"..\"]; };\n+    let mut path = []/~;\n+    for uint::range(start_idx, len1 - 1u) {|_i| vec::push(path, \"..\"); };\n \n     path += vec::slice(split2, start_idx, len2 - 1u);\n \n@@ -151,7 +151,7 @@ fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n     }\n }\n \n-fn get_absolute_rpaths(cwd: path::path, libs: [path::path]) -> [str] {\n+fn get_absolute_rpaths(cwd: path::path, libs: [path::path]/~) -> [str]/~ {\n     vec::map(libs, {|a|get_absolute_rpath(cwd, a)})\n }\n \n@@ -174,17 +174,17 @@ fn get_install_prefix_rpath(cwd: path::path, target_triple: str) -> str {\n         fail \"rustc compiled without CFG_PREFIX environment variable\";\n     }\n \n-    let path = [install_prefix]\n+    let path = [install_prefix]/~\n         + filesearch::relative_target_lib_path(target_triple);\n     get_absolute(cwd, path::connect_many(path))\n }\n \n-fn minimize_rpaths(rpaths: [str]) -> [str] {\n+fn minimize_rpaths(rpaths: [str]/~) -> [str]/~ {\n     let set = map::str_hash::<()>();\n-    let mut minimized = [];\n+    let mut minimized = []/~;\n     for rpaths.each {|rpath|\n         if !set.contains_key(rpath) {\n-            minimized += [rpath];\n+            minimized += [rpath]/~;\n             set.insert(rpath, ());\n         }\n     }\n@@ -195,8 +195,8 @@ fn minimize_rpaths(rpaths: [str]) -> [str] {\n mod test {\n     #[test]\n     fn test_rpaths_to_flags() {\n-        let flags = rpaths_to_flags([\"path1\", \"path2\"]);\n-        assert flags == [\"-Wl,-rpath,path1\", \"-Wl,-rpath,path2\"];\n+        let flags = rpaths_to_flags([\"path1\", \"path2\"]/~);\n+        assert flags == [\"-Wl,-rpath,path1\", \"-Wl,-rpath,path2\"]/~;\n     }\n \n     #[test]\n@@ -230,15 +230,15 @@ mod test {\n \n     #[test]\n     fn test_minimize1() {\n-        let res = minimize_rpaths([\"rpath1\", \"rpath2\", \"rpath1\"]);\n-        assert res == [\"rpath1\", \"rpath2\"];\n+        let res = minimize_rpaths([\"rpath1\", \"rpath2\", \"rpath1\"]/~);\n+        assert res == [\"rpath1\", \"rpath2\"]/~;\n     }\n \n     #[test]\n     fn test_minimize2() {\n         let res = minimize_rpaths([\"1a\", \"2\", \"2\", \"1a\", \"4a\",\n-                                   \"1a\", \"2\", \"3\", \"4a\", \"3\"]);\n-        assert res == [\"1a\", \"2\", \"4a\", \"3\"];\n+                                   \"1a\", \"2\", \"3\", \"4a\", \"3\"]/~);\n+        assert res == [\"1a\", \"2\", \"4a\", \"3\"]/~;\n     }\n \n     #[test]"}, {"sha": "24665c2ab36a978e51fef3bf6de3bcc6b4a5a95d", "filename": "src/rustc/back/target_strs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Ftarget_strs.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -3,5 +3,5 @@ type t = {\n     meta_sect_name: str,\n     data_layout: str,\n     target_triple: str,\n-    cc_args: [str]\n+    cc_args: [str]/~\n };"}, {"sha": "98dc3200b8945c308aa36cb90465abb95e29e598", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -33,10 +33,10 @@ fn declare_upcalls(targ_cfg: @session::config,\n                    tydesc_type: TypeRef,\n                    llmod: ModuleRef) -> @upcalls {\n     fn decl(llmod: ModuleRef, prefix: str, name: str,\n-            tys: [TypeRef], rv: TypeRef) ->\n+            tys: [TypeRef]/~, rv: TypeRef) ->\n        ValueRef {\n-        let mut arg_tys: [TypeRef] = [];\n-        for tys.each {|t| arg_tys += [t]; }\n+        let mut arg_tys: [TypeRef]/~ = []/~;\n+        for tys.each {|t| arg_tys += [t]/~; }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n     }\n@@ -51,61 +51,61 @@ fn declare_upcalls(targ_cfg: @session::config,\n \n     ret @{_fail: dv(\"fail\", [T_ptr(T_i8()),\n                              T_ptr(T_i8()),\n-                             size_t]),\n+                             size_t]/~),\n           trace: dv(\"trace\", [T_ptr(T_i8()),\n                               T_ptr(T_i8()),\n-                              int_t]),\n+                              int_t]/~),\n           malloc:\n               nothrow(d(\"malloc\",\n-                        [T_ptr(tydesc_type), int_t],\n+                        [T_ptr(tydesc_type), int_t]/~,\n                         T_ptr(T_i8()))),\n           free:\n-              nothrow(dv(\"free\", [T_ptr(T_i8())])),\n+              nothrow(dv(\"free\", [T_ptr(T_i8())]/~)),\n           exchange_malloc:\n               nothrow(d(\"exchange_malloc\",\n-                        [T_ptr(tydesc_type), int_t],\n+                        [T_ptr(tydesc_type), int_t]/~,\n                         T_ptr(T_i8()))),\n           exchange_free:\n-              nothrow(dv(\"exchange_free\", [T_ptr(T_i8())])),\n+              nothrow(dv(\"exchange_free\", [T_ptr(T_i8())]/~)),\n           validate_box:\n-              nothrow(dv(\"validate_box\", [T_ptr(T_i8())])),\n+              nothrow(dv(\"validate_box\", [T_ptr(T_i8())]/~)),\n           mark:\n-              d(\"mark\", [T_ptr(T_i8())], int_t),\n+              d(\"mark\", [T_ptr(T_i8())]/~, int_t),\n           vec_grow:\n-              nothrow(dv(\"vec_grow\", [T_ptr(T_ptr(T_i8())), int_t])),\n+              nothrow(dv(\"vec_grow\", [T_ptr(T_ptr(T_i8())), int_t]/~)),\n           str_new_uniq:\n-              nothrow(d(\"str_new_uniq\", [T_ptr(T_i8()), int_t],\n+              nothrow(d(\"str_new_uniq\", [T_ptr(T_i8()), int_t]/~,\n                         T_ptr(T_i8()))),\n           str_new_shared:\n-              nothrow(d(\"str_new_shared\", [T_ptr(T_i8()), int_t],\n+              nothrow(d(\"str_new_shared\", [T_ptr(T_i8()), int_t]/~,\n                         T_ptr(T_i8()))),\n           str_concat:\n               nothrow(d(\"str_concat\", [T_ptr(T_i8()),\n-                                       T_ptr(T_i8())],\n+                                       T_ptr(T_i8())]/~,\n                         T_ptr(T_i8()))),\n           cmp_type:\n               dv(\"cmp_type\",\n                  [T_ptr(T_i1()), T_ptr(tydesc_type),\n                   T_ptr(T_ptr(tydesc_type)), T_ptr(T_i8()),\n                   T_ptr(T_i8()),\n-                  T_i8()]),\n+                  T_i8()]/~),\n           log_type:\n               dv(\"log_type\", [T_ptr(tydesc_type),\n-                              T_ptr(T_i8()), T_i32()]),\n+                              T_ptr(T_i8()), T_i32()]/~),\n           alloc_c_stack:\n-              d(\"alloc_c_stack\", [size_t], T_ptr(T_i8())),\n+              d(\"alloc_c_stack\", [size_t]/~, T_ptr(T_i8())),\n           call_shim_on_c_stack:\n               d(\"call_shim_on_c_stack\",\n                 // arguments: void *args, void *fn_ptr\n-                [T_ptr(T_i8()), T_ptr(T_i8())],\n+                [T_ptr(T_i8()), T_ptr(T_i8())]/~,\n                 int_t),\n           call_shim_on_rust_stack:\n               d(\"call_shim_on_rust_stack\",\n-                [T_ptr(T_i8()), T_ptr(T_i8())], int_t),\n+                [T_ptr(T_i8()), T_ptr(T_i8())]/~, int_t),\n           rust_personality:\n-              nothrow(d(\"rust_personality\", [], T_i32())),\n+              nothrow(d(\"rust_personality\", []/~, T_i32())),\n           reset_stack_limit:\n-              nothrow(dv(\"reset_stack_limit\", []))\n+              nothrow(dv(\"reset_stack_limit\", []/~))\n          };\n }\n //"}, {"sha": "df68aee37e53c89627dcfb8c6d940ab6acf6dd5d", "filename": "src/rustc/back/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -35,7 +35,7 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n           session::os_freebsd { \"i686-unknown-freebsd\" }\n         },\n \n-        cc_args: [\"-m32\"]\n+        cc_args: [\"-m32\"]/~\n     };\n }\n "}, {"sha": "6936b3cec7d4e634fa86d7d1060bc4006dca6e0c", "filename": "src/rustc/back/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86_64.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -42,7 +42,7 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n           session::os_freebsd { \"x86_64-unknown-freebsd\" }\n         },\n \n-        cc_args: [\"-m64\"]\n+        cc_args: [\"-m64\"]/~\n     };\n }\n "}, {"sha": "13c0035011ceebc0f0e90ed37cfa0ee672670b12", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -56,7 +56,7 @@ fn default_configuration(sess: session, argv0: str, input: input) ->\n          mk(@\"target_libc\", libc),\n          // Build bindings.\n          mk(@\"build_compiler\", argv0),\n-         mk(@\"build_input\", source_name(input))];\n+         mk(@\"build_input\", source_name(input))]/~;\n }\n \n fn build_configuration(sess: session, argv0: str, input: input) ->\n@@ -70,19 +70,19 @@ fn build_configuration(sess: session, argv0: str, input: input) ->\n         {\n             if sess.opts.test && !attr::contains_name(user_cfg, \"test\")\n                {\n-                [attr::mk_word_item(@\"test\")]\n-            } else { [] }\n+                [attr::mk_word_item(@\"test\")]/~\n+            } else { []/~ }\n         };\n     ret user_cfg + gen_cfg + default_cfg;\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: [str]) -> ast::crate_cfg {\n+fn parse_cfgspecs(cfgspecs: [str]/~) -> ast::crate_cfg {\n     // FIXME (#2399): It would be nice to use the parser to parse all\n     // varieties of meta_item here. At the moment we just support the\n     // meta_word variant.\n-    let mut words = [];\n-    for cfgspecs.each {|s| words += [attr::mk_word_item(@s)]; }\n+    let mut words = []/~;\n+    for cfgspecs.each {|s| vec::push(words, attr::mk_word_item(@s)); }\n     ret words;\n }\n \n@@ -563,7 +563,7 @@ fn parse_pretty(sess: session, &&name: str) -> pp_mode {\n                    \"`identified`\");\n }\n \n-fn opts() -> [getopts::opt] {\n+fn opts() -> [getopts::opt]/~ {\n     ret [optflag(\"h\"), optflag(\"help\"), optflag(\"v\"), optflag(\"version\"),\n          optflag(\"emit-llvm\"), optflagopt(\"pretty\"),\n          optflag(\"ls\"), optflag(\"parse-only\"), optflag(\"no-trans\"),\n@@ -577,7 +577,7 @@ fn opts() -> [getopts::opt] {\n          optmulti(\"Z\"),\n \n          optmulti(\"cfg\"), optflag(\"test\"),\n-         optflag(\"lib\"), optflag(\"bin\"), optflag(\"static\"), optflag(\"gc\")];\n+         optflag(\"lib\"), optflag(\"bin\"), optflag(\"static\"), optflag(\"gc\")]/~;\n }\n \n type output_filenames = @{out_filename: str, obj_filename:str};\n@@ -692,7 +692,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let match =\n-            alt getopts::getopts([\"--test\"], opts()) {\n+            alt getopts::getopts([\"--test\"]/~, opts()) {\n               ok(m) { m }\n               err(f) { fail \"test_switch_implies_cfg_test: \" +\n                        getopts::fail_str(f); }\n@@ -708,7 +708,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let match =\n-            alt getopts::getopts([\"--test\", \"--cfg=test\"], opts()) {\n+            alt getopts::getopts([\"--test\", \"--cfg=test\"]/~, opts()) {\n               ok(m) { m }\n               err(f) { fail \"test_switch_implies_cfg_test_unless_cfg_test: \" +\n                        getopts::fail_str(f); }"}, {"sha": "1d99f3a7012e2b21b46e0f99c2531f0a2c8fbe79", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -109,7 +109,7 @@ fn describe_debug_flags() {\n     }\n }\n \n-fn run_compiler(args: [str], demitter: diagnostic::emitter) {\n+fn run_compiler(args: [str]/~, demitter: diagnostic::emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n     logging::console_off();\n \n@@ -250,7 +250,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n                      to get further details and report the results \\\n                      to github.com/mozilla/rust/issues\"\n \n-                ].each {|note|\n+                ]/~.each {|note|\n                     diagnostic::emit(none, note, diagnostic::note)\n                 }\n             }\n@@ -260,7 +260,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n     }\n }\n \n-fn main(args: [str]) {\n+fn main(args: [str]/~) {\n     monitor {|demitter|\n         run_compiler(args, demitter);\n     }"}, {"sha": "263343d63d71fcfbe5b5c33d0387e03d089ca235", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -36,7 +36,7 @@ const trace: uint = 128u;\n // It should be removed\n const no_rt: uint = 256u;\n \n-fn debugging_opts_map() -> [(str, str, uint)] {\n+fn debugging_opts_map() -> [(str, str, uint)]/~ {\n     [(\"ppregions\", \"prettyprint regions with \\\n                     internal repr details\", ppregions),\n      (\"time-passes\", \"measure time of each rustc pass\", time_passes),\n@@ -48,7 +48,7 @@ fn debugging_opts_map() -> [(str, str, uint)] {\n      (\"no-verify\", \"skip LLVM verification\", no_verify),\n      (\"trace\", \"emit trace logs\", trace),\n      (\"no-rt\", \"do not link to the runtime\", no_rt)\n-    ]\n+    ]/~\n }\n \n type options =\n@@ -59,10 +59,10 @@ type options =\n      optimize: uint,\n      debuginfo: bool,\n      extra_debuginfo: bool,\n-     lint_opts: [(lint::lint, lint::level)],\n+     lint_opts: [(lint::lint, lint::level)]/~,\n      save_temps: bool,\n      output_type: back::link::output_type,\n-     addl_lib_search_paths: [str],\n+     addl_lib_search_paths: [str]/~,\n      maybe_sysroot: option<str>,\n      target_triple: str,\n      cfg: ast::crate_cfg,\n@@ -72,7 +72,7 @@ type options =\n      debugging_opts: uint,\n     };\n \n-type crate_metadata = {name: str, data: [u8]};\n+type crate_metadata = {name: str, data: [u8]/~};\n \n type session = @{targ_cfg: @config,\n                  opts: @options,\n@@ -172,13 +172,13 @@ fn basic_options() -> @options {\n         optimize: 0u,\n         debuginfo: false,\n         extra_debuginfo: false,\n-        lint_opts: [],\n+        lint_opts: []/~,\n         save_temps: false,\n         output_type: link::output_type_exe,\n-        addl_lib_search_paths: [],\n+        addl_lib_search_paths: []/~,\n         maybe_sysroot: none,\n         target_triple: driver::host_triple(),\n-        cfg: [],\n+        cfg: []/~,\n         test: false,\n         parse_only: false,\n         no_trans: false,\n@@ -238,14 +238,14 @@ mod test {\n     }\n \n     fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n-        let mut attrs = [];\n-        if with_bin { attrs += [make_crate_type_attr(\"bin\")]; }\n-        if with_lib { attrs += [make_crate_type_attr(\"lib\")]; }\n+        let mut attrs = []/~;\n+        if with_bin { attrs += [make_crate_type_attr(\"bin\")]/~; }\n+        if with_lib { attrs += [make_crate_type_attr(\"lib\")]/~; }\n         @ast_util::respan(ast_util::dummy_sp(), {\n-            directives: [],\n-            module: {view_items: [], items: []},\n+            directives: []/~,\n+            module: {view_items: []/~, items: []/~},\n             attrs: attrs,\n-            config: []\n+            config: []/~\n         })\n     }\n "}, {"sha": "079e8fb71cb5ece07f84793604ab60ec6a45259a", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -4,7 +4,7 @@ export strip_unconfigured_items;\n export metas_in_cfg;\n export strip_items;\n \n-type in_cfg_pred = fn@([ast::attribute]) -> bool;\n+type in_cfg_pred = fn@([ast::attribute]/~) -> bool;\n \n type ctxt = @{\n     in_cfg: in_cfg_pred\n@@ -100,11 +100,11 @@ fn native_item_in_cfg(cx: ctxt, item: @ast::native_item) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: ast::crate_cfg, attrs: [ast::attribute]) -> bool {\n+fn in_cfg(cfg: ast::crate_cfg, attrs: [ast::attribute]/~) -> bool {\n     metas_in_cfg(cfg, attr::attr_metas(attrs))\n }\n \n-fn metas_in_cfg(cfg: ast::crate_cfg, metas: [@ast::meta_item]) -> bool {\n+fn metas_in_cfg(cfg: ast::crate_cfg, metas: [@ast::meta_item]/~) -> bool {\n \n     // The \"cfg\" attributes on the item\n     let cfg_metas = attr::find_meta_items_by_name(metas, \"cfg\");"}, {"sha": "c15f08e561f3d82c55a8db72a8b0f6366e0d9530", "filename": "src/rustc/front/core_inject.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fcore_inject.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -30,18 +30,18 @@ fn inject_libcore_ref(sess: session,\n     let n1 = sess.next_node_id();\n     let n2 = sess.next_node_id();\n \n-    let vi1 = @{node: ast::view_item_use(@\"core\", [], n1),\n-                attrs: [],\n+    let vi1 = @{node: ast::view_item_use(@\"core\", []/~, n1),\n+                attrs: []/~,\n                 vis: ast::public,\n                 span: dummy_sp()};\n     let vp = spanned(ast::view_path_glob(ident_to_path(dummy_sp(), @\"core\"),\n                                          n2));\n-    let vi2 = @{node: ast::view_item_import([vp]),\n-                attrs: [],\n+    let vi2 = @{node: ast::view_item_import([vp]/~),\n+                attrs: []/~,\n                 vis: ast::public,\n                 span: dummy_sp()};\n \n-    let vis = [vi1, vi2] + crate.node.module.view_items;\n+    let vis = [vi1, vi2]/~ + crate.node.module.view_items;\n \n     ret @{node: {module: { view_items: vis with crate.node.module }\n                  with crate.node} with *crate }"}, {"sha": "06f8bbe92c901bff9ee0c078608ada6de7061f86", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -12,7 +12,7 @@ fn inject_intrinsic(sess: session,\n     let item = parse::parse_item_from_source_str(\"<intrinsic>\",\n                                                  intrinsic_module,\n                                                  sess.opts.cfg,\n-                                                 [], ast::public,\n+                                                 []/~, ast::public,\n                                                  sess.parse_sess);\n     let item =\n         alt item {\n@@ -22,7 +22,7 @@ fn inject_intrinsic(sess: session,\n           }\n         };\n \n-    let items = [item] + crate.node.module.items;\n+    let items = [item]/~ + crate.node.module.items;\n \n     ret @{node: {module: { items: items with crate.node.module }\n                  with crate.node} with *crate }"}, {"sha": "d9240dc88779ae9f42dc6cf51a22d95deaa574a8", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -15,12 +15,13 @@ export modify_for_testing;\n \n type node_id_gen = fn@() -> ast::node_id;\n \n-type test = {span: span, path: [ast::ident], ignore: bool, should_fail: bool};\n+type test = {span: span, path: [ast::ident]/~,\n+             ignore: bool, should_fail: bool};\n \n type test_ctxt =\n     @{sess: session::session,\n       crate: @ast::crate,\n-      mut path: [ast::ident],\n+      mut path: [ast::ident]/~,\n       testfns: dvec<test>};\n \n // Traverse the crate, collecting all the test functions, eliding any\n@@ -40,7 +41,7 @@ fn generate_test_harness(sess: session::session,\n     let cx: test_ctxt =\n         @{sess: sess,\n           crate: crate,\n-          mut path: [],\n+          mut path: []/~,\n           testfns: dvec()};\n \n     let precursor =\n@@ -97,7 +98,7 @@ fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n    @ast::item {\n \n-    cx.path += [i.ident];\n+    cx.path += [i.ident]/~;\n     #debug(\"current path: %s\", ast_util::path_name_i(cx.path));\n \n     if is_test_fn(i) {\n@@ -160,7 +161,7 @@ fn should_fail(i: @ast::item) -> bool {\n \n fn add_test_module(cx: test_ctxt, m: ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n-    ret {items: m.items + [testmod] with m};\n+    ret {items: m.items + [testmod]/~ with m};\n }\n \n /*\n@@ -169,11 +170,11 @@ We're going to be building a module that looks more or less like:\n \n mod __test {\n \n-  fn main(args: [str]) -> int {\n+  fn main(args: [str]/~) -> int {\n     std::test::test_main(args, tests())\n   }\n \n-  fn tests() -> [std::test::test_desc] {\n+  fn tests() -> [std::test::test_desc]/~ {\n     ... the list of tests in the crate ...\n   }\n }\n@@ -187,14 +188,14 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     // The synthesized main function which will call the console test runner\n     // with our list of tests\n     let mainfn = mk_main(cx);\n-    let testmod: ast::_mod = {view_items: [], items: [mainfn, testsfn]};\n+    let testmod: ast::_mod = {view_items: []/~, items: [mainfn, testsfn]/~};\n     let item_ = ast::item_mod(testmod);\n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n         attr::mk_attr(attr::mk_word_item(@\"!resolve_unexported\"));\n     let item: ast::item =\n         {ident: @\"__test\",\n-         attrs: [resolve_unexported_attr],\n+         attrs: [resolve_unexported_attr]/~,\n          id: cx.sess.next_node_id(),\n          node: item_,\n          vis: ast::public,\n@@ -209,39 +210,39 @@ fn nospan<T: copy>(t: T) -> ast::spanned<T> {\n     ret {node: t, span: dummy_sp()};\n }\n \n-fn path_node(ids: [ast::ident]) -> @ast::path {\n-    @{span: dummy_sp(), global: false, idents: ids, rp: none, types: []}\n+fn path_node(ids: [ast::ident]/~) -> @ast::path {\n+    @{span: dummy_sp(), global: false, idents: ids, rp: none, types: []/~}\n }\n \n fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);\n \n     let decl: ast::fn_decl =\n-        {inputs: [],\n+        {inputs: []/~,\n          output: ret_ty,\n          purity: ast::impure_fn,\n          cf: ast::return_val,\n-         constraints: []};\n+         constraints: []/~};\n \n     // The vector of test_descs for this crate\n     let test_descs = mk_test_desc_vec(cx);\n \n     let body_: ast::blk_ =\n-        default_block([], option::some(test_descs), cx.sess.next_node_id());\n+        default_block([]/~, option::some(test_descs), cx.sess.next_node_id());\n     let body = nospan(body_);\n \n-    let item_ = ast::item_fn(decl, [], body);\n+    let item_ = ast::item_fn(decl, []/~, body);\n     let item: ast::item =\n         {ident: @\"tests\",\n-         attrs: [],\n+         attrs: []/~,\n          id: cx.sess.next_node_id(),\n          node: item_,\n          vis: ast::public,\n          span: dummy_sp()};\n     ret @item;\n }\n \n-fn mk_path(cx: test_ctxt, path: [ast::ident]) -> [ast::ident] {\n+fn mk_path(cx: test_ctxt, path: [ast::ident]/~) -> [ast::ident]/~ {\n     // For tests that are inside of std we don't want to prefix\n     // the paths with std::\n     let is_std = {\n@@ -251,12 +252,12 @@ fn mk_path(cx: test_ctxt, path: [ast::ident]) -> [ast::ident] {\n           _ { false }\n         }\n     };\n-    (if is_std { [] } else { [@\"std\"] }) + path\n+    (if is_std { []/~ } else { [@\"std\"]/~ }) + path\n }\n \n-// The ast::ty of [std::test::test_desc]\n+// The ast::ty of [std::test::test_desc]/~\n fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n-    let test_desc_ty_path = path_node(mk_path(cx, [@\"test\", @\"test_desc\"]));\n+    let test_desc_ty_path = path_node(mk_path(cx, [@\"test\", @\"test_desc\"]/~));\n \n     let test_desc_ty: ast::ty =\n         {id: cx.sess.next_node_id(),\n@@ -275,9 +276,9 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n \n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     #debug(\"building test vector from %u tests\", cx.testfns.len());\n-    let mut descs = [];\n+    let mut descs = []/~;\n     for cx.testfns.each {|test|\n-        descs += [mk_test_desc_rec(cx, test)];\n+        descs += [mk_test_desc_rec(cx, test)]/~;\n     }\n \n     let inner_expr = @{id: cx.sess.next_node_id(),\n@@ -337,7 +338,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n         nospan({mutbl: ast::m_imm, ident: @\"should_fail\", expr: @fail_expr});\n \n     let desc_rec_: ast::expr_ =\n-        ast::expr_rec([name_field, fn_field, ignore_field, fail_field],\n+        ast::expr_rec([name_field, fn_field, ignore_field, fail_field]/~,\n             option::none);\n     let desc_rec: ast::expr =\n         {id: cx.sess.next_node_id(), node: desc_rec_, span: span};\n@@ -352,24 +353,24 @@ fn mk_test_wrapper(cx: test_ctxt,\n                    span: span) -> @ast::expr {\n     let call_expr: ast::expr = {\n         id: cx.sess.next_node_id(),\n-        node: ast::expr_call(@fn_path_expr, [], false),\n+        node: ast::expr_call(@fn_path_expr, []/~, false),\n         span: span\n     };\n \n     let call_stmt: ast::stmt = nospan(\n         ast::stmt_semi(@call_expr, cx.sess.next_node_id()));\n \n     let wrapper_decl: ast::fn_decl = {\n-        inputs: [],\n+        inputs: []/~,\n         output: @{id: cx.sess.next_node_id(), node: ast::ty_nil, span: span},\n         purity: ast::impure_fn,\n         cf: ast::return_val,\n-        constraints: []\n+        constraints: []/~\n     };\n \n     let wrapper_body: ast::blk = nospan({\n-        view_items: [],\n-        stmts: [@call_stmt],\n+        view_items: []/~,\n+        stmts: [@call_stmt]/~,\n         expr: option::none,\n         id: cx.sess.next_node_id(),\n         rules: ast::default_blk\n@@ -378,15 +379,15 @@ fn mk_test_wrapper(cx: test_ctxt,\n     let wrapper_expr: ast::expr = {\n         id: cx.sess.next_node_id(),\n         node: ast::expr_fn(ast::proto_bare, wrapper_decl,\n-                           wrapper_body, @[]),\n+                           wrapper_body, @[]/~),\n         span: span\n     };\n \n     ret @wrapper_expr;\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n-    let str_pt = path_node([@\"str\"]);\n+    let str_pt = path_node([@\"str\"]/~);\n     let str_ty = @{id: cx.sess.next_node_id(),\n                    node: ast::ty_path(str_pt, cx.sess.next_node_id()),\n                    span: dummy_sp()};\n@@ -410,23 +411,23 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n                   span: dummy_sp()};\n \n     let decl: ast::fn_decl =\n-        {inputs: [args_arg],\n+        {inputs: [args_arg]/~,\n          output: @ret_ty,\n          purity: ast::impure_fn,\n          cf: ast::return_val,\n-         constraints: []};\n+         constraints: []/~};\n \n     let test_main_call_expr = mk_test_main_call(cx);\n \n     let body_: ast::blk_ =\n-        default_block([], option::some(test_main_call_expr),\n+        default_block([]/~, option::some(test_main_call_expr),\n                       cx.sess.next_node_id());\n     let body = {node: body_, span: dummy_sp()};\n \n-    let item_ = ast::item_fn(decl, [], body);\n+    let item_ = ast::item_fn(decl, []/~, body);\n     let item: ast::item =\n         {ident: @\"main\",\n-         attrs: [],\n+         attrs: []/~,\n          id: cx.sess.next_node_id(),\n          node: item_,\n          vis: ast::public,\n@@ -437,28 +438,28 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n \n     // Get the args passed to main so we can pass the to test_main\n-    let args_path = path_node([@\"args\"]);\n+    let args_path = path_node([@\"args\"]/~);\n \n     let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n     let args_path_expr: ast::expr =\n         {id: cx.sess.next_node_id(), node: args_path_expr_, span: dummy_sp()};\n \n     // Call __test::test to generate the vector of test_descs\n-    let test_path = path_node([@\"tests\"]);\n+    let test_path = path_node([@\"tests\"]/~);\n \n     let test_path_expr_: ast::expr_ = ast::expr_path(test_path);\n \n     let test_path_expr: ast::expr =\n         {id: cx.sess.next_node_id(), node: test_path_expr_, span: dummy_sp()};\n \n-    let test_call_expr_ = ast::expr_call(@test_path_expr, [], false);\n+    let test_call_expr_ = ast::expr_call(@test_path_expr, []/~, false);\n \n     let test_call_expr: ast::expr =\n         {id: cx.sess.next_node_id(), node: test_call_expr_, span: dummy_sp()};\n \n     // Call std::test::test_main\n-    let test_main_path = path_node(mk_path(cx, [@\"test\", @\"test_main\"]));\n+    let test_main_path = path_node(mk_path(cx, [@\"test\", @\"test_main\"]/~));\n \n     let test_main_path_expr_: ast::expr_ = ast::expr_path(test_main_path);\n \n@@ -468,7 +469,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n \n     let test_main_call_expr_: ast::expr_ =\n         ast::expr_call(@test_main_path_expr,\n-                       [@args_path_expr, @test_call_expr], false);\n+                       [@args_path_expr, @test_call_expr]/~, false);\n \n     let test_main_call_expr: ast::expr =\n         {id: cx.sess.next_node_id(), node: test_main_call_expr_,"}, {"sha": "e43f73697c74f393262daeccc7b0c34ada83f4fd", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -981,21 +981,22 @@ fn mk_type_names() -> type_names {\n }\n \n fn type_to_str(names: type_names, ty: TypeRef) -> str {\n-    ret type_to_str_inner(names, [], ty);\n+    ret type_to_str_inner(names, []/~, ty);\n }\n \n-fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n+fn type_to_str_inner(names: type_names, outer0: [TypeRef]/~, ty: TypeRef) ->\n    str {\n     alt type_has_name(names, ty) {\n       option::some(n) { ret n; }\n       _ {}\n     }\n \n-    let outer = outer0 + [ty];\n+    let outer = outer0 + [ty]/~;\n \n     let kind = llvm::LLVMGetTypeKind(ty);\n \n-    fn tys_str(names: type_names, outer: [TypeRef], tys: [TypeRef]) -> str {\n+    fn tys_str(names: type_names, outer: [TypeRef]/~,\n+               tys: [TypeRef]/~) -> str {\n         let mut s: str = \"\";\n         let mut first: bool = true;\n         for tys.each {|t|\n@@ -1021,7 +1022,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n         let mut s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n         let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n-        let args: [TypeRef] = vec::from_elem::<TypeRef>(n_args, 0 as TypeRef);\n+        let args = vec::from_elem(n_args, 0 as TypeRef);\n         unsafe {\n             llvm::LLVMGetParamTypes(ty, vec::unsafe::to_ptr(args));\n         }\n@@ -1033,7 +1034,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n       Struct {\n         let mut s: str = \"{\";\n         let n_elts = llvm::LLVMCountStructElementTypes(ty) as uint;\n-        let elts: [TypeRef] = vec::from_elem::<TypeRef>(n_elts, 0 as TypeRef);\n+        let elts = vec::from_elem(n_elts, 0 as TypeRef);\n         unsafe {\n             llvm::LLVMGetStructElementTypes(ty, vec::unsafe::to_ptr(elts));\n         }\n@@ -1082,7 +1083,7 @@ fn float_width(llt: TypeRef) -> uint {\n         };\n }\n \n-fn fn_ty_param_tys(fn_ty: TypeRef) -> [TypeRef] unsafe {\n+fn fn_ty_param_tys(fn_ty: TypeRef) -> [TypeRef]/~ unsafe {\n     let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n                              0 as TypeRef);\n     llvm::LLVMGetParamTypes(fn_ty, vec::unsafe::to_ptr(args));"}, {"sha": "391ab8bfda4eeda65dbb421030adaa9f63d1f5ce", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -68,7 +68,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n                        ii: ast::inlined_item) {\n     #debug[\"> Encoding inlined item: %s::%s (%u)\",\n            ast_map::path_to_str(path), ii.ident(),\n-           ebml_w.writer.tell()];\n+           ebml_w.writer.tell()]/~;\n \n     let id_range = compute_id_range_for_inlined_item(ii);\n     ebml_w.wr_tag(c::tag_ast as uint) {||\n@@ -79,7 +79,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n \n     #debug[\"< Encoded inlined fn: %s::%s (%u)\",\n            ast_map::path_to_str(path), ii.ident(),\n-           ebml_w.writer.tell()];\n+           ebml_w.writer.tell()]/~;\n }\n \n fn decode_inlined_item(cdata: cstore::crate_metadata,\n@@ -103,7 +103,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n         #debug[\"Fn named: %s\", ii.ident()];\n         decode_side_tables(xcx, ast_doc);\n         #debug[\"< Decoded inlined fn: %s::%s\",\n-               ast_map::path_to_str(path), ii.ident()];\n+               ast_map::path_to_str(path), ii.ident()]/~;\n         alt ii {\n           ast::ii_item(i) {\n             #debug(\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n@@ -522,7 +522,7 @@ impl helpers for ebml::writer {\n         e::write_type(ecx, self, ty)\n     }\n \n-    fn emit_tys(ecx: @e::encode_ctxt, tys: [ty::t]) {\n+    fn emit_tys(ecx: @e::encode_ctxt, tys: [ty::t]/~) {\n         self.emit_from_vec(tys) {|ty|\n             e::write_type(ecx, self, ty)\n         }\n@@ -707,7 +707,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n impl decoder for ebml::doc {\n     fn as_int() -> int { ebml::doc_as_u64(self) as int }\n-    fn [](tag: c::astencode_tag) -> ebml::doc {\n+    fn []/~(tag: c::astencode_tag) -> ebml::doc {\n         ebml::get_doc(self, tag as uint)\n     }\n     fn opt_child(tag: c::astencode_tag) -> option<ebml::doc> {\n@@ -727,11 +727,11 @@ impl decoder for ebml::ebml_deserializer {\n             xcx.tr_def_id(_))\n     }\n \n-    fn read_tys(xcx: extended_decode_ctxt) -> [ty::t] {\n+    fn read_tys(xcx: extended_decode_ctxt) -> [ty::t]/~ {\n         self.read_to_vec {|| self.read_ty(xcx) }\n     }\n \n-    fn read_bounds(xcx: extended_decode_ctxt) -> @[ty::param_bound] {\n+    fn read_bounds(xcx: extended_decode_ctxt) -> @[ty::param_bound]/~ {\n         tydecode::parse_bounds_data(\n             self.parent.data, self.pos, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n             xcx.tr_def_id(_))\n@@ -765,7 +765,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n \n         #debug[\">> Side table document with tag 0x%x \\\n                 found for id %d (orig %d)\",\n-               tag, id, id0];\n+               tag, id, id0]/~;\n \n         if tag == (c::tag_table_mutbl as uint) {\n             dcx.maps.mutbl_map.insert(id, ());\n@@ -859,7 +859,7 @@ type fake_session = ();\n \n #[cfg(test)]\n impl of fake_ext_ctxt for fake_session {\n-    fn cfg() -> ast::crate_cfg { [] }\n+    fn cfg() -> ast::crate_cfg { []/~ }\n     fn parse_sess() -> parse::parse_sess { new_parse_sess() }\n }\n \n@@ -922,13 +922,13 @@ fn test_simplification() {\n     let item_in = ast::ii_item(#ast(item) {\n         fn new_int_alist<B: copy>() -> alist<int, B> {\n             fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-            ret {eq_fn: eq_int, mut data: []};\n+            ret {eq_fn: eq_int, mut data: []/~};\n         }\n     });\n     let item_out = simplify_ast(item_in);\n     let item_exp = ast::ii_item(#ast(item) {\n         fn new_int_alist<B: copy>() -> alist<int, B> {\n-            ret {eq_fn: eq_int, mut data: []};\n+            ret {eq_fn: eq_int, mut data: []/~};\n         }\n     });\n     alt (item_out, item_exp) {"}, {"sha": "c9146135bca94f01d5c0140a02e6193ded5cf5a0", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -43,7 +43,7 @@ type cache_entry = {\n     cnum: int,\n     span: span,\n     hash: @str,\n-    metas: @[@ast::meta_item]\n+    metas: @[@ast::meta_item]/~\n };\n \n fn dump_crates(crate_cache: dvec<cache_entry>) {\n@@ -54,15 +54,15 @@ fn dump_crates(crate_cache: dvec<cache_entry>) {\n         #debug(\"hash: %?\", entry.hash);\n         let attrs = [\n             attr::mk_attr(attr::mk_list_item(@\"link\", *entry.metas))\n-        ];\n+        ]/~;\n         for attr::find_linkage_attrs(attrs).each {|attr|\n             #debug(\"meta: %s\", pprust::attr_to_str(attr));\n         }\n     }\n }\n \n fn warn_if_multiple_versions(diag: span_handler,\n-                             crate_cache: [cache_entry]) {\n+                             crate_cache: [cache_entry]/~) {\n     import either::*;\n \n     if crate_cache.len() != 0u {\n@@ -86,7 +86,7 @@ fn warn_if_multiple_versions(diag: span_handler,\n                 diag.span_note(match.span, \"used here\");\n                 let attrs = [\n                     attr::mk_attr(attr::mk_list_item(@\"link\", *match.metas))\n-                ];\n+                ]/~;\n                 loader::note_linkage_attrs(diag, attrs);\n             }\n         }\n@@ -161,21 +161,21 @@ fn visit_item(e: env, i: @ast::item) {\n }\n \n fn metas_with(ident: ast::ident, key: ast::ident,\n-                    metas: [@ast::meta_item]) -> [@ast::meta_item] {\n+                    metas: [@ast::meta_item]/~) -> [@ast::meta_item]/~ {\n     let name_items = attr::find_meta_items_by_name(metas, *key);\n     if name_items.is_empty() {\n-        metas + [attr::mk_name_value_item_str(key, *ident)]\n+        metas + [attr::mk_name_value_item_str(key, *ident)]/~\n     } else {\n         metas\n     }\n }\n \n fn metas_with_ident(ident: ast::ident,\n-                    metas: [@ast::meta_item]) -> [@ast::meta_item] {\n+                    metas: [@ast::meta_item]/~) -> [@ast::meta_item]/~ {\n     metas_with(ident, @\"name\", metas)\n }\n \n-fn existing_match(e: env, metas: [@ast::meta_item], hash: str) ->\n+fn existing_match(e: env, metas: [@ast::meta_item]/~, hash: str) ->\n     option<int> {\n \n     for e.crate_cache.each {|c|\n@@ -187,7 +187,7 @@ fn existing_match(e: env, metas: [@ast::meta_item], hash: str) ->\n     ret none;\n }\n \n-fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n+fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item]/~,\n                  hash: str, span: span) -> ast::crate_num {\n     let metas = metas_with_ident(ident, metas);\n \n@@ -241,15 +241,15 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: env, cdata: @[u8]) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: env, cdata: @[u8]/~) -> cstore::cnum_map {\n     #debug(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let cnum_map = int_hash::<ast::crate_num>();\n     for decoder::get_crate_deps(cdata).each {|dep|\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n-        let cmetas = metas_with(dep.vers, @\"vers\", []);\n+        let cmetas = metas_with(dep.vers, @\"vers\", []/~);\n         #debug(\"resolving dep crate %s ver: %s hash: %s\",\n                *dep.name, *dep.vers, *dep.hash);\n         alt existing_match(e, metas_with_ident(cname, cmetas), *dep.hash) {"}, {"sha": "f5d628622b2b68b2cce1aa93eda212a3915a0d65", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -39,12 +39,12 @@ fn get_type_param_count(cstore: cstore::cstore, def: ast::def_id) -> uint {\n }\n \n fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n-               path: [ast::ident]) -> [ast::def] {\n-    let mut result = [];\n+               path: [ast::ident]/~) -> [ast::def]/~ {\n+    let mut result = []/~;\n     #debug(\"lookup_defs: path = %? cnum = %?\", path, cnum);\n     for resolve_path(cstore, cnum, path).each {|elt|\n         let (c, data, def) = elt;\n-        result += [decoder::lookup_def(c, data, def)];\n+        result += [decoder::lookup_def(c, data, def)]/~;\n     }\n     ret result;\n }\n@@ -60,21 +60,21 @@ fn lookup_method_purity(cstore: cstore::cstore, did: ast::def_id)\n /* Returns a vector of possible def IDs for a given path,\n    in a given crate */\n fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n-                path: [ast::ident]) ->\n-    [(ast::crate_num, @[u8], ast::def_id)] {\n+                path: [ast::ident]/~) ->\n+    [(ast::crate_num, @[u8]/~, ast::def_id)]/~ {\n     let cm = cstore::get_crate_data(cstore, cnum);\n     #debug(\"resolve_path %s in crates[%d]:%s\",\n            ast_util::path_name_i(path), cnum, cm.name);\n-    let mut result = [];\n+    let mut result = []/~;\n     for decoder::resolve_path(path, cm.data).each {|def|\n         if def.crate == ast::local_crate {\n-            result += [(cnum, cm.data, def)];\n+            result += [(cnum, cm.data, def)]/~;\n         } else {\n             if cm.cnum_map.contains_key(def.crate) {\n                 // This reexport is itself a reexport from another crate\n                 let next_cnum = cm.cnum_map.get(def.crate);\n                 let next_cm_data = cstore::get_crate_data(cstore, next_cnum);\n-                result += [(next_cnum, next_cm_data.data, def)];\n+                result += [(next_cnum, next_cm_data.data, def)]/~;\n             }\n         }\n     }\n@@ -88,7 +88,7 @@ fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    [ast_map::path_mod(@cdata.name)] + path\n+    [ast_map::path_mod(@cdata.name)]/~ + path\n }\n \n enum found_ast {\n@@ -109,28 +109,29 @@ fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n                                 decode_inlined_item)\n }\n \n-fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n+fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n+    -> [ty::variant_info]/~ {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     ret decoder::get_enum_variants(cdata, def.node, tcx)\n }\n \n fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n                      name: option<ast::ident>)\n-    -> @[@decoder::_impl] {\n+    -> @[@decoder::_impl]/~ {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impls_for_mod(cdata, def.node, name) {|cnum|\n         cstore::get_crate_data(cstore, cnum)\n     }\n }\n \n-fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method] {\n+fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method]/~ {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_iface_methods(cdata, def.node, tcx)\n }\n \n-fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> [ty::field_ty] {\n+fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> [ty::field_ty]/~ {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_class_fields(cdata, def.node)\n@@ -159,7 +160,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                  class_id, def)});\n     #debug(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n-    ret {bounds: @[], rp: ast::rp_none, ty: ty};\n+    ret {bounds: @[]/~, rp: ast::rp_none, ty: ty};\n }\n \n // Given a def_id for an impl or class, return the iface it implements,"}, {"sha": "7f7468faea5cce782268d7a68688a943a91f8dac", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -40,7 +40,7 @@ type cnum_map = map::hashmap<ast::crate_num, ast::crate_num>;\n type mod_path_map = map::hashmap<ast::def_id, @str>;\n \n type crate_metadata = @{name: str,\n-                        data: @[u8],\n+                        data: @[u8]/~,\n                         cnum_map: cnum_map,\n                         cnum: ast::crate_num};\n \n@@ -55,9 +55,9 @@ type cstore_private =\n     @{metas: map::hashmap<ast::crate_num, crate_metadata>,\n       use_crate_map: use_crate_map,\n       mod_path_map: mod_path_map,\n-      mut used_crate_files: [str],\n-      mut used_libraries: [str],\n-      mut used_link_args: [str]};\n+      mut used_crate_files: [str]/~,\n+      mut used_libraries: [str]/~,\n+      mut used_link_args: [str]/~};\n \n // Map from node_id's of local use statements to crate numbers\n type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n@@ -74,9 +74,9 @@ fn mk_cstore() -> cstore {\n     ret private(@{metas: meta_cache,\n                   use_crate_map: crate_map,\n                   mod_path_map: mod_path_map,\n-                  mut used_crate_files: [],\n-                  mut used_libraries: [],\n-                  mut used_link_args: []});\n+                  mut used_crate_files: []/~,\n+                  mut used_libraries: []/~,\n+                  mut used_link_args: []/~});\n }\n \n fn get_crate_data(cstore: cstore, cnum: ast::crate_num) -> crate_metadata {\n@@ -113,31 +113,31 @@ fn iter_crate_data(cstore: cstore, i: fn(ast::crate_num, crate_metadata)) {\n \n fn add_used_crate_file(cstore: cstore, lib: str) {\n     if !vec::contains(p(cstore).used_crate_files, lib) {\n-        p(cstore).used_crate_files += [lib];\n+        p(cstore).used_crate_files += [lib]/~;\n     }\n }\n \n-fn get_used_crate_files(cstore: cstore) -> [str] {\n+fn get_used_crate_files(cstore: cstore) -> [str]/~ {\n     ret p(cstore).used_crate_files;\n }\n \n fn add_used_library(cstore: cstore, lib: str) -> bool {\n     assert lib != \"\";\n \n     if vec::contains(p(cstore).used_libraries, lib) { ret false; }\n-    p(cstore).used_libraries += [lib];\n+    p(cstore).used_libraries += [lib]/~;\n     ret true;\n }\n \n-fn get_used_libraries(cstore: cstore) -> [str] {\n+fn get_used_libraries(cstore: cstore) -> [str]/~ {\n     ret p(cstore).used_libraries;\n }\n \n fn add_used_link_args(cstore: cstore, args: str) {\n     p(cstore).used_link_args += str::split_char(args, ' ');\n }\n \n-fn get_used_link_args(cstore: cstore) -> [str] {\n+fn get_used_link_args(cstore: cstore) -> [str]/~ {\n     ret p(cstore).used_link_args;\n }\n \n@@ -153,15 +153,15 @@ fn find_use_stmt_cnum(cstore: cstore,\n \n // returns hashes of crates directly used by this crate. Hashes are\n // sorted by crate name.\n-fn get_dep_hashes(cstore: cstore) -> [@str] {\n+fn get_dep_hashes(cstore: cstore) -> [@str]/~ {\n     type crate_hash = {name: @str, hash: @str};\n-    let mut result = [];\n+    let mut result = []/~;\n \n     for p(cstore).use_crate_map.each_value {|cnum|\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         #debug(\"Add hash[%s]: %s\", cdata.name, *hash);\n-        result += [{name: @cdata.name, hash: hash}];\n+        result += [{name: @cdata.name, hash: hash}]/~;\n     };\n     fn lteq(a: crate_hash, b: crate_hash) -> bool {\n         ret *a.name <= *b.name;\n@@ -175,9 +175,9 @@ fn get_dep_hashes(cstore: cstore) -> [@str] {\n     ret vec::map(sorted, mapper);\n }\n \n-fn get_path(cstore: cstore, d: ast::def_id) -> [ast::ident] {\n+fn get_path(cstore: cstore, d: ast::def_id) -> [ast::ident]/~ {\n     // let f = bind str::split_str(_, \"::\");\n-    option::map_default(p(cstore).mod_path_map.find(d), [],\n+    option::map_default(p(cstore).mod_path_map.find(d), []/~,\n                         {|ds| str::split_str(*ds, \"::\").map({|x|@x})})\n }\n // Local Variables:"}, {"sha": "9979bda226c23c9ec8bdbca8d8152f53c67f6290", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -53,28 +53,28 @@ export translate_def_id;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]) -> bool, hash: uint) ->\n-   [ebml::doc] {\n+fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]/~) -> bool, hash: uint) ->\n+   [ebml::doc]/~ {\n     let index = ebml::get_doc(d, tag_index);\n     let table = ebml::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n     let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4u) as uint;\n     let {tag:_, doc:bucket} = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n-    let mut result: [ebml::doc] = [];\n+    let mut result: [ebml::doc]/~ = []/~;\n     let belt = tag_index_buckets_bucket_elt;\n     ebml::tagged_docs(bucket, belt) {|elt|\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n-            result += [ebml::doc_at(d.data, pos).doc];\n+            result += [ebml::doc_at(d.data, pos).doc]/~;\n         }\n     };\n     ret result;\n }\n \n fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n-    fn eq_item(bytes: [u8], item_id: int) -> bool {\n+    fn eq_item(bytes: [u8]/~, item_id: int) -> bool {\n         ret io::u64_from_be_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n     let eqer = {|a|eq_item(a, item_id)};\n@@ -90,7 +90,7 @@ fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: @[u8]) -> ebml::doc {\n+fn lookup_item(item_id: int, data: @[u8]/~) -> ebml::doc {\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n     alt maybe_find_item(item_id, items) {\n        none { fail(#fmt(\"lookup_item: id not found: %d\", item_id)); }\n@@ -164,13 +164,13 @@ fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n }\n \n fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n-    -> @[ty::param_bounds] {\n-    let mut bounds = [];\n+    -> @[ty::param_bounds]/~ {\n+    let mut bounds = []/~;\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, {|did|\n             translate_def_id(cdata, did)\n         });\n-        bounds += [bd];\n+        bounds += [bd]/~;\n     }\n     @bounds\n }\n@@ -194,31 +194,31 @@ fn item_ty_param_count(item: ebml::doc) -> uint {\n     n\n }\n \n-fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id] {\n-    let mut ids: [ast::def_id] = [];\n+fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id]/~ {\n+    let mut ids: [ast::def_id]/~ = []/~;\n     let v = tag_items_data_item_variant;\n     ebml::tagged_docs(item, v) {|p|\n         let ext = parse_def_id(ebml::doc_data(p));\n-        ids += [{crate: cdata.cnum, node: ext.node}];\n+        ids += [{crate: cdata.cnum, node: ext.node}]/~;\n     };\n     ret ids;\n }\n \n // Given a path and serialized crate metadata, returns the IDs of the\n // definitions the path may refer to.\n-fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n-    fn eq_item(data: [u8], s: str) -> bool {\n+fn resolve_path(path: [ast::ident]/~, data: @[u8]/~) -> [ast::def_id]/~ {\n+    fn eq_item(data: [u8]/~, s: str) -> bool {\n         ret str::eq(str::from_bytes(data), s);\n     }\n     let s = ast_util::path_name_i(path);\n     let md = ebml::doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = {|a|eq_item(a, s)};\n-    let mut result: [ast::def_id] = [];\n+    let mut result: [ast::def_id]/~ = []/~;\n     #debug(\"resolve_path: looking up %s\", s);\n     for lookup_hash(paths, eqer, hash_path(s)).each {|doc|\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n-        result += [parse_def_id(ebml::doc_data(did_doc))];\n+        result += [parse_def_id(ebml::doc_data(did_doc))]/~;\n     }\n     ret result;\n }\n@@ -229,16 +229,16 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     let len_doc = ebml::get_doc(path_doc, tag_path_len);\n     let len = ebml::doc_as_u32(len_doc) as uint;\n \n-    let mut result = [];\n+    let mut result = []/~;\n     vec::reserve(result, len);\n \n     ebml::docs(path_doc) {|tag, elt_doc|\n         if tag == tag_path_elt_mod {\n             let str = ebml::doc_as_str(elt_doc);\n-            result += [ast_map::path_mod(@str)];\n+            result += [ast_map::path_mod(@str)]/~;\n         } else if tag == tag_path_elt_name {\n             let str = ebml::doc_as_str(elt_doc);\n-            result += [ast_map::path_name(@str)];\n+            result += [ast_map::path_name(@str)]/~;\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -252,11 +252,11 @@ fn item_name(item: ebml::doc) -> ast::ident {\n     @str::from_bytes(ebml::doc_data(name))\n }\n \n-fn lookup_item_name(data: @[u8], id: ast::node_id) -> ast::ident {\n+fn lookup_item_name(data: @[u8]/~, id: ast::node_id) -> ast::ident {\n     item_name(lookup_item(id, data))\n }\n \n-fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n+fn lookup_def(cnum: ast::crate_num, data: @[u8]/~, did_: ast::def_id) ->\n    ast::def {\n     let item = lookup_item(did_.node, data);\n     let fam_ch = item_family(item);\n@@ -288,12 +288,12 @@ fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let t = item_type({crate: cdata.cnum, node: id}, item, tcx, cdata);\n     let tp_bounds = if family_has_type_params(item_family(item)) {\n         item_ty_param_bounds(item, tcx, cdata)\n-    } else { @[] };\n+    } else { @[]/~ };\n     let rp = item_ty_region_param(item);\n     ret {bounds: tp_bounds, rp: rp, ty: t};\n }\n \n-fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {\n+fn get_type_param_count(data: @[u8]/~, id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n@@ -351,7 +351,7 @@ fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n     found\n }\n \n-fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n+fn get_symbol(data: @[u8]/~, id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n@@ -392,22 +392,22 @@ fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n }\n \n fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-    -> [ty::variant_info] {\n+    -> [ty::variant_info]/~ {\n     let data = cdata.data;\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n     let item = find_item(id, items);\n-    let mut infos: [ty::variant_info] = [];\n+    let mut infos: [ty::variant_info]/~ = []/~;\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n     for variant_ids.each {|did|\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type({crate: cdata.cnum, node: id}, item,\n                                 tcx, cdata);\n         let name = item_name(item);\n-        let mut arg_tys: [ty::t] = [];\n+        let mut arg_tys: [ty::t]/~ = []/~;\n         alt ty::get(ctor_ty).struct {\n           ty::ty_fn(f) {\n-            for f.inputs.each {|a| arg_tys += [a.ty]; }\n+            for f.inputs.each {|a| arg_tys += [a.ty]/~; }\n           }\n           _ { /* Nullary enum variant. */ }\n         }\n@@ -416,37 +416,37 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n           _         { /* empty */ }\n         }\n         infos += [@{args: arg_tys, ctor_ty: ctor_ty, name: name,\n-                    id: did, disr_val: disr_val}];\n+                    id: did, disr_val: disr_val}]/~;\n         disr_val += 1;\n     }\n     ret infos;\n }\n \n // NB: These types are duplicated in resolve.rs\n type method_info = {did: ast::def_id, n_tps: uint, ident: ast::ident};\n-type _impl = {did: ast::def_id, ident: ast::ident, methods: [@method_info]};\n+type _impl = {did: ast::def_id, ident: ast::ident, methods: [@method_info]/~};\n \n fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n-    -> [@method_info] {\n-    let mut rslt = [];\n+    -> [@method_info]/~ {\n+    let mut rslt = []/~;\n     ebml::tagged_docs(item, tag_item_impl_method) {|doc|\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         rslt += [@{did: translate_def_id(cdata, m_did),\n                     /* FIXME (maybe #2323) tjc: take a look at this. */\n                    n_tps: item_ty_param_count(mth_item) - base_tps,\n-                   ident: item_name(mth_item)}];\n+                   ident: item_name(mth_item)}]/~;\n     }\n     rslt\n }\n \n fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n                      name: option<ast::ident>,\n                      get_cdata: fn(ast::crate_num) -> cmd)\n-    -> @[@_impl] {\n+    -> @[@_impl]/~ {\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n-    let mut result = [];\n+    let mut result = []/~;\n     ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n         let did = parse_def_id(ebml::doc_data(doc));\n         let local_did = translate_def_id(cdata, did);\n@@ -461,18 +461,18 @@ fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n            result += [@{\n                 did: local_did, ident: nm,\n                 methods: item_impl_methods(impl_cdata, item, base_tps)\n-            }];\n+            }]/~;\n         };\n     }\n     @result\n }\n \n /* Works for both classes and ifaces */\n fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-    -> @[ty::method] {\n+    -> @[ty::method]/~ {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n-    let mut result = [];\n+    let mut result = []/~;\n     ebml::tagged_docs(item, tag_item_iface_method) {|mth|\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n@@ -487,25 +487,25 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n                       'u' { ast::unsafe_fn }\n                       'f' { ast::impure_fn }\n                       'p' { ast::pure_fn }\n-                    }, vis: ast::public}];\n+                    }, vis: ast::public}]/~;\n     }\n     @result\n }\n \n // Helper function that gets either fields or methods\n fn get_class_members(cdata: cmd, id: ast::node_id,\n-                     p: fn(char) -> bool) -> [ty::field_ty] {\n+                     p: fn(char) -> bool) -> [ty::field_ty]/~ {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n-    let mut result = [];\n+    let mut result = []/~;\n     ebml::tagged_docs(item, tag_item_field) {|an_item|\n        let f = item_family(an_item);\n        if p(f) {\n           let name = item_name(an_item);\n           let did = class_member_id(an_item, cdata);\n           let mt = field_mutability(an_item);\n           result += [{ident: name, id: did, vis:\n-                  family_to_visibility(f), mutability: mt}];\n+                  family_to_visibility(f), mutability: mt}]/~;\n        }\n     }\n     result\n@@ -519,7 +519,7 @@ pure fn family_to_visibility(family: char) -> ast::visibility {\n }\n \n /* 'g' for public field, 'j' for private field */\n-fn get_class_fields(cdata: cmd, id: ast::node_id) -> [ty::field_ty] {\n+fn get_class_fields(cdata: cmd, id: ast::node_id) -> [ty::field_ty]/~ {\n     get_class_members(cdata, id, {|f| f == 'g' || f == 'j'})\n }\n \n@@ -576,12 +576,12 @@ fn item_family_to_str(fam: char) -> str {\n     }\n }\n \n-fn get_meta_items(md: ebml::doc) -> [@ast::meta_item] {\n-    let mut items: [@ast::meta_item] = [];\n+fn get_meta_items(md: ebml::doc) -> [@ast::meta_item]/~ {\n+    let mut items: [@ast::meta_item]/~ = []/~;\n     ebml::tagged_docs(md, tag_meta_item_word) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n-        items += [attr::mk_word_item(@n)];\n+        items += [attr::mk_word_item(@n)]/~;\n     };\n     ebml::tagged_docs(md, tag_meta_item_name_value) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -590,19 +590,19 @@ fn get_meta_items(md: ebml::doc) -> [@ast::meta_item] {\n         let v = str::from_bytes(ebml::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n-        items += [attr::mk_name_value_item_str(@n, v)];\n+        items += [attr::mk_name_value_item_str(@n, v)]/~;\n     };\n     ebml::tagged_docs(md, tag_meta_item_list) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n-        items += [attr::mk_list_item(@n, subitems)];\n+        items += [attr::mk_list_item(@n, subitems)]/~;\n     };\n     ret items;\n }\n \n-fn get_attributes(md: ebml::doc) -> [ast::attribute] {\n-    let mut attrs: [ast::attribute] = [];\n+fn get_attributes(md: ebml::doc) -> [ast::attribute]/~ {\n+    let mut attrs: [ast::attribute]/~ = []/~;\n     alt ebml::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) {\n         ebml::tagged_docs(attrs_d, tag_attribute) {|attr_doc|\n@@ -613,7 +613,7 @@ fn get_attributes(md: ebml::doc) -> [ast::attribute] {\n             let meta_item = meta_items[0];\n             attrs +=\n                 [{node: {style: ast::attr_outer, value: *meta_item},\n-                  span: ast_util::dummy_sp()}];\n+                  span: ast_util::dummy_sp()}]/~;\n         };\n       }\n       option::none { }\n@@ -637,15 +637,15 @@ fn list_crate_attributes(md: ebml::doc, hash: @str, out: io::writer) {\n     out.write_str(\"\\n\\n\");\n }\n \n-fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n+fn get_crate_attributes(data: @[u8]/~) -> [ast::attribute]/~ {\n     ret get_attributes(ebml::doc(data));\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n                   vers: @str, hash: @str};\n \n-fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n-    let mut deps: [crate_dep] = [];\n+fn get_crate_deps(data: @[u8]/~) -> [crate_dep]/~ {\n+    let mut deps: [crate_dep]/~ = []/~;\n     let cratedoc = ebml::doc(data);\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n@@ -656,13 +656,13 @@ fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n         deps += [{cnum: crate_num,\n                   name: @docstr(depdoc, tag_crate_dep_name),\n                   vers: @docstr(depdoc, tag_crate_dep_vers),\n-                  hash: @docstr(depdoc, tag_crate_dep_hash)}];\n+                  hash: @docstr(depdoc, tag_crate_dep_hash)}]/~;\n         crate_num += 1;\n     };\n     ret deps;\n }\n \n-fn list_crate_deps(data: @[u8], out: io::writer) {\n+fn list_crate_deps(data: @[u8]/~, out: io::writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     for get_crate_deps(data).each {|dep|\n@@ -673,13 +673,13 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n     out.write_str(\"\\n\");\n }\n \n-fn get_crate_hash(data: @[u8]) -> @str {\n+fn get_crate_hash(data: @[u8]/~) -> @str {\n     let cratedoc = ebml::doc(data);\n     let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n     ret @str::from_bytes(ebml::doc_data(hashdoc));\n }\n \n-fn get_crate_vers(data: @[u8]) -> @str {\n+fn get_crate_vers(data: @[u8]/~) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n     ret alt attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), \"vers\") {\n@@ -688,7 +688,7 @@ fn get_crate_vers(data: @[u8]) -> @str {\n     };\n }\n \n-fn list_crate_items(bytes: @[u8], md: ebml::doc, out: io::writer) {\n+fn list_crate_items(bytes: @[u8]/~, md: ebml::doc, out: io::writer) {\n     out.write_str(\"=Items=\\n\");\n     let items = ebml::get_doc(md, tag_items);\n     iter_crate_items(bytes) {|path, did|\n@@ -697,7 +697,7 @@ fn list_crate_items(bytes: @[u8], md: ebml::doc, out: io::writer) {\n     out.write_str(\"\\n\");\n }\n \n-fn iter_crate_items(bytes: @[u8], proc: fn(str, ast::def_id)) {\n+fn iter_crate_items(bytes: @[u8]/~, proc: fn(str, ast::def_id)) {\n     let md = ebml::doc(bytes);\n     let paths = ebml::get_doc(md, tag_paths);\n     let index = ebml::get_doc(paths, tag_index);\n@@ -714,14 +714,14 @@ fn iter_crate_items(bytes: @[u8], proc: fn(str, ast::def_id)) {\n     };\n }\n \n-fn get_crate_module_paths(bytes: @[u8]) -> [(ast::def_id, str)] {\n+fn get_crate_module_paths(bytes: @[u8]/~) -> [(ast::def_id, str)]/~ {\n     fn mod_of_path(p: str) -> str {\n         str::connect(vec::init(str::split_str(p, \"::\")), \"::\")\n     }\n \n     // find all module (path, def_ids), which are not\n     // fowarded path due to renamed import or reexport\n-    let mut res = [];\n+    let mut res = []/~;\n     let mods = map::str_hash();\n     iter_crate_items(bytes) {|path, did|\n         let m = mod_of_path(path);\n@@ -732,15 +732,15 @@ fn get_crate_module_paths(bytes: @[u8]) -> [(ast::def_id, str)] {\n         // Collect everything by now. There might be multiple\n         // paths pointing to the same did. Those will be\n         // unified later by using the mods map\n-        res += [(did, path)];\n+        res += [(did, path)]/~;\n     }\n     ret vec::filter(res) {|x|\n         let (_, xp) = x;\n         mods.contains_key(xp)\n     }\n }\n \n-fn list_crate_metadata(bytes: @[u8], out: io::writer) {\n+fn list_crate_metadata(bytes: @[u8]/~, out: io::writer) {\n     let hash = get_crate_hash(bytes);\n     let md = ebml::doc(bytes);\n     list_crate_attributes(md, hash, out);"}, {"sha": "c9802da3b03d0aa032bc1b221cee68ac3fc722f2", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 77, "deletions": 75, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -43,8 +43,8 @@ type encode_parms = {\n     diag: span_handler,\n     tcx: ty::ctxt,\n     reachable: hashmap<ast::node_id, ()>,\n-    reexports: [(str, def_id)],\n-    impl_map: fn@(ast::node_id) -> [(ident, def_id)],\n+    reexports: [(str, def_id)]/~,\n+    impl_map: fn@(ast::node_id) -> [(ident, def_id)]/~,\n     item_symbols: hashmap<ast::node_id, str>,\n     discrim_symbols: hashmap<ast::node_id, str>,\n     link_meta: link_meta,\n@@ -56,8 +56,8 @@ enum encode_ctxt = {\n     diag: span_handler,\n     tcx: ty::ctxt,\n     reachable: hashmap<ast::node_id, ()>,\n-    reexports: [(str, def_id)],\n-    impl_map: fn@(ast::node_id) -> [(ident, def_id)],\n+    reexports: [(str, def_id)]/~,\n+    impl_map: fn@(ast::node_id) -> [(ident, def_id)]/~,\n     item_symbols: hashmap<ast::node_id, str>,\n     discrim_symbols: hashmap<ast::node_id, str>,\n     link_meta: link_meta,\n@@ -108,8 +108,8 @@ fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: [variant],\n-                            path: [ident], &index: [entry<str>]) {\n+fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: [variant]/~,\n+                            path: [ident]/~, &index: [entry<str>]/~) {\n     for variants.each {|variant|\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebml_w.wr_tag(tag_paths_data_item) {||\n@@ -119,23 +119,23 @@ fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: [variant],\n     }\n }\n \n-fn add_to_index(ebml_w: ebml::writer, path: [ident], &index: [entry<str>],\n+fn add_to_index(ebml_w: ebml::writer, path: [ident]/~, &index: [entry<str>]/~,\n                 name: ident) {\n-    let full_path = path + [name];\n-    index +=\n-        [{val: ast_util::path_name_i(full_path), pos: ebml_w.writer.tell()}];\n+    let full_path = path + [name]/~;\n+    vec::push(index, {val: ast_util::path_name_i(full_path),\n+                      pos: ebml_w.writer.tell()});\n }\n \n fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n-                                   path: [ident], &index: [entry<str>]) {\n+                                   path: [ident]/~, &index: [entry<str>]/~) {\n     for nmod.items.each {|nitem|\n         add_to_index(ebml_w, path, index, nitem.ident);\n         encode_named_def_id(ebml_w, nitem.ident, local_def(nitem.id));\n     }\n }\n \n fn encode_class_item_paths(ebml_w: ebml::writer,\n-     items: [@class_member], path: [ident], &index: [entry<str>]) {\n+     items: [@class_member]/~, path: [ident]/~, &index: [entry<str>]/~) {\n     for items.each {|it|\n      alt ast_util::class_member_visibility(it) {\n           private { cont; }\n@@ -152,8 +152,8 @@ fn encode_class_item_paths(ebml_w: ebml::writer,\n }\n \n fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n-                            module: _mod, path: [ident],\n-                            &index: [entry<str>]) {\n+                            module: _mod, path: [ident]/~,\n+                            &index: [entry<str>]/~) {\n     for module.items.each {|it|\n         if !reachable(ecx, it.id) ||\n            !ast_util::is_exported(it.ident, module) { cont; }\n@@ -170,15 +170,16 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n           item_mod(_mod) {\n             ebml_w.wr_tag(tag_paths_data_mod) {||\n                encode_name_and_def_id(ebml_w, it.ident, it.id);\n-               encode_module_item_paths(ebml_w, ecx, _mod, path + [it.ident],\n+               encode_module_item_paths(ebml_w, ecx, _mod,\n+                                        path + [it.ident]/~,\n                                         index);\n             }\n           }\n           item_native_mod(nmod) {\n             ebml_w.wr_tag(tag_paths_data_mod) {||\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n               encode_native_module_item_paths(ebml_w, nmod,\n-                   path + [it.ident], index);\n+                   path + [it.ident]/~, index);\n             }\n           }\n           item_ty(_, tps, _) {\n@@ -196,7 +197,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                 add_to_index(ebml_w, path, index, it.ident);\n                 encode_named_def_id(ebml_w, it.ident,\n                                     local_def(ctor.node.id));\n-                encode_class_item_paths(ebml_w, items, path + [it.ident],\n+                encode_class_item_paths(ebml_w, items, path + [it.ident]/~,\n                                         index);\n             }\n           }\n@@ -223,9 +224,9 @@ fn encode_iface_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @iface_ref) {\n }\n \n fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n-    -> [entry<str>] {\n-    let mut index: [entry<str>] = [];\n-    let mut path: [ident] = [];\n+    -> [entry<str>]/~ {\n+    let mut index: [entry<str>]/~ = []/~;\n+    let mut path: [ident]/~ = []/~;\n     ebml_w.start_tag(tag_paths);\n     encode_module_item_paths(ebml_w, ecx, crate.node.module, path, index);\n     encode_reexport_paths(ebml_w, ecx, index);\n@@ -234,10 +235,10 @@ fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n }\n \n fn encode_reexport_paths(ebml_w: ebml::writer,\n-                         ecx: @encode_ctxt, &index: [entry<str>]) {\n+                         ecx: @encode_ctxt, &index: [entry<str>]/~) {\n     for ecx.reexports.each {|reexport|\n         let (path, def_id) = reexport;\n-        index += [{val: path, pos: ebml_w.writer.tell()}];\n+        index += [{val: path, pos: ebml_w.writer.tell()}]/~;\n         ebml_w.start_tag(tag_paths_data_item);\n         encode_name(ebml_w, @path);\n         encode_def_id(ebml_w, def_id);\n@@ -256,7 +257,7 @@ fn encode_family(ebml_w: ebml::writer, c: char) {\n fn def_to_str(did: def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n \n fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n-                            params: [ty_param]) {\n+                            params: [ty_param]/~) {\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n                         tcx: ecx.tcx,\n@@ -324,14 +325,14 @@ fn encode_parent_item(ebml_w: ebml::writer, id: def_id) {\n }\n \n fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n-                            id: node_id, variants: [variant],\n-                            path: ast_map::path, index: @mut [entry<int>],\n-                            ty_params: [ty_param]) {\n+                            id: node_id, variants: [variant]/~,\n+                            path: ast_map::path, index: @mut [entry<int>]/~,\n+                            ty_params: [ty_param]/~) {\n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx, {crate: local_crate, node: id});\n     for variants.each {|variant|\n-        *index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n+        *index += [{val: variant.node.id, pos: ebml_w.writer.tell()}]/~;\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v');\n@@ -420,20 +421,20 @@ fn encode_visibility(ebml_w: ebml::writer, visibility: visibility) {\n /* Returns an index of items in this class */\n fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          id: node_id, path: ast_map::path,\n-                         class_tps: [ty_param],\n-                         items: [@class_member],\n-                         global_index: @mut[entry<int>]) -> [entry<int>] {\n+                         class_tps: [ty_param]/~,\n+                         items: [@class_member]/~,\n+                         global_index: @mut[entry<int>]/~) -> [entry<int>]/~ {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n-    let index = @mut [];\n+    let index = @mut []/~;\n     let tcx = ecx.tcx;\n     for items.each {|ci|\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n       alt ci.node {\n         instance_var(nm, _, mt, id, vis) {\n-          *index += [{val: id, pos: ebml_w.writer.tell()}];\n-          *global_index += [{val: id, pos: ebml_w.writer.tell()}];\n+          *index += [{val: id, pos: ebml_w.writer.tell()}]/~;\n+          *global_index += [{val: id, pos: ebml_w.writer.tell()}]/~;\n           ebml_w.start_tag(tag_items_data_item);\n           #debug(\"encode_info_for_class: doing %s %d\", *nm, id);\n           encode_visibility(ebml_w, vis);\n@@ -447,9 +448,9 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         class_method(m) {\n            alt m.vis {\n               public {\n-                *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n-                *global_index += [{val: m.id, pos: ebml_w.writer.tell()}];\n-                let impl_path = path + [ast_map::path_name(m.ident)];\n+                *index += [{val: m.id, pos: ebml_w.writer.tell()}]/~;\n+                *global_index += [{val: m.id, pos: ebml_w.writer.tell()}]/~;\n+                let impl_path = path + [ast_map::path_name(m.ident)]/~;\n                 #debug(\"encode_info_for_class: doing %s %d\", *m.ident, m.id);\n                 encode_info_for_method(ecx, ebml_w, impl_path,\n                                        should_inline(m.attrs), id, m,\n@@ -465,7 +466,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n \n fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                       id: node_id, ident: ident, path: ast_map::path,\n-                      item: option<inlined_item>, tps: [ty_param],\n+                      item: option<inlined_item>, tps: [ty_param]/~,\n                       decl: fn_decl) {\n         ebml_w.start_tag(tag_items_data_item);\n         encode_name(ebml_w, ident);\n@@ -491,7 +492,7 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n-                          m: @method, all_tps: [ty_param]) {\n+                          m: @method, all_tps: [ty_param]/~) {\n     #debug(\"encode_info_for_method: %d %s %u\", m.id, *m.ident, all_tps.len());\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n@@ -520,7 +521,7 @@ fn purity_fn_family(p: purity) -> char {\n }\n \n \n-fn should_inline(attrs: [attribute]) -> bool {\n+fn should_inline(attrs: [attribute]/~) -> bool {\n     alt attr::find_inline_attr(attrs) {\n         attr::ia_none { false }\n         attr::ia_hint | attr::ia_always { true }\n@@ -529,16 +530,16 @@ fn should_inline(attrs: [attribute]) -> bool {\n \n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n-                        index: @mut [entry<int>], path: ast_map::path) {\n+                        index: @mut [entry<int>]/~, path: ast_map::path) {\n \n     let tcx = ecx.tcx;\n     let must_write =\n         alt item.node { item_enum(_, _, _) { true } _ { false } };\n     if !must_write && !reachable(ecx, item.id) { ret; }\n \n     fn add_to_index_(item: @item, ebml_w: ebml::writer,\n-                     index: @mut [entry<int>]) {\n-        *index += [{val: item.id, pos: ebml_w.writer.tell()}];\n+                     index: @mut [entry<int>]/~) {\n+        *index += [{val: item.id, pos: ebml_w.writer.tell()}]/~;\n     }\n     let add_to_index = {|copy ebml_w|add_to_index_(item, ebml_w, index)};\n \n@@ -620,7 +621,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                                           items, index);\n         /* Encode the dtor */\n         option::iter(m_dtor) {|dtor|\n-          *index += [{val: dtor.node.id, pos: ebml_w.writer.tell()}];\n+          *index += [{val: dtor.node.id, pos: ebml_w.writer.tell()}]/~;\n           encode_info_for_fn(ecx, ebml_w, dtor.node.id, @(*item.ident\n                              + \"_dtor\"), path, if tps.len() > 0u {\n                                some(ii_dtor(dtor, item.ident, tps,\n@@ -707,9 +708,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n \n-        let impl_path = path + [ast_map::path_name(item.ident)];\n+        let impl_path = path + [ast_map::path_name(item.ident)]/~;\n         for methods.each {|m|\n-            *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n+            *index += [{val: m.id, pos: ebml_w.writer.tell()}]/~;\n             encode_info_for_method(ecx, ebml_w, impl_path,\n                    should_inline(m.attrs), item.id, m, tps + m.tps);\n         }\n@@ -741,10 +742,10 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                nitem: @native_item,\n-                               index: @mut [entry<int>],\n+                               index: @mut [entry<int>]/~,\n                                path: ast_map::path, abi: native_abi) {\n     if !reachable(ecx, nitem.id) { ret; }\n-    *index += [{val: nitem.id, pos: ebml_w.writer.tell()}];\n+    *index += [{val: nitem.id, pos: ebml_w.writer.tell()}]/~;\n \n     ebml_w.start_tag(tag_items_data_item);\n     alt nitem.node {\n@@ -766,12 +767,12 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n }\n \n fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n-                         crate: @crate) -> [entry<int>] {\n-    let index = @mut [];\n+                         crate: @crate) -> [entry<int>]/~ {\n+    let index = @mut []/~;\n     ebml_w.start_tag(tag_items_data);\n-    *index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n+    *index += [{val: crate_node_id, pos: ebml_w.writer.tell()}]/~;\n     encode_info_for_mod(ecx, ebml_w, crate.node.module,\n-                        crate_node_id, [], @\"\");\n+                        crate_node_id, []/~, @\"\");\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n         visit_expr: {|_e, _cx, _v|},\n         visit_item: {|i, cx, v, copy ebml_w|\n@@ -784,7 +785,8 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                    item_class(tps, _, _, ctor, m_dtor, _) {\n                    #debug(\"encoding info for ctor %s %d\", *i.ident,\n                           ctor.node.id);\n-                   *index += [{val: ctor.node.id, pos: ebml_w.writer.tell()}];\n+                   *index +=\n+                       [{val: ctor.node.id, pos: ebml_w.writer.tell()}]/~;\n                    encode_info_for_fn(ecx, ebml_w, ctor.node.id, i.ident,\n                       *pt, if tps.len() > 0u {\n                              some(ii_ctor(ctor, i.ident, tps,\n@@ -813,30 +815,30 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n \n // Path and definition ID indexing\n \n-fn create_index<T: copy>(index: [entry<T>], hash_fn: fn@(T) -> uint) ->\n-   [@[entry<T>]] {\n-    let mut buckets: [@mut [entry<T>]] = [];\n-    for uint::range(0u, 256u) {|_i| buckets += [@mut []]; };\n+fn create_index<T: copy>(index: [entry<T>]/~, hash_fn: fn@(T) -> uint) ->\n+   [@[entry<T>]/~]/~ {\n+    let mut buckets: [@mut [entry<T>]/~]/~ = []/~;\n+    for uint::range(0u, 256u) {|_i| buckets += [@mut []/~]/~; };\n     for index.each {|elt|\n         let h = hash_fn(elt.val);\n-        *buckets[h % 256u] += [elt];\n+        vec::push(*buckets[h % 256u], elt);\n     }\n \n-    let mut buckets_frozen = [];\n+    let mut buckets_frozen = []/~;\n     for buckets.each {|bucket|\n-        buckets_frozen += [@*bucket];\n+        vec::push(buckets_frozen, @*bucket);\n     }\n     ret buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]],\n+fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]/~]/~,\n                    write_fn: fn(io::writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n-    let mut bucket_locs: [uint] = [];\n+    let mut bucket_locs: [uint]/~ = []/~;\n     ebml_w.start_tag(tag_index_buckets);\n     for buckets.each {|bucket|\n-        bucket_locs += [ebml_w.writer.tell()];\n+        bucket_locs += [ebml_w.writer.tell()]/~;\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for vec::each(*bucket) {|elt|\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n@@ -896,7 +898,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: ebml::writer, attrs: [attribute]) {\n+fn encode_attributes(ebml_w: ebml::writer, attrs: [attribute]/~) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each {|attr|\n         ebml_w.start_tag(tag_attribute);\n@@ -910,9 +912,9 @@ fn encode_attributes(ebml_w: ebml::writer, attrs: [attribute]) {\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n-fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute] {\n+fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute]/~ {\n \n-    fn synthesize_link_attr(ecx: @encode_ctxt, items: [@meta_item]) ->\n+    fn synthesize_link_attr(ecx: @encode_ctxt, items: [@meta_item]/~) ->\n        attribute {\n \n         assert (*ecx.link_meta.name != \"\");\n@@ -929,47 +931,47 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute] {\n                 attr::remove_meta_items_by_name(tmp, @\"vers\")\n             };\n \n-        let meta_items = [name_item, vers_item] + other_items;\n+        let meta_items = [name_item, vers_item]/~ + other_items;\n         let link_item = attr::mk_list_item(@\"link\", meta_items);\n \n         ret attr::mk_attr(link_item);\n     }\n \n-    let mut attrs: [attribute] = [];\n+    let mut attrs: [attribute]/~ = []/~;\n     let mut found_link_attr = false;\n     for crate.node.attrs.each {|attr|\n         attrs +=\n             if *attr::get_attr_name(attr) != \"link\" {\n-                [attr]\n+                [attr]/~\n             } else {\n                 alt attr.node.value.node {\n                   meta_list(n, l) {\n                     found_link_attr = true;;\n-                    [synthesize_link_attr(ecx, l)]\n+                    [synthesize_link_attr(ecx, l)]/~\n                   }\n-                  _ { [attr] }\n+                  _ { [attr]/~ }\n                 }\n             };\n     }\n \n-    if !found_link_attr { attrs += [synthesize_link_attr(ecx, [])]; }\n+    if !found_link_attr { attrs += [synthesize_link_attr(ecx, []/~)]/~; }\n \n     ret attrs;\n }\n \n fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n-    fn get_ordered_deps(cstore: cstore::cstore) -> [decoder::crate_dep] {\n+    fn get_ordered_deps(cstore: cstore::cstore) -> [decoder::crate_dep]/~ {\n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n         type numdep = decoder::crate_dep;\n \n         // Pull the cnums and name,vers,hash out of cstore\n-        let mut deps: [mut numdep] = [mut];\n+        let mut deps: [mut numdep]/~ = [mut]/~;\n         cstore::iter_crate_data(cstore) {|key, val|\n             let dep = {cnum: key, name: @val.name,\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n-            deps += [mut dep];\n+            deps += [mut dep]/~;\n         };\n \n         // Sort by cnum\n@@ -1018,7 +1020,7 @@ fn encode_hash(ebml_w: ebml::writer, hash: str) {\n     ebml_w.end_tag();\n }\n \n-fn encode_metadata(parms: encode_parms, crate: @crate) -> [u8] {\n+fn encode_metadata(parms: encode_parms, crate: @crate) -> [u8]/~ {\n     let ecx: @encode_ctxt = @encode_ctxt({\n         diag: parms.diag,\n         tcx: parms.tcx,"}, {"sha": "c66c02bce9c8fb2e3492b7bf941f8ca54fa70a1a", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -25,29 +25,29 @@ fn pick_file(file: path, path: path) -> option<path> {\n \n iface filesearch {\n     fn sysroot() -> path;\n-    fn lib_search_paths() -> [path];\n+    fn lib_search_paths() -> [path]/~;\n     fn get_target_lib_path() -> path;\n     fn get_target_lib_file_path(file: path) -> path;\n }\n \n fn mk_filesearch(maybe_sysroot: option<path>,\n                  target_triple: str,\n-                 addl_lib_search_paths: [path]) -> filesearch {\n+                 addl_lib_search_paths: [path]/~) -> filesearch {\n     type filesearch_impl = {sysroot: path,\n-                            addl_lib_search_paths: [path],\n+                            addl_lib_search_paths: [path]/~,\n                             target_triple: str};\n     impl of filesearch for filesearch_impl {\n         fn sysroot() -> path { self.sysroot }\n-        fn lib_search_paths() -> [path] {\n+        fn lib_search_paths() -> [path]/~ {\n             self.addl_lib_search_paths\n-                + [make_target_lib_path(self.sysroot, self.target_triple)]\n+                + [make_target_lib_path(self.sysroot, self.target_triple)]/~\n                 + alt get_cargo_lib_path_nearest() {\n-                  result::ok(p) { [p] }\n-                  result::err(p) { [] }\n+                  result::ok(p) { [p]/~ }\n+                  result::err(p) { []/~ }\n                 }\n                 + alt get_cargo_lib_path() {\n-                  result::ok(p) { [p] }\n-                  result::err(p) { [] }\n+                  result::ok(p) { [p]/~ }\n+                  result::err(p) { []/~ }\n                 }\n         }\n         fn get_target_lib_path() -> path {\n@@ -85,13 +85,13 @@ fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n     ret rslt;\n }\n \n-fn relative_target_lib_path(target_triple: str) -> [path] {\n-    [libdir(), \"rustc\", target_triple, libdir()]\n+fn relative_target_lib_path(target_triple: str) -> [path]/~ {\n+    [libdir(), \"rustc\", target_triple, libdir()]/~\n }\n \n fn make_target_lib_path(sysroot: path,\n                         target_triple: str) -> path {\n-    let path = [sysroot] + relative_target_lib_path(target_triple);\n+    let path = [sysroot]/~ + relative_target_lib_path(target_triple);\n     let path = path::connect_many(path);\n     ret path;\n }\n@@ -113,7 +113,7 @@ fn get_sysroot(maybe_sysroot: option<path>) -> path {\n }\n \n fn get_cargo_sysroot() -> result<path, str> {\n-    let path = [get_default_sysroot(), libdir(), \"cargo\"];\n+    let path = [get_default_sysroot(), libdir(), \"cargo\"]/~;\n     result::ok(path::connect_many(path))\n }\n "}, {"sha": "e7fbdb96d56e41b697753049f8f2da887c92ab74", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -33,13 +33,13 @@ type ctxt = {\n     filesearch: filesearch,\n     span: span,\n     ident: ast::ident,\n-    metas: [@ast::meta_item],\n+    metas: [@ast::meta_item]/~,\n     hash: str,\n     os: os,\n     static: bool\n };\n \n-fn load_library_crate(cx: ctxt) -> {ident: str, data: @[u8]} {\n+fn load_library_crate(cx: ctxt) -> {ident: str, data: @[u8]/~} {\n     alt find_library_crate(cx) {\n       some(t) { ret t; }\n       none {\n@@ -49,7 +49,7 @@ fn load_library_crate(cx: ctxt) -> {ident: str, data: @[u8]} {\n     }\n }\n \n-fn find_library_crate(cx: ctxt) -> option<{ident: str, data: @[u8]}> {\n+fn find_library_crate(cx: ctxt) -> option<{ident: str, data: @[u8]/~}> {\n     attr::require_unique_names(cx.diag, cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n@@ -67,12 +67,12 @@ fn libname(cx: ctxt) -> {prefix: str, suffix: str} {\n fn find_library_crate_aux(cx: ctxt,\n                           nn: {prefix: str, suffix: str},\n                           filesearch: filesearch::filesearch) ->\n-   option<{ident: str, data: @[u8]}> {\n+   option<{ident: str, data: @[u8]/~}> {\n     let crate_name = crate_name_from_metas(cx.metas);\n     let prefix: str = nn.prefix + *crate_name + \"-\";\n     let suffix: str = nn.suffix;\n \n-    let mut matches = [];\n+    let mut matches = []/~;\n     filesearch::search(filesearch, { |path|\n         #debug(\"inspecting file %s\", path);\n         let f: str = path::basename(path);\n@@ -89,7 +89,7 @@ fn find_library_crate_aux(cx: ctxt,\n                     option::none::<()>\n                 } else {\n                     #debug(\"found %s with matching metadata\", path);\n-                    matches += [{ident: path, data: cvec}];\n+                    matches += [{ident: path, data: cvec}]/~;\n                     option::none::<()>\n                 }\n               }\n@@ -119,7 +119,7 @@ fn find_library_crate_aux(cx: ctxt,\n     }\n }\n \n-fn crate_name_from_metas(metas: [@ast::meta_item]) -> @str {\n+fn crate_name_from_metas(metas: [@ast::meta_item]/~) -> @str {\n     let name_items = attr::find_meta_items_by_name(metas, \"name\");\n     alt vec::last_opt(name_items) {\n       some(i) {\n@@ -134,14 +134,14 @@ fn crate_name_from_metas(metas: [@ast::meta_item]) -> @str {\n     }\n }\n \n-fn note_linkage_attrs(diag: span_handler, attrs: [ast::attribute]) {\n+fn note_linkage_attrs(diag: span_handler, attrs: [ast::attribute]/~) {\n     for attr::find_linkage_attrs(attrs).each {|attr|\n         diag.handler().note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n     }\n }\n \n-fn crate_matches(crate_data: @[u8], metas: [@ast::meta_item], hash: str) ->\n-    bool {\n+fn crate_matches(crate_data: @[u8]/~, metas: [@ast::meta_item]/~,\n+                 hash: str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n     if hash.is_not_empty() {\n@@ -151,8 +151,8 @@ fn crate_matches(crate_data: @[u8], metas: [@ast::meta_item], hash: str) ->\n     metadata_matches(linkage_metas, metas)\n }\n \n-fn metadata_matches(extern_metas: [@ast::meta_item],\n-                    local_metas: [@ast::meta_item]) -> bool {\n+fn metadata_matches(extern_metas: [@ast::meta_item]/~,\n+                    local_metas: [@ast::meta_item]/~) -> bool {\n \n     #debug(\"matching %u metadata requirements against %u items\",\n            vec::len(local_metas), vec::len(extern_metas));\n@@ -173,14 +173,14 @@ fn metadata_matches(extern_metas: [@ast::meta_item],\n }\n \n fn get_metadata_section(os: os,\n-                        filename: str) -> option<@[u8]> unsafe {\n+                        filename: str) -> option<@[u8]/~> unsafe {\n     let mb = str::as_c_str(filename, {|buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n                                    });\n-    if mb as int == 0 { ret option::none::<@[u8]>; }\n+    if mb as int == 0 { ret option::none::<@[u8]/~>; }\n     let of = alt mk_object_file(mb) {\n         option::some(of) { of }\n-        _ { ret option::none::<@[u8]>; }\n+        _ { ret option::none::<@[u8]/~>; }\n     };\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n@@ -196,7 +196,7 @@ fn get_metadata_section(os: os,\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);\n     }\n-    ret option::none::<@[u8]>;\n+    ret option::none::<@[u8]/~>;\n }\n \n fn meta_section_name(os: os) -> str {"}, {"sha": "28eddf2b238c5e1e29d819402ea9623b3cbcc112", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -17,7 +17,7 @@ export parse_bounds_data;\n // Callback to translate defs to strs or back:\n type conv_did = fn(ast::def_id) -> ast::def_id;\n \n-type pstate = {data: @[u8], crate: int, mut pos: uint, tcx: ty::ctxt};\n+type pstate = {data: @[u8]/~, crate: int, mut pos: uint, tcx: ty::ctxt};\n \n fn peek(st: @pstate) -> char {\n     st.data[st.pos] as char\n@@ -50,7 +50,7 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n }\n \n \n-fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+fn parse_ty_data(data: @[u8]/~, crate_num: int, pos: uint, tcx: ty::ctxt,\n                  conv: conv_did) -> ty::t {\n     let st = @{data: data, crate: crate_num, mut pos: pos, tcx: tcx};\n     parse_ty(st, conv)\n@@ -65,13 +65,13 @@ fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n \n fn parse_constrs_gen<T: copy>(st: @pstate, conv: conv_did,\n                                        pser: fn(@pstate)\n-  -> ast::constr_arg_general_<T>) -> [@ty::constr_general<T>] {\n-    let mut rslt: [@ty::constr_general<T>] = [];\n+  -> ast::constr_arg_general_<T>) -> [@ty::constr_general<T>]/~ {\n+    let mut rslt: [@ty::constr_general<T>]/~ = []/~;\n     alt peek(st) {\n       ':' {\n         loop {\n           next(st);\n-          rslt += [parse_constr(st, conv, pser)];\n+          rslt += [parse_constr(st, conv, pser)]/~;\n           if peek(st) != ';' { break; }\n         }\n       }\n@@ -80,27 +80,27 @@ fn parse_constrs_gen<T: copy>(st: @pstate, conv: conv_did,\n     rslt\n }\n \n-fn parse_constrs(st: @pstate, conv: conv_did) -> [@ty::constr] {\n+fn parse_constrs(st: @pstate, conv: conv_did) -> [@ty::constr]/~ {\n     parse_constrs_gen(st, conv, parse_constr_arg)\n }\n \n-fn parse_ty_constrs(st: @pstate, conv: conv_did) -> [@ty::type_constr] {\n+fn parse_ty_constrs(st: @pstate, conv: conv_did) -> [@ty::type_constr]/~ {\n     parse_constrs_gen(st, conv, parse_ty_constr_arg)\n }\n \n fn parse_path(st: @pstate) -> @ast::path {\n-    let mut idents: [ast::ident] = [];\n+    let mut idents: [ast::ident]/~ = []/~;\n     fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n-    idents += [parse_ident_(st, is_last)];\n+    idents += [parse_ident_(st, is_last)]/~;\n     loop {\n         alt peek(st) {\n           ':' { next(st); next(st); }\n           c {\n             if c == '(' {\n                 ret @{span: ast_util::dummy_sp(),\n                       global: false, idents: idents,\n-                      rp: none, types: []};\n-            } else { idents += [parse_ident_(st, is_last)]; }\n+                      rp: none, types: []/~};\n+            } else { idents += [parse_ident_(st, is_last)]/~; }\n           }\n         }\n     };\n@@ -124,7 +124,7 @@ fn parse_constr_arg(st: @pstate) -> ast::fn_constr_arg {\n         /*\n           else {\n           auto lit = parse_lit(st, conv, ',');\n-          args += [respan(st.span, ast::carg_lit(lit))];\n+          args += [respan(st.span, ast::carg_lit(lit))]/~;\n           }\n         */\n       }\n@@ -143,15 +143,15 @@ fn parse_constr<T: copy>(st: @pstate, conv: conv_did,\n     -> @ty::constr_general<T> {\n     // FIXME: use real spans and not a bogus one (#2407)\n     let sp = ast_util::dummy_sp();\n-    let mut args: [@sp_constr_arg<T>] = [];\n+    let mut args: [@sp_constr_arg<T>]/~ = []/~;\n     let pth = parse_path(st);\n     let mut ignore: char = next(st);\n     assert (ignore == '(');\n     let def = parse_def(st, conv);\n     let mut an_arg: constr_arg_general_<T>;\n     loop {\n         an_arg = pser(st);\n-        args += [@respan(sp, an_arg)];\n+        args += [@respan(sp, an_arg)]/~;\n         ignore = next(st);\n         if ignore != ';' { break; }\n     }\n@@ -197,8 +197,8 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n     let self_ty = parse_opt(st) {|| parse_ty(st, conv) };\n \n     assert next(st) == '[';\n-    let mut params: [ty::t] = [];\n-    while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n+    let mut params: [ty::t]/~ = []/~;\n+    while peek(st) != ']' { params += [parse_ty(st, conv)]/~; }\n     st.pos = st.pos + 1u;\n \n     ret {self_r: self_r,\n@@ -320,18 +320,18 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       'R' {\n         assert (next(st) == '[');\n-        let mut fields: [ty::field] = [];\n+        let mut fields: [ty::field]/~ = []/~;\n         while peek(st) != ']' {\n             let name = @parse_str(st, '=');\n-            fields += [{ident: name, mt: parse_mt(st, conv)}];\n+            fields += [{ident: name, mt: parse_mt(st, conv)}]/~;\n         }\n         st.pos = st.pos + 1u;\n         ret ty::mk_rec(st.tcx, fields);\n       }\n       'T' {\n         assert (next(st) == '[');\n-        let mut params = [];\n-        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n+        let mut params = []/~;\n+        while peek(st) != ']' { params += [parse_ty(st, conv)]/~; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tup(st.tcx, params);\n       }\n@@ -403,8 +403,8 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n }\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n-    let mut def = [];\n-    while peek(st) != '|' { def += [next_byte(st)]; }\n+    let mut def = []/~;\n+    while peek(st) != '|' { def += [next_byte(st)]/~; }\n     st.pos = st.pos + 1u;\n     ret conv(parse_def_id(def));\n }\n@@ -446,7 +446,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     let proto = parse_proto(next(st));\n     let purity = parse_purity(next(st));\n     assert (next(st) == '[');\n-    let mut inputs: [ty::arg] = [];\n+    let mut inputs: [ty::arg]/~ = []/~;\n     while peek(st) != ']' {\n         let mode = alt check peek(st) {\n           '&' { ast::by_mutbl_ref }\n@@ -456,7 +456,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n           '#' { ast::by_val }\n         };\n         st.pos += 1u;\n-        inputs += [{mode: ast::expl(mode), ty: parse_ty(st, conv)}];\n+        inputs += [{mode: ast::expl(mode), ty: parse_ty(st, conv)}]/~;\n     }\n     st.pos += 1u; // eat the ']'\n     let cs = parse_constrs(st, conv);\n@@ -467,7 +467,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n \n \n // Rust metadata parsing\n-fn parse_def_id(buf: [u8]) -> ast::def_id {\n+fn parse_def_id(buf: [u8]/~) -> ast::def_id {\n     let mut colon_idx = 0u;\n     let len = vec::len(buf);\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n@@ -491,23 +491,23 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n     ret {crate: crate_num, node: def_num};\n }\n \n-fn parse_bounds_data(data: @[u8], start: uint,\n+fn parse_bounds_data(data: @[u8]/~, start: uint,\n                      crate_num: int, tcx: ty::ctxt, conv: conv_did)\n-    -> @[ty::param_bound] {\n+    -> @[ty::param_bound]/~ {\n     let st = @{data: data, crate: crate_num, mut pos: start, tcx: tcx};\n     parse_bounds(st, conv)\n }\n \n-fn parse_bounds(st: @pstate, conv: conv_did) -> @[ty::param_bound] {\n-    let mut bounds = [];\n+fn parse_bounds(st: @pstate, conv: conv_did) -> @[ty::param_bound]/~ {\n+    let mut bounds = []/~;\n     loop {\n         bounds += [alt check next(st) {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }\n           'K' { ty::bound_const }\n           'I' { ty::bound_iface(parse_ty(st, conv)) }\n           '.' { break; }\n-        }];\n+        }]/~;\n     }\n     @bounds\n }"}, {"sha": "3f7c6ee648c45f4d0ffef74cf9cfbd90e229e22b", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -395,7 +395,7 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n     });\n }\n \n-fn enc_bounds(w: io::writer, cx: @ctxt, bs: @[ty::param_bound]) {\n+fn enc_bounds(w: io::writer, cx: @ctxt, bs: @[ty::param_bound]/~) {\n     for vec::each(*bs) {|bound|\n         alt bound {\n           ty::bound_send { w.write_char('S'); }"}, {"sha": "e463f371bf5ecb4f0de22f22e5829223d9c2a1e7", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -540,7 +540,7 @@ impl helpers for ebml::writer {\n         e::write_type(ecx, self, ty)\n     }\n \n-    fn emit_tys(ecx: @e::encode_ctxt, tys: [ty::t]) {\n+    fn emit_tys(ecx: @e::encode_ctxt, tys: [ty::t]/~) {\n         self.emit_from_vec(tys) {|ty|\n             e::write_type(ecx, self, ty)\n         }\n@@ -741,11 +741,11 @@ impl decoder for ebml::ebml_deserializer {\n             {|a|xcx.tr_def_id(a)})\n     }\n \n-    fn read_tys(xcx: extended_decode_ctxt) -> [ty::t] {\n+    fn read_tys(xcx: extended_decode_ctxt) -> [ty::t]/~ {\n         self.read_to_vec {|| self.read_ty(xcx) }\n     }\n \n-    fn read_bounds(xcx: extended_decode_ctxt) -> @[ty::param_bound] {\n+    fn read_bounds(xcx: extended_decode_ctxt) -> @[ty::param_bound]/~ {\n         tydecode::parse_bounds_data(\n             self.parent.data, self.pos, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n             {|a|xcx.tr_def_id(a)})\n@@ -861,7 +861,7 @@ type fake_session = ();\n \n #[cfg(test)]\n impl of fake_ext_ctxt for fake_session {\n-    fn cfg() -> ast::crate_cfg { [] }\n+    fn cfg() -> ast::crate_cfg { []/~ }\n     fn parse_sess() -> parse::parse_sess { parse::new_parse_sess(none) }\n }\n \n@@ -924,13 +924,13 @@ fn test_simplification() {\n     let item_in = ast::ii_item(#ast(item) {\n         fn new_int_alist<B: copy>() -> alist<int, B> {\n             fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-            ret {eq_fn: eq_int, mut data: []};\n+            ret {eq_fn: eq_int, mut data: []/~};\n         }\n     });\n     let item_out = simplify_ast(item_in);\n     let item_exp = ast::ii_item(#ast(item) {\n         fn new_int_alist<B: copy>() -> alist<int, B> {\n-            ret {eq_fn: eq_int, mut data: []};\n+            ret {eq_fn: eq_int, mut data: []/~};\n         }\n     });\n     alt (item_out, item_exp) {"}, {"sha": "af8e1860e5392bb228785af46aabbda1c828a4e8", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -23,7 +23,7 @@ enum check_loan_ctxt = @{\n     // we are in a ctor, we track the self id\n     mut in_ctor: bool,\n     mut declared_purity: ast::purity,\n-    mut fn_args: @[ast::node_id]\n+    mut fn_args: @[ast::node_id]/~\n };\n \n // if we are enforcing purity, why are we doing so?\n@@ -45,7 +45,7 @@ fn check_loans(bccx: borrowck_ctxt,\n                                  reported: int_hash(),\n                                  mut in_ctor: false,\n                                  mut declared_purity: ast::impure_fn,\n-                                 mut fn_args: @[]});\n+                                 mut fn_args: @[]/~});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n                             visit_local: check_loans_in_local,\n                             visit_block: check_loans_in_block,\n@@ -473,7 +473,7 @@ impl methods for check_loan_ctxt {\n                   callee: option<@ast::expr>,\n                   callee_id: ast::node_id,\n                   callee_span: span,\n-                  args: [@ast::expr]) {\n+                  args: [@ast::expr]/~) {\n         alt self.purity(expr.id) {\n           none {}\n           some(pc) {\n@@ -618,15 +618,15 @@ fn check_loans_in_expr(expr: @ast::expr,\n                         none,\n                         ast_util::op_expr_callee_id(expr),\n                         expr.span,\n-                        [rval]);\n+                        [rval]/~);\n       }\n       ast::expr_unary(*) | ast::expr_index(*)\n       if self.bccx.method_map.contains_key(expr.id) {\n         self.check_call(expr,\n                         none,\n                         ast_util::op_expr_callee_id(expr),\n                         expr.span,\n-                        []);\n+                        []/~);\n       }\n       _ { }\n     }"}, {"sha": "5c4b804164cd532086fb4df9c570ef5cf0c17fb6", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -86,12 +86,11 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 // passing the buck onto us to enforce this)\n                 //\n                 // FIXME (#2493): this handling is not really adequate.\n-                // For example, if there is a type like, {f: [int]}, we\n+                // For example, if there is a type like, {f: [int]/~}, we\n                 // will ignore it, but we ought to be requiring it to be\n                 // immutable (whereas something like {f:int} would be\n                 // fine).\n                 //\n-\n                 alt opt_deref_kind(arg_ty.ty) {\n                   some(deref_ptr(region_ptr)) |\n                   some(deref_ptr(unsafe_ptr)) {\n@@ -281,7 +280,7 @@ impl methods for gather_loan_ctxt {\n           }\n           none {\n             self.req_maps.req_loan_map.insert(\n-                scope_id, @dvec::from_vec([mut loans]));\n+                scope_id, @dvec::from_vec([mut loans]/~));\n           }\n         }\n     }"}, {"sha": "07bf22aedce2308602ddb8573a4369bdc21b416e", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -60,7 +60,7 @@ fn check_capture_clause(tcx: ty::ctxt,\n fn compute_capture_vars(tcx: ty::ctxt,\n                         fn_expr_id: ast::node_id,\n                         fn_proto: ast::proto,\n-                        cap_clause: ast::capture_clause) -> [capture_var] {\n+                        cap_clause: ast::capture_clause) -> [capture_var]/~ {\n     let freevars = freevars::get_freevars(tcx, fn_expr_id);\n     let cap_map = map::int_hash();\n \n@@ -119,7 +119,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n         }\n     }\n \n-    let mut result = [];\n-    for cap_map.each_value { |cap_var| result += [cap_var]; }\n+    let mut result = []/~;\n+    for cap_map.each_value { |cap_var| result += [cap_var]/~; }\n     ret result;\n }"}, {"sha": "e9681c2d8cf13c2d49d05a9be25dcac5c3ae59d0", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -36,18 +36,18 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n }\n \n // Check for unreachable patterns\n-fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n-    let mut seen = [];\n+fn check_arms(tcx: ty::ctxt, arms: [arm]/~) {\n+    let mut seen = []/~;\n     for arms.each {|arm|\n         for arm.pats.each {|pat|\n-            let v = [pat];\n+            let v = [pat]/~;\n             alt is_useful(tcx, seen, v) {\n               not_useful {\n                 tcx.sess.span_err(pat.span, \"unreachable pattern\");\n               }\n               _ {}\n             }\n-            if option::is_none(arm.guard) { seen += [v]; }\n+            if option::is_none(arm.guard) { seen += [v]/~; }\n         }\n     }\n }\n@@ -59,8 +59,8 @@ fn raw_pat(p: @pat) -> @pat {\n     }\n }\n \n-fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n-    let ext = alt is_useful(tcx, vec::map(pats, {|p| [p]}), [wild()]) {\n+fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]/~) {\n+    let ext = alt is_useful(tcx, vec::map(pats, {|p| [p]/~}), [wild()]/~) {\n       not_useful { ret; } // This is good, wildcard pattern isn't reachable\n       useful_ { none }\n       useful(ty, ctor) {\n@@ -89,7 +89,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n     tcx.sess.span_err(sp, msg);\n }\n \n-type matrix = [[@pat]];\n+type matrix = [[@pat]/~]/~;\n \n enum useful { useful(ty::t, ctor), useful_, not_useful }\n \n@@ -111,7 +111,7 @@ enum ctor {\n // checking (if a wildcard pattern is useful in relation to a matrix, the\n // matrix isn't exhaustive).\n \n-fn is_useful(tcx: ty::ctxt, m: matrix, v: [@pat]) -> useful {\n+fn is_useful(tcx: ty::ctxt, m: matrix, v: [@pat]/~) -> useful {\n     if m.len() == 0u { ret useful_; }\n     if m[0].len() == 0u { ret not_useful; }\n     let real_pat = alt vec::find(m, {|r| r[0].id != 0}) {\n@@ -167,7 +167,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: [@pat]) -> useful {\n     }\n }\n \n-fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: [@pat], ctor: ctor,\n+fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: [@pat]/~, ctor: ctor,\n                           arity: uint, lty: ty::t) -> useful {\n     let ms = vec::filter_map(m, {|r| specialize(tcx, r, ctor, arity, lty)});\n     alt is_useful(tcx, ms, option::get(specialize(tcx, v, ctor, arity, lty))){\n@@ -217,10 +217,10 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n         ret some(single);\n       }\n       ty::ty_enum(eid, _) {\n-        let mut found = [];\n+        let mut found = []/~;\n         for m.each {|r|\n             option::iter(pat_ctor_id(tcx, r[0])) {|id|\n-                if !vec::contains(found, id) { found += [id]; }\n+                if !vec::contains(found, id) { found += [id]/~; }\n             }\n         }\n         let variants = ty::enum_variants(tcx, eid);\n@@ -270,8 +270,8 @@ fn wild() -> @pat {\n     @{id: 0, node: pat_wild, span: syntax::ast_util::dummy_sp()}\n }\n \n-fn specialize(tcx: ty::ctxt, r: [@pat], ctor_id: ctor, arity: uint,\n-              left_ty: ty::t) -> option<[@pat]> {\n+fn specialize(tcx: ty::ctxt, r: [@pat]/~, ctor_id: ctor, arity: uint,\n+              left_ty: ty::t) -> option<[@pat]/~> {\n     let r0 = raw_pat(r[0]);\n     alt r0.node {\n       pat_wild { some(vec::from_elem(arity, wild()) + vec::tail(r)) }\n@@ -308,7 +308,7 @@ fn specialize(tcx: ty::ctxt, r: [@pat], ctor_id: ctor, arity: uint,\n         some(args + vec::tail(r))\n       }\n       pat_tup(args) { some(args + vec::tail(r)) }\n-      pat_box(a) | pat_uniq(a) { some([a] + vec::tail(r)) }\n+      pat_box(a) | pat_uniq(a) { some([a]/~ + vec::tail(r)) }\n       pat_lit(expr) {\n         let e_v = eval_const_expr(tcx, expr);\n         let match = alt check ctor_id {\n@@ -334,7 +334,7 @@ fn specialize(tcx: ty::ctxt, r: [@pat], ctor_id: ctor, arity: uint,\n     }\n }\n \n-fn default(tcx: ty::ctxt, r: [@pat]) -> option<[@pat]> {\n+fn default(tcx: ty::ctxt, r: [@pat]/~) -> option<[@pat]/~> {\n     if is_wild(tcx, r[0]) { some(vec::tail(r)) }\n     else { none }\n }"}, {"sha": "bbfc16b64b2e3a5b24c1bb6da40b8e6c6b93aa1c", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -23,7 +23,7 @@ type freevar_entry = {\n     def: ast::def, //< The variable being accessed free.\n     span: span     //< First span where it is accessed (there can be multiple)\n };\n-type freevar_info = @[@freevar_entry];\n+type freevar_info = @[@freevar_entry]/~;\n type freevar_map = hashmap<ast::node_id, freevar_info>;\n \n // Searches through part of the AST for all references to locals or\n@@ -34,7 +34,7 @@ type freevar_map = hashmap<ast::node_id, freevar_info>;\n fn collect_freevars(def_map: resolve::def_map, blk: ast::blk)\n     -> freevar_info {\n     let seen = int_hash();\n-    let refs = @mut [];\n+    let refs = @mut []/~;\n \n     fn ignore_item(_i: @ast::item, &&_depth: int, _v: visit::vt<int>) { }\n \n@@ -64,7 +64,7 @@ fn collect_freevars(def_map: resolve::def_map, blk: ast::blk)\n                       if i == depth { // Made it to end of loop\n                         let dnum = ast_util::def_id_of_def(def).node;\n                         if !seen.contains_key(dnum) {\n-                           *refs += [@{def:def, span:expr.span}];\n+                           *refs += [@{def:def, span:expr.span}]/~;\n                            seen.insert(dnum, ());\n                         }\n                       }"}, {"sha": "b34880de3f2dec323530d1117cb7e68a5d788e41", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -40,15 +40,15 @@ import lint::{non_implicitly_copyable_typarams,implicit_copies};\n // types.\n \n fn kind_to_str(k: kind) -> str {\n-    let mut kinds = [];\n+    let mut kinds = []/~;\n     if ty::kind_lteq(kind_const(), k) {\n-        kinds += [\"const\"];\n+        vec::push(kinds, \"const\");\n     }\n     if ty::kind_can_be_copied(k) {\n-        kinds += [\"copy\"];\n+        vec::push(kinds, \"copy\");\n     }\n     if ty::kind_can_be_sent(k) {\n-        kinds += [\"send\"];\n+        vec::push(kinds, \"send\");\n     }\n     str::connect(kinds, \" \")\n }\n@@ -160,7 +160,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n         let cap_clause = alt fk {\n           visit::fk_anon(_, cc) | visit::fk_fn_block(cc) { cc }\n           visit::fk_item_fn(*) | visit::fk_method(*) |\n-          visit::fk_ctor(*) | visit::fk_dtor(*) { @[] }\n+          visit::fk_ctor(*) | visit::fk_dtor(*) { @[]/~ }\n         };\n         let captured_vars = (*cap_clause).map { |cap_item|\n             let cap_def = cx.tcx.def_map.get(cap_item.id);"}, {"sha": "3c93bf5f5c5328a3d07405cbeec1d68f7544938c", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -134,7 +134,7 @@ fn get_lint_dict() -> lint_dict {\n            desc: \"implicit copies of non implicitly copyable data\",\n            default: warn})\n \n-    ];\n+    ]/~;\n     hash_from_strs(v)\n }\n \n@@ -206,7 +206,7 @@ impl methods for ctxt {\n           current lint context, call the provided function, then reset the\n           warnings in effect to their previous state.\n     \"]\n-    fn with_warn_attrs(attrs: [ast::attribute], f: fn(ctxt)) {\n+    fn with_warn_attrs(attrs: [ast::attribute]/~, f: fn(ctxt)) {\n \n         let mut new_ctxt = self;\n \n@@ -358,7 +358,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n     fn check_native_fn(cx: ty::ctxt, fn_id: ast::node_id,\n                        decl: ast::fn_decl) {\n         let tys = vec::map(decl.inputs) {|a| a.ty };\n-        for vec::each(tys + [decl.output]) {|ty|\n+        for vec::each(tys + [decl.output]/~) {|ty|\n             alt ty.node {\n               ast::ty_path(_, id) {\n                 alt cx.def_map.get(id) {\n@@ -456,7 +456,7 @@ fn check_item_old_vecs(cx: ty::ctxt, it: @ast::item) {\n               }\n               ast::ty_path(@{span: _, global: _, idents: ids,\n                              rp: none, types: _}, _)\n-              if ids == [@\"str\"] && (! uses_vstore.contains_key(t.id)) {\n+              if ids == [@\"str\"]/~ && (! uses_vstore.contains_key(t.id)) {\n                 cx.sess.span_lint(\n                     old_strs, t.id, it.id,\n                     t.span, \"deprecated str type\");"}, {"sha": "836dced30c44089d7094576c440b2bb0f6b6f358", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -220,9 +220,9 @@ class ir_maps {\n     let live_node_map: hashmap<node_id, live_node>;\n     let variable_map: hashmap<node_id, variable>;\n     let field_map: hashmap<ident, variable>;\n-    let capture_map: hashmap<node_id, @[capture_info]>;\n-    let mut var_kinds: [var_kind];\n-    let mut lnks: [live_node_kind];\n+    let capture_map: hashmap<node_id, @[capture_info]/~>;\n+    let mut var_kinds: [var_kind]/~;\n+    let mut lnks: [live_node_kind]/~;\n \n     new(tcx: ty::ctxt, method_map: typeck::method_map,\n         last_use_map: last_use_map) {\n@@ -236,13 +236,13 @@ class ir_maps {\n         self.variable_map = int_hash();\n         self.capture_map = int_hash();\n         self.field_map = box_str_hash();\n-        self.var_kinds = [];\n-        self.lnks = [];\n+        self.var_kinds = []/~;\n+        self.lnks = []/~;\n     }\n \n     fn add_live_node(lnk: live_node_kind) -> live_node {\n         let ln = live_node(self.num_live_nodes);\n-        self.lnks += [lnk];\n+        self.lnks += [lnk]/~;\n         self.num_live_nodes += 1u;\n \n         #debug[\"%s is of kind %?\", ln.to_str(), lnk];\n@@ -259,7 +259,7 @@ class ir_maps {\n \n     fn add_variable(vk: var_kind) -> variable {\n         let v = variable(self.num_vars);\n-        self.var_kinds += [vk];\n+        self.var_kinds += [vk]/~;\n         self.num_vars += 1u;\n \n         alt vk {\n@@ -297,11 +297,11 @@ class ir_maps {\n         }\n     }\n \n-    fn set_captures(node_id: node_id, +cs: [capture_info]) {\n+    fn set_captures(node_id: node_id, +cs: [capture_info]/~) {\n         self.capture_map.insert(node_id, @cs);\n     }\n \n-    fn captures(expr: @expr) -> @[capture_info] {\n+    fn captures(expr: @expr) -> @[capture_info]/~ {\n         alt self.capture_map.find(expr.id) {\n           some(caps) {caps}\n           none {\n@@ -435,7 +435,7 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n         let proto = ty::ty_fn_proto(ty::expr_ty(self.tcx, expr));\n         let cvs = capture::compute_capture_vars(self.tcx, expr.id,\n                                                 proto, cap_clause);\n-        let mut call_caps = [];\n+        let mut call_caps = []/~;\n         for cvs.each { |cv|\n             alt relevant_def(cv.def) {\n               some(rv) {\n@@ -444,7 +444,7 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n                   cap_move | cap_drop {true} // var must be dead afterwards\n                   cap_copy | cap_ref {false} // var can still be used\n                 };\n-                call_caps += [{ln: cv_ln, is_move: is_move, rv: rv}];\n+                call_caps += [{ln: cv_ln, is_move: is_move, rv: rv}]/~;\n               }\n               none {}\n             }\n@@ -511,8 +511,8 @@ class liveness {\n     let tcx: ty::ctxt;\n     let ir: @ir_maps;\n     let s: specials;\n-    let successors: [mut live_node];\n-    let users: [mut users];\n+    let successors: [mut live_node]/~;\n+    let users: [mut users]/~;\n     let mut break_ln: live_node;\n     let mut cont_ln: live_node;\n \n@@ -887,7 +887,8 @@ class liveness {\n         succ\n     }\n \n-    fn propagate_through_exprs(exprs: [@expr], succ: live_node) -> live_node {\n+    fn propagate_through_exprs(exprs: [@expr]/~,\n+                               succ: live_node) -> live_node {\n         exprs.foldr(succ) { |expr, succ|\n             self.propagate_through_expr(expr, succ)\n         }\n@@ -1095,7 +1096,7 @@ class liveness {\n           expr_log(_, l, r) |\n           expr_index(l, r) |\n           expr_binary(_, l, r) {\n-            self.propagate_through_exprs([l, r], succ)\n+            self.propagate_through_exprs([l, r]/~, succ)\n           }\n \n           expr_assert(e) |"}, {"sha": "fa5ab8fc5c53042351252bc55812f4671221954a", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -49,8 +49,8 @@ fn pat_bindings(dm: resolve::def_map, pat: @pat,\n     }\n }\n \n-fn pat_binding_ids(dm: resolve::def_map, pat: @pat) -> [node_id] {\n-    let mut found = [];\n-    pat_bindings(dm, pat) {|b_id, _sp, _pt| found += [b_id]; };\n+fn pat_binding_ids(dm: resolve::def_map, pat: @pat) -> [node_id]/~ {\n+    let mut found = []/~;\n+    pat_bindings(dm, pat) {|b_id, _sp, _pt| found += [b_id]/~; };\n     ret found;\n }"}, {"sha": "6b79b3c6aa82ff7da5c324c3e015a500097a3854", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -214,14 +214,14 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n                            scope_b: ast::node_id) -> option<ast::node_id> {\n \n     fn ancestors_of(region_map: region_map, scope: ast::node_id)\n-                    -> [ast::node_id] {\n-        let mut result = [scope];\n+                    -> [ast::node_id]/~ {\n+        let mut result = [scope]/~;\n         let mut scope = scope;\n         loop {\n             alt region_map.find(scope) {\n                 none { ret result; }\n                 some(superscope) {\n-                    result += [superscope];\n+                    result += [superscope]/~;\n                     scope = superscope;\n                 }\n             }\n@@ -235,7 +235,7 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n     let mut a_index = vec::len(a_ancestors) - 1u;\n     let mut b_index = vec::len(b_ancestors) - 1u;\n \n-    // Here, [ab]_ancestors is a vector going from narrow to broad.\n+    // Here, [ab]/~_ancestors is a vector going from narrow to broad.\n     // The end of each vector will be the item where the scope is\n     // defined; if there are any common ancestors, then the tails of\n     // the vector will be the same.  So basically we want to walk"}, {"sha": "340f05e4616bb7a4e550a058684981e74c5138e0", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 75, "deletions": 73, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -34,13 +34,13 @@ enum scope {\n     scope_toplevel,\n     scope_crate,\n     scope_item(@ast::item),\n-    scope_bare_fn(ast::fn_decl, node_id, [ast::ty_param]),\n-    scope_fn_expr(ast::fn_decl, node_id, [ast::ty_param]),\n+    scope_bare_fn(ast::fn_decl, node_id, [ast::ty_param]/~),\n+    scope_fn_expr(ast::fn_decl, node_id, [ast::ty_param]/~),\n     scope_native_item(@ast::native_item),\n     scope_loop(@ast::local), // there's only 1 decl per loop.\n     scope_block(ast::blk, @mut uint, @mut uint),\n     scope_arm(ast::arm),\n-    scope_method(node_id, [ast::ty_param]),\n+    scope_method(node_id, [ast::ty_param]/~),\n }\n \n type scopes = @list<scope>;\n@@ -50,13 +50,13 @@ fn top_scope() -> scopes {\n }\n \n enum import_state {\n-    todo(ast::ident, @[ast::ident], span, scopes),\n-    is_glob(@[ast::ident], scopes, span),\n+    todo(ast::ident, @[ast::ident]/~, span, scopes),\n+    is_glob(@[ast::ident]/~, scopes, span),\n     resolving(span),\n     resolved(option<def>, /* value */\n              option<def>, /* type */\n              option<def>, /* module */\n-             @[@_impl], /* impls */\n+             @[@_impl]/~, /* impls */\n              /* used for reporting unused import warning */\n              ast::ident, span),\n }\n@@ -88,7 +88,7 @@ enum mod_index_entry {\n     mie_item(@ast::item),\n     mie_native_item(@ast::native_item),\n     mie_enum_variant(/* variant index */uint,\n-                     /*parts of enum item*/ [variant],\n+                     /*parts of enum item*/ [variant]/~,\n                     node_id, span),\n }\n \n@@ -101,7 +101,7 @@ type indexed_mod = {\n     m: option<ast::_mod>,\n     index: mod_index,\n     glob_imports: dvec<glob_imp_def>,\n-    mut globbed_exports: [ident],\n+    mut globbed_exports: [ident]/~,\n     glob_imported_names: hashmap<ident, glob_import_state>,\n     path: str\n };\n@@ -111,12 +111,12 @@ type indexed_mod = {\n    control.*/\n \n type def_map = hashmap<node_id, def>;\n-type ext_map = hashmap<def_id, [ident]>;\n+type ext_map = hashmap<def_id, [ident]/~>;\n type impl_map = hashmap<node_id, iscopes>;\n-type impl_cache = hashmap<def_id, option<@[@_impl]>>;\n+type impl_cache = hashmap<def_id, option<@[@_impl]/~>>;\n \n type exp = {reexp: bool, id: def_id};\n-type exp_map = hashmap<node_id, [exp]>;\n+type exp_map = hashmap<node_id, [exp]/~>;\n \n type env =\n     {cstore: cstore::cstore,\n@@ -125,15 +125,15 @@ type env =\n      imports: hashmap<node_id, import_state>,\n      exp_map: exp_map,\n      mod_map: hashmap<node_id, @indexed_mod>,\n-     block_map: hashmap<node_id, [glob_imp_def]>,\n+     block_map: hashmap<node_id, [glob_imp_def]/~>,\n      ext_map: ext_map,\n      impl_map: impl_map,\n      impl_cache: impl_cache,\n      ext_cache: ext_hash,\n      used_imports: {mut track: bool,\n-                    mut data: [node_id]},\n+                    mut data: [node_id]/~},\n      reported: dvec<{ident: ast::ident, sc: scope}>,\n-     mut ignored_imports: [node_id],\n+     mut ignored_imports: [node_id]/~,\n      mut current_tp: option<uint>,\n      mut resolve_unexported: bool,\n      sess: session};\n@@ -181,9 +181,9 @@ fn create_env(sess: session, amap: ast_map::map) -> @env {\n       impl_map: int_hash(),\n       impl_cache: new_def_hash(),\n       ext_cache: new_ext_hash(),\n-      used_imports: {mut track: false, mut data:  []},\n+      used_imports: {mut track: false, mut data:  []/~},\n       reported: dvec(),\n-      mut ignored_imports: [],\n+      mut ignored_imports: []/~,\n       mut current_tp: none,\n       mut resolve_unexported: false,\n       sess: sess}\n@@ -243,7 +243,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n               ast::view_path_list(mod_path, idents, _) {\n                 for idents.each {|ident|\n                     let t = todo(ident.node.name,\n-                                 @(mod_path.idents + [ident.node.name]),\n+                                 @(mod_path.idents + [ident.node.name]/~),\n                                  ident.span, sc);\n                     e.imports.insert(ident.node.id, t);\n                 }\n@@ -271,7 +271,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                              @{m: some(md),\n                                index: index_mod(md),\n                                glob_imports: dvec(),\n-                               mut globbed_exports: [],\n+                               mut globbed_exports: []/~,\n                                glob_imported_names: box_str_hash(),\n                                path: path_from_scope(sc, *i.ident)});\n           }\n@@ -280,7 +280,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                              @{m: none::<ast::_mod>,\n                                index: index_nmod(nmd),\n                                glob_imports: dvec(),\n-                               mut globbed_exports: [],\n+                               mut globbed_exports: []/~,\n                                glob_imported_names: box_str_hash(),\n                                path: path_from_scope(sc, *i.ident)});\n           }\n@@ -305,8 +305,8 @@ fn map_crate(e: @env, c: @ast::crate) {\n                       }\n                       scope_block(b, _, _) {\n                         let globs = alt e.block_map.find(b.node.id) {\n-                          some(globs) { globs + [glob] }\n-                          none { [glob] }\n+                          some(globs) { globs + [glob]/~ }\n+                          none { [glob]/~ }\n                         };\n                         e.block_map.insert(b.node.id, globs);\n                       }\n@@ -339,7 +339,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                      @{m: some(c.node.module),\n                        index: index_mod(c.node.module),\n                        glob_imports: dvec(),\n-                       mut globbed_exports: [],\n+                       mut globbed_exports: []/~,\n                        glob_imported_names: box_str_hash(),\n                        path: \"\"});\n \n@@ -476,7 +476,8 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           _ { }\n         }\n     }\n-    fn walk_tps(e: @env, tps: [ast::ty_param], &&sc: scopes, v: vt<scopes>) {\n+    fn walk_tps(e: @env, tps: [ast::ty_param]/~,\n+                &&sc: scopes, v: vt<scopes>) {\n         let outer_current_tp = e.current_tp;\n         let mut current = 0u;\n         for tps.each {|tp|\n@@ -557,7 +558,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n         for methods.each {|m|\n             v.visit_ty_params(m.tps, sc, v);\n             let msc = @cons(scope_method(m.self_id, tps + m.tps), sc);\n-            v.visit_fn(visit::fk_method(m.ident, [], m),\n+            v.visit_fn(visit::fk_method(m.ident, []/~, m),\n                        m.decl, m.body, m.span, m.id, msc, v);\n         }\n       }\n@@ -625,7 +626,7 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n     // is this a main fn declaration?\n     alt fk {\n       visit::fk_item_fn(nm, _) {\n-        if is_main_name([ast_map::path_name(nm)]) &&\n+        if is_main_name([ast_map::path_name(nm)]/~) &&\n            !e.sess.building_library {\n             // This is a main function -- set it in the session\n             // as the main ID\n@@ -643,9 +644,9 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n       | visit::fk_ctor(_, tps, _, _) | visit::fk_dtor(tps, _, _) {\n         scope_bare_fn(decl, id, tps) }\n       visit::fk_anon(ast::proto_bare, _) {\n-        scope_bare_fn(decl, id, []) }\n+        scope_bare_fn(decl, id, []/~) }\n       visit::fk_anon(_, _) | visit::fk_fn_block(_) {\n-        scope_fn_expr(decl, id, []) }\n+        scope_fn_expr(decl, id, []/~) }\n     };\n \n     visit::visit_fn(fk, decl, body, sp, id, @cons(scope, sc), v);\n@@ -713,7 +714,7 @@ fn visit_local_with_scope(e: @env, loc: @local, &&sc: scopes, v:vt<scopes>) {\n }\n \n \n-fn follow_import(e: env, &&sc: scopes, path: [ident], sp: span) ->\n+fn follow_import(e: env, &&sc: scopes, path: [ident]/~, sp: span) ->\n    option<def> {\n     let path_len = vec::len(path);\n     let mut dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n@@ -757,10 +758,10 @@ fn resolve_constr(e: @env, c: @ast::constr, &&sc: scopes, _v: vt<scopes>) {\n \n // Import resolution\n fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n-                  ids: [ast::ident], sp: codemap::span, &&sc: scopes) {\n+                  ids: [ast::ident]/~, sp: codemap::span, &&sc: scopes) {\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n                 name: ast::ident, lookup: fn(namespace) -> option<def>,\n-                impls: [@_impl]) {\n+                impls: [@_impl]/~) {\n         let val = lookup(ns_val), typ = lookup(ns_type),\n             md = lookup(ns_module);\n         if is_none(val) && is_none(typ) && is_none(md) &&\n@@ -772,21 +773,21 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n     }\n     // Temporarily disable this import and the imports coming after during\n     // resolution of this import.\n-    fn find_imports_after(e: env, id: node_id, &&sc: scopes) -> [node_id] {\n-        fn lst(my_id: node_id, vis: [@view_item]) -> [node_id] {\n-            let mut imports = [], found = false;\n+    fn find_imports_after(e: env, id: node_id, &&sc: scopes) -> [node_id]/~ {\n+        fn lst(my_id: node_id, vis: [@view_item]/~) -> [node_id]/~ {\n+            let mut imports = []/~, found = false;\n             for vis.each {|vi|\n                 iter_effective_import_paths(*vi) {|vp|\n                     alt vp.node {\n                       view_path_simple(_, _, id)\n                       | view_path_glob(_, id) {\n                         if id == my_id { found = true; }\n-                        if found { imports += [id]; }\n+                        if found { imports += [id]/~; }\n                       }\n                       view_path_list(_, ids, _) {\n                         for ids.each {|id|\n                             if id.node.id == my_id { found = true; }\n-                            if found { imports += [id.node.id]; }\n+                            if found { imports += [id.node.id]/~; }\n                         }\n                       }\n                     }\n@@ -822,7 +823,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n     let end_id = ids[n_idents - 1u];\n     if n_idents == 1u {\n         register(e, n_id, in_scope(sc), sp, name,\n-                 {|ns| lookup_in_scope(e, sc, sp, end_id, ns, true) }, []);\n+                 {|ns| lookup_in_scope(e, sc, sp, end_id, ns, true) }, []/~);\n     } else {\n         alt lookup_in_scope(e, sc, sp, ids[0], ns_module, true) {\n           none {\n@@ -832,7 +833,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n             let mut dcur = dcur_, i = 1u;\n             loop {\n                 if i == n_idents - 1u {\n-                    let mut impls = [];\n+                    let mut impls = []/~;\n                     find_impls_in_mod(e, dcur, impls, some(end_id));\n                     register(e, n_id, in_mod(dcur), sp, name, {|ns|\n                         lookup_in_mod(e, dcur, sp, end_id, ns, outside)\n@@ -860,7 +861,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n     // import\n     alt e.imports.find(n_id) {\n       some(resolving(sp)) {\n-        e.imports.insert(n_id, resolved(none, none, none, @[], @\"\", sp));\n+        e.imports.insert(n_id, resolved(none, none, none, @[]/~, @\"\", sp));\n       }\n       _ { }\n     }\n@@ -910,7 +911,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n             path = @(e.mod_map.get(did.node).path + *path);\n         } else if did.node != ast::crate_node_id {\n             let paths = e.ext_map.get(did);\n-            path = @str::connect((paths + [path]).map({|x|*x}), \"::\");\n+            path = @str::connect((paths + [path]/~).map({|x|*x}), \"::\");\n         }\n       }\n     }\n@@ -1110,7 +1111,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n         ret none;\n     }\n     let mut left_fn = false;\n-    let mut closing = [];\n+    let mut closing = []/~;\n     // Used to determine whether self is in scope\n     let mut left_fn_level2 = false;\n     let mut sc = sc;\n@@ -1150,7 +1151,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n         } else if ns != ns_module {\n                 left_fn = scope_is_fn(hd);\n                 alt scope_closes(hd) {\n-                  some(node_id) { closing += [node_id]; }\n+                  some(node_id) { closing += [node_id]/~; }\n                   _ { }\n                 }\n             }\n@@ -1160,7 +1161,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n     };\n }\n \n-fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n+fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param]/~)\n     -> option<def> {\n     let mut n = 0u;\n     for ty_params.each {|tp|\n@@ -1183,7 +1184,7 @@ fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option<node_id> {\n }\n \n fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n-                ty_params: [ast::ty_param],\n+                ty_params: [ast::ty_param]/~,\n                 ns: namespace) -> option<def> {\n     alt ns {\n       ns_val {\n@@ -1367,7 +1368,7 @@ fn lookup_in_mod(e: env, m: def, sp: span, name: ident, ns: namespace,\n         // examining a module in an external crate\n         let cached = e.ext_cache.find({did: defid, ident: name, ns: ns});\n         if !is_none(cached) { ret cached; }\n-        let mut path = [name];\n+        let mut path = [name]/~;\n         if defid.node != ast::crate_node_id {\n             path = cstore::get_path(e.cstore, defid) + path;\n         }\n@@ -1420,7 +1421,7 @@ fn lookup_import(e: env, n_id: node_id, ns: namespace) -> option<def> {\n       }\n       resolved(val, typ, md, _, _, _) {\n         if e.used_imports.track {\n-            e.used_imports.data += [n_id];\n+            e.used_imports.data += [n_id]/~;\n         }\n         ret alt ns { ns_val { val } ns_type { typ } ns_module { md } };\n       }\n@@ -1490,7 +1491,7 @@ fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n     ret lookup_glob_in_mod(e, inf, sp, id, ns, outside);\n }\n \n-fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n+fn lookup_in_globs(e: env, globs: [glob_imp_def]/~, sp: span, id: ident,\n                    ns: namespace, dr: dir) -> option<def> {\n     fn lookup_in_mod_(e: env, def: glob_imp_def, sp: span, name: ident,\n                       ns: namespace, dr: dir) -> option<glob_imp_def> {\n@@ -1595,7 +1596,7 @@ fn add_to_index(index: hashmap<ident, @list<mod_index_entry>>, id: ident,\n     }\n }\n \n-fn index_view_items(view_items: [@ast::view_item],\n+fn index_view_items(view_items: [@ast::view_item]/~,\n                     index: hashmap<ident, @list<mod_index_entry>>) {\n     for view_items.each {|vi|\n         alt vi.node {\n@@ -1684,7 +1685,7 @@ fn ns_for_def(d: def) -> namespace {\n     }\n }\n \n-fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n+fn lookup_external(e: env, cnum: int, ids: [ident]/~, ns: namespace) ->\n    option<def> {\n     let mut result = none;\n     for csearch::lookup_defs(e.sess.cstore, cnum, ids).each {|d|\n@@ -1757,9 +1758,9 @@ fn mie_span(mie: mod_index_entry) -> span {\n }\n \n fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n-    fn typaram_names(tps: [ast::ty_param]) -> [ident] {\n-        let mut x: [ast::ident] = [];\n-        for tps.each {|tp| x += [tp.ident]; }\n+    fn typaram_names(tps: [ast::ty_param]/~) -> [ident]/~ {\n+        let mut x: [ast::ident]/~ = []/~;\n+        for tps.each {|tp| x += [tp.ident]/~; }\n         ret x;\n     }\n     visit::visit_item(i, x, v);\n@@ -1914,7 +1915,7 @@ fn add_name(ch: checker, sp: span, name: ident) {\n     ch.seen.push(name);\n }\n \n-fn ensure_unique<T>(e: env, sp: span, elts: [T], id: fn(T) -> ident,\n+fn ensure_unique<T>(e: env, sp: span, elts: [T]/~, id: fn(T) -> ident,\n                     kind: str) {\n     let ch = checker(e, kind);\n     for elts.each {|elt| add_name(ch, sp, id(elt)); }\n@@ -1942,7 +1943,7 @@ fn check_exports(e: @env) {\n                         let defs =\n                             [ found_def_item(item, ns_val),\n                              found_def_item(item, ns_type),\n-                             found_def_item(item, ns_module) ];\n+                             found_def_item(item, ns_module) ]/~;\n                         for defs.each {|d|\n                             alt d {\n                               some(def) {\n@@ -1984,9 +1985,10 @@ fn check_exports(e: @env) {\n     fn add_export(e: @env, export_id: node_id, target_id: def_id,\n                   reexp: bool) {\n         let found = alt e.exp_map.find(export_id) {\n-          some(f) { f } none { [] }\n+          some(f) { f } none { []/~ }\n         };\n-        e.exp_map.insert(export_id, found + [{reexp: reexp, id: target_id}]);\n+        e.exp_map.insert(export_id,\n+                         found + [{reexp: reexp, id: target_id}]/~);\n     }\n \n     fn check_export(e: @env, ident: ident, _mod: @indexed_mod,\n@@ -2053,7 +2055,7 @@ fn check_exports(e: @env) {\n \n     fn check_export_enum_list(e: @env, export_id: node_id, _mod: @indexed_mod,\n                               span: codemap::span, id: ast::ident,\n-                              ids: [ast::path_list_ident]) {\n+                              ids: [ast::path_list_ident]/~) {\n         let parent_id = check_enum_ok(e, span, id, _mod);\n         add_export(e, export_id, local_def(parent_id), false);\n         for ids.each {|variant_id|\n@@ -2119,7 +2121,7 @@ fn check_exports(e: @env) {\n                 if ! glob_is_re_exported.contains_key(id) { cont; }\n                 iter_mod(*e, glob.def,\n                          glob.path.span, outside) {|ident, def|\n-                    _mod.globbed_exports += [ident];\n+                    _mod.globbed_exports += [ident]/~;\n                     maybe_add_reexport(e, id, some(def));\n                 }\n             }\n@@ -2140,8 +2142,8 @@ type method_info = {did: def_id, n_tps: uint, ident: ast::ident};\n    is the ident of the iface that's being implemented\n    * methods: the item's methods\n */\n-type _impl = {did: def_id, ident: ast::ident, methods: [@method_info]};\n-type iscopes = @list<@[@_impl]>;\n+type _impl = {did: def_id, ident: ast::ident, methods: [@method_info]/~};\n+type iscopes = @list<@[@_impl]/~>;\n \n fn resolve_impls(e: @env, c: @ast::crate) {\n     visit::visit_crate(*c, @nil, visit::mk_vt(@{\n@@ -2153,9 +2155,9 @@ fn resolve_impls(e: @env, c: @ast::crate) {\n }\n \n fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n-                           &impls: [@_impl], sc: option<iscopes>) {\n+                           &impls: [@_impl]/~, sc: option<iscopes>) {\n     fn lookup_imported_impls(e: env, id: node_id,\n-                             act: fn(@[@_impl])) {\n+                             act: fn(@[@_impl]/~)) {\n         alt e.imports.get(id) {\n           resolved(_, _, _, is, _, _) { act(is); }\n           todo(name, path, span, scopes) {\n@@ -2171,14 +2173,14 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n     iter_effective_import_paths(*vi) { |vp|\n         alt vp.node {\n           ast::view_path_simple(name, pt, id) {\n-            let mut found = [];\n+            let mut found = []/~;\n             if vec::len(pt.idents) == 1u {\n                 option::iter(sc) {|sc|\n                     list::iter(sc) {|level|\n                         if vec::len(found) == 0u {\n                             for vec::each(*level) {|imp|\n                                 if imp.ident == pt.idents[0] {\n-                                    found += [@{ident: name with *imp}];\n+                                    found += [@{ident: name with *imp}]/~;\n                                 }\n                             }\n                             if vec::len(found) > 0u { impls += found; }\n@@ -2188,7 +2190,7 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n             } else {\n                 lookup_imported_impls(e, id) {|is|\n                     for vec::each(*is) {|i|\n-                        impls += [@{ident: name with *i}];\n+                        impls += [@{ident: name with *i}]/~;\n                     }\n                 }\n             }\n@@ -2220,7 +2222,7 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n   item is a class; and none otherwise. Each record describes\n   one interface implemented by i.\n  */\n-fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n+fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl]/~,\n                       name: option<ident>,\n                       ck_exports: option<@indexed_mod>) {\n     alt i.node {\n@@ -2236,7 +2238,7 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n                             @{did: local_def(m.id),\n                               n_tps: vec::len(m.tps),\n                               ident: m.ident}\n-                        })}];\n+                        })}]/~;\n         }\n       }\n       ast::item_class(tps, ifces, items, _, _, _) {\n@@ -2250,14 +2252,14 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n                          methods: vec::map(mthds, {|m|\n                                       @{did: local_def(m.id),\n                                           n_tps: n_tps + m.tps.len(),\n-                                          ident: m.ident}})}];\n+                                          ident: m.ident}})}]/~;\n           }\n       }\n       _ {}\n     }\n }\n \n-fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n+fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl]/~,\n                            name: option<ident>) {\n     let mut cached;\n     alt e.impl_cache.find(defid) {\n@@ -2266,7 +2268,7 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n       none {\n         e.impl_cache.insert(defid, none);\n         cached = if defid.crate == ast::local_crate {\n-            let mut tmp = [];\n+            let mut tmp = []/~;\n             let mi = e.mod_map.get(defid.node);\n             let md = option::get(mi.m);\n             for md.view_items.each {|vi|\n@@ -2285,14 +2287,14 @@ fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n     alt name {\n       some(n) {\n         for vec::each(*cached) {|im|\n-            if n == im.ident { impls += [im]; }\n+            if n == im.ident { impls += [im]/~; }\n         }\n       }\n       _ { impls += *cached; }\n     }\n }\n \n-fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n+fn find_impls_in_mod(e: env, m: def, &impls: [@_impl]/~,\n                      name: option<ident>) {\n     alt m {\n       ast::def_mod(defid) {\n@@ -2304,7 +2306,7 @@ fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n \n fn visit_block_with_impl_scope(e: @env, b: ast::blk, &&sc: iscopes,\n                                v: vt<iscopes>) {\n-    let mut impls = [];\n+    let mut impls = []/~;\n     for b.node.view_items.each {|vi|\n         find_impls_in_view_item(*e, vi, impls, some(sc));\n     }\n@@ -2322,7 +2324,7 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, &&sc: iscopes,\n \n fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, id: node_id,\n                              &&sc: iscopes, v: vt<iscopes>) {\n-    let mut impls = [];\n+    let mut impls = []/~;\n     for m.view_items.each {|vi|\n         find_impls_in_view_item(*e, vi, impls, some(sc));\n     }"}, {"sha": "b7da0b825404f3c2a08995fafa749b5b44b67985", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 65, "deletions": 63, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -77,7 +77,7 @@ fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n     core::unreachable();\n }\n \n-type bind_map = [{ident: ast::ident, val: ValueRef}];\n+type bind_map = [{ident: ast::ident, val: ValueRef}]/~;\n fn assoc(key: ast::ident, list: bind_map) -> option<ValueRef> {\n     for vec::each(list) {|elt|\n         if str::eq(*elt.ident, *key) { ret some(elt.val); }\n@@ -86,12 +86,12 @@ fn assoc(key: ast::ident, list: bind_map) -> option<ValueRef> {\n }\n \n type match_branch =\n-    @{pats: [@ast::pat],\n+    @{pats: [@ast::pat]/~,\n       bound: bind_map,\n       data: @{bodycx: block,\n               guard: option<@ast::expr>,\n               id_map: pat_id_map}};\n-type match = [match_branch];\n+type match = [match_branch]/~;\n \n fn has_nested_bindings(m: match, col: uint) -> bool {\n     for vec::each(m) {|br|\n@@ -104,28 +104,28 @@ fn has_nested_bindings(m: match, col: uint) -> bool {\n }\n \n fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n-    let mut result = [];\n+    let mut result = []/~;\n     for vec::each(m) {|br|\n       alt br.pats[col].node {\n           ast::pat_ident(name, some(inner)) {\n-            let pats = vec::slice(br.pats, 0u, col) + [inner] +\n+            let pats = vec::slice(br.pats, 0u, col) + [inner]/~ +\n                 vec::slice(br.pats, col + 1u, br.pats.len());\n             result += [@{pats: pats,\n                         bound: br.bound + [{ident: path_to_ident(name),\n-                                val: val}]\n-                         with *br}];\n+                                val: val}]/~\n+                         with *br}]/~;\n           }\n-          _ { result += [br]; }\n+          _ { result += [br]/~; }\n         }\n     }\n     result\n }\n \n-type enter_pat = fn(@ast::pat) -> option<[@ast::pat]>;\n+type enter_pat = fn(@ast::pat) -> option<[@ast::pat]/~>;\n \n fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n                e: enter_pat) -> match {\n-    let mut result = [];\n+    let mut result = []/~;\n     for vec::each(m) {|br|\n         alt e(br.pats[col]) {\n           some(sub) {\n@@ -134,11 +134,11 @@ fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n             let self = br.pats[col];\n             let bound = alt self.node {\n               ast::pat_ident(name, none) if !pat_is_variant(dm, self) {\n-                br.bound + [{ident: path_to_ident(name), val: val}]\n+                br.bound + [{ident: path_to_ident(name), val: val}]/~\n               }\n               _ { br.bound }\n             };\n-            result += [@{pats: pats, bound: bound with *br}];\n+            result += [@{pats: pats, bound: bound with *br}]/~;\n           }\n           none { }\n         }\n@@ -149,9 +149,9 @@ fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n fn enter_default(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     enter_match(dm, m, col, val) {|p|\n         alt p.node {\n-          ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) { some([]) }\n+          ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) { some([]/~) }\n           ast::pat_ident(_, none) if !pat_is_variant(dm, p) {\n-            some([])\n+            some([]/~)\n           }\n           _ { none }\n         }\n@@ -170,33 +170,33 @@ fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n             else { none }\n           }\n           ast::pat_ident(_, none) if pat_is_variant(tcx.def_map, p) {\n-            if opt_eq(tcx, variant_opt(tcx, p.id), opt) { some([]) }\n+            if opt_eq(tcx, variant_opt(tcx, p.id), opt) { some([]/~) }\n             else { none }\n           }\n           ast::pat_lit(l) {\n-            if opt_eq(tcx, lit(l), opt) { some([]) } else { none }\n+            if opt_eq(tcx, lit(l), opt) { some([]/~) } else { none }\n           }\n           ast::pat_range(l1, l2) {\n-            if opt_eq(tcx, range(l1, l2), opt) { some([]) } else { none }\n+            if opt_eq(tcx, range(l1, l2), opt) { some([]/~) } else { none }\n           }\n           _ { some(vec::from_elem(variant_size, dummy)) }\n         }\n     }\n }\n \n-fn enter_rec(dm: def_map, m: match, col: uint, fields: [ast::ident],\n+fn enter_rec(dm: def_map, m: match, col: uint, fields: [ast::ident]/~,\n              val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     enter_match(dm, m, col, val) {|p|\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n-            let mut pats = [];\n+            let mut pats = []/~;\n             for vec::each(fields) {|fname|\n                 let mut pat = dummy;\n                 for vec::each(fpats) {|fpat|\n                     if str::eq(*fpat.ident, *fname) { pat = fpat.pat; break; }\n                 }\n-                pats += [pat];\n+                pats += [pat]/~;\n             }\n             some(pats)\n           }\n@@ -220,8 +220,8 @@ fn enter_box(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     enter_match(dm, m, col, val) {|p|\n         alt p.node {\n-          ast::pat_box(sub) { some([sub]) }\n-          _ { some([dummy]) }\n+          ast::pat_box(sub) { some([sub]/~) }\n+          _ { some([dummy]/~) }\n         }\n     }\n }\n@@ -230,13 +230,13 @@ fn enter_uniq(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     enter_match(dm, m, col, val) {|p|\n         alt p.node {\n-          ast::pat_uniq(sub) { some([sub]) }\n-          _ { some([dummy]) }\n+          ast::pat_uniq(sub) { some([sub]/~) }\n+          _ { some([dummy]/~) }\n         }\n     }\n }\n \n-fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n+fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt]/~ {\n     fn add_to_set(tcx: ty::ctxt, &&set: dvec<opt>, val: opt) {\n         if set.any({|l| opt_eq(tcx, l, val)}) {ret;}\n         set.push(val);\n@@ -262,7 +262,7 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n \n fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n                         vdefs: {enm: def_id, var: def_id}, val: ValueRef) ->\n-   {vals: [ValueRef], bcx: block} {\n+   {vals: [ValueRef]/~, bcx: block} {\n     let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = alt check ty::get(node_id_type(bcx, pat_id)).struct {\n@@ -275,7 +275,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     if size > 0u && (*variants).len() != 1u {\n         let enumptr =\n             PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-        blobptr = GEPi(bcx, enumptr, [0u, 1u]);\n+        blobptr = GEPi(bcx, enumptr, [0u, 1u]/~);\n     }\n     let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n@@ -286,14 +286,14 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     ret {vals: args, bcx: bcx};\n }\n \n-fn collect_record_fields(m: match, col: uint) -> [ast::ident] {\n-    let mut fields: [ast::ident] = [];\n+fn collect_record_fields(m: match, col: uint) -> [ast::ident]/~ {\n+    let mut fields: [ast::ident]/~ = []/~;\n     for vec::each(m) {|br|\n         alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n             for vec::each(fs) {|f|\n                 if !vec::any(fields, {|x| str::eq(*f.ident, *x)}) {\n-                    fields += [f.ident];\n+                    fields += [f.ident]/~;\n                 }\n             }\n           }\n@@ -375,8 +375,8 @@ fn pick_col(m: match) -> uint {\n     ret best_col;\n }\n \n-fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n-                    chk: option<mk_fail>, &exits: [exit_node]) {\n+fn compile_submatch(bcx: block, m: match, vals: [ValueRef]/~,\n+                    chk: option<mk_fail>, &exits: [exit_node]/~) {\n     let _icx = bcx.insn_ctxt(\"alt::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;\n@@ -405,7 +405,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n         }\n         if !bcx.unreachable {\n             exits += [{bound: m[0].bound, from: bcx.llbb,\n-                       to: data.bodycx.llbb}];\n+                       to: data.bodycx.llbb}]/~;\n         }\n         Br(bcx, data.bodycx.llbb);\n         ret;\n@@ -433,10 +433,10 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     // Separate path for extracting and binding record fields\n     if rec_fields.len() > 0u {\n         let fields = ty::get_fields(node_id_type(bcx, pat_id));\n-        let mut rec_vals = [];\n+        let mut rec_vals = []/~;\n         for vec::each(rec_fields) {|field_name|\n             let ix = option::get(ty::field_idx(field_name, fields));\n-            rec_vals += [GEPi(bcx, val, [0u, ix])];\n+            rec_vals += [GEPi(bcx, val, [0u, ix]/~)]/~;\n         }\n         compile_submatch(bcx, enter_rec(dm, m, col, rec_fields, val),\n                          rec_vals + vals_left, chk, exits);\n@@ -449,9 +449,9 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n           ty::ty_tup(elts) { elts.len() }\n           _ { ccx.sess.bug(\"non-tuple type in tuple pattern\"); }\n         };\n-        let mut tup_vals = [], i = 0u;\n+        let mut tup_vals = []/~, i = 0u;\n         while i < n_tup_elts {\n-            tup_vals += [GEPi(bcx, val, [0u, i])];\n+            tup_vals += [GEPi(bcx, val, [0u, i]/~)]/~;\n             i += 1u;\n         }\n         compile_submatch(bcx, enter_tup(dm, m, col, val, n_tup_elts),\n@@ -463,18 +463,20 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     if any_box_pat(m, col) {\n         let box = Load(bcx, val);\n         let box_no_addrspace = non_gc_box_cast(bcx, box);\n-        let unboxed = GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n-        compile_submatch(bcx, enter_box(dm, m, col, val), [unboxed]\n+        let unboxed =\n+            GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]/~);\n+        compile_submatch(bcx, enter_box(dm, m, col, val), [unboxed]/~\n                          + vals_left, chk, exits);\n         ret;\n     }\n \n     if any_uniq_pat(m, col) {\n         let box = Load(bcx, val);\n         let box_no_addrspace = non_gc_box_cast(bcx, box);\n-        let unboxed = GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n+        let unboxed =\n+            GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]/~);\n         compile_submatch(bcx, enter_uniq(dm, m, col, val),\n-                         [unboxed] + vals_left, chk, exits);\n+                         [unboxed]/~ + vals_left, chk, exits);\n         ret;\n     }\n \n@@ -491,7 +493,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n             } else {\n                 let enumptr =\n                     PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-                let discrimptr = GEPi(bcx, enumptr, [0u, 0u]);\n+                let discrimptr = GEPi(bcx, enumptr, [0u, 0u]/~);\n                 test_val = Load(bcx, discrimptr);\n                 kind = switch;\n             }\n@@ -567,7 +569,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n             }\n         } else if kind == compare { Br(bcx, else_cx.llbb); }\n         let mut size = 0u;\n-        let mut unpacked = [];\n+        let mut unpacked = []/~;\n         alt opt {\n           var(_, vdef) {\n             let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n@@ -591,18 +593,18 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n }\n \n // Returns false for unreachable blocks\n-fn make_phi_bindings(bcx: block, map: [exit_node],\n+fn make_phi_bindings(bcx: block, map: [exit_node]/~,\n                      ids: pat_util::pat_id_map) -> bool {\n     let _icx = bcx.insn_ctxt(\"alt::make_phi_bindings\");\n     let our_block = bcx.llbb as uint;\n     let mut success = true, bcx = bcx;\n     for ids.each {|name, node_id|\n-        let mut llbbs = [];\n-        let mut vals = [];\n+        let mut llbbs = []/~;\n+        let mut vals = []/~;\n         for vec::each(map) {|ex|\n             if ex.to as uint == our_block {\n                 alt assoc(name, ex.bound) {\n-                  some(val) { llbbs += [ex.from]; vals += [val]; }\n+                  some(val) { llbbs += [ex.from]/~; vals += [val]/~; }\n                   none { }\n                 }\n             }\n@@ -621,7 +623,7 @@ fn make_phi_bindings(bcx: block, map: [exit_node],\n fn trans_alt(bcx: block,\n              alt_expr: @ast::expr,\n              expr: @ast::expr,\n-             arms: [ast::arm],\n+             arms: [ast::arm]/~,\n              mode: ast::alt_mode,\n              dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"alt::trans_alt\");\n@@ -630,24 +632,24 @@ fn trans_alt(bcx: block,\n     }\n }\n \n-fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n+fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm]/~,\n                    mode: ast::alt_mode, dest: dest) -> block {\n     let _icx = scope_cx.insn_ctxt(\"alt::trans_alt_inner\");\n     let bcx = scope_cx, tcx = bcx.tcx();\n-    let mut bodies = [], match = [];\n+    let mut bodies = []/~, match = []/~;\n \n     let {bcx, val, _} = trans_temp_expr(bcx, expr);\n     if bcx.unreachable { ret bcx; }\n \n     for vec::each(arms) {|a|\n         let body = scope_block(bcx, a.body.info(), \"case_body\");\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n-        bodies += [body];\n+        bodies += [body]/~;\n         for vec::each(a.pats) {|p|\n-            match += [@{pats: [p],\n-                        bound: [],\n+            match += [@{pats: [p]/~,\n+                        bound: []/~,\n                         data: @{bodycx: body, guard: a.guard,\n-                                id_map: id_map}}];\n+                                id_map: id_map}}]/~;\n         }\n     }\n \n@@ -667,21 +669,21 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n       }\n       ast::alt_exhaustive { none }\n     };\n-    let mut exit_map = [];\n+    let mut exit_map = []/~;\n     let t = node_id_type(bcx, expr.id);\n     let spilled = spill_if_immediate(bcx, val, t);\n-    compile_submatch(bcx, match, [spilled], mk_fail, exit_map);\n+    compile_submatch(bcx, match, [spilled]/~, mk_fail, exit_map);\n \n-    let mut arm_cxs = [], arm_dests = [], i = 0u;\n+    let mut arm_cxs = []/~, arm_dests = []/~, i = 0u;\n     for vec::each(arms) {|a|\n         let body_cx = bodies[i];\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         if make_phi_bindings(body_cx, exit_map, id_map) {\n             let arm_dest = dup_for_join(dest);\n-            arm_dests += [arm_dest];\n+            arm_dests += [arm_dest]/~;\n             let mut arm_cx = trans_block(body_cx, a.body, arm_dest);\n             arm_cx = trans_block_cleanups(arm_cx, body_cx);\n-            arm_cxs += [arm_cx];\n+            arm_cxs += [arm_cx]/~;\n         }\n         i += 1u;\n     }\n@@ -726,28 +728,28 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         let rec_fields = ty::get_fields(node_id_type(bcx, pat.id));\n         for vec::each(fields) {|f|\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n-            let fldptr = GEPi(bcx, val, [0u, ix]);\n+            let fldptr = GEPi(bcx, val, [0u, ix]/~);\n             bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n         }\n       }\n       ast::pat_tup(elems) {\n         let mut i = 0u;\n         for vec::each(elems) {|elem|\n-            let fldptr = GEPi(bcx, val, [0u, i]);\n+            let fldptr = GEPi(bcx, val, [0u, i]/~);\n             bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);\n             i += 1u;\n         }\n       }\n       ast::pat_box(inner) {\n         let box = Load(bcx, val);\n         let unboxed =\n-            GEPi(bcx, box, [0u, abi::box_field_body]);\n+            GEPi(bcx, box, [0u, abi::box_field_body]/~);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_uniq(inner) {\n         let box = Load(bcx, val);\n         let unboxed =\n-            GEPi(bcx, box, [0u, abi::box_field_body]);\n+            GEPi(bcx, box, [0u, abi::box_field_body]/~);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) { }"}, {"sha": "5c36bcc7cdac4bd6f359c75a3614f26e0e6fe8b6", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 195, "deletions": 184, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -102,7 +102,7 @@ impl ccx_icx for @crate_ctxt {\n     fn insn_ctxt(s: str) -> icx_popper {\n         #debug(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n-            *self.stats.llvm_insn_ctxt += [s];\n+            *self.stats.llvm_insn_ctxt += [s]/~;\n         }\n         icx_popper(self)\n     }\n@@ -120,8 +120,8 @@ impl fcx_icx for fn_ctxt {\n     }\n }\n \n-fn join_returns(parent_cx: block, in_cxs: [block],\n-                in_ds: [dest], out_dest: dest) -> block {\n+fn join_returns(parent_cx: block, in_cxs: [block]/~,\n+                in_ds: [dest]/~, out_dest: dest) -> block {\n     let out = sub_block(parent_cx, \"join\");\n     let mut reachable = false, i = 0u, phi = none;\n     for vec::each(in_cxs) {|cx|\n@@ -172,7 +172,7 @@ fn log_fn_time(ccx: @crate_ctxt, name: str, start: time::timespec,\n                end: time::timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n-    *ccx.stats.fn_times += [{ident: name, time: elapsed}];\n+    *ccx.stats.fn_times += [{ident: name, time: elapsed}]/~;\n }\n \n \n@@ -228,29 +228,29 @@ fn get_simple_extern_fn(cx: block,\n }\n \n fn trans_native_call(cx: block, externs: hashmap<str, ValueRef>,\n-                     llmod: ModuleRef, name: str, args: [ValueRef]) ->\n+                     llmod: ModuleRef, name: str, args: [ValueRef]/~) ->\n    ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_native_call\");\n     let n = args.len() as int;\n     let llnative: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n-    let mut call_args: [ValueRef] = [];\n+    let mut call_args: [ValueRef]/~ = []/~;\n     for vec::each(args) {|a|\n-        call_args += [a];\n+        call_args += [a]/~;\n     }\n     ret Call(cx, llnative, call_args);\n }\n \n fn trans_free(cx: block, v: ValueRef) -> block {\n     let _icx = cx.insn_ctxt(\"trans_free\");\n-    Call(cx, cx.ccx().upcalls.free, [PointerCast(cx, v, T_ptr(T_i8()))]);\n+    Call(cx, cx.ccx().upcalls.free, [PointerCast(cx, v, T_ptr(T_i8()))]/~);\n     cx\n }\n \n fn trans_unique_free(cx: block, v: ValueRef) -> block {\n     let _icx = cx.insn_ctxt(\"trans_shared_free\");\n     Call(cx, cx.ccx().upcalls.exchange_free,\n-         [PointerCast(cx, v, T_ptr(T_i8()))]);\n+         [PointerCast(cx, v, T_ptr(T_i8()))]/~);\n     ret cx;\n }\n \n@@ -304,7 +304,7 @@ fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"ptr_offs\");\n     let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n-    InBoundsGEP(bcx, raw, [sz])\n+    InBoundsGEP(bcx, raw, [sz]/~)\n }\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n@@ -322,7 +322,7 @@ fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n // @llblobptr is the data part of a enum value; its actual type\n // is meaningless, as it will be cast away.\n fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n-            variant_id: ast::def_id, ty_substs: [ty::t],\n+            variant_id: ast::def_id, ty_substs: [ty::t]/~,\n             ix: uint) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"GEP_enum\");\n     let ccx = bcx.ccx();\n@@ -334,7 +334,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     });\n     let typed_blobptr = PointerCast(bcx, llblobptr,\n                                     T_ptr(T_struct(arg_lltys)));\n-    GEPi(bcx, typed_blobptr, [0u, ix])\n+    GEPi(bcx, typed_blobptr, [0u, ix]/~)\n }\n \n // Returns a pointer to the body for the box. The box may be an opaque\n@@ -348,7 +348,7 @@ fn opaque_box_body(bcx: block,\n     let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n-    let bodyptr = GEPi(bcx, boxptr, [1u]);\n+    let bodyptr = GEPi(bcx, boxptr, [1u]/~);\n     PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n }\n \n@@ -376,7 +376,7 @@ fn malloc_raw_dyn(bcx: block, t: ty::t, heap: heap,\n     lazily_emit_all_tydesc_glue(ccx, copy static_ti);\n \n     // Allocate space:\n-    let rval = Call(bcx, upcall, [lltydesc, size]);\n+    let rval = Call(bcx, upcall, [lltydesc, size]/~);\n     ret PointerCast(bcx, rval, llty);\n }\n \n@@ -394,7 +394,7 @@ fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef) ->\n     let _icx = bcx.insn_ctxt(\"malloc_general\");\n     let box = malloc_raw_dyn(bcx, t, heap, size);\n     let non_gc_box = non_gc_box_cast(bcx, box);\n-    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n+    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]/~);\n     ret {box: box, body: body};\n }\n \n@@ -462,7 +462,7 @@ fn set_inline_hint(f: ValueRef) {\n                               as c_ulonglong, 0u as c_ulonglong);\n }\n \n-fn set_inline_hint_if_appr(attrs: [ast::attribute],\n+fn set_inline_hint_if_appr(attrs: [ast::attribute]/~,\n                            llfn: ValueRef) {\n     alt attr::find_inline_attr(attrs) {\n       attr::ia_hint { set_inline_hint(llfn); }\n@@ -546,7 +546,7 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n-    let fcx = new_fn_ctxt(ccx, [], llfn, none);\n+    let fcx = new_fn_ctxt(ccx, []/~, llfn, none);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n     // Any nontrivial glue is with values passed *by alias*; this is a\n@@ -628,7 +628,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n                             C_shape(ccx, shape), // shape\n                             shape_tables, // shape_tables\n                             C_int(ccx, 0), // ununsed\n-                            C_int(ccx, 0)]); // unused\n+                            C_int(ccx, 0)]/~); // unused\n \n         let gvar = ti.tydesc;\n         llvm::LLVMSetInitializer(gvar, tydesc);\n@@ -660,7 +660,7 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n         closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_iface(_, _) {\n-        let box = Load(bcx, GEPi(bcx, v, [0u, 1u]));\n+        let box = Load(bcx, GEPi(bcx, v, [0u, 1u]/~));\n         incr_refcnt_of_boxed(bcx, box);\n         bcx\n       }\n@@ -680,7 +680,7 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n     let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     maybe_validate_box(cx, box_ptr);\n-    let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n+    let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]/~);\n     let rc = Load(cx, rc_ptr);\n     let rc = Add(cx, rc, C_int(ccx, 1));\n     Store(cx, rc, rc_ptr);\n@@ -706,14 +706,14 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let bcx = alt ty::get(t).struct {\n       ty::ty_box(body_mt) {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n-        let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n+        let body = GEPi(bcx, v, [0u, abi::box_field_body]/~);\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free(bcx, v)\n       }\n       ty::ty_opaque_box {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n-        let td = Load(bcx, GEPi(bcx, v, [0u, abi::box_field_tydesc]));\n-        let valptr = GEPi(bcx, v, [0u, abi::box_field_body]);\n+        let td = Load(bcx, GEPi(bcx, v, [0u, abi::box_field_tydesc]/~));\n+        let valptr = GEPi(bcx, v, [0u, abi::box_field_body]/~);\n         call_tydesc_glue_full(bcx, valptr, td, abi::tydesc_field_drop_glue,\n                               none);\n         trans_free(bcx, v)\n@@ -752,11 +752,11 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n                     class_did: ast::def_id,\n                     substs: ty::substs) -> block {\n-  let drop_flag = GEPi(bcx, v0, [0u, 0u]);\n+  let drop_flag = GEPi(bcx, v0, [0u, 0u]/~);\n   with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|cx|\n     let mut bcx = cx;\n       // We have to cast v0\n-     let classptr = GEPi(bcx, v0, [0u, 1u]);\n+     let classptr = GEPi(bcx, v0, [0u, 1u]/~);\n      // Find and call the actual destructor\n      let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, class_did, substs.tps);\n      // The second argument is the \"self\" argument for drop\n@@ -767,13 +767,13 @@ fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n      // of the output pointer and the environment (self)\n      assert(params.len() == 2u);\n      let self_arg = PointerCast(bcx, v0, params[1u]);\n-     let args = [bcx.fcx.llretptr, self_arg];\n+     let args = [bcx.fcx.llretptr, self_arg]/~;\n      Call(bcx, dtor_addr, args);\n      // Drop the fields\n      for vec::eachi(ty::class_items_as_mutable_fields(bcx.tcx(), class_did,\n                                                       substs))\n      {|i, fld|\n-        let llfld_a = GEPi(bcx, classptr, [0u, i]);\n+        let llfld_a = GEPi(bcx, classptr, [0u, i]/~);\n         bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n      }\n      Store(bcx, C_u8(0u), drop_flag);\n@@ -814,7 +814,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n         closure::make_fn_glue(bcx, v0, t, drop_ty)\n       }\n       ty::ty_iface(_, _) {\n-        let box = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n+        let box = Load(bcx, GEPi(bcx, v0, [0u, 1u]/~));\n         decr_refcnt_maybe_free(bcx, box, ty::mk_opaque_box(ccx.tcx))\n       }\n       ty::ty_opaque_closure_ptr(ck) {\n@@ -831,7 +831,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n }\n \n fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n-                parent_id: ast::def_id, substs: [ty::t])\n+                parent_id: ast::def_id, substs: [ty::t]/~)\n    -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if (substs.len() > 0u) {\n@@ -861,7 +861,7 @@ fn maybe_validate_box(_cx: block, _box_ptr: ValueRef) {\n     // let ccx = cx.ccx();\n     // warn_not_to_commit(ccx, \"validate_box() is uncommented\");\n     // let raw_box_ptr = PointerCast(cx, box_ptr, T_ptr(T_i8()));\n-    // Call(cx, ccx.upcalls.validate_box, [raw_box_ptr]);\n+    // Call(cx, ccx.upcalls.validate_box, [raw_box_ptr]/~);\n }\n \n fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n@@ -872,7 +872,7 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n     let llbox_ty = T_opaque_box_ptr(ccx);\n     let box_ptr = PointerCast(bcx, box_ptr, llbox_ty);\n     with_cond(bcx, IsNotNull(bcx, box_ptr)) {|bcx|\n-        let rc_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_refcnt]);\n+        let rc_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_refcnt]/~);\n         let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n         Store(bcx, rc, rc_ptr);\n         let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n@@ -978,12 +978,12 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n type val_pair_fn = fn@(block, ValueRef, ValueRef) -> block;\n type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> block;\n \n-fn load_inbounds(cx: block, p: ValueRef, idxs: [uint]) -> ValueRef {\n+fn load_inbounds(cx: block, p: ValueRef, idxs: [uint]/~) -> ValueRef {\n     ret Load(cx, GEPi(cx, p, idxs));\n }\n \n fn store_inbounds(cx: block, v: ValueRef, p: ValueRef,\n-                  idxs: [uint]) {\n+                  idxs: [uint]/~) {\n     Store(cx, v, GEPi(cx, p, idxs));\n }\n \n@@ -993,7 +993,8 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     let _icx = cx.insn_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant(cx: block, a_tup: ValueRef,\n-                    variant: ty::variant_info, tps: [ty::t], tid: ast::def_id,\n+                    variant: ty::variant_info,\n+                    tps: [ty::t]/~, tid: ast::def_id,\n                     f: val_and_ty_fn) -> block {\n         let _icx = cx.insn_ctxt(\"iter_variant\");\n         if variant.args.len() == 0u { ret cx; }\n@@ -1023,7 +1024,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     alt ty::get(t).struct {\n       ty::ty_rec(fields) {\n         for vec::eachi(fields) {|i, fld|\n-            let llfld_a = GEPi(cx, av, [0u, i]);\n+            let llfld_a = GEPi(cx, av, [0u, i]/~);\n             cx = f(cx, llfld_a, fld.mt.ty);\n         }\n       }\n@@ -1034,7 +1035,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       }\n       ty::ty_tup(args) {\n         for vec::eachi(args) {|i, arg|\n-            let llfld_a = GEPi(cx, av, [0u, i]);\n+            let llfld_a = GEPi(cx, av, [0u, i]/~);\n             cx = f(cx, llfld_a, arg);\n         }\n       }\n@@ -1051,8 +1052,8 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let ccx = cx.ccx();\n         let llenumty = T_opaque_enum_ptr(ccx);\n         let av_enum = PointerCast(cx, av, llenumty);\n-        let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]);\n-        let llunion_a_ptr = GEPi(cx, av_enum, [0u, 1u]);\n+        let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]/~);\n+        let llunion_a_ptr = GEPi(cx, av_enum, [0u, 1u]/~);\n         let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n \n         // NB: we must hit the discriminant first so that structural\n@@ -1078,13 +1079,13 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_class(did, substs) {\n           // Take the drop bit into account\n           let classptr = if is_some(ty::ty_dtor(cx.tcx(), did)) {\n-                  GEPi(cx, av, [0u, 1u])\n+                  GEPi(cx, av, [0u, 1u]/~)\n               }\n           else { av };\n         for vec::eachi(ty::class_items_as_mutable_fields(cx.tcx(), did,\n                                                          substs))\n            {|i, fld|\n-               let llfld_a = GEPi(cx, classptr, [0u, i]);\n+               let llfld_a = GEPi(cx, classptr, [0u, i]/~);\n                cx = f(cx, llfld_a, fld.mt.ty);\n            }\n       }\n@@ -1201,15 +1202,15 @@ fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n     let llfn = {\n         alt static_glue_fn {\n           none {\n-            let llfnptr = GEPi(cx, tydesc, [0u, field]);\n+            let llfnptr = GEPi(cx, tydesc, [0u, field]/~);\n             Load(cx, llfnptr)\n           }\n           some(sgf) { sgf }\n         }\n     };\n \n     Call(cx, llfn, [C_null(T_ptr(T_nil())), C_null(T_ptr(T_nil())),\n-                    C_null(T_ptr(T_ptr(cx.ccx().tydesc_type))), llrawptr]);\n+                    C_null(T_ptr(T_ptr(cx.ccx().tydesc_type))), llrawptr]/~);\n }\n \n // See [Note-arg-mode]\n@@ -1235,13 +1236,13 @@ fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     let llrawrhsptr = BitCast(bcx, llrhs, T_ptr(T_i8()));\n     let lltydesc = get_tydesc_simple(bcx.ccx(), t);\n     let lltydescs =\n-        Load(bcx, GEPi(bcx, lltydesc, [0u, abi::tydesc_field_first_param]));\n+        Load(bcx, GEPi(bcx, lltydesc, [0u, abi::tydesc_field_first_param]/~));\n \n     let llfn = bcx.ccx().upcalls.cmp_type;\n \n     let llcmpresultptr = alloca(bcx, T_i1());\n     Call(bcx, llfn, [llcmpresultptr, lltydesc, lltydescs,\n-                     llrawlhsptr, llrawrhsptr, llop]);\n+                     llrawlhsptr, llrawrhsptr, llop]/~);\n     ret Load(bcx, llcmpresultptr);\n }\n \n@@ -1325,7 +1326,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(1i32);\n     let volatile = C_bool(false);\n-    Call(cx, memmove, [dst_ptr, src_ptr, size, align, volatile]);\n+    Call(cx, memmove, [dst_ptr, src_ptr, size, align, volatile]/~);\n }\n \n fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n@@ -1498,7 +1499,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n             bcx, un_expr.info(), fty,\n             expr_ty(bcx, un_expr),\n             {|bcx| impl::trans_method_callee(bcx, callee_id, e, mentry) },\n-            arg_exprs([]), dest);\n+            arg_exprs([]/~), dest);\n       }\n       _ {}\n     }\n@@ -1749,7 +1750,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                 // the expr.\n                 impl::trans_method_callee(bcx, callee_id, dst, origin)\n             },\n-            arg_exprs([src]), save_in(target));\n+            arg_exprs([src]/~), save_in(target));\n \n         ret move_val(bcx, DROP_EXISTING, lhs_res.val,\n                      {bcx: bcx, val: target, kind: owned},\n@@ -1758,7 +1759,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n       _ {}\n     }\n \n-    // Special case for `+= [x]`\n+    // Special case for `+= [x]/~`\n     alt ty::get(t).struct {\n       ty::ty_vec(_) {\n         alt src.node {\n@@ -1826,7 +1827,7 @@ fn autoderef(cx: block, e_id: ast::node_id,\n \n         alt ty::get(t1).struct {\n           ty::ty_box(mt) {\n-            let body = GEPi(cx, v1, [0u, abi::box_field_body]);\n+            let body = GEPi(cx, v1, [0u, abi::box_field_body]/~);\n             t1 = mt.ty;\n \n             // Since we're changing levels of box indirection, we may have\n@@ -1891,7 +1892,8 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n \n     if past_rhs.unreachable { ret store_in_dest(join, lhs, dest); }\n     Br(past_rhs, join.llbb);\n-    let phi = Phi(join, T_bool(), [lhs, rhs], [past_lhs.llbb, past_rhs.llbb]);\n+    let phi =\n+        Phi(join, T_bool(), [lhs, rhs]/~, [past_lhs.llbb, past_rhs.llbb]/~);\n     ret store_in_dest(join, phi, dest);\n }\n \n@@ -1909,7 +1911,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n             {|bcx|\n                 impl::trans_method_callee(bcx, callee_id, lhs, origin)\n             },\n-            arg_exprs([rhs]), dest);\n+            arg_exprs([rhs]/~), dest);\n       }\n       _ {}\n     }\n@@ -1968,7 +1970,8 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n       _ { else_cx }\n     };\n     let else_bcx = trans_block_cleanups(else_bcx, else_cx);\n-    ret join_returns(cx, [then_bcx, else_bcx], [then_dest, else_dest], dest);\n+    ret join_returns(cx,\n+                     [then_bcx, else_bcx]/~, [then_dest, else_dest]/~, dest);\n }\n \n fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n@@ -2052,39 +2055,39 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n }\n \n fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n-    // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n+    // FIXME[mono]/~ could do this recursively. is that worthwhile? (#2529)\n     alt ty::get(ty).struct {\n       ty::ty_box(mt) { some(ty::mk_opaque_box(tcx)) }\n       ty::ty_fn(fty) { some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n                                             proto: fty.proto,\n-                                            inputs: [],\n+                                            inputs: []/~,\n                                             output: ty::mk_nil(tcx),\n                                             ret_style: ast::return_val,\n-                                            constraints: []})) }\n+                                            constraints: []/~})) }\n       ty::ty_iface(_, _) { some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n                                                 proto: ast::proto_box,\n-                                                inputs: [],\n+                                                inputs: []/~,\n                                                 output: ty::mk_nil(tcx),\n                                                 ret_style: ast::return_val,\n-                                                constraints: []})) }\n+                                                constraints: []/~})) }\n       ty::ty_ptr(_) { some(ty::mk_uint(tcx)) }\n       _ { none }\n     }\n }\n \n-fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: [ty::t],\n+fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: [ty::t]/~,\n                 vtables: option<typeck::vtable_res>,\n-                param_uses: option<[type_use::type_uses]>) -> mono_id {\n+                param_uses: option<[type_use::type_uses]/~>) -> mono_id {\n     let precise_param_ids = alt vtables {\n       some(vts) {\n         let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n         let mut i = 0u;\n         vec::map2(*bounds, substs, {|bounds, subst|\n-            let mut v = [];\n+            let mut v = []/~;\n             for vec::each(*bounds) {|bound|\n                 alt bound {\n                   ty::bound_iface(_) {\n-                    v += [impl::vtable_id(ccx, vts[i])];\n+                    vec::push(v, impl::vtable_id(ccx, vts[i]));\n                     i += 1u;\n                   }\n                   _ {}\n@@ -2124,7 +2127,8 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: [ty::t],\n     @{def: item, params: param_ids}\n }\n \n-fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n+fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n+                  real_substs: [ty::t]/~,\n                   vtables: option<typeck::vtable_res>,\n                   ref_id: option<ast::node_id>)\n     -> {val: ValueRef, must_cast: bool} {\n@@ -2204,7 +2208,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n     }\n     ccx.monomorphizing.insert(fn_id, depth + 1u);\n \n-    let pt = *pt + [path_name(@ccx.names(*name))];\n+    let pt = *pt + [path_name(@ccx.names(*name))]/~;\n     let s = mangle_exported_name(ccx, pt, mono_ty);\n \n     let mk_lldecl = {||\n@@ -2252,10 +2256,10 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n       ast_map::node_ctor(nm, tps, ctor, parent_id, _) {\n         // ctors don't have attrs, at least not right now\n         let d = mk_lldecl();\n-        let tp_tys: [ty::t] = ty::ty_params_to_tys(ccx.tcx, tps);\n+        let tp_tys = ty::ty_params_to_tys(ccx.tcx, tps);\n         trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, d,\n                option::get_default(psubsts,\n-                        {tys:tp_tys, vtables: none, bounds: @[]}),\n+                        {tys:tp_tys, vtables: none, bounds: @[]/~}),\n                          fn_id.node, parent_id, ctor.span);\n         d\n       }\n@@ -2348,7 +2352,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             if (*impl_bnds).len() + mth.tps.len() == 0u {\n                 let llfn = get_item_val(ccx, mth.id);\n                 let path = ty::item_path(ccx.tcx, impl_did) +\n-                    [path_name(mth.ident)];\n+                    [path_name(mth.ident)]/~;\n                 trans_fn(ccx, path, mth.decl, mth.body,\n                          llfn, impl_self(impl_ty), none, mth.id);\n             }\n@@ -2373,7 +2377,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n }\n \n fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n-                        tys: [ty::t], vtables: option<typeck::vtable_res>)\n+                        tys: [ty::t]/~, vtables: option<typeck::vtable_res>)\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"lval_static_fn_inner\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n@@ -2509,7 +2513,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n             // Nullary variant.\n             let enum_ty = node_id_type(cx, id);\n             let llenumptr = alloc_ty(cx, enum_ty);\n-            let lldiscrimptr = GEPi(cx, llenumptr, [0u, 0u]);\n+            let lldiscrimptr = GEPi(cx, llenumptr, [0u, 0u]/~);\n             let lldiscrim_gv = lookup_discriminant(ccx, vid);\n             let lldiscrim = Load(cx, lldiscrim_gv);\n             Store(cx, lldiscrim, lldiscrimptr);\n@@ -2569,9 +2573,9 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n        (If any other code does the same thing, that's\n        a bug */\n     let val = if deref {\n-        GEPi(bcx, GEPi(bcx, val, [0u, 1u]), [0u, ix])\n+        GEPi(bcx, GEPi(bcx, val, [0u, 1u]/~), [0u, ix]/~)\n     }\n-    else { GEPi(bcx, val, [0u, ix]) };\n+    else { GEPi(bcx, val, [0u, ix]/~) };\n \n     ret {bcx: bcx, val: val, kind: owned};\n }\n@@ -2622,7 +2626,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n         // fail: bad bounds check.\n         trans_fail(bcx, some(ex.span), \"bounds check\")\n     };\n-    let elt = InBoundsGEP(bcx, base, [ix_val]);\n+    let elt = InBoundsGEP(bcx, base, [ix_val]/~);\n     ret lval_owned(bcx, PointerCast(bcx, elt, T_ptr(llunitty)));\n }\n \n@@ -2706,11 +2710,11 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n             let val = alt check ty::get(t).struct {\n               ty::ty_box(_) {\n                 let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n-                GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n+                GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body]/~)\n               }\n               ty::ty_uniq(_) {\n                 let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n-                GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n+                GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body]/~)\n               }\n               ty::ty_enum(_, _) {\n                 let ety = expr_ty(cx, e);\n@@ -2857,7 +2861,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n             let cx = e_res.bcx;\n             let llenumty = T_opaque_enum_ptr(ccx);\n             let av_enum = PointerCast(cx, e_res.val, llenumty);\n-            let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]);\n+            let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]/~);\n             let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n             alt k_out {\n               cast_integral {int_cast(e_res.bcx, ll_t_out,\n@@ -2889,7 +2893,7 @@ fn trans_loop_body(bcx: block, e: @ast::expr, ret_flag: option<ValueRef>,\n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n-                  &temp_cleanups: [ValueRef], ret_flag: option<ValueRef>,\n+                  &temp_cleanups: [ValueRef]/~, ret_flag: option<ValueRef>,\n                   derefs: uint)\n     -> result {\n     #debug(\"+++ trans_arg_expr on %s\", expr_to_str(e));\n@@ -2979,7 +2983,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n             // In the event that failure occurs before the call actually\n             // happens, have to cleanup this copy:\n             add_clean_temp_mem(bcx, val, arg.ty);\n-            temp_cleanups += [val];\n+            temp_cleanups += [val]/~;\n           }\n         }\n     }\n@@ -2994,7 +2998,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n }\n \n // when invoking a method, an argument of type @T or ~T can be implicltly\n-// converted to an argument of type &T. Similarly, [T] can be converted to\n+// converted to an argument of type &T. Similarly, [T]/~ can be converted to\n // [T]/& and so on.  If such a conversion (called borrowing) is necessary,\n // then the borrowings table will have an appropriate entry inserted.  This\n // routine consults this table and performs these adaptations.  It returns a\n@@ -3012,7 +3016,7 @@ fn adapt_borrowed_value(lv: lval_result,\n     alt ty::get(e_ty).struct {\n       ty::ty_uniq(mt) | ty::ty_box(mt) {\n         let box_ptr = load_value_from_lval_result(lv, e_ty);\n-        let body_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_body]);\n+        let body_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_body]/~);\n         let rptr_ty = ty::mk_rptr(bcx.tcx(), ty::re_static, mt);\n         ret {lv: lval_temp(bcx, body_ptr), ty: rptr_ty};\n       }\n@@ -3030,14 +3034,14 @@ fn adapt_borrowed_value(lv: lval_result,\n         let unit_ty = ty::sequence_element_type(ccx.tcx, e_ty);\n         let llunit_ty = type_of(ccx, unit_ty);\n         let (base, len) = tvec::get_base_and_len(bcx, val, e_ty);\n-        let p = alloca(bcx, T_struct([T_ptr(llunit_ty), ccx.int_type]));\n+        let p = alloca(bcx, T_struct([T_ptr(llunit_ty), ccx.int_type]/~));\n \n         #debug(\"adapt_borrowed_value: adapting %s to %s\",\n                val_str(bcx.ccx().tn, val),\n                val_str(bcx.ccx().tn, p));\n \n-        Store(bcx, base, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n-        Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n+        Store(bcx, base, GEPi(bcx, p, [0u, abi::slice_elt_base]/~));\n+        Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]/~));\n \n         // this isn't necessarily the type that rust would assign but it's\n         // close enough for trans purposes, as it will have the same runtime\n@@ -3058,8 +3062,8 @@ fn adapt_borrowed_value(lv: lval_result,\n }\n \n enum call_args {\n-    arg_exprs([@ast::expr]),\n-    arg_vals([ValueRef])\n+    arg_exprs([@ast::expr]/~),\n+    arg_vals([ValueRef]/~)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -3070,11 +3074,11 @@ enum call_args {\n //  - trans_args\n fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n               dest: dest, ret_flag: option<ValueRef>)\n-    -> {bcx: block, args: [ValueRef], retslot: ValueRef} {\n+    -> {bcx: block, args: [ValueRef]/~, retslot: ValueRef} {\n     let _icx = cx.insn_ctxt(\"trans_args\");\n-    let mut temp_cleanups = [];\n+    let mut temp_cleanups = []/~;\n     let arg_tys = ty::ty_fn_args(fn_ty);\n-    let mut llargs: [ValueRef] = [];\n+    let mut llargs: [ValueRef]/~ = []/~;\n \n     let ccx = cx.ccx();\n     let mut bcx = cx;\n@@ -3091,10 +3095,10 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n       by_val(_) { alloc_ty(bcx, retty) }\n     };\n \n-    llargs += [llretslot];\n+    llargs += [llretslot]/~;\n \n     // Arg 1: Env (closure-bindings / self value)\n-    llargs += [llenv];\n+    llargs += [llenv]/~;\n \n     // ... then explicit args.\n \n@@ -3110,7 +3114,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n                                    e, temp_cleanups, if i == last { ret_flag }\n                                    else { none }, 0u);\n             bcx = r.bcx;\n-            llargs += [r.val];\n+            llargs += [r.val]/~;\n         }\n       }\n       arg_vals(vs) {\n@@ -3199,9 +3203,9 @@ fn trans_call_inner(\n                 faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n             }\n             let pair = faddr;\n-            faddr = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n+            faddr = GEPi(bcx, pair, [0u, abi::fn_field_code]/~);\n             faddr = Load(bcx, faddr);\n-            let llclosure = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n+            let llclosure = GEPi(bcx, pair, [0u, abi::fn_field_box]/~);\n             Load(bcx, llclosure)\n           }\n         };\n@@ -3247,7 +3251,7 @@ fn trans_call_inner(\n     }\n }\n \n-fn invoke(bcx: block, llfn: ValueRef, llargs: [ValueRef]) -> block {\n+fn invoke(bcx: block, llfn: ValueRef, llargs: [ValueRef]/~) -> block {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable { ret bcx; }\n     if need_invoke(bcx) {\n@@ -3335,7 +3339,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n-    let llretty = T_struct([T_ptr(T_i8()), T_i32()]);\n+    let llretty = T_struct([T_ptr(T_i8()), T_i32()]/~);\n     // The exception handling personality function. This is the C++\n     // personality function __gxx_personality_v0, wrapped in our naming\n     // convention.\n@@ -3348,7 +3352,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // Because we may have unwound across a stack boundary, we must call into\n     // the runtime to figure out which stack segment we are on and place the\n     // stack limit back into the TLS.\n-    Call(pad_bcx, bcx.ccx().upcalls.reset_stack_limit, []);\n+    Call(pad_bcx, bcx.ccx().upcalls.reset_stack_limit, []/~);\n \n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n@@ -3366,7 +3370,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     ret pad_bcx.llbb;\n }\n \n-fn trans_tup(bcx: block, elts: [@ast::expr], dest: dest) -> block {\n+fn trans_tup(bcx: block, elts: [@ast::expr]/~, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_tup\");\n     let mut bcx = bcx;\n     let addr = alt dest {\n@@ -3377,19 +3381,19 @@ fn trans_tup(bcx: block, elts: [@ast::expr], dest: dest) -> block {\n       save_in(pos) { pos }\n       _ { bcx.tcx().sess.bug(\"trans_tup: weird dest\"); }\n     };\n-    let mut temp_cleanups = [];\n+    let mut temp_cleanups = []/~;\n     for vec::eachi(elts) {|i, e|\n-        let dst = GEPi(bcx, addr, [0u, i]);\n+        let dst = GEPi(bcx, addr, [0u, i]/~);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_expr_save_in(bcx, e, dst);\n         add_clean_temp_mem(bcx, dst, e_ty);\n-        temp_cleanups += [dst];\n+        temp_cleanups += [dst]/~;\n     }\n     for vec::each(temp_cleanups) {|cleanup| revoke_clean(bcx, cleanup); }\n     ret bcx;\n }\n \n-fn trans_rec(bcx: block, fields: [ast::field],\n+fn trans_rec(bcx: block, fields: [ast::field]/~,\n              base: option<@ast::expr>, id: ast::node_id,\n              dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_rec\");\n@@ -3407,15 +3411,15 @@ fn trans_rec(bcx: block, fields: [ast::field],\n \n     let ty_fields = alt check ty::get(t).struct { ty::ty_rec(f) { f } };\n \n-    let mut temp_cleanups = [];\n+    let mut temp_cleanups = []/~;\n     for fields.each {|fld|\n         let ix = option::get(vec::position(ty_fields, {|ft|\n             str::eq(*fld.node.ident, *ft.ident)\n         }));\n-        let dst = GEPi(bcx, addr, [0u, ix]);\n+        let dst = GEPi(bcx, addr, [0u, ix]/~);\n         bcx = trans_expr_save_in(bcx, fld.node.expr, dst);\n         add_clean_temp_mem(bcx, dst, ty_fields[ix].mt.ty);\n-        temp_cleanups += [dst];\n+        temp_cleanups += [dst]/~;\n     }\n     alt base {\n       some(bexp) {\n@@ -3424,8 +3428,8 @@ fn trans_rec(bcx: block, fields: [ast::field],\n         // Copy over inherited fields\n         for ty_fields.eachi {|i, tf|\n             if !vec::any(fields, {|f| str::eq(*f.node.ident, *tf.ident)}) {\n-                let dst = GEPi(bcx, addr, [0u, i]);\n-                let base = GEPi(bcx, base_val, [0u, i]);\n+                let dst = GEPi(bcx, addr, [0u, i]/~);\n+                let base = GEPi(bcx, base_val, [0u, i]/~);\n                 let val = load_if_immediate(bcx, base, tf.mt.ty);\n                 bcx = copy_val(bcx, INIT, dst, val, tf.mt.ty);\n             }\n@@ -3652,7 +3656,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                 { |bcx|\n                     impl::trans_method_callee(bcx, callee_id, base, origin)\n                 },\n-                arg_exprs([idx]), dest);\n+                arg_exprs([idx]/~), dest);\n           }\n \n           // These return nothing\n@@ -3765,7 +3769,8 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             #debug[\"voidval = %s\", val_str(ccx.tn, voidval)];\n \n             let llval_ty = type_of(ccx, expr_ty(bcx, val));\n-            let args = [llsize_of(ccx, llval_ty), llalign_of(ccx, llval_ty)];\n+            let args =\n+                [llsize_of(ccx, llval_ty), llalign_of(ccx, llval_ty)]/~;\n             let origin = bcx.ccx().maps.method_map.get(alloc_id);\n             let bcx = trans_call_inner(\n                 bcx, e.info(), node_id_type(bcx, alloc_id), void_ty,\n@@ -3867,7 +3872,7 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n        ret trans_expr(bcx, lvl, ignore);\n     }\n \n-    let modpath = [path_mod(ccx.link_meta.name)] +\n+    let modpath = [path_mod(ccx.link_meta.name)]/~ +\n         vec::filter(bcx.fcx.path, {|e|\n             alt e { path_mod(_) { true } _ { false } }\n         });\n@@ -3902,7 +3907,7 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n             // Call the polymorphic log function.\n             let val = spill_if_immediate(bcx, val, e_ty);\n             let val = PointerCast(bcx, val, T_ptr(T_i8()));\n-            Call(bcx, ccx.upcalls.log_type, [tydesc, val, level]);\n+            Call(bcx, ccx.upcalls.log_type, [tydesc, val, level]/~);\n             bcx\n         }\n     }\n@@ -3969,7 +3974,7 @@ fn trans_trace(bcx: block, sp_opt: option<span>, trace_str: str) {\n     let ccx = bcx.ccx();\n     let V_trace_str = PointerCast(bcx, V_trace_str, T_ptr(T_i8()));\n     let V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n-    let args = [V_trace_str, V_filename, C_int(ccx, V_line)];\n+    let args = [V_trace_str, V_filename, C_int(ccx, V_line)]/~;\n     Call(bcx, ccx.upcalls.trace, args);\n }\n \n@@ -3998,7 +4003,7 @@ fn trans_fail_value(bcx: block, sp_opt: option<span>,\n     };\n     let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n     let V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n-    let args = [V_str, V_filename, C_int(ccx, V_line)];\n+    let args = [V_str, V_filename, C_int(ccx, V_line)]/~;\n     let bcx = invoke(bcx, bcx.ccx().upcalls._fail, args);\n     Unreachable(bcx);\n     ret bcx;\n@@ -4160,8 +4165,8 @@ fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n }\n \n fn simple_block_scope() -> block_kind {\n-    block_scope({loop_break: none, mut cleanups: [],\n-                 mut cleanup_paths: [], mut landing_pad: none})\n+    block_scope({loop_break: none, mut cleanups: []/~,\n+                 mut cleanup_paths: []/~, mut landing_pad: none})\n }\n \n // Use this when you're at the top block of a function or the like.\n@@ -4181,8 +4186,8 @@ fn loop_scope_block(bcx: block, loop_break: block, n: str,\n                     opt_node_info: option<node_info>) -> block {\n     ret new_block(bcx.fcx, some(bcx), block_scope({\n         loop_break: some(loop_break),\n-        mut cleanups: [],\n-        mut cleanup_paths: [],\n+        mut cleanups: []/~,\n+        mut cleanup_paths: []/~,\n         mut landing_pad: none\n     }), n, opt_node_info);\n }\n@@ -4259,7 +4264,7 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n             }\n             let sub_cx = sub_block(bcx, \"cleanup\");\n             Br(bcx, sub_cx.llbb);\n-            inf.cleanup_paths += [{target: leave, dest: sub_cx.llbb}];\n+            inf.cleanup_paths += [{target: leave, dest: sub_cx.llbb}]/~;\n             bcx = trans_block_cleanups_(sub_cx, cur, is_lpad);\n           }\n           _ {}\n@@ -4448,7 +4453,7 @@ fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n // field of the fn_ctxt with\n fn create_llargs_for_fn_args(cx: fn_ctxt,\n                              ty_self: self_arg,\n-                             args: [ast::arg]) {\n+                             args: [ast::arg]/~) {\n     let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n     // Skip the implicit arguments 0, and 1.\n     let mut arg_n = first_real_arg;\n@@ -4472,8 +4477,8 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n     }\n }\n \n-fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: [ast::arg],\n-                        arg_tys: [ty::arg]) -> block {\n+fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: [ast::arg]/~,\n+                        arg_tys: [ty::arg]/~) -> block {\n     let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n     let tcx = bcx.tcx();\n     let mut arg_n: uint = 0u, bcx = bcx;\n@@ -4615,12 +4620,12 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n          ident: @\"arg\",\n          id: varg.id}\n     });\n-    let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id,\n+    let fcx = new_fn_ctxt_w_id(ccx, []/~, llfndecl, variant.node.id,\n                                param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args);\n     let ty_param_substs = alt param_substs {\n       some(substs) { substs.tys }\n-      none { [] }\n+      none { []/~ }\n     };\n     let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n@@ -4632,9 +4637,9 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     } else {\n         let llenumptr =\n             PointerCast(bcx, fcx.llretptr, T_opaque_enum_ptr(ccx));\n-        let lldiscrimptr = GEPi(bcx, llenumptr, [0u, 0u]);\n+        let lldiscrimptr = GEPi(bcx, llenumptr, [0u, 0u]/~);\n         Store(bcx, C_int(ccx, disr), lldiscrimptr);\n-        GEPi(bcx, llenumptr, [0u, 1u])\n+        GEPi(bcx, llenumptr, [0u, 1u]/~)\n     };\n     let t_id = local_def(enum_id);\n     let v_id = local_def(variant.node.id);\n@@ -4824,10 +4829,10 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                                   parent_id)) {\n     // Initialize the drop flag\n     let one = C_u8(1u);\n-    let flag = GEPi(bcx_top, selfptr, [0u, 0u]);\n+    let flag = GEPi(bcx_top, selfptr, [0u, 0u]/~);\n     Store(bcx_top, one, flag);\n     // Select the pointer to the class itself\n-    GEPi(bcx_top, selfptr, [0u, 1u])\n+    GEPi(bcx_top, selfptr, [0u, 1u]/~)\n   }\n   else { selfptr };\n \n@@ -4839,7 +4844,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   // drop their LHS\n   for fields.each {|field|\n      let ix = field_idx_strict(bcx.tcx(), sp, field.ident, fields);\n-     bcx = zero_mem(bcx, GEPi(bcx, valptr, [0u, ix]), field.mt.ty);\n+     bcx = zero_mem(bcx, GEPi(bcx, valptr, [0u, ix]/~), field.mt.ty);\n   }\n \n   // note we don't want to take *or* drop self.\n@@ -4872,7 +4877,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n   /* The dtor takes a (null) output pointer, and a self argument,\n      and returns () */\n   let lldty = T_fn([T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n-                    T_ptr(type_of(ccx, class_ty))],\n+                    T_ptr(type_of(ccx, class_ty))]/~,\n                    llvm::LLVMVoidType());\n \n   let s = get_dtor_symbol(ccx, path, dtor_id, psubsts);\n@@ -4901,11 +4906,11 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast::item_fn(decl, tps, body) {\n         if decl.purity == ast::crust_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n-            native::trans_crust_fn(ccx, *path + [path_name(item.ident)],\n+            native::trans_crust_fn(ccx, *path + [path_name(item.ident)]/~,\n                                    decl, body, llfndecl, item.id);\n         } else if tps.len() == 0u {\n             let llfndecl = get_item_val(ccx, item.id);\n-            trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n+            trans_fn(ccx, *path + [path_name(item.ident)]/~, decl, body,\n                      llfndecl, no_self, none, item.id);\n         } else {\n             for vec::each(body.node.stmts) {|stmt|\n@@ -4952,7 +4957,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         if tps.len() == 0u {\n           let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n                          vtables: none,\n-                         bounds: @[]};\n+                         bounds: @[]/~};\n           trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n                            get_item_val(ccx, ctor.node.id), psubsts,\n                            ctor.node.id, local_def(item.id), ctor.span);\n@@ -5014,7 +5019,7 @@ fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path,\n     llfn\n }\n \n-// Create a _rust_main(args: [str]) function which will be called from the\n+// Create a _rust_main(args: [str]/~) function which will be called from the\n // runtime rust_start function\n fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n                        main_node_type: ty::t) {\n@@ -5041,19 +5046,21 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n             {mode: ast::expl(ast::by_val),\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mutbl: ast::m_imm})};\n         let nt = ty::mk_nil(ccx.tcx);\n-        let llfty = type_of_fn(ccx, [vecarg_ty], nt);\n+        let llfty = type_of_fn(ccx, [vecarg_ty]/~, nt);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n-        let fcx = new_fn_ctxt(ccx, [], llfdecl, none);\n+        let fcx = new_fn_ctxt(ccx, []/~, llfdecl, none);\n \n         let bcx = top_scope_block(fcx, none);\n         let lltop = bcx.llbb;\n \n         let lloutputarg = llvm::LLVMGetParam(llfdecl, 0 as c_uint);\n         let llenvarg = llvm::LLVMGetParam(llfdecl, 1 as c_uint);\n-        let mut args = [lloutputarg, llenvarg];\n-        if takes_argv { args += [llvm::LLVMGetParam(llfdecl, 2 as c_uint)]; }\n+        let mut args = [lloutputarg, llenvarg]/~;\n+        if takes_argv {\n+            args += [llvm::LLVMGetParam(llfdecl, 2 as c_uint)]/~;\n+        }\n         Call(bcx, main_llfn, args);\n         build_return(bcx);\n \n@@ -5067,7 +5074,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         fn main_name() -> str { ret \"WinMain@16\"; }\n         #[cfg(unix)]\n         fn main_name() -> str { ret \"main\"; }\n-        let llfty = T_fn([ccx.int_type, ccx.int_type], ccx.int_type);\n+        let llfty = T_fn([ccx.int_type, ccx.int_type]/~, ccx.int_type);\n         let llfn = decl_cdecl_fn(ccx.llmod, main_name(), llfty);\n         let llbb = str::as_c_str(\"top\", {|buf|\n             llvm::LLVMAppendBasicBlock(llfn, buf)\n@@ -5076,11 +5083,11 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n         let crate_map = ccx.crate_map;\n         let start_ty = T_fn([val_ty(rust_main), ccx.int_type, ccx.int_type,\n-                             val_ty(crate_map)], ccx.int_type);\n+                             val_ty(crate_map)]/~, ccx.int_type);\n         let start = decl_cdecl_fn(ccx.llmod, \"rust_start\", start_ty);\n \n         let args = [rust_main, llvm::LLVMGetParam(llfn, 0 as c_uint),\n-                    llvm::LLVMGetParam(llfn, 1 as c_uint), crate_map];\n+                    llvm::LLVMGetParam(llfn, 1 as c_uint), crate_map]/~;\n         let result = unsafe {\n             llvm::LLVMBuildCall(bld, start, vec::unsafe::to_ptr(args),\n                                 args.len() as c_uint, noname())\n@@ -5102,17 +5109,17 @@ fn create_real_fn_pair(cx: block, llfnty: TypeRef, llfn: ValueRef,\n fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n                 llenvptr: ValueRef) {\n     let ccx = bcx.ccx();\n-    let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n+    let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]/~);\n     Store(bcx, llfn, code_cell);\n-    let env_cell = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n+    let env_cell = GEPi(bcx, pair, [0u, abi::fn_field_box]/~);\n     let llenvblobptr = PointerCast(bcx, llenvptr, T_opaque_box_ptr(ccx));\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n     *alt check ccx.tcx.items.get(i.id) {\n       ast_map::node_item(_, p) { p }\n-    } + [path_name(i.ident)]\n+    } + [path_name(i.ident)]/~\n }\n \n /* If there's already a symbol for the dtor with <id> and substs <substs>,\n@@ -5124,7 +5131,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n      some(s) { s }\n      none if is_none(substs) {\n        let s = mangle_exported_name(ccx,\n-                               path + [path_name(@ccx.names(\"dtor\"))],\n+                               path + [path_name(@ccx.names(\"dtor\"))]/~,\n                                t);\n        ccx.item_symbols.insert(id, s);\n        s\n@@ -5136,7 +5143,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n          some(ss) {\n            let mono_ty = ty::subst_tps(ccx.tcx, ss.tys, t);\n            mangle_exported_name(ccx, path +\n-                           [path_name(@ccx.names(\"dtor\"))], mono_ty)\n+                           [path_name(@ccx.names(\"dtor\"))]/~, mono_ty)\n          }\n          none {\n              ccx.sess.bug(#fmt(\"get_dtor_symbol: not monomorphizing and \\\n@@ -5155,7 +5162,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n         let mut exprt = false;\n         let val = alt check ccx.tcx.items.get(id) {\n           ast_map::node_item(i, pth) {\n-            let my_path = *pth + [path_name(i.ident)];\n+            let my_path = *pth + [path_name(i.ident)]/~;\n             alt check i.node {\n               ast::item_const(_, _) {\n                 let typ = ty::node_id_to_type(ccx.tcx, i.id);\n@@ -5181,17 +5188,17 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             exprt = true;\n             let mty = ty::node_id_to_type(ccx.tcx, id);\n             let pth = *pth + [path_name(@ccx.names(\"meth\")),\n-                              path_name(m.ident)];\n+                              path_name(m.ident)]/~;\n             let llfn = register_fn_full(ccx, m.span, pth, id, mty);\n             set_inline_hint_if_appr(m.attrs, llfn);\n             llfn\n           }\n           ast_map::node_native_item(ni, _, pth) {\n             exprt = true;\n-            register_fn(ccx, ni.span, *pth + [path_name(ni.ident)], ni.id)\n+            register_fn(ccx, ni.span, *pth + [path_name(ni.ident)]/~, ni.id)\n           }\n           ast_map::node_ctor(nm, tps, ctor, _, pt) {\n-            let my_path = *pt + [path_name(nm)];\n+            let my_path = *pt + [path_name(nm)]/~;\n             register_fn(ccx, ctor.span, my_path, ctor.node.id)\n           }\n           ast_map::node_dtor(tps, dt, parent_id, pt) {\n@@ -5205,7 +5212,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             // This code shouldn't be reached if the class is generic\n             assert !ty::type_has_params(class_ty);\n             let lldty = T_fn([T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n-                    T_ptr(type_of(ccx, class_ty))],\n+                    T_ptr(type_of(ccx, class_ty))]/~,\n                                    llvm::LLVMVoidType());\n             let s = get_dtor_symbol(ccx, *pt, dt.node.id, none);\n \n@@ -5217,7 +5224,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n \n           ast_map::node_variant(v, enm, pth) {\n             assert v.node.args.len() != 0u;\n-            let pth = *pth + [path_name(enm.ident), path_name(v.node.name)];\n+            let pth = *pth + [path_name(enm.ident), path_name(v.node.name)]/~;\n             let llfn = alt check enm.node {\n               ast::item_enum(_, _, _) {\n                 register_fn(ccx, v.span, pth, id)\n@@ -5247,7 +5254,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n         let path = item_path(ccx, it);\n         for vec::each(variants) {|variant|\n             let p = path + [path_name(variant.node.name),\n-                            path_name(@\"discrim\")];\n+                            path_name(@\"discrim\")]/~;\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n             let disr_val = vi[i].disr_val;\n             note_unique_llvm_symbol(ccx, s);\n@@ -5283,22 +5290,24 @@ fn p2i(ccx: @crate_ctxt, v: ValueRef) -> ValueRef {\n }\n \n fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n-    let T_memmove32_args: [TypeRef] =\n-        [T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n-    let T_memmove64_args: [TypeRef] =\n-        [T_ptr(T_i8()), T_ptr(T_i8()), T_i64(), T_i32(), T_i1()];\n-    let T_memset32_args: [TypeRef] =\n-        [T_ptr(T_i8()), T_i8(), T_i32(), T_i32(), T_i1()];\n-    let T_memset64_args: [TypeRef] =\n-        [T_ptr(T_i8()), T_i8(), T_i64(), T_i32(), T_i1()];\n-    let T_trap_args: [TypeRef] = [];\n-    let T_frameaddress_args: [TypeRef] = [T_i32()];\n+    let T_memmove32_args: [TypeRef]/~ =\n+        [T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()]/~;\n+    let T_memmove64_args: [TypeRef]/~ =\n+        [T_ptr(T_i8()), T_ptr(T_i8()), T_i64(), T_i32(), T_i1()]/~;\n+    let T_memset32_args: [TypeRef]/~ =\n+        [T_ptr(T_i8()), T_i8(), T_i32(), T_i32(), T_i1()]/~;\n+    let T_memset64_args: [TypeRef]/~ =\n+        [T_ptr(T_i8()), T_i8(), T_i64(), T_i32(), T_i1()]/~;\n+    let T_trap_args: [TypeRef]/~ = []/~;\n+    let T_frameaddress_args: [TypeRef]/~ = [T_i32()]/~;\n     let gcroot =\n         decl_cdecl_fn(llmod, \"llvm.gcroot\",\n-                      T_fn([T_ptr(T_ptr(T_i8())), T_ptr(T_i8())], T_void()));\n+                      T_fn([T_ptr(T_ptr(T_i8())), T_ptr(T_i8())]/~,\n+                           T_void()));\n     let gcread =\n         decl_cdecl_fn(llmod, \"llvm.gcread\",\n-                      T_fn([T_ptr(T_i8()), T_ptr(T_ptr(T_i8()))], T_void()));\n+                      T_fn([T_ptr(T_i8()), T_ptr(T_ptr(T_i8()))]/~,\n+                           T_void()));\n     let memmove32 =\n         decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i32\",\n                       T_fn(T_memmove32_args, T_void()));\n@@ -5311,7 +5320,8 @@ fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n     let memset64 =\n         decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i64\",\n                       T_fn(T_memset64_args, T_void()));\n-    let trap = decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args, T_void()));\n+    let trap = decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args,\n+                                                      T_void()));\n     let frameaddress = decl_cdecl_fn(llmod, \"llvm.frameaddress\",\n                                      T_fn(T_frameaddress_args,\n                                           T_ptr(T_i8())));\n@@ -5331,37 +5341,38 @@ fn declare_dbg_intrinsics(llmod: ModuleRef,\n                           intrinsics: hashmap<str, ValueRef>) {\n     let declare =\n         decl_cdecl_fn(llmod, \"llvm.dbg.declare\",\n-                      T_fn([T_metadata(), T_metadata()], T_void()));\n+                      T_fn([T_metadata(), T_metadata()]/~, T_void()));\n     let value =\n         decl_cdecl_fn(llmod, \"llvm.dbg.value\",\n-                      T_fn([T_metadata(), T_i64(), T_metadata()], T_void()));\n+                      T_fn([T_metadata(), T_i64(), T_metadata()]/~,\n+                           T_void()));\n     intrinsics.insert(\"llvm.dbg.declare\", declare);\n     intrinsics.insert(\"llvm.dbg.value\", value);\n }\n \n fn trap(bcx: block) {\n-    let v: [ValueRef] = [];\n+    let v: [ValueRef]/~ = []/~;\n     alt bcx.ccx().intrinsics.find(\"llvm.trap\") {\n       some(x) { Call(bcx, x, v); }\n       _ { bcx.sess().bug(\"unbound llvm.trap in trap\"); }\n     }\n }\n \n fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n-    let elttype = T_struct([ccx.int_type, ccx.int_type]);\n+    let elttype = T_struct([ccx.int_type, ccx.int_type]/~);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     let map = str::as_c_str(\"_rust_mod_map\", {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n-    let mut elts: [ValueRef] = [];\n+    let mut elts: [ValueRef]/~ = []/~;\n     for ccx.module_data.each {|key, val|\n         let elt = C_struct([p2i(ccx, C_cstr(ccx, key)),\n-                            p2i(ccx, val)]);\n-        elts += [elt];\n+                            p2i(ccx, val)]/~);\n+        elts += [elt]/~;\n     };\n-    let term = C_struct([C_int(ccx, 0), C_int(ccx, 0)]);\n-    elts += [term];\n+    let term = C_struct([C_int(ccx, 0), C_int(ccx, 0)]/~);\n+    elts += [term]/~;\n     llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     ret map;\n }\n@@ -5379,7 +5390,7 @@ fn decl_crate_map(sess: session::session, mapmeta: link_meta,\n     } else { \"toplevel\" };\n     let sym_name = \"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n-    let maptype = T_struct([int_type, arrtype]);\n+    let maptype = T_struct([int_type, arrtype]/~);\n     let map = str::as_c_str(sym_name, {|buf|\n         llvm::LLVMAddGlobal(llmod, maptype, buf)\n     });\n@@ -5388,7 +5399,7 @@ fn decl_crate_map(sess: session::session, mapmeta: link_meta,\n }\n \n fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n-    let mut subcrates: [ValueRef] = [];\n+    let mut subcrates: [ValueRef]/~ = []/~;\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n     while cstore::have_crate_data(cstore, i) {\n@@ -5399,13 +5410,13 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n         let cr = str::as_c_str(nm, {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n-        subcrates += [p2i(ccx, cr)];\n+        subcrates += [p2i(ccx, cr)]/~;\n         i += 1;\n     }\n-    subcrates += [C_int(ccx, 0)];\n+    subcrates += [C_int(ccx, 0)]/~;\n     llvm::LLVMSetInitializer(map, C_struct(\n         [p2i(ccx, create_module_map(ccx)),\n-         C_array(ccx.int_type, subcrates)]));\n+         C_array(ccx.int_type, subcrates)]/~));\n }\n \n fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n@@ -5427,8 +5438,8 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n         encode_inlined_item: encode_inlined_item\n     };\n \n-    fn reexports(cx: @crate_ctxt) -> [(str, ast::def_id)] {\n-        let mut reexports = [];\n+    fn reexports(cx: @crate_ctxt) -> [(str, ast::def_id)]/~ {\n+        let mut reexports = []/~;\n         for cx.exp_map.each {|exp_id, defs|\n             for defs.each {|def|\n                 if !def.reexp { cont; }\n@@ -5437,14 +5448,14 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n                     ast_map::path_to_str(*path)\n                   }\n                 };\n-                reexports += [(path, def.id)];\n+                reexports += [(path, def.id)]/~;\n             }\n         }\n         ret reexports;\n     }\n \n     fn impl_map(cx: @crate_ctxt,\n-                id: ast::node_id) -> [(ast::ident, ast::def_id)] {\n+                id: ast::node_id) -> [(ast::ident, ast::def_id)]/~ {\n         alt *cx.maps.impl_map.get(id) {\n           list::cons(impls, @list::nil) {\n             (*impls).map {|i|\n@@ -5463,7 +5474,7 @@ fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     if !cx.sess.building_library { ret; }\n     let encode_parms = crate_ctxt_to_encode_parms(cx);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n-    let llconst = C_struct([llmeta]);\n+    let llconst = C_struct([llmeta]/~);\n     let mut llglobal = str::as_c_str(\"rust_metadata\", {|buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n     });\n@@ -5479,7 +5490,7 @@ fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n         llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n     });\n     lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n-    llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n+    llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]/~));\n }\n \n // Writes the current ABI version into the crate.\n@@ -5577,9 +5588,9 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                mut n_glues_created: 0u,\n                mut n_null_glues: 0u,\n                mut n_real_glues: 0u,\n-               llvm_insn_ctxt: @mut [],\n+               llvm_insn_ctxt: @mut []/~,\n                llvm_insns: str_hash(),\n-               fn_times: @mut []},\n+               fn_times: @mut []/~},\n           upcalls:\n               upcall::declare_upcalls(targ_cfg, tn, tydesc_type,\n                                       llmod),"}, {"sha": "ca18bd25289fba19dbf64f60d5bf12a9ac20d867", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -79,7 +79,7 @@ fn Ret(cx: block, V: ValueRef) {\n     llvm::LLVMBuildRet(B(cx), V);\n }\n \n-fn AggregateRet(cx: block, RetVals: [ValueRef]) {\n+fn AggregateRet(cx: block, RetVals: [ValueRef]/~) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n@@ -134,7 +134,7 @@ fn noname() -> *libc::c_char unsafe {\n     ret unsafe::reinterpret_cast(ptr::addr_of(cnull));\n }\n \n-fn Invoke(cx: block, Fn: ValueRef, Args: [ValueRef],\n+fn Invoke(cx: block, Fn: ValueRef, Args: [ValueRef]/~,\n           Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n@@ -151,7 +151,7 @@ fn Invoke(cx: block, Fn: ValueRef, Args: [ValueRef],\n     }\n }\n \n-fn FastInvoke(cx: block, Fn: ValueRef, Args: [ValueRef],\n+fn FastInvoke(cx: block, Fn: ValueRef, Args: [ValueRef]/~,\n               Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n@@ -417,7 +417,7 @@ fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n-fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n+fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]/~) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n     count_insn(cx, \"gep\");\n@@ -428,14 +428,14 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n \n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n-fn GEPi(cx: block, base: ValueRef, ixs: [uint]) -> ValueRef {\n-    let mut v: [ValueRef] = [];\n-    for vec::each(ixs) {|i| v += [C_i32(i as i32)]; }\n+fn GEPi(cx: block, base: ValueRef, ixs: [uint]/~) -> ValueRef {\n+    let mut v: [ValueRef]/~ = []/~;\n+    for vec::each(ixs) {|i| v += [C_i32(i as i32)]/~; }\n     count_insn(cx, \"gepi\");\n     ret InBoundsGEP(cx, base, v);\n }\n \n-fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) ->\n+fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]/~) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n@@ -607,7 +607,7 @@ fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n     ret llvm::LLVMBuildPhi(B(cx), Ty, noname());\n }\n \n-fn Phi(cx: block, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n+fn Phi(cx: block, Ty: TypeRef, vals: [ValueRef]/~, bbs: [BasicBlockRef]/~)\n    -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n     assert vals.len() == bbs.len();\n@@ -657,15 +657,15 @@ fn add_comment(bcx: block, text: str) {\n         let asm = str::as_c_str(comment_text, {|c|\n             str::as_c_str(\"\", {|e|\n                 count_insn(bcx, \"inlineasm\");\n-                llvm::LLVMConstInlineAsm(T_fn([], T_void()), c, e,\n+                llvm::LLVMConstInlineAsm(T_fn([]/~, T_void()), c, e,\n                                          False, False)\n             })\n         });\n-        Call(bcx, asm, []);\n+        Call(bcx, asm, []/~);\n     }\n }\n \n-fn Call(cx: block, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n+fn Call(cx: block, Fn: ValueRef, Args: [ValueRef]/~) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, \"call\");\n@@ -679,7 +679,7 @@ fn Call(cx: block, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     }\n }\n \n-fn FastCall(cx: block, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n+fn FastCall(cx: block, Fn: ValueRef, Args: [ValueRef]/~) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, \"fastcall\");\n@@ -690,7 +690,7 @@ fn FastCall(cx: block, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     }\n }\n \n-fn CallWithConv(cx: block, Fn: ValueRef, Args: [ValueRef],\n+fn CallWithConv(cx: block, Fn: ValueRef, Args: [ValueRef]/~,\n                 Conv: CallConv) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n@@ -779,7 +779,7 @@ fn Trap(cx: block) {\n         llvm::LLVMGetNamedFunction(M, buf)\n     });\n     assert (T as int != 0);\n-    let Args: [ValueRef] = [];\n+    let Args: [ValueRef]/~ = []/~;\n     unsafe {\n         count_insn(cx, \"trap\");\n         llvm::LLVMBuildCall(b, T, vec::unsafe::to_ptr(Args),"}, {"sha": "51a1bba1162aefe294a011e93b50ca3dd242475d", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 59, "deletions": 55, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -122,9 +122,9 @@ fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n \n // Given a closure ty, emits a corresponding tuple ty\n fn mk_closure_tys(tcx: ty::ctxt,\n-                  bound_values: [environment_value])\n-    -> (ty::t, [ty::t]) {\n-    let mut bound_tys = [];\n+                  bound_values: [environment_value]/~)\n+    -> (ty::t, [ty::t]/~) {\n+    let mut bound_tys = []/~;\n \n     // Compute the closed over data\n     for vec::each(bound_values) {|bv|\n@@ -133,20 +133,20 @@ fn mk_closure_tys(tcx: ty::ctxt,\n             env_move(_, t, _) { t }\n             env_ref(_, t, _) { t }\n             env_expr(_, t) { t }\n-        }];\n+        }]/~;\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n-    // FIXME[mono] remove tuple of tydescs from closure types (#2531)\n-    let cdata_ty = ty::mk_tup(tcx, [ty::mk_tup(tcx, []),\n-                                    bound_data_ty]);\n+    // FIXME[mono]/~ remove tuple of tydescs from closure types (#2531)\n+    let cdata_ty = ty::mk_tup(tcx, [ty::mk_tup(tcx, []/~),\n+                                    bound_data_ty]/~);\n     #debug[\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty)];\n     ret (cdata_ty, bound_tys);\n }\n \n fn allocate_cbox(bcx: block,\n                  ck: ty::closure_kind,\n                  cdata_ty: ty::t)\n-    -> (block, ValueRef, [ValueRef]) {\n+    -> (block, ValueRef, [ValueRef]/~) {\n     let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n@@ -155,7 +155,7 @@ fn allocate_cbox(bcx: block,\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n         let box = PointerCast(bcx, box, T_opaque_box_ptr(ccx));\n-        let ref_cnt = GEPi(bcx, box, [0u, abi::box_field_refcnt]);\n+        let ref_cnt = GEPi(bcx, box, [0u, abi::box_field_refcnt]/~);\n         let rc = C_int(ccx, 0x12345678);\n         Store(bcx, rc, ref_cnt);\n     }\n@@ -164,15 +164,15 @@ fn allocate_cbox(bcx: block,\n                     cdata_ty: ty::t,\n                     box: ValueRef,\n                     &ti: option<@tydesc_info>) -> block {\n-        let bound_tydesc = GEPi(bcx, box, [0u, abi::box_field_tydesc]);\n+        let bound_tydesc = GEPi(bcx, box, [0u, abi::box_field_tydesc]/~);\n         let td = base::get_tydesc(bcx.ccx(), cdata_ty, ti);\n         Store(bcx, td, bound_tydesc);\n         bcx\n     }\n \n     // Allocate and initialize the box:\n     let mut ti = none;\n-    let mut temp_cleanups = [];\n+    let mut temp_cleanups = []/~;\n     let (bcx, box) = alt ck {\n       ty::ck_box {\n         get_tydesc(ccx, cdata_ty, ti);\n@@ -209,7 +209,7 @@ type closure_result = {\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n fn store_environment(bcx: block,\n-                     bound_values: [environment_value],\n+                     bound_values: [environment_value]/~,\n                      ck: ty::closure_kind) -> closure_result {\n     let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n@@ -242,12 +242,12 @@ fn store_environment(bcx: block,\n         }\n \n         let bound_data = GEPi(bcx, llbox,\n-             [0u, abi::box_field_body, abi::closure_body_bindings, i]);\n+             [0u, abi::box_field_body, abi::closure_body_bindings, i]/~);\n         alt bv {\n           env_expr(e, _) {\n             bcx = base::trans_expr_save_in(bcx, e, bound_data);\n             add_clean_temp_mem(bcx, bound_data, bound_tys[i]);\n-            temp_cleanups += [bound_data];\n+            temp_cleanups += [bound_data]/~;\n           }\n           env_copy(val, ty, owned) {\n             let val1 = load_if_immediate(bcx, val, ty);\n@@ -283,13 +283,13 @@ fn store_environment(bcx: block,\n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n fn build_closure(bcx0: block,\n-                 cap_vars: [capture::capture_var],\n+                 cap_vars: [capture::capture_var]/~,\n                  ck: ty::closure_kind,\n                  id: ast::node_id,\n                  include_ret_handle: option<ValueRef>) -> closure_result {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n-    let mut env_vals = [];\n+    let mut env_vals = []/~;\n     let mut bcx = bcx0;\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n@@ -303,18 +303,18 @@ fn build_closure(bcx0: block,\n           capture::cap_ref {\n             assert ck == ty::ck_block;\n             ty = ty::mk_mut_ptr(tcx, ty);\n-            env_vals += [env_ref(lv.val, ty, lv.kind)];\n+            env_vals += [env_ref(lv.val, ty, lv.kind)]/~;\n           }\n           capture::cap_copy {\n             let mv = alt check ccx.maps.last_use_map.find(id) {\n               none { false }\n               some(vars) { (*vars).contains(nid) }\n             };\n-            if mv { env_vals += [env_move(lv.val, ty, lv.kind)]; }\n-            else { env_vals += [env_copy(lv.val, ty, lv.kind)]; }\n+            if mv { env_vals += [env_move(lv.val, ty, lv.kind)]/~; }\n+            else { env_vals += [env_copy(lv.val, ty, lv.kind)]/~; }\n           }\n           capture::cap_move {\n-            env_vals += [env_move(lv.val, ty, lv.kind)];\n+            env_vals += [env_move(lv.val, ty, lv.kind)]/~;\n           }\n           capture::cap_drop {\n             assert lv.kind == owned;\n@@ -331,7 +331,7 @@ fn build_closure(bcx0: block,\n         let nil_ret = PointerCast(bcx, our_ret, T_ptr(T_nil()));\n         env_vals +=\n             [env_ref(flagptr, ty::mk_mut_ptr(tcx, ty::mk_bool(tcx)), owned),\n-             env_ref(nil_ret, ty::mk_nil_ptr(tcx), owned)];\n+             env_ref(nil_ret, ty::mk_nil_ptr(tcx), owned)]/~;\n     }\n     ret store_environment(bcx, env_vals, ck);\n }\n@@ -341,7 +341,7 @@ fn build_closure(bcx0: block,\n // with the upvars and type descriptors.\n fn load_environment(fcx: fn_ctxt,\n                     cdata_ty: ty::t,\n-                    cap_vars: [capture::capture_var],\n+                    cap_vars: [capture::capture_var]/~,\n                     load_ret_handle: bool,\n                     ck: ty::closure_kind) {\n     let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n@@ -357,7 +357,7 @@ fn load_environment(fcx: fn_ctxt,\n           capture::cap_drop { /* ignore */ }\n           _ {\n             let mut upvarptr =\n-                GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, i]);\n+                GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, i]/~);\n             alt ck {\n               ty::ck_block { upvarptr = Load(bcx, upvarptr); }\n               ty::ck_uniq | ty::ck_box { }\n@@ -370,9 +370,10 @@ fn load_environment(fcx: fn_ctxt,\n     }\n     if load_ret_handle {\n         let flagptr = Load(bcx, GEPi(bcx, llcdata,\n-                                     [0u, abi::closure_body_bindings, i]));\n-        let retptr = Load(bcx, GEPi(bcx, llcdata,\n-                                    [0u, abi::closure_body_bindings, i+1u]));\n+                                     [0u, abi::closure_body_bindings, i]/~));\n+        let retptr = Load(bcx,\n+                          GEPi(bcx, llcdata,\n+                               [0u, abi::closure_body_bindings, i+1u]/~));\n         fcx.loop_ret = some({flagptr: flagptr, retptr: retptr});\n     }\n }\n@@ -390,7 +391,7 @@ fn trans_expr_fn(bcx: block,\n     let ccx = bcx.ccx(), bcx = bcx;\n     let fty = node_id_type(bcx, id);\n     let llfnty = type_of_fn_from_ty(ccx, fty);\n-    let sub_path = bcx.fcx.path + [path_name(@\"anon\")];\n+    let sub_path = bcx.fcx.path + [path_name(@\"anon\")]/~;\n     let s = mangle_internal_name_by_path(ccx, sub_path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n@@ -428,13 +429,13 @@ fn trans_expr_fn(bcx: block,\n \n fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n                 f_res: lval_maybe_callee,\n-                args: [option<@ast::expr>], pair_ty: ty::t,\n+                args: [option<@ast::expr>]/~, pair_ty: ty::t,\n                 dest: dest) -> block {\n     let _icx = cx.insn_ctxt(\"closure::trans_bind1\");\n     let ccx = cx.ccx();\n-    let mut bound: [@ast::expr] = [];\n+    let mut bound: [@ast::expr]/~ = []/~;\n     for vec::each(args) {|argopt|\n-        alt argopt { none { } some(e) { bound += [e]; } }\n+        alt argopt { none { } some(e) { bound += [e]/~; } }\n     }\n     let mut bcx = f_res.bcx;\n     if dest == ignore {\n@@ -453,22 +454,22 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n     // Arrange for the bound function to live in the first binding spot\n     // if the function is not statically known.\n     let (env_vals, target_info) = alt f_res.env {\n-      null_env { ([], target_static(f_res.val)) }\n+      null_env { ([]/~, target_static(f_res.val)) }\n       is_closure {\n         // Cast the function we are binding to be the type that the\n         // closure will expect it to have. The type the closure knows\n         // about has the type parameters substituted with the real types.\n         let llclosurety = T_ptr(type_of(ccx, outgoing_fty));\n         let src_loc = PointerCast(bcx, f_res.val, llclosurety);\n-        ([env_copy(src_loc, pair_ty, owned)], target_closure)\n+        ([env_copy(src_loc, pair_ty, owned)]/~, target_closure)\n       }\n       self_env(slf, slf_t, none) {\n-        ([env_copy(slf, slf_t, owned)], target_static_self(f_res.val))\n+        ([env_copy(slf, slf_t, owned)]/~, target_static_self(f_res.val))\n       }\n       self_env(_, slf_t, some(slf)) {\n         let cast = PointerCast(bcx, f_res.val, T_ptr(T_nil()));\n         ([env_copy(cast, ty::mk_nil_ptr(ccx.tcx), owned_imm),\n-          env_copy(slf, slf_t, owned_imm)], target_self)\n+          env_copy(slf, slf_t, owned_imm)]/~, target_self)\n       }\n     };\n \n@@ -498,7 +499,7 @@ fn make_fn_glue(\n     let tcx = cx.tcx();\n \n     let fn_env = fn@(ck: ty::closure_kind) -> block {\n-        let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n+        let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]/~);\n         let box_ptr_v = Load(cx, box_cell_v);\n         with_cond(cx, IsNotNull(cx, box_ptr_v)) {|bcx|\n             let closure_ty = ty::mk_opaque_closure_ptr(tcx, ck);\n@@ -536,28 +537,28 @@ fn make_opaque_cbox_take_glue(\n     with_cond(bcx, IsNotNull(bcx, cbox_in)) {|bcx|\n         // Load the size from the type descr found in the cbox\n         let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n-        let tydescptr = GEPi(bcx, cbox_in, [0u, abi::box_field_tydesc]);\n+        let tydescptr = GEPi(bcx, cbox_in, [0u, abi::box_field_tydesc]/~);\n         let tydesc = Load(bcx, tydescptr);\n         let tydesc = PointerCast(bcx, tydesc, T_ptr(ccx.tydesc_type));\n-        let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]));\n+        let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]/~));\n \n         // Adjust sz to account for the rust_opaque_box header fields\n         let sz = Add(bcx, sz, shape::llsize_of(ccx, T_box_header(ccx)));\n \n         // Allocate memory, update original ptr, and copy existing data\n         let malloc = ccx.upcalls.exchange_malloc;\n-        let cbox_out = Call(bcx, malloc, [tydesc, sz]);\n+        let cbox_out = Call(bcx, malloc, [tydesc, sz]/~);\n         let cbox_out = PointerCast(bcx, cbox_out, llopaquecboxty);\n         call_memmove(bcx, cbox_out, cbox_in, sz);\n         Store(bcx, cbox_out, cboxptr);\n \n         // Take the (deeply cloned) type descriptor\n-        let tydesc_out = GEPi(bcx, cbox_out, [0u, abi::box_field_tydesc]);\n+        let tydesc_out = GEPi(bcx, cbox_out, [0u, abi::box_field_tydesc]/~);\n         let bcx = take_ty(bcx, tydesc_out, ty::mk_type(tcx));\n \n         // Take the data in the tuple\n         let ti = none;\n-        let cdata_out = GEPi(bcx, cbox_out, [0u, abi::box_field_body]);\n+        let cdata_out = GEPi(bcx, cbox_out, [0u, abi::box_field_body]/~);\n         call_tydesc_glue_full(bcx, cdata_out, tydesc,\n                               abi::tydesc_field_take_glue, ti);\n         bcx\n@@ -599,13 +600,13 @@ fn make_opaque_cbox_free_glue(\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n         let cbox = PointerCast(bcx, cbox, T_opaque_cbox_ptr(ccx));\n-        let tydescptr = GEPi(bcx, cbox, [0u, abi::box_field_tydesc]);\n+        let tydescptr = GEPi(bcx, cbox, [0u, abi::box_field_tydesc]/~);\n         let tydesc = Load(bcx, tydescptr);\n         let tydesc = PointerCast(bcx, tydesc, lltydescty);\n \n         // Drop the tuple data then free the descriptor\n         let ti = none;\n-        let cdata = GEPi(bcx, cbox, [0u, abi::box_field_body]);\n+        let cdata = GEPi(bcx, cbox, [0u, abi::box_field_body]/~);\n         call_tydesc_glue_full(bcx, cdata, tydesc,\n                               abi::tydesc_field_drop_glue, ti);\n \n@@ -634,14 +635,14 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n                     path: path,\n                     incoming_fty: ty::t,\n                     outgoing_fty: ty::t,\n-                    args: [option<@ast::expr>],\n+                    args: [option<@ast::expr>]/~,\n                     cdata_ty: ty::t,\n                     target_info: target_info)\n     -> {val: ValueRef, ty: TypeRef} {\n     let _icx = ccx.insn_ctxt(\"closure::trans_bind_thunk\");\n     let tcx = ccx.tcx;\n     #debug[\"trans_bind_thunk[incoming_fty=%s,outgoing_fty=%s,\\\n-            cdata_ty=%s]\",\n+            cdata_ty=%s]/~\",\n            ty_to_str(tcx, incoming_fty),\n            ty_to_str(tcx, outgoing_fty),\n            ty_to_str(tcx, cdata_ty)];\n@@ -701,22 +702,25 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n         (fptr, llvm::LLVMGetUndef(T_opaque_cbox_ptr(ccx)), 0u)\n       }\n       target_closure {\n-        let pair = GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, 0u]);\n+        let pair = GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, 0u]/~);\n         let lltargetenv =\n-            Load(bcx, GEPi(bcx, pair, [0u, abi::fn_field_box]));\n+            Load(bcx, GEPi(bcx, pair, [0u, abi::fn_field_box]/~));\n         let lltargetfn = Load\n-            (bcx, GEPi(bcx, pair, [0u, abi::fn_field_code]));\n+            (bcx, GEPi(bcx, pair, [0u, abi::fn_field_code]/~));\n         (lltargetfn, lltargetenv, 1u)\n       }\n       target_self {\n         let fptr = Load(bcx, GEPi(bcx, llcdata,\n-                                  [0u, abi::closure_body_bindings, 0u]));\n-        let slfbox = GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, 1u]);\n-        let selfptr = GEPi(bcx, Load(bcx, slfbox), [0u, abi::box_field_body]);\n+                                  [0u, abi::closure_body_bindings, 0u]/~));\n+        let slfbox =\n+            GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, 1u]/~);\n+        let selfptr =\n+            GEPi(bcx, Load(bcx, slfbox), [0u, abi::box_field_body]/~);\n         (fptr, PointerCast(bcx, selfptr, T_opaque_cbox_ptr(ccx)), 2u)\n       }\n       target_static_self(fptr) {\n-        let slfptr = GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, 0u]);\n+        let slfptr =\n+            GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, 0u]/~);\n         (fptr, PointerCast(bcx, slfptr, T_opaque_cbox_ptr(ccx)), 1u)\n       }\n     };\n@@ -728,7 +732,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     let outgoing_args = ty::ty_fn_args(outgoing_fty);\n \n     // Set up the three implicit arguments to the thunk.\n-    let mut llargs: [ValueRef] = [fcx.llretptr, lltargetenv];\n+    let mut llargs: [ValueRef]/~ = [fcx.llretptr, lltargetenv]/~;\n \n     let mut a: uint = first_real_arg; // retptr, env come first\n     let mut b: uint = starting_idx;\n@@ -740,7 +744,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n           // closure.\n           some(e) {\n             let mut val =\n-                GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, b]);\n+                GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, b]/~);\n \n             alt ty::resolved_mode(tcx, out_arg.mode) {\n               ast::by_val {\n@@ -754,13 +758,13 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n               }\n               ast::by_ref | ast::by_mutbl_ref | ast::by_move { }\n             }\n-            llargs += [val];\n+            llargs += [val]/~;\n             b += 1u;\n           }\n \n           // Arg will be provided when the thunk is invoked.\n           none {\n-            llargs += [llvm::LLVMGetParam(llthunk, a as c_uint)];\n+            llargs += [llvm::LLVMGetParam(llthunk, a as c_uint)]/~;\n             a += 1u;\n           }\n         }"}, {"sha": "109b533b007b9580058fe514fbb3a2e28bb8f1cf", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -58,9 +58,9 @@ type stats =\n      mut n_glues_created: uint,\n      mut n_null_glues: uint,\n      mut n_real_glues: uint,\n-     llvm_insn_ctxt: @mut [str],\n+     llvm_insn_ctxt: @mut [str]/~,\n      llvm_insns: hashmap<str, uint>,\n-     fn_times: @mut [{ident: str, time: int}]};\n+     fn_times: @mut [{ident: str, time: int}]/~};\n \n class BuilderRef_res {\n     let B: BuilderRef;\n@@ -92,7 +92,7 @@ type crate_ctxt = {\n      monomorphized: hashmap<mono_id, ValueRef>,\n      monomorphizing: hashmap<ast::def_id, uint>,\n      // Cache computed type parameter uses (see type_use.rs)\n-     type_use_cache: hashmap<ast::def_id, [type_use::type_uses]>,\n+     type_use_cache: hashmap<ast::def_id, [type_use::type_uses]/~>,\n      // Cache generated vtables\n      vtables: hashmap<mono_id, ValueRef>,\n      // Cache of constant strings,\n@@ -129,9 +129,9 @@ type val_self_pair = {v: ValueRef, t: ty::t};\n \n enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n \n-type param_substs = {tys: [ty::t],\n+type param_substs = {tys: [ty::t]/~,\n                      vtables: option<typeck::vtable_res>,\n-                     bounds: @[ty::param_bounds]};\n+                     bounds: @[ty::param_bounds]/~};\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n@@ -217,7 +217,7 @@ type cleanup_path = {target: option<BasicBlockRef>,\n                      dest: BasicBlockRef};\n \n fn scope_clean_changed(info: scope_info) {\n-    if info.cleanup_paths.len() > 0u { info.cleanup_paths = []; }\n+    if info.cleanup_paths.len() > 0u { info.cleanup_paths = []/~; }\n     info.landing_pad = none;\n }\n \n@@ -237,7 +237,7 @@ fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean({|a|base::drop_ty(a, val, ty)},\n-                                cleanup_type)];\n+                                cleanup_type)]/~;\n         scope_clean_changed(info);\n     }\n }\n@@ -257,7 +257,7 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n     }\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean_temp(val, {|a|do_drop(a, val, ty)},\n-                                     cleanup_type)];\n+                                     cleanup_type)]/~;\n         scope_clean_changed(info);\n     }\n }\n@@ -269,7 +269,7 @@ fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean_temp(val, {|a|base::drop_ty(a, val, ty)},\n-                                     cleanup_type)];\n+                                     cleanup_type)]/~;\n         scope_clean_changed(info);\n     }\n }\n@@ -278,7 +278,7 @@ fn add_clean_free(cx: block, ptr: ValueRef, shared: bool) {\n     else { {|a|base::trans_free(a, ptr)} };\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean_temp(ptr, free_fn,\n-                                     normal_exit_and_unwind)];\n+                                     normal_exit_and_unwind)]/~;\n         scope_clean_changed(info);\n     }\n }\n@@ -318,10 +318,10 @@ type scope_info = {\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n     // block.\n-    mut cleanups: [cleanup],\n+    mut cleanups: [cleanup]/~,\n     // Existing cleanup paths that may be reused, indexed by destination and\n     // cleared when the set of cleanups changes.\n-    mut cleanup_paths: [cleanup_path],\n+    mut cleanup_paths: [cleanup_path]/~,\n     // Unwinding landing pad. Also cleared when cleanups change.\n     mut landing_pad: option<BasicBlockRef>,\n };\n@@ -551,21 +551,21 @@ fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n     ret T_int(targ_cfg);\n }\n \n-fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef unsafe {\n+fn T_fn(inputs: [TypeRef]/~, output: TypeRef) -> TypeRef unsafe {\n     ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n                                inputs.len() as c_uint,\n                                False);\n }\n \n fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n-    ret T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n+    ret T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)]/~);\n }\n \n fn T_ptr(t: TypeRef) -> TypeRef {\n     ret llvm::LLVMPointerType(t, 0u as c_uint);\n }\n \n-fn T_struct(elts: [TypeRef]) -> TypeRef unsafe {\n+fn T_struct(elts: [TypeRef]/~) -> TypeRef unsafe {\n     ret llvm::LLVMStructType(to_ptr(elts), elts.len() as c_uint, False);\n }\n \n@@ -574,12 +574,12 @@ fn T_named_struct(name: str) -> TypeRef {\n     ret str::as_c_str(name, {|buf| llvm::LLVMStructCreateNamed(c, buf) });\n }\n \n-fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n+fn set_struct_body(t: TypeRef, elts: [TypeRef]/~) unsafe {\n     llvm::LLVMStructSetBody(t, to_ptr(elts),\n                             elts.len() as c_uint, False);\n }\n \n-fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n+fn T_empty_struct() -> TypeRef { ret T_struct([]/~); }\n \n // A vtable is, in reality, a vtable pointer followed by zero or more pointers\n // to tydescs and other vtables that it closes over. But the types and number\n@@ -604,15 +604,15 @@ fn T_task(targ_cfg: @session::config) -> TypeRef {\n     let t_int = T_int(targ_cfg);\n     let elems =\n         [t_int, t_int, t_int, t_int,\n-         t_int, t_int, t_int, t_int];\n+         t_int, t_int, t_int, t_int]/~;\n     set_struct_body(t, elems);\n     ret t;\n }\n \n fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef unsafe {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n-    let tydesc_elts: [TypeRef] =\n+    let tydesc_elts: [TypeRef]/~ =\n         vec::from_elem::<TypeRef>(abi::n_tydesc_fields,\n                                  T_nil());\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n@@ -635,14 +635,14 @@ fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n     let pvoid = T_ptr(T_i8());\n     let glue_fn_ty =\n         T_ptr(T_fn([T_ptr(T_nil()), T_ptr(T_nil()), tydescpp,\n-                    pvoid], T_void()));\n+                    pvoid]/~, T_void()));\n \n     let int_type = T_int(targ_cfg);\n     let elems =\n         [tydescpp, int_type, int_type,\n          glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty,\n          int_type, int_type, int_type, int_type,\n-         T_ptr(T_i8()), T_ptr(T_i8()), int_type, int_type];\n+         T_ptr(T_i8()), T_ptr(T_i8()), int_type, int_type]/~;\n     set_struct_body(tydesc, elems);\n     ret tydesc;\n }\n@@ -655,7 +655,7 @@ fn T_array(t: TypeRef, n: uint) -> TypeRef {\n fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n     ret T_struct([T_int(targ_cfg), // fill\n                   T_int(targ_cfg), // alloc\n-                  T_array(t, 0u)]); // elements\n+                  T_array(t, 0u)]/~); // elements\n }\n \n fn T_vec(ccx: @crate_ctxt, t: TypeRef) -> TypeRef {\n@@ -674,20 +674,20 @@ fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm});\n     ret ty::mk_tup(tcx, [ty::mk_uint(tcx), ty::mk_type(tcx),\n                          ptr, ptr,\n-                         t]);\n+                         t]/~);\n }\n \n-fn T_box_header_fields(cx: @crate_ctxt) -> [TypeRef] {\n+fn T_box_header_fields(cx: @crate_ctxt) -> [TypeRef]/~ {\n     let ptr = T_ptr(T_i8());\n-    ret [cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n+    ret [cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr]/~;\n }\n \n fn T_box_header(cx: @crate_ctxt) -> TypeRef {\n     ret T_struct(T_box_header_fields(cx));\n }\n \n fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n-    ret T_struct(T_box_header_fields(cx) + [t]);\n+    ret T_struct(T_box_header_fields(cx) + [t]/~);\n }\n \n fn T_box_ptr(t: TypeRef) -> TypeRef {\n@@ -704,7 +704,7 @@ fn T_opaque_box_ptr(cx: @crate_ctxt) -> TypeRef {\n }\n \n fn T_unique(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n-    ret T_struct(T_box_header_fields(cx) + [t]);\n+    ret T_struct(T_box_header_fields(cx) + [t]/~);\n }\n \n fn T_unique_ptr(t: TypeRef) -> TypeRef {\n@@ -713,12 +713,12 @@ fn T_unique_ptr(t: TypeRef) -> TypeRef {\n }\n \n fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n-    ret T_struct([cx.int_type]); // Refcount\n+    ret T_struct([cx.int_type]/~); // Refcount\n \n }\n \n fn T_chan(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n-    ret T_struct([cx.int_type]); // Refcount\n+    ret T_struct([cx.int_type]/~); // Refcount\n \n }\n \n@@ -749,7 +749,7 @@ fn T_enum_discrim(cx: @crate_ctxt) -> TypeRef {\n fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n     let s = \"opaque_enum\";\n     alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n-    let t = T_struct([T_enum_discrim(cx), T_i8()]);\n+    let t = T_struct([T_enum_discrim(cx), T_i8()]/~);\n     associate_type(cx.tn, s, t);\n     ret t;\n }\n@@ -763,7 +763,7 @@ fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n }\n \n fn T_opaque_iface(cx: @crate_ctxt) -> TypeRef {\n-    T_struct([T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n+    T_struct([T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)]/~)\n }\n \n fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n@@ -836,7 +836,7 @@ fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n \n fn C_estr_slice(cx: @crate_ctxt, s: str) -> ValueRef {\n     let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n-    C_struct([cs, C_uint(cx, str::len(s) + 1u /* +1 for null */)])\n+    C_struct([cs, C_uint(cx, str::len(s) + 1u /* +1 for null */)]/~)\n }\n \n // Returns a Plain Old LLVM String:\n@@ -848,34 +848,34 @@ fn C_postr(s: str) -> ValueRef {\n \n fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n     let mut i = 0u;\n-    let mut elts: [ValueRef] = [];\n-    while i < size { elts += [C_u8(0u)]; i += 1u; }\n+    let mut elts: [ValueRef]/~ = []/~;\n+    while i < size { elts += [C_u8(0u)]/~; i += 1u; }\n     ret llvm::LLVMConstArray(T_i8(), vec::unsafe::to_ptr(elts),\n                              elts.len() as c_uint);\n }\n \n-fn C_struct(elts: [ValueRef]) -> ValueRef unsafe {\n+fn C_struct(elts: [ValueRef]/~) -> ValueRef unsafe {\n     ret llvm::LLVMConstStruct(vec::unsafe::to_ptr(elts),\n                               elts.len() as c_uint, False);\n }\n \n-fn C_named_struct(T: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n+fn C_named_struct(T: TypeRef, elts: [ValueRef]/~) -> ValueRef unsafe {\n     ret llvm::LLVMConstNamedStruct(T, vec::unsafe::to_ptr(elts),\n                                    elts.len() as c_uint);\n }\n \n-fn C_array(ty: TypeRef, elts: [ValueRef]) -> ValueRef unsafe {\n+fn C_array(ty: TypeRef, elts: [ValueRef]/~) -> ValueRef unsafe {\n     ret llvm::LLVMConstArray(ty, vec::unsafe::to_ptr(elts),\n                              elts.len() as c_uint);\n }\n \n-fn C_bytes(bytes: [u8]) -> ValueRef unsafe {\n+fn C_bytes(bytes: [u8]/~) -> ValueRef unsafe {\n     ret llvm::LLVMConstString(\n         unsafe::reinterpret_cast(vec::unsafe::to_ptr(bytes)),\n         bytes.len() as c_uint, False);\n }\n \n-fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n+fn C_shape(ccx: @crate_ctxt, bytes: [u8]/~) -> ValueRef {\n     let llshape = C_bytes(bytes);\n     let llglobal = str::as_c_str(ccx.names(\"shape\"), {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n@@ -892,11 +892,11 @@ fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n \n // Used to identify cached monomorphized functions and vtables\n enum mono_param_id {\n-    mono_precise(ty::t, option<[mono_id]>),\n+    mono_precise(ty::t, option<[mono_id]/~>),\n     mono_any,\n     mono_repr(uint /* size */, uint /* align */),\n }\n-type mono_id = @{def: ast::def_id, params: [mono_param_id]};\n+type mono_id = @{def: ast::def_id, params: [mono_param_id]/~};\n fn hash_mono_id(&&mi: mono_id) -> uint {\n     let mut h = syntax::ast_util::hash_def(mi.def);\n     for vec::each(mi.params) {|param|\n@@ -954,7 +954,7 @@ fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n-fn node_id_type_params(bcx: block, id: ast::node_id) -> [ty::t] {\n+fn node_id_type_params(bcx: block, id: ast::node_id) -> [ty::t]/~ {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n     alt bcx.fcx.param_substs {\n@@ -966,7 +966,7 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> [ty::t] {\n }\n \n fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n-                    fields: [ty::field])\n+                    fields: [ty::field]/~)\n     -> uint {\n     alt ty::field_idx(ident, fields) {\n        none { cx.sess.span_bug(sp, #fmt(\"base expr doesn't appear to \\\n@@ -975,7 +975,7 @@ fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n     }\n }\n \n-fn dummy_substs(tps: [ty::t]) -> ty::substs {\n+fn dummy_substs(tps: [ty::t]/~) -> ty::substs {\n     {self_r: some(ty::re_bound(ty::br_self)),\n      self_ty: none,\n      tps: tps}"}, {"sha": "219658cebb9ecc3a75c9616abd4869ca87001376", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -64,7 +64,7 @@ fn lli64(val: int) -> ValueRef {\n fn lli1(bval: bool) -> ValueRef {\n     C_bool(bval)\n }\n-fn llmdnode(elems: [ValueRef]) -> ValueRef unsafe {\n+fn llmdnode(elems: [ValueRef]/~) -> ValueRef unsafe {\n     llvm::LLVMMDNode(vec::unsafe::to_ptr(elems),\n                      vec::len(elems) as libc::c_uint)\n }\n@@ -99,9 +99,9 @@ fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n     let existing = if cache.contains_key(mdtag) {\n         cache.get(mdtag)\n     } else {\n-        []\n+        []/~\n     };\n-    cache.insert(mdtag, existing + [val]);\n+    cache.insert(mdtag, existing + [val]/~);\n }\n \n type metadata<T> = {node: ValueRef, data: T};\n@@ -115,7 +115,7 @@ type block_md = {start: codemap::loc, end: codemap::loc};\n type argument_md = {id: ast::node_id};\n type retval_md = {id: ast::node_id};\n \n-type metadata_cache = hashmap<int, [debug_metadata]>;\n+type metadata_cache = hashmap<int, [debug_metadata]/~>;\n \n enum debug_metadata {\n     file_metadata(@metadata<file_md>),\n@@ -183,7 +183,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n                          lli1(cx.sess.opts.optimize != 0u),\n                          llstr(\"\"), // flags (???)\n                          lli32(0) // runtime version (???)\n-                        ];\n+                        ]/~;\n     let unit_node = llmdnode(unit_metadata);\n     add_named_metadata(cx, \"llvm.dbg.cu\", unit_node);\n     let mdval = @{node: unit_node, data: {name: crate_name}};\n@@ -220,7 +220,7 @@ fn create_file(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n     let file_md = [lltag(tg),\n                    llstr(file_path),\n                    llstr(work_dir),\n-                   unit_node];\n+                   unit_node]/~;\n     let val = llmdnode(file_md);\n     let mdval = @{node: val, data: {path: full_path}};\n     update_cache(cache, tg, file_metadata(mdval));\n@@ -268,7 +268,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n                   lli32(start.col as int),\n                   file_node.node,\n                   lli32(unique_id)\n-                 ];\n+                 ]/~;\n     let val = llmdnode(lldata);\n     let mdval = @{node: val, data: {start: start, end: end}};\n     //update_cache(cache, tg, block_metadata(mdval));\n@@ -328,7 +328,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n                   lli64(align * 8), // alignment in bits\n                   lli64(0), //XXX offset?\n                   lli32(0), //XXX flags?\n-                  lli32(encoding)];\n+                  lli32(encoding)]/~;\n     let llnode = llmdnode(lldata);\n     let mdval = @{node: llnode, data: {hash: ty::type_id(t)}};\n     update_cache(cache, tg, tydesc_metadata(mdval));\n@@ -362,7 +362,7 @@ type struct_ctxt = {\n     file: ValueRef,\n     name: str,\n     line: int,\n-    mut members: [ValueRef],\n+    mut members: [ValueRef]/~,\n     mut total_size: int,\n     align: int\n };\n@@ -378,7 +378,7 @@ fn create_structure(file: @metadata<file_md>, name: str, line: int)\n     let cx = @{file: file.node,\n                name: name,\n                line: line,\n-               mut members: [],\n+               mut members: []/~,\n                mut total_size: 0,\n                align: 64 //XXX different alignment per arch?\n               };\n@@ -397,19 +397,19 @@ fn create_derived_type(type_tag: int, file: ValueRef, name: str, line: int,\n                   lli64(align),\n                   lli64(offset),\n                   lli32(0),\n-                  ty];\n+                  ty]/~;\n     ret llmdnode(lldata);\n }\n \n fn add_member(cx: @struct_ctxt, name: str, line: int, size: int, align: int,\n               ty: ValueRef) {\n     cx.members += [create_derived_type(MemberTag, cx.file, name, line,\n                                        size * 8, align * 8, cx.total_size,\n-                                       ty)];\n+                                       ty)]/~;\n     cx.total_size += size * 8;\n }\n \n-fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n+fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field]/~,\n                  span: span) -> @metadata<tydesc_md> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n@@ -461,7 +461,7 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n fn create_composite_type(type_tag: int, name: str, file: ValueRef, line: int,\n                          size: int, align: int, offset: int,\n                          derived: option<ValueRef>,\n-                         members: option<[ValueRef]>)\n+                         members: option<[ValueRef]/~>)\n     -> ValueRef {\n     let lldata = [lltag(type_tag),\n                   file,\n@@ -484,7 +484,7 @@ fn create_composite_type(type_tag: int, name: str, file: ValueRef, line: int,\n                   },\n                   lli32(0),  // runtime language\n                   llnull()\n-                 ];\n+                 ]/~;\n     ret llmdnode(lldata);\n }\n \n@@ -501,12 +501,12 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n     add_member(scx, \"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(0)]);\n+    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(0)]/~);\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n     let data_ptr = create_composite_type(ArrayTypeTag, \"\", file_node.node, 0,\n                                          arr_size, arr_align, 0,\n                                          option::some(elem_ty_md.node),\n-                                         option::some([subrange]));\n+                                         option::some([subrange]/~));\n     add_member(scx, \"data\", 0, 0, // clang says the size should be 0\n                sys::min_align_of::<u8>() as int, data_ptr);\n     let llnode = finish_structure(scx);\n@@ -548,12 +548,12 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n           ty::ty_uniq(mt) { ast::ty_uniq({ty: t_to_ty(cx, mt.ty, span),\n                                           mutbl: mt.mutbl}) }\n           ty::ty_rec(fields) {\n-            let fs = [];\n+            let fs = []/~;\n             for field in fields {\n                 fs += [{node: {ident: field.ident,\n                                mt: {ty: t_to_ty(cx, field.mt.ty, span),\n                                     mutbl: field.mt.mutbl}},\n-                        span: span}];\n+                        span: span}]/~;\n             }\n             ast::ty_rec(fs)\n           }\n@@ -630,7 +630,7 @@ fn create_var(type_tag: int, context: ValueRef, name: str, file: ValueRef,\n                   lli32(line),\n                   ret_ty,\n                   lli32(0)\n-                 ];\n+                 ]/~;\n     ret llmdnode(lldata);\n }\n \n@@ -678,7 +678,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n         }\n       }\n     };\n-    let declargs = [llmdnode([llptr]), mdnode];\n+    let declargs = [llmdnode([llptr]/~), mdnode]/~;\n     trans::build::Call(bcx, cx.intrinsics.get(\"llvm.dbg.declare\"),\n                        declargs);\n     ret mdval;\n@@ -709,7 +709,7 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let llptr = alt fcx.llargs.get(arg.id) {\n       local_mem(v) | local_imm(v) { v }\n     };\n-    let declargs = [llmdnode([llptr]), mdnode];\n+    let declargs = [llmdnode([llptr]/~), mdnode]/~;\n     trans::build::Call(bcx, cx.intrinsics.get(\"llvm.dbg.declare\"),\n                        declargs);\n     ret mdval;\n@@ -725,7 +725,7 @@ fn update_source_pos(cx: block, s: span) {\n     let scopedata = [lli32(loc.line as int),\n                      lli32(loc.col as int),\n                      blockmd.node,\n-                     llnull()];\n+                     llnull()]/~;\n     let dbgscope = llmdnode(scopedata);\n     llvm::LLVMSetCurrentDebugLocation(trans::build::B(cx), dbgscope);\n }\n@@ -796,7 +796,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     };\n     let sub_node = create_composite_type(SubroutineTag, \"\", file_node, 0, 0,\n                                          0, 0, option::none,\n-                                         option::some([ty_node]));\n+                                         option::some([ty_node]/~));\n \n     let fn_metadata = [lltag(SubprogramTag),\n                        llunused(),\n@@ -818,7 +818,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n                        //list of template params\n                        //func decl descriptor\n                        //list of func vars\n-                      ];\n+                      ]/~;\n     let val = llmdnode(fn_metadata);\n     add_named_metadata(cx, \"llvm.dbg.sp\", val);\n     let mdval = @{node: val, data: {id: id}};"}, {"sha": "b38fa05f465fd331420d04e26f9eb2aa0e2bf819", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -16,14 +16,14 @@ import lib::llvm::llvm::LLVMGetParam;\n import std::map::hashmap;\n \n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n-              methods: [@ast::method], tps: [ast::ty_param]) {\n+              methods: [@ast::method]/~, tps: [ast::ty_param]/~) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { ret; }\n-    let sub_path = path + [path_name(name)];\n+    let sub_path = path + [path_name(name)]/~;\n     for vec::each(methods) {|m|\n         if m.tps.len() == 0u {\n             let llfn = get_item_val(ccx, m.id);\n-            trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n+            trans_fn(ccx, sub_path + [path_name(m.ident)]/~, m.decl, m.body,\n                      llfn, impl_self(ty::node_id_to_type(ccx.tcx, m.self_id)),\n                      none, m.id);\n         }\n@@ -34,14 +34,14 @@ fn trans_self_arg(bcx: block, base: @ast::expr, derefs: uint) -> result {\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n-    let mut temp_cleanups = [];\n+    let mut temp_cleanups = []/~;\n     let result = trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n                                 T_ptr(type_of::type_of(bcx.ccx(), basety)),\n                                 base, temp_cleanups, none, derefs);\n \n     // by-ref self argument should not require cleanup in the case of\n     // other arguments failing:\n-    assert temp_cleanups == [];\n+    assert temp_cleanups == []/~;\n \n     ret result;\n }\n@@ -73,7 +73,8 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n     }\n }\n \n-fn method_from_methods(ms: [@ast::method], name: ast::ident) -> ast::def_id {\n+fn method_from_methods(ms: [@ast::method]/~, name: ast::ident)\n+    -> ast::def_id {\n   local_def(option::get(vec::find(ms, {|m| m.ident == name})).id)\n }\n \n@@ -147,16 +148,16 @@ fn trans_iface_callee(bcx: block, val: ValueRef,\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_iface_callee\");\n     let ccx = bcx.ccx();\n-    let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0u, 0u]),\n+    let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0u, 0u]/~),\n                                        T_ptr(T_ptr(T_vtable()))));\n-    let box = Load(bcx, GEPi(bcx, val, [0u, 1u]));\n-    // FIXME[impl] I doubt this is alignment-safe (#2534)\n-    let self = GEPi(bcx, box, [0u, abi::box_field_body]);\n+    let box = Load(bcx, GEPi(bcx, val, [0u, 1u]/~));\n+    // FIXME[impl]/~ I doubt this is alignment-safe (#2534)\n+    let self = GEPi(bcx, box, [0u, abi::box_field_body]/~);\n     let env = self_env(self, ty::mk_opaque_box(bcx.tcx()), some(box));\n     let llfty = type_of::type_of_fn_from_ty(ccx, callee_ty);\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n-    let mptr = Load(bcx, GEPi(bcx, vtable, [0u, n_method]));\n+    let mptr = Load(bcx, GEPi(bcx, vtable, [0u, n_method]/~));\n     {bcx: bcx, val: mptr, kind: owned, env: env}\n }\n \n@@ -234,7 +235,7 @@ fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n     }\n }\n \n-fn make_vtable(ccx: @crate_ctxt, ptrs: [ValueRef]) -> ValueRef {\n+fn make_vtable(ccx: @crate_ctxt, ptrs: [ValueRef]/~) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n     let tbl = C_struct(ptrs);\n     let vt_gvar = str::as_c_str(ccx.names(\"vtable\"), {|buf|\n@@ -246,7 +247,7 @@ fn make_vtable(ccx: @crate_ctxt, ptrs: [ValueRef]) -> ValueRef {\n     vt_gvar\n }\n \n-fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n+fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t]/~,\n                     vtables: typeck::vtable_res) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n@@ -288,12 +289,12 @@ fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     let bcx = trans_expr_save_in(bcx, val, body);\n     revoke_clean(bcx, box);\n     let result = get_dest_addr(dest);\n-    Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0u, 1u]),\n+    Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0u, 1u]/~),\n                                 T_ptr(val_ty(box))));\n     let orig = ccx.maps.vtable_map.get(id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);\n-    Store(bcx, vtable, PointerCast(bcx, GEPi(bcx, result, [0u, 0u]),\n+    Store(bcx, vtable, PointerCast(bcx, GEPi(bcx, result, [0u, 0u]/~),\n                                    T_ptr(val_ty(vtable))));\n     bcx\n }"}, {"sha": "da687c8a3c88ba1cc23a7d08a8a379f0857f3a0f", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 76, "deletions": 74, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -44,7 +44,7 @@ fn is_sse(++c: x86_64_reg_class) -> bool {\n     };\n }\n \n-fn is_ymm(cls: [x86_64_reg_class]) -> bool {\n+fn is_ymm(cls: [x86_64_reg_class]/~) -> bool {\n     let len = vec::len(cls);\n     ret (len > 2u &&\n          is_sse(cls[0]) &&\n@@ -56,13 +56,13 @@ fn is_ymm(cls: [x86_64_reg_class]) -> bool {\n          cls[3] == sseup_class);\n }\n \n-fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n+fn classify_ty(ty: TypeRef) -> [x86_64_reg_class]/~ {\n     fn align(off: uint, ty: TypeRef) -> uint {\n         let a = ty_align(ty);\n         ret (off + a - 1u) / a * a;\n     }\n \n-    fn struct_tys(ty: TypeRef) -> [TypeRef] {\n+    fn struct_tys(ty: TypeRef) -> [TypeRef]/~ {\n         let n = llvm::LLVMCountStructElementTypes(ty);\n         let elts = vec::from_elem(n as uint, ptr::null());\n         vec::as_buf(elts) {|buf|\n@@ -119,13 +119,13 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n         };\n     }\n \n-    fn all_mem(cls: [mut x86_64_reg_class]) {\n+    fn all_mem(cls: [mut x86_64_reg_class]/~) {\n         for uint::range(0u, cls.len()) { |i|\n             cls[i] = memory_class;\n         }\n     }\n \n-    fn unify(cls: [mut x86_64_reg_class],\n+    fn unify(cls: [mut x86_64_reg_class]/~,\n              i: uint,\n              newv: x86_64_reg_class) {\n         if cls[i] == newv {\n@@ -150,8 +150,8 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n         }\n     }\n \n-    fn classify_struct(tys: [TypeRef],\n-                       cls: [mut x86_64_reg_class], i: uint,\n+    fn classify_struct(tys: [TypeRef]/~,\n+                       cls: [mut x86_64_reg_class]/~, i: uint,\n                        off: uint) {\n         if vec::is_empty(tys) {\n             classify(T_i64(), cls, i, off);\n@@ -166,7 +166,7 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n     }\n \n     fn classify(ty: TypeRef,\n-                cls: [mut x86_64_reg_class], ix: uint,\n+                cls: [mut x86_64_reg_class]/~, ix: uint,\n                 off: uint) {\n         let t_align = ty_align(ty);\n         let t_size = ty_size(ty);\n@@ -216,7 +216,7 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n         }\n     }\n \n-    fn fixup(ty: TypeRef, cls: [mut x86_64_reg_class]) {\n+    fn fixup(ty: TypeRef, cls: [mut x86_64_reg_class]/~) {\n         let mut i = 0u;\n         let llty = llvm::LLVMGetTypeKind(ty) as int;\n         let e = vec::len(cls);\n@@ -274,8 +274,8 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n     ret vec::from_mut(cls);\n }\n \n-fn llreg_ty(cls: [x86_64_reg_class]) -> TypeRef {\n-    fn llvec_len(cls: [x86_64_reg_class]) -> uint {\n+fn llreg_ty(cls: [x86_64_reg_class]/~) -> TypeRef {\n+    fn llvec_len(cls: [x86_64_reg_class]/~) -> uint {\n         let mut len = 1u;\n         for vec::each(cls) {|c|\n             if c != sseup_class {\n@@ -286,27 +286,27 @@ fn llreg_ty(cls: [x86_64_reg_class]) -> TypeRef {\n         ret len;\n     }\n \n-    let mut tys = [];\n+    let mut tys = []/~;\n     let mut i = 0u;\n     let e = vec::len(cls);\n     while i < e {\n         alt cls[i] {\n             integer_class {\n-                tys += [T_i64()];\n+                tys += [T_i64()]/~;\n             }\n             sse_fv_class {\n                 let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n                 let vec_ty = llvm::LLVMVectorType(T_f32(),\n                                                   vec_len as c_uint);\n-                tys += [vec_ty];\n+                tys += [vec_ty]/~;\n                 i += vec_len;\n                 cont;\n             }\n             sse_fs_class {\n-                tys += [T_f32()];\n+                tys += [T_f32()]/~;\n             }\n             sse_ds_class {\n-                tys += [T_f64()];\n+                tys += [T_f64()]/~;\n             }\n             _ {\n                 fail \"llregtype: unhandled class\";\n@@ -323,13 +323,13 @@ type x86_64_llty = {\n };\n \n type x86_64_tys = {\n-    arg_tys: [x86_64_llty],\n+    arg_tys: [x86_64_llty]/~,\n     ret_ty: x86_64_llty,\n-    attrs: [option<Attribute>],\n+    attrs: [option<Attribute>]/~,\n     sret: bool\n };\n \n-fn x86_64_tys(atys: [TypeRef],\n+fn x86_64_tys(atys: [TypeRef]/~,\n               rty: TypeRef,\n               ret_def: bool) -> x86_64_tys {\n     fn is_reg_ty(ty: TypeRef) -> bool {\n@@ -342,18 +342,18 @@ fn x86_64_tys(atys: [TypeRef],\n         };\n     }\n \n-    fn is_pass_byval(cls: [x86_64_reg_class]) -> bool {\n+    fn is_pass_byval(cls: [x86_64_reg_class]/~) -> bool {\n         ret cls[0] == memory_class ||\n             cls[0] == x87_class ||\n             cls[0] == complex_x87_class;\n     }\n \n-    fn is_ret_bysret(cls: [x86_64_reg_class]) -> bool {\n+    fn is_ret_bysret(cls: [x86_64_reg_class]/~) -> bool {\n         ret cls[0] == memory_class;\n     }\n \n     fn x86_64_ty(ty: TypeRef,\n-                 is_mem_cls: fn(cls: [x86_64_reg_class]) -> bool,\n+                 is_mem_cls: fn(cls: [x86_64_reg_class]/~) -> bool,\n                  attr: Attribute) -> (x86_64_llty, option<Attribute>) {\n         let mut cast = false;\n         let mut ty_attr = option::none;\n@@ -371,22 +371,22 @@ fn x86_64_tys(atys: [TypeRef],\n         ret ({ cast: cast, ty: llty }, ty_attr);\n     }\n \n-    let mut arg_tys = [];\n-    let mut attrs = [];\n+    let mut arg_tys = []/~;\n+    let mut attrs = []/~;\n     for vec::each(atys) {|t|\n         let (ty, attr) = x86_64_ty(t, is_pass_byval, ByValAttribute);\n-        arg_tys += [ty];\n-        attrs += [attr];\n+        arg_tys += [ty]/~;\n+        attrs += [attr]/~;\n     }\n     let mut (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n                                        StructRetAttribute);\n     let sret = option::is_some(ret_attr);\n     if sret {\n-        arg_tys = [ret_ty] + arg_tys;\n+        arg_tys = [ret_ty]/~ + arg_tys;\n         ret_ty = { cast:  false,\n                    ty: T_void()\n                  };\n-        attrs = [ret_attr] + attrs;\n+        attrs = [ret_attr]/~ + attrs;\n     } else if !ret_def {\n         ret_ty = { cast: false,\n                    ty: T_void()\n@@ -427,7 +427,7 @@ fn link_name(i: @ast::native_item) -> str {\n }\n \n type c_stack_tys = {\n-    arg_tys: [TypeRef],\n+    arg_tys: [TypeRef]/~,\n     ret_ty: TypeRef,\n     ret_def: bool,\n     bundle_ty: TypeRef,\n@@ -436,7 +436,7 @@ type c_stack_tys = {\n };\n \n fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n-                       id: ast::node_id) -> ([TypeRef], TypeRef, ty::t) {\n+                       id: ast::node_id) -> ([TypeRef]/~, TypeRef, ty::t) {\n     alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n       ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n         let llargtys = type_of_explicit_args(ccx, arg_tys);\n@@ -450,7 +450,7 @@ fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n fn c_stack_tys(ccx: @crate_ctxt,\n                id: ast::node_id) -> @c_stack_tys {\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, id);\n-    let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n+    let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]/~);\n     let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n     let x86_64 = if ccx.sess.targ_cfg.arch == arch_x86_64 {\n         option::some(x86_64_tys(llargtys, llretty, ret_def))\n@@ -462,13 +462,13 @@ fn c_stack_tys(ccx: @crate_ctxt,\n         ret_ty: llretty,\n         ret_def: ret_def,\n         bundle_ty: bundle_ty,\n-        shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void()),\n+        shim_fn_ty: T_fn([T_ptr(bundle_ty)]/~, T_void()),\n         x86_64_tys: x86_64\n     };\n }\n \n type shim_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n-                           llargbundle: ValueRef) -> [ValueRef];\n+                           llargbundle: ValueRef) -> [ValueRef]/~;\n \n type shim_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef, llretval: ValueRef);\n@@ -485,7 +485,7 @@ fn build_shim_fn_(ccx: @crate_ctxt,\n         ccx.llmod, shim_name, tys.shim_fn_ty);\n \n     // Declare the body of the shim function:\n-    let fcx = new_fn_ctxt(ccx, [], llshimfn, none);\n+    let fcx = new_fn_ctxt(ccx, []/~, llshimfn, none);\n     let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n     let llargbundle = get_param(llshimfn, 0u);\n@@ -519,7 +519,7 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n                   ret_builder: wrap_ret_builder) {\n \n     let _icx = ccx.insn_ctxt(\"native::build_wrap_fn_\");\n-    let fcx = new_fn_ctxt(ccx, [], llwrapfn, none);\n+    let fcx = new_fn_ctxt(ccx, []/~, llwrapfn, none);\n     let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n \n@@ -530,7 +530,7 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n     // Create call itself.\n     let llshimfnptr = PointerCast(bcx, llshimfn, T_ptr(T_i8()));\n     let llrawargbundle = PointerCast(bcx, llargbundle, T_ptr(T_i8()));\n-    Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]);\n+    Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]/~);\n     ret_builder(bcx, tys, llargbundle);\n \n     tie_up_header_blocks(fcx, lltop);\n@@ -588,9 +588,9 @@ fn trans_native_mod(ccx: @crate_ctxt,\n         let _icx = ccx.insn_ctxt(\"native::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n-                      llargbundle: ValueRef) -> [ValueRef] {\n+                      llargbundle: ValueRef) -> [ValueRef]/~ {\n             let _icx = bcx.insn_ctxt(\"native::shim::build_args\");\n-            let mut llargvals = [];\n+            let mut llargvals = []/~;\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n \n@@ -599,33 +599,33 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                     let mut atys = x86_64.arg_tys;\n                     let mut attrs = x86_64.attrs;\n                     if x86_64.sret {\n-                        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n+                        let llretptr = GEPi(bcx, llargbundle, [0u, n]/~);\n                         let llretloc = Load(bcx, llretptr);\n-                        llargvals = [llretloc];\n+                        llargvals = [llretloc]/~;\n                         atys = vec::tail(atys);\n                         attrs = vec::tail(attrs);\n                     }\n                     while i < n {\n                         let llargval = if atys[i].cast {\n                             let arg_ptr = GEPi(bcx, llargbundle,\n-                                               [0u, i]);\n+                                               [0u, i]/~);\n                             let arg_ptr = BitCast(bcx, arg_ptr,\n                                               T_ptr(atys[i].ty));\n                             Load(bcx, arg_ptr)\n                         } else if option::is_some(attrs[i]) {\n-                            GEPi(bcx, llargbundle, [0u, i])\n+                            GEPi(bcx, llargbundle, [0u, i]/~)\n                         } else {\n-                            load_inbounds(bcx, llargbundle, [0u, i])\n+                            load_inbounds(bcx, llargbundle, [0u, i]/~)\n                         };\n-                        llargvals += [llargval];\n+                        llargvals += [llargval]/~;\n                         i += 1u;\n                     }\n                 }\n                 _ {\n                     while i < n {\n                         let llargval = load_inbounds(bcx, llargbundle,\n-                                                          [0u, i]);\n-                        llargvals += [llargval];\n+                                                          [0u, i]/~);\n+                        llargvals += [llargval]/~;\n                         i += 1u;\n                     }\n                 }\n@@ -652,7 +652,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                         ret;\n                     }\n                     let n = vec::len(tys.arg_tys);\n-                    let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n+                    let llretptr = GEPi(bcx, llargbundle, [0u, n]/~);\n                     let llretloc = Load(bcx, llretptr);\n                     if x86_64.ret_ty.cast {\n                         let tmp_ptr = BitCast(bcx, llretloc,\n@@ -666,7 +666,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                     if tys.ret_def {\n                         let n = vec::len(tys.arg_tys);\n                         // R** llretptr = &args->r;\n-                        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n+                        let llretptr = GEPi(bcx, llargbundle, [0u, n]/~);\n                         // R* llretloc = *llretptr; /* (args->r) */\n                         let llretloc = Load(bcx, llretptr);\n                         // *args->r = r;\n@@ -705,7 +705,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n     fn build_direct_fn(ccx: @crate_ctxt, decl: ValueRef,\n                        item: @ast::native_item, tys: @c_stack_tys,\n                        cc: lib::llvm::CallConv) {\n-        let fcx = new_fn_ctxt(ccx, [], decl, none);\n+        let fcx = new_fn_ctxt(ccx, []/~, decl, none);\n         let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n         let llbasefn = base_fn(ccx, link_name(item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n@@ -736,11 +736,11 @@ fn trans_native_mod(ccx: @crate_ctxt,\n             let implicit_args = first_real_arg; // ret + env\n             while i < n {\n                 let llargval = get_param(llwrapfn, i + implicit_args);\n-                store_inbounds(bcx, llargval, llargbundle, [0u, i]);\n+                store_inbounds(bcx, llargval, llargbundle, [0u, i]/~);\n                 i += 1u;\n             }\n             let llretptr = get_param(llwrapfn, 0u);\n-            store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n+            store_inbounds(bcx, llretptr, llargbundle, [0u, n]/~);\n         }\n \n         fn build_ret(bcx: block, _tys: @c_stack_tys,\n@@ -786,9 +786,9 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                       }\n                   };\n                   let psubsts = {\n-                      tys: [],\n+                      tys: []/~,\n                       vtables: none,\n-                      bounds: @[]\n+                      bounds: @[]/~\n                   };\n                   trans_intrinsic(ccx, llwrapfn, native_item,\n                                   *path, psubsts, none);\n@@ -894,7 +894,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n       }\n       \"frame_address\" {\n         let frameaddress = ccx.intrinsics.get(\"llvm.frameaddress\");\n-        let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]);\n+        let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]/~);\n         let fty = ty::mk_fn(bcx.tcx(), {\n             purity: ast::impure_fn,\n             proto: ast::proto_any,\n@@ -903,10 +903,10 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n                 ty: ty::mk_imm_ptr(\n                     bcx.tcx(),\n                     ty::mk_mach_uint(bcx.tcx(), ast::ty_u8))\n-            }],\n+            }]/~,\n             output: ty::mk_nil(bcx.tcx()),\n             ret_style: ast::return_val,\n-            constraints: []\n+            constraints: []/~\n         });\n         bcx = trans_call_inner(bcx, none, fty, ty::mk_nil(bcx.tcx()),\n                                { |bcx|\n@@ -915,7 +915,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n                                        get_param(decl, first_real_arg),\n                                        temporary)\n                                },\n-                               arg_vals([frameaddress_val]), ignore);\n+                               arg_vals([frameaddress_val]/~), ignore);\n       }\n     }\n     build_return(bcx);\n@@ -933,7 +933,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         let _icx = ccx.insn_ctxt(\"native::crust::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n-            ccx, path + [ast_map::path_name(@\"__rust_abi\")]);\n+            ccx, path + [ast_map::path_name(@\"__rust_abi\")]/~);\n         let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n         trans_fn(ccx, path, decl, body, llfndecl, no_self, none, id);\n@@ -946,18 +946,18 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         let _icx = ccx.insn_ctxt(\"native::crust::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n-                      llargbundle: ValueRef) -> [ValueRef] {\n+                      llargbundle: ValueRef) -> [ValueRef]/~ {\n             let _icx = bcx.insn_ctxt(\"native::crust::shim::build_args\");\n-            let mut llargvals = [];\n+            let mut llargvals = []/~;\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n-            let llretptr = load_inbounds(bcx, llargbundle, [0u, n]);\n-            llargvals += [llretptr];\n+            let llretptr = load_inbounds(bcx, llargbundle, [0u, n]/~);\n+            llargvals += [llretptr]/~;\n             let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n-            llargvals += [llenvptr];\n+            llargvals += [llenvptr]/~;\n             while i < n {\n-                let llargval = load_inbounds(bcx, llargbundle, [0u, i]);\n-                llargvals += [llargval];\n+                let llargval = load_inbounds(bcx, llargbundle, [0u, i]/~);\n+                llargvals += [llargval]/~;\n                 i += 1u;\n             }\n             ret llargvals;\n@@ -970,7 +970,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         }\n \n         let shim_name = link::mangle_internal_name_by_path(\n-            ccx, path + [ast_map::path_name(@\"__rust_stack_shim\")]);\n+            ccx, path + [ast_map::path_name(@\"__rust_stack_shim\")]/~);\n         ret build_shim_fn_(ccx, shim_name, llrustfn, tys,\n                            lib::llvm::CCallConv,\n                            build_args, build_ret);\n@@ -1007,28 +1007,30 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                         let mut argval = get_param(llwrapfn, i + j);\n                         if option::is_some(attrs[i]) {\n                             argval = Load(bcx, argval);\n-                            store_inbounds(bcx, argval, llargbundle, [0u, i]);\n+                            store_inbounds(bcx, argval, llargbundle,\n+                                           [0u, i]/~);\n                         } else if atys[i].cast {\n-                            let argptr = GEPi(bcx, llargbundle, [0u, i]);\n+                            let argptr = GEPi(bcx, llargbundle, [0u, i]/~);\n                             let argptr = BitCast(bcx, argptr,\n                                                  T_ptr(atys[i].ty));\n                             Store(bcx, argval, argptr);\n                         } else {\n-                            store_inbounds(bcx, argval, llargbundle, [0u, i]);\n+                            store_inbounds(bcx, argval, llargbundle,\n+                                           [0u, i]/~);\n                         }\n                         i += 1u;\n                     }\n-                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n+                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]/~);\n                 }\n                 _ {\n                     let llretptr = alloca(bcx, tys.ret_ty);\n                     let n = vec::len(tys.arg_tys);\n                     for uint::range(0u, n) {|i|\n                         let llargval = get_param(llwrapfn, i);\n                         store_inbounds(bcx, llargval, llargbundle,\n-                                                      [0u, i]);\n+                                                      [0u, i]/~);\n                     };\n-                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n+                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]/~);\n                 }\n             }\n         }\n@@ -1043,7 +1045,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                         ret;\n                     }\n                     let n = vec::len(tys.arg_tys);\n-                    let llretval = load_inbounds(bcx, llargbundle, [0u, n]);\n+                    let llretval = load_inbounds(bcx, llargbundle, [0u, n]/~);\n                     let llretval = if x86_64.ret_ty.cast {\n                         let retptr = BitCast(bcx, llretval,\n                                                   T_ptr(x86_64.ret_ty.ty));\n@@ -1055,7 +1057,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                 }\n                 _ {\n                     let n = vec::len(tys.arg_tys);\n-                    let llretval = load_inbounds(bcx, llargbundle, [0u, n]);\n+                    let llretval = load_inbounds(bcx, llargbundle, [0u, n]/~);\n                     let llretval = Load(bcx, llretval);\n                     Ret(bcx, llretval);\n                 }"}, {"sha": "a745c347853a89f2a147966aa05c71a50a0f151b", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -31,7 +31,7 @@ fn find_reachable(crate_mod: _mod, exp_map: resolve::exp_map,\n     rmap\n }\n \n-fn traverse_exports(cx: ctx, vis: [@view_item]) -> bool {\n+fn traverse_exports(cx: ctx, vis: [@view_item]/~) -> bool {\n     let mut found_export = false;\n     for vec::each(vis) {|vi|\n         alt vi.node {"}, {"sha": "bad3d52f147ebb71b07b990026cfe3b3a22bc6e6", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -12,7 +12,7 @@ import util::ppaux::ty_to_str;\n \n enum reflector = {\n     visitor_val: ValueRef,\n-    visitor_methods: @[ty::method],\n+    visitor_methods: @[ty::method]/~,\n     mut bcx: block\n };\n \n@@ -31,15 +31,15 @@ impl methods for reflector {\n         do_spill_noroot(self.bcx, ss)\n     }\n \n-    fn c_size_and_align(t: ty::t) -> [ValueRef] {\n+    fn c_size_and_align(t: ty::t) -> [ValueRef]/~ {\n         let tr = type_of::type_of(self.bcx.ccx(), t);\n         let s = shape::llsize_of_real(self.bcx.ccx(), tr);\n         let a = shape::llalign_of_min(self.bcx.ccx(), tr);\n         ret [self.c_uint(s),\n-             self.c_uint(a)];\n+             self.c_uint(a)]/~;\n     }\n \n-    fn visit(ty_name: str, args: [ValueRef]) {\n+    fn visit(ty_name: str, args: [ValueRef]/~) {\n         let tcx = self.bcx.tcx();\n         let mth_idx = option::get(ty::method_idx(@(\"visit_\" + ty_name),\n                                                  *self.visitor_methods));\n@@ -69,33 +69,33 @@ impl methods for reflector {\n                              abi::tydesc_field_visit_glue);\n     }\n \n-    fn bracketed_t(bracket_name: str, t: ty::t, extra: [ValueRef]) {\n+    fn bracketed_t(bracket_name: str, t: ty::t, extra: [ValueRef]/~) {\n         self.visit(\"enter_\" + bracket_name, extra);\n         self.visit_tydesc(t);\n         self.visit(\"leave_\" + bracket_name, extra);\n     }\n \n-    fn bracketed_mt(bracket_name: str, mt: ty::mt, extra: [ValueRef]) {\n+    fn bracketed_mt(bracket_name: str, mt: ty::mt, extra: [ValueRef]/~) {\n         self.bracketed_t(bracket_name, mt.ty,\n-                         [self.c_uint(mt.mutbl as uint)] + extra);\n+                         [self.c_uint(mt.mutbl as uint)]/~ + extra);\n     }\n \n     fn vstore_name_and_extra(t: ty::t,\n                              vstore: ty::vstore,\n-                             f: fn(str,[ValueRef])) {\n+                             f: fn(str,[ValueRef]/~)) {\n         alt vstore {\n           ty::vstore_fixed(n) {\n-            let extra = [self.c_uint(n)] + self.c_size_and_align(t);\n+            let extra = [self.c_uint(n)]/~ + self.c_size_and_align(t);\n             f(\"fixed\", extra)\n           }\n-          ty::vstore_slice(_) { f(\"slice\", []) }\n-          ty::vstore_uniq { f(\"uniq\", []);}\n-          ty::vstore_box { f(\"box\", []); }\n+          ty::vstore_slice(_) { f(\"slice\", []/~) }\n+          ty::vstore_uniq { f(\"uniq\", []/~);}\n+          ty::vstore_box { f(\"box\", []/~); }\n         }\n     }\n \n     fn leaf(name: str) {\n-        self.visit(name, []);\n+        self.visit(name, []/~);\n     }\n \n     // Entrypoint\n@@ -125,7 +125,7 @@ impl methods for reflector {\n           ty::ty_float(ast::ty_f64) { self.leaf(\"f64\") }\n           ty::ty_str { self.leaf(\"str\") }\n \n-          ty::ty_vec(mt) { self.bracketed_mt(\"vec\", mt, []) }\n+          ty::ty_vec(mt) { self.bracketed_mt(\"vec\", mt, []/~) }\n           ty::ty_estr(vst) {\n             self.vstore_name_and_extra(t, vst) {|name, extra|\n                 self.visit(\"estr_\" + name, extra)\n@@ -136,29 +136,29 @@ impl methods for reflector {\n                 self.bracketed_mt(\"evec_\" + name, mt, extra)\n             }\n           }\n-          ty::ty_box(mt) { self.bracketed_mt(\"box\", mt, []) }\n-          ty::ty_uniq(mt) { self.bracketed_mt(\"uniq\", mt, []) }\n-          ty::ty_ptr(mt) { self.bracketed_mt(\"ptr\", mt, []) }\n-          ty::ty_rptr(_, mt) { self.bracketed_mt(\"rptr\", mt, []) }\n+          ty::ty_box(mt) { self.bracketed_mt(\"box\", mt, []/~) }\n+          ty::ty_uniq(mt) { self.bracketed_mt(\"uniq\", mt, []/~) }\n+          ty::ty_ptr(mt) { self.bracketed_mt(\"ptr\", mt, []/~) }\n+          ty::ty_rptr(_, mt) { self.bracketed_mt(\"rptr\", mt, []/~) }\n \n           ty::ty_rec(fields) {\n-            let extra = ([self.c_uint(vec::len(fields))]\n+            let extra = ([self.c_uint(vec::len(fields))]/~\n                          + self.c_size_and_align(t));\n             self.visit(\"enter_rec\", extra);\n             for fields.eachi {|i, field|\n                 self.bracketed_mt(\"rec_field\", field.mt,\n                                   [self.c_uint(i),\n-                                   self.c_slice(*field.ident)]);\n+                                   self.c_slice(*field.ident)]/~);\n             }\n             self.visit(\"leave_rec\", extra);\n           }\n \n           ty::ty_tup(tys) {\n-            let extra = ([self.c_uint(vec::len(tys))]\n+            let extra = ([self.c_uint(vec::len(tys))]/~\n                          + self.c_size_and_align(t));\n             self.visit(\"enter_tup\", extra);\n             for tys.eachi {|i, t|\n-                self.bracketed_t(\"tup_field\", t, [self.c_uint(i)]);\n+                self.bracketed_t(\"tup_field\", t, [self.c_uint(i)]/~);\n             }\n             self.visit(\"leave_tup\", extra);\n           }\n@@ -186,7 +186,7 @@ impl methods for reflector {\n             let extra = [self.c_uint(pureval),\n                          self.c_uint(protoval),\n                          self.c_uint(vec::len(fty.inputs)),\n-                         self.c_uint(retval)];\n+                         self.c_uint(retval)]/~;\n             self.visit(\"enter_fn\", extra);\n             for fty.inputs.eachi {|i, arg|\n                 let modeval = alt arg.mode {\n@@ -203,25 +203,25 @@ impl methods for reflector {\n                 };\n                 self.bracketed_t(\"fn_input\", arg.ty,\n                                  [self.c_uint(i),\n-                                  self.c_uint(modeval)]);\n+                                  self.c_uint(modeval)]/~);\n             }\n             self.bracketed_t(\"fn_output\", fty.output,\n-                             [self.c_uint(retval)]);\n+                             [self.c_uint(retval)]/~);\n             self.visit(\"leave_fn\", extra);\n           }\n \n           ty::ty_class(did, substs) {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;\n             let fields = ty::class_items_as_fields(tcx, did, substs);\n-            let extra = ([self.c_uint(vec::len(fields))]\n+            let extra = ([self.c_uint(vec::len(fields))]/~\n                          + self.c_size_and_align(t));\n \n             self.visit(\"enter_class\", extra);\n             for fields.eachi {|i, field|\n                 self.bracketed_mt(\"class_field\", field.mt,\n                                   [self.c_uint(i),\n-                                   self.c_slice(*field.ident)]);\n+                                   self.c_slice(*field.ident)]/~);\n             }\n             self.visit(\"leave_class\", extra);\n           }\n@@ -234,19 +234,19 @@ impl methods for reflector {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;\n             let variants = ty::substd_enum_variants(tcx, did, substs);\n-            let extra = ([self.c_uint(vec::len(variants))]\n+            let extra = ([self.c_uint(vec::len(variants))]/~\n                          + self.c_size_and_align(t));\n \n             self.visit(\"enter_enum\", extra);\n             for variants.eachi {|i, v|\n                 let extra = [self.c_uint(i),\n                              self.c_int(v.disr_val),\n                              self.c_uint(vec::len(v.args)),\n-                             self.c_slice(*v.name)];\n+                             self.c_slice(*v.name)]/~;\n                 self.visit(\"enter_enum_variant\", extra);\n                 for v.args.eachi {|j, a|\n                     self.bracketed_t(\"enum_variant_field\", a,\n-                                     [self.c_uint(j)]);\n+                                     [self.c_uint(j)]/~);\n                 }\n                 self.visit(\"leave_enum_variant\", extra);\n             }\n@@ -257,20 +257,20 @@ impl methods for reflector {\n           ty::ty_iface(_, _) { self.leaf(\"iface\") }\n           ty::ty_var(_) { self.leaf(\"var\") }\n           ty::ty_var_integral(_) { self.leaf(\"var_integral\") }\n-          ty::ty_param(n, _) { self.visit(\"param\", [self.c_uint(n)]) }\n+          ty::ty_param(n, _) { self.visit(\"param\", [self.c_uint(n)]/~) }\n           ty::ty_self { self.leaf(\"self\") }\n           ty::ty_type { self.leaf(\"type\") }\n           ty::ty_opaque_box { self.leaf(\"opaque_box\") }\n-          ty::ty_constr(t, _) { self.bracketed_t(\"constr\", t, []) }\n+          ty::ty_constr(t, _) { self.bracketed_t(\"constr\", t, []/~) }\n           ty::ty_opaque_closure_ptr(ck) {\n             let ckval = alt ck {\n               ty::ck_block { 0u }\n               ty::ck_box { 1u }\n               ty::ck_uniq { 2u }\n             };\n-            self.visit(\"closure_ptr\", [self.c_uint(ckval)])\n+            self.visit(\"closure_ptr\", [self.c_uint(ckval)]/~)\n           }\n-          ty::ty_unboxed_vec(mt) { self.bracketed_mt(\"vec\", mt, []) }\n+          ty::ty_unboxed_vec(mt) { self.bracketed_mt(\"vec\", mt, []/~) }\n         }\n     }\n }"}, {"sha": "9b8f99e4c364224ffface0db22f037c719b15526", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 75, "deletions": 72, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -22,11 +22,11 @@ import std::map::hashmap;\n import ty_ctxt = middle::ty::ctxt;\n \n type nominal_id = @{did: ast::def_id, parent_id: option<ast::def_id>,\n-                    tps: [ty::t]};\n+                    tps: [ty::t]/~};\n \n fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n                  parent_id: option<ast::def_id>,\n-                 tps: [ty::t]) -> nominal_id {\n+                 tps: [ty::t]/~) -> nominal_id {\n     let tps_norm = tps.map { |t| ty::normalize_ty(tcx, t) };\n     @{did: did, parent_id: parent_id, tps: tps_norm}\n }\n@@ -197,44 +197,46 @@ fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n          llshapetables: llshapetables};\n }\n \n-fn add_bool(&dest: [u8], val: bool) { dest += [if val { 1u8 } else { 0u8 }]; }\n+fn add_bool(&dest: [u8]/~, val: bool) {\n+    dest += [if val { 1u8 } else { 0u8 }]/~;\n+}\n \n-fn add_u16(&dest: [u8], val: u16) {\n-    dest += [(val & 0xffu16) as u8, (val >> 8u16) as u8];\n+fn add_u16(&dest: [u8]/~, val: u16) {\n+    dest += [(val & 0xffu16) as u8, (val >> 8u16) as u8]/~;\n }\n \n-fn add_substr(&dest: [u8], src: [u8]) {\n+fn add_substr(&dest: [u8]/~, src: [u8]/~) {\n     add_u16(dest, vec::len(src) as u16);\n     dest += src;\n }\n \n-fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n+fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8]/~ {\n     alt ty::get(t).struct {\n       ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n-      ty::ty_bot { [shape_u8] }\n-      ty::ty_int(ast::ty_i) { [s_int(ccx.tcx)] }\n-      ty::ty_float(ast::ty_f) { [s_float(ccx.tcx)] }\n-      ty::ty_uint(ast::ty_u) | ty::ty_ptr(_) { [s_uint(ccx.tcx)] }\n-      ty::ty_type { [s_tydesc(ccx.tcx)] }\n-      ty::ty_int(ast::ty_i8) { [shape_i8] }\n-      ty::ty_uint(ast::ty_u16) { [shape_u16] }\n-      ty::ty_int(ast::ty_i16) { [shape_i16] }\n-      ty::ty_uint(ast::ty_u32) { [shape_u32] }\n-      ty::ty_int(ast::ty_i32) | ty::ty_int(ast::ty_char) { [shape_i32] }\n-      ty::ty_uint(ast::ty_u64) { [shape_u64] }\n-      ty::ty_int(ast::ty_i64) { [shape_i64] }\n-      ty::ty_float(ast::ty_f32) { [shape_f32] }\n-      ty::ty_float(ast::ty_f64) { [shape_f64] }\n+      ty::ty_bot { [shape_u8]/~ }\n+      ty::ty_int(ast::ty_i) { [s_int(ccx.tcx)]/~ }\n+      ty::ty_float(ast::ty_f) { [s_float(ccx.tcx)]/~ }\n+      ty::ty_uint(ast::ty_u) | ty::ty_ptr(_) { [s_uint(ccx.tcx)]/~ }\n+      ty::ty_type { [s_tydesc(ccx.tcx)]/~ }\n+      ty::ty_int(ast::ty_i8) { [shape_i8]/~ }\n+      ty::ty_uint(ast::ty_u16) { [shape_u16]/~ }\n+      ty::ty_int(ast::ty_i16) { [shape_i16]/~ }\n+      ty::ty_uint(ast::ty_u32) { [shape_u32]/~ }\n+      ty::ty_int(ast::ty_i32) | ty::ty_int(ast::ty_char) { [shape_i32]/~ }\n+      ty::ty_uint(ast::ty_u64) { [shape_u64]/~ }\n+      ty::ty_int(ast::ty_i64) { [shape_i64]/~ }\n+      ty::ty_float(ast::ty_f32) { [shape_f32]/~ }\n+      ty::ty_float(ast::ty_f64) { [shape_f64]/~ }\n       ty::ty_estr(ty::vstore_uniq) |\n       ty::ty_str {\n         shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n       }\n       ty::ty_enum(did, substs) {\n         alt enum_kind(ccx, did) {\n-          tk_unit { [s_variant_enum_t(ccx.tcx)] }\n-          tk_enum { [s_variant_enum_t(ccx.tcx)] }\n+          tk_unit { [s_variant_enum_t(ccx.tcx)]/~ }\n+          tk_enum { [s_variant_enum_t(ccx.tcx)]/~ }\n           tk_newtype | tk_complex {\n-            let mut s = [shape_enum], id;\n+            let mut s = [shape_enum]/~, id;\n             let nom_id = mk_nominal_id(ccx.tcx, did, none, substs.tps);\n             alt ccx.shape_cx.tag_id_to_index.find(nom_id) {\n               none {\n@@ -257,14 +259,14 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n       }\n       ty::ty_estr(ty::vstore_box) |\n       ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_box(_) | ty::ty_opaque_box { [shape_box] }\n+      ty::ty_box(_) | ty::ty_opaque_box { [shape_box]/~ }\n       ty::ty_uniq(mt) {\n-        let mut s = [shape_uniq];\n+        let mut s = [shape_uniq]/~;\n         add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n       ty::ty_unboxed_vec(mt) {\n-        let mut s = [shape_unboxed_vec];\n+        let mut s = [shape_unboxed_vec]/~;\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n         add_substr(s, shape_of(ccx, mt.ty));\n         s\n@@ -275,7 +277,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) {\n-        let mut s = [shape_fixedvec];\n+        let mut s = [shape_fixedvec]/~;\n         let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n         assert (n + 1u) <= 0xffffu;\n         add_u16(s, (n + 1u) as u16);\n@@ -285,7 +287,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n       }\n \n       ty::ty_evec(mt, ty::vstore_fixed(n)) {\n-        let mut s = [shape_fixedvec];\n+        let mut s = [shape_fixedvec]/~;\n         assert n <= 0xffffu;\n         add_u16(s, n as u16);\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n@@ -294,7 +296,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n       }\n \n       ty::ty_estr(ty::vstore_slice(r)) {\n-        let mut s = [shape_slice];\n+        let mut s = [shape_slice]/~;\n         let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n         add_bool(s, true); // is_pod\n         add_bool(s, true); // is_str\n@@ -303,38 +305,38 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n       }\n \n       ty::ty_evec(mt, ty::vstore_slice(r)) {\n-        let mut s = [shape_slice];\n+        let mut s = [shape_slice]/~;\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n         add_bool(s, false); // is_str\n         add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n \n       ty::ty_rec(fields) {\n-        let mut s = [shape_struct], sub = [];\n+        let mut s = [shape_struct]/~, sub = []/~;\n         for vec::each(fields) {|f|\n             sub += shape_of(ccx, f.mt.ty);\n         }\n         add_substr(s, sub);\n         s\n       }\n       ty::ty_tup(elts) {\n-        let mut s = [shape_struct], sub = [];\n+        let mut s = [shape_struct]/~, sub = []/~;\n         for vec::each(elts) {|elt|\n             sub += shape_of(ccx, elt);\n         }\n         add_substr(s, sub);\n         s\n       }\n-      ty::ty_iface(_, _) { [shape_box_fn] }\n+      ty::ty_iface(_, _) { [shape_box_fn]/~ }\n       ty::ty_class(did, substs) {\n         // same as records, unless there's a dtor\n         let tps = substs.tps;\n         let m_dtor_did = ty::ty_dtor(ccx.tcx, did);\n         let mut s = if option::is_some(m_dtor_did) {\n-            [shape_res]\n+            [shape_res]/~\n           }\n-        else { [shape_struct] }, sub = [];\n+        else { [shape_struct]/~ }, sub = []/~;\n         option::iter(m_dtor_did) {|dtor_did|\n           let ri = @{did: dtor_did, parent_id: some(did), tps: tps};\n           let id = interner::intern(ccx.shape_cx.resources, ri);\n@@ -351,28 +353,28 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n         s\n       }\n       ty::ty_rptr(_, mt) {\n-        let mut s = [shape_rptr];\n+        let mut s = [shape_rptr]/~;\n         add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n       ty::ty_param(*) {\n         ccx.tcx.sess.bug(\"non-monomorphized type parameter\");\n       }\n-      ty::ty_fn({proto: ast::proto_box, _}) { [shape_box_fn] }\n-      ty::ty_fn({proto: ast::proto_uniq, _}) { [shape_uniq_fn] }\n+      ty::ty_fn({proto: ast::proto_box, _}) { [shape_box_fn]/~ }\n+      ty::ty_fn({proto: ast::proto_uniq, _}) { [shape_uniq_fn]/~ }\n       ty::ty_fn({proto: ast::proto_block, _}) |\n-      ty::ty_fn({proto: ast::proto_any, _}) { [shape_stack_fn] }\n-      ty::ty_fn({proto: ast::proto_bare, _}) { [shape_bare_fn] }\n-      ty::ty_opaque_closure_ptr(_) { [shape_opaque_closure_ptr] }\n+      ty::ty_fn({proto: ast::proto_any, _}) { [shape_stack_fn]/~ }\n+      ty::ty_fn({proto: ast::proto_bare, _}) { [shape_bare_fn]/~ }\n+      ty::ty_opaque_closure_ptr(_) { [shape_opaque_closure_ptr]/~ }\n       ty::ty_constr(inner_t, _) { shape_of(ccx, inner_t) }\n       ty::ty_var(_) | ty::ty_var_integral(_) | ty::ty_self {\n         ccx.sess.bug(\"shape_of: unexpected type struct found\");\n       }\n     }\n }\n \n-fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info) -> [u8] {\n-    let mut s = [];\n+fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info) -> [u8]/~ {\n+    let mut s = []/~;\n     for vec::each(v.args) {|t| s += shape_of(ccx, t); }\n     ret s;\n }\n@@ -381,32 +383,32 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // Loop over all the enum variants and write their shapes into a\n     // data buffer. As we do this, it's possible for us to discover\n     // new enums, so we must do this first.\n-    let mut data = [];\n-    let mut offsets = [];\n+    let mut data = []/~;\n+    let mut offsets = []/~;\n     let mut i = 0u;\n-    let mut enum_variants = [];\n+    let mut enum_variants = []/~;\n     while i < ccx.shape_cx.tag_order.len() {\n         let {did, substs} = ccx.shape_cx.tag_order[i];\n         let variants = @ty::substd_enum_variants(ccx.tcx, did, substs);\n         vec::iter(*variants) {|v|\n-            offsets += [vec::len(data) as u16];\n+            offsets += [vec::len(data) as u16]/~;\n \n             let variant_shape = shape_of_variant(ccx, v);\n             add_substr(data, variant_shape);\n \n-            let zname = str::bytes(*v.name) + [0u8];\n+            let zname = str::bytes(*v.name) + [0u8]/~;\n             add_substr(data, zname);\n         }\n-        enum_variants += [variants];\n+        enum_variants += [variants]/~;\n         i += 1u;\n     }\n \n     // Now calculate the sizes of the header space (which contains offsets to\n     // info records for each enum) and the info space (which contains offsets\n     // to each variant shape). As we do so, build up the header.\n \n-    let mut header = [];\n-    let mut inf = [];\n+    let mut header = []/~;\n+    let mut inf = []/~;\n     let header_sz = 2u16 * ccx.shape_cx.next_tag_id;\n     let data_sz = vec::len(data) as u16;\n \n@@ -421,7 +423,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // variant. Also construct the largest-variant table for each enum, which\n     // contains the variants that the size-of operation needs to look at.\n \n-    let mut lv_table = [];\n+    let mut lv_table = []/~;\n     let mut i = 0u;\n     for enum_variants.each { |variants|\n         add_u16(inf, vec::len(*variants) as u16);\n@@ -445,7 +447,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n         // Write in the static size and alignment of the enum.\n         add_u16(inf, size_align.size);\n-        inf += [size_align.align];\n+        inf += [size_align.align]/~;\n \n         // Now write in the offset of each variant.\n         for vec::each(*variants) {|_v|\n@@ -467,14 +469,14 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n /* tjc: Not annotating FIXMEs in this module because of #1498 */\n     fn largest_variants(ccx: @crate_ctxt,\n-                        variants: @[ty::variant_info]) -> [uint] {\n+                        variants: @[ty::variant_info]/~) -> [uint]/~ {\n         // Compute the minimum and maximum size and alignment for each\n         // variant.\n         //\n         // NB: We could do better here; e.g. we know that any\n         // variant that contains (T,T) must be as least as large as\n         // any variant that contains just T.\n-        let mut ranges = [];\n+        let mut ranges = []/~;\n         for vec::each(*variants) {|variant|\n             let mut bounded = true;\n             let mut min_size = 0u, min_align = 0u;\n@@ -493,12 +495,12 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n             ranges +=\n                 [{size: {min: min_size, bounded: bounded},\n-                  align: {min: min_align, bounded: bounded}}];\n+                  align: {min: min_align, bounded: bounded}}]/~;\n         }\n \n         // Initialize the candidate set to contain all variants.\n-        let mut candidates = [mut];\n-        for vec::each(*variants) {|_v| candidates += [mut true]; }\n+        let mut candidates = [mut]/~;\n+        for vec::each(*variants) {|_v| candidates += [mut true]/~; }\n \n         // Do a pairwise comparison among all variants still in the\n         // candidate set.  Throw out any variant that we know has size\n@@ -531,24 +533,25 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         }\n \n         // Return the resulting set.\n-        let mut result = [];\n+        let mut result = []/~;\n         let mut i = 0u;\n         while i < vec::len(candidates) {\n-            if candidates[i] { result += [i]; }\n+            if candidates[i] { vec::push(result, i); }\n             i += 1u;\n         }\n         ret result;\n     }\n \n-    fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n-                                variants: @[ty::variant_info]) -> size_align {\n+    fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint]/~,\n+                                variants: @[ty::variant_info]/~)\n+        -> size_align {\n         let mut max_size = 0u16;\n         let mut max_align = 1u8;\n         for vec::each(largest_variants) {|vid|\n             // We increment a \"virtual data pointer\" to compute the size.\n-            let mut lltys = [];\n+            let mut lltys = []/~;\n             for vec::each(variants[vid].args) {|typ|\n-                lltys += [type_of::type_of(ccx, typ)];\n+                lltys += [type_of::type_of(ccx, typ)]/~;\n             }\n \n             let llty = trans::common::T_struct(lltys);\n@@ -574,13 +577,13 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n }\n \n fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n-    let mut dtors = [];\n+    let mut dtors = []/~;\n     let len = interner::len(ccx.shape_cx.resources);\n     for uint::range(0u, len) {|i|\n         let ri = interner::get(ccx.shape_cx.resources, i);\n         for ri.tps.each() {|s| assert !ty::type_has_params(s); }\n         option::iter(ri.parent_id) {|id|\n-            dtors += [trans::base::get_res_dtor(ccx, ri.did, id, ri.tps)];\n+            dtors += [trans::base::get_res_dtor(ccx, ri.did, id, ri.tps)]/~;\n         }\n     }\n     ret mk_global(ccx, \"resource_shapes\", C_struct(dtors), true);\n@@ -591,11 +594,11 @@ fn gen_shape_tables(ccx: @crate_ctxt) {\n     let llresourcestable = gen_resource_shapes(ccx);\n     trans::common::set_struct_body(ccx.shape_cx.llshapetablesty,\n                                    [val_ty(lltagstable),\n-                                    val_ty(llresourcestable)]);\n+                                    val_ty(llresourcestable)]/~);\n \n     let lltables =\n         C_named_struct(ccx.shape_cx.llshapetablesty,\n-                       [lltagstable, llresourcestable]);\n+                       [lltagstable, llresourcestable]/~);\n     lib::llvm::llvm::LLVMSetInitializer(ccx.shape_cx.llshapetables, lltables);\n     lib::llvm::llvm::LLVMSetGlobalConstant(ccx.shape_cx.llshapetables, True);\n     lib::llvm::SetLinkage(ccx.shape_cx.llshapetables,\n@@ -724,10 +727,10 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           ty::ty_evec(_, ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_box) |\n           ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |\n           ty::ty_ptr(_) | ty::ty_rptr(_,_) { nilptr(tcx) }\n-          ty::ty_fn(_) { ty::mk_tup(tcx, [nilptr(tcx), nilptr(tcx)]) }\n+          ty::ty_fn(_) { ty::mk_tup(tcx, [nilptr(tcx), nilptr(tcx)]/~) }\n           ty::ty_evec(_, ty::vstore_slice(_)) |\n           ty::ty_estr(ty::vstore_slice(_)) {\n-            ty::mk_tup(tcx, [nilptr(tcx), ty::mk_int(tcx)])\n+            ty::mk_tup(tcx, [nilptr(tcx), ty::mk_int(tcx)]/~)\n           }\n           _ { typ }\n         }\n@@ -736,7 +739,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n }\n \n // Given a tag type `ty`, returns the offset of the payload.\n-//fn tag_payload_offs(bcx: block, tag_id: ast::def_id, tps: [ty::t])\n+//fn tag_payload_offs(bcx: block, tag_id: ast::def_id, tps: [ty::t]/~)\n //    -> ValueRef {\n //    alt tag_kind(tag_id) {\n //      tk_unit | tk_enum | tk_newtype { C_int(bcx.ccx(), 0) }"}, {"sha": "7bc0ca506083472826d979b880306d90ce42f234", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -36,30 +36,30 @@ fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n \n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n-    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n+    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]/~))\n }\n fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n-    Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]));\n+    Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]/~));\n }\n fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n-    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n+    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]/~))\n }\n \n fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n-    non_gc_box_cast(bcx, GEPi(bcx, vptr, [0u, abi::box_field_body]))\n+    non_gc_box_cast(bcx, GEPi(bcx, vptr, [0u, abi::box_field_body]/~))\n }\n \n fn get_dataptr(bcx: block, vptr: ValueRef)\n     -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n-    GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n+    GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u]/~)\n }\n \n fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n-    ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n+    ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]/~), old_ty);\n }\n \n fn alloc_raw(bcx: block, unit_ty: ty::t,\n@@ -71,8 +71,8 @@ fn alloc_raw(bcx: block, unit_ty: ty::t,\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n \n     let {box, body} = base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n-    Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n-    Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n+    Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]/~));\n+    Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]/~));\n     ret {bcx: bcx, val: box};\n }\n fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n@@ -119,7 +119,7 @@ fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n     } else { bcx }\n }\n \n-fn trans_evec(bcx: block, args: [@ast::expr],\n+fn trans_evec(bcx: block, args: [@ast::expr]/~,\n               vst: ast::vstore, id: ast::node_id, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::trans_evec\");\n     let ccx = bcx.ccx();\n@@ -158,9 +158,9 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n             let len = Mul(bcx, n, unit_sz);\n \n             let p = base::alloca(bcx, T_struct([T_ptr(llunitty),\n-                                                ccx.int_type]));\n-            Store(bcx, vp, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n-            Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n+                                                ccx.int_type]/~));\n+            Store(bcx, vp, GEPi(bcx, p, [0u, abi::slice_elt_base]/~));\n+            Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]/~));\n \n             {bcx: bcx, val: p, dataptr: vp}\n           }\n@@ -182,12 +182,12 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n \n \n     // Store the individual elements.\n-    let mut i = 0u, temp_cleanups = [val];\n+    let mut i = 0u, temp_cleanups = [val]/~;\n     #debug(\"trans_evec: v: %s, dataptr: %s\",\n            val_str(ccx.tn, val),\n            val_str(ccx.tn, dataptr));\n     for vec::each(args) {|e|\n-        let lleltptr = InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]);\n+        let lleltptr = InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]/~);\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         vec::push(temp_cleanups, lleltptr);\n@@ -242,14 +242,14 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n \n     alt vstore {\n       ty::vstore_fixed(n) {\n-        let base = GEPi(cx, v, [0u, 0u]);\n+        let base = GEPi(cx, v, [0u, 0u]/~);\n         let n = if ty::type_is_str(e_ty) { n + 1u } else { n };\n         let len = Mul(cx, C_uint(ccx, n), unit_sz);\n         (base, len)\n       }\n       ty::vstore_slice(_) {\n-        let base = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_base]));\n-        let len = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_len]));\n+        let base = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_base]/~));\n+        let len = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_len]/~));\n         (base, len)\n       }\n       ty::vstore_uniq | ty::vstore_box {\n@@ -268,7 +268,7 @@ fn trans_estr(bcx: block, s: @str, vstore: ast::vstore,\n     let c = alt vstore {\n       ast::vstore_fixed(_)\n       {\n-        // \"hello\"/_  =>  \"hello\"/5  =>  [i8 x 6] in llvm\n+        // \"hello\"/_  =>  \"hello\"/5  =>  [i8 x 6]/~ in llvm\n         #debug(\"trans_estr: fixed: %s\", *s);\n         C_postr(*s)\n       }\n@@ -282,15 +282,15 @@ fn trans_estr(bcx: block, s: @str, vstore: ast::vstore,\n       ast::vstore_uniq {\n         let cs = PointerCast(bcx, C_cstr(ccx, *s), T_ptr(T_i8()));\n         let len = C_uint(ccx, str::len(*s));\n-        let c = Call(bcx, ccx.upcalls.str_new_uniq, [cs, len]);\n+        let c = Call(bcx, ccx.upcalls.str_new_uniq, [cs, len]/~);\n         PointerCast(bcx, c,\n                     T_unique_ptr(T_unique(ccx, T_vec(ccx, T_i8()))))\n       }\n \n       ast::vstore_box {\n         let cs = PointerCast(bcx, C_cstr(ccx, *s), T_ptr(T_i8()));\n         let len = C_uint(ccx, str::len(*s));\n-        let c = Call(bcx, ccx.upcalls.str_new_shared, [cs, len]);\n+        let c = Call(bcx, ccx.upcalls.str_new_shared, [cs, len]/~);\n         PointerCast(bcx, c,\n                     T_box_ptr(T_box(ccx, T_vec(ccx, T_i8()))))\n       }\n@@ -317,7 +317,7 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     let opaque_lhs = PointerCast(bcx, lhsptr,\n                                  T_ptr(T_ptr(T_i8())));\n     Call(bcx, ccx.upcalls.vec_grow,\n-         [opaque_lhs, new_fill]);\n+         [opaque_lhs, new_fill]/~);\n     // Was overwritten if we resized\n     let lhs = Load(bcx, lhsptr);\n     let rhs = Select(bcx, self_append, lhs, rhs);\n@@ -333,14 +333,14 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n                            load_if_immediate(bcx, addr, unit_ty), unit_ty);\n-        Store(bcx, InBoundsGEP(bcx, write_ptr, [C_int(ccx, 1)]),\n+        Store(bcx, InBoundsGEP(bcx, write_ptr, [C_int(ccx, 1)]/~),\n               write_ptr_ptr);\n         bcx\n     })\n }\n \n fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n-                        vals: [@ast::expr]) -> block {\n+                        vals: [@ast::expr]/~) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::trans_append_literal\");\n     let mut bcx = bcx, ccx = bcx.ccx();\n     let elt_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n@@ -357,7 +357,7 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n         bcx = base::with_cond(bcx, do_grow) {|bcx|\n             let pt = PointerCast(bcx, vptrptr,\n                                  T_ptr(T_ptr(T_i8())));\n-            Call(bcx, ccx.upcalls.vec_grow, [pt, new_fill]);\n+            Call(bcx, ccx.upcalls.vec_grow, [pt, new_fill]/~);\n             bcx\n         };\n         let vptr = get_bodyptr(bcx, Load(bcx, vptrptr));\n@@ -380,7 +380,7 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n     if ty::get(vec_ty).struct == ty::ty_str {\n         let lhs = PointerCast(bcx, lhs, T_ptr(T_i8()));\n         let rhs = PointerCast(bcx, rhs, T_ptr(T_i8()));\n-        let n = Call(bcx, ccx.upcalls.str_concat, [lhs, rhs]);\n+        let n = Call(bcx, ccx.upcalls.str_concat, [lhs, rhs]/~);\n         let n = PointerCast(\n             bcx, n, T_unique_ptr(T_unique(ccx, T_vec(ccx, llunitty))));\n         ret base::store_in_dest(bcx, n, dest);\n@@ -401,7 +401,7 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n                            load_if_immediate(bcx, addr, unit_ty), unit_ty);\n-        Store(bcx, InBoundsGEP(bcx, write_ptr, [C_int(ccx, 1)]),\n+        Store(bcx, InBoundsGEP(bcx, write_ptr, [C_int(ccx, 1)]/~),\n               write_ptr_ptr);\n         ret bcx;\n     };\n@@ -430,15 +430,16 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n     // Now perform the iteration.\n     let header_cx = sub_block(bcx, \"iter_vec_loop_header\");\n     Br(bcx, header_cx.llbb);\n-    let data_ptr = Phi(header_cx, val_ty(data_ptr), [data_ptr], [bcx.llbb]);\n+    let data_ptr =\n+        Phi(header_cx, val_ty(data_ptr), [data_ptr]/~, [bcx.llbb]/~);\n     let not_yet_at_end =\n         ICmp(header_cx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n     let body_cx = sub_block(header_cx, \"iter_vec_loop_body\");\n     let next_cx = sub_block(header_cx, \"iter_vec_next\");\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n     let body_cx = f(body_cx, data_ptr, unit_ty);\n     AddIncomingToPhi(data_ptr, InBoundsGEP(body_cx, data_ptr,\n-                                           [C_int(bcx.ccx(), 1)]),\n+                                           [C_int(bcx.ccx(), 1)]/~),\n                      body_cx.llbb);\n     Br(body_cx, header_cx.llbb);\n     ret next_cx;"}, {"sha": "db459ddae006c4526eb07a3881feee2ae5fbd6a2", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -14,7 +14,8 @@ export type_of_fn_from_ty;\n export type_of_fn;\n export type_of_non_gc_box;\n \n-fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n+fn type_of_explicit_args(cx: @crate_ctxt,\n+                         inputs: [ty::arg]/~) -> [TypeRef]/~ {\n     vec::map(inputs) {|arg|\n         let arg_ty = arg.ty;\n         let llty = type_of(cx, arg_ty);\n@@ -25,14 +26,15 @@ fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n     }\n }\n \n-fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg], output: ty::t) -> TypeRef {\n-    let mut atys: [TypeRef] = [];\n+fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg]/~,\n+              output: ty::t) -> TypeRef {\n+    let mut atys: [TypeRef]/~ = []/~;\n \n     // Arg 0: Output pointer.\n-    atys += [T_ptr(type_of(cx, output))];\n+    atys += [T_ptr(type_of(cx, output))]/~;\n \n     // Arg 1: Environment\n-    atys += [T_opaque_box_ptr(cx)];\n+    atys += [T_opaque_box_ptr(cx)]/~;\n \n     // ... then explicit args.\n     atys += type_of_explicit_args(cx, inputs);\n@@ -115,12 +117,12 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n \n           ty::ty_evec(mt, ty::vstore_slice(_)) {\n             T_struct([T_ptr(type_of(cx, mt.ty)),\n-                      T_uint_ty(cx, ast::ty_u)])\n+                      T_uint_ty(cx, ast::ty_u)]/~)\n           }\n \n           ty::ty_estr(ty::vstore_slice(_)) {\n             T_struct([T_ptr(T_i8()),\n-                      T_uint_ty(cx, ast::ty_u)])\n+                      T_uint_ty(cx, ast::ty_u)]/~)\n           }\n \n           ty::ty_estr(ty::vstore_fixed(n)) {\n@@ -132,20 +134,20 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           }\n \n           ty::ty_rec(fields) {\n-            let mut tys: [TypeRef] = [];\n+            let mut tys: [TypeRef]/~ = []/~;\n             for vec::each(fields) {|f|\n                 let mt_ty = f.mt.ty;\n-                tys += [type_of(cx, mt_ty)];\n+                tys += [type_of(cx, mt_ty)]/~;\n             }\n             T_struct(tys)\n           }\n           ty::ty_fn(_) { T_fn_pair(cx, type_of_fn_from_ty(cx, t)) }\n           ty::ty_iface(_, _) { T_opaque_iface(cx) }\n           ty::ty_type { T_ptr(cx.tydesc_type) }\n           ty::ty_tup(elts) {\n-            let mut tys = [];\n+            let mut tys = []/~;\n             for vec::each(elts) {|elt|\n-                tys += [type_of(cx, elt)];\n+                tys += [type_of(cx, elt)]/~;\n             }\n             T_struct(tys)\n           }\n@@ -180,7 +182,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n \n             if ty::ty_dtor(cx.tcx, did) != none {\n               // resource type\n-              tys = [T_i8(), T_struct(tys)];\n+              tys = [T_i8(), T_struct(tys)]/~;\n             }\n \n             common::set_struct_body(llty, tys);\n@@ -213,13 +215,13 @@ fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n         let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n         let size = shape::static_size_of_enum(cx, t);\n         if !degen {\n-            [T_enum_discrim(cx), T_array(T_i8(), size)]\n+            [T_enum_discrim(cx), T_array(T_i8(), size)]/~\n         }\n         else if size == 0u {\n-            [T_enum_discrim(cx)]\n+            [T_enum_discrim(cx)]/~\n         }\n         else {\n-            [T_array(T_i8(), size)]\n+            [T_array(T_i8(), size)]/~\n         }\n     };\n \n@@ -250,7 +252,7 @@ fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> str {\n \n fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {\n     T_fn([T_ptr(type_of(ccx, ty::mk_nil(ccx.tcx))),\n-          T_ptr(type_of(ccx, self_ty))],\n+          T_ptr(type_of(ccx, self_ty))]/~,\n          llvm::LLVMVoidType())\n }\n "}, {"sha": "325647bfe445a11b17472850afa35921b72d366d", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -31,10 +31,10 @@ const use_repr: uint = 1u; // Dependency on size/alignment and take/drop glue\n const use_tydesc: uint = 2u; // Takes the tydesc, or compares\n \n type ctx = {ccx: @crate_ctxt,\n-            uses: [mut type_uses]};\n+            uses: [mut type_uses]/~};\n \n fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n-    -> [type_uses] {\n+    -> [type_uses]/~ {\n     alt ccx.type_use_cache.find(fn_id) {\n       some(uses) { ret uses; }\n       none {}"}, {"sha": "ec4fd7680baf79f7a7a04259a2e00160718b4967", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -56,9 +56,9 @@ fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let bcx = copy_val(bcx, INIT, dst_body, src_body, content_ty);\n \n     let src_tydesc_ptr = GEPi(bcx, src_box,\n-                              [0u, back::abi::box_field_tydesc]);\n+                              [0u, back::abi::box_field_tydesc]/~);\n     let dst_tydesc_ptr = GEPi(bcx, dst_box,\n-                              [0u, back::abi::box_field_tydesc]);\n+                              [0u, back::abi::box_field_tydesc]/~);\n \n     let td = Load(bcx, src_tydesc_ptr);\n     Store(bcx, td, dst_tydesc_ptr);"}, {"sha": "0427e48018111deb47cdf19529475907159d7f99", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -7,13 +7,13 @@ import aux::{num_constraints, get_fn_info, crate_ctxt, add_node};\n import ann::empty_ann;\n import pat_util::pat_binding_ids;\n \n-fn collect_ids_expr(e: @expr, rs: @mut [node_id]) { vec::push(*rs, e.id); }\n+fn collect_ids_expr(e: @expr, rs: @mut [node_id]/~) { vec::push(*rs, e.id); }\n \n-fn collect_ids_block(b: blk, rs: @mut [node_id]) {\n+fn collect_ids_block(b: blk, rs: @mut [node_id]/~) {\n     vec::push(*rs, b.node.id);\n }\n \n-fn collect_ids_stmt(s: @stmt, rs: @mut [node_id]) {\n+fn collect_ids_stmt(s: @stmt, rs: @mut [node_id]/~) {\n     alt s.node {\n       stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n         #debug[\"node_id %s\", int::str(id)];\n@@ -23,11 +23,11 @@ fn collect_ids_stmt(s: @stmt, rs: @mut [node_id]) {\n     }\n }\n \n-fn collect_ids_local(tcx: ty::ctxt, l: @local, rs: @mut [node_id]) {\n+fn collect_ids_local(tcx: ty::ctxt, l: @local, rs: @mut [node_id]/~) {\n     *rs += pat_binding_ids(tcx.def_map, l.node.pat);\n }\n \n-fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut [node_id]) {\n+fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut [node_id]/~) {\n     let collect_ids =\n         visit::mk_simple_visitor(@{visit_expr: {|a|collect_ids_expr(a, rs)},\n                                    visit_block: {|a|collect_ids_block(a, rs)},\n@@ -38,15 +38,15 @@ fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut [node_id]) {\n     collect_ids.visit_block(body, (), collect_ids);\n }\n \n-fn init_vecs(ccx: crate_ctxt, node_ids: [node_id], len: uint) {\n+fn init_vecs(ccx: crate_ctxt, node_ids: [node_id]/~, len: uint) {\n     for node_ids.each {|i|\n         log(debug, int::str(i) + \" |-> \" + uint::str(len));\n         add_node(ccx, i, empty_ann(len));\n     }\n }\n \n fn visit_fn(ccx: crate_ctxt, num_constraints: uint, body: blk) {\n-    let node_ids: @mut [node_id] = @mut [];\n+    let node_ids: @mut [node_id]/~ = @mut []/~;\n     node_ids_in_fn(ccx.tcx, body, node_ids);\n     let node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);"}, {"sha": "eee67f1a1f73501c23ef366bfa873866230a0841", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 70, "deletions": 67, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -34,7 +34,7 @@ fn def_id_to_str(d: def_id) -> str {\n     ret int::str(d.crate) + \",\" + int::str(d.node);\n }\n \n-fn comma_str(args: [@constr_arg_use]) -> str {\n+fn comma_str(args: [@constr_arg_use]/~) -> str {\n     let mut rslt = \"\";\n     let mut comma = false;\n     for args.each {|a|\n@@ -93,7 +93,7 @@ fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) {\n     log(error, tritv_to_str(fcx, v));\n }\n \n-fn tos(v: [uint]) -> str {\n+fn tos(v: [uint]/~) -> str {\n     let mut rslt = \"\";\n     for v.each {|i|\n         if i == 0u {\n@@ -103,9 +103,9 @@ fn tos(v: [uint]) -> str {\n     ret rslt;\n }\n \n-fn log_cond(v: [uint]) { log(debug, tos(v)); }\n+fn log_cond(v: [uint]/~) { log(debug, tos(v)); }\n \n-fn log_cond_err(v: [uint]) { log(error, tos(v)); }\n+fn log_cond_err(v: [uint]/~) { log(error, tos(v)); }\n \n fn log_pp(pp: pre_and_post) {\n     let p1 = tritv::to_vec(pp.precondition);\n@@ -145,7 +145,7 @@ fn log_states_err(pp: pre_and_post_state) {\n \n fn print_ident(i: ident) { log(debug, \" \" + *i + \" \"); }\n \n-fn print_idents(&idents: [ident]) {\n+fn print_idents(&idents: [ident]/~) {\n     if vec::len::<ident>(idents) == 0u { ret; }\n     log(debug, \"an ident: \" + *vec::pop::<ident>(idents));\n     print_idents(idents);\n@@ -180,7 +180,7 @@ to represent predicate *arguments* however. This type\n \n Both types store an ident and span, for error-logging purposes.\n */\n-type pred_args_ = {args: [@constr_arg_use], bit_num: uint};\n+type pred_args_ = {args: [@constr_arg_use]/~, bit_num: uint};\n \n type pred_args = spanned<pred_args_>;\n \n@@ -203,7 +203,7 @@ type constraint = {\n type tsconstr = {\n     path: @path,\n     def_id: def_id,\n-    args: [@constr_arg_use]\n+    args: [@constr_arg_use]/~\n };\n \n type sp_constr = spanned<tsconstr>;\n@@ -224,11 +224,11 @@ type fn_info =\n     {constrs: constr_map,\n      num_constraints: uint,\n      cf: ret_style,\n-     used_vars: @mut [node_id],\n+     used_vars: @mut [node_id]/~,\n      ignore: bool};\n \n /* mapping from node ID to typestate annotation */\n-type node_ann_table = @mut [mut ts_ann];\n+type node_ann_table = @mut [mut ts_ann]/~;\n \n \n /* mapping from function name to fn_info map */\n@@ -436,7 +436,7 @@ fn pure_exp(ccx: crate_ctxt, id: node_id, p: prestate) -> bool {\n fn num_constraints(m: fn_info) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n-    let na: [mut ts_ann] = [mut];\n+    let na: [mut ts_ann]/~ = [mut]/~;\n     ret {tcx: cx, node_anns: @mut na, fm: int_hash::<fn_info>()};\n }\n \n@@ -450,10 +450,10 @@ fn controlflow_expr(ccx: crate_ctxt, e: @expr) -> ret_style {\n     }\n }\n \n-fn constraints_expr(cx: ty::ctxt, e: @expr) -> [@ty::constr] {\n+fn constraints_expr(cx: ty::ctxt, e: @expr) -> [@ty::constr]/~ {\n     alt ty::get(ty::node_id_to_type(cx, e.id)).struct {\n       ty::ty_fn(f) { ret f.constraints; }\n-      _ { ret []; }\n+      _ { ret []/~; }\n     }\n }\n \n@@ -471,23 +471,23 @@ fn node_id_to_def(ccx: crate_ctxt, id: node_id) -> option<def> {\n     ret ccx.tcx.def_map.find(id);\n }\n \n-fn norm_a_constraint(id: def_id, c: constraint) -> [norm_constraint] {\n-    let mut rslt: [norm_constraint] = [];\n+fn norm_a_constraint(id: def_id, c: constraint) -> [norm_constraint]/~ {\n+    let mut rslt: [norm_constraint]/~ = []/~;\n     for (*c.descs).each {|pd|\n         rslt +=\n             [{bit_num: pd.node.bit_num,\n               c: respan(pd.span, {path: c.path,\n                                   def_id: id,\n-                                  args: pd.node.args})}];\n+                                  args: pd.node.args})}]/~;\n     }\n     ret rslt;\n }\n \n \n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n-fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n-    let mut rslt: [norm_constraint] = [];\n+fn constraints(fcx: fn_ctxt) -> [norm_constraint]/~ {\n+    let mut rslt: [norm_constraint]/~ = []/~;\n     for fcx.enclosing.constrs.each {|key, val|\n         rslt += norm_a_constraint(key, val);\n     };\n@@ -497,7 +497,7 @@ fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n // FIXME (#2539): Would rather take an immutable vec as an argument,\n // should freeze it at some earlier point.\n fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n-              occ: [@constr_arg_use]) -> uint {\n+              occ: [@constr_arg_use]/~) -> uint {\n     #debug(\"match_args: looking at %s\",\n            constr_args_to_str(fn@(i: inst) -> str { ret *i.ident; }, occ));\n     for (*occs).each {|pd|\n@@ -549,10 +549,11 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n     }\n }\n \n-fn exprs_to_constr_args(tcx: ty::ctxt, args: [@expr]) -> [@constr_arg_use] {\n+fn exprs_to_constr_args(tcx: ty::ctxt,\n+                        args: [@expr]/~) -> [@constr_arg_use]/~ {\n     let f = {|a|expr_to_constr_arg(tcx, a)};\n-    let mut rslt: [@constr_arg_use] = [];\n-    for args.each {|e| rslt += [f(e)]; }\n+    let mut rslt: [@constr_arg_use]/~ = []/~;\n+    for args.each {|e| rslt += [f(e)]/~; }\n     rslt\n }\n \n@@ -584,18 +585,18 @@ fn pred_args_to_str(p: pred_args) -> str {\n         + \">\"\n }\n \n-fn substitute_constr_args(cx: ty::ctxt, actuals: [@expr], c: @ty::constr) ->\n+fn substitute_constr_args(cx: ty::ctxt, actuals: [@expr]/~, c: @ty::constr) ->\n    tsconstr {\n-    let mut rslt: [@constr_arg_use] = [];\n+    let mut rslt: [@constr_arg_use]/~ = []/~;\n     for c.node.args.each {|a|\n-        rslt += [substitute_arg(cx, actuals, a)];\n+        rslt += [substitute_arg(cx, actuals, a)]/~;\n     }\n     ret {path: c.node.path,\n          def_id: c.node.id,\n          args: rslt};\n }\n \n-fn substitute_arg(cx: ty::ctxt, actuals: [@expr], a: @constr_arg) ->\n+fn substitute_arg(cx: ty::ctxt, actuals: [@expr]/~, a: @constr_arg) ->\n    @constr_arg_use {\n     let num_actuals = vec::len(actuals);\n     alt a.node {\n@@ -611,7 +612,7 @@ fn substitute_arg(cx: ty::ctxt, actuals: [@expr], a: @constr_arg) ->\n     }\n }\n \n-fn pred_args_matches(pattern: [constr_arg_general_<inst>],\n+fn pred_args_matches(pattern: [constr_arg_general_<inst>]/~,\n                      desc: pred_args) ->\n    bool {\n     let mut i = 0u;\n@@ -637,8 +638,8 @@ fn pred_args_matches(pattern: [constr_arg_general_<inst>],\n     ret true;\n }\n \n-fn find_instance_(pattern: [constr_arg_general_<inst>],\n-                  descs: [pred_args]) ->\n+fn find_instance_(pattern: [constr_arg_general_<inst>]/~,\n+                  descs: [pred_args]/~) ->\n    option<uint> {\n     for descs.each {|d|\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n@@ -653,21 +654,21 @@ enum dest {\n     call                        // RHS is passed to a function\n }\n \n-type subst = [{from: inst, to: inst}];\n+type subst = [{from: inst, to: inst}]/~;\n \n fn find_instances(_fcx: fn_ctxt, subst: subst,\n-                  c: constraint) -> [{from: uint, to: uint}] {\n+                  c: constraint) -> [{from: uint, to: uint}]/~ {\n \n-    if vec::len(subst) == 0u { ret []; }\n-    let mut res = [];\n+    if vec::len(subst) == 0u { ret []/~; }\n+    let mut res = []/~;\n     (*c.descs).swap { |v|\n         let v <- vec::from_mut(v);\n         for v.each { |d|\n             if args_mention(d.node.args, find_in_subst_bool, subst) {\n                 let old_bit_num = d.node.bit_num;\n                 let newv = replace(subst, d);\n                 alt find_instance_(newv, v) {\n-                  some(d1) {res += [{from: old_bit_num, to: d1}]}\n+                  some(d1) {res += [{from: old_bit_num, to: d1}]/~}\n                   _ {}\n                 }\n             } else {}\n@@ -688,33 +689,33 @@ fn find_in_subst_bool(s: subst, id: node_id) -> bool {\n     is_some(find_in_subst(id, s))\n }\n \n-fn insts_to_str(stuff: [constr_arg_general_<inst>]) -> str {\n+fn insts_to_str(stuff: [constr_arg_general_<inst>]/~) -> str {\n     let mut rslt = \"<\";\n     for stuff.each {|i|\n         rslt +=\n             \" \" +\n                 alt i {\n                   carg_ident(p) { *p.ident }\n                   carg_base { \"*\" }\n-                  carg_lit(_) { \"[lit]\" }\n+                  carg_lit(_) { \"[lit]/~\" }\n                 } + \" \";\n     }\n     rslt += \">\";\n     rslt\n }\n \n-fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n-    let mut rslt: [constr_arg_general_<inst>] = [];\n+fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>]/~ {\n+    let mut rslt: [constr_arg_general_<inst>]/~ = []/~;\n     for d.node.args.each {|c|\n         alt c.node {\n           carg_ident(p) {\n             alt find_in_subst(p.node, subst) {\n-              some(newv) { rslt += [carg_ident(newv)]; }\n-              _ { rslt += [c.node]; }\n+              some(newv) { rslt += [carg_ident(newv)]/~; }\n+              _ { rslt += [c.node]/~; }\n             }\n           }\n           _ {\n-            rslt += [c.node];\n+            rslt += [c.node]/~;\n           }\n         }\n     }\n@@ -796,11 +797,11 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n                          ty: oper_type) {\n     let mut subst;\n     alt ty {\n-      oper_swap { subst = [{from: dest, to: src}, {from: src, to: dest}]; }\n+      oper_swap { subst = [{from: dest, to: src}, {from: src, to: dest}]/~; }\n       oper_assign_op {\n         ret; // Don't do any propagation\n       }\n-      _ { subst = [{from: src, to: dest}]; }\n+      _ { subst = [{from: src, to: dest}]/~; }\n     }\n \n \n@@ -845,27 +846,27 @@ fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n     ret changed;\n }\n \n-fn any_eq(v: [node_id], d: node_id) -> bool {\n+fn any_eq(v: [node_id]/~, d: node_id) -> bool {\n     for v.each {|i| if i == d { ret true; } }\n     false\n }\n \n fn constraint_mentions(_fcx: fn_ctxt, c: norm_constraint, v: node_id) ->\n    bool {\n-    ret args_mention(c.c.node.args, any_eq, [v]);\n+    ret args_mention(c.c.node.args, any_eq, [v]/~);\n }\n \n-fn args_mention<T>(args: [@constr_arg_use],\n-                   q: fn([T], node_id) -> bool,\n-                   s: [T]) -> bool {\n+fn args_mention<T>(args: [@constr_arg_use]/~,\n+                   q: fn([T]/~, node_id) -> bool,\n+                   s: [T]/~) -> bool {\n \n     for args.each {|a|\n         alt a.node { carg_ident(p1) { if q(s, p1.node) { ret true; } } _ { } }\n     }\n     ret false;\n }\n \n-fn use_var(fcx: fn_ctxt, v: node_id) { *fcx.enclosing.used_vars += [v]; }\n+fn use_var(fcx: fn_ctxt, v: node_id) { *fcx.enclosing.used_vars += [v]/~; }\n \n fn op_to_oper_ty(io: init_op) -> oper_type {\n     alt io { init_move { oper_move } _ { oper_assign } }\n@@ -878,9 +879,10 @@ fn do_nothing<T>(_fk: visit::fn_kind, _decl: fn_decl, _body: blk,\n }\n \n \n-fn args_to_constr_args(tcx: ty::ctxt, args: [arg],\n-                       indices: [@sp_constr_arg<uint>]) -> [@constr_arg_use] {\n-    let mut actuals: [@constr_arg_use] = [];\n+fn args_to_constr_args(tcx: ty::ctxt, args: [arg]/~,\n+                       indices: [@sp_constr_arg<uint>]/~)\n+    -> [@constr_arg_use]/~ {\n+    let mut actuals: [@constr_arg_use]/~ = []/~;\n     let num_args = vec::len(args);\n     for indices.each {|a|\n         actuals +=\n@@ -898,48 +900,48 @@ fn args_to_constr_args(tcx: ty::ctxt, args: [arg],\n                          }\n                        }\n                        carg_lit(l) { carg_lit(l) }\n-                     })];\n+                     })]/~;\n     }\n     ret actuals;\n }\n \n-fn ast_constr_to_ts_constr(tcx: ty::ctxt, args: [arg], c: @constr) ->\n+fn ast_constr_to_ts_constr(tcx: ty::ctxt, args: [arg]/~, c: @constr) ->\n    tsconstr {\n     let tconstr = ty::ast_constr_to_constr(tcx, c);\n     ret {path: tconstr.node.path,\n          def_id: tconstr.node.id,\n          args: args_to_constr_args(tcx, args, tconstr.node.args)};\n }\n \n-fn ast_constr_to_sp_constr(tcx: ty::ctxt, args: [arg], c: @constr) ->\n+fn ast_constr_to_sp_constr(tcx: ty::ctxt, args: [arg]/~, c: @constr) ->\n    sp_constr {\n     let tconstr = ast_constr_to_ts_constr(tcx, args, c);\n     ret respan(c.span, tconstr);\n }\n \n-type binding = {lhs: [dest], rhs: option<initializer>};\n+type binding = {lhs: [dest]/~, rhs: option<initializer>};\n \n fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n-    let mut lhs = [];\n+    let mut lhs = []/~;\n     pat_bindings(tcx.def_map, loc.node.pat) {|p_id, _s, name|\n-      lhs += [local_dest({ident: path_to_ident(name), node: p_id})];\n+      lhs += [local_dest({ident: path_to_ident(name), node: p_id})]/~;\n     };\n     {lhs: lhs, rhs: loc.node.init}\n }\n \n-fn locals_to_bindings(tcx: ty::ctxt, locals: [@local]) -> [binding] {\n-    let mut rslt = [];\n-    for locals.each {|loc| rslt += [local_to_bindings(tcx, loc)]; }\n+fn locals_to_bindings(tcx: ty::ctxt, locals: [@local]/~) -> [binding]/~ {\n+    let mut rslt = []/~;\n+    for locals.each {|loc| rslt += [local_to_bindings(tcx, loc)]/~; }\n     ret rslt;\n }\n \n-fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [mode] {\n+fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [mode]/~ {\n     let ty = ty::type_autoderef(fcx.ccx.tcx,\n                                 ty::node_id_to_type(fcx.ccx.tcx, callee));\n     alt ty::get(ty).struct {\n       ty::ty_fn({inputs: args, _}) {\n-        let mut modes = [];\n-        for args.each {|arg| modes += [arg.mode]; }\n+        let mut modes = []/~;\n+        for args.each {|arg| modes += [arg.mode]/~; }\n         ret modes;\n       }\n       _ {\n@@ -950,7 +952,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [mode] {\n     }\n }\n \n-fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n+fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op]/~ {\n     vec::map(callee_modes(fcx, callee)) {|m|\n         alt ty::resolved_mode(fcx.ccx.tcx, m) {\n           by_move { init_move }\n@@ -959,11 +961,12 @@ fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n     }\n }\n \n-fn arg_bindings(ops: [init_op], es: [@expr]) -> [binding] {\n-    let mut bindings: [binding] = [];\n+fn arg_bindings(ops: [init_op]/~, es: [@expr]/~) -> [binding]/~ {\n+    let mut bindings: [binding]/~ = []/~;\n     let mut i = 0u;\n     for ops.each {|op|\n-        bindings += [{lhs: [call], rhs: some({op: op, expr: es[i]})}];\n+        vec::push(bindings,\n+                  {lhs: [call]/~, rhs: some({op: op, expr: es[i]})});\n         i += 1u;\n     }\n     ret bindings;"}, {"sha": "c1ca98d5f90bb542af8eb9b482c221c3330839db", "filename": "src/rustc/middle/tstate/bitvectors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -45,7 +45,7 @@ fn seq_tritv(p: postcond, q: postcond) {\n     }\n }\n \n-fn seq_postconds(fcx: fn_ctxt, ps: [postcond]) -> postcond {\n+fn seq_postconds(fcx: fn_ctxt, ps: [postcond]/~) -> postcond {\n     let sz = vec::len(ps);\n     if sz >= 1u {\n         let prev = tritv_clone(ps[0]);\n@@ -58,11 +58,11 @@ fn seq_postconds(fcx: fn_ctxt, ps: [postcond]) -> postcond {\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n-fn seq_preconds(fcx: fn_ctxt, pps: [pre_and_post]) -> precond {\n+fn seq_preconds(fcx: fn_ctxt, pps: [pre_and_post]/~) -> precond {\n     let sz: uint = vec::len(pps);\n     let num_vars: uint = num_constraints(fcx.enclosing);\n \n-    fn seq_preconds_go(fcx: fn_ctxt, pps: [pre_and_post],\n+    fn seq_preconds_go(fcx: fn_ctxt, pps: [pre_and_post]/~,\n                        idx: uint, first: pre_and_post)\n        -> precond {\n         let mut idx = idx;"}, {"sha": "bf22f4287bb477766408f53eb82b5ec7d070be25", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -10,12 +10,12 @@ import aux::*;\n import std::map::hashmap;\n import dvec::{dvec, extensions};\n \n-type ctxt = {cs: @mut [sp_constr], tcx: ty::ctxt};\n+type ctxt = {cs: @mut [sp_constr]/~, tcx: ty::ctxt};\n \n fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n     alt e.node {\n-      expr_check(_, ch) { *cx.cs += [expr_to_constr(cx.tcx, ch)]; }\n-      expr_if_check(ex, _, _) { *cx.cs += [expr_to_constr(cx.tcx, ex)]; }\n+      expr_check(_, ch) { *cx.cs += [expr_to_constr(cx.tcx, ch)]/~; }\n+      expr_if_check(ex, _, _) { *cx.cs += [expr_to_constr(cx.tcx, ex)]/~; }\n \n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n@@ -24,7 +24,7 @@ fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n             let ct: sp_constr =\n                 respan(c.span,\n                        aux::substitute_constr_args(cx.tcx, operands, c));\n-            *cx.cs += [ct];\n+            *cx.cs += [ct]/~;\n         }\n       }\n       _ { }\n@@ -39,7 +39,7 @@ fn find_locals(tcx: ty::ctxt,\n                f_body: blk,\n                sp: span,\n                id: node_id) -> ctxt {\n-    let cx: ctxt = {cs: @mut [], tcx: tcx};\n+    let cx: ctxt = {cs: @mut []/~, tcx: tcx};\n     let visitor = visit::default_visitor::<ctxt>();\n     let visitor =\n         @{visit_expr: collect_pred,\n@@ -130,7 +130,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n         }\n     }\n \n-    let v: @mut [node_id] = @mut [];\n+    let v: @mut [node_id]/~ = @mut []/~;\n     let rslt =\n         {constrs: res_map,\n          num_constraints: next,"}, {"sha": "cc157ff4356f4ac3cd712d673327e14961a73483", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -63,7 +63,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n    sets the precondition in a to be the result of combining\n    the preconditions for <args>, and the postcondition in a to\n    be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(fcx: fn_ctxt, args: [@expr], id: node_id) {\n+fn find_pre_post_exprs(fcx: fn_ctxt, args: [@expr]/~, id: node_id) {\n     if vec::len::<@expr>(args) > 0u {\n         #debug[\"find_pre_post_exprs: oper = %s\", expr_to_str(args[0])];\n     }\n@@ -84,7 +84,8 @@ fn find_pre_post_loop(fcx: fn_ctxt, index: @expr, body: blk, id: node_id) {\n     find_pre_post_block(fcx, body);\n \n     let loop_precond =\n-        seq_preconds(fcx, [expr_pp(fcx.ccx, index), block_pp(fcx.ccx, body)]);\n+        seq_preconds(fcx, [expr_pp(fcx.ccx, index),\n+                           block_pp(fcx.ccx, body)]/~);\n     let loop_postcond =\n         intersect_states(expr_postcond(fcx.ccx, index),\n                          block_postcond(fcx.ccx, body));\n@@ -111,7 +112,7 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n         let precond_res =\n             seq_preconds(fcx,\n                          [expr_pp(fcx.ccx, antec),\n-                          block_pp(fcx.ccx, conseq)]);\n+                          block_pp(fcx.ccx, conseq)]/~);\n         set_pre_and_post(fcx.ccx, id, precond_res,\n                          expr_poststate(fcx.ccx, antec));\n       }\n@@ -124,11 +125,12 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n         find_pre_post_expr(fcx, altern);\n         let precond_false_case =\n             seq_preconds(fcx,\n-                         [expr_pp(fcx.ccx, antec), expr_pp(fcx.ccx, altern)]);\n+                         [expr_pp(fcx.ccx, antec),\n+                          expr_pp(fcx.ccx, altern)]/~);\n         let postcond_false_case =\n             seq_postconds(fcx,\n                           [expr_postcond(fcx.ccx, antec),\n-                           expr_postcond(fcx.ccx, altern)]);\n+                           expr_postcond(fcx.ccx, altern)]/~);\n \n         /* Be sure to set the bit for the check condition here,\n          so that it's *not* set in the alternative. */\n@@ -142,14 +144,14 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n         let precond_true_case =\n             seq_preconds(fcx,\n                          [expr_pp(fcx.ccx, antec),\n-                          block_pp(fcx.ccx, conseq)]);\n+                          block_pp(fcx.ccx, conseq)]/~);\n         let postcond_true_case =\n             seq_postconds(fcx,\n                           [expr_postcond(fcx.ccx, antec),\n-                           block_postcond(fcx.ccx, conseq)]);\n+                           block_postcond(fcx.ccx, conseq)]/~);\n \n         let precond_res =\n-            seq_postconds(fcx, [precond_true_case, precond_false_case]);\n+            seq_postconds(fcx, [precond_true_case, precond_false_case]/~);\n         let postcond_res =\n             intersect_states(postcond_true_case, postcond_false_case);\n         set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n@@ -168,10 +170,10 @@ fn gen_if_local(fcx: fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n             set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n                              p.postcondition);\n           }\n-          _ { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n+          _ { find_pre_post_exprs(fcx, [lhs, rhs]/~, larger_id); }\n         }\n       }\n-      _ { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n+      _ { find_pre_post_exprs(fcx, [lhs, rhs]/~, larger_id); }\n     }\n }\n \n@@ -226,8 +228,8 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n     }\n }\n \n-fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [mode],\n-                        operands: [@expr]) {\n+fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [mode]/~,\n+                        operands: [@expr]/~) {\n     vec::iteri(modes) {|i,mode|\n         alt ty::resolved_mode(fcx.ccx.tcx, mode) {\n           by_move { forget_in_postcond(fcx, parent.id, operands[i].id); }\n@@ -253,7 +255,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         /* copy */\n \n         let mut args = operands;\n-        args += [operator];\n+        args += [operator]/~;\n \n         find_pre_post_exprs(fcx, args, e.id);\n         /* see if the call has any constraints on its type */\n@@ -285,10 +287,10 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         clear_pp(rslt);\n       }\n       expr_new(p, _, v) {\n-        find_pre_post_exprs(fcx, [p, v], e.id);\n+        find_pre_post_exprs(fcx, [p, v]/~, e.id);\n       }\n       expr_log(_, lvl, arg) {\n-        find_pre_post_exprs(fcx, [lvl, arg], e.id);\n+        find_pre_post_exprs(fcx, [lvl, arg]/~, e.id);\n       }\n       expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n         find_pre_post_expr_fn_upvars(fcx, e);\n@@ -312,7 +314,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       }\n       expr_rec(fields, maybe_base) {\n         let mut es = field_exprs(fields);\n-        alt maybe_base { none {/* no-op */ } some(b) { es += [b]; } }\n+        alt maybe_base { none {/* no-op */ } some(b) { es += [b]/~; } }\n         find_pre_post_exprs(fcx, es, e.id);\n       }\n       expr_tup(elts) { find_pre_post_exprs(fcx, elts, e.id); }\n@@ -323,7 +325,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         /* Different from expr_assign in that the lhs *must*\n            already be initialized */\n \n-        find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n+        find_pre_post_exprs(fcx, [lhs, rhs]/~, e.id);\n         forget_in_postcond(fcx, e.id, lhs.id);\n       }\n       expr_lit(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n@@ -349,11 +351,12 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n             find_pre_post_expr(fcx, l);\n             find_pre_post_expr(fcx, r);\n             let overall_pre =\n-                seq_preconds(fcx, [expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n+                seq_preconds(fcx,\n+                             [expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]/~);\n             set_precondition(node_id_to_ts_ann(fcx.ccx, e.id), overall_pre);\n             set_postcondition(node_id_to_ts_ann(fcx.ccx, e.id),\n                               expr_postcond(fcx.ccx, l));\n-        } else { find_pre_post_exprs(fcx, [l, r], e.id); }\n+        } else { find_pre_post_exprs(fcx, [l, r]/~, e.id); }\n       }\n       expr_addr_of(_, x) | expr_cast(x, _) | expr_unary(_, x) |\n       expr_loop_body(x) | expr_do_body(x) | expr_assert(x) | expr_copy(x) {\n@@ -366,7 +369,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         set_pre_and_post(fcx.ccx, e.id,\n                          seq_preconds(fcx,\n                                       [expr_pp(fcx.ccx, test),\n-                                       block_pp(fcx.ccx, body)]),\n+                                       block_pp(fcx.ccx, body)]/~),\n                          intersect_states(expr_postcond(fcx.ccx, test),\n                                           block_postcond(fcx.ccx, body)));\n       }\n@@ -383,7 +386,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         set_pre_and_post(fcx.ccx, e.id, block_precond(fcx.ccx, body),\n                          loop_postcond);\n       }\n-      expr_index(val, sub) { find_pre_post_exprs(fcx, [val, sub], e.id); }\n+      expr_index(val, sub) { find_pre_post_exprs(fcx, [val, sub]/~, e.id); }\n       expr_alt(ex, alts, _) {\n         find_pre_post_expr(fcx, ex);\n         fn do_an_alt(fcx: fn_ctxt, an_alt: arm) -> pre_and_post {\n@@ -394,11 +397,11 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n             find_pre_post_block(fcx, an_alt.body);\n             ret block_pp(fcx.ccx, an_alt.body);\n         }\n-        let mut alt_pps = [];\n-        for alts.each {|a| alt_pps += [do_an_alt(fcx, a)]; }\n+        let mut alt_pps = []/~;\n+        for alts.each {|a| alt_pps += [do_an_alt(fcx, a)]/~; }\n         fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, &&pp: pre_and_post,\n                       &&next: pre_and_post) -> pre_and_post {\n-            union(pp.precondition, seq_preconds(fcx, [antec, next]));\n+            union(pp.precondition, seq_preconds(fcx, [antec, next]/~));\n             intersect(pp.postcondition, next.postcondition);\n             ret pp;\n         }\n@@ -494,7 +497,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     guaranteed */\n                     let e_pp = expr_pp(fcx.ccx, an_init.expr);\n                     tritv_copy(prev_pp.precondition,\n-                               seq_preconds(fcx, [prev_pp, e_pp]));\n+                               seq_preconds(fcx, [prev_pp, e_pp]/~));\n \n                     /* Include the LHSs too, since those aren't in the\n                      postconds of the RHSs themselves */\n@@ -551,21 +554,21 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     let do_inner = {|a|do_inner_(fcx, a)};\n     option::map::<@expr, ()>(b.node.expr, do_inner);\n \n-    let mut pps: [pre_and_post] = [];\n-    for b.node.stmts.each {|s| pps += [stmt_pp(fcx.ccx, *s)]; }\n+    let mut pps: [pre_and_post]/~ = []/~;\n+    for b.node.stmts.each {|s| pps += [stmt_pp(fcx.ccx, *s)]/~; }\n     alt b.node.expr {\n       none {/* no-op */ }\n-      some(e) { pps += [expr_pp(fcx.ccx, e)]; }\n+      some(e) { pps += [expr_pp(fcx.ccx, e)]/~; }\n     }\n \n     let block_precond = seq_preconds(fcx, pps);\n \n-    let mut postconds = [];\n-    for pps.each {|pp| postconds += [get_post(pp)]; }\n+    let mut postconds = []/~;\n+    for pps.each {|pp| postconds += [get_post(pp)]/~; }\n \n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n-    postconds += [block_precond];\n+    postconds += [block_precond]/~;\n \n     let mut block_postcond = empty_poststate(nv);\n     /* conservative approximation */"}, {"sha": "64748a43b99475a05082dea03e30f15810b3219d", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -54,7 +54,7 @@ fn handle_move_or_copy(fcx: fn_ctxt, post: poststate, rhs_path: @path,\n     }\n }\n \n-fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n+fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]/~) ->\n    {changed: bool, post: poststate} {\n     let mut changed = false;\n     let mut post = tritv_clone(pres);\n@@ -166,7 +166,7 @@ fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n }\n \n fn find_pre_post_state_call(fcx: fn_ctxt, pres: prestate, a: @expr,\n-                            id: node_id, ops: [init_op], bs: [@expr],\n+                            id: node_id, ops: [init_op]/~, bs: [@expr]/~,\n                             cf: ret_style) -> bool {\n     let mut changed = find_pre_post_state_expr(fcx, pres, a);\n     // FIXME (#2178): This could be a typestate constraint (except we're\n@@ -183,8 +183,8 @@ fn find_pre_post_state_call(fcx: fn_ctxt, pres: prestate, a: @expr,\n }\n \n fn find_pre_post_state_exprs(fcx: fn_ctxt, pres: prestate, id: node_id,\n-                             ops: [init_op], es: [@expr], cf: ret_style) ->\n-   bool {\n+                             ops: [init_op]/~, es: [@expr]/~,\n+                             cf: ret_style) -> bool {\n     let rs = seq_states(fcx, pres, arg_bindings(ops, es));\n     let mut changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n@@ -404,7 +404,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n \n         /* conservative approximation: if a loop contains a break\n            or cont, we assume nothing about the poststate */\n-        /* which is still unsound -- see [Break-unsound] */\n+        /* which is still unsound -- see [Break-unsound]/~ */\n         if has_nonlocal_exits(body) {\n             ret changed | set_poststate_ann(fcx.ccx, e.id, pres);\n         } else {\n@@ -423,7 +423,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         /* conservative approximation: if a loop contains a break\n            or cont, we assume nothing about the poststate (so, we\n            set all predicates to \"don't know\" */\n-        /* which is still unsound -- see [Break-unsound] */\n+        /* which is still unsound -- see [Break-unsound]/~ */\n         if may_break(body) {\n                 /* Only do this if there are *breaks* not conts.\n                  An infinite loop with conts is still an infinite loop."}, {"sha": "b66cfe00b3f9cf4f30e5ff0d73ec79a34f8f95e2", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7", "patch": "@@ -249,16 +249,16 @@ fn tritv_doesntcare(v: t) -> bool {\n     ret true;\n }\n \n-fn to_vec(v: t) -> [uint] {\n+fn to_vec(v: t) -> [uint]/~ {\n     let mut i: uint = 0u;\n-    let mut rslt: [uint] = [];\n+    let mut rslt: [uint]/~ = []/~;\n     while i < v.nbits {\n         rslt +=\n             [alt tritv_get(v, i) {\n                dont_care { 2u }\n                ttrue { 1u }\n                tfalse { 0u }\n-             }];\n+             }]/~;\n         i += 1u;\n     }\n     ret rslt;"}, {"sha": "d766f8b29605bc1554629b6d55cac41760802dc8", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "95f4e6c0c953ece60915fc6a79d6033500151a96", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "101f3f6e44fe304a85e1a2003029f9d87772bf6c", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "3ddbc505a28f03ce2a31339e0c670294f7cbfc3b", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "9aa4d37fd7762113a89223f258e79ed62474b6eb", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b54be2fadf13f7275159d0cee29d94526989ab0a", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "7eebe1a31cad9e91dfc493d2c9f7f7a3f1e13202", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e86773bf76ada97888c8b7771e63122a3fd39c93", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b0059fab251e30159dc3e0f7e3ed390d7a3c81ba", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "fdf455e398aefb22fc00f45ead6c2fcf24f0fc1b", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "4652ddc2747bd91dfab33c50a6f9dc6383206833", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "74c57007880d4818610c188ed893de8f3743461f", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "5d2098a2e5f39f2b13b52e55ffb6c3f53b8440a6", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "44c2b8da3e662f8f8b2e145097cb065f2ccb69f2", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "a88f3d7b07f1528f814c28fee6d7714566f3e1b5", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "7a5c3cf67caf9cae0f784b1b814835eb3c61a2b2", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b40995a0c822f81a8b4ab35998121a2974e29fb6", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "83fda9f7b5cdd8b6e128a60afd55a070f4e1146f", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "3665e9cc331c67ffd26763e68ae121bfc6bc6dd3", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "29ac568e2e27a8e2d29a126174b4ab9dd3cd829e", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "ef8acd39df62862b96939a6f143ef0248a9298f1", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "18b06092f05caf7e749a19276901f35c00fe578d", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b1f7ef3a97053703718e46a9305662074b058e5c", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "dd00276b4b0331d0c6053063042afc44bcb6c801", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "c07c3d50c7cdad3a4b8f30fa6a4a0f661030e15f", "filename": "src/rustdoc/par.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpar.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "433cc825a3125c58a78408ae7261312f55aef6bf", "filename": "src/rustdoc/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fparse.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "f0411d0b70224359cc964567c66347b88b130829", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e2c09a33a7e7d94b494247ad478f47d99a2c6190", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b564af58794524e84bca37eb885ed469b43ae11d", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "f9d1c50283030e6cd3a60e9b886edef8c4914037", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "07749fcb41c6f7130964a125614caaf98e582eaa", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "9a92d527115d11441b5be286c4d42b6b9e3d77b7", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "fb34cb8ae844492b462bc06e46a70dd4230f814e", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e3c79de22bb9a5f46c5bfdabec7eb4d95cc5922e", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "abb42578d29da917b9b3f5b7b38b6fcf67e2e838", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "c7063f4ca0593126c2b229b2ee82db45b5cf7558", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "8460b67075320e9dd5d9683c63b12dedf3068991", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "af575dc00f6b8bb7561f0cc005496bed725d00d6", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "468ebeb198c77a158c43f32de78e0a0bf0697f26", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "dfe0f582435133747087c8f42e276d06e7eeed3b", "filename": "src/test/auxiliary/issue2378a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378a.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e26be8c69733481a49efcd6ffa05af47b66cdae3", "filename": "src/test/auxiliary/issue2378b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fissue2378b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fauxiliary%2Fissue2378b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378b.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "a711ae5dd46dec0d86c79109bf04f522d16b9b42", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e46cf25fade2612c310204763520f19195744443", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "edad5e0dbbaebb43f2eb6bc849720ea122c3d650", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b8e74520b8f44937f2da0578d301031fe71940ac", "filename": "src/test/bench/msgsend-ring-new.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "5b59005e5721b763f98e1312007b775d7de68d64", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "cea712635a0301f8b2bb1f60362080e702188549", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "8f1f95b2581f4d5f2e984e58065a49eb1bc4b040", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b2769a36e899e183eb648944c79f8470cd465250", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "7a518e8c39450ca71991639ebdde14af6e975e46", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "0670f928adb596257465d564362180d466ba7aab", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "2f076343cfd9822e352998c8dbdc602935e5ba8b", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b6811db4b626581ee1506526cff843a8b071fef1", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "8b91f8310e7196a88ae56bfb03ea202bc7dd8f77", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "518d1c39d851b76c0215915fa08d504b138a2706", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b81d27df5b5611986be3e6346c96c9e8741a6cb3", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "37e3380554bdbc2d84c03f1993d64d463287216b", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "9d8c5cc165b569e7a1794009dc927e792c62a4ac", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "b043264ff93f7108a295f3642b4283854d5dfd75", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "5b3b104a3429c27eaf56d24382e4bb5c72ca33b4", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "f10e198e29fb6cc66826402f6c3578498b9b9dcb", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "14896a3e73e2665cc5142a995b4633f10278b0b8", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "686a2175061d0e708869e54ffb79f9601c3979e6", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e4528333373cc13ed3bce9b6d5d60e9afdd7d969", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "a1493badbf393d9975837fcc86863febe9c31412", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "038ade94bd4e1f5e2e57ba1b3bfaec0552f658af", "filename": "src/test/compile-fail/ambig_impl_unify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "70532cef3ae3c73352e46a0de5efce18dcc0e8d7", "filename": "src/test/compile-fail/assign-super.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fassign-super.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fassign-super.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-super.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "f1f04c8ae98c950a3b8454e5df9be4f9fed2765c", "filename": "src/test/compile-fail/attr-bad-meta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "34690d29a3c859a11820303f8d7ab2f2e515af51", "filename": "src/test/compile-fail/bad-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "14bcfdf8352a6850db78109d955b693577df980a", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "775f1137e1b5689c2ada3892f5a093cbd1780a9c", "filename": "src/test/compile-fail/bad-main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-main.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "d96ea37cc78f0478c5ed5127329699c4ef9924c5", "filename": "src/test/compile-fail/bad-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-module.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "76519ff6dad80e8a9fe1734cdd3c7c60036c133f", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e069a356aaeafa55290f683489770e508f50141c", "filename": "src/test/compile-fail/block-must-not-have-result-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e2a7610ddc63ac34a14501570de1686dfb8773c2", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "0da9a8a860fcca8f91fe3128069d4434acd1e420", "filename": "src/test/compile-fail/borrowck-binding-mutbl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fborrowck-binding-mutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fborrowck-binding-mutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-binding-mutbl.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "2e54f948de2db8ab8c854023864714ad386bac98", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "8735e8e48bacf5dd4682fcf571e0e9cdd36db2e6", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "2d01da0f485bd3899c8fade30919e92c2bd0961b", "filename": "src/test/compile-fail/empty-vec-trailing-comma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fempty-vec-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fempty-vec-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-vec-trailing-comma.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "2bf07c0bf910e5157ee94ac914d104d8d2da8943", "filename": "src/test/compile-fail/fail-type-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "992f4e66eb8ef7b805dd71bfa5b5b83bf1e5a2fd", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "ea0c2dcd9b077d8984e493e04d117969a6be059e", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "9bb941c6daf3cee7f40ebffe980107d88ae95c12", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "ab9a9e2e54476cfb9519bd83dbd4fea356c7e472", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "35d01d0b624f50a365cdfb7df78435b38a3aebc8", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "32785c2316723708d6680e861377319c1fb56e41", "filename": "src/test/compile-fail/issue-1655.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fissue-1655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fissue-1655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1655.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "6363ca5fb6c15498f23a0a9a3d032b0c7146f9b2", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "a4877dad5b9f4a2af543a53a615829bb4081268d", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "2113a1ec127ebe7d28049a02e0adfd7ab5cf4443", "filename": "src/test/compile-fail/issue-2509-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e5a7cd0365d09208ea999dcd202fe7826713afb1", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "fd7ad945a572792fe85a9b68599d0b8e02d602cb", "filename": "src/test/compile-fail/liveness-use-in-index-lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fliveness-use-in-index-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fliveness-use-in-index-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-in-index-lvalue.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "1b10639445afe88c3c48bfcf7ff68bbe9f662d3c", "filename": "src/test/compile-fail/lub-in-args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "7fbb8bca0f79d7a8538e81891c1b83a23defd393", "filename": "src/test/compile-fail/mutable-huh-variance-box.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-box.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "1d7de6b078f7126fcafc2ba04cc50873372f22f8", "filename": "src/test/compile-fail/mutable-huh-variance-deep.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "2b807f6cc240f4816569d08f5f0ba20a09a7601a", "filename": "src/test/compile-fail/mutable-huh-variance-ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "326dcd2c1aef0d58ee8e9197e6c7ffe09f02d3e5", "filename": "src/test/compile-fail/mutable-huh-variance-rec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-rec.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "2cc0bcb614505db2fd41eba63f6c8d4a10c1f877", "filename": "src/test/compile-fail/mutable-huh-variance-unique.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "ba25fbbb9d7b67c5788f3ffad77f16c190be2a1b", "filename": "src/test/compile-fail/mutable-huh-variance-vec1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "cab07b804e6bf77db45cb2872bb499eb9245199e", "filename": "src/test/compile-fail/mutable-huh-variance-vec2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "afba07126cf13c9806cc068f2b405fe8606e108d", "filename": "src/test/compile-fail/mutable-huh-variance-vec3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "a7394928076be994be84b3f22197fc1c60bc0816", "filename": "src/test/compile-fail/mutable-huh-variance-vec4.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec4.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "3a94c6d9b17d9634fd5f3f804f8c4e2ccb657e95", "filename": "src/test/compile-fail/mutable-huh-vec-assign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-vec-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-vec-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-vec-assign.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "12e2205c3b25bc8647a126e75f50da13a7307c37", "filename": "src/test/compile-fail/nested-ty-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "ec489529739ce86ec40f64a39d0d50b7d3c7bb4a", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "2369edd43dc68435ccffde2a12d7be6ab0858dbd", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "ab542f3bc1ebeb89cb3ce598698982535d3cf85f", "filename": "src/test/compile-fail/non-const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fnon-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fnon-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-const.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "07b93989ba7dbd71f3fa9670d078349c6f0a17a6", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e05581aa10ba94a833d2dfb0a952ecfce68f8974", "filename": "src/test/compile-fail/nonsense-constraints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "162240ed8aa04cfa50d58d44eeb401b5c5755bee", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "60c555413aeb80fac78f635abdfa92d0ab9961f8", "filename": "src/test/compile-fail/pattern-tyvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "c88bf563e7144408e205c3ab5db7275fff69faf2", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "af5cf1c3fab58094a2ac0971a236c51814451ee3", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "309cb0302330e03722290fa51a261381560d380d", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "0587e21e5aa120035474258aeb50e5db38295cdf", "filename": "src/test/compile-fail/seq-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fseq-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fseq-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fseq-args.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "a7b0bb7175df3ddcbdd0ab57ee901992271b639f", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "24cfa527e95370c6d9e37536b51716385876d282", "filename": "src/test/compile-fail/tstate-unsat-in-called-fn-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-called-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-called-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-called-fn-expr.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "753655d354c540fe6b5c48aee2980e71d677c718", "filename": "src/test/compile-fail/tstate-unsat-in-fn-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-fn-expr.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "5159d0ddbfe6212119db2339402aec2c01b7f436", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "583ffb9c197345621f89b95ff0607360ebeb9bb1", "filename": "src/test/compile-fail/vec-add.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-add.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "40e6e2b0358136c9b43e0782abeb9c366e54290d", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "936b14b6c7dac1590b6727ed46293439f0833a5e", "filename": "src/test/compile-fail/vec-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-field.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "4ce5ad3cbf0634080a1b5fbc6aca54983a19218a", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "c68995a68544aba4f6550763c3dc8aea543b5b4c", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "837b85280ecfcd9d061bbc2ea443e4554d3cec4d", "filename": "src/test/pretty/blank-lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fblank-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fblank-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblank-lines.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "a6e0cc7f610872601359ca225b9f6b2704b0bf32", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "5492484d0c82e0d4e21fe3d7927fe4c5d350ccbd", "filename": "src/test/pretty/vec-comments.pp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fvec-comments.pp", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fvec-comments.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-comments.pp?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "5492484d0c82e0d4e21fe3d7927fe4c5d350ccbd", "filename": "src/test/pretty/vec-comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fvec-comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fvec-comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-comments.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "af111a64c3f4d491a82192124f023d2825b053cf", "filename": "src/test/pretty/vec-type.pp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fvec-type.pp", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fvec-type.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-type.pp?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "af111a64c3f4d491a82192124f023d2825b053cf", "filename": "src/test/pretty/vec-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fvec-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Fpretty%2Fvec-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-type.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "dcea4e893f6477eecdd298b2fc78c8f52a6a9e5d", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "a547bc1a3f3c9b8954a111125933825c62210f4d", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "710cecd99e2f845d6e1da9bddd282dc45991e03d", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "616a9e75cefd9716c25231459b28b65138244e52", "filename": "src/test/run-fail/unwind-box-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-box-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-box-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-vec.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "d914ff82219bacd7b938f098215bdec3684bd5df", "filename": "src/test/run-fail/unwind-interleaved.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-interleaved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-interleaved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-interleaved.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "442efe3be258b7de309b4a08d7222be2a3dd8229", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "7ff5c6ec7f33a6f8cc06afe651313e8d5fed6d5a", "filename": "src/test/run-fail/unwind-partial-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-partial-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-partial-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-partial-box.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "5f998e802dcb75879d0cdbc8b6f93432576c8885", "filename": "src/test/run-fail/unwind-partial-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-partial-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-partial-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-partial-unique.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "feb7449c532e77501041f8900e892608b6b13cc2", "filename": "src/test/run-fail/unwind-partial-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-partial-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-partial-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-partial-vec.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "58fb32cf3e5281c37fe18ee5948b413e4f5e7477", "filename": "src/test/run-fail/unwind-rec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-rec.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "10e9cd70323aa0e22148c1008dce3688257d1e0a", "filename": "src/test/run-fail/unwind-rec2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-rec2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-rec2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-rec2.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "219e4d2a31193cc008ef1b7a79d2b008150902f7", "filename": "src/test/run-fail/unwind-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-tup.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "cba38527da9d55980c70a47ea54fb5d660b083e7", "filename": "src/test/run-fail/unwind-tup2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-tup2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Funwind-tup2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-tup2.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "f0d21ec7a73f575ebcc107d0c5d3eaf3cc37b948", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "faeeed4460377ae7696489bda1f467f59b3b2d18", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "f41c03e7e76ebd2cfa174bcc7411f82619dadfd9", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "856e916ac0c11715924236beba094615b5bea158", "filename": "src/test/run-pass-fulldeps/issue-1926.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "d6da96d0393d69aec7536f4b611c3bc38b33ed01", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "df4fac9945f291ebe45a09a32a787fa00e9fc0ee", "filename": "src/test/run-pass/alloca-from-derived-tydesc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "ecc24877d2f55259ff8d3ac53273a22ab67d84a6", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "d49f54115ec041baa139fd574751bfb78f0d7cab", "filename": "src/test/run-pass/argv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "7a795f7cdfee702e352b0c084018884a79381fd2", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "6a3d54b5e35043083c2588a47d754543f4a5ec76", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "e4a0db4f15dde6ebc523e28b370327cc58bceb20", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "1b00df3b750a86f4da4743993e59dc393d81c13b", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "57ced911004ff3ea2689d6b24b4c3f63be7e9e53", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "31bb412de3b3de2b7c8e069dba4eb539144991ca", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "9d51c99389874690e623a6ce7c672dcbbab6e980", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "f33d12f4361540afa03b92f91aa3153dc4393ad6", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "12b7372227a114565a297ab6d519ff5252fbb62b", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}, {"sha": "ac96dbed60f43a04ce3c57787ef5fe0b493260ad", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329eca6044fdf376a7a89ec7a96dba7a8b884cf7/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=329eca6044fdf376a7a89ec7a96dba7a8b884cf7"}]}