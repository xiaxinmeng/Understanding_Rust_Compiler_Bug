{"sha": "84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZTlhNjFlOWM2OTdmZmI2ZjZmNzgzZTkxOTBkNWE5M2RmZGMxMGE=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-02T05:34:16Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-03T02:55:37Z"}, "message": "metadata: Implement relaxation of short RBML lengths.\n\nWe try to move the data when the length can be encoded in\nthe much smaller number of bytes. This interferes with indices and\ntype abbreviations however, so this commit introduces a public\ninterface to get and mark a \"stable\" (i.e. not affected by\nrelaxation) position of the current pointer.\n\nThe relaxation logic only moves a small data, currently at most\n256 bytes, as moving the data can be costly. There might be\nfurther opportunities to allow more relaxation by moving fields\naround, which I didn't seriously try.", "tree": {"sha": "6ecbad8ccff7283b3fe845aa09fe56d6fed1ef98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ecbad8ccff7283b3fe845aa09fe56d6fed1ef98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a", "html_url": "https://github.com/rust-lang/rust/commit/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de00b858d10aec2c39c692d4f61af8e9c9170ee0", "url": "https://api.github.com/repos/rust-lang/rust/commits/de00b858d10aec2c39c692d4f61af8e9c9170ee0", "html_url": "https://github.com/rust-lang/rust/commit/de00b858d10aec2c39c692d4f61af8e9c9170ee0"}], "stats": {"total": 240, "additions": 138, "deletions": 102}, "files": [{"sha": "d74d9ae812511b71162799e1348bf11a33075fac", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 62, "deletions": 32, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a", "patch": "@@ -729,21 +729,24 @@ pub mod writer {\n     use std::num::Int;\n     use std::old_io::{Writer, Seek};\n     use std::old_io;\n+    use std::slice::bytes;\n \n     use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n         EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n         EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsUint,\n         EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS };\n+    use super::io::SeekableMemWriter;\n \n     use serialize;\n \n \n     pub type EncodeResult = old_io::IoResult<()>;\n \n     // rbml writing\n-    pub struct Encoder<'a, W:'a> {\n-        pub writer: &'a mut W,\n+    pub struct Encoder<'a> {\n+        pub writer: &'a mut SeekableMemWriter,\n         size_positions: Vec<uint>,\n+        relax_limit: u64, // do not move encoded bytes before this position\n     }\n \n     fn write_tag<W: Writer>(w: &mut W, n: uint) -> EncodeResult {\n@@ -788,19 +791,21 @@ pub mod writer {\n         })\n     }\n \n-    impl<'a, W: Writer + Seek> Encoder<'a, W> {\n-        pub fn new(w: &'a mut W) -> Encoder<'a, W> {\n+    impl<'a> Encoder<'a> {\n+        pub fn new(w: &'a mut SeekableMemWriter) -> Encoder<'a> {\n             Encoder {\n                 writer: w,\n                 size_positions: vec!(),\n+                relax_limit: 0,\n             }\n         }\n \n         /// FIXME(pcwalton): Workaround for badness in trans. DO NOT USE ME.\n-        pub unsafe fn unsafe_clone(&self) -> Encoder<'a, W> {\n+        pub unsafe fn unsafe_clone(&self) -> Encoder<'a> {\n             Encoder {\n                 writer: mem::transmute_copy(&self.writer),\n                 size_positions: self.size_positions.clone(),\n+                relax_limit: self.relax_limit,\n             }\n         }\n \n@@ -822,11 +827,29 @@ pub mod writer {\n             let cur_pos = try!(self.writer.tell());\n             try!(self.writer.seek(last_size_pos as i64, old_io::SeekSet));\n             let size = cur_pos as uint - last_size_pos - 4;\n-            try!(write_sized_vuint(self.writer, size, 4));\n-            let r = try!(self.writer.seek(cur_pos as i64, old_io::SeekSet));\n+\n+            // relax the size encoding for small tags (bigger tags are costly to move).\n+            // we should never try to move the stable positions, however.\n+            const RELAX_MAX_SIZE: uint = 0x100;\n+            if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit as uint {\n+                // we can't alter the buffer in place, so have a temporary buffer\n+                let mut buf = [0u8; RELAX_MAX_SIZE];\n+                {\n+                    let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as uint];\n+                    bytes::copy_memory(&mut buf, data);\n+                }\n+\n+                // overwrite the size and data and continue\n+                try!(write_vuint(self.writer, size));\n+                try!(self.writer.write_all(&buf[..size]));\n+            } else {\n+                // overwrite the size with an overlong encoding and skip past the data\n+                try!(write_sized_vuint(self.writer, size, 4));\n+                try!(self.writer.seek(cur_pos as i64, old_io::SeekSet));\n+            }\n \n             debug!(\"End tag (size = {:?})\", size);\n-            Ok(r)\n+            Ok(())\n         }\n \n         pub fn wr_tag<F>(&mut self, tag_id: uint, blk: F) -> EncodeResult where\n@@ -933,12 +956,19 @@ pub mod writer {\n             debug!(\"Write str: {:?}\", s);\n             self.writer.write_all(s.as_bytes())\n         }\n-    }\n \n-    // FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n-    // efficiently encode sizes; this is a fixed point iteration\n+        /// Returns the current position while marking it stable, i.e.\n+        /// generated bytes so far woundn't be affected by relaxation.\n+        pub fn mark_stable_position(&mut self) -> u64 {\n+            let pos = self.writer.tell().unwrap();\n+            if self.relax_limit < pos {\n+                self.relax_limit = pos;\n+            }\n+            pos\n+        }\n+    }\n \n-    impl<'a, W: Writer + Seek> Encoder<'a, W> {\n+    impl<'a> Encoder<'a> {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_sub(&mut self, v: uint) -> EncodeResult {\n             if let Some(v) = v.to_u8() {\n@@ -955,15 +985,15 @@ pub mod writer {\n         }\n \n         pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder) -> EncodeResult,\n         {\n             try!(self.start_tag(EsOpaque as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n     }\n \n-    impl<'a, W: Writer + Seek> serialize::Encoder for Encoder<'a, W> {\n+    impl<'a> serialize::Encoder for Encoder<'a> {\n         type Error = old_io::IoError;\n \n         fn emit_nil(&mut self) -> EncodeResult {\n@@ -1023,7 +1053,7 @@ pub mod writer {\n         }\n \n         fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             try!(self.start_tag(EsEnum as uint));\n             try!(f(self));\n@@ -1035,14 +1065,14 @@ pub mod writer {\n                                 v_id: uint,\n                                 _: uint,\n                                 f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             try!(self._emit_tagged_sub(v_id));\n             f(self)\n         }\n \n         fn emit_enum_variant_arg<F>(&mut self, _: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n@@ -1052,7 +1082,7 @@ pub mod writer {\n                                        v_id: uint,\n                                        cnt: uint,\n                                        f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n@@ -1061,62 +1091,62 @@ pub mod writer {\n                                              _: &str,\n                                              idx: uint,\n                                              f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n         fn emit_struct<F>(&mut self, _: &str, _len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n \n         fn emit_struct_field<F>(&mut self, _name: &str, _: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n \n         fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq(len, f)\n         }\n         fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq_elt(idx, f)\n         }\n \n         fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq(len, f)\n         }\n         fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq_elt(idx, f)\n         }\n \n         fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_enum(\"Option\", f)\n         }\n         fn emit_option_none(&mut self) -> EncodeResult {\n             self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n         }\n         fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n         fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n             try!(self.start_tag(EsVec as uint));\n@@ -1126,7 +1156,7 @@ pub mod writer {\n         }\n \n         fn emit_seq_elt<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n             try!(self.start_tag(EsVecElt as uint));\n@@ -1135,7 +1165,7 @@ pub mod writer {\n         }\n \n         fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n             try!(self.start_tag(EsMap as uint));\n@@ -1145,7 +1175,7 @@ pub mod writer {\n         }\n \n         fn emit_map_elt_key<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n             try!(self.start_tag(EsMapKey as uint));\n@@ -1154,7 +1184,7 @@ pub mod writer {\n         }\n \n         fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             try!(self.start_tag(EsMapVal as uint));\n             try!(f(self));"}, {"sha": "fa9e28bf56d23e42633633a04c84c5d570f5ec65", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -46,7 +46,7 @@ use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax;\n-use rbml::writer;\n+use rbml::writer::Encoder;\n use rbml::io::SeekableMemWriter;\n \n /// A borrowed version of `ast::InlinedItem`.\n@@ -57,8 +57,6 @@ pub enum InlinedItemRef<'a> {\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n-pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n-\n pub type EncodeInlinedItem<'a> =\n     Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n \n@@ -115,7 +113,7 @@ fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n     };\n \n     rbml_w.start_tag(tag);\n-    tyencode::enc_trait_ref(rbml_w.writer, ty_str_ctxt, trait_ref);\n+    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, trait_ref);\n     rbml_w.end_tag();\n }\n \n@@ -169,7 +167,7 @@ pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_closure_ty(rbml_w.writer, ty_str_ctxt, closure_type);\n+    tyencode::enc_closure_ty(rbml_w, ty_str_ctxt, closure_type);\n }\n \n pub fn write_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n@@ -181,7 +179,7 @@ pub fn write_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_ty(rbml_w.writer, ty_str_ctxt, typ);\n+    tyencode::enc_ty(rbml_w, ty_str_ctxt, typ);\n }\n \n pub fn write_trait_ref<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n@@ -193,7 +191,7 @@ pub fn write_trait_ref<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_trait_ref(rbml_w.writer, ty_str_ctxt, trait_ref);\n+    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, trait_ref);\n }\n \n pub fn write_region(ecx: &EncodeContext,\n@@ -205,7 +203,7 @@ pub fn write_region(ecx: &EncodeContext,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_region(rbml_w.writer, ty_str_ctxt, r);\n+    tyencode::enc_region(rbml_w, ty_str_ctxt, r);\n }\n \n fn encode_bounds<'a, 'tcx>(rbml_w: &mut Encoder,\n@@ -218,7 +216,7 @@ fn encode_bounds<'a, 'tcx>(rbml_w: &mut Encoder,\n                                         ds: def_to_string,\n                                         tcx: ecx.tcx,\n                                         abbrevs: &ecx.type_abbrevs };\n-    tyencode::enc_bounds(rbml_w.writer, ty_str_ctxt, bounds);\n+    tyencode::enc_bounds(rbml_w, ty_str_ctxt, bounds);\n \n     rbml_w.end_tag();\n }\n@@ -250,7 +248,7 @@ fn encode_method_fty<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_bare_fn_ty(rbml_w.writer, ty_str_ctxt, typ);\n+    tyencode::enc_bare_fn_ty(rbml_w, ty_str_ctxt, typ);\n \n     rbml_w.end_tag();\n }\n@@ -312,7 +310,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n             val: variant.node.id as i64,\n-            pos: rbml_w.writer.tell().unwrap(),\n+            pos: rbml_w.mark_stable_position(),\n         });\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -659,10 +657,11 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         let nm = field.name;\n         let id = field.id.node;\n \n-        index.push(entry {val: id as i64, pos: rbml_w.writer.tell().unwrap()});\n+        let pos = rbml_w.mark_stable_position();\n+        index.push(entry {val: id as i64, pos: pos});\n         global_index.push(entry {\n             val: id as i64,\n-            pos: rbml_w.writer.tell().unwrap(),\n+            pos: pos,\n         });\n         rbml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n@@ -688,7 +687,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                struct_id: NodeId) {\n     index.push(entry {\n         val: ctor_id as i64,\n-        pos: rbml_w.writer.tell().unwrap(),\n+        pos: rbml_w.mark_stable_position(),\n     });\n \n     rbml_w.start_tag(tag_items_data_item);\n@@ -731,7 +730,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n     };\n     for param in generics.types.iter() {\n         rbml_w.start_tag(tag_type_param_def);\n-        tyencode::enc_type_param_def(rbml_w.writer, ty_str_ctxt, param);\n+        tyencode::enc_type_param_def(rbml_w, ty_str_ctxt, param);\n         rbml_w.end_tag();\n     }\n \n@@ -765,7 +764,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.wr_tagged_u8(tag_predicate_space, space as u8);\n \n         rbml_w.start_tag(tag_predicate_data);\n-        tyencode::enc_predicate(rbml_w.writer, ty_str_ctxt, predicate);\n+        tyencode::enc_predicate(rbml_w, ty_str_ctxt, predicate);\n         rbml_w.end_tag();\n \n         rbml_w.end_tag();\n@@ -964,11 +963,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &ast::Item, rbml_w: &Encoder,\n+    fn add_to_index(item: &ast::Item, rbml_w: &mut Encoder,\n                     index: &mut Vec<entry<i64>>) {\n         index.push(entry {\n             val: item.id as i64,\n-            pos: rbml_w.writer.tell().unwrap(),\n+            pos: rbml_w.mark_stable_position(),\n         });\n     }\n \n@@ -1224,7 +1223,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             index.push(entry {\n                 val: trait_item_def_id.def_id().node as i64,\n-                pos: rbml_w.writer.tell().unwrap(),\n+                pos: rbml_w.mark_stable_position(),\n             });\n \n             let trait_item_type =\n@@ -1322,7 +1321,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             index.push(entry {\n                 val: item_def_id.def_id().node as i64,\n-                pos: rbml_w.writer.tell().unwrap(),\n+                pos: rbml_w.mark_stable_position(),\n             });\n \n             rbml_w.start_tag(tag_items_data_item);\n@@ -1427,7 +1426,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 abi: abi::Abi) {\n     index.push(entry {\n         val: nitem.id as i64,\n-        pos: rbml_w.writer.tell().unwrap(),\n+        pos: rbml_w.mark_stable_position(),\n     });\n \n     rbml_w.start_tag(tag_items_data_item);\n@@ -1527,7 +1526,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_items_data);\n     index.push(entry {\n         val: ast::CRATE_NODE_ID as i64,\n-        pos: rbml_w.writer.tell().unwrap(),\n+        pos: rbml_w.mark_stable_position(),\n     });\n     encode_info_for_mod(ecx,\n                         rbml_w,\n@@ -1567,7 +1566,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     let mut bucket_locs = Vec::new();\n     rbml_w.start_tag(tag_index_buckets);\n     for bucket in &buckets {\n-        bucket_locs.push(rbml_w.writer.tell().unwrap());\n+        bucket_locs.push(rbml_w.mark_stable_position());\n         rbml_w.start_tag(tag_index_buckets_bucket);\n         for elt in bucket {\n             rbml_w.start_tag(tag_index_buckets_bucket_elt);\n@@ -1926,7 +1925,13 @@ pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't',\n pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n     let mut wr = SeekableMemWriter::new();\n     encode_metadata_inner(&mut wr, parms, krate);\n+\n+    // RBML compacts the encoded bytes whenever appropriate,\n+    // so there are some garbages left after the end of the data.\n+    let metalen = wr.tell().unwrap() as uint;\n     let mut v = wr.unwrap();\n+    v.truncate(metalen);\n+    assert_eq!(v.len(), metalen);\n \n     // And here we run into yet another obscure archive bug: in which metadata\n     // loaded from archives may have trailing garbage bytes. Awhile back one of\n@@ -2008,7 +2013,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         reachable: reachable,\n      };\n \n-    let mut rbml_w = writer::Encoder::new(wr);\n+    let mut rbml_w = Encoder::new(wr);\n \n     encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name);\n     encode_crate_triple(&mut rbml_w,\n@@ -2099,7 +2104,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n // Get the encoded string for a type\n pub fn encoded_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> String {\n     let mut wr = SeekableMemWriter::new();\n-    tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n+    tyencode::enc_ty(&mut Encoder::new(&mut wr), &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_string,\n         tcx: tcx,"}, {"sha": "86f1605b8bfaa706fa0de0f511703893d3f1c9a6", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -27,9 +27,9 @@ use syntax::ast;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n \n-use rbml::io::SeekableMemWriter;\n+use rbml::writer::Encoder;\n \n-macro_rules! mywrite { ($($arg:tt)*) => ({ write!($($arg)*); }) }\n+macro_rules! mywrite { ($w:expr, $($arg:tt)*) => ({ write!($w.writer, $($arg)*); }) }\n \n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n@@ -49,12 +49,14 @@ pub struct ty_abbrev {\n \n pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n \n-pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n+pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     match cx.abbrevs.borrow_mut().get(&t) {\n-        Some(a) => { w.write_all(a.s.as_bytes()); return; }\n+        Some(a) => { w.writer.write_all(a.s.as_bytes()); return; }\n         None => {}\n     }\n-    let pos = w.tell().unwrap();\n+\n+    // type abbreviations needs a stable position\n+    let pos = w.mark_stable_position();\n \n     match t.sty {\n         ty::ty_bool => mywrite!(w, \"b\"),\n@@ -154,7 +156,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         }\n     }\n \n-    let end = w.tell().unwrap();\n+    let end = w.mark_stable_position();\n     let len = end - pos;\n     fn estimate_sz(u: u64) -> u64 {\n         let mut n = u;\n@@ -171,21 +173,21 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n     }\n }\n \n-fn enc_mutability(w: &mut SeekableMemWriter, mt: ast::Mutability) {\n+fn enc_mutability(w: &mut Encoder, mt: ast::Mutability) {\n     match mt {\n         ast::MutImmutable => (),\n         ast::MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n-fn enc_mt<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+fn enc_mt<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                     mt: ty::mt<'tcx>) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T, F>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: F) where\n-    F: FnOnce(&mut SeekableMemWriter, T),\n+fn enc_opt<T, F>(w: &mut Encoder, t: Option<T>, enc_f: F) where\n+    F: FnOnce(&mut Encoder, T),\n {\n     match t {\n         None => mywrite!(w, \"n\"),\n@@ -196,11 +198,11 @@ fn enc_opt<T, F>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: F) where\n     }\n }\n \n-fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut SeekableMemWriter,\n+fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut Encoder,\n                                            cx: &ctxt<'a, 'tcx>,\n                                            v: &VecPerParamSpace<T>,\n                                            mut op: F) where\n-    F: FnMut(&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T),\n+    F: FnMut(&mut Encoder, &ctxt<'a, 'tcx>, &T),\n {\n     for &space in &subst::ParamSpace::all() {\n         mywrite!(w, \"[\");\n@@ -211,14 +213,14 @@ fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut SeekableMemWriter,\n     }\n }\n \n-pub fn enc_substs<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_substs<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                             substs: &subst::Substs<'tcx>) {\n     enc_region_substs(w, cx, &substs.regions);\n     enc_vec_per_param_space(w, cx, &substs.types,\n                             |w, cx, &ty| enc_ty(w, cx, ty));\n }\n \n-fn enc_region_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::RegionSubsts) {\n+fn enc_region_substs(w: &mut Encoder, cx: &ctxt, substs: &subst::RegionSubsts) {\n     match *substs {\n         subst::ErasedRegions => {\n             mywrite!(w, \"e\");\n@@ -231,7 +233,7 @@ fn enc_region_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::Regio\n     }\n }\n \n-pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n+pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n             mywrite!(w, \"b[{}|\", id.depth);\n@@ -270,7 +272,7 @@ pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n     }\n }\n \n-fn enc_scope(w: &mut SeekableMemWriter, _cx: &ctxt, scope: region::CodeExtent) {\n+fn enc_scope(w: &mut Encoder, _cx: &ctxt, scope: region::CodeExtent) {\n     match scope {\n         region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n         region::CodeExtent::Remainder(region::BlockRemainder {\n@@ -279,12 +281,12 @@ fn enc_scope(w: &mut SeekableMemWriter, _cx: &ctxt, scope: region::CodeExtent) {\n     }\n }\n \n-fn enc_destruction_scope_data(w: &mut SeekableMemWriter,\n+fn enc_destruction_scope_data(w: &mut Encoder,\n                               d: region::DestructionScopeData) {\n     mywrite!(w, \"{}\", d.node_id);\n }\n \n-fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n+fn enc_bound_region(w: &mut Encoder, cx: &ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {\n             mywrite!(w, \"a{}|\", idx);\n@@ -303,40 +305,40 @@ fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_trait_ref<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_trait_ref<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                s: &ty::TraitRef<'tcx>) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, s.substs);\n }\n \n-fn enc_unsafety(w: &mut SeekableMemWriter, p: ast::Unsafety) {\n+fn enc_unsafety(w: &mut Encoder, p: ast::Unsafety) {\n     match p {\n         ast::Unsafety::Normal => mywrite!(w, \"n\"),\n         ast::Unsafety::Unsafe => mywrite!(w, \"u\"),\n     }\n }\n \n-fn enc_abi(w: &mut SeekableMemWriter, abi: Abi) {\n+fn enc_abi(w: &mut Encoder, abi: Abi) {\n     mywrite!(w, \"[\");\n     mywrite!(w, \"{}\", abi.name());\n     mywrite!(w, \"]\")\n }\n \n-pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::BareFnTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n     enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_closure_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::ClosureTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n     enc_fn_sig(w, cx, &ft.sig);\n     enc_abi(w, ft.abi);\n }\n \n-fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+fn enc_fn_sig<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                         fsig: &ty::PolyFnSig<'tcx>) {\n     mywrite!(w, \"[\");\n     for ty in &fsig.0.inputs {\n@@ -358,7 +360,7 @@ fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     }\n }\n \n-pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n+pub fn enc_builtin_bounds(w: &mut Encoder, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n     for bound in bs {\n         match bound {\n             ty::BoundSend => mywrite!(w, \"S\"),\n@@ -371,7 +373,7 @@ pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::Builti\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_existential_bounds<'a,'tcx>(w: &mut SeekableMemWriter,\n+pub fn enc_existential_bounds<'a,'tcx>(w: &mut Encoder,\n                                        cx: &ctxt<'a,'tcx>,\n                                        bs: &ty::ExistentialBounds<'tcx>) {\n     let param_bounds = ty::ParamBounds { trait_bounds: vec!(),\n@@ -381,7 +383,7 @@ pub fn enc_existential_bounds<'a,'tcx>(w: &mut SeekableMemWriter,\n     enc_bounds(w, cx, &param_bounds);\n }\n \n-pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_bounds<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                             bs: &ty::ParamBounds<'tcx>) {\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n \n@@ -400,7 +402,7 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_region_bounds<'a, 'tcx>(w: &mut SeekableMemWriter,\n+pub fn enc_region_bounds<'a, 'tcx>(w: &mut Encoder,\n                             cx: &ctxt<'a, 'tcx>,\n                             rs: &[ty::Region]) {\n     for &r in rs {\n@@ -411,7 +413,7 @@ pub fn enc_region_bounds<'a, 'tcx>(w: &mut SeekableMemWriter,\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_name(v.name), (cx.ds)(v.def_id),\n@@ -420,7 +422,7 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tc\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n-fn enc_object_lifetime_default<'a, 'tcx>(w: &mut SeekableMemWriter,\n+fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Encoder,\n                                          cx: &ctxt<'a, 'tcx>,\n                                          default: Option<ty::ObjectLifetimeDefault>)\n {\n@@ -434,7 +436,7 @@ fn enc_object_lifetime_default<'a, 'tcx>(w: &mut SeekableMemWriter,\n     }\n }\n \n-pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n+pub fn enc_predicate<'a, 'tcx>(w: &mut Encoder,\n                                cx: &ctxt<'a, 'tcx>,\n                                p: &ty::Predicate<'tcx>)\n {\n@@ -465,7 +467,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n     }\n }\n \n-fn enc_projection_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n+fn enc_projection_predicate<'a, 'tcx>(w: &mut Encoder,\n                                       cx: &ctxt<'a, 'tcx>,\n                                       data: &ty::ProjectionPredicate<'tcx>) {\n     enc_trait_ref(w, cx, &*data.projection_ty.trait_ref);"}, {"sha": "da3e6b4765b98991aee8b62a48a54544fae083d8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=84e9a61e9c697ffb6f6f783e9190d5a93dfdc10a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -43,13 +43,14 @@ use std::old_io::Seek;\n use std::num::FromPrimitive;\n use std::rc::Rc;\n \n-use rbml::io::SeekableMemWriter;\n-use rbml::{reader, writer};\n+use rbml::reader;\n+use rbml::writer::Encoder;\n use rbml;\n use serialize;\n use serialize::{Decodable, Decoder, DecoderHelpers, Encodable};\n use serialize::{EncoderHelpers};\n \n+#[cfg(test)] use rbml::io::SeekableMemWriter;\n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n \n@@ -68,8 +69,6 @@ trait tr_intern {\n     fn tr_intern(&self, dcx: &DecodeContext) -> ast::DefId;\n }\n \n-pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n-\n // ______________________________________________________________________\n // Top-level methods.\n \n@@ -911,7 +910,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     fn emit_type_param_def<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                                type_param_def: &ty::TypeParameterDef<'tcx>) {\n         self.emit_opaque(|this| {\n-            Ok(tyencode::enc_type_param_def(this.writer,\n+            Ok(tyencode::enc_type_param_def(this,\n                                          &ecx.ty_str_ctxt(),\n                                          type_param_def))\n         });\n@@ -920,7 +919,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>) {\n         self.emit_opaque(|this| {\n-            Ok(tyencode::enc_predicate(this.writer,\n+            Ok(tyencode::enc_predicate(this,\n                                        &ecx.ty_str_ctxt(),\n                                        predicate))\n         });\n@@ -954,20 +953,20 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n \n     fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n                                    bounds: &ty::ExistentialBounds<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this.writer,\n+        self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this,\n                                                                     &ecx.ty_str_ctxt(),\n                                                                     bounds)));\n     }\n \n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_builtin_bounds(this.writer,\n+        self.emit_opaque(|this| Ok(tyencode::enc_builtin_bounds(this,\n                                                                 &ecx.ty_str_ctxt(),\n                                                                 bounds)));\n     }\n \n     fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                        substs: &subst::Substs<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_substs(this.writer,\n+        self.emit_opaque(|this| Ok(tyencode::enc_substs(this,\n                                                            &ecx.ty_str_ctxt(),\n                                                            substs)));\n     }\n@@ -1995,7 +1994,7 @@ fn mk_ctxt() -> parse::ParseSess {\n fn roundtrip(in_item: Option<P<ast::Item>>) {\n     let in_item = in_item.unwrap();\n     let mut wr = SeekableMemWriter::new();\n-    encode_item_ast(&mut writer::Encoder::new(&mut wr), &*in_item);\n+    encode_item_ast(&mut Encoder::new(&mut wr), &*in_item);\n     let rbml_doc = rbml::Doc::new(wr.get_ref());\n     let out_item = decode_item_ast(rbml_doc);\n "}]}