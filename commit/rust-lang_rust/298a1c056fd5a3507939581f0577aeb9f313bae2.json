{"sha": "298a1c056fd5a3507939581f0577aeb9f313bae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5OGExYzA1NmZkNWEzNTA3OTM5NTgxZjA1NzdhZWI5ZjMxM2JhZTI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-02T00:02:38Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-02T00:19:19Z"}, "message": "Cleanup formatting", "tree": {"sha": "ffa82fe72dd91f06df7c0ee3fcfcb68e70ebb070", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffa82fe72dd91f06df7c0ee3fcfcb68e70ebb070"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/298a1c056fd5a3507939581f0577aeb9f313bae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/298a1c056fd5a3507939581f0577aeb9f313bae2", "html_url": "https://github.com/rust-lang/rust/commit/298a1c056fd5a3507939581f0577aeb9f313bae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/298a1c056fd5a3507939581f0577aeb9f313bae2/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8dc2a7c768eb288b0984a4429a793df6a1213de", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8dc2a7c768eb288b0984a4429a793df6a1213de", "html_url": "https://github.com/rust-lang/rust/commit/b8dc2a7c768eb288b0984a4429a793df6a1213de"}], "stats": {"total": 654, "additions": 321, "deletions": 333}, "files": [{"sha": "099e13dfa09e8328669815f29ec7dd05ad93435e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 321, "deletions": 333, "changes": 654, "blob_url": "https://github.com/rust-lang/rust/blob/298a1c056fd5a3507939581f0577aeb9f313bae2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298a1c056fd5a3507939581f0577aeb9f313bae2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=298a1c056fd5a3507939581f0577aeb9f313bae2", "patch": "@@ -978,102 +978,100 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                 //     InPlace::finalize(place)\n                 // })\n-                return {\n-                    let placer_expr = lower_expr(lctx, placer);\n-                    let value_expr = lower_expr(lctx, value_expr);\n-\n-                    let placer_ident = lctx.str_to_ident(\"placer\");\n-                    let place_ident = lctx.str_to_ident(\"place\");\n-                    let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n-\n-                    let make_place = [\"ops\", \"Placer\", \"make_place\"];\n-                    let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n-                    let move_val_init = [\"intrinsics\", \"move_val_init\"];\n-                    let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n-\n-                    let make_call = |lctx: &LoweringContext, p, args| {\n-                        let path = core_path(lctx, e.span, p);\n-                        let path = expr_path(lctx, path, None);\n-                        expr_call(lctx, e.span, path, args, None)\n-                    };\n-\n-                    let mk_stmt_let = |lctx: &LoweringContext, bind, expr| {\n-                        stmt_let(lctx, e.span, false, bind, expr, None)\n-                    };\n+                let placer_expr = lower_expr(lctx, placer);\n+                let value_expr = lower_expr(lctx, value_expr);\n+\n+                let placer_ident = lctx.str_to_ident(\"placer\");\n+                let place_ident = lctx.str_to_ident(\"place\");\n+                let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n+\n+                let make_place = [\"ops\", \"Placer\", \"make_place\"];\n+                let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n+                let move_val_init = [\"intrinsics\", \"move_val_init\"];\n+                let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+\n+                let make_call = |lctx: &LoweringContext, p, args| {\n+                    let path = core_path(lctx, e.span, p);\n+                    let path = expr_path(lctx, path, None);\n+                    expr_call(lctx, e.span, path, args, None)\n+                };\n \n-                    let mk_stmt_let_mut = |lctx: &LoweringContext, bind, expr| {\n-                        stmt_let(lctx, e.span, true, bind, expr, None)\n-                    };\n+                let mk_stmt_let = |lctx: &LoweringContext, bind, expr| {\n+                    stmt_let(lctx, e.span, false, bind, expr, None)\n+                };\n \n-                    // let placer = <placer_expr> ;\n-                    let s1 = {\n-                        let placer_expr = signal_block_expr(lctx,\n-                                                            hir_vec![],\n-                                                            placer_expr,\n-                                                            e.span,\n-                                                            hir::PopUnstableBlock,\n-                                                            None);\n-                        mk_stmt_let(lctx, placer_ident, placer_expr)\n-                    };\n+                let mk_stmt_let_mut = |lctx: &LoweringContext, bind, expr| {\n+                    stmt_let(lctx, e.span, true, bind, expr, None)\n+                };\n \n-                    // let mut place = Placer::make_place(placer);\n-                    let s2 = {\n-                        let placer = expr_ident(lctx, e.span, placer_ident, None);\n-                        let call = make_call(lctx, &make_place, hir_vec![placer]);\n-                        mk_stmt_let_mut(lctx, place_ident, call)\n-                    };\n+                // let placer = <placer_expr> ;\n+                let s1 = {\n+                    let placer_expr = signal_block_expr(lctx,\n+                                                        hir_vec![],\n+                                                        placer_expr,\n+                                                        e.span,\n+                                                        hir::PopUnstableBlock,\n+                                                        None);\n+                    mk_stmt_let(lctx, placer_ident, placer_expr)\n+                };\n \n-                    // let p_ptr = Place::pointer(&mut place);\n-                    let s3 = {\n-                        let agent = expr_ident(lctx, e.span, place_ident, None);\n-                        let args = hir_vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n-                        let call = make_call(lctx, &place_pointer, args);\n-                        mk_stmt_let(lctx, p_ptr_ident, call)\n-                    };\n+                // let mut place = Placer::make_place(placer);\n+                let s2 = {\n+                    let placer = expr_ident(lctx, e.span, placer_ident, None);\n+                    let call = make_call(lctx, &make_place, hir_vec![placer]);\n+                    mk_stmt_let_mut(lctx, place_ident, call)\n+                };\n \n-                    // pop_unsafe!(EXPR));\n-                    let pop_unsafe_expr = {\n-                        let value_expr = signal_block_expr(lctx,\n-                                                           hir_vec![],\n-                                                           value_expr,\n-                                                           e.span,\n-                                                           hir::PopUnstableBlock,\n-                                                           None);\n-                        signal_block_expr(lctx,\n-                                          hir_vec![],\n-                                          value_expr,\n-                                          e.span,\n-                                          hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n-                    };\n+                // let p_ptr = Place::pointer(&mut place);\n+                let s3 = {\n+                    let agent = expr_ident(lctx, e.span, place_ident, None);\n+                    let args = hir_vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n+                    let call = make_call(lctx, &place_pointer, args);\n+                    mk_stmt_let(lctx, p_ptr_ident, call)\n+                };\n \n-                    // push_unsafe!({\n-                    //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-                    //     InPlace::finalize(place)\n-                    // })\n-                    let expr = {\n-                        let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n-                        let call_move_val_init =\n-                            hir::StmtSemi(\n-                                make_call(lctx, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n-                                lctx.next_id());\n-                        let call_move_val_init = respan(e.span, call_move_val_init);\n-\n-                        let place = expr_ident(lctx, e.span, place_ident, None);\n-                        let call = make_call(lctx, &inplace_finalize, hir_vec![place]);\n-                        signal_block_expr(lctx,\n-                                          hir_vec![call_move_val_init],\n-                                          call,\n-                                          e.span,\n-                                          hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n-                    };\n+                // pop_unsafe!(EXPR));\n+                let pop_unsafe_expr = {\n+                    let value_expr = signal_block_expr(lctx,\n+                                                       hir_vec![],\n+                                                       value_expr,\n+                                                       e.span,\n+                                                       hir::PopUnstableBlock,\n+                                                       None);\n+                    signal_block_expr(lctx,\n+                                      hir_vec![],\n+                                      value_expr,\n+                                      e.span,\n+                                      hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n+                };\n \n+                // push_unsafe!({\n+                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+                //     InPlace::finalize(place)\n+                // })\n+                let expr = {\n+                    let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n+                    let call_move_val_init =\n+                        hir::StmtSemi(\n+                            make_call(lctx, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n+                            lctx.next_id());\n+                    let call_move_val_init = respan(e.span, call_move_val_init);\n+\n+                    let place = expr_ident(lctx, e.span, place_ident, None);\n+                    let call = make_call(lctx, &inplace_finalize, hir_vec![place]);\n                     signal_block_expr(lctx,\n-                                      hir_vec![s1, s2, s3],\n-                                      expr,\n+                                      hir_vec![call_move_val_init],\n+                                      call,\n                                       e.span,\n-                                      hir::PushUnstableBlock,\n-                                      e.attrs.clone())\n-                }\n+                                      hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n+                };\n+\n+                return signal_block_expr(lctx,\n+                                         hir_vec![s1, s2, s3],\n+                                         expr,\n+                                         e.span,\n+                                         hir::PushUnstableBlock,\n+                                         e.attrs.clone());\n             }\n \n             ExprKind::Vec(ref exprs) => {\n@@ -1227,38 +1225,36 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                       None)\n                 }\n \n-                return {\n-                    use syntax::ast::RangeLimits::*;\n+                use syntax::ast::RangeLimits::*;\n \n-                    match (e1, e2, lims) {\n-                        (&None,         &None,         HalfOpen) =>\n-                            make_struct(lctx, e, &[\"RangeFull\"],\n-                                                 &[]),\n+                return match (e1, e2, lims) {\n+                    (&None,         &None,         HalfOpen) =>\n+                        make_struct(lctx, e, &[\"RangeFull\"],\n+                                             &[]),\n \n-                        (&Some(ref e1), &None,         HalfOpen) =>\n-                            make_struct(lctx, e, &[\"RangeFrom\"],\n-                                                 &[(\"start\", e1)]),\n+                    (&Some(ref e1), &None,         HalfOpen) =>\n+                        make_struct(lctx, e, &[\"RangeFrom\"],\n+                                             &[(\"start\", e1)]),\n \n-                        (&None,         &Some(ref e2), HalfOpen) =>\n-                            make_struct(lctx, e, &[\"RangeTo\"],\n-                                                 &[(\"end\", e2)]),\n+                    (&None,         &Some(ref e2), HalfOpen) =>\n+                        make_struct(lctx, e, &[\"RangeTo\"],\n+                                             &[(\"end\", e2)]),\n \n-                        (&Some(ref e1), &Some(ref e2), HalfOpen) =>\n-                            make_struct(lctx, e, &[\"Range\"],\n-                                                 &[(\"start\", e1), (\"end\", e2)]),\n+                    (&Some(ref e1), &Some(ref e2), HalfOpen) =>\n+                        make_struct(lctx, e, &[\"Range\"],\n+                                             &[(\"start\", e1), (\"end\", e2)]),\n \n-                        (&None,         &Some(ref e2), Closed)   =>\n-                            make_struct(lctx, e, &[\"RangeToInclusive\"],\n-                                                 &[(\"end\", e2)]),\n+                    (&None,         &Some(ref e2), Closed)   =>\n+                        make_struct(lctx, e, &[\"RangeToInclusive\"],\n+                                             &[(\"end\", e2)]),\n \n-                        (&Some(ref e1), &Some(ref e2), Closed)   =>\n-                            make_struct(lctx, e, &[\"RangeInclusive\", \"NonEmpty\"],\n-                                                 &[(\"start\", e1), (\"end\", e2)]),\n+                    (&Some(ref e1), &Some(ref e2), Closed)   =>\n+                        make_struct(lctx, e, &[\"RangeInclusive\", \"NonEmpty\"],\n+                                             &[(\"start\", e1), (\"end\", e2)]),\n \n-                        _ => panic!(lctx.diagnostic().span_fatal(e.span,\n-                                                                 \"inclusive range with no end\"))\n-                    }\n-                }\n+                    _ => panic!(lctx.diagnostic().span_fatal(e.span,\n+                                                             \"inclusive range with no end\"))\n+                };\n             }\n             ExprKind::Path(ref qself, ref path) => {\n                 let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n@@ -1332,81 +1328,79 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     _ => [<else_opt> | ()]\n                 //   }\n \n-                return {\n-                    // `<pat> => <body>`\n-                    let pat_arm = {\n-                        let body = lower_block(lctx, body);\n-                        let body_expr = expr_block(lctx, body, None);\n-                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n-                    };\n+                // `<pat> => <body>`\n+                let pat_arm = {\n+                    let body = lower_block(lctx, body);\n+                    let body_expr = expr_block(lctx, body, None);\n+                    arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n+                };\n \n-                    // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n-                    let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n-                    let else_if_arms = {\n-                        let mut arms = vec![];\n-                        loop {\n-                            let else_opt_continue = else_opt.and_then(|els| {\n-                                els.and_then(|els| {\n-                                    match els.node {\n-                                        // else if\n-                                        hir::ExprIf(cond, then, else_opt) => {\n-                                            let pat_under = pat_wild(lctx, e.span);\n-                                            arms.push(hir::Arm {\n-                                                attrs: hir_vec![],\n-                                                pats: hir_vec![pat_under],\n-                                                guard: Some(cond),\n-                                                body: expr_block(lctx, then, None),\n-                                            });\n-                                            else_opt.map(|else_opt| (else_opt, true))\n-                                        }\n-                                        _ => Some((P(els), false)),\n+                // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n+                let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n+                let else_if_arms = {\n+                    let mut arms = vec![];\n+                    loop {\n+                        let else_opt_continue = else_opt.and_then(|els| {\n+                            els.and_then(|els| {\n+                                match els.node {\n+                                    // else if\n+                                    hir::ExprIf(cond, then, else_opt) => {\n+                                        let pat_under = pat_wild(lctx, e.span);\n+                                        arms.push(hir::Arm {\n+                                            attrs: hir_vec![],\n+                                            pats: hir_vec![pat_under],\n+                                            guard: Some(cond),\n+                                            body: expr_block(lctx, then, None),\n+                                        });\n+                                        else_opt.map(|else_opt| (else_opt, true))\n                                     }\n-                                })\n-                            });\n-                            match else_opt_continue {\n-                                Some((e, true)) => {\n-                                    else_opt = Some(e);\n-                                }\n-                                Some((e, false)) => {\n-                                    else_opt = Some(e);\n-                                    break;\n-                                }\n-                                None => {\n-                                    else_opt = None;\n-                                    break;\n+                                    _ => Some((P(els), false)),\n                                 }\n+                            })\n+                        });\n+                        match else_opt_continue {\n+                            Some((e, true)) => {\n+                                else_opt = Some(e);\n+                            }\n+                            Some((e, false)) => {\n+                                else_opt = Some(e);\n+                                break;\n+                            }\n+                            None => {\n+                                else_opt = None;\n+                                break;\n                             }\n                         }\n-                        arms\n-                    };\n-\n-                    let contains_else_clause = else_opt.is_some();\n+                    }\n+                    arms\n+                };\n \n-                    // `_ => [<else_opt> | ()]`\n-                    let else_arm = {\n-                        let pat_under = pat_wild(lctx, e.span);\n-                        let else_expr =\n-                            else_opt.unwrap_or_else(\n-                                || expr_tuple(lctx, e.span, hir_vec![], None));\n-                        arm(hir_vec![pat_under], else_expr)\n-                    };\n+                let contains_else_clause = else_opt.is_some();\n \n-                    let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n-                    arms.push(pat_arm);\n-                    arms.extend(else_if_arms);\n-                    arms.push(else_arm);\n+                // `_ => [<else_opt> | ()]`\n+                let else_arm = {\n+                    let pat_under = pat_wild(lctx, e.span);\n+                    let else_expr =\n+                        else_opt.unwrap_or_else(\n+                            || expr_tuple(lctx, e.span, hir_vec![], None));\n+                    arm(hir_vec![pat_under], else_expr)\n+                };\n \n-                    let sub_expr = lower_expr(lctx, sub_expr);\n-                    // add attributes to the outer returned expr node\n-                    expr(lctx,\n-                         e.span,\n-                         hir::ExprMatch(sub_expr,\n-                                        arms.into(),\n-                                        hir::MatchSource::IfLetDesugar {\n-                                            contains_else_clause: contains_else_clause,\n-                                        }),\n-                         e.attrs.clone())\n-                }\n+                let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n+                arms.push(pat_arm);\n+                arms.extend(else_if_arms);\n+                arms.push(else_arm);\n+\n+                let sub_expr = lower_expr(lctx, sub_expr);\n+                // add attributes to the outer returned expr node\n+                return expr(lctx,\n+                            e.span,\n+                            hir::ExprMatch(sub_expr,\n+                                           arms.into(),\n+                                           hir::MatchSource::IfLetDesugar {\n+                                               contains_else_clause: contains_else_clause,\n+                                           }),\n+                            e.attrs.clone());\n             }\n \n             // Desugar ExprWhileLet\n@@ -1421,38 +1415,36 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     }\n                 //   }\n \n-                return {\n-                    // `<pat> => <body>`\n-                    let pat_arm = {\n-                        let body = lower_block(lctx, body);\n-                        let body_expr = expr_block(lctx, body, None);\n-                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n-                    };\n+                // `<pat> => <body>`\n+                let pat_arm = {\n+                    let body = lower_block(lctx, body);\n+                    let body_expr = expr_block(lctx, body, None);\n+                    arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n+                };\n \n-                    // `_ => break`\n-                    let break_arm = {\n-                        let pat_under = pat_wild(lctx, e.span);\n-                        let break_expr = expr_break(lctx, e.span, None);\n-                        arm(hir_vec![pat_under], break_expr)\n-                    };\n+                // `_ => break`\n+                let break_arm = {\n+                    let pat_under = pat_wild(lctx, e.span);\n+                    let break_expr = expr_break(lctx, e.span, None);\n+                    arm(hir_vec![pat_under], break_expr)\n+                };\n \n-                    // `match <sub_expr> { ... }`\n-                    let arms = hir_vec![pat_arm, break_arm];\n-                    let sub_expr = lower_expr(lctx, sub_expr);\n-                    let match_expr = expr(lctx,\n-                                          e.span,\n-                                          hir::ExprMatch(sub_expr,\n-                                                         arms,\n-                                                         hir::MatchSource::WhileLetDesugar),\n-                                          None);\n-\n-                    // `[opt_ident]: loop { ... }`\n-                    let loop_block = block_expr(lctx, match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block,\n-                                                  opt_ident.map(|ident| lower_ident(lctx, ident)));\n-                    // add attributes to the outer returned expr node\n-                    expr(lctx, e.span, loop_expr, e.attrs.clone())\n-                }\n+                // `match <sub_expr> { ... }`\n+                let arms = hir_vec![pat_arm, break_arm];\n+                let sub_expr = lower_expr(lctx, sub_expr);\n+                let match_expr = expr(lctx,\n+                                      e.span,\n+                                      hir::ExprMatch(sub_expr,\n+                                                     arms,\n+                                                     hir::MatchSource::WhileLetDesugar),\n+                                      None);\n+\n+                // `[opt_ident]: loop { ... }`\n+                let loop_block = block_expr(lctx, match_expr);\n+                let loop_expr = hir::ExprLoop(loop_block,\n+                                              opt_ident.map(|ident| lower_ident(lctx, ident)));\n+                // add attributes to the outer returned expr node\n+                return expr(lctx, e.span, loop_expr, e.attrs.clone());\n             }\n \n             // Desugar ExprForLoop\n@@ -1474,106 +1466,104 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     result\n                 //   }\n \n-                return {\n-                    // expand <head>\n-                    let head = lower_expr(lctx, head);\n-\n-                    let iter = lctx.str_to_ident(\"iter\");\n-\n-                    // `::std::option::Option::Some(<pat>) => <body>`\n-                    let pat_arm = {\n-                        let body_block = lower_block(lctx, body);\n-                        let body_span = body_block.span;\n-                        let body_expr = P(hir::Expr {\n-                            id: lctx.next_id(),\n-                            node: hir::ExprBlock(body_block),\n-                            span: body_span,\n-                            attrs: None,\n-                        });\n-                        let pat = lower_pat(lctx, pat);\n-                        let some_pat = pat_some(lctx, e.span, pat);\n+                // expand <head>\n+                let head = lower_expr(lctx, head);\n \n-                        arm(hir_vec![some_pat], body_expr)\n-                    };\n+                let iter = lctx.str_to_ident(\"iter\");\n \n-                    // `::std::option::Option::None => break`\n-                    let break_arm = {\n-                        let break_expr = expr_break(lctx, e.span, None);\n+                // `::std::option::Option::Some(<pat>) => <body>`\n+                let pat_arm = {\n+                    let body_block = lower_block(lctx, body);\n+                    let body_span = body_block.span;\n+                    let body_expr = P(hir::Expr {\n+                        id: lctx.next_id(),\n+                        node: hir::ExprBlock(body_block),\n+                        span: body_span,\n+                        attrs: None,\n+                    });\n+                    let pat = lower_pat(lctx, pat);\n+                    let some_pat = pat_some(lctx, e.span, pat);\n \n-                        arm(hir_vec![pat_none(lctx, e.span)], break_expr)\n-                    };\n+                    arm(hir_vec![some_pat], body_expr)\n+                };\n \n-                    // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n-                    let match_expr = {\n-                        let next_path = {\n-                            let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n-\n-                            path_global(e.span, strs)\n-                        };\n-                        let iter = expr_ident(lctx, e.span, iter, None);\n-                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter, None);\n-                        let next_path = expr_path(lctx, next_path, None);\n-                        let next_expr = expr_call(lctx,\n-                                                  e.span,\n-                                                  next_path,\n-                                                  hir_vec![ref_mut_iter],\n-                                                  None);\n-                        let arms = hir_vec![pat_arm, break_arm];\n-\n-                        expr(lctx,\n-                             e.span,\n-                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n-                             None)\n-                    };\n+                // `::std::option::Option::None => break`\n+                let break_arm = {\n+                    let break_expr = expr_break(lctx, e.span, None);\n \n-                    // `[opt_ident]: loop { ... }`\n-                    let loop_block = block_expr(lctx, match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block,\n-                                                  opt_ident.map(|ident| lower_ident(lctx, ident)));\n-                    let loop_expr = expr(lctx, e.span, loop_expr, None);\n-\n-                    // `mut iter => { ... }`\n-                    let iter_arm = {\n-                        let iter_pat = pat_ident_binding_mode(lctx,\n-                                                              e.span,\n-                                                              iter,\n-                                                              hir::BindByValue(hir::MutMutable));\n-                        arm(hir_vec![iter_pat], loop_expr)\n+                    arm(hir_vec![pat_none(lctx, e.span)], break_expr)\n+                };\n+\n+                // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+                let match_expr = {\n+                    let next_path = {\n+                        let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n+\n+                        path_global(e.span, strs)\n                     };\n+                    let iter = expr_ident(lctx, e.span, iter, None);\n+                    let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter, None);\n+                    let next_path = expr_path(lctx, next_path, None);\n+                    let next_expr = expr_call(lctx,\n+                                              e.span,\n+                                              next_path,\n+                                              hir_vec![ref_mut_iter],\n+                                              None);\n+                    let arms = hir_vec![pat_arm, break_arm];\n+\n+                    expr(lctx,\n+                         e.span,\n+                         hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n+                         None)\n+                };\n \n-                    // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n-                    let into_iter_expr = {\n-                        let into_iter_path = {\n-                            let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n+                // `[opt_ident]: loop { ... }`\n+                let loop_block = block_expr(lctx, match_expr);\n+                let loop_expr = hir::ExprLoop(loop_block,\n+                                              opt_ident.map(|ident| lower_ident(lctx, ident)));\n+                let loop_expr = expr(lctx, e.span, loop_expr, None);\n+\n+                // `mut iter => { ... }`\n+                let iter_arm = {\n+                    let iter_pat = pat_ident_binding_mode(lctx,\n+                                                          e.span,\n+                                                          iter,\n+                                                          hir::BindByValue(hir::MutMutable));\n+                    arm(hir_vec![iter_pat], loop_expr)\n+                };\n \n-                            path_global(e.span, strs)\n-                        };\n+                // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+                let into_iter_expr = {\n+                    let into_iter_path = {\n+                        let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n-                        let into_iter = expr_path(lctx, into_iter_path, None);\n-                        expr_call(lctx, e.span, into_iter, hir_vec![head], None)\n+                        path_global(e.span, strs)\n                     };\n \n-                    let match_expr = expr_match(lctx,\n-                                                e.span,\n-                                                into_iter_expr,\n-                                                hir_vec![iter_arm],\n-                                                hir::MatchSource::ForLoopDesugar,\n-                                                None);\n-\n-                    // `{ let _result = ...; _result }`\n-                    // underscore prevents an unused_variables lint if the head diverges\n-                    let result_ident = lctx.str_to_ident(\"_result\");\n-                    let let_stmt = stmt_let(lctx,\n+                    let into_iter = expr_path(lctx, into_iter_path, None);\n+                    expr_call(lctx, e.span, into_iter, hir_vec![head], None)\n+                };\n+\n+                let match_expr = expr_match(lctx,\n                                             e.span,\n-                                            false,\n-                                            result_ident,\n-                                            match_expr,\n+                                            into_iter_expr,\n+                                            hir_vec![iter_arm],\n+                                            hir::MatchSource::ForLoopDesugar,\n                                             None);\n-                    let result = expr_ident(lctx, e.span, result_ident, None);\n-                    let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n-                    // add the attributes to the outer returned expr node\n-                    expr_block(lctx, block, e.attrs.clone())\n-                }\n+\n+                // `{ let _result = ...; _result }`\n+                // underscore prevents an unused_variables lint if the head diverges\n+                let result_ident = lctx.str_to_ident(\"_result\");\n+                let let_stmt = stmt_let(lctx,\n+                                        e.span,\n+                                        false,\n+                                        result_ident,\n+                                        match_expr,\n+                                        None);\n+                let result = expr_ident(lctx, e.span, result_ident, None);\n+                let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n+                // add the attributes to the outer returned expr node\n+                return expr_block(lctx, block, e.attrs.clone());\n             }\n \n             // Desugar ExprKind::Try\n@@ -1590,48 +1580,46 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     }\n                 // }\n \n-                return {\n-                    // expand <expr>\n-                    let sub_expr = lower_expr(lctx, sub_expr);\n+                // expand <expr>\n+                let sub_expr = lower_expr(lctx, sub_expr);\n \n-                    // Ok(val) => val\n-                    let ok_arm = {\n-                        let val_ident = lctx.str_to_ident(\"val\");\n-                        let val_pat = pat_ident(lctx, e.span, val_ident);\n-                        let val_expr = expr_ident(lctx, e.span, val_ident, None);\n-                        let ok_pat = pat_ok(lctx, e.span, val_pat);\n+                // Ok(val) => val\n+                let ok_arm = {\n+                    let val_ident = lctx.str_to_ident(\"val\");\n+                    let val_pat = pat_ident(lctx, e.span, val_ident);\n+                    let val_expr = expr_ident(lctx, e.span, val_ident, None);\n+                    let ok_pat = pat_ok(lctx, e.span, val_pat);\n \n-                        arm(hir_vec![ok_pat], val_expr)\n-                    };\n+                    arm(hir_vec![ok_pat], val_expr)\n+                };\n \n-                    // Err(err) => return Err(From::from(err))\n-                    let err_arm = {\n-                        let err_ident = lctx.str_to_ident(\"err\");\n-                        let from_expr = {\n-                            let path = std_path(lctx, &[\"convert\", \"From\", \"from\"]);\n-                            let path = path_global(e.span, path);\n-                            let from = expr_path(lctx, path, None);\n-                            let err_expr = expr_ident(lctx, e.span, err_ident, None);\n-\n-                            expr_call(lctx, e.span, from, hir_vec![err_expr], None)\n-                        };\n-                        let err_expr = {\n-                            let path = std_path(lctx, &[\"result\", \"Result\", \"Err\"]);\n-                            let path = path_global(e.span, path);\n-                            let err_ctor = expr_path(lctx, path, None);\n-                            expr_call(lctx, e.span, err_ctor, hir_vec![from_expr], None)\n-                        };\n-                        let err_pat = pat_err(lctx, e.span,\n-                                              pat_ident(lctx, e.span, err_ident));\n-                        let ret_expr = expr(lctx, e.span,\n-                                            hir::Expr_::ExprRet(Some(err_expr)), None);\n-\n-                        arm(hir_vec![err_pat], ret_expr)\n+                // Err(err) => return Err(From::from(err))\n+                let err_arm = {\n+                    let err_ident = lctx.str_to_ident(\"err\");\n+                    let from_expr = {\n+                        let path = std_path(lctx, &[\"convert\", \"From\", \"from\"]);\n+                        let path = path_global(e.span, path);\n+                        let from = expr_path(lctx, path, None);\n+                        let err_expr = expr_ident(lctx, e.span, err_ident, None);\n+\n+                        expr_call(lctx, e.span, from, hir_vec![err_expr], None)\n+                    };\n+                    let err_expr = {\n+                        let path = std_path(lctx, &[\"result\", \"Result\", \"Err\"]);\n+                        let path = path_global(e.span, path);\n+                        let err_ctor = expr_path(lctx, path, None);\n+                        expr_call(lctx, e.span, err_ctor, hir_vec![from_expr], None)\n                     };\n+                    let err_pat = pat_err(lctx, e.span,\n+                                          pat_ident(lctx, e.span, err_ident));\n+                    let ret_expr = expr(lctx, e.span,\n+                                        hir::Expr_::ExprRet(Some(err_expr)), None);\n \n-                    expr_match(lctx, e.span, sub_expr, hir_vec![err_arm, ok_arm],\n-                               hir::MatchSource::TryDesugar, None)\n-                }\n+                    arm(hir_vec![err_pat], ret_expr)\n+                };\n+\n+                return expr_match(lctx, e.span, sub_expr, hir_vec![err_arm, ok_arm],\n+                                  hir::MatchSource::TryDesugar, None);\n             }\n \n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),"}]}