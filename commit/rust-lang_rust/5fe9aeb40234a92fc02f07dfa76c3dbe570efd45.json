{"sha": "5fe9aeb40234a92fc02f07dfa76c3dbe570efd45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZTlhZWI0MDIzNGE5MmZjMDJmMDdkZmE3NmMzZGJlNTcwZWZkNDU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-26T18:48:50Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:32Z"}, "message": "Refactor mod/check (part ii)", "tree": {"sha": "227b635d440488607e7277017c845db5d90c4a85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/227b635d440488607e7277017c845db5d90c4a85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fe9aeb40234a92fc02f07dfa76c3dbe570efd45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fe9aeb40234a92fc02f07dfa76c3dbe570efd45", "html_url": "https://github.com/rust-lang/rust/commit/5fe9aeb40234a92fc02f07dfa76c3dbe570efd45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fe9aeb40234a92fc02f07dfa76c3dbe570efd45/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1a82af23575dad3d7af2760dac6db0132b9a2d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1a82af23575dad3d7af2760dac6db0132b9a2d1", "html_url": "https://github.com/rust-lang/rust/commit/d1a82af23575dad3d7af2760dac6db0132b9a2d1"}], "stats": {"total": 166, "additions": 106, "deletions": 60}, "files": [{"sha": "0bee400f449fe0fc538e9e200c4f430ee06e97a6", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fe9aeb40234a92fc02f07dfa76c3dbe570efd45/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fe9aeb40234a92fc02f07dfa76c3dbe570efd45/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=5fe9aeb40234a92fc02f07dfa76c3dbe570efd45", "patch": "@@ -226,9 +226,9 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     fn fill_item<F>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>,\n-                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    defs: &ty::Generics,\n-                    mk_kind: &mut F)\n+                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        defs: &ty::Generics,\n+                        mk_kind: &mut F)\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n     {\n         if let Some(def_id) = defs.parent {\n@@ -238,7 +238,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         Substs::fill_single(substs, defs, mk_kind)\n     }\n \n-    fn fill_single<F>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>,\n+    pub fn fill_single<F>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>,\n                       defs: &ty::Generics,\n                       mk_kind: &mut F)\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>"}, {"sha": "4b16cbbf750484617d959b994ad69303463bcd83", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 102, "deletions": 56, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/5fe9aeb40234a92fc02f07dfa76c3dbe570efd45/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fe9aeb40234a92fc02f07dfa76c3dbe570efd45/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5fe9aeb40234a92fc02f07dfa76c3dbe570efd45", "patch": "@@ -103,6 +103,8 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use errors::{DiagnosticBuilder, DiagnosticId};\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::array_vec::ArrayVec;\n \n use require_c_abi_if_variadic;\n use session::{CompileIncomplete, config, Session};\n@@ -5002,10 +5004,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut infer_types_type_seg = true;\n         if let Some((seg, _)) = type_segment {\n             if let Some(ref data) = seg.args {\n-                for arg in &data.args {\n+                for (i, arg) in data.args.iter().enumerate() {\n                     match arg {\n-                        GenericArg::Lifetime(lt) => lifetimes_type_seg.push(lt),\n-                        GenericArg::Type(ty) => types_type_seg.push(ty),\n+                        GenericArg::Lifetime(lt) => lifetimes_type_seg.push((i, lt)),\n+                        GenericArg::Type(ty) => types_type_seg.push((i, ty)),\n                     }\n                 }\n             }\n@@ -5017,74 +5019,118 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut infer_types_fn_seg = true;\n         if let Some((seg, _)) = fn_segment {\n             if let Some(ref data) = seg.args {\n-                for arg in &data.args {\n+                for (i, arg) in data.args.iter().enumerate() {\n                     match arg {\n-                        GenericArg::Lifetime(lt) => lifetimes_fn_seg.push(lt),\n-                        GenericArg::Type(ty) => types_fn_seg.push(ty),\n+                        GenericArg::Lifetime(lt) => lifetimes_fn_seg.push((i, lt)),\n+                        GenericArg::Type(ty) => types_fn_seg.push((i, ty)),\n                     }\n                 }\n             }\n             infer_types_fn_seg = seg.infer_types;\n         }\n \n-        let substs = Substs::for_item(self.tcx, def.def_id(), |param, substs| {\n-            let mut i = param.index as usize;\n-\n-            let (segment, lifetimes, types, infer_types) = if i < fn_start {\n-                if let GenericParamDefKind::Type { .. } = param.kind {\n-                    // Handle Self first, so we can adjust the index to match the AST.\n-                    if has_self && i == 0 {\n-                        return opt_self_ty.map(|ty| ty.into()).unwrap_or_else(|| {\n-                            self.var_for_def(span, param)\n-                        });\n+        let defs = self.tcx.generics_of(def.def_id());\n+        let count = defs.count();\n+        let mut substs = if count <= 8 {\n+            AccumulateVec::Array(ArrayVec::new())\n+        } else {\n+            AccumulateVec::Heap(Vec::with_capacity(count))\n+        };\n+        let mut stack = vec![def.def_id()];\n+        let mut parent_defs = defs;\n+        while let Some(def_id) = parent_defs.parent {\n+            parent_defs = self.tcx.generics_of(def_id);\n+            stack.push(def_id);\n+        }\n+        while let Some(def_id) = stack.pop() {\n+            let defs = self.tcx.generics_of(def_id);\n+            Substs::fill_single(&mut substs, defs, &mut |param: &ty::GenericParamDef, substs| {\n+                let mut i = param.index as usize;\n+\n+                let (lifetimes, types, infer_types) = if i < fn_start {\n+                    if let GenericParamDefKind::Type { .. } = param.kind {\n+                        // Handle Self first, so we can adjust the index to match the AST.\n+                        if has_self && i == 0 {\n+                            return opt_self_ty.map(|ty| ty.into()).unwrap_or_else(|| {\n+                                self.var_for_def(span, param)\n+                            });\n+                        }\n                     }\n-                }\n-                i -= has_self as usize;\n-                (type_segment, &lifetimes_type_seg, &types_type_seg, infer_types_type_seg)\n-            } else {\n-                i -= fn_start;\n-                (fn_segment, &lifetimes_fn_seg, &types_fn_seg, infer_types_fn_seg)\n-            };\n+                    i -= has_self as usize;\n+                    (&lifetimes_type_seg, &types_type_seg, infer_types_type_seg)\n+                } else {\n+                    i -= fn_start;\n+                    (&lifetimes_fn_seg, &types_fn_seg, infer_types_fn_seg)\n+                };\n \n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {\n-                    if let Some(lifetime) = lifetimes.get(i) {\n-                        AstConv::ast_region_to_region(self, lifetime, Some(param)).into()\n-                    } else {\n-                        self.re_infer(span, Some(param)).unwrap().into()\n+                let mut pi = param.index as usize - has_self as usize;\n+\n+                let segment = if let Some(&PathSeg(_, ind)) = path_segs.iter().find(|&PathSeg(di, _)| *di == def_id) {\n+                    let seg = &segments[ind];\n+                    if lifetimes.len() == 0 {\n+                        pi -= defs.own_counts().lifetimes;\n                     }\n-                }\n-                GenericParamDefKind::Type { .. } => {\n-                    // Skip over the lifetimes in the same segment.\n-                    if let Some((_, generics)) = segment {\n-                        i -= generics.own_counts().lifetimes;\n+\n+                    Some((seg, defs))\n+                } else {\n+                    None\n+                };\n+\n+                // eprintln!(\"{:?} {:?} {:?}\", param.index, i, segment);\n+\n+\n+\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        if let Some((z, lt)) = lifetimes.get(i) {\n+                            eprintln!(\"lifetime {:?} {:?} {:?}\", pi, z, has_self);\n+                            if pi != *z {\n+                                eprintln!(\"error {:?} {:?} {:?} {:?} {:?} {:?}\", pi, z, i, segment, fn_start, has_self);\n+                                bug!(\"uh oh\")\n+                            }\n+                            AstConv::ast_region_to_region(self, lt, Some(param)).into()\n+                        } else {\n+                            self.re_infer(span, Some(param)).unwrap().into()\n+                        }\n                     }\n+                    GenericParamDefKind::Type { .. } => {\n+                        // Skip over the lifetimes in the same segment.\n+                        if let Some((_, generics)) = segment {\n+                            i -= generics.own_counts().lifetimes;\n+                        }\n \n-                    let has_default = match param.kind {\n-                        GenericParamDefKind::Type { has_default, .. } => has_default,\n-                        _ => unreachable!()\n-                    };\n+                        let has_default = match param.kind {\n+                            GenericParamDefKind::Type { has_default, .. } => has_default,\n+                            _ => unreachable!()\n+                        };\n \n-                    if let Some(ast_ty) = types.get(i) {\n-                        // A provided type parameter.\n-                        self.to_ty(ast_ty).into()\n-                    } else if !infer_types && has_default {\n-                        // No type parameter provided, but a default exists.\n-                        let default = self.tcx.type_of(param.def_id);\n-                        self.normalize_ty(\n-                            span,\n-                            default.subst_spanned(self.tcx, substs, Some(span))\n-                        ).into()\n-                    } else {\n-                        // No type parameters were provided, we can infer all.\n-                        // This can also be reached in some error cases:\n-                        // We prefer to use inference variables instead of\n-                        // TyError to let type inference recover somewhat.\n-                        self.var_for_def(span, param)\n+                        if let Some((z, ty)) = types.get(i) {\n+                            eprintln!(\"type {:?} {:?} {:?}\", pi, z, has_self);\n+                            if pi != *z {\n+                                eprintln!(\"error {:?} {:?} {:?} {:?} {:?} {:?}\", pi, z, i, segment, fn_start, has_self);\n+                                bug!(\"uh oh\")\n+                            }\n+                            // A provided type parameter.\n+                            self.to_ty(ty).into()\n+                        } else if !infer_types && has_default {\n+                            // No type parameter provided, but a default exists.\n+                            let default = self.tcx.type_of(param.def_id);\n+                            self.normalize_ty(\n+                                span,\n+                                default.subst_spanned(self.tcx, substs, Some(span))\n+                            ).into()\n+                        } else {\n+                            // No type parameters were provided, we can infer all.\n+                            // This can also be reached in some error cases:\n+                            // We prefer to use inference variables instead of\n+                            // TyError to let type inference recover somewhat.\n+                            self.var_for_def(span, param)\n+                        }\n                     }\n                 }\n-            }\n-        });\n+            });\n+        }\n+        let substs = self.tcx.intern_substs(&substs);\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme."}]}