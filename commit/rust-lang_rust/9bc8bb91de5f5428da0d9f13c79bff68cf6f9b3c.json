{"sha": "9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c", "node_id": "C_kwDOAAsO6NoAKDliYzhiYjkxZGU1ZjU0MjhkYTBkOWYxM2M3OWJmZjY4Y2Y2ZjliM2M", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-03-08T09:27:38Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-04-03T07:24:01Z"}, "message": "validate ignore-FOO/only-FOO directives and output only-FOO reasoning", "tree": {"sha": "8beea32e74113f0d832726dd2c3ac26d7fccccf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8beea32e74113f0d832726dd2c3ac26d7fccccf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmQqfxEACgkQzXazX3c0\ndp7Thw/+JB7s1qD+6ql117E+qrL7WT4eoQRdIY1reE7sc9x9LzKbc7wj/OXbrTmI\nZEtBjbJ0do8jStt/BjrOm9bagYZpXU0joStpVbQaS3QyJ2QzGwVh5Jsn/NZOlkNB\nkqtYSPWQZSvpZK7IPI6LVe4xkr5aLmh2Zxb81S7FDVaw0gSaNmbffBs+cSJD3+uY\nPDhfYUfb+pUsQ9zUeenAiWoZbVmbEx1Wdl9zXiF0/kpicYJJPAClCvuugtH9l/YQ\nGM+tXlEglsV1sAwvpteeivAPHnL8JYqkzP2BVZf7wT+MQ1Kwp8QEn0Qc2LW5iyju\nt4RssD8diOrFc38LpmMNgl3tA9nab48O89fExWgYTN0VBhrPJ25m3XoDtPM1keLH\npIbQHrBfgH6BGtWFhmB1ct73rucEXSiUvG88D1g9JnqkDPd6bZvlW3p6LVPe/bMb\nK2ek7Al5GdXY7QHw/7B0cOLe/GeKc4WmS9ZG1jtpJ0Z3+sQiBIv8d3DpOkk4608h\nddfhQYyspy4zJIHGd0M4sURvQ7fPyndb1FWpmz7t4fYA/rcCvCvA2Sq3uF9Hqtni\n2SV/ho/9gPDYv8fQbvWTomTPFCcULUUDTeRSgQkjqHgn/Im9PgDDtTeXwOoAllYY\nVNsUFuiuzjn0RmFec9nd0jL9/GUWf3WPm8HkPNjYZhewU3zvqjM=\n=gfU4\n-----END PGP SIGNATURE-----", "payload": "tree 8beea32e74113f0d832726dd2c3ac26d7fccccf5\nparent 4e2a98268a3193e3161adafd4534c036f139da8f\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1678267658 +0100\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1680506641 +0200\n\nvalidate ignore-FOO/only-FOO directives and output only-FOO reasoning\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c", "html_url": "https://github.com/rust-lang/rust/commit/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e2a98268a3193e3161adafd4534c036f139da8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e2a98268a3193e3161adafd4534c036f139da8f", "html_url": "https://github.com/rust-lang/rust/commit/4e2a98268a3193e3161adafd4534c036f139da8f"}], "stats": {"total": 216, "additions": 178, "deletions": 38}, "files": [{"sha": "9df5c298757dc17cef53223dc8fc73fbda3d212e", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 95, "deletions": 23, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c", "patch": "@@ -9,6 +9,7 @@ use std::str::FromStr;\n \n use crate::util::{add_dylib_path, PathBufExt};\n use lazycell::LazyCell;\n+use std::collections::HashSet;\n use test::{ColorConfig, OutputFormat};\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -129,6 +130,14 @@ pub enum CompareMode {\n }\n \n impl CompareMode {\n+    pub(crate) const VARIANTS: &'static [CompareMode] = &[\n+        CompareMode::Polonius,\n+        CompareMode::Chalk,\n+        CompareMode::NextSolver,\n+        CompareMode::SplitDwarf,\n+        CompareMode::SplitDwarfSingle,\n+    ];\n+\n     pub(crate) fn to_str(&self) -> &'static str {\n         match *self {\n             CompareMode::Polonius => \"polonius\",\n@@ -159,6 +168,9 @@ pub enum Debugger {\n }\n \n impl Debugger {\n+    pub(crate) const VARIANTS: &'static [Debugger] =\n+        &[Debugger::Cdb, Debugger::Gdb, Debugger::Lldb];\n+\n     pub(crate) fn to_str(&self) -> &'static str {\n         match self {\n             Debugger::Cdb => \"cdb\",\n@@ -396,8 +408,12 @@ impl Config {\n         })\n     }\n \n+    pub fn target_cfgs(&self) -> &TargetCfgs {\n+        self.target_cfgs.borrow_with(|| TargetCfgs::new(self))\n+    }\n+\n     pub fn target_cfg(&self) -> &TargetCfg {\n-        self.target_cfg.borrow_with(|| TargetCfg::new(self))\n+        &self.target_cfgs().current\n     }\n \n     pub fn matches_arch(&self, arch: &str) -> bool {\n@@ -449,6 +465,63 @@ impl Config {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub struct TargetCfgs {\n+    pub current: TargetCfg,\n+    pub all_targets: HashSet<String>,\n+    pub all_archs: HashSet<String>,\n+    pub all_oses: HashSet<String>,\n+    pub all_envs: HashSet<String>,\n+    pub all_abis: HashSet<String>,\n+    pub all_families: HashSet<String>,\n+    pub all_pointer_widths: HashSet<String>,\n+}\n+\n+impl TargetCfgs {\n+    fn new(config: &Config) -> TargetCfgs {\n+        // Gather list of all targets\n+        let targets = rustc_output(config, &[\"--print=target-list\"]);\n+\n+        let mut current = None;\n+        let mut all_targets = HashSet::new();\n+        let mut all_archs = HashSet::new();\n+        let mut all_oses = HashSet::new();\n+        let mut all_envs = HashSet::new();\n+        let mut all_abis = HashSet::new();\n+        let mut all_families = HashSet::new();\n+        let mut all_pointer_widths = HashSet::new();\n+\n+        for target in targets.trim().lines() {\n+            let cfg = TargetCfg::new(config, target);\n+\n+            all_archs.insert(cfg.arch.clone());\n+            all_oses.insert(cfg.os.clone());\n+            all_envs.insert(cfg.env.clone());\n+            all_abis.insert(cfg.abi.clone());\n+            for family in &cfg.families {\n+                all_families.insert(family.clone());\n+            }\n+            all_pointer_widths.insert(format!(\"{}bit\", cfg.pointer_width));\n+\n+            if target == config.target {\n+                current = Some(cfg);\n+            }\n+            all_targets.insert(target.into());\n+        }\n+\n+        Self {\n+            current: current.expect(\"current target not found\"),\n+            all_targets,\n+            all_archs,\n+            all_oses,\n+            all_envs,\n+            all_abis,\n+            all_families,\n+            all_pointer_widths,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct TargetCfg {\n     pub(crate) arch: String,\n@@ -468,28 +541,8 @@ pub enum Endian {\n }\n \n impl TargetCfg {\n-    fn new(config: &Config) -> TargetCfg {\n-        let mut command = Command::new(&config.rustc_path);\n-        add_dylib_path(&mut command, iter::once(&config.compile_lib_path));\n-        let output = match command\n-            .arg(\"--print=cfg\")\n-            .arg(\"--target\")\n-            .arg(&config.target)\n-            .args(&config.target_rustcflags)\n-            .output()\n-        {\n-            Ok(output) => output,\n-            Err(e) => panic!(\"error: failed to get cfg info from {:?}: {e}\", config.rustc_path),\n-        };\n-        if !output.status.success() {\n-            panic!(\n-                \"error: failed to get cfg info from {:?}\\n--- stdout\\n{}\\n--- stderr\\n{}\",\n-                config.rustc_path,\n-                String::from_utf8(output.stdout).unwrap(),\n-                String::from_utf8(output.stderr).unwrap(),\n-            );\n-        }\n-        let print_cfg = String::from_utf8(output.stdout).unwrap();\n+    fn new(config: &Config, target: &str) -> TargetCfg {\n+        let print_cfg = rustc_output(config, &[\"--print=cfg\", \"--target\", target]);\n         let mut arch = None;\n         let mut os = None;\n         let mut env = None;\n@@ -539,6 +592,25 @@ impl TargetCfg {\n     }\n }\n \n+fn rustc_output(config: &Config, args: &[&str]) -> String {\n+    let mut command = Command::new(&config.rustc_path);\n+    add_dylib_path(&mut command, iter::once(&config.compile_lib_path));\n+    command.args(&config.target_rustcflags).args(args);\n+\n+    let output = match command.output() {\n+        Ok(output) => output,\n+        Err(e) => panic!(\"error: failed to run {command:?}: {e}\"),\n+    };\n+    if !output.status.success() {\n+        panic!(\n+            \"error: failed to run {command:?}\\n--- stdout\\n{}\\n--- stderr\\n{}\",\n+            String::from_utf8(output.stdout).unwrap(),\n+            String::from_utf8(output.stderr).unwrap(),\n+        );\n+    }\n+    String::from_utf8(output.stdout).unwrap()\n+}\n+\n #[derive(Debug, Clone)]\n pub struct TestPaths {\n     pub file: PathBuf,         // e.g., compile-test/foo/bar/baz.rs"}, {"sha": "71e1072ceb376a0a418677d5021e46ea40fa48a0", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 82, "deletions": 14, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c", "patch": "@@ -8,6 +8,7 @@ use std::process::Command;\n \n use tracing::*;\n \n+use crate::common::CompareMode;\n use crate::common::{Config, Debugger, FailMode, Mode, PassMode};\n use crate::util;\n use crate::{extract_cdb_version, extract_gdb_version};\n@@ -36,6 +37,10 @@ enum MatchOutcome {\n     NoMatch,\n     /// Match.\n     Match,\n+    /// The directive was invalid.\n+    Invalid,\n+    /// The directive is handled by other parts of our tooling.\n+    External,\n }\n \n /// Properties which must be known very early, before actually running\n@@ -692,60 +697,99 @@ impl Config {\n         let (name, comment) =\n             line.split_once(&[':', ' ']).map(|(l, c)| (l, Some(c))).unwrap_or((line, None));\n \n-        let mut is_match = None;\n+        let mut outcome = MatchOutcome::Invalid;\n+        let mut message = None;\n \n         macro_rules! maybe_condition {\n-            (name: $name:expr, $(condition: $condition:expr,)? message: $($message:tt)*) => {\n-                if let Some(expected) = $name {\n-                    if name == expected $(&& $condition)? {\n-                        is_match = Some(format!($($message)*));\n+            (\n+                name: $name:expr,\n+                $(allowed_names: $allowed_names:expr,)?\n+                $(condition: $condition:expr,)?\n+                message: $($message:tt)*\n+            ) => {{\n+                // This is not inlined to avoid problems with macro repetitions.\n+                let format_message = || format!($($message)*);\n+\n+                if outcome != MatchOutcome::Invalid {\n+                    // Ignore all other matches if we already found one\n+                } else if $name.as_ref().map(|n| n == &name).unwrap_or(false) {\n+                    message = Some(format_message());\n+                    if true $(&& $condition)? {\n+                        outcome = MatchOutcome::Match;\n+                    } else {\n+                        outcome = MatchOutcome::NoMatch;\n                     }\n                 }\n-            };\n+                $(else if $allowed_names.contains(name) {\n+                    message = Some(format_message());\n+                    outcome = MatchOutcome::NoMatch;\n+                })?\n+            }};\n         }\n         macro_rules! condition {\n-            (name: $name:expr, $(condition: $condition:expr,)? message: $($message:tt)*) => {\n+            (\n+                name: $name:expr,\n+                $(allowed_names: $allowed_names:expr,)?\n+                $(condition: $condition:expr,)?\n+                message: $($message:tt)*\n+            ) => {\n                 maybe_condition! {\n                     name: Some($name),\n+                    $(allowed_names: $allowed_names,)*\n                     $(condition: $condition,)*\n                     message: $($message)*\n                 }\n             };\n         }\n+        macro_rules! hashset {\n+            ($($value:expr),* $(,)?) => {{\n+                let mut set = HashSet::new();\n+                $(set.insert($value);)*\n+                set\n+            }}\n+        }\n+\n+        let target_cfgs = self.target_cfgs();\n+        let target_cfg = self.target_cfg();\n \n         condition! {\n             name: \"test\",\n             message: \"always\"\n         }\n         condition! {\n             name: &self.target,\n+            allowed_names: &target_cfgs.all_targets,\n             message: \"when the target is {name}\"\n         }\n-\n-        let target_cfg = self.target_cfg();\n         condition! {\n             name: &target_cfg.os,\n+            allowed_names: &target_cfgs.all_oses,\n             message: \"when the operative system is {name}\"\n         }\n         condition! {\n             name: &target_cfg.env,\n+            allowed_names: &target_cfgs.all_envs,\n             message: \"when the target environment is {name}\"\n         }\n         condition! {\n             name: &target_cfg.abi,\n+            allowed_names: &target_cfgs.all_abis,\n             message: \"when the ABI is {name}\"\n         }\n         condition! {\n             name: &target_cfg.arch,\n+            allowed_names: &target_cfgs.all_archs,\n             message: \"when the architecture is {name}\"\n         }\n         condition! {\n             name: format!(\"{}bit\", target_cfg.pointer_width),\n+            allowed_names: &target_cfgs.all_pointer_widths,\n             message: \"when the pointer width is {name}\"\n         }\n         for family in &target_cfg.families {\n             condition! {\n                 name: family,\n+                allowed_names: &target_cfgs.all_families,\n                 message: \"when the target family is {name}\"\n             }\n         }\n@@ -768,6 +812,7 @@ impl Config {\n \n         condition! {\n             name: &self.channel,\n+            allowed_names: hashset![\"stable\", \"beta\", \"nightly\"],\n             message: \"when the release channel is {name}\",\n         }\n         condition! {\n@@ -782,6 +827,7 @@ impl Config {\n         }\n         condition! {\n             name: self.stage_id.split('-').next().unwrap(),\n+            allowed_names: hashset![\"stable\", \"beta\", \"nightly\"],\n             message: \"when the bootstrapping stage is {name}\",\n         }\n         condition! {\n@@ -796,20 +842,38 @@ impl Config {\n         }\n         maybe_condition! {\n             name: self.debugger.as_ref().map(|d| d.to_str()),\n+            allowed_names: Debugger::VARIANTS\n+                .iter()\n+                .map(|v| v.to_str())\n+                .collect::<HashSet<_>>(),\n             message: \"when the debugger is {name}\",\n         }\n         maybe_condition! {\n             name: self.compare_mode\n                 .as_ref()\n                 .map(|d| format!(\"compare-mode-{}\", d.to_str())),\n+            allowed_names: CompareMode::VARIANTS\n+                .iter()\n+                .map(|cm| format!(\"compare-mode-{}\", cm.to_str()))\n+                .collect::<HashSet<_>>(),\n             message: \"when comparing with {name}\",\n         }\n \n+        // Don't error out for ignore-tidy-* diretives, as those are not handled by compiletest.\n+        if prefix == \"ignore\" && name.starts_with(\"tidy-\") && outcome == MatchOutcome::Invalid {\n+            outcome = MatchOutcome::External;\n+        }\n+\n+        // Don't error out for ignore-pass, as that is handled elsewhere.\n+        if prefix == \"ignore\" && name == \"pass\" && outcome == MatchOutcome::Invalid {\n+            outcome = MatchOutcome::External;\n+        }\n+\n         ParsedNameDirective {\n             name: Some(name),\n             comment: comment.map(|c| c.trim().trim_start_matches('-').trim()),\n-            outcome: if is_match.is_some() { MatchOutcome::Match } else { MatchOutcome::NoMatch },\n-            pretty_reason: is_match,\n+            outcome,\n+            pretty_reason: message,\n         }\n     }\n \n@@ -1095,6 +1159,8 @@ pub fn make_test_description<R: Read>(\n                     true\n                 }\n                 MatchOutcome::NoMatch => ignore,\n+                MatchOutcome::External => ignore,\n+                MatchOutcome::Invalid => panic!(\"invalid line in {}: {ln}\", path.display()),\n             };\n         }\n \n@@ -1103,16 +1169,18 @@ pub fn make_test_description<R: Read>(\n             ignore = match parsed.outcome {\n                 MatchOutcome::Match => ignore,\n                 MatchOutcome::NoMatch => {\n-                    let name = parsed.name.unwrap();\n+                    let reason = parsed.pretty_reason.unwrap();\n                     // The ignore reason must be a &'static str, so we have to leak memory to\n                     // create it. This is fine, as the header is parsed only at the start of\n                     // compiletest so it won't grow indefinitely.\n                     ignore_message = Some(Box::leak(Box::<str>::from(match parsed.comment {\n-                        Some(comment) => format!(\"did not match only-{name} ({comment})\"),\n-                        None => format!(\"did not match only-{name}\"),\n+                        Some(comment) => format!(\"only executed {reason} ({comment})\"),\n+                        None => format!(\"only executed {reason}\"),\n                     })) as &str);\n                     true\n                 }\n+                MatchOutcome::External => ignore,\n+                MatchOutcome::Invalid => panic!(\"invalid line in {}: {ln}\", path.display()),\n             };\n         }\n "}, {"sha": "b10c2d36d602c20cdb530813ccbd4fa79f55a718", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=9bc8bb91de5f5428da0d9f13c79bff68cf6f9b3c", "patch": "@@ -311,7 +311,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n \n         force_rerun: matches.opt_present(\"force-rerun\"),\n \n-        target_cfg: LazyCell::new(),\n+        target_cfgs: LazyCell::new(),\n \n         nocapture: matches.opt_present(\"nocapture\"),\n     }"}]}