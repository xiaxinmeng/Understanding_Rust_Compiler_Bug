{"sha": "4c6b6c200befdef9d5882a8edf135efc20de905a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNmI2YzIwMGJlZmRlZjlkNTg4MmE4ZWRmMTM1ZWZjMjBkZTkwNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-23T09:48:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-23T09:48:11Z"}, "message": "Auto merge of #33098 - raphlinus:master, r=alexcrichton\n\nEfficient trie lookup for boolean Unicode properties\n\nReplace binary search of ranges with trie lookup using leaves of\n64-bit bitmap chunks. Benchmarks suggest this is approximately 10x\nfaster than the bsearch approach.", "tree": {"sha": "f5fe0a969c87b6d2c0df684107c3a292a9555746", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5fe0a969c87b6d2c0df684107c3a292a9555746"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c6b6c200befdef9d5882a8edf135efc20de905a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c6b6c200befdef9d5882a8edf135efc20de905a", "html_url": "https://github.com/rust-lang/rust/commit/4c6b6c200befdef9d5882a8edf135efc20de905a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c6b6c200befdef9d5882a8edf135efc20de905a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e455640950c4e8cb8bff919edb4854fcf7773ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e455640950c4e8cb8bff919edb4854fcf7773ca", "html_url": "https://github.com/rust-lang/rust/commit/6e455640950c4e8cb8bff919edb4854fcf7773ca"}, {"sha": "cfaf66c94e29a38cd3264b4a55c85b90213543d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfaf66c94e29a38cd3264b4a55c85b90213543d9", "html_url": "https://github.com/rust-lang/rust/commit/cfaf66c94e29a38cd3264b4a55c85b90213543d9"}], "stats": {"total": 2517, "additions": 1383, "deletions": 1134}, "files": [{"sha": "a99770f2261409d84774c6c7911f690426da710b", "filename": "src/etc/unicode.py", "status": "modified", "additions": 134, "deletions": 4, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/4c6b6c200befdef9d5882a8edf135efc20de905a/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/4c6b6c200befdef9d5882a8edf135efc20de905a/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=4c6b6c200befdef9d5882a8edf135efc20de905a", "patch": "@@ -25,6 +25,9 @@\n \n import fileinput, re, os, sys, operator\n \n+bytes_old = 0\n+bytes_new = 0\n+\n preamble = '''// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -307,12 +310,137 @@ def emit_table(f, name, t_data, t_type = \"&'static [(char, char)]\", is_pub=True,\n     format_table_content(f, data, 8)\n     f.write(\"\\n    ];\\n\\n\")\n \n+def emit_trie_lookup_range_table(f):\n+    f.write(\"\"\"\n+\n+// BoolTrie is a trie for representing a set of Unicode codepoints. It is\n+// implemented with postfix compression (sharing of identical child nodes),\n+// which gives both compact size and fast lookup.\n+//\n+// The space of Unicode codepoints is divided into 3 subareas, each\n+// represented by a trie with different depth. In the first (0..0x800), there\n+// is no trie structure at all; each u64 entry corresponds to a bitvector\n+// effectively holding 64 bool values.\n+//\n+// In the second (0x800..0x10000), each child of the root node represents a\n+// 64-wide subrange, but instead of storing the full 64-bit value of the leaf,\n+// the trie stores an 8-bit index into a shared table of leaf values. This\n+// exploits the fact that in reasonable sets, many such leaves can be shared.\n+//\n+// In the third (0x10000..0x110000), each child of the root node represents a\n+// 4096-wide subrange, and the trie stores an 8-bit index into a 64-byte slice\n+// of a child tree. Each of these 64 bytes represents an index into the table\n+// of shared 64-bit leaf values. This exploits the sparse structure in the\n+// non-BMP range of most Unicode sets.\n+pub struct BoolTrie {\n+    // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n+    r1: [u64; 32],   // leaves\n+\n+    // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n+    r2: [u8; 992],      // first level\n+    r3: &'static [u64],  // leaves\n+\n+    // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n+    r4: [u8; 256],       // first level\n+    r5: &'static [u8],   // second level\n+    r6: &'static [u64],  // leaves\n+}\n+\n+fn trie_range_leaf(c: usize, bitmap_chunk: u64) -> bool {\n+    ((bitmap_chunk >> (c & 63)) & 1) != 0\n+}\n+\n+fn trie_lookup_range_table(c: char, r: &'static BoolTrie) -> bool {\n+    let c = c as usize;\n+    if c < 0x800 {\n+        trie_range_leaf(c, r.r1[c >> 6])\n+    } else if c < 0x10000 {\n+        let child = r.r2[(c >> 6) - 0x20];\n+        trie_range_leaf(c, r.r3[child as usize])\n+    } else {\n+        let child = r.r4[(c >> 12) - 0x10];\n+        let leaf = r.r5[((child as usize) << 6) + ((c >> 6) & 0x3f)];\n+        trie_range_leaf(c, r.r6[leaf as usize])\n+    }\n+}\\n\n+\"\"\")\n+\n+def compute_trie(rawdata, chunksize):\n+    root = []\n+    childmap = {}\n+    child_data = []\n+    for i in range(len(rawdata) / chunksize):\n+        data = rawdata[i * chunksize: (i + 1) * chunksize]\n+        child = '|'.join(map(str, data))\n+        if child not in childmap:\n+            childmap[child] = len(childmap)\n+            child_data.extend(data)\n+        root.append(childmap[child])\n+    return (root, child_data)\n+\n+def emit_bool_trie(f, name, t_data, is_pub=True):\n+    global bytes_old, bytes_new\n+    bytes_old += 8 * len(t_data)\n+    CHUNK = 64\n+    rawdata = [False] * 0x110000;\n+    for (lo, hi) in t_data:\n+        for cp in range(lo, hi + 1):\n+            rawdata[cp] = True\n+\n+    # convert to bitmap chunks of 64 bits each\n+    chunks = []\n+    for i in range(0x110000 / CHUNK):\n+        chunk = 0\n+        for j in range(64):\n+            if rawdata[i * 64 + j]:\n+                chunk |= 1 << j\n+        chunks.append(chunk)\n+\n+    pub_string = \"\"\n+    if is_pub:\n+        pub_string = \"pub \"\n+    f.write(\"    %sconst %s: &'static super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name))\n+    f.write(\"        r1: [\\n\")\n+    data = ','.join('0x%016x' % chunk for chunk in chunks[0:0x800 / CHUNK])\n+    format_table_content(f, data, 12)\n+    f.write(\"\\n        ],\\n\")\n+\n+    # 0x800..0x10000 trie\n+    (r2, r3) = compute_trie(chunks[0x800 / CHUNK : 0x10000 / CHUNK], 64 / CHUNK)\n+    f.write(\"        r2: [\\n\")\n+    data = ','.join(str(node) for node in r2)\n+    format_table_content(f, data, 12)\n+    f.write(\"\\n        ],\\n\")\n+    f.write(\"        r3: &[\\n\")\n+    data = ','.join('0x%016x' % chunk for chunk in r3)\n+    format_table_content(f, data, 12)\n+    f.write(\"\\n        ],\\n\")\n+\n+    # 0x10000..0x110000 trie\n+    (mid, r6) = compute_trie(chunks[0x10000 / CHUNK : 0x110000 / CHUNK], 64 / CHUNK)\n+    (r4, r5) = compute_trie(mid, 64)\n+    f.write(\"        r4: [\\n\")\n+    data = ','.join(str(node) for node in r4)\n+    format_table_content(f, data, 12)\n+    f.write(\"\\n        ],\\n\")\n+    f.write(\"        r5: &[\\n\")\n+    data = ','.join(str(node) for node in r5)\n+    format_table_content(f, data, 12)\n+    f.write(\"\\n        ],\\n\")\n+    f.write(\"        r6: &[\\n\")\n+    data = ','.join('0x%016x' % chunk for chunk in r6)\n+    format_table_content(f, data, 12)\n+    f.write(\"\\n        ],\\n\")\n+\n+    f.write(\"    };\\n\\n\")\n+    bytes_new += 256 + 992 + 256 + 8 * len(r3) + len(r5) + 8 * len(r6)\n+\n def emit_property_module(f, mod, tbl, emit):\n     f.write(\"pub mod %s {\\n\" % mod)\n     for cat in sorted(emit):\n-        emit_table(f, \"%s_table\" % cat, tbl[cat])\n+        emit_bool_trie(f, \"%s_table\" % cat, tbl[cat])\n         f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n-        f.write(\"        super::bsearch_range_table(c, %s_table)\\n\" % cat)\n+        f.write(\"        super::trie_lookup_range_table(c, %s_table)\\n\" % cat)\n         f.write(\"    }\\n\\n\")\n     f.write(\"}\\n\\n\")\n \n@@ -402,8 +530,9 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n         norm_props = load_properties(\"DerivedNormalizationProps.txt\",\n                      [\"Full_Composition_Exclusion\"])\n \n-        # bsearch_range_table is used in all the property modules below\n-        emit_bsearch_range_table(rf)\n+        # trie_lookup_table is used in all the property modules below\n+        emit_trie_lookup_range_table(rf)\n+        # emit_bsearch_range_table(rf)\n \n         # category tables\n         for (name, cat, pfuns) in (\"general_category\", gencats, [\"N\", \"Cc\"]), \\\n@@ -414,3 +543,4 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n         # normalizations and conversions module\n         emit_norm_module(rf, canon_decomp, compat_decomp, combines, norm_props)\n         emit_conversions_module(rf, to_upper, to_lower, to_title)\n+    #print 'bytes before = %d, bytes after = %d' % (bytes_old, bytes_new)"}, {"sha": "43e7c26fd7215b427159784919072329ef2eb081", "filename": "src/librustc_unicode/tables.rs", "status": "modified", "additions": 1249, "deletions": 1130, "changes": 2379, "blob_url": "https://github.com/rust-lang/rust/blob/4c6b6c200befdef9d5882a8edf135efc20de905a/src%2Flibrustc_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c6b6c200befdef9d5882a8edf135efc20de905a/src%2Flibrustc_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Ftables.rs?ref=4c6b6c200befdef9d5882a8edf135efc20de905a"}]}