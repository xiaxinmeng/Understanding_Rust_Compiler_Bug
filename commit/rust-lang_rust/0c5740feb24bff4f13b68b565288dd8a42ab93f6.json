{"sha": "0c5740feb24bff4f13b68b565288dd8a42ab93f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNTc0MGZlYjI0YmZmNGYxM2I2OGI1NjUyODhkZDhhNDJhYjkzZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-25T01:50:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-25T01:50:56Z"}, "message": "Auto merge of #49986 - zofrex:better-derived-argument-names, r=Manishearth\n\nProvide better names for builtin deriving-generated attributes\n\nFirst attempt at fixing #49967\n\nNot in love with any choices here, don't be shy if you aren't happy with anything :)\n\nI've tested that this produces nicer names in documentation, and that it no longer has issues conflicting with constants with the same name. (I guess we _could_ make a test for that... unsure if that would be valuable)\n\nIn all cases I took the names from the methods as declared in the relevant trait.\n\nIn some cases I had to prepend the names with _ otherwise there were errors about un-used variables. I'm uneasy with the inconsistency... do they all need to be like that? Is there a way to generate an alternate impl or use a different name (`_`?) in the cases where the arguments are not used?\n\nLastly the gensym addition to Ident I implemented largely as suggested, but I want to point out it's a little circuitous (at least, as far as I understand it). `cx.ident_of(name)` is just `Ident::from_str`, so we create an Ident then another Ident from it. `Ident::with_empty_ctxt(Symbol::gensym(string))` may or may not be equivalent, I don't know if it's important to intern it _then_ gensym it. It seems like either we could use that, or if we do want a new method to make this convenient, it could be on Ident instead (`from_str_gensymed`?)", "tree": {"sha": "f4ae998795d7e3ec2cfcbf0ccd3aa1c6816ccb08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ae998795d7e3ec2cfcbf0ccd3aa1c6816ccb08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c5740feb24bff4f13b68b565288dd8a42ab93f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5740feb24bff4f13b68b565288dd8a42ab93f6", "html_url": "https://github.com/rust-lang/rust/commit/0c5740feb24bff4f13b68b565288dd8a42ab93f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c5740feb24bff4f13b68b565288dd8a42ab93f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "190a6c41cf2afdb11e81545846f2639ee96998e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/190a6c41cf2afdb11e81545846f2639ee96998e8", "html_url": "https://github.com/rust-lang/rust/commit/190a6c41cf2afdb11e81545846f2639ee96998e8"}, {"sha": "d6feab6f57a4fd284640b255a53b6e5727cf1b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6feab6f57a4fd284640b255a53b6e5727cf1b78", "html_url": "https://github.com/rust-lang/rust/commit/d6feab6f57a4fd284640b255a53b6e5727cf1b78"}], "stats": {"total": 137, "additions": 97, "deletions": 40}, "files": [{"sha": "17c114bc3b3c0f3beff9483681aa136d30f6b221", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -184,6 +184,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n                 b: hir::BodyId, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n+\n     fn visit_local(&mut self, l: &'tcx hir::Local) { visit_local(self, l); }\n     fn visit_expr(&mut self, ex: &'tcx Expr) { visit_expr(self, ex); }\n     fn visit_arm(&mut self, a: &'tcx hir::Arm) { visit_arm(self, a); }\n@@ -361,6 +362,16 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     // swap in a new set of IR maps for this function body:\n     let mut fn_maps = IrMaps::new(ir.tcx);\n \n+    // Don't run unused pass for #[derive()]\n+    if let FnKind::Method(..) = fk {\n+        let parent = ir.tcx.hir.get_parent(id);\n+        if let Some(hir::map::Node::NodeItem(i)) = ir.tcx.hir.find(parent) {\n+            if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n+                return;\n+            }\n+        }\n+    }\n+\n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n     let body = ir.tcx.hir.body(body_id);"}, {"sha": "99b6f752e9406a48c91e12f1ef8a806897cb9d71", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -38,7 +38,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                           name: \"cmp\",\n                           generics: LifetimeBounds::empty(),\n                           explicit_self: borrowed_explicit_self(),\n-                          args: vec![borrowed_self()],\n+                          args: vec![(borrowed_self(), \"other\")],\n                           ret_ty: Literal(path_std!(cx, cmp::Ordering)),\n                           attributes: attrs,\n                           is_unsafe: false,\n@@ -64,7 +64,7 @@ pub fn ordering_collapsed(cx: &mut ExtCtxt,\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"__cmp\");\n+    let test_id = cx.ident_of(\"cmp\").gensym();\n     let equals_path = cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n \n     let cmp_path = cx.std_path(&[\"cmp\", \"Ord\", \"cmp\"]);\n@@ -77,9 +77,9 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n     // ::std::cmp::Ordering::Equal => {\n     // ...\n     // }\n-    // __cmp => __cmp\n+    // cmp => cmp\n     // },\n-    // __cmp => __cmp\n+    // cmp => cmp\n     // }\n     //\n     cs_fold(// foldr nests the if-elses correctly, leaving the first field\n@@ -88,7 +88,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n             |cx, span, old, self_f, other_fs| {\n         // match new {\n         //     ::std::cmp::Ordering::Equal => old,\n-        //     __cmp => __cmp\n+        //     cmp => cmp\n         // }\n \n         let new = {"}, {"sha": "c259733d81abdc8e8e288b3f7a91c940672b40d5", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -78,7 +78,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec![borrowed_self()],\n+                args: vec![(borrowed_self(), \"other\")],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,"}, {"sha": "d71527fd0ed0f960f11502401150d58b1575a74a", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -34,7 +34,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec![borrowed_self()],\n+                args: vec![(borrowed_self(), \"other\")],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,\n@@ -59,7 +59,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n         name: \"partial_cmp\",\n         generics: LifetimeBounds::empty(),\n         explicit_self: borrowed_explicit_self(),\n-        args: vec![borrowed_self()],\n+        args: vec![(borrowed_self(), \"other\")],\n         ret_ty,\n         attributes: attrs,\n         is_unsafe: false,\n@@ -123,7 +123,7 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"__cmp\");\n+    let test_id = cx.ident_of(\"cmp\").gensym();\n     let ordering = cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n     let equals_expr = cx.expr_some(span, ordering_expr);\n@@ -138,9 +138,9 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n     // ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n     // ...\n     // }\n-    // __cmp => __cmp\n+    // cmp => cmp\n     // },\n-    // __cmp => __cmp\n+    // cmp => cmp\n     // }\n     //\n     cs_fold(// foldr nests the if-elses correctly, leaving the first field\n@@ -149,7 +149,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n             |cx, span, old, self_f, other_fs| {\n         // match new {\n         //     Some(::std::cmp::Ordering::Equal) => old,\n-        //     __cmp => __cmp\n+        //     cmp => cmp\n         // }\n \n         let new = {"}, {"sha": "b546f5df15799467ad2daf2f8dd9408c4692a9e1", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -40,7 +40,7 @@ pub fn expand_deriving_debug(cx: &mut ExtCtxt,\n                           name: \"fmt\",\n                           generics: LifetimeBounds::empty(),\n                           explicit_self: borrowed_explicit_self(),\n-                          args: vec![fmtr],\n+                          args: vec![(fmtr, \"f\")],\n                           ret_ty: Literal(path_std!(cx, fmt::Result)),\n                           attributes: Vec::new(),\n                           is_unsafe: false,\n@@ -70,7 +70,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = span.with_ctxt(cx.backtrace());\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let builder = Ident::from_str(\"__debug_trait_builder\");\n+    let builder = Ident::from_str(\"debug_trait_builder\").gensym();\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();"}, {"sha": "7618fe63ab3354461b499c423792defbe1f3a93b", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -67,8 +67,8 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                                                             PathKind::Global)])],\n                           },\n                           explicit_self: None,\n-                          args: vec![Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                                         Borrowed(None, Mutability::Mutable))],\n+                          args: vec![(Ptr(Box::new(Literal(Path::new_local(typaram))),\n+                                         Borrowed(None, Mutability::Mutable)), \"d\")],\n                           ret_ty:\n                               Literal(Path::new_(pathvec_std!(cx, result::Result),\n                                                  None,"}, {"sha": "2c6c18cc51cd7daf36067031c163ae580fc4dcc3", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -148,8 +148,8 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                     ],\n                 },\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec![Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                           Borrowed(None, Mutability::Mutable))],\n+                args: vec![(Ptr(Box::new(Literal(Path::new_local(typaram))),\n+                           Borrowed(None, Mutability::Mutable)), \"s\")],\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, result::Result),\n                     None,"}, {"sha": "1ef0d2b0b4931be33057d9148e21a769696bb846", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -252,7 +252,7 @@ pub struct MethodDef<'a> {\n     pub explicit_self: Option<Option<PtrTy<'a>>>,\n \n     /// Arguments other than the self argument\n-    pub args: Vec<Ty<'a>>,\n+    pub args: Vec<(Ty<'a>, &'a str)>,\n \n     /// Return type\n     pub ret_ty: Ty<'a>,\n@@ -915,9 +915,9 @@ impl<'a> MethodDef<'a> {\n             explicit_self\n         });\n \n-        for (i, ty) in self.args.iter().enumerate() {\n+        for (ty, name) in self.args.iter() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(&format!(\"__arg_{}\", i));\n+            let ident = cx.ident_of(name).gensym();\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -1004,10 +1004,10 @@ impl<'a> MethodDef<'a> {\n     ///\n     /// // equivalent to:\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, __arg_1: &A) -> bool {\n+    ///     fn eq(&self, other: &A) -> bool {\n     ///         match *self {\n     ///             A {x: ref __self_0_0, y: ref __self_0_1} => {\n-    ///                 match *__arg_1 {\n+    ///                 match *other {\n     ///                     A {x: ref __self_1_0, y: ref __self_1_1} => {\n     ///                         __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n     ///                     }\n@@ -1020,10 +1020,10 @@ impl<'a> MethodDef<'a> {\n     /// // or if A is repr(packed) - note fields are matched by-value\n     /// // instead of by-reference.\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, __arg_1: &A) -> bool {\n+    ///     fn eq(&self, other: &A) -> bool {\n     ///         match *self {\n     ///             A {x: __self_0_0, y: __self_0_1} => {\n-    ///                 match __arg_1 {\n+    ///                 match other {\n     ///                     A {x: __self_1_0, y: __self_1_1} => {\n     ///                         __self_0_0.eq(&__self_1_0) && __self_0_1.eq(&__self_1_1)\n     ///                     }\n@@ -1134,14 +1134,14 @@ impl<'a> MethodDef<'a> {\n     /// // is equivalent to\n     ///\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, __arg_1: &A) -> ::bool {\n-    ///         match (&*self, &*__arg_1) {\n+    ///     fn eq(&self, other: &A) -> ::bool {\n+    ///         match (&*self, &*other) {\n     ///             (&A1, &A1) => true,\n     ///             (&A2(ref self_0),\n     ///              &A2(ref __arg_1_0)) => (*self_0).eq(&(*__arg_1_0)),\n     ///             _ => {\n     ///                 let __self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n-    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0, A2(..) => 1 };\n+    ///                 let __arg_1_vi = match *other { A1(..) => 0, A2(..) => 1 };\n     ///                 false\n     ///             }\n     ///         }\n@@ -1240,7 +1240,7 @@ impl<'a> MethodDef<'a> {\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                cx.ident_of(&vi_suffix[..])\n+                cx.ident_of(&vi_suffix[..]).gensym()\n             })\n             .collect::<Vec<ast::Ident>>();\n \n@@ -1616,7 +1616,7 @@ impl<'a> TraitDef<'a> {\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n+            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i)).gensym();\n             paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries {"}, {"sha": "67096cdb49a3c5da2d589f47c4978b8a12a9cc3d", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -44,8 +44,8 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                               bounds: vec![(typaram, vec![path_std!(cx, hash::Hasher)])],\n                           },\n                           explicit_self: borrowed_explicit_self(),\n-                          args: vec![Ptr(Box::new(Literal(arg)),\n-                                         Borrowed(None, Mutability::Mutable))],\n+                          args: vec![(Ptr(Box::new(Literal(arg)),\n+                                         Borrowed(None, Mutability::Mutable)), \"state\")],\n                           ret_ty: nil_ty(),\n                           attributes: vec![],\n                           is_unsafe: false,"}, {"sha": "6b155b6596d08c80cd50d1e09564ceba91ac2aa1", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -543,6 +543,10 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n+        let names_pos: Vec<_> = (0..self.args.len()).map(|i| {\n+            self.ecx.ident_of(&format!(\"arg{}\", i)).gensym()\n+        }).collect();\n+\n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n         let pieces = self.ecx.expr_vec_slice(self.fmtsp, self.str_pieces);\n@@ -560,7 +564,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n-            let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n+            let name = names_pos[i];\n             let span =\n                 DUMMY_SP.with_ctxt(e.span.ctxt().apply_mark(self.ecx.current_expansion.mark));\n             pats.push(self.ecx.pat_ident(span, name));\n@@ -570,14 +574,12 @@ impl<'a, 'b> Context<'a, 'b> {\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n         for pos in self.count_args {\n-            let name = self.ecx.ident_of(&match pos {\n-                Exact(i) => format!(\"__arg{}\", i),\n-                _ => panic!(\"should never happen\"),\n-            });\n-            let span = match pos {\n-                Exact(i) => spans_pos[i],\n+            let index = match pos {\n+                Exact(i) => i,\n                 _ => panic!(\"should never happen\"),\n             };\n+            let name = names_pos[index];\n+            let span = spans_pos[index];\n             counts.push(Context::format_arg(self.ecx, self.macsp, span, &Count, name));\n         }\n "}, {"sha": "556ee162c6ef2974dfc51fe5ef1caf2e98059088", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -53,6 +53,10 @@ impl Ident {\n     pub fn modern(self) -> Ident {\n         Ident::new(self.name, self.span.modern())\n     }\n+\n+    pub fn gensym(self) -> Ident {\n+        Ident::new(self.name.gensymed(), self.span)\n+    }\n }\n \n impl PartialEq for Ident {"}, {"sha": "6d5e82c68cc8ed883c27e7d8bc504e2c681344d8", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -58,7 +58,7 @@ fn expand_deriving_partial_eq(cx: &mut ExtCtxt, span: Span, mitem: &MetaItem, it\n         name: \"eq\",\n         generics: LifetimeBounds::empty(),\n         explicit_self: borrowed_explicit_self(),\n-        args: vec![borrowed_self()],\n+        args: vec![(borrowed_self(), \"other\")],\n         ret_ty: Literal(deriving::generic::ty::Path::new_local(\"bool\")),\n         attributes: attrs,\n         is_unsafe: false,"}, {"sha": "532f2456599763b4fd897f2ee7b746af108ab02b", "filename": "src/test/run-pass-fulldeps/deriving-hygiene.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Ftest%2Frun-pass-fulldeps%2Fderiving-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Ftest%2Frun-pass-fulldeps%2Fderiving-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fderiving-hygiene.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+extern crate serialize;\n+\n+pub const other: u8 = 1;\n+pub const f: u8 = 1;\n+pub const d: u8 = 1;\n+pub const s: u8 = 1;\n+pub const state: u8 = 1;\n+pub const cmp: u8 = 1;\n+\n+#[derive(Ord,Eq,PartialOrd,PartialEq,Debug,Decodable,Encodable,Hash)]\n+struct Foo {}\n+\n+fn main() {\n+}"}, {"sha": "6971f775231d5f7179bff9ea971a10e59fe748ee", "filename": "src/test/run-pass/format-hygiene.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Ftest%2Frun-pass%2Fformat-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5740feb24bff4f13b68b565288dd8a42ab93f6/src%2Ftest%2Frun-pass%2Fformat-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fformat-hygiene.rs?ref=0c5740feb24bff4f13b68b565288dd8a42ab93f6", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub const arg0: u8 = 1;\n+\n+pub fn main() {\n+    format!(\"{}\", 1);\n+}"}]}