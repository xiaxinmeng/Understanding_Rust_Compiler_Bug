{"sha": "1279b3b9232e4c44112d98f19cfa8846776d1fe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNzliM2I5MjMyZTRjNDQxMTJkOThmMTljZmE4ODQ2Nzc2ZDFmZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-23T21:13:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-23T21:13:14Z"}, "message": "Auto merge of #81304 - jonas-schievink:rollup-d9kuugm, r=jonas-schievink\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #79841 (More clear documentation for NonNull<T>)\n - #81072 (PlaceRef::ty: use method call syntax)\n - #81130 (Edit rustc_middle::dep_graph module documentation)\n - #81170 (Avoid hash_slice in VecDeque's Hash implementation)\n - #81243 (mir: Improve size_of handling when arg is unsized)\n - #81245 (Update cargo)\n - #81249 (Lower closure prototype after its body.)\n - #81252 (Add more self-profile info to rustc_resolve)\n - #81275 (Fix <unknown> queries and add more timing info to render_html)\n - #81281 (Inline methods of Path and OsString)\n - #81283 (Note library tracking issue template in tracking issue template.)\n - #81285 (Remove special casing of rustdoc in rustc_lint)\n - #81288 (rustdoc: Fix visibility of trait and impl items)\n - #81298 (replace RefCell with Cell in FnCtxt)\n - #81301 (Fix small typo)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2656f7f38ceb24cc242b3f814288924f8e9bc7ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2656f7f38ceb24cc242b3f814288924f8e9bc7ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1279b3b9232e4c44112d98f19cfa8846776d1fe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1279b3b9232e4c44112d98f19cfa8846776d1fe8", "html_url": "https://github.com/rust-lang/rust/commit/1279b3b9232e4c44112d98f19cfa8846776d1fe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1279b3b9232e4c44112d98f19cfa8846776d1fe8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d0dd02ee07bddad9136f95c9f7846ebf3eb3fc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d0dd02ee07bddad9136f95c9f7846ebf3eb3fc5", "html_url": "https://github.com/rust-lang/rust/commit/4d0dd02ee07bddad9136f95c9f7846ebf3eb3fc5"}, {"sha": "ebeb6b8b26f78c2c1a412a2e0e65e2e1f5ebc111", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebeb6b8b26f78c2c1a412a2e0e65e2e1f5ebc111", "html_url": "https://github.com/rust-lang/rust/commit/ebeb6b8b26f78c2c1a412a2e0e65e2e1f5ebc111"}], "stats": {"total": 546, "additions": 434, "deletions": 112}, "files": [{"sha": "00659605071790ce71e955132ea52dc488569fb9", "filename": ".github/ISSUE_TEMPLATE/tracking_issue.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -5,6 +5,8 @@ title: Tracking Issue for XXX\n labels: C-tracking-issue\n ---\n <!--\n+NOTE: For library features, please use the \"Library Tracking Issue\" template instead.\n+\n Thank you for creating a tracking issue! \ud83d\udcdc Tracking issues are for tracking a\n feature from implementation to stabilisation. Make sure to include the relevant\n RFC for the feature if it has one. Otherwise provide a short summary of the"}, {"sha": "afcff1bfb0607a0f2a70fd43f1ec0a777baebb2b", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -427,6 +427,7 @@ dependencies = [\n  \"remove_dir_all\",\n  \"serde_json\",\n  \"tar\",\n+ \"toml\",\n  \"url 2.1.1\",\n ]\n "}, {"sha": "4d6afd2fe0d089ffcf3f375857352d0a23a26e03", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -776,10 +776,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Expr,\n         fn_decl_span: Span,\n     ) -> hir::ExprKind<'hir> {\n-        // Lower outside new scope to preserve `is_in_loop_condition`.\n-        let fn_decl = self.lower_fn_decl(decl, None, false, None);\n-\n-        self.with_new_scopes(move |this| {\n+        let (body_id, generator_option) = self.with_new_scopes(move |this| {\n             let prev = this.current_item;\n             this.current_item = Some(fn_decl_span);\n             let mut generator_kind = None;\n@@ -791,8 +788,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let generator_option =\n                 this.generator_movability_for_fn(&decl, fn_decl_span, generator_kind, movability);\n             this.current_item = prev;\n-            hir::ExprKind::Closure(capture_clause, fn_decl, body_id, fn_decl_span, generator_option)\n-        })\n+            (body_id, generator_option)\n+        });\n+\n+        // Lower outside new scope to preserve `is_in_loop_condition`.\n+        let fn_decl = self.lower_fn_decl(decl, None, false, None);\n+\n+        hir::ExprKind::Closure(capture_clause, fn_decl, body_id, fn_decl_span, generator_option)\n     }\n \n     fn generator_movability_for_fn(\n@@ -838,12 +840,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         let outer_decl =\n             FnDecl { inputs: decl.inputs.clone(), output: FnRetTy::Default(fn_decl_span) };\n-        // We need to lower the declaration outside the new scope, because we\n-        // have to conserve the state of being inside a loop condition for the\n-        // closure argument types.\n-        let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n \n-        self.with_new_scopes(move |this| {\n+        let body_id = self.with_new_scopes(|this| {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n             if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n                 struct_span_err!(\n@@ -874,8 +872,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 this.expr(fn_decl_span, async_body, ThinVec::new())\n             });\n-            hir::ExprKind::Closure(capture_clause, fn_decl, body_id, fn_decl_span, None)\n-        })\n+            body_id\n+        });\n+\n+        // We need to lower the declaration outside the new scope, because we\n+        // have to conserve the state of being inside a loop condition for the\n+        // closure argument types.\n+        let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n+\n+        hir::ExprKind::Closure(capture_clause, fn_decl, body_id, fn_decl_span, None)\n     }\n \n     /// Destructure the LHS of complex assignments."}, {"sha": "fd0ff5b66e6070d3aea2d1f9743c6a7ea131a0cc", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -119,7 +119,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 )\n             );\n             if is_consume {\n-                let base_ty = mir::PlaceRef::ty(&place_base, self.fx.mir, cx.tcx());\n+                let base_ty = place_base.ty(self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(base_ty);\n \n                 // ZSTs don't require any actual memory access."}, {"sha": "66d9d1a1e0c490ef2237a25e1602c92f8ceda921", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -506,7 +506,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::PlaceRef::ty(&place_ref, self.mir, tcx);\n+        let place_ty = place_ref.ty(self.mir, tcx);\n         self.monomorphize(place_ty.ty)\n     }\n }"}, {"sha": "7031234e1089d15fb3c93514cac93b1115f89bc0", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -1017,13 +1017,6 @@ pub fn start_codegen<'tcx>(\n     tcx.sess.time(\"assert_dep_graph\", || rustc_incremental::assert_dep_graph(tcx));\n     tcx.sess.time(\"serialize_dep_graph\", || rustc_incremental::save_dep_graph(tcx));\n \n-    // We assume that no queries are run past here. If there are new queries\n-    // after this point, they'll show up as \"<unknown>\" in self-profiling data.\n-    {\n-        let _prof_timer = tcx.prof.generic_activity(\"self_profile_alloc_query_strings\");\n-        tcx.alloc_self_profile_query_strings();\n-    }\n-\n     info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {"}, {"sha": "ac6b6d0311545a45f9087471eb6a7b8aca5f56f1", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -417,9 +417,19 @@ impl Compiler {\n         let queries = Queries::new(&self);\n         let ret = f(&queries);\n \n-        if self.session().opts.debugging_opts.query_stats {\n-            if let Ok(gcx) = queries.global_ctxt() {\n-                gcx.peek_mut().print_stats();\n+        // NOTE: intentionally does not compute the global context if it hasn't been built yet,\n+        // since that likely means there was a parse error.\n+        if let Some(Ok(gcx)) = &mut *queries.global_ctxt.result.borrow_mut() {\n+            // We assume that no queries are run past here. If there are new queries\n+            // after this point, they'll show up as \"<unknown>\" in self-profiling data.\n+            {\n+                let _prof_timer =\n+                    queries.session().prof.generic_activity(\"self_profile_alloc_query_strings\");\n+                gcx.enter(|tcx| tcx.alloc_self_profile_query_strings());\n+            }\n+\n+            if self.session().opts.debugging_opts.query_stats {\n+                gcx.print_stats();\n             }\n         }\n "}, {"sha": "e36af2349360f5ab90ac32bc4271de8f77e91309", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -379,17 +379,9 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n     // All of the buffered lints should have been emitted at this point.\n     // If not, that means that we somehow buffered a lint for a node id\n     // that was not lint-checked (perhaps it doesn't exist?). This is a bug.\n-    //\n-    // Rustdoc runs everybody-loops before the early lints and removes\n-    // function bodies, so it's totally possible for linted\n-    // node ids to not exist (e.g., macros defined within functions for the\n-    // unused_macro lint) anymore. So we only run this check\n-    // when we're not in rustdoc mode. (see issue #47639)\n-    if !sess.opts.actually_rustdoc {\n-        for (_id, lints) in buffered.map {\n-            for early_lint in lints {\n-                sess.delay_span_bug(early_lint.span, \"failed to process buffered lint here\");\n-            }\n+    for (_id, lints) in buffered.map {\n+        for early_lint in lints {\n+            sess.delay_span_bug(early_lint.span, \"failed to process buffered lint here\");\n         }\n     }\n }"}, {"sha": "1cb75757379c99b9ddfb1daeab2dc7fa37c1d36c", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -1,16 +1,17 @@\n-//! This module defines the `DepNode` type which the compiler uses to represent\n-//! nodes in the dependency graph.\n+//! Nodes in the dependency graph.\n //!\n-//! A `DepNode` consists of a `DepKind` (which\n-//! specifies the kind of thing it represents, like a piece of HIR, MIR, etc)\n-//! and a `Fingerprint`, a 128-bit hash value the exact meaning of which\n+//! A node in the [dependency graph] is represented by a [`DepNode`].\n+//! A `DepNode` consists of a [`DepKind`] (which\n+//! specifies the kind of thing it represents, like a piece of HIR, MIR, etc.)\n+//! and a [`Fingerprint`], a 128-bit hash value, the exact meaning of which\n //! depends on the node's `DepKind`. Together, the kind and the fingerprint\n //! fully identify a dependency node, even across multiple compilation sessions.\n //! In other words, the value of the fingerprint does not depend on anything\n //! that is specific to a given compilation session, like an unpredictable\n-//! interning key (e.g., NodeId, DefId, Symbol) or the numeric value of a\n+//! interning key (e.g., `NodeId`, `DefId`, `Symbol`) or the numeric value of a\n //! pointer. The concept behind this could be compared to how git commit hashes\n-//! uniquely identify a given commit and has a few advantages:\n+//! uniquely identify a given commit. The fingerprinting approach has\n+//! a few advantages:\n //!\n //! * A `DepNode` can simply be serialized to disk and loaded in another session\n //!   without the need to do any \"rebasing\" (like we have to do for Spans and\n@@ -51,6 +52,8 @@\n //! than a zeroed out fingerprint. More generally speaking, it relieves the\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n+//!\n+//! [dependency graph]: https://rustc-dev-guide.rust-lang.org/query.html\n \n use crate::ty::TyCtxt;\n "}, {"sha": "cf931ece712b0acd8e217d4463804624f0e0d84b", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -127,6 +127,8 @@ pub enum InvalidProgramInfo<'tcx> {\n     Layout(layout::LayoutError<'tcx>),\n     /// An invalid transmute happened.\n     TransmuteSizeDiff(Ty<'tcx>, Ty<'tcx>),\n+    /// SizeOf of unsized type was requested.\n+    SizeOfUnsizedType(Ty<'tcx>),\n }\n \n impl fmt::Display for InvalidProgramInfo<'_> {\n@@ -144,6 +146,7 @@ impl fmt::Display for InvalidProgramInfo<'_> {\n                 \"transmuting `{}` to `{}` is not possible, because these types do not have the same size\",\n                 from_ty, to_ty\n             ),\n+            SizeOfUnsizedType(ty) => write!(f, \"size_of called on unsized type `{}`\", ty),\n         }\n     }\n }"}, {"sha": "cd16a88e5fc3c7d16dc79949b60f564489f553f7", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -289,7 +289,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            let ty = PlaceRef::ty(&used_place, self.body, self.infcx.tcx).ty;\n+            let ty = used_place.ty(self.body, self.infcx.tcx).ty;\n             let needs_note = match ty.kind() {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck(id.expect_local());\n@@ -728,6 +728,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n         let union_ty = |place_base| {\n+            // Need to use fn call syntax `PlaceRef::ty` to determine the type of `place_base`;\n+            // using a type annotation in the closure argument instead leads to a lifetime error.\n             let ty = PlaceRef::ty(&place_base, self.body, self.infcx.tcx).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };"}, {"sha": "7c7edfdb5fbaf5cb4cfe6cce3a57ff9f2e267ee4", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -1743,7 +1743,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some((place_base, ProjectionElem::Subslice { from, to, from_end: false })) =\n             place_span.0.last_projection()\n         {\n-            let place_ty = PlaceRef::ty(&place_base, self.body(), self.infcx.tcx);\n+            let place_ty = place_base.ty(self.body(), self.infcx.tcx);\n             if let ty::Array(..) = place_ty.ty.kind() {\n                 self.check_if_subslice_element_is_moved(\n                     location,\n@@ -1854,7 +1854,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = PlaceRef::ty(&place_base, self.body(), tcx).ty;\n+                    let base_ty = place_base.ty(self.body(), tcx).ty;\n                     match base_ty.kind() {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n@@ -1951,7 +1951,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::Adt(def, _) = PlaceRef::ty(&base, this.body(), tcx).ty.kind() {\n+                if let ty::Adt(def, _) = base.ty(this.body(), tcx).ty.kind() {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(location, this.body)\n@@ -2173,7 +2173,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Some((place_base, elem)) => {\n                 match elem {\n                     ProjectionElem::Deref => {\n-                        let base_ty = PlaceRef::ty(&place_base, self.body(), self.infcx.tcx).ty;\n+                        let base_ty = place_base.ty(self.body(), self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.kind() {"}, {"sha": "bdf2becb711264eff522a8cbe962ea5db3888cc1", "filename": "compiler/rustc_mir/src/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -117,7 +117,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = PlaceRef::ty(&cursor_base, self.body, self.tcx).ty;\n+                    let ty = cursor_base.ty(self.body, self.tcx).ty;\n                     match ty.kind() {\n                         ty::RawPtr(_) | ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Not) => {\n                             // don't continue traversing over derefs of raw pointers or shared"}, {"sha": "fbc72ad8adc9656c3fbf2f51d7888fab76ceecc0", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -270,6 +270,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         self.frame().current_span(),\n                         &format!(\"SizeOf nullary MIR operator called for unsized type {}\", ty),\n                     );\n+                    throw_inval!(SizeOfUnsizedType(ty));\n                 }\n                 self.write_scalar(Scalar::from_machine_usize(layout.size.bytes(), self), dest)?;\n             }"}, {"sha": "2b4a1d9e3fa0a45a0ed676d9892a38e794bbcd9d", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -1465,16 +1465,14 @@ impl<'a> Resolver<'a> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n-        let _prof_timer = self.session.prof.generic_activity(\"resolve_crate\");\n-\n-        ImportResolver { r: self }.finalize_imports();\n-        self.finalize_macro_resolutions();\n-\n-        self.late_resolve_crate(krate);\n-\n-        self.check_unused(krate);\n-        self.report_errors(krate);\n-        self.crate_loader.postprocess(krate);\n+        self.session.time(\"resolve_crate\", || {\n+            self.session.time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n+            self.session.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n+            self.session.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));\n+            self.session.time(\"resolve_check_unused\", || self.check_unused(krate));\n+            self.session.time(\"resolve_report_errors\", || self.report_errors(krate));\n+            self.session.time(\"resolve_postprocess\", || self.crate_loader.postprocess(krate));\n+        });\n     }\n \n     pub fn traits_in_scope("}, {"sha": "ab3c26fac8338a03ba0c707780a64def2018f38d", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -66,7 +66,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n-    *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n+    fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n \n     let tcx = fcx.tcx;\n     let sess = tcx.sess;"}, {"sha": "b2395b7bb2502d3da006cca7e8ab4c68b6e4a45c", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -1472,22 +1472,22 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 fn_output = Some(&fn_decl.output); // `impl Trait` return type\n             }\n         }\n-        if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.borrow().as_ref(), fn_output) {\n-            self.add_impl_trait_explanation(&mut err, cause, fcx, expected, *sp, fn_output);\n+        if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.get(), fn_output) {\n+            self.add_impl_trait_explanation(&mut err, cause, fcx, expected, sp, fn_output);\n         }\n \n-        if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n+        if let Some(sp) = fcx.ret_coercion_span.get() {\n             // If the closure has an explicit return type annotation,\n             // then a type error may occur at the first return expression we\n             // see in the closure (if it conflicts with the declared\n             // return type). Skip adding a note in this case, since it\n             // would be incorrect.\n-            if !err.span.primary_spans().iter().any(|span| span == sp) {\n+            if !err.span.primary_spans().iter().any(|&span| span == sp) {\n                 let hir = fcx.tcx.hir();\n                 let body_owner = hir.body_owned_by(hir.enclosing_body_owner(fcx.body_id));\n                 if fcx.tcx.is_closure(hir.body_owner_def_id(body_owner).to_def_id()) {\n                     err.span_note(\n-                        *sp,\n+                        sp,\n                         &format!(\n                             \"return type inferred to be `{}` here\",\n                             fcx.resolve_vars_if_possible(expected)"}, {"sha": "e37b4ff742bc62ab715e60774a4180fc92f191dc", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -680,14 +680,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if self.ret_coercion.is_none() {\n             self.tcx.sess.emit_err(ReturnStmtOutsideOfFnBody { span: expr.span });\n         } else if let Some(ref e) = expr_opt {\n-            if self.ret_coercion_span.borrow().is_none() {\n-                *self.ret_coercion_span.borrow_mut() = Some(e.span);\n+            if self.ret_coercion_span.get().is_none() {\n+                self.ret_coercion_span.set(Some(e.span));\n             }\n             self.check_return_expr(e);\n         } else {\n             let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n-            if self.ret_coercion_span.borrow().is_none() {\n-                *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n+            if self.ret_coercion_span.get().is_none() {\n+                self.ret_coercion_span.set(Some(expr.span));\n             }\n             let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n             if let Some((fn_decl, _)) = self.get_fn_decl(expr.hir_id) {"}, {"sha": "fb6f9c03352b43d83e69e9c99381d1be746d08a9", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -23,7 +23,6 @@ use rustc_span::{self, MultiSpan, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpression};\n \n use crate::structured_errors::StructuredDiagnostic;\n-use std::mem::replace;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -589,11 +588,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         blk: &'tcx hir::Block<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        let prev = {\n-            let mut fcx_ps = self.ps.borrow_mut();\n-            let unsafety_state = fcx_ps.recurse(blk);\n-            replace(&mut *fcx_ps, unsafety_state)\n-        };\n+        let prev = self.ps.replace(self.ps.get().recurse(blk));\n \n         // In some cases, blocks have just one exit, but other blocks\n         // can be targeted by multiple breaks. This can happen both\n@@ -709,7 +704,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.write_ty(blk.hir_id, ty);\n \n-        *self.ps.borrow_mut() = prev;\n+        self.ps.set(prev);\n         ty\n     }\n "}, {"sha": "e9223f700dcc722c0e78f0f943721940d69ef8f4", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -66,11 +66,11 @@ pub struct FnCtxt<'a, 'tcx> {\n     pub(super) in_tail_expr: bool,\n \n     /// First span of a return site that we find. Used in error messages.\n-    pub(super) ret_coercion_span: RefCell<Option<Span>>,\n+    pub(super) ret_coercion_span: Cell<Option<Span>>,\n \n     pub(super) resume_yield_tys: Option<(Ty<'tcx>, Ty<'tcx>)>,\n \n-    pub(super) ps: RefCell<UnsafetyState>,\n+    pub(super) ps: Cell<UnsafetyState>,\n \n     /// Whether the last checked node generates a divergence (e.g.,\n     /// `return` will set this to `Always`). In general, when entering\n@@ -127,9 +127,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ret_coercion_impl_trait: None,\n             ret_type_span: None,\n             in_tail_expr: false,\n-            ret_coercion_span: RefCell::new(None),\n+            ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,\n-            ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n+            ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             has_errors: Cell::new(false),\n             enclosing_breakables: RefCell::new(EnclosingBreakables {"}, {"sha": "c8c6fa12fae08c58959c43edf9fac9fec8623ae9", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -184,14 +184,14 @@ impl UnsafetyState {\n         UnsafetyState { def, unsafety, unsafe_push_count: 0, from_fn: true }\n     }\n \n-    pub fn recurse(&mut self, blk: &hir::Block<'_>) -> UnsafetyState {\n+    pub fn recurse(self, blk: &hir::Block<'_>) -> UnsafetyState {\n         use hir::BlockCheckMode;\n         match self.unsafety {\n             // If this unsafe, then if the outer function was already marked as\n             // unsafe we shouldn't attribute the unsafe'ness to the block. This\n             // way the block can be warned about instead of ignoring this\n             // extraneous block (functions are never warned about).\n-            hir::Unsafety::Unsafe if self.from_fn => *self,\n+            hir::Unsafety::Unsafe if self.from_fn => self,\n \n             unsafety => {\n                 let (unsafety, def, count) = match blk.rules {"}, {"sha": "6f9133e2811bf18c8c261941b190fdf652b530a0", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -2646,9 +2646,13 @@ impl<A: Ord> Ord for VecDeque<A> {\n impl<A: Hash> Hash for VecDeque<A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);\n-        let (a, b) = self.as_slices();\n-        Hash::hash_slice(a, state);\n-        Hash::hash_slice(b, state);\n+        // It's not possible to use Hash::hash_slice on slices\n+        // returned by as_slices method as their length can vary\n+        // in otherwise identical deques.\n+        //\n+        // Hasher only guarantees equivalence for the exact same\n+        // set of calls to its methods.\n+        self.iter().for_each(|elem| elem.hash(state));\n     }\n }\n "}, {"sha": "87e06fa394d38baef06c904aae9cbd968b5bcabe", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -599,3 +599,43 @@ fn issue_53529() {\n         assert_eq!(*a, 2);\n     }\n }\n+\n+#[test]\n+fn issue_80303() {\n+    use core::iter;\n+    use core::num::Wrapping;\n+\n+    // This is a valid, albeit rather bad hash function implementation.\n+    struct SimpleHasher(Wrapping<u64>);\n+\n+    impl Hasher for SimpleHasher {\n+        fn finish(&self) -> u64 {\n+            self.0.0\n+        }\n+\n+        fn write(&mut self, bytes: &[u8]) {\n+            // This particular implementation hashes value 24 in addition to bytes.\n+            // Such an implementation is valid as Hasher only guarantees equivalence\n+            // for the exact same set of calls to its methods.\n+            for &v in iter::once(&24).chain(bytes) {\n+                self.0 = Wrapping(31) * self.0 + Wrapping(u64::from(v));\n+            }\n+        }\n+    }\n+\n+    fn hash_code(value: impl Hash) -> u64 {\n+        let mut hasher = SimpleHasher(Wrapping(1));\n+        value.hash(&mut hasher);\n+        hasher.finish()\n+    }\n+\n+    // This creates two deques for which values returned by as_slices\n+    // method differ.\n+    let vda: VecDeque<u8> = (0..10).collect();\n+    let mut vdb = VecDeque::with_capacity(10);\n+    vdb.extend(5..10);\n+    (0..5).rev().for_each(|elem| vdb.push_front(elem));\n+    assert_ne!(vda.as_slices(), vdb.as_slices());\n+    assert_eq!(vda, vdb);\n+    assert_eq!(hash_code(vda), hash_code(vdb));\n+}"}, {"sha": "91c61f814e1a81a5bf3a042c49c7893ff4f301dd", "filename": "library/core/src/num/dec2flt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -3,7 +3,7 @@\n //! # Problem statement\n //!\n //! We are given a decimal string such as `12.34e56`. This string consists of integral (`12`),\n-//! fractional (`45`), and exponent (`56`) parts. All parts are optional and interpreted as zero\n+//! fractional (`34`), and exponent (`56`) parts. All parts are optional and interpreted as zero\n //! when missing.\n //!\n //! We seek the IEEE 754 floating point number that is closest to the exact value of the decimal"}, {"sha": "e45fefc7ed7657f1c3e0f949d97ed58a46f626ce", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -19,12 +19,19 @@ use crate::slice::{self, SliceIndex};\n /// as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.\n /// However the pointer may still dangle if it isn't dereferenced.\n ///\n-/// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n-/// for your use case, you should include some [`PhantomData`] in your type to\n-/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n-/// Usually this won't be necessary; covariance is correct for most safe abstractions,\n-/// such as `Box`, `Rc`, `Arc`, `Vec`, and `LinkedList`. This is the case because they\n-/// provide a public API that follows the normal shared XOR mutable rules of Rust.\n+/// Unlike `*mut T`, `NonNull<T>` was chosen to be covariant over `T`. This makes it\n+/// possible to use `NonNull<T>` when building covariant types, but introduces the\n+/// risk of unsoundness if used in a type that shouldn't actually be covariant.\n+/// (The opposite choice was made for `*mut T` even though technically the unsoundness\n+/// could only be caused by calling unsafe functions.)\n+///\n+/// Covariance is correct for most safe abstractions, such as `Box`, `Rc`, `Arc`, `Vec`,\n+/// and `LinkedList`. This is the case because they provide a public API that follows the\n+/// normal shared XOR mutable rules of Rust.\n+///\n+/// If your type cannot safely be covariant, you must ensure it contains some\n+/// additional field to provide invariance. Often this field will be a [`PhantomData`]\n+/// type like `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n ///\n /// Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n /// not change the fact that mutating through a (pointer derived from a) shared"}, {"sha": "32f0f8a52f820cb0c7e710db8ec385af58abbfd3", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -111,6 +111,7 @@ impl OsString {\n     /// let os_string = OsString::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn new() -> OsString {\n         OsString { inner: Buf::from_string(String::new()) }\n     }\n@@ -127,6 +128,7 @@ impl OsString {\n     /// assert_eq!(os_string.as_os_str(), os_str);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_os_str(&self) -> &OsStr {\n         self\n     }\n@@ -145,6 +147,7 @@ impl OsString {\n     /// assert_eq!(string, Ok(String::from(\"foo\")));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn into_string(self) -> Result<String, OsString> {\n         self.inner.into_string().map_err(|buf| OsString { inner: buf })\n     }\n@@ -163,6 +166,7 @@ impl OsString {\n     /// assert_eq!(&os_string, \"foobar\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n         self.inner.push_slice(&s.as_ref().inner)\n     }\n@@ -189,6 +193,7 @@ impl OsString {\n     /// assert_eq!(capacity, os_string.capacity());\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn with_capacity(capacity: usize) -> OsString {\n         OsString { inner: Buf::with_capacity(capacity) }\n     }\n@@ -207,6 +212,7 @@ impl OsString {\n     /// assert_eq!(&os_string, \"\");\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn clear(&mut self) {\n         self.inner.clear()\n     }\n@@ -224,6 +230,7 @@ impl OsString {\n     /// assert!(os_string.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn capacity(&self) -> usize {\n         self.inner.capacity()\n     }\n@@ -243,6 +250,7 @@ impl OsString {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn reserve(&mut self, additional: usize) {\n         self.inner.reserve(additional)\n     }\n@@ -265,6 +273,7 @@ impl OsString {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.inner.reserve_exact(additional)\n     }\n@@ -285,6 +294,7 @@ impl OsString {\n     /// assert_eq!(3, s.capacity());\n     /// ```\n     #[stable(feature = \"osstring_shrink_to_fit\", since = \"1.19.0\")]\n+    #[inline]\n     pub fn shrink_to_fit(&mut self) {\n         self.inner.shrink_to_fit()\n     }\n@@ -342,6 +352,7 @@ impl From<String> for OsString {\n     /// Converts a [`String`] into a [`OsString`].\n     ///\n     /// The conversion copies the data, and includes an allocation on the heap.\n+    #[inline]\n     fn from(s: String) -> OsString {\n         OsString { inner: Buf::from_string(s) }\n     }\n@@ -408,34 +419,39 @@ impl fmt::Debug for OsString {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for OsString {\n+    #[inline]\n     fn eq(&self, other: &OsString) -> bool {\n         &**self == &**other\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq<str> for OsString {\n+    #[inline]\n     fn eq(&self, other: &str) -> bool {\n         &**self == other\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq<OsString> for str {\n+    #[inline]\n     fn eq(&self, other: &OsString) -> bool {\n         &**other == self\n     }\n }\n \n #[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\n impl PartialEq<&str> for OsString {\n+    #[inline]\n     fn eq(&self, other: &&str) -> bool {\n         **self == **other\n     }\n }\n \n #[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\n impl<'a> PartialEq<OsString> for &'a str {\n+    #[inline]\n     fn eq(&self, other: &OsString) -> bool {\n         **other == **self\n     }\n@@ -539,6 +555,7 @@ impl OsStr {\n     /// assert_eq!(os_str.to_str(), Some(\"foo\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n     }\n@@ -589,6 +606,7 @@ impl OsStr {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_string_lossy(&self) -> Cow<'_, str> {\n         self.inner.to_string_lossy()\n     }\n@@ -605,6 +623,7 @@ impl OsStr {\n     /// assert_eq!(os_string, OsString::from(\"foo\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_os_string(&self) -> OsString {\n         OsString { inner: self.inner.to_owned() }\n     }\n@@ -655,6 +674,7 @@ impl OsStr {\n     /// ```\n     #[doc(alias = \"length\")]\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn len(&self) -> usize {\n         self.inner.inner.len()\n     }\n@@ -696,6 +716,7 @@ impl OsStr {\n     /// assert_eq!(\"gr\u00dc\u00dfe, j\u00dcrgen \u2764\", s);\n     /// ```\n     #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[inline]\n     pub fn make_ascii_lowercase(&mut self) {\n         self.inner.make_ascii_lowercase()\n     }\n@@ -721,6 +742,7 @@ impl OsStr {\n     /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s);\n     /// ```\n     #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[inline]\n     pub fn make_ascii_uppercase(&mut self) {\n         self.inner.make_ascii_uppercase()\n     }\n@@ -784,6 +806,7 @@ impl OsStr {\n     /// assert!(!non_ascii.is_ascii());\n     /// ```\n     #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[inline]\n     pub fn is_ascii(&self) -> bool {\n         self.inner.is_ascii()\n     }\n@@ -811,6 +834,7 @@ impl OsStr {\n \n #[stable(feature = \"box_from_os_str\", since = \"1.17.0\")]\n impl From<&OsStr> for Box<OsStr> {\n+    #[inline]\n     fn from(s: &OsStr) -> Box<OsStr> {\n         let rw = Box::into_raw(s.inner.into_box()) as *mut OsStr;\n         unsafe { Box::from_raw(rw) }\n@@ -832,6 +856,7 @@ impl From<Cow<'_, OsStr>> for Box<OsStr> {\n impl From<Box<OsStr>> for OsString {\n     /// Converts a [`Box`]`<`[`OsStr`]`>` into a `OsString` without copying or\n     /// allocating.\n+    #[inline]\n     fn from(boxed: Box<OsStr>) -> OsString {\n         boxed.into_os_string()\n     }\n@@ -840,6 +865,7 @@ impl From<Box<OsStr>> for OsString {\n #[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n impl From<OsString> for Box<OsStr> {\n     /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n+    #[inline]\n     fn from(s: OsString) -> Box<OsStr> {\n         s.into_boxed_os_str()\n     }\n@@ -925,6 +951,7 @@ impl<'a> From<Cow<'a, OsStr>> for OsString {\n \n #[stable(feature = \"box_default_extra\", since = \"1.17.0\")]\n impl Default for Box<OsStr> {\n+    #[inline]\n     fn default() -> Box<OsStr> {\n         let rw = Box::into_raw(Slice::empty_box()) as *mut OsStr;\n         unsafe { Box::from_raw(rw) }\n@@ -1075,6 +1102,7 @@ impl OsStr {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<OsStr> for OsString {\n+    #[inline]\n     fn borrow(&self) -> &OsStr {\n         &self[..]\n     }\n@@ -1083,16 +1111,19 @@ impl Borrow<OsStr> for OsString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for OsStr {\n     type Owned = OsString;\n+    #[inline]\n     fn to_owned(&self) -> OsString {\n         self.to_os_string()\n     }\n+    #[inline]\n     fn clone_into(&self, target: &mut OsString) {\n         self.inner.clone_into(&mut target.inner)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for OsStr {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         self\n     }\n@@ -1123,12 +1154,14 @@ impl AsRef<OsStr> for String {\n }\n \n impl FromInner<Buf> for OsString {\n+    #[inline]\n     fn from_inner(buf: Buf) -> OsString {\n         OsString { inner: buf }\n     }\n }\n \n impl IntoInner<Buf> for OsString {\n+    #[inline]\n     fn into_inner(self) -> Buf {\n         self.inner\n     }\n@@ -1145,6 +1178,7 @@ impl AsInner<Slice> for OsStr {\n impl FromStr for OsString {\n     type Err = core::convert::Infallible;\n \n+    #[inline]\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         Ok(OsString::from(s))\n     }"}, {"sha": "1889e549338676dcbed5b8faeac53538f2e05aec", "filename": "library/std/src/path.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -401,33 +401,38 @@ impl<'a> PrefixComponent<'a> {\n     /// See [`Prefix`]'s documentation for more information on the different\n     /// kinds of prefixes.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn kind(&self) -> Prefix<'a> {\n         self.parsed\n     }\n \n     /// Returns the raw [`OsStr`] slice for this prefix.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_os_str(&self) -> &'a OsStr {\n         self.raw\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialEq for PrefixComponent<'a> {\n+    #[inline]\n     fn eq(&self, other: &PrefixComponent<'a>) -> bool {\n         cmp::PartialEq::eq(&self.parsed, &other.parsed)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialOrd for PrefixComponent<'a> {\n+    #[inline]\n     fn partial_cmp(&self, other: &PrefixComponent<'a>) -> Option<cmp::Ordering> {\n         cmp::PartialOrd::partial_cmp(&self.parsed, &other.parsed)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for PrefixComponent<'_> {\n+    #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n         cmp::Ord::cmp(&self.parsed, &other.parsed)\n     }\n@@ -522,13 +527,15 @@ impl<'a> Component<'a> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for Component<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         self.as_os_str()\n     }\n }\n \n #[stable(feature = \"path_component_asref\", since = \"1.25.0\")]\n impl AsRef<Path> for Component<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         self.as_os_str().as_ref()\n     }\n@@ -750,13 +757,15 @@ impl<'a> Components<'a> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for Components<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         self.as_path()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for Components<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         self.as_path().as_os_str()\n     }\n@@ -792,20 +801,23 @@ impl<'a> Iter<'a> {\n     /// assert_eq!(Path::new(\"foo/bar.txt\"), iter.as_path());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_path(&self) -> &'a Path {\n         self.inner.as_path()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for Iter<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         self.as_path()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for Iter<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         self.as_path().as_os_str()\n     }\n@@ -815,13 +827,15 @@ impl AsRef<OsStr> for Iter<'_> {\n impl<'a> Iterator for Iter<'a> {\n     type Item = &'a OsStr;\n \n+    #[inline]\n     fn next(&mut self) -> Option<&'a OsStr> {\n         self.inner.next().map(Component::as_os_str)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Iter<'a> {\n+    #[inline]\n     fn next_back(&mut self) -> Option<&'a OsStr> {\n         self.inner.next_back().map(Component::as_os_str)\n     }\n@@ -935,6 +949,7 @@ impl FusedIterator for Components<'_> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialEq for Components<'a> {\n+    #[inline]\n     fn eq(&self, other: &Components<'a>) -> bool {\n         Iterator::eq(self.clone(), other.clone())\n     }\n@@ -945,13 +960,15 @@ impl cmp::Eq for Components<'_> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialOrd for Components<'a> {\n+    #[inline]\n     fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> {\n         Iterator::partial_cmp(self.clone(), other.clone())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for Components<'_> {\n+    #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n         Iterator::cmp(self.clone(), other.clone())\n     }\n@@ -985,6 +1002,7 @@ pub struct Ancestors<'a> {\n impl<'a> Iterator for Ancestors<'a> {\n     type Item = &'a Path;\n \n+    #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n         let next = self.next;\n         self.next = next.and_then(Path::parent);\n@@ -1060,6 +1078,7 @@ pub struct PathBuf {\n }\n \n impl PathBuf {\n+    #[inline]\n     fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n         unsafe { &mut *(self as *mut PathBuf as *mut Vec<u8>) }\n     }\n@@ -1074,6 +1093,7 @@ impl PathBuf {\n     /// let path = PathBuf::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn new() -> PathBuf {\n         PathBuf { inner: OsString::new() }\n     }\n@@ -1097,6 +1117,7 @@ impl PathBuf {\n     ///\n     /// [`with_capacity`]: OsString::with_capacity\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn with_capacity(capacity: usize) -> PathBuf {\n         PathBuf { inner: OsString::with_capacity(capacity) }\n     }\n@@ -1112,6 +1133,7 @@ impl PathBuf {\n     /// assert_eq!(Path::new(\"/test\"), p.as_path());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_path(&self) -> &Path {\n         self\n     }\n@@ -1315,12 +1337,14 @@ impl PathBuf {\n     /// let os_str = p.into_os_string();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn into_os_string(self) -> OsString {\n         self.inner\n     }\n \n     /// Converts this `PathBuf` into a [boxed](Box) [`Path`].\n     #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n+    #[inline]\n     pub fn into_boxed_path(self) -> Box<Path> {\n         let rw = Box::into_raw(self.inner.into_boxed_os_str()) as *mut Path;\n         unsafe { Box::from_raw(rw) }\n@@ -1330,6 +1354,7 @@ impl PathBuf {\n     ///\n     /// [`capacity`]: OsString::capacity\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn capacity(&self) -> usize {\n         self.inner.capacity()\n     }\n@@ -1338,6 +1363,7 @@ impl PathBuf {\n     ///\n     /// [`clear`]: OsString::clear\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn clear(&mut self) {\n         self.inner.clear()\n     }\n@@ -1346,6 +1372,7 @@ impl PathBuf {\n     ///\n     /// [`reserve`]: OsString::reserve\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn reserve(&mut self, additional: usize) {\n         self.inner.reserve(additional)\n     }\n@@ -1354,6 +1381,7 @@ impl PathBuf {\n     ///\n     /// [`reserve_exact`]: OsString::reserve_exact\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.inner.reserve_exact(additional)\n     }\n@@ -1362,6 +1390,7 @@ impl PathBuf {\n     ///\n     /// [`shrink_to_fit`]: OsString::shrink_to_fit\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn shrink_to_fit(&mut self) {\n         self.inner.shrink_to_fit()\n     }\n@@ -1370,6 +1399,7 @@ impl PathBuf {\n     ///\n     /// [`shrink_to`]: OsString::shrink_to\n     #[unstable(feature = \"shrink_to\", issue = \"56431\")]\n+    #[inline]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n         self.inner.shrink_to(min_capacity)\n     }\n@@ -1400,6 +1430,7 @@ impl From<Box<Path>> for PathBuf {\n     /// Converts a `Box<Path>` into a `PathBuf`\n     ///\n     /// This conversion does not allocate or copy memory.\n+    #[inline]\n     fn from(boxed: Box<Path>) -> PathBuf {\n         boxed.into_path_buf()\n     }\n@@ -1411,6 +1442,7 @@ impl From<PathBuf> for Box<Path> {\n     ///\n     /// This conversion currently should not allocate memory,\n     /// but this behavior is not guaranteed on all platforms or in all future versions.\n+    #[inline]\n     fn from(p: PathBuf) -> Box<Path> {\n         p.into_boxed_path()\n     }\n@@ -1426,6 +1458,7 @@ impl Clone for Box<Path> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + AsRef<OsStr>> From<&T> for PathBuf {\n+    #[inline]\n     fn from(s: &T) -> PathBuf {\n         PathBuf::from(s.as_ref().to_os_string())\n     }\n@@ -1447,6 +1480,7 @@ impl From<PathBuf> for OsString {\n     /// Converts a `PathBuf` into a `OsString`\n     ///\n     /// This conversion does not allocate or copy memory.\n+    #[inline]\n     fn from(path_buf: PathBuf) -> OsString {\n         path_buf.inner\n     }\n@@ -1457,6 +1491,7 @@ impl From<String> for PathBuf {\n     /// Converts a `String` into a `PathBuf`\n     ///\n     /// This conversion does not allocate or copy memory.\n+    #[inline]\n     fn from(s: String) -> PathBuf {\n         PathBuf::from(OsString::from(s))\n     }\n@@ -1466,6 +1501,7 @@ impl From<String> for PathBuf {\n impl FromStr for PathBuf {\n     type Err = core::convert::Infallible;\n \n+    #[inline]\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         Ok(PathBuf::from(s))\n     }\n@@ -1510,13 +1546,15 @@ impl ops::Deref for PathBuf {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<Path> for PathBuf {\n+    #[inline]\n     fn borrow(&self) -> &Path {\n         self.deref()\n     }\n }\n \n #[stable(feature = \"default_for_pathbuf\", since = \"1.17.0\")]\n impl Default for PathBuf {\n+    #[inline]\n     fn default() -> Self {\n         PathBuf::new()\n     }\n@@ -1597,16 +1635,19 @@ impl From<&Path> for Rc<Path> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for Path {\n     type Owned = PathBuf;\n+    #[inline]\n     fn to_owned(&self) -> PathBuf {\n         self.to_path_buf()\n     }\n+    #[inline]\n     fn clone_into(&self, target: &mut PathBuf) {\n         self.inner.clone_into(&mut target.inner);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for PathBuf {\n+    #[inline]\n     fn eq(&self, other: &PathBuf) -> bool {\n         self.components() == other.components()\n     }\n@@ -1624,20 +1665,23 @@ impl cmp::Eq for PathBuf {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialOrd for PathBuf {\n+    #[inline]\n     fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> {\n         self.components().partial_cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for PathBuf {\n+    #[inline]\n     fn cmp(&self, other: &PathBuf) -> cmp::Ordering {\n         self.components().cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for PathBuf {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         &self.inner[..]\n     }\n@@ -1745,6 +1789,7 @@ impl Path {\n     /// assert_eq!(os_str, std::ffi::OsStr::new(\"foo.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_os_str(&self) -> &OsStr {\n         &self.inner\n     }\n@@ -1766,6 +1811,7 @@ impl Path {\n     /// assert_eq!(path.to_str(), Some(\"foo.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n     }\n@@ -1791,6 +1837,7 @@ impl Path {\n     /// Had `path` contained invalid unicode, the `to_string_lossy` call might\n     /// have returned `\"fo\ufffd.txt\"`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_string_lossy(&self) -> Cow<'_, str> {\n         self.inner.to_string_lossy()\n     }\n@@ -1854,6 +1901,7 @@ impl Path {\n     ///\n     /// [`is_absolute`]: Path::is_absolute\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n     }\n@@ -1879,6 +1927,7 @@ impl Path {\n     /// assert!(Path::new(\"/etc/passwd\").has_root());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn has_root(&self) -> bool {\n         self.components().has_root()\n     }\n@@ -1941,6 +1990,7 @@ impl Path {\n     ///\n     /// [`parent`]: Path::parent\n     #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n+    #[inline]\n     pub fn ancestors(&self) -> Ancestors<'_> {\n         Ancestors { next: Some(&self) }\n     }\n@@ -2265,6 +2315,7 @@ impl Path {\n     /// assert_eq!(it.next(), None)\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn iter(&self) -> Iter<'_> {\n         Iter { inner: self.components() }\n     }\n@@ -2284,6 +2335,7 @@ impl Path {\n     /// println!(\"{}\", path.display());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn display(&self) -> Display<'_> {\n         Display { path: self }\n     }\n@@ -2305,6 +2357,7 @@ impl Path {\n     /// println!(\"{:?}\", metadata.file_type());\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn metadata(&self) -> io::Result<fs::Metadata> {\n         fs::metadata(self)\n     }\n@@ -2323,6 +2376,7 @@ impl Path {\n     /// println!(\"{:?}\", metadata.file_type());\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> {\n         fs::symlink_metadata(self)\n     }\n@@ -2341,6 +2395,7 @@ impl Path {\n     /// assert_eq!(path.canonicalize().unwrap(), PathBuf::from(\"/foo/test/bar.rs\"));\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn canonicalize(&self) -> io::Result<PathBuf> {\n         fs::canonicalize(self)\n     }\n@@ -2358,6 +2413,7 @@ impl Path {\n     /// let path_link = path.read_link().expect(\"read_link call failed\");\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn read_link(&self) -> io::Result<PathBuf> {\n         fs::read_link(self)\n     }\n@@ -2382,6 +2438,7 @@ impl Path {\n     /// }\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn read_dir(&self) -> io::Result<fs::ReadDir> {\n         fs::read_dir(self)\n     }\n@@ -2406,6 +2463,7 @@ impl Path {\n     /// This is a convenience function that coerces errors to false. If you want to\n     /// check errors, call [`fs::metadata`].\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn exists(&self) -> bool {\n         fs::metadata(self).is_ok()\n     }\n@@ -2480,6 +2538,7 @@ impl Path {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for Path {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         &self.inner\n     }\n@@ -2531,6 +2590,7 @@ impl fmt::Display for Display<'_> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for Path {\n+    #[inline]\n     fn eq(&self, other: &Path) -> bool {\n         self.components().eq(other.components())\n     }\n@@ -2550,41 +2610,47 @@ impl cmp::Eq for Path {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialOrd for Path {\n+    #[inline]\n     fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> {\n         self.components().partial_cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for Path {\n+    #[inline]\n     fn cmp(&self, other: &Path) -> cmp::Ordering {\n         self.components().cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for Path {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for OsStr {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         Path::new(self)\n     }\n }\n \n #[stable(feature = \"cow_os_str_as_ref_path\", since = \"1.8.0\")]\n impl AsRef<Path> for Cow<'_, OsStr> {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         Path::new(self)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for OsString {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         Path::new(self)\n     }\n@@ -2600,6 +2666,7 @@ impl AsRef<Path> for str {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for String {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         Path::new(self)\n     }\n@@ -2617,6 +2684,7 @@ impl AsRef<Path> for PathBuf {\n impl<'a> IntoIterator for &'a PathBuf {\n     type Item = &'a OsStr;\n     type IntoIter = Iter<'a>;\n+    #[inline]\n     fn into_iter(self) -> Iter<'a> {\n         self.iter()\n     }\n@@ -2626,6 +2694,7 @@ impl<'a> IntoIterator for &'a PathBuf {\n impl<'a> IntoIterator for &'a Path {\n     type Item = &'a OsStr;\n     type IntoIter = Iter<'a>;\n+    #[inline]\n     fn into_iter(self) -> Iter<'a> {\n         self.iter()\n     }"}, {"sha": "a116ed686d90e745609ffd49e18e2c1e521e4f20", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -1096,7 +1096,10 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     AssocTypeItem(bounds.clean(cx), default.clean(cx))\n                 }\n             };\n-            Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+            let what_rustc_thinks =\n+                Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx);\n+            // Trait items always inherit the trait's visibility -- we don't want to show `pub`.\n+            Item { visibility: Inherited, ..what_rustc_thinks }\n         })\n     }\n }\n@@ -1131,7 +1134,21 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                     )\n                 }\n             };\n-            Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+\n+            let what_rustc_thinks =\n+                Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx);\n+            let parent_item = cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(self.hir_id));\n+            if let hir::ItemKind::Impl(impl_) = &parent_item.kind {\n+                if impl_.of_trait.is_some() {\n+                    // Trait impl items always inherit the impl's visibility --\n+                    // we don't want to show `pub`.\n+                    Item { visibility: Inherited, ..what_rustc_thinks }\n+                } else {\n+                    what_rustc_thinks\n+                }\n+            } else {\n+                panic!(\"found impl item with non-impl parent {:?}\", parent_item);\n+            }\n         })\n     }\n }"}, {"sha": "6941fa064ec0392ea2f3606271a1ad4706f65c41", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -12,6 +12,9 @@ use crate::formats::cache::{Cache, CACHE_KEY};\n /// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n /// module, and cleanup/finalizing output.\n crate trait FormatRenderer<'tcx>: Clone {\n+    /// Gives a description of the renderer. Used for performance profiling.\n+    fn descr() -> &'static str;\n+\n     /// Sets up any state required for the renderer. When this is called the cache has already been\n     /// populated.\n     fn init(\n@@ -57,16 +60,20 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n     edition: Edition,\n     tcx: TyCtxt<'tcx>,\n ) -> Result<(), Error> {\n-    let (krate, mut cache) = Cache::from_krate(\n-        render_info.clone(),\n-        options.document_private,\n-        &options.extern_html_root_urls,\n-        &options.output,\n-        krate,\n-    );\n-\n-    let (mut format_renderer, mut krate) =\n-        T::init(krate, options, render_info, edition, &mut cache, tcx)?;\n+    let (krate, mut cache) = tcx.sess.time(\"create_format_cache\", || {\n+        Cache::from_krate(\n+            render_info.clone(),\n+            options.document_private,\n+            &options.extern_html_root_urls,\n+            &options.output,\n+            krate,\n+        )\n+    });\n+    let prof = &tcx.sess.prof;\n+\n+    let (mut format_renderer, mut krate) = prof\n+        .extra_verbose_generic_activity(\"create_renderer\", T::descr())\n+        .run(|| T::init(krate, options, render_info, edition, &mut cache, tcx))?;\n \n     let cache = Arc::new(cache);\n     // Freeze the cache now that the index has been built. Put an Arc into TLS for future\n@@ -83,6 +90,7 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n     // Render the crate documentation\n     let mut work = vec![(format_renderer.clone(), item)];\n \n+    let unknown = rustc_span::Symbol::intern(\"<unknown item>\");\n     while let Some((mut cx, item)) = work.pop() {\n         if item.is_mod() {\n             // modules are special because they add a namespace. We also need to\n@@ -91,6 +99,7 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n             if name.is_empty() {\n                 panic!(\"Unexpected module with empty name\");\n             }\n+            let _timer = prof.generic_activity_with_arg(\"render_mod_item\", name.as_str());\n \n             cx.mod_item_in(&item, &name, &cache)?;\n             let module = match *item.kind {\n@@ -104,9 +113,10 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n \n             cx.mod_item_out(&name)?;\n         } else if item.name.is_some() {\n-            cx.item(item, &cache)?;\n+            prof.generic_activity_with_arg(\"render_item\", &*item.name.unwrap_or(unknown).as_str())\n+                .run(|| cx.item(item, &cache))?;\n         }\n     }\n-\n-    format_renderer.after_krate(&krate, &cache, diag)\n+    prof.extra_verbose_generic_activity(\"renderer_after_krate\", T::descr())\n+        .run(|| format_renderer.after_krate(&krate, &cache, diag))\n }"}, {"sha": "8e010839ad81ed05430c331f797c269016e67580", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -383,6 +383,10 @@ crate fn initial_ids() -> Vec<String> {\n \n /// Generates the documentation for `crate` into the directory `dst`\n impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n+    fn descr() -> &'static str {\n+        \"html\"\n+    }\n+\n     fn init(\n         mut krate: clean::Crate,\n         options: RenderOptions,"}, {"sha": "512c9124727efde4d836fa436d9a8d103de53775", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -125,6 +125,10 @@ impl JsonRenderer<'_> {\n }\n \n impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n+    fn descr() -> &'static str {\n+        \"json\"\n+    }\n+\n     fn init(\n         krate: clean::Crate,\n         options: RenderOptions,"}, {"sha": "83736295beb19eab055feb409ba334dd0bf41eae", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -540,7 +540,7 @@ fn main_options(options: config::Options) -> MainResult {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");\n             }\n \n-            let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n+            let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).peek_mut();\n \n             global_ctxt.enter(|tcx| {\n                 let (mut krate, render_info, render_opts) = sess.time(\"run_global_ctxt\", || {"}, {"sha": "beb638406c4bed54cc3683ead73f57ee53bb15ca", "filename": "src/test/rustdoc/visibility.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Ftest%2Frustdoc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Ftest%2Frustdoc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fvisibility.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -42,3 +42,35 @@ mod a {\n         struct FooBPriv;\n     }\n }\n+\n+// @has 'foo/trait.PubTrait.html' '//pre' 'pub trait PubTrait'\n+//\n+// @has 'foo/trait.PubTrait.html' '//pre' 'type Type;'\n+// @!has 'foo/trait.PubTrait.html' '//pre' 'pub type Type;'\n+//\n+// @has 'foo/trait.PubTrait.html' '//pre' 'const CONST: usize;'\n+// @!has 'foo/trait.PubTrait.html' '//pre' 'pub const CONST: usize;'\n+//\n+// @has 'foo/trait.PubTrait.html' '//pre' 'fn function();'\n+// @!has 'foo/trait.PubTrait.html' '//pre' 'pub fn function();'\n+\n+pub trait PubTrait {\n+    type Type;\n+    const CONST: usize;\n+    fn function();\n+}\n+\n+// @has 'foo/struct.FooPublic.html' '//code' 'type Type'\n+// @!has 'foo/struct.FooPublic.html' '//code' 'pub type Type'\n+//\n+// @has 'foo/struct.FooPublic.html' '//code' 'const CONST: usize'\n+// @!has 'foo/struct.FooPublic.html' '//code' 'pub const CONST: usize'\n+//\n+// @has 'foo/struct.FooPublic.html' '//code' 'fn function()'\n+// @!has 'foo/struct.FooPublic.html' '//code' 'pub fn function()'\n+\n+impl PubTrait for FooPublic {\n+    type Type = usize;\n+    const CONST: usize = 0;\n+    fn function() {}\n+}"}, {"sha": "006e6f490f06b14bb3b5c1a271754fcc8bb77595", "filename": "src/test/ui/closures/local-type-mix.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Ftest%2Fui%2Fclosures%2Flocal-type-mix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Ftest%2Fui%2Fclosures%2Flocal-type-mix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Flocal-type-mix.rs?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -0,0 +1,17 @@\n+// Check that using the parameter name in its type does not ICE.\n+// edition:2018\n+\n+#![feature(async_closure)]\n+\n+fn main() {\n+    let _ = |x: x| x; //~ ERROR expected type\n+    let _ = |x: bool| -> x { x }; //~ ERROR expected type\n+    let _ = async move |x: x| x; //~ ERROR expected type\n+    let _ = async move |x: bool| -> x { x }; //~ ERROR expected type\n+}\n+\n+fn foo(x: x) {} //~ ERROR expected type\n+fn foo_ret(x: bool) -> x {} //~ ERROR expected type\n+\n+async fn async_foo(x: x) {} //~ ERROR expected type\n+async fn async_foo_ret(x: bool) -> x {} //~ ERROR expected type"}, {"sha": "68c320a065d57919c10c1bb5a8c434ea8c9cfb64", "filename": "src/test/ui/closures/local-type-mix.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Ftest%2Fui%2Fclosures%2Flocal-type-mix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Ftest%2Fui%2Fclosures%2Flocal-type-mix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Flocal-type-mix.stderr?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -0,0 +1,51 @@\n+error[E0573]: expected type, found local variable `x`\n+  --> $DIR/local-type-mix.rs:7:17\n+   |\n+LL |     let _ = |x: x| x;\n+   |                 ^ not a type\n+\n+error[E0573]: expected type, found local variable `x`\n+  --> $DIR/local-type-mix.rs:8:26\n+   |\n+LL |     let _ = |x: bool| -> x { x };\n+   |                          ^ not a type\n+\n+error[E0573]: expected type, found local variable `x`\n+  --> $DIR/local-type-mix.rs:9:28\n+   |\n+LL |     let _ = async move |x: x| x;\n+   |                            ^ not a type\n+\n+error[E0573]: expected type, found local variable `x`\n+  --> $DIR/local-type-mix.rs:10:37\n+   |\n+LL |     let _ = async move |x: bool| -> x { x };\n+   |                                     ^ not a type\n+\n+error[E0573]: expected type, found local variable `x`\n+  --> $DIR/local-type-mix.rs:13:11\n+   |\n+LL | fn foo(x: x) {}\n+   |           ^ not a type\n+\n+error[E0573]: expected type, found local variable `x`\n+  --> $DIR/local-type-mix.rs:14:24\n+   |\n+LL | fn foo_ret(x: bool) -> x {}\n+   |                        ^ not a type\n+\n+error[E0573]: expected type, found local variable `x`\n+  --> $DIR/local-type-mix.rs:16:23\n+   |\n+LL | async fn async_foo(x: x) {}\n+   |                       ^ not a type\n+\n+error[E0573]: expected type, found local variable `x`\n+  --> $DIR/local-type-mix.rs:17:36\n+   |\n+LL | async fn async_foo_ret(x: bool) -> x {}\n+   |                                    ^ not a type\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0573`."}, {"sha": "26f9c786ba13b9ce60a8dd01720590a44c03dc89", "filename": "src/test/ui/mir/issue-80742.stderr", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Ftest%2Fui%2Fmir%2Fissue-80742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1279b3b9232e4c44112d98f19cfa8846776d1fe8/src%2Ftest%2Fui%2Fmir%2Fissue-80742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-80742.stderr?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -1,3 +1,17 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+   |\n+LL |     intrinsics::size_of::<T>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     size_of called on unsized type `dyn Debug`\n+   |     inside `std::mem::size_of::<dyn Debug>` at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+   | \n+  ::: $DIR/issue-80742.rs:23:10\n+   |\n+LL |     [u8; size_of::<T>() + 1]: ,\n+   |          -------------- inside `Inline::<dyn Debug>::{constant#0}` at $DIR/issue-80742.rs:23:10\n+\n error[E0599]: no function or associated item named `new` found for struct `Inline<dyn Debug>` in the current scope\n   --> $DIR/issue-80742.rs:31:36\n    |\n@@ -21,6 +35,20 @@ LL |   pub trait Debug {\n    = note: the method `new` exists but the following trait bounds were not satisfied:\n            `dyn Debug: Sized`\n \n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+   |\n+LL |     intrinsics::size_of::<T>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     size_of called on unsized type `dyn Debug`\n+   |     inside `std::mem::size_of::<dyn Debug>` at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+   | \n+  ::: $DIR/issue-80742.rs:15:10\n+   |\n+LL |     [u8; size_of::<T>() + 1]: ,\n+   |          -------------- inside `Inline::<dyn Debug>::{constant#0}` at $DIR/issue-80742.rs:15:10\n+\n error[E0277]: the size for values of type `dyn Debug` cannot be known at compilation time\n   --> $DIR/issue-80742.rs:31:15\n    |\n@@ -36,7 +64,7 @@ help: consider relaxing the implicit `Sized` restriction\n LL | struct Inline<T: ?Sized>\n    |                ^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0277, E0599.\n-For more information about an error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0080, E0277, E0599.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "783bc43c660bf39c1e562c8c429b32078ad3099b", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=1279b3b9232e4c44112d98f19cfa8846776d1fe8", "patch": "@@ -1 +1 @@\n-Subproject commit a73e5b7d567c3036b296fc6b33ed52c5edcd882e\n+Subproject commit 783bc43c660bf39c1e562c8c429b32078ad3099b"}]}