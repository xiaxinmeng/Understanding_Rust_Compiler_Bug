{"sha": "6c78fa822a311e30e6421525570f472bf19e32fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNzhmYTgyMmEzMTFlMzBlNjQyMTUyNTU3MGY0NzJiZjE5ZTMyZmQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-26T10:59:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "use associated const for machine controlling mutable statics\n\nSo get rid of the IsStatic trait again", "tree": {"sha": "aef708a3956954e2d3948e777338d99ffdd84019", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aef708a3956954e2d3948e777338d99ffdd84019"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c78fa822a311e30e6421525570f472bf19e32fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c78fa822a311e30e6421525570f472bf19e32fd", "html_url": "https://github.com/rust-lang/rust/commit/6c78fa822a311e30e6421525570f472bf19e32fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c78fa822a311e30e6421525570f472bf19e32fd/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b737dbbf473d75a82ce77ce70066dd57b4e7bd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7", "html_url": "https://github.com/rust-lang/rust/commit/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7"}], "stats": {"total": 106, "additions": 39, "deletions": 67}, "files": [{"sha": "75298a8fcda2582ccddb3ec689eddb5ddba7f60e", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=6c78fa822a311e30e6421525570f472bf19e32fd", "patch": "@@ -26,11 +26,11 @@ use syntax::source_map::Span;\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Scalar, AllocId, Allocation, ConstValue, AllocType,\n+    Scalar, Allocation, ConstValue,\n };\n use interpret::{self,\n     Place, PlaceTy, MemPlace, OpTy, Operand, Value,\n-    EvalContext, StackPopCleanup, MemoryKind, Memory,\n+    EvalContext, StackPopCleanup, MemoryKind,\n };\n \n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n@@ -232,17 +232,12 @@ impl Error for ConstEvalError {\n     }\n }\n \n-impl interpret::IsStatic for ! {\n-    fn is_static(self) -> bool {\n-        // unreachable\n-        self\n-    }\n-}\n-\n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     type MemoryData = ();\n     type MemoryKinds = !;\n \n+    const MUT_STATIC_KIND: Option<!> = None; // no mutating of statics allowed\n+\n     fn find_fn<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n@@ -308,19 +303,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         }\n     }\n \n-    fn access_static_mut<'a, 'm>(\n-        mem: &'m mut Memory<'a, 'mir, 'tcx, Self>,\n-        id: AllocId,\n-    ) -> EvalResult<'tcx, &'m mut Allocation> {\n-        // This is always an error, we do not allow mutating statics\n-        match mem.tcx.alloc_map.lock().get(id) {\n-            Some(AllocType::Memory(..)) |\n-            Some(AllocType::Static(..)) => err!(ModifiedConstantMemory),\n-            Some(AllocType::Function(..)) => err!(DerefFunctionPointer),\n-            None => err!(DanglingPointerDeref),\n-        }\n-    }\n-\n     fn find_foreign_static<'a>(\n         _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         _def_id: DefId,"}, {"sha": "a8fae2b4871ed7a13d07666fbca0197e3a798516", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=6c78fa822a311e30e6421525570f472bf19e32fd", "patch": "@@ -15,16 +15,11 @@\n use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{AllocId, Allocation, EvalResult, Scalar};\n+use rustc::mir::interpret::{Allocation, EvalResult, Scalar};\n use rustc::mir;\n use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n \n-use super::{EvalContext, PlaceTy, OpTy, Memory};\n-\n-/// Used by the machine to tell if a certain allocation is for static memory\n-pub trait IsStatic {\n-    fn is_static(self) -> bool;\n-}\n+use super::{EvalContext, PlaceTy, OpTy};\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n@@ -33,7 +28,10 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n     type MemoryData: Clone + Eq + Hash;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq + Hash + IsStatic;\n+    type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq + Hash;\n+\n+    /// The memory kind to use for mutated statics -- or None if those are not supported.\n+    const MUT_STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -63,6 +61,9 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n     ) -> EvalResult<'tcx>;\n \n     /// Called for read access to a foreign static item.\n+    /// This can be called multiple times for the same static item and should return consistent\n+    /// results.  Once the item is *written* the first time, as usual for statics a copy is\n+    /// made and this function is not called again.\n     fn find_foreign_static<'a>(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n@@ -83,12 +84,6 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n         right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n \n-    /// Called when requiring mutable access to data in a static.\n-    fn access_static_mut<'a, 'm>(\n-        mem: &'m mut Memory<'a, 'mir, 'tcx, Self>,\n-        id: AllocId,\n-    ) -> EvalResult<'tcx, &'m mut Allocation>;\n-\n     /// Heap allocations via the `box` keyword\n     ///\n     /// Returns a pointer to the allocated memory"}, {"sha": "240f977a5a0e8ddfc045260fae96090ee575e4ab", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=6c78fa822a311e30e6421525570f472bf19e32fd", "patch": "@@ -29,7 +29,7 @@ use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n \n use syntax::ast::Mutability;\n \n-use super::{Machine, IsStatic};\n+use super::Machine;\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub enum MemoryKind<T> {\n@@ -39,23 +39,16 @@ pub enum MemoryKind<T> {\n     Machine(T),\n }\n \n-impl<T: IsStatic> IsStatic for MemoryKind<T> {\n-    fn is_static(self) -> bool {\n-        match self {\n-            MemoryKind::Stack => false,\n-            MemoryKind::Machine(kind) => kind.is_static(),\n-        }\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Additional data required by the Machine\n     pub data: M::MemoryData,\n \n     /// Allocations local to this instance of the miri engine.  The kind\n     /// helps ensure that the same mechanism is used for allocation and\n-    /// deallocation.\n+    /// deallocation.  When an allocation is not found here, it is a\n+    /// static and looked up in the `tcx` for read access.  Writing to\n+    /// a static creates a copy here, in the machine.\n     alloc_map: FxHashMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n \n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n@@ -223,10 +216,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(new_ptr)\n     }\n \n-    pub fn is_static(&self, alloc_id: AllocId) -> bool {\n-        self.alloc_map.get(&alloc_id).map_or(true, |&(kind, _)| kind.is_static())\n-    }\n-\n     /// Deallocate a local, or do nothing if that local has been made into a static\n     pub fn deallocate_local(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n         // The allocation might be already removed by static interning.\n@@ -354,10 +343,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n /// Allocation accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n-        // normal alloc?\n         match self.alloc_map.get(&id) {\n+            // Normal alloc?\n             Some(alloc) => Ok(&alloc.1),\n-            // No need to make any copies, just provide read access to the global static\n+            // Static. No need to make any copies, just provide read access to the global static\n             // memory in tcx.\n             None => const_eval_static::<M>(self.tcx, id),\n         }\n@@ -368,14 +357,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         id: AllocId,\n     ) -> EvalResult<'tcx, &mut Allocation> {\n         // Static?\n-        let alloc = if self.alloc_map.contains_key(&id) {\n-            &mut self.alloc_map.get_mut(&id).unwrap().1\n-        } else {\n-            // The machine controls to what extend we are allowed to mutate global\n-            // statics.  (We do not want to allow that during CTFE, but miri needs it.)\n-            M::access_static_mut(self, id)?\n-        };\n-        // See if we can use this\n+        if !self.alloc_map.contains_key(&id) {\n+            // Ask the machine for what to do\n+            if let Some(kind) = M::MUT_STATIC_KIND {\n+                // The machine supports mutating statics.  Make a copy, use that.\n+                self.deep_copy_static(id, MemoryKind::Machine(kind))?;\n+            } else {\n+                return err!(ModifiedConstantMemory)\n+            }\n+        }\n+        // If we come here, we know the allocation is in our map\n+        let alloc = &mut self.alloc_map.get_mut(&id).unwrap().1;\n+        // See if we are allowed to mutate this\n         if alloc.mutability == Mutability::Immutable {\n             err!(ModifiedConstantMemory)\n         } else {\n@@ -489,10 +482,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn leak_report(&self) -> usize {\n         trace!(\"### LEAK REPORT ###\");\n+        let mut_static_kind = M::MUT_STATIC_KIND.map(|k| MemoryKind::Machine(k));\n         let leaks: Vec<_> = self.alloc_map\n             .iter()\n-            .filter_map(|(&id, (kind, _))|\n-                if kind.is_static() { None } else { Some(id) } )\n+            .filter_map(|(&id, &(kind, _))|\n+                // exclude mutable statics\n+                if Some(kind) == mut_static_kind { None } else { Some(id) } )\n             .collect();\n         let n = leaks.len();\n         self.dump_allocs(leaks);\n@@ -609,7 +604,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// The alloc_id must refer to a (mutable) static; a deep copy of that\n     /// static is made into this memory.\n-    pub fn deep_copy_static(\n+    fn deep_copy_static(\n         &mut self,\n         id: AllocId,\n         kind: MemoryKind<M::MemoryKinds>,\n@@ -619,7 +614,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             return err!(ModifiedConstantMemory);\n         }\n         let old = self.alloc_map.insert(id, (kind, alloc.clone()));\n-        assert!(old.is_none(), \"deep_copy_static: must not overwrite memory with\");\n+        assert!(old.is_none(), \"deep_copy_static: must not overwrite existing memory\");\n         Ok(())\n     }\n "}, {"sha": "462c4b8889dd1977dc06c8154a388ac92fe56c6e", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=6c78fa822a311e30e6421525570f472bf19e32fd", "patch": "@@ -31,7 +31,7 @@ pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind};\n \n-pub use self::machine::{Machine, IsStatic};\n+pub use self::machine::Machine;\n \n pub use self::operand::{Value, ValTy, Operand, OpTy};\n "}, {"sha": "d2a91bd3ac28f8c52e2e94ef173ba889e625058e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c78fa822a311e30e6421525570f472bf19e32fd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=6c78fa822a311e30e6421525570f472bf19e32fd", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                 }\n                                 (instance, sig)\n                             }\n-                            ref other => bug!(\"instance def ty: {:?}\", other),\n+                            _ => bug!(\"unexpected fn ptr to ty: {:?}\", instance_ty),\n                         }\n                     }\n                     ty::FnDef(def_id, substs) => {"}]}