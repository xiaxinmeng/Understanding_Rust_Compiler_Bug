{"sha": "8462c6c83170dea3e835cfbe459406492c1413a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NjJjNmM4MzE3MGRlYTNlODM1Y2ZiZTQ1OTQwNjQ5MmMxNDEzYTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-25T06:13:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-25T06:14:45Z"}, "message": "rustc: Generalize several parts of infer in preparation for using them for region bounds as well", "tree": {"sha": "f9692408b7dfe50d976c53d9c9818b8f77b41906", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9692408b7dfe50d976c53d9c9818b8f77b41906"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8462c6c83170dea3e835cfbe459406492c1413a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8462c6c83170dea3e835cfbe459406492c1413a6", "html_url": "https://github.com/rust-lang/rust/commit/8462c6c83170dea3e835cfbe459406492c1413a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8462c6c83170dea3e835cfbe459406492c1413a6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d7d5c16b375872db6f798e2e4b2f5f8d533dec5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d7d5c16b375872db6f798e2e4b2f5f8d533dec5", "html_url": "https://github.com/rust-lang/rust/commit/1d7d5c16b375872db6f798e2e4b2f5f8d533dec5"}], "stats": {"total": 191, "additions": 97, "deletions": 94}, "files": [{"sha": "48c4d19cdca6044b78b8f934e98602fba671fbbe", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 97, "deletions": 94, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/8462c6c83170dea3e835cfbe459406492c1413a6/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8462c6c83170dea3e835cfbe459406492c1413a6/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=8462c6c83170dea3e835cfbe459406492c1413a6", "patch": "@@ -16,53 +16,45 @@ export fixup_vars;\n export resolve_var;\n export compare_tys;\n \n-type bound = option<ty::t>;\n+type bound<T:copy> = option<T>;\n \n-type bounds = {lb: bound, ub: bound};\n+type bounds<T:copy> = {lb: bound<T>, ub: bound<T>};\n \n-enum var_value {\n+enum var_value<T:copy> {\n     redirect(uint),\n-    bounded(bounds)\n+    bounded(bounds<T>)\n }\n \n-type region_bound = option<ty::region>;\n-\n-type region_bounds = {lb: region_bound, ub: region_bound};\n-\n-enum region_value {\n-    rv_redirect(uint),\n-    rv_bounded(region_bounds)\n-}\n+type vals_and_bindings<T:copy> = {\n+    vals: smallintmap<var_value<T>>,\n+    mut bindings: [(uint, var_value<T>)]\n+};\n \n enum infer_ctxt = @{\n     tcx: ty::ctxt,\n-    vals: smallintmap<var_value>,\n-    mut bindings: [(uint, var_value)],\n-    region_vals: smallintmap<region_value>,\n-    mut region_bindings: [(uint, region_value)]\n+    vb: vals_and_bindings<ty::t>,\n+    rb: vals_and_bindings<ty::region>,\n };\n \n type ures = result::result<(), ty::type_err>;\n type fres<T> = result::result<T,int>;\n \n fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n     infer_ctxt(@{tcx: tcx,\n-                 vals: smallintmap::mk(),\n-                 mut bindings: [],\n-                 region_vals: smallintmap::mk(),\n-                 mut region_bindings: []})\n+                 vb: {vals: smallintmap::mk(), mut bindings: []},\n+                 rb: {vals: smallintmap::mk(), mut bindings: []}})\n }\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\">> mk_subty(%s <: %s)\", cx.ty_to_str(a), cx.ty_to_str(b)];\n-    cx.commit {||\n+    cx.commit(cx.vb) {||\n         cx.tys(a, b)\n     }\n }\n \n fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"> mk_eqty(%s <: %s)\", cx.ty_to_str(a), cx.ty_to_str(b)];\n-    cx.commit {||\n+    cx.commit(cx.vb) {||\n         mk_subty(cx, a, b).then {||\n             mk_subty(cx, b, a)\n         }\n@@ -72,7 +64,7 @@ fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n     let infcx = new_infer_ctxt(tcx);\n     #debug[\"> compare_tys(%s == %s)\", infcx.ty_to_str(a), infcx.ty_to_str(b)];\n-    infcx.commit {||\n+    infcx.commit(infcx.vb) {||\n         mk_subty(infcx, a, b).then {||\n             mk_subty(infcx, b, a)\n         }\n@@ -122,54 +114,63 @@ impl unify_methods for infer_ctxt {\n         ty_to_str(self.tcx, t)\n     }\n \n-    fn bound_to_str(b: bound) -> str {\n+    fn ty_bound_to_str(b: bound<ty::t>) -> str {\n         alt b {\n           none { \"none\" }\n           some(t) { self.ty_to_str(t) }\n         }\n     }\n \n-    fn bounds_to_str(v: bounds) -> str {\n+    fn ty_bounds_to_str(v: bounds<ty::t>) -> str {\n         #fmt[\"{%s <: X <: %s}\",\n-             self.bound_to_str(v.lb),\n-             self.bound_to_str(v.ub)]\n+             self.ty_bound_to_str(v.lb),\n+             self.ty_bound_to_str(v.ub)]\n     }\n \n-    fn var_value_to_str(v: var_value) -> str {\n+    fn ty_var_value_to_str(v: var_value<ty::t>) -> str {\n         alt v {\n           redirect(v) { #fmt[\"redirect(%u)\", v] }\n-          bounded(b) { self.bounds_to_str(b) }\n+          bounded(b) { self.ty_bounds_to_str(b) }\n         }\n     }\n \n-    fn set(vid: uint, +new_v: var_value) {\n-        let old_v = self.vals.get(vid);\n-        vec::push(self.bindings, (vid, old_v));\n+    fn set<T:copy>(vb: vals_and_bindings<T>, vid: uint,\n+                   +new_v: var_value<T>) {\n \n+        let old_v = vb.vals.get(vid);\n+        vec::push(vb.bindings, (vid, old_v));\n+        vb.vals.insert(vid, new_v);\n+    }\n+\n+    fn set_ty(vid: uint, +new_v: var_value<ty::t>) {\n+        let old_v = self.vb.vals.get(vid);\n+        self.set(self.vb, vid, new_v);\n         #debug[\"Updating variable <T%u> from %s to %s\",\n                vid,\n-               self.var_value_to_str(old_v),\n-               self.var_value_to_str(new_v)];\n-\n-        self.vals.insert(vid, new_v);\n+               self.ty_var_value_to_str(old_v),\n+               self.ty_var_value_to_str(new_v)];\n     }\n \n-    fn rollback_to(len: uint) {\n-        while self.bindings.len() != len {\n-            let (vid, old_v) = vec::pop(self.bindings);\n-            self.vals.insert(vid, old_v);\n+    fn rollback_to<T:copy>(vb: vals_and_bindings<T>, len: uint) {\n+        while vb.bindings.len() != len {\n+            let (vid, old_v) = vec::pop(vb.bindings);\n+            vb.vals.insert(vid, old_v);\n         }\n     }\n \n-    fn commit<T:copy,E:copy>(f: fn() -> result<T,E>) -> result<T,E> {\n-        assert self.bindings.len() == 0u;\n-        let r = self.try(f);\n-        vec::clear(self.bindings);\n+    fn commit<T:copy,E:copy,U:copy>(vb: vals_and_bindings<U>,\n+                                    f: fn() -> result<T,E>) -> result<T,E> {\n+\n+        assert vb.bindings.len() == 0u;\n+        let r = self.try(vb, f);\n+        vec::clear(vb.bindings);\n         ret r;\n     }\n \n-    fn try<T:copy,E:copy>(f: fn() -> result<T,E>) -> result<T,E> {\n-        let l = self.bindings.len();\n+    fn try<T:copy,E:copy,U:copy>(vb: vals_and_bindings<U>,\n+                                 f: fn() -> result<T,E>) -> result<T,E> {\n+\n+        let l = vb.bindings.len();\n         #debug[\"try(l=%u)\", l];\n         let r = f();\n         alt r {\n@@ -179,17 +180,19 @@ impl unify_methods for infer_ctxt {\n         ret r;\n     }\n \n-    fn get(vid: uint) -> {root: uint, bounds:bounds} {\n-        alt self.vals.find(vid) {\n+    fn get<T:copy>(vb: vals_and_bindings<T>, vid: uint)\n+            -> {root: uint, bounds:bounds<T>} {\n+\n+        alt vb.vals.find(vid) {\n           none {\n             let bnds = {lb: none, ub: none};\n-            self.vals.insert(vid, bounded(bnds));\n+            vb.vals.insert(vid, bounded(bnds));\n             {root: vid, bounds: bnds}\n           }\n           some(redirect(vid)) {\n-            let {root, bounds} = self.get(vid);\n+            let {root, bounds} = self.get(vb, vid);\n             if root != vid {\n-                self.vals.insert(vid, redirect(root));\n+                vb.vals.insert(vid, redirect(root));\n             }\n             {root: root, bounds: bounds}\n           }\n@@ -199,31 +202,21 @@ impl unify_methods for infer_ctxt {\n         }\n     }\n \n-    // FIXME: See if we can't throw some polymorphism on this to make this\n-    // less of a straight copy of the above.\n-    fn get_region(rid: uint) -> {root: uint, bounds:region_bounds} {\n-        alt self.region_vals.find(rid) {\n-          none {\n-            let bnds = {lb: none, ub: none};\n-            self.region_vals.insert(rid, rv_bounded(bnds));\n-            {root: rid, bounds: bnds}\n-          }\n-          some(rv_redirect(rid)) {\n-            let {root, bounds} = self.get_region(rid);\n-            if root != rid {\n-                self.region_vals.insert(rid, rv_redirect(root));\n-            }\n-            {root: root, bounds: bounds}\n-          }\n-          some(rv_bounded(bounds)) {\n-            {root: rid, bounds: bounds}\n-          }\n-        }\n+    fn get_var(vid: uint) -> {root: uint, bounds:bounds<ty::t>} {\n+        ret self.get(self.vb, vid);\n+    }\n+\n+    fn get_region(rid: uint) -> {root: uint, bounds:bounds<ty::region>} {\n+        ret self.get(self.rb, rid);\n     }\n \n     // Combines the two bounds.  Returns a bounds r where (r.lb <:\n     // a,b) and (a,b <: r.ub) (if such a bounds exists).\n-    fn merge_bnds(a: bound, b: bound) -> result<bounds, ty::type_err> {\n+    //\n+    // TODO: Generalize this to region bounds too.\n+    fn merge_bnds(a: bound<ty::t>, b: bound<ty::t>)\n+            -> result<bounds<ty::t>, ty::type_err> {\n+\n         alt (a, b) {\n           (none, none) {\n             ok({lb: none, ub: none})\n@@ -235,7 +228,7 @@ impl unify_methods for infer_ctxt {\n             ok({lb: b, ub: b})\n           }\n           (some(t_a), some(t_b)) {\n-            let r1 = self.try {||\n+            let r1 = self.try(self.vb) {||\n                 self.tys(t_a, t_b).then {||\n                     ok({lb: a, ub: b})\n                 }\n@@ -257,7 +250,9 @@ impl unify_methods for infer_ctxt {\n     //    a.lb <: c.lb\n     //    b.lb <: c.lb\n     // If this cannot be achieved, the result is failure.\n-    fn merge(v_id: uint, a: bounds, b: bounds) -> ures {\n+    //\n+    // TODO: Generalize to regions.\n+    fn merge(v_id: uint, a: bounds<ty::t>, b: bounds<ty::t>) -> ures {\n         // Think of the two diamonds, we want to find the\n         // intersection.  There are basically four possibilities (you\n         // can swap A/B in these pictures):\n@@ -275,8 +270,8 @@ impl unify_methods for infer_ctxt {\n \n         #debug[\"merge(<T%u>,%s,%s)\",\n                v_id,\n-               self.bounds_to_str(a),\n-               self.bounds_to_str(b)];\n+               self.ty_bounds_to_str(a),\n+               self.ty_bounds_to_str(b)];\n \n         chain(self.merge_bnds(a.ub, b.ub)) {|ub|\n             chain(self.merge_bnds(a.lb, b.lb)) {|lb|\n@@ -285,17 +280,18 @@ impl unify_methods for infer_ctxt {\n                 // the new bounds must themselves\n                 // be relatable:\n                 self.bnds(lb.ub, ub.lb).then {||\n-                    self.set(v_id, bounded(bnds));\n+                    self.set(self.vb, v_id, bounded(bnds));\n                     self.uok()\n                 }\n             }\n         }\n     }\n \n+    // TODO: Generalize to regions.\n     fn vars(a_id: uint, b_id: uint) -> ures {\n         // Need to make sub_id a subtype of sup_id.\n-        let {root: a_id, bounds: a_bounds} = self.get(a_id);\n-        let {root: b_id, bounds: b_bounds} = self.get(b_id);\n+        let {root: a_id, bounds: a_bounds} = self.get(self.vb, a_id);\n+        let {root: b_id, bounds: b_bounds} = self.get(self.vb, b_id);\n \n         #debug[\"vars(<T%u>=%s <: <T%u>=%s)\",\n                a_id, self.bounds_to_str(a_bounds),\n@@ -321,26 +317,26 @@ impl unify_methods for infer_ctxt {\n         // but that's the route we choose to take.\n         self.merge(a_id, a_bounds, b_bounds).then {||\n             // For max perf, we should consider the rank here.\n-            self.set(b_id, redirect(a_id));\n+            self.set(self.vb, b_id, redirect(a_id));\n             self.uok()\n         }\n     }\n \n     fn varty(a_id: uint, b: ty::t) -> ures {\n-        let {root: a_id, bounds: a_bounds} = self.get(a_id);\n+        let {root: a_id, bounds: a_bounds} = self.get(self.vb, a_id);\n         #debug[\"varty(<T%u>=%s <: %s)\",\n-               a_id, self.bounds_to_str(a_bounds),\n+               a_id, self.ty_bounds_to_str(a_bounds),\n                self.ty_to_str(b)];\n         let b_bounds = {lb: none, ub: some(b)};\n         self.merge(a_id, a_bounds, b_bounds)\n     }\n \n     fn tyvar(a: ty::t, b_id: uint) -> ures {\n         let a_bounds = {lb: some(a), ub: none};\n-        let {root: b_id, bounds: b_bounds} = self.get(b_id);\n+        let {root: b_id, bounds: b_bounds} = self.get(self.vb, b_id);\n         #debug[\"tyvar(%s <: <T%u>=%s)\",\n                self.ty_to_str(a),\n-               b_id, self.bounds_to_str(b_bounds)];\n+               b_id, self.ty_bounds_to_str(b_bounds)];\n         self.merge(b_id, a_bounds, b_bounds)\n     }\n \n@@ -530,10 +526,11 @@ impl unify_methods for infer_ctxt {\n         ret self.uok();\n     }\n \n-    fn bnds(a: bound, b: bound) -> ures {\n+    // TODO: Generalize this.\n+    fn bnds(a: bound<ty::t>, b: bound<ty::t>) -> ures {\n         #debug(\"bnds(%s <: %s)\",\n-               self.bound_to_str(a),\n-               self.bound_to_str(b));\n+               self.ty_bound_to_str(a),\n+               self.ty_bound_to_str(b));\n \n         alt (a, b) {\n           (none, none) |\n@@ -662,8 +659,10 @@ impl resolve_methods for infer_ctxt {\n         result::err(v)\n     }\n \n-    fn resolve_var(vid: int) -> fres<ty::t> {\n-        let {root:_, bounds} = self.get(vid as uint);\n+    fn resolve_var<T:copy>(vb: vals_and_bindings<T>, bot_guard: fn(T)->bool,\n+                           vid: int) -> fres<T> {\n+\n+        let {root:_, bounds} = self.get(vb, vid as uint);\n \n         // Nonobvious: prefer the most specific type\n         // (i.e., the lower bound) to the more general\n@@ -672,16 +671,20 @@ impl resolve_methods for infer_ctxt {\n         // perf. penalties, so it pays to know more.\n \n         alt bounds {\n-          { ub:_, lb:some(t) } if !type_is_bot(t) { self.rok(t) }\n-          { ub:some(t), lb:_ } { self.rok(t) }\n-          { ub:_, lb:some(t) } { self.rok(t) }\n+          { ub:_, lb:some(t) } if !bot_guard(t) { result::ok(t) }\n+          { ub:some(t), lb:_ } { result::ok(t) }\n+          { ub:_, lb:some(t) } { result::ok(t) }\n           { ub:none, lb:none } { self.rerr(vid) }\n         }\n     }\n \n+    fn resolve_ty_var(vid: int) -> fres<ty::t> {\n+        ret self.resolve_var(self.vb, {|t| type_is_bot(t)}, vid);\n+    }\n+\n     fn resolve_ty(typ: ty::t) -> fres<ty::t> {\n         alt ty::get(typ).struct {\n-          ty::ty_var(vid) { self.resolve_var(vid) }\n+          ty::ty_var(vid) { self.resolve_ty_var(vid) }\n           ty::ty_rptr(ty::re_var(rid), base_ty) {\n             alt self.resolve_region(rid as int) {\n               result::err(terr)  { result::err(terr) }\n@@ -699,7 +702,7 @@ impl resolve_methods for infer_ctxt {\n                   vid: int) -> ty::t {\n         // Should really return a fixup_result instead of a t, but fold_ty\n         // doesn't allow returning anything but a t.\n-        alt self.resolve_var(vid) {\n+        alt self.resolve_ty_var(vid) {\n           result::err(vid) {\n             *unresolved = some(vid);\n             ret ty::mk_var(self.tcx, vid);"}]}