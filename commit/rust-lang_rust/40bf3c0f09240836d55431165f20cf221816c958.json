{"sha": "40bf3c0f09240836d55431165f20cf221816c958", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYmYzYzBmMDkyNDA4MzZkNTU0MzExNjVmMjBjZjIyMTgxNmM5NTg=", "commit": {"author": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-12-28T22:57:13Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-12-30T15:57:49Z"}, "message": "Implement edition-based macro pat feature", "tree": {"sha": "cf5ad3b7f873a47247d4f0fa62a78a521297499a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf5ad3b7f873a47247d4f0fa62a78a521297499a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40bf3c0f09240836d55431165f20cf221816c958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40bf3c0f09240836d55431165f20cf221816c958", "html_url": "https://github.com/rust-lang/rust/commit/40bf3c0f09240836d55431165f20cf221816c958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40bf3c0f09240836d55431165f20cf221816c958/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2987785df3d46d5ff144a5c67fbb8f5cca798d78", "url": "https://api.github.com/repos/rust-lang/rust/commits/2987785df3d46d5ff144a5c67fbb8f5cca798d78", "html_url": "https://github.com/rust-lang/rust/commit/2987785df3d46d5ff144a5c67fbb8f5cca798d78"}], "stats": {"total": 227, "additions": 151, "deletions": 76}, "files": [{"sha": "6dde304e8cfe5e6e0c500496923dec3ab2bcfac1", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -15,7 +15,7 @@ use rustc_span::hygiene::ExpnKind;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{self, FileName, RealFileName, Span, DUMMY_SP};\n+use rustc_span::{self, edition::Edition, FileName, RealFileName, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::{fmt, mem};\n \n@@ -690,7 +690,16 @@ pub enum NonterminalKind {\n     Item,\n     Block,\n     Stmt,\n-    Pat,\n+    Pat2018 {\n+        /// Keep track of whether the user used `:pat2018` or `:pat` and we inferred it from the\n+        /// edition of the span. This is used for diagnostics.\n+        inferred: bool,\n+    },\n+    Pat2021 {\n+        /// Keep track of whether the user used `:pat2018` or `:pat` and we inferred it from the\n+        /// edition of the span. This is used for diagnostics.\n+        inferred: bool,\n+    },\n     Expr,\n     Ty,\n     Ident,\n@@ -703,12 +712,25 @@ pub enum NonterminalKind {\n }\n \n impl NonterminalKind {\n-    pub fn from_symbol(symbol: Symbol) -> Option<NonterminalKind> {\n+    /// The `edition` closure is used to get the edition for the given symbol. Doing\n+    /// `span.edition()` is expensive, so we do it lazily.\n+    pub fn from_symbol(\n+        symbol: Symbol,\n+        edition: impl FnOnce() -> Edition,\n+    ) -> Option<NonterminalKind> {\n         Some(match symbol {\n             sym::item => NonterminalKind::Item,\n             sym::block => NonterminalKind::Block,\n             sym::stmt => NonterminalKind::Stmt,\n-            sym::pat => NonterminalKind::Pat,\n+            sym::pat => match edition() {\n+                Edition::Edition2015 | Edition::Edition2018 => {\n+                    NonterminalKind::Pat2018 { inferred: true }\n+                }\n+                // FIXME(mark-i-m): uncomment when 2021 machinery is available.\n+                //Edition::Edition2021 => NonterminalKind::Pat2021{inferred:true},\n+            },\n+            sym::pat2018 => NonterminalKind::Pat2018 { inferred: false },\n+            sym::pat2021 => NonterminalKind::Pat2021 { inferred: false },\n             sym::expr => NonterminalKind::Expr,\n             sym::ty => NonterminalKind::Ty,\n             sym::ident => NonterminalKind::Ident,\n@@ -726,7 +748,10 @@ impl NonterminalKind {\n             NonterminalKind::Item => sym::item,\n             NonterminalKind::Block => sym::block,\n             NonterminalKind::Stmt => sym::stmt,\n-            NonterminalKind::Pat => sym::pat,\n+            NonterminalKind::Pat2018 { inferred: false } => sym::pat2018,\n+            NonterminalKind::Pat2021 { inferred: false } => sym::pat2021,\n+            NonterminalKind::Pat2018 { inferred: true }\n+            | NonterminalKind::Pat2021 { inferred: true } => sym::pat,\n             NonterminalKind::Expr => sym::expr,\n             NonterminalKind::Ty => sym::ty,\n             NonterminalKind::Ident => sym::ident,"}, {"sha": "e76cc6f1fed7bd4710de45006e832300bf0cf28b", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -77,9 +77,9 @@ use TokenTreeOrTokenTreeSlice::*;\n use crate::mbe::{self, TokenTree};\n \n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n-use rustc_parse::parser::{OrPatNonterminalMode, Parser};\n+use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n-use rustc_span::{edition::Edition, symbol::MacroRulesNormalizedIdent};\n+use rustc_span::symbol::MacroRulesNormalizedIdent;\n \n use smallvec::{smallvec, SmallVec};\n \n@@ -419,18 +419,6 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     }\n }\n \n-/// In edition 2015/18, `:pat` can only match `pat<no_top_alt>` because otherwise, we have\n-/// breakage. As of edition 2021, `:pat` matches `top_pat`.\n-///\n-/// See <https://github.com/rust-lang/rust/issues/54883> for more info.\n-fn or_pat_mode(edition: Edition) -> OrPatNonterminalMode {\n-    match edition {\n-        Edition::Edition2015 | Edition::Edition2018 => OrPatNonterminalMode::NoTopAlt,\n-        // FIXME(mark-i-m): uncomment this when edition 2021 machinery is added.\n-        // Edition::Edition2021 =>  OrPatNonterminalMode::TopPat,\n-    }\n-}\n-\n /// Process the matcher positions of `cur_items` until it is empty. In the process, this will\n /// produce more items in `next_items`, `eof_items`, and `bb_items`.\n ///\n@@ -578,14 +566,13 @@ fn inner_parse_loop<'root, 'tt>(\n \n                 // We need to match a metavar with a valid ident... call out to the black-box\n                 // parser by adding an item to `bb_items`.\n-                TokenTree::MetaVarDecl(span, _, Some(kind)) => {\n+                TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n                     // Built-in nonterminals never start with these tokens, so we can eliminate\n                     // them from consideration.\n                     //\n                     // We use the span of the metavariable declaration to determine any\n                     // edition-specific matching behavior for non-terminals.\n-                    if Parser::nonterminal_may_begin_with(kind, token, or_pat_mode(span.edition()))\n-                    {\n+                    if Parser::nonterminal_may_begin_with(kind, token) {\n                         bb_items.push(item);\n                     }\n                 }\n@@ -749,8 +736,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n                 let match_cur = item.match_cur;\n                 // We use the span of the metavariable declaration to determine any\n                 // edition-specific matching behavior for non-terminals.\n-                let nt = match parser.to_mut().parse_nonterminal(kind, or_pat_mode(span.edition()))\n-                {\n+                let nt = match parser.to_mut().parse_nonterminal(kind) {\n                     Err(mut err) => {\n                         err.span_label(\n                             span,"}, {"sha": "3d126749d541d184c92b8507bf8a2acda7febc94", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -476,10 +476,15 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt =\n-                            mbe::quoted::parse(tt.clone().into(), true, &sess.parse_sess, def.id)\n-                                .pop()\n-                                .unwrap();\n+                        let tt = mbe::quoted::parse(\n+                            tt.clone().into(),\n+                            true,\n+                            &sess.parse_sess,\n+                            def.id,\n+                            features,\n+                        )\n+                        .pop()\n+                        .unwrap();\n                         valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n@@ -501,6 +506,7 @@ pub fn compile_declarative_macro(\n                             false,\n                             &sess.parse_sess,\n                             def.id,\n+                            features,\n                         )\n                         .pop()\n                         .unwrap();\n@@ -1090,7 +1096,7 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            NonterminalKind::Pat => {\n+            NonterminalKind::Pat2018 { .. } | NonterminalKind::Pat2021 { .. } => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {"}, {"sha": "a4b44931fc1aeb0a66f73d8e1fc606de938516d8", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -5,8 +5,9 @@ use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream;\n use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n-use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_feature::Features;\n+use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_span::symbol::{kw, sym, Ident};\n \n use rustc_span::Span;\n \n@@ -29,10 +30,8 @@ const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n ///   `ident` are \"matchers\". They are not present in the body of a macro rule -- just in the\n ///   pattern, so we pass a parameter to indicate whether to expect them or not.\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n-/// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n-///   unstable features or not.\n-/// - `edition`: which edition are we in.\n-/// - `macro_node_id`: the NodeId of the macro we are parsing.\n+/// - `node_id`: the NodeId of the macro we are parsing.\n+/// - `features`: language features so we can do feature gating.\n ///\n /// # Returns\n ///\n@@ -42,6 +41,7 @@ pub(super) fn parse(\n     expect_matchers: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n+    features: &Features,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -52,7 +52,7 @@ pub(super) fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e., in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id);\n+        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id, features);\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -61,18 +61,39 @@ pub(super) fn parse(\n                             Some(tokenstream::TokenTree::Token(token)) => match token.ident() {\n                                 Some((frag, _)) => {\n                                     let span = token.span.with_lo(start_sp.lo());\n-                                    let kind = token::NonterminalKind::from_symbol(frag.name)\n-                                        .unwrap_or_else(|| {\n-                                            let msg = format!(\n-                                                \"invalid fragment specifier `{}`\",\n-                                                frag.name\n-                                            );\n-                                            sess.span_diagnostic\n-                                                .struct_span_err(span, &msg)\n-                                                .help(VALID_FRAGMENT_NAMES_MSG)\n+\n+                                    match frag.name {\n+                                        sym::pat2018 | sym::pat2021 => {\n+                                            if !features.edition_macro_pats {\n+                                                feature_err(\n+                                                    sess,\n+                                                    sym::edition_macro_pats,\n+                                                    frag.span,\n+                                                    \"`pat2018` and `pat2021` are unstable.\",\n+                                                )\n                                                 .emit();\n-                                            token::NonterminalKind::Ident\n-                                        });\n+                                            }\n+                                        }\n+                                        _ => {}\n+                                    }\n+\n+                                    let kind =\n+                                        token::NonterminalKind::from_symbol(frag.name, || {\n+                                            span.edition()\n+                                        })\n+                                        .unwrap_or_else(\n+                                            || {\n+                                                let msg = format!(\n+                                                    \"invalid fragment specifier `{}`\",\n+                                                    frag.name\n+                                                );\n+                                                sess.span_diagnostic\n+                                                    .struct_span_err(span, &msg)\n+                                                    .help(VALID_FRAGMENT_NAMES_MSG)\n+                                                    .emit();\n+                                                token::NonterminalKind::Ident\n+                                            },\n+                                        );\n                                     result.push(TokenTree::MetaVarDecl(span, ident, Some(kind)));\n                                     continue;\n                                 }\n@@ -110,14 +131,14 @@ pub(super) fn parse(\n ///   converting `tree`\n /// - `expect_matchers`: same as for `parse` (see above).\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n-/// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n-///   unstable features or not.\n+/// - `features`: language features so we can do feature gating.\n fn parse_tree(\n     tree: tokenstream::TokenTree,\n     outer_trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n+    features: &Features,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n@@ -145,7 +166,7 @@ fn parse_tree(\n                         sess.span_diagnostic.span_err(span.entire(), &msg);\n                     }\n                     // Parse the contents of the sequence itself\n-                    let sequence = parse(tts, expect_matchers, sess, node_id);\n+                    let sequence = parse(tts, expect_matchers, sess, node_id, features);\n                     // Get the Kleene operator and optional separator\n                     let (separator, kleene) =\n                         parse_sep_and_kleene_op(&mut trees, span.entire(), sess);\n@@ -196,7 +217,10 @@ fn parse_tree(\n         // descend into the delimited set and further parse it.\n         tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n             span,\n-            Lrc::new(Delimited { delim, tts: parse(tts, expect_matchers, sess, node_id) }),\n+            Lrc::new(Delimited {\n+                delim,\n+                tts: parse(tts, expect_matchers, sess, node_id, features),\n+            }),\n         ),\n     }\n }"}, {"sha": "c61857a1cd0ae46304df4285b6e26fe5cc55f780", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -620,6 +620,9 @@ declare_features! (\n     /// Allows arbitrary expressions in key-value attributes at parse time.\n     (active, extended_key_value_attributes, \"1.50.0\", Some(78835), None),\n \n+    /// `:pat2018` and `:pat2021` macro matchers.\n+    (active, edition_macro_pats, \"1.51.0\", Some(54883), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "d51a0fcbf09e4fbd2fe053487bfd6c4fcb3573eb", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -12,7 +12,6 @@ mod ty;\n use crate::lexer::UnmatchedBrace;\n pub use diagnostics::AttemptLocalParseRecovery;\n use diagnostics::Error;\n-pub use pat::OrPatNonterminalMode;\n pub use path::PathStyle;\n \n use rustc_ast::ptr::P;"}, {"sha": "eb5d7075f0081e6c8f75facd8db5b52041858aa3", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -4,19 +4,15 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n \n-use crate::parser::pat::{GateOr, OrPatNonterminalMode, RecoverComma};\n+use crate::parser::pat::{GateOr, RecoverComma};\n use crate::parser::{FollowedByType, Parser, PathStyle};\n \n impl<'a> Parser<'a> {\n     /// Checks whether a non-terminal may begin with a particular token.\n     ///\n     /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n     /// token. Be conservative (return true) if not sure.\n-    pub fn nonterminal_may_begin_with(\n-        kind: NonterminalKind,\n-        token: &Token,\n-        or_pat_mode: OrPatNonterminalMode,\n-    ) -> bool {\n+    pub fn nonterminal_may_begin_with(kind: NonterminalKind, token: &Token) -> bool {\n         /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n         fn may_be_ident(nt: &token::Nonterminal) -> bool {\n             match *nt {\n@@ -62,7 +58,7 @@ impl<'a> Parser<'a> {\n                 },\n                 _ => false,\n             },\n-            NonterminalKind::Pat => match token.kind {\n+            NonterminalKind::Pat2018 { .. } | NonterminalKind::Pat2021 { .. } => match token.kind {\n                 token::Ident(..) |                  // box, ref, mut, and other identifiers (can stricten)\n                 token::OpenDelim(token::Paren) |    // tuple pattern\n                 token::OpenDelim(token::Bracket) |  // slice pattern\n@@ -76,7 +72,7 @@ impl<'a> Parser<'a> {\n                 token::Lt |                         // path (UFCS constant)\n                 token::BinOp(token::Shl) => true,   // path (double UFCS)\n                 // leading vert `|` or-pattern\n-                token::BinOp(token::Or) =>  matches!(or_pat_mode, OrPatNonterminalMode::TopPat),\n+                token::BinOp(token::Or) =>  matches!(kind, NonterminalKind::Pat2021 {..}),\n                 token::Interpolated(ref nt) => may_be_ident(nt),\n                 _ => false,\n             },\n@@ -94,11 +90,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a non-terminal (e.g. MBE `:pat` or `:ident`).\n-    pub fn parse_nonterminal(\n-        &mut self,\n-        kind: NonterminalKind,\n-        or_pat_mode: OrPatNonterminalMode,\n-    ) -> PResult<'a, Nonterminal> {\n+    pub fn parse_nonterminal(&mut self, kind: NonterminalKind) -> PResult<'a, Nonterminal> {\n         // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n         // needs to have them force-captured here.\n         // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n@@ -141,12 +133,13 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n             }\n-            NonterminalKind::Pat => {\n-                let (mut pat, tokens) = self.collect_tokens(|this| match or_pat_mode {\n-                    OrPatNonterminalMode::TopPat => {\n+            NonterminalKind::Pat2018 { .. } | NonterminalKind::Pat2021 { .. } => {\n+                let (mut pat, tokens) = self.collect_tokens(|this| match kind {\n+                    NonterminalKind::Pat2018 { .. } => this.parse_pat(None),\n+                    NonterminalKind::Pat2021 { .. } => {\n                         this.parse_top_pat(GateOr::Yes, RecoverComma::No)\n                     }\n-                    OrPatNonterminalMode::NoTopAlt => this.parse_pat(None),\n+                    _ => unreachable!(),\n                 })?;\n                 // We have have eaten an NtPat, which could already have tokens\n                 if pat.tokens.is_none() {"}, {"sha": "456e32680fe5024dc4fc00b5b448a2faca8b8c94", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -31,13 +31,6 @@ pub(super) enum RecoverComma {\n     No,\n }\n \n-/// Used when parsing a non-terminal (see `parse_nonterminal`) to determine if `:pat` should match\n-/// `top_pat` or `pat<no_top_alt>`. See issue <https://github.com/rust-lang/rust/pull/78935>.\n-pub enum OrPatNonterminalMode {\n-    TopPat,\n-    NoTopAlt,\n-}\n-\n impl<'a> Parser<'a> {\n     /// Parses a pattern.\n     ///"}, {"sha": "eb3588d57752dca1c49acf4c36c8c48659d1676f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -470,6 +470,7 @@ symbols! {\n         dropck_parametricity,\n         dylib,\n         dyn_trait,\n+        edition_macro_pats,\n         eh_catch_typeinfo,\n         eh_personality,\n         emit_enum,\n@@ -808,6 +809,8 @@ symbols! {\n         partial_ord,\n         passes,\n         pat,\n+        pat2018,\n+        pat2021,\n         path,\n         pattern_parentheses,\n         phantom_data,"}, {"sha": "bd8a21ea36acd6212df2ed7b6759a53bc0148378", "filename": "src/test/ui/feature-gate-edition_macro_pats.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/src%2Ftest%2Fui%2Ffeature-gate-edition_macro_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/src%2Ftest%2Fui%2Ffeature-gate-edition_macro_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-edition_macro_pats.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -0,0 +1,8 @@\n+// Feature gate test for `edition_macro_pats` feature.\n+\n+macro_rules! foo {\n+    ($x:pat2018) => {}; //~ERROR `pat2018` and `pat2021` are unstable\n+    ($x:pat2021) => {}; //~ERROR `pat2018` and `pat2021` are unstable\n+}\n+\n+fn main() {}"}, {"sha": "89bfb239d9ecaa7d99507b5bfc5a3016f668eb27", "filename": "src/test/ui/feature-gate-edition_macro_pats.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/src%2Ftest%2Fui%2Ffeature-gate-edition_macro_pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/src%2Ftest%2Fui%2Ffeature-gate-edition_macro_pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-edition_macro_pats.stderr?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -0,0 +1,21 @@\n+error[E0658]: `pat2018` and `pat2021` are unstable.\n+  --> $DIR/feature-gate-edition_macro_pats.rs:4:9\n+   |\n+LL |     ($x:pat2018) => {};\n+   |         ^^^^^^^\n+   |\n+   = note: see issue #54883 <https://github.com/rust-lang/rust/issues/54883> for more information\n+   = help: add `#![feature(edition_macro_pats)]` to the crate attributes to enable\n+\n+error[E0658]: `pat2018` and `pat2021` are unstable.\n+  --> $DIR/feature-gate-edition_macro_pats.rs:5:9\n+   |\n+LL |     ($x:pat2021) => {};\n+   |         ^^^^^^^\n+   |\n+   = note: see issue #54883 <https://github.com/rust-lang/rust/issues/54883> for more information\n+   = help: add `#![feature(edition_macro_pats)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ea1f9bff6bf7063d647ea50bf5236419ec158f95", "filename": "src/test/ui/macros/edition-macro-pats.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40bf3c0f09240836d55431165f20cf221816c958/src%2Ftest%2Fui%2Fmacros%2Fedition-macro-pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bf3c0f09240836d55431165f20cf221816c958/src%2Ftest%2Fui%2Fmacros%2Fedition-macro-pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fedition-macro-pats.rs?ref=40bf3c0f09240836d55431165f20cf221816c958", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+\n+#![feature(or_patterns)]\n+#![feature(edition_macro_pats)]\n+\n+macro_rules! foo {\n+    (a $x:pat2018) => {};\n+    (b $x:pat2021) => {};\n+}\n+\n+fn main() {\n+    foo!(a None);\n+    foo!(b 1 | 2);\n+}"}]}