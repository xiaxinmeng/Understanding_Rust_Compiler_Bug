{"sha": "f24d0354f95615731d49a993adf2ea2983b661c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNGQwMzU0Zjk1NjE1NzMxZDQ5YTk5M2FkZjJlYTI5ODNiNjYxYzE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-01-05T11:59:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-01-07T14:10:22Z"}, "message": "rewrite RangeMap to use a sorted Vec instead of a RangeMap\n\nThis gives us a 20% perf improve for the benchmark from https://github.com/solson/miri/issues/593", "tree": {"sha": "46c90896fc98051f9379cc7b0ba641670eaae93d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46c90896fc98051f9379cc7b0ba641670eaae93d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f24d0354f95615731d49a993adf2ea2983b661c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f24d0354f95615731d49a993adf2ea2983b661c1", "html_url": "https://github.com/rust-lang/rust/commit/f24d0354f95615731d49a993adf2ea2983b661c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f24d0354f95615731d49a993adf2ea2983b661c1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c9e702d9bdcef31a73949617cf5cb53c94c5dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9e702d9bdcef31a73949617cf5cb53c94c5dcb", "html_url": "https://github.com/rust-lang/rust/commit/6c9e702d9bdcef31a73949617cf5cb53c94c5dcb"}], "stats": {"total": 253, "additions": 127, "deletions": 126}, "files": [{"sha": "5b7a940329b097810b845810acfe0a8faa4724be", "filename": "src/range_map.rs", "status": "modified", "additions": 127, "deletions": 126, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/f24d0354f95615731d49a993adf2ea2983b661c1/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24d0354f95615731d49a993adf2ea2983b661c1/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=f24d0354f95615731d49a993adf2ea2983b661c1", "patch": "@@ -6,62 +6,29 @@\n //! necessary (e.g. when [0,5) is first associated with X, and then [1,2) is mutated).\n //! Users must not depend on whether a range is coalesced or not, even though this is observable\n //! via the iteration APIs.\n-use std::collections::BTreeMap;\n+\n use std::ops;\n+use std::num::NonZeroU64;\n \n use rustc::ty::layout::Size;\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct RangeMap<T> {\n-    map: BTreeMap<Range, T>,\n+// Representation: offset-length-data tuples, sorted by offset.\n+#[derive(Clone, Debug)]\n+struct Elem<T> {\n+    offset: u64,\n+    len: NonZeroU64,\n+    data: T,\n }\n-\n-// The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n-// by the second field.\n-// This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n-// `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n-// At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n-// This kind of search breaks, if `end < start`, so don't do that!\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n-struct Range {\n-    start: u64,\n-    end: u64, // Invariant: end > start\n+// Length is always > 0.\n+#[derive(Clone, Debug)]\n+pub struct RangeMap<T> {\n+    v: Vec<Elem<T>>,\n }\n \n-impl Range {\n-    /// Compute a range of ranges that contains all ranges overlaping with [offset, offset+len)\n-    fn range(offset: u64, len: u64) -> ops::Range<Range> {\n-        if len == 0 {\n-            // We can produce an empty range, nothing overlaps with this.\n-            let r = Range { start: 0, end: 1 };\n-            return r..r;\n-        }\n-        // We select all elements that are within\n-        // the range given by the offset into the allocation and the length.\n-        // This is sound if all ranges that intersect with the argument range, are in the\n-        // resulting range of ranges.\n-        let left = Range {\n-            // lowest range to include `offset`\n-            start: 0,\n-            end: offset + 1,\n-        };\n-        let right = Range {\n-            // lowest (valid) range not to include `offset+len`\n-            start: offset + len,\n-            end: offset + len + 1,\n-        };\n-        left..right\n-    }\n-\n-    /// Tests if any element of [offset, offset+len) is contained in this range.\n+impl<T> Elem<T> {\n     #[inline(always)]\n-    fn overlaps(&self, offset: u64, len: u64) -> bool {\n-        if len == 0 {\n-            // `offset` totally does not matter, we cannot overlap with an empty interval\n-            false\n-        } else {\n-            offset < self.end && offset.checked_add(len).unwrap() >= self.start\n-        }\n+    fn contains(&self, offset: u64) -> bool {\n+        offset >= self.offset && offset < self.offset + self.len.get()\n     }\n }\n \n@@ -70,73 +37,95 @@ impl<T> RangeMap<T> {\n     /// the entire range.\n     #[inline(always)]\n     pub fn new(size: Size, init: T) -> RangeMap<T> {\n-        let mut map = RangeMap { map: BTreeMap::new() };\n-        if size.bytes() > 0 {\n-            map.map.insert(Range { start: 0, end: size.bytes() }, init);\n+        let size = size.bytes();\n+        let mut map = RangeMap { v: Vec::new() };\n+        if size > 0 {\n+            map.v.push(Elem {\n+                offset: 0,\n+                len: NonZeroU64::new(size).unwrap(),\n+                data: init\n+            });\n         }\n         map\n     }\n \n-    fn iter_with_range<'a>(\n-        &'a self,\n-        offset: u64,\n-        len: u64,\n-    ) -> impl Iterator<Item = (&'a Range, &'a T)> + 'a {\n-        self.map.range(Range::range(offset, len)).filter_map(\n-            move |(range, data)| {\n-                debug_assert!(len > 0);\n-                if range.overlaps(offset, len) {\n-                    Some((range, data))\n-                } else {\n-                    None\n-                }\n-            },\n-        )\n+    /// Find the index containing the given offset.\n+    fn find_offset(&self, offset: u64) -> usize {\n+        debug_assert!(self.v.len() > 0);\n+        let mut left = 0usize; // inclusive\n+        let mut right = self.v.len(); // exclusive\n+        loop {\n+            let candidate = left.checked_add(right).unwrap() / 2;\n+            let elem = &self.v[candidate];\n+            if elem.offset > offset {\n+                // we are too far right (offset is further left)\n+                debug_assert!(candidate < right); // we are making progress\n+                right = candidate;\n+            } else if offset >= elem.offset + elem.len.get() {\n+                // we are too far left (offset is further right)\n+                debug_assert!(candidate >= left); // we are making progress\n+                left = candidate+1;\n+                debug_assert!(left < right, \"find_offset: offset {} is out-of-bounds\", offset);\n+            } else {\n+                // This is it!\n+                return candidate;\n+            }\n+        }\n     }\n \n     /// Provide read-only iteration over everything in the given range.  This does\n     /// *not* split items if they overlap with the edges.  Do not use this to mutate\n     /// through interior mutability.\n     pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = &'a T> + 'a {\n-        self.iter_with_range(offset.bytes(), len.bytes()).map(|(_, data)| data)\n+        let offset = offset.bytes();\n+        let len = len.bytes();\n+        // Compute a slice starting with the elements we care about\n+        let slice: &[Elem<T>] = if len == 0 {\n+                // We just need any empty iterator.  We don't even want to\n+                // yield the element that surrounds this position.\n+                &[]\n+            } else {\n+                let first = self.find_offset(offset);\n+                &self.v[first..]\n+            };\n+        let end = offset + len; // the first offset that is not included any more\n+        slice.iter()\n+            .take_while(move |elem| elem.offset < end)\n+            .map(|elem| &elem.data)\n     }\n \n     pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n-        self.map.values_mut()\n+        self.v.iter_mut().map(|elem| &mut elem.data)\n     }\n \n-    fn split_entry_at(&mut self, offset: u64)\n+    // Split the element situated at the given `index`, such that the 2nd one starts at offset `split_offset`.\n+    // Do nothing if the element already starts there.\n+    // Return whether a split was necessary.\n+    fn split_index(&mut self, index: usize, split_offset: u64) -> bool\n     where\n         T: Clone,\n     {\n-        let range = match self.iter_with_range(offset, 1).next() {\n-            Some((&range, _)) => range,\n-            None => return,\n-        };\n-        assert!(\n-            range.start <= offset && range.end > offset,\n-            \"We got a range that doesn't even contain what we asked for.\"\n-        );\n-        // There is an entry overlapping this position, see if we have to split it\n-        if range.start < offset {\n-            let data = self.map.remove(&range).unwrap();\n-            let old = self.map.insert(\n-                Range {\n-                    start: range.start,\n-                    end: offset,\n-                },\n-                data.clone(),\n-            );\n-            assert!(old.is_none());\n-            let old = self.map.insert(\n-                Range {\n-                    start: offset,\n-                    end: range.end,\n-                },\n-                data,\n-            );\n-            assert!(old.is_none());\n+        let elem = &mut self.v[index];\n+        let first_len = split_offset.checked_sub(elem.offset)\n+            .expect(\"The split_offset is before the element to be split\");\n+        assert!(first_len <= elem.len.get(),\n+            \"The split_offset is after the element to be split\");\n+        if first_len == 0 || first_len == elem.len.get() {\n+            // Nothing to do\n+            return false;\n         }\n+\n+        // Now we really have to split.  Reduce length of first element.\n+        let second_len = elem.len.get() - first_len;\n+        elem.len = NonZeroU64::new(first_len).unwrap();\n+        // Copy the data, and insert 2nd element\n+        let second = Elem {\n+            offset: split_offset,\n+            len: NonZeroU64::new(second_len).unwrap(),\n+            data: elem.data.clone(),\n+        };\n+        self.v.insert(index+1, second);\n+        return true;\n     }\n \n     /// Provide mutable iteration over everything in the given range.  As a side-effect,\n@@ -152,28 +141,43 @@ impl<T> RangeMap<T> {\n     {\n         let offset = offset.bytes();\n         let len = len.bytes();\n-\n-        if len > 0 {\n-            // Preparation: Split first and last entry as needed.\n-            self.split_entry_at(offset);\n-            self.split_entry_at(offset + len);\n-        }\n-        // Now we can provide a mutable iterator\n-        self.map.range_mut(Range::range(offset, len)).filter_map(\n-            move |(&range, data)| {\n-                debug_assert!(len > 0);\n-                if range.overlaps(offset, len) {\n-                    assert!(\n-                        offset <= range.start && offset + len >= range.end,\n-                        \"The splitting went wrong\"\n-                    );\n-                    Some(data)\n-                } else {\n-                    // Skip this one\n-                    None\n+        // Compute a slice containing exactly the elements we care about\n+        let slice: &mut [Elem<T>] = if len == 0 {\n+                // We just need any empty iterator.  We don't even want to\n+                // yield the element that surrounds this position, nor do\n+                // any splitting.\n+                &mut []\n+            } else {\n+                // Make sure we got a clear beginning\n+                let mut first = self.find_offset(offset);\n+                if self.split_index(first, offset) {\n+                    // The newly created 2nd element is ours\n+                    first += 1;\n+                }\n+                let first = first; // no more mutation\n+                // Find our end.  Linear scan, but that's okay because the iteration\n+                // is doing the same linear scan anyway -- no increase in complexity.\n+                let mut end = first; // the last element to be included\n+                loop {\n+                    let elem = &self.v[end];\n+                    if elem.offset+elem.len.get() < offset+len {\n+                        // We need to scan further.\n+                        end += 1;\n+                        debug_assert!(end < self.v.len(), \"iter_mut: end-offset {} is out-of-bounds\", offset+len);\n+                    } else {\n+                        // `elem` is the last included element.  Stop search.\n+                        break;\n+                    }\n                 }\n-            },\n-        )\n+                let end = end; // no more mutation\n+                // We need to split the end as well.  Even if this performs a\n+                // split, we don't have to adjust our index as we only care about\n+                // the first part of the split.\n+                self.split_index(end, offset+len);\n+                // Now we yield the slice. `end` is inclusive.\n+                &mut self.v[first..=end]\n+            };\n+        slice.iter_mut().map(|elem| &mut elem.data)\n     }\n }\n \n@@ -203,7 +207,7 @@ mod tests {\n         }\n         // Check\n         assert_eq!(to_vec(&map, 10, 1), vec![42]);\n-        assert_eq!(map.map.len(), 3);\n+        assert_eq!(map.v.len(), 3);\n \n         // Insert with size 0\n         for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n@@ -213,7 +217,7 @@ mod tests {\n             *x = 19;\n         }\n         assert_eq!(to_vec(&map, 10, 2), vec![42, -1]);\n-        assert_eq!(map.map.len(), 3);\n+        assert_eq!(map.v.len(), 3);\n     }\n \n     #[test]\n@@ -225,7 +229,7 @@ mod tests {\n         for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n             *x = 43;\n         }\n-        assert_eq!(map.map.len(), 5);\n+        assert_eq!(map.v.len(), 5);\n         assert_eq!(\n             to_vec(&map, 10, 10),\n             vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]\n@@ -236,22 +240,19 @@ mod tests {\n                 *x = 23;\n             }\n         }\n-        assert_eq!(map.map.len(), 6);\n+        assert_eq!(map.v.len(), 6);\n \n         assert_eq!(\n             to_vec(&map, 10, 10),\n             vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]\n         );\n         assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 43, 23, 23]);\n \n-        // Now request a range that goes beyond the initial size\n-        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(10)) {\n+        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {\n             *x = 19;\n         }\n-        assert_eq!(map.map.len(), 6);\n+        assert_eq!(map.v.len(), 6);\n         assert_eq!(map.iter(Size::from_bytes(19), Size::from_bytes(1))\n             .map(|&t| t).collect::<Vec<_>>(), vec![19]);\n-        assert_eq!(map.iter(Size::from_bytes(20), Size::from_bytes(1))\n-            .map(|&t| t).collect::<Vec<_>>(), vec![]);\n     }\n }"}]}