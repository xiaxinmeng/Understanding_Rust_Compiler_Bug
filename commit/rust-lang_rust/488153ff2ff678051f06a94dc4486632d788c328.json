{"sha": "488153ff2ff678051f06a94dc4486632d788c328", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ODE1M2ZmMmZmNjc4MDUxZjA2YTk0ZGM0NDg2NjMyZDc4OGMzMjg=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-01-15T09:56:44Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-01-15T09:56:44Z"}, "message": "Merge commit '953f024793dab92745fee9cd2c4dee6a60451771' into clippyup", "tree": {"sha": "079c80170f184cdee4176c73994a298a27c02e50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/079c80170f184cdee4176c73994a298a27c02e50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/488153ff2ff678051f06a94dc4486632d788c328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/488153ff2ff678051f06a94dc4486632d788c328", "html_url": "https://github.com/rust-lang/rust/commit/488153ff2ff678051f06a94dc4486632d788c328", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/488153ff2ff678051f06a94dc4486632d788c328/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b3af4145b62781f6f8cf0b003cfd81780b608ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b3af4145b62781f6f8cf0b003cfd81780b608ec", "html_url": "https://github.com/rust-lang/rust/commit/7b3af4145b62781f6f8cf0b003cfd81780b608ec"}], "stats": {"total": 2576, "additions": 2328, "deletions": 248}, "files": [{"sha": "64864c2e2780dbee9ad45976b4c978f744a46265", "filename": "CHANGELOG.md", "status": "modified", "additions": 134, "deletions": 3, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -6,11 +6,138 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[b20d4c1...master](https://github.com/rust-lang/rust-clippy/compare/b20d4c1...master)\n+[4911ab1...master](https://github.com/rust-lang/rust-clippy/compare/4911ab1...master)\n+\n+## Rust 1.50\n+\n+Current beta, release 2021-02-11\n+\n+[b20d4c1...4911ab1](https://github.com/rust-lang/rust-clippy/compare/b20d4c1...4911ab1)\n+\n+### New Lints\n+\n+* [`suspicious_operation_groupings`] [#6086](https://github.com/rust-lang/rust-clippy/pull/6086)\n+* [`size_of_in_element_count`] [#6394](https://github.com/rust-lang/rust-clippy/pull/6394)\n+* [`unnecessary_wraps`] [#6070](https://github.com/rust-lang/rust-clippy/pull/6070)\n+* [`let_underscore_drop`] [#6305](https://github.com/rust-lang/rust-clippy/pull/6305)\n+* [`collapsible_match`] [#6402](https://github.com/rust-lang/rust-clippy/pull/6402)\n+* [`redundant_else`] [#6330](https://github.com/rust-lang/rust-clippy/pull/6330)\n+* [`zero_sized_map_values`] [#6218](https://github.com/rust-lang/rust-clippy/pull/6218)\n+* [`print_stderr`] [#6367](https://github.com/rust-lang/rust-clippy/pull/6367)\n+* [`string_from_utf8_as_bytes`] [#6134](https://github.com/rust-lang/rust-clippy/pull/6134)\n+\n+### Moves and Deprecations\n+\n+* Previously deprecated [`str_to_string`] and [`string_to_string`] have been un-deprecated\n+  as `restriction` lints [#6333](https://github.com/rust-lang/rust-clippy/pull/6333)\n+* Deprecate [`panic_params`] lint. This is now available in rustc as `panic_fmt`\n+  [#6351](https://github.com/rust-lang/rust-clippy/pull/6351)\n+* Move [`map_err_ignore`] to `restriction`\n+  [#6416](https://github.com/rust-lang/rust-clippy/pull/6416)\n+* Move [`await_holding_refcell_ref`] to `pedantic`\n+  [#6354](https://github.com/rust-lang/rust-clippy/pull/6354)\n+* Move [`await_holding_lock`] to `pedantic`\n+  [#6354](https://github.com/rust-lang/rust-clippy/pull/6354)\n+\n+### Enhancements\n+\n+* Add the `unreadable-literal-lint-fractions` configuration to disable\n+  the `unreadable_literal` lint for fractions\n+  [#6421](https://github.com/rust-lang/rust-clippy/pull/6421)\n+* [`clone_on_copy`]: Now shows the type in the lint message\n+  [#6443](https://github.com/rust-lang/rust-clippy/pull/6443)\n+* [`redundant_pattern_matching`]: Now also lints on `std::task::Poll`\n+  [#6339](https://github.com/rust-lang/rust-clippy/pull/6339)\n+* [`redundant_pattern_matching`]: Additionally also lints on `std::net::IpAddr`\n+  [#6377](https://github.com/rust-lang/rust-clippy/pull/6377)\n+* [`search_is_some`]: Now suggests `contains` instead of `find(foo).is_some()`\n+  [#6119](https://github.com/rust-lang/rust-clippy/pull/6119)\n+* [`clone_double_ref`]: Now prints the reference type in the lint message\n+  [#6442](https://github.com/rust-lang/rust-clippy/pull/6442)\n+* [`modulo_one`]: Now also lints on -1.\n+  [#6360](https://github.com/rust-lang/rust-clippy/pull/6360)\n+* [`empty_loop`]: Now lints no_std crates, too\n+  [#6205](https://github.com/rust-lang/rust-clippy/pull/6205)\n+* [`or_fun_call`]: Now also lints when indexing `HashMap` or `BTreeMap`\n+  [#6267](https://github.com/rust-lang/rust-clippy/pull/6267)\n+* [`wrong_self_convention`]: Now also lints in trait definitions\n+  [#6316](https://github.com/rust-lang/rust-clippy/pull/6316)\n+* [`needless_borrow`]: Print the type in the lint message\n+  [#6449](https://github.com/rust-lang/rust-clippy/pull/6449)\n+\n+[msrv_readme]: https://github.com/rust-lang/rust-clippy#specifying-the-minimum-supported-rust-version\n+\n+### False Positive Fixes\n+\n+* [`manual_range_contains`]: No longer lints in `const fn`\n+  [#6382](https://github.com/rust-lang/rust-clippy/pull/6382)\n+* [`unnecessary_lazy_evaluations`]: No longer lints if closure argument is used\n+  [#6370](https://github.com/rust-lang/rust-clippy/pull/6370)\n+* [`match_single_binding`]: Now ignores cases with `#[cfg()]` macros\n+  [#6435](https://github.com/rust-lang/rust-clippy/pull/6435)\n+* [`match_like_matches_macro`]: No longer lints on arms with attributes\n+  [#6290](https://github.com/rust-lang/rust-clippy/pull/6290)\n+* [`map_clone`]: No longer lints with deref and clone\n+  [#6269](https://github.com/rust-lang/rust-clippy/pull/6269)\n+* [`map_clone`]: No longer lints in the case of &mut\n+  [#6301](https://github.com/rust-lang/rust-clippy/pull/6301)\n+* [`needless_update`]: Now ignores `non_exhaustive` structs\n+  [#6464](https://github.com/rust-lang/rust-clippy/pull/6464)\n+* [`needless_collect`]: No longer lints when a collect is needed multiple times\n+  [#6313](https://github.com/rust-lang/rust-clippy/pull/6313)\n+* [`unnecessary_cast`] No longer lints cfg-dependent types\n+  [#6369](https://github.com/rust-lang/rust-clippy/pull/6369)\n+* [`declare_interior_mutable_const`] and [`borrow_interior_mutable_const`]:\n+  Both now ignore enums with frozen variants\n+  [#6110](https://github.com/rust-lang/rust-clippy/pull/6110)\n+\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`vec_box`]: Provide correct type scope suggestion\n+  [#6271](https://github.com/rust-lang/rust-clippy/pull/6271)\n+* [`manual_range_contains`]: Give correct suggestion when using floats\n+  [#6320](https://github.com/rust-lang/rust-clippy/pull/6320)\n+* [`unnecessary_lazy_evaluations`]: Don't always mark suggestion as MachineApplicable\n+  [#6272](https://github.com/rust-lang/rust-clippy/pull/6272)\n+* [`manual_async_fn`]: Improve suggestion formatting\n+  [#6294](https://github.com/rust-lang/rust-clippy/pull/6294)\n+* [`unnecessary_cast`]: Fix incorrectly formatted float literal suggestion\n+  [#6362](https://github.com/rust-lang/rust-clippy/pull/6362)\n+\n+### ICE Fixes\n+\n+* Fix a crash in [`from_iter_instead_of_collect`]\n+  [#6304](https://github.com/rust-lang/rust-clippy/pull/6304)\n+* Fix a silent crash when parsing doc comments in [`needless_doctest_main`]\n+  [#6458](https://github.com/rust-lang/rust-clippy/pull/6458)\n+\n+### Documentation Improvements\n+\n+* The lint website search has been improved ([#6477](https://github.com/rust-lang/rust-clippy/pull/6477)):\n+  * Searching for lints with dashes and spaces is possible now. For example\n+    `missing-errors-doc` and `missing errors doc` are now valid aliases for lint names\n+  * Improved fuzzy search in lint descriptions\n+* Various README improvements\n+  [#6287](https://github.com/rust-lang/rust-clippy/pull/6287)\n+* Add known problems to [`comparison_chain`] documentation\n+  [#6390](https://github.com/rust-lang/rust-clippy/pull/6390)\n+* Fix example used in [`cargo_common_metadata`]\n+  [#6293](https://github.com/rust-lang/rust-clippy/pull/6293)\n+* Improve [`map_clone`] documentation\n+  [#6340](https://github.com/rust-lang/rust-clippy/pull/6340)\n+\n+### Others\n+\n+* You can now tell Clippy about the MSRV your project supports. Please refer to\n+  the specific README section to learn more about MSRV support [here][msrv_readme]\n+  [#6201](https://github.com/rust-lang/rust-clippy/pull/6201)\n+* Add `--no-deps` option to avoid running on path dependencies in workspaces\n+  [#6188](https://github.com/rust-lang/rust-clippy/pull/6188)\n \n ## Rust 1.49\n \n-Current beta, release 2020-12-31\n+Current stable, released 2020-12-31\n \n [e636b88...b20d4c1](https://github.com/rust-lang/rust-clippy/compare/e636b88...b20d4c1)\n \n@@ -116,7 +243,7 @@ Current beta, release 2020-12-31\n \n ## Rust 1.48\n \n-Current stable, released 2020-11-19\n+Released 2020-11-19\n \n [09bd400...e636b88](https://github.com/rust-lang/rust-clippy/compare/09bd400...e636b88)\n \n@@ -1769,6 +1896,7 @@ Released 2018-09-13\n [`cmp_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_null\n [`cmp_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_owned\n [`cognitive_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity\n+[`collapsible_else_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\n [`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n [`collapsible_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_match\n [`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n@@ -1973,6 +2101,7 @@ Released 2018-09-13\n [`needless_doctest_main`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n+[`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n [`needless_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_range_loop\n [`needless_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_return\n [`needless_update`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_update\n@@ -2012,6 +2141,7 @@ Released 2018-09-13\n [`print_with_newline`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_with_newline\n [`println_empty_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#println_empty_string\n [`ptr_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg\n+[`ptr_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_as_ptr\n [`ptr_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_eq\n [`ptr_offset_with_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_offset_with_cast\n [`pub_enum_variant_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#pub_enum_variant_names\n@@ -2152,6 +2282,7 @@ Released 2018-09-13\n [`useless_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n [`useless_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_vec\n [`vec_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#vec_box\n+[`vec_init_then_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#vec_init_then_push\n [`vec_resize_to_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#vec_resize_to_zero\n [`verbose_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#verbose_bit_mask\n [`verbose_file_reads`]: https://rust-lang.github.io/rust-clippy/master/index.html#verbose_file_reads"}, {"sha": "b877806946cfeb0435b5d348368ff3505e2cb414", "filename": "clippy_dev/src/bless.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fbless.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -5,7 +5,7 @@ use std::env;\n use std::ffi::OsStr;\n use std::fs;\n use std::lazy::SyncLazy;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use walkdir::WalkDir;\n \n use crate::clippy_project_root;\n@@ -16,27 +16,41 @@ pub static CARGO_TARGET_DIR: SyncLazy<PathBuf> = SyncLazy::new(|| match env::var\n     None => env::current_dir().unwrap().join(\"target\"),\n });\n \n-pub fn bless() {\n-    let test_dirs = [\n+static CLIPPY_BUILD_TIME: SyncLazy<Option<std::time::SystemTime>> = SyncLazy::new(|| {\n+    let profile = env::var(\"PROFILE\").unwrap_or_else(|_| \"debug\".to_string());\n+    let mut path = PathBuf::from(&**CARGO_TARGET_DIR);\n+    path.push(profile);\n+    path.push(\"cargo-clippy\");\n+    fs::metadata(path).ok()?.modified().ok()\n+});\n+\n+pub fn bless(ignore_timestamp: bool) {\n+    let test_suite_dirs = [\n         clippy_project_root().join(\"tests\").join(\"ui\"),\n+        clippy_project_root().join(\"tests\").join(\"ui-internal\"),\n         clippy_project_root().join(\"tests\").join(\"ui-toml\"),\n         clippy_project_root().join(\"tests\").join(\"ui-cargo\"),\n     ];\n-    for test_dir in &test_dirs {\n-        WalkDir::new(test_dir)\n+    for test_suite_dir in &test_suite_dirs {\n+        WalkDir::new(test_suite_dir)\n             .into_iter()\n             .filter_map(Result::ok)\n             .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n             .for_each(|f| {\n-                update_reference_file(f.path().with_extension(\"stdout\"));\n-                update_reference_file(f.path().with_extension(\"stderr\"));\n-                update_reference_file(f.path().with_extension(\"fixed\"));\n+                let test_name = f.path().strip_prefix(test_suite_dir).unwrap();\n+                for &ext in &[\"stdout\", \"stderr\", \"fixed\"] {\n+                    update_reference_file(\n+                        f.path().with_extension(ext),\n+                        test_name.with_extension(ext),\n+                        ignore_timestamp,\n+                    );\n+                }\n             });\n     }\n }\n \n-fn update_reference_file(reference_file_path: PathBuf) {\n-    let test_output_path = build_dir().join(PathBuf::from(reference_file_path.file_name().unwrap()));\n+fn update_reference_file(reference_file_path: PathBuf, test_name: PathBuf, ignore_timestamp: bool) {\n+    let test_output_path = build_dir().join(test_name);\n     let relative_reference_file_path = reference_file_path.strip_prefix(clippy_project_root()).unwrap();\n \n     // If compiletest did not write any changes during the test run,\n@@ -45,6 +59,11 @@ fn update_reference_file(reference_file_path: PathBuf) {\n         return;\n     }\n \n+    // If the test output was not updated since the last clippy build, it may be outdated\n+    if !ignore_timestamp && !updated_since_clippy_build(&test_output_path).unwrap_or(true) {\n+        return;\n+    }\n+\n     let test_output_file = fs::read(&test_output_path).expect(\"Unable to read test output file\");\n     let reference_file = fs::read(&reference_file_path).unwrap_or_default();\n \n@@ -64,6 +83,12 @@ fn update_reference_file(reference_file_path: PathBuf) {\n     }\n }\n \n+fn updated_since_clippy_build(path: &Path) -> Option<bool> {\n+    let clippy_build_time = (*CLIPPY_BUILD_TIME)?;\n+    let modified = fs::metadata(path).ok()?.modified().ok()?;\n+    Some(modified >= clippy_build_time)\n+}\n+\n fn build_dir() -> PathBuf {\n     let profile = env::var(\"PROFILE\").unwrap_or_else(|_| \"debug\".to_string());\n     let mut path = PathBuf::new();"}, {"sha": "2ea56c42fafd62316adc779fa60b5922b70ced30", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -7,8 +7,8 @@ fn main() {\n     let matches = get_clap_config();\n \n     match matches.subcommand() {\n-        (\"bless\", Some(_)) => {\n-            bless::bless();\n+        (\"bless\", Some(matches)) => {\n+            bless::bless(matches.is_present(\"ignore-timestamp\"));\n         },\n         (\"fmt\", Some(matches)) => {\n             fmt::run(matches.is_present(\"check\"), matches.is_present(\"verbose\"));\n@@ -47,7 +47,15 @@ fn main() {\n \n fn get_clap_config<'a>() -> ArgMatches<'a> {\n     App::new(\"Clippy developer tooling\")\n-        .subcommand(SubCommand::with_name(\"bless\").about(\"bless the test output changes\"))\n+        .subcommand(\n+            SubCommand::with_name(\"bless\")\n+                .about(\"bless the test output changes\")\n+                .arg(\n+                    Arg::with_name(\"ignore-timestamp\")\n+                        .long(\"ignore-timestamp\")\n+                        .help(\"Include files updated before clippy was built\"),\n+                ),\n+        )\n         .subcommand(\n             SubCommand::with_name(\"fmt\")\n                 .about(\"Run rustfmt on all projects and tests\")"}, {"sha": "9a00fc535fc5c297f818bb4614599c6c227816cb", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -399,7 +399,7 @@ fn extract_clippy_lint(lint: &NestedMetaItem) -> Option<SymbolStr> {\n         if let Some(meta_item) = lint.meta_item();\n         if meta_item.path.segments.len() > 1;\n         if let tool_name = meta_item.path.segments[0].ident;\n-        if tool_name.as_str() == \"clippy\";\n+        if tool_name.name == sym::clippy;\n         let lint_name = meta_item.path.segments.last().unwrap().ident.name;\n         then {\n             return Some(lint_name.as_str());"}, {"sha": "93ccc76d0c9cdf829ed63b09cae07f21ad6c073d", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -23,9 +23,7 @@ use rustc_errors::Applicability;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for nested `if` statements which can be collapsed\n-    /// by `&&`-combining their conditions and for `else { if ... }` expressions\n-    /// that\n-    /// can be collapsed to `else if ...`.\n+    /// by `&&`-combining their conditions.\n     ///\n     /// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n     /// makes code look more complex than it really is.\n@@ -40,7 +38,31 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     ///\n-    /// // or\n+    /// ```\n+    ///\n+    /// Should be written:\n+    ///\n+    /// ```rust.ignore\n+    /// if x && y {\n+    ///     \u2026\n+    /// }\n+    /// ```\n+    pub COLLAPSIBLE_IF,\n+    style,\n+    \"nested `if`s that can be collapsed (e.g., `if x { if y { ... } }`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for collapsible `else { if ... }` expressions\n+    /// that can be collapsed to `else if ...`.\n+    ///\n+    /// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n+    /// makes code look more complex than it really is.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n     ///\n     /// if x {\n     ///     \u2026\n@@ -54,24 +76,18 @@ declare_clippy_lint! {\n     /// Should be written:\n     ///\n     /// ```rust.ignore\n-    /// if x && y {\n-    ///     \u2026\n-    /// }\n-    ///\n-    /// // or\n-    ///\n     /// if x {\n     ///     \u2026\n     /// } else if y {\n     ///     \u2026\n     /// }\n     /// ```\n-    pub COLLAPSIBLE_IF,\n+    pub COLLAPSIBLE_ELSE_IF,\n     style,\n-    \"`if`s that can be collapsed (e.g., `if x { if y { ... } }` and `else { if x { ... } }`)\"\n+    \"nested `else`-`if` expressions that can be collapsed (e.g., `else { if x { ... } }`)\"\n }\n \n-declare_lint_pass!(CollapsibleIf => [COLLAPSIBLE_IF]);\n+declare_lint_pass!(CollapsibleIf => [COLLAPSIBLE_IF, COLLAPSIBLE_ELSE_IF]);\n \n impl EarlyLintPass for CollapsibleIf {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n@@ -112,7 +128,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n-                COLLAPSIBLE_IF,\n+                COLLAPSIBLE_ELSE_IF,\n                 block.span,\n                 \"this `else { if .. }` block can be collapsed\",\n                 \"collapse nested if block\","}, {"sha": "90d31dece13113ae9d2c64711211df9b1c67553a", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -13,7 +13,7 @@ declare_clippy_lint! {\n     /// repetitive\n     ///\n     /// **Known problems:** The match statement may be slower due to the compiler\n-    /// not inlining the call to cmp. See issue #5354\n+    /// not inlining the call to cmp. See issue [#5354](https://github.com/rust-lang/rust-clippy/issues/5354)\n     ///\n     /// **Example:**\n     /// ```rust,ignore"}, {"sha": "944aaafb46de59e5748f60d3f1773a8e71f87657", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -112,7 +112,8 @@ impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n             if let Some(&Expr {\n                 kind: ExprKind::If(_, _, Some(ref else_expr)),\n                 ..\n-            }) = get_parent_expr(cx, expr) {\n+            }) = get_parent_expr(cx, expr)\n+            {\n                 if else_expr.hir_id == expr.hir_id {\n                     return;\n                 }"}, {"sha": "48899b33899370b0afd37f57f8281d2a7bc41d15", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{is_copy, match_path, paths, span_lint_and_note};\n-use rustc_hir::{Item, ItemKind, Impl};\n+use rustc_hir::{Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n "}, {"sha": "f7224811e6e79816a82376a564be2cc205d9d870", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,11 +1,14 @@\n-use crate::utils::{any_parent_is_automatically_derived, contains_name, match_def_path, paths, qpath_res, snippet};\n+use crate::utils::{\n+    any_parent_is_automatically_derived, contains_name, match_def_path, paths, qpath_res, snippet_with_macro_callsite,\n+};\n use crate::utils::{span_lint_and_note, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{Ident, Symbol};\n@@ -118,6 +121,8 @@ impl LateLintPass<'_> for Default {\n                 // only take `let ...` statements\n                 if let StmtKind::Local(local) = stmt.kind;\n                 if let Some(expr) = local.init;\n+                if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n+                if !in_external_macro(cx.tcx.sess, expr.span);\n                 // only take bindings to identifiers\n                 if let PatKind::Binding(_, binding_id, ident, _) = local.pat.kind;\n                 // only when assigning `... = Default::default()`\n@@ -187,7 +192,7 @@ impl LateLintPass<'_> for Default {\n                     .into_iter()\n                     .map(|(field, rhs)| {\n                         // extract and store the assigned value for help message\n-                        let value_snippet = snippet(cx, rhs.span, \"..\");\n+                        let value_snippet = snippet_with_macro_callsite(cx, rhs.span, \"..\");\n                         format!(\"{}: {}\", field, value_snippet)\n                     })\n                     .collect::<Vec<String>>()"}, {"sha": "b1e363663bb27fd8fd5a051960fbc6e953e5ba39", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -7,7 +7,7 @@ use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_expr, walk_fn, walk_item, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BlockCheckMode, BodyId, Expr, ExprKind, FnDecl, HirId, Item, ItemKind, Impl, TraitRef, UnsafeSource, Unsafety,\n+    BlockCheckMode, BodyId, Expr, ExprKind, FnDecl, HirId, Impl, Item, ItemKind, TraitRef, UnsafeSource, Unsafety,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;"}, {"sha": "853b3afdc3ae2a0016e5c9da909c08b35cd2c400", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -8,8 +8,12 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n declare_clippy_lint! {\n     /// **What it does:** Checks for `enum`s with no variants.\n     ///\n+    /// As of this writing, the `never_type` is still a\n+    /// nightly-only experimental API. Therefore, this lint is only triggered\n+    /// if the `never_type` is enabled.\n+    ///\n     /// **Why is this bad?** If you want to introduce a type which\n-    /// can't be instantiated, you should use `!` (the never type),\n+    /// can't be instantiated, you should use `!` (the primitive type \"never\"),\n     /// or a wrapper around it, because `!` has more extensive\n     /// compiler support (type inference, etc...) and wrappers\n     /// around it are the conventional way to define an uninhabited type.\n@@ -40,6 +44,11 @@ declare_lint_pass!(EmptyEnum => [EMPTY_ENUM]);\n \n impl<'tcx> LateLintPass<'tcx> for EmptyEnum {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        // Only suggest the `never_type` if the feature is enabled\n+        if !cx.tcx.features().never_type {\n+            return;\n+        }\n+\n         let did = cx.tcx.hir().local_def_id(item.hir_id);\n         if let ItemKind::Enum(..) = item.kind {\n             let ty = cx.tcx.type_of(did);"}, {"sha": "40e93da8dffb4624e3c8457fae6e07fcacaf558f", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,15 +1,16 @@\n use rustc_hir::intravisit;\n-use rustc_hir::{self, Body, FnDecl, HirId, HirIdSet, ItemKind, Impl, Node};\n+use rustc_hir::{self, AssocItemKind, Body, FnDecl, HirId, HirIdSet, Impl, ItemKind, Node};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, TraitRef, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n+use rustc_span::symbol::kw;\n use rustc_target::abi::LayoutOf;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n-use crate::utils::span_lint;\n+use crate::utils::{contains_ty, span_lint};\n \n #[derive(Copy, Clone)]\n pub struct BoxedLocal {\n@@ -51,6 +52,7 @@ fn is_non_trait_box(ty: Ty<'_>) -> bool {\n struct EscapeDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     set: HirIdSet,\n+    trait_self_ty: Option<Ty<'a>>,\n     too_large_for_stack: u64,\n }\n \n@@ -72,19 +74,34 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n             }\n         }\n \n-        // If the method is an impl for a trait, don't warn.\n         let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n         let parent_node = cx.tcx.hir().find(parent_id);\n \n+        let mut trait_self_ty = None;\n         if let Some(Node::Item(item)) = parent_node {\n+            // If the method is an impl for a trait, don't warn.\n             if let ItemKind::Impl(Impl { of_trait: Some(_), .. }) = item.kind {\n                 return;\n             }\n+\n+            // find `self` ty for this trait if relevant\n+            if let ItemKind::Trait(_, _, _, _, items) = item.kind {\n+                for trait_item in items {\n+                    if trait_item.id.hir_id == hir_id {\n+                        // be sure we have `self` parameter in this function\n+                        if let AssocItemKind::Fn { has_self: true } = trait_item.kind {\n+                            trait_self_ty =\n+                                Some(TraitRef::identity(cx.tcx, trait_item.id.hir_id.owner.to_def_id()).self_ty());\n+                        }\n+                    }\n+                }\n+            }\n         }\n \n         let mut v = EscapeDelegate {\n             cx,\n             set: HirIdSet::default(),\n+            trait_self_ty,\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n@@ -153,10 +170,17 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                     return;\n                 }\n \n+                // skip if there is a `self` parameter binding to a type\n+                // that contains `Self` (i.e.: `self: Box<Self>`), see #4804\n+                if let Some(trait_self_ty) = self.trait_self_ty {\n+                    if map.name(cmt.hir_id) == kw::SelfLower && contains_ty(cmt.place.ty(), trait_self_ty) {\n+                        return;\n+                    }\n+                }\n+\n                 if is_non_trait_box(cmt.place.ty()) && !self.is_large_box(cmt.place.ty()) {\n                     self.set.insert(cmt.hir_id);\n                 }\n-                return;\n             }\n         }\n     }"}, {"sha": "1a722d39f730bb1cb293920cd610fbe9b8f329b7", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -22,7 +22,7 @@ declare_clippy_lint! {\n     /// **Known problems:** If creating the closure inside the closure has a side-\n     /// effect then moving the closure creation out will change when that side-\n     /// effect runs.\n-    /// See rust-lang/rust-clippy#1439 for more details.\n+    /// See [#1439](https://github.com/rust-lang/rust-clippy/issues/1439) for more details.\n     ///\n     /// **Example:**\n     /// ```rust,ignore\n@@ -45,8 +45,9 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** It's unnecessary to create the closure.\n     ///\n-    /// **Known problems:** rust-lang/rust-clippy#3071, rust-lang/rust-clippy#4002,\n-    /// rust-lang/rust-clippy#3942\n+    /// **Known problems:** [#3071](https://github.com/rust-lang/rust-clippy/issues/3071),\n+    /// [#3942](https://github.com/rust-lang/rust-clippy/issues/3942),\n+    /// [#4002](https://github.com/rust-lang/rust-clippy/issues/4002)\n     ///\n     ///\n     /// **Example:**"}, {"sha": "b010abda24d108f35752b6edc602e8a86c185654", "filename": "clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -70,7 +70,7 @@ impl LateLintPass<'_> for FromOverInto {\n                 span_lint_and_help(\n                     cx,\n                     FROM_OVER_INTO,\n-                    item.span,\n+                    cx.tcx.sess.source_map().guess_head_span(item.span),\n                     \"an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\",\n                     None,\n                     \"consider to implement `From` instead\","}, {"sha": "58511c6d57c686dedd3c01f5f29a4a19d4fddec4", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -145,7 +145,7 @@ impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n         if let ExprKind::MethodCall(path, _span, args, _) = &expr.kind;\n-        if path.ident.to_string() == \"lock\";\n+        if path.ident.as_str() == \"lock\";\n         let ty = cx.typeck_results().expr_ty(&args[0]);\n         if is_type_diagnostic_item(cx, ty, sym!(mutex_type));\n         then {"}, {"sha": "ea26c84cde16a93260f18c9f73c90e0d29c81991", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -2,7 +2,7 @@\n \n use crate::utils::{in_macro, span_lint_and_then};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{def_id, Crate, Item, ItemKind, Impl};\n+use rustc_hir::{def_id, Crate, Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;"}, {"sha": "e95caf6a35f900915920278e03abc2489bd4750d", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{AssocItemKind, BinOpKind, Expr, ExprKind, ImplItemRef, Item, ItemKind, Impl, TraitItemRef};\n+use rustc_hir::{AssocItemKind, BinOpKind, Expr, ExprKind, Impl, ImplItemRef, Item, ItemKind, TraitItemRef};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};"}, {"sha": "f12994c7a605e21a7e8cafde3bd1cd7d489672c5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -271,6 +271,7 @@ mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n mod needless_pass_by_value;\n+mod needless_question_mark;\n mod needless_update;\n mod neg_cmp_op_on_partial_ord;\n mod neg_multiply;\n@@ -341,6 +342,7 @@ mod unwrap_in_result;\n mod use_self;\n mod useless_conversion;\n mod vec;\n+mod vec_init_then_push;\n mod vec_resize_to_zero;\n mod verbose_file_reads;\n mod wildcard_dependencies;\n@@ -524,6 +526,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n         #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::PRODUCE_ICE,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n         &approx_const::APPROX_CONSTANT,\n         &arithmetic::FLOAT_ARITHMETIC,\n         &arithmetic::INTEGER_ARITHMETIC,\n@@ -556,6 +560,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &cargo_common_metadata::CARGO_COMMON_METADATA,\n         &checked_conversions::CHECKED_CONVERSIONS,\n         &cognitive_complexity::COGNITIVE_COMPLEXITY,\n+        &collapsible_if::COLLAPSIBLE_ELSE_IF,\n         &collapsible_if::COLLAPSIBLE_IF,\n         &collapsible_match::COLLAPSIBLE_MATCH,\n         &comparison_chain::COMPARISON_CHAIN,\n@@ -799,6 +804,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         &needless_continue::NEEDLESS_CONTINUE,\n         &needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n+        &needless_question_mark::NEEDLESS_QUESTION_MARK,\n         &needless_update::NEEDLESS_UPDATE,\n         &neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD,\n         &neg_multiply::NEG_MULTIPLY,\n@@ -908,6 +914,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &types::LET_UNIT_VALUE,\n         &types::LINKEDLIST,\n         &types::OPTION_OPTION,\n+        &types::PTR_AS_PTR,\n         &types::RC_BUFFER,\n         &types::REDUNDANT_ALLOCATION,\n         &types::TYPE_COMPLEXITY,\n@@ -935,6 +942,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &use_self::USE_SELF,\n         &useless_conversion::USELESS_CONVERSION,\n         &vec::USELESS_VEC,\n+        &vec_init_then_push::VEC_INIT_THEN_PUSH,\n         &vec_resize_to_zero::VEC_RESIZE_TO_ZERO,\n         &verbose_file_reads::VERBOSE_FILE_READS,\n         &wildcard_dependencies::WILDCARD_DEPENDENCIES,\n@@ -1019,6 +1027,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box from_over_into::FromOverInto::new(msrv));\n     store.register_late_pass(move || box use_self::UseSelf::new(msrv));\n     store.register_late_pass(move || box missing_const_for_fn::MissingConstForFn::new(msrv));\n+    store.register_late_pass(move || box needless_question_mark::NeedlessQuestionMark::new(msrv));\n \n     store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n     store.register_late_pass(|| box map_clone::MapClone);\n@@ -1215,6 +1224,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box strings::StrToString);\n     store.register_late_pass(|| box strings::StringToString);\n     store.register_late_pass(|| box zero_sized_map_values::ZeroSizedMapValues);\n+    store.register_late_pass(|| box vec_init_then_push::VecInitThenPush::default());\n+    store.register_late_pass(move || box types::PtrAsPtr::new(msrv));\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1341,6 +1352,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::LET_UNIT_VALUE),\n         LintId::of(&types::LINKEDLIST),\n         LintId::of(&types::OPTION_OPTION),\n+        LintId::of(&types::PTR_AS_PTR),\n         LintId::of(&unicode::NON_ASCII_LITERAL),\n         LintId::of(&unicode::UNICODE_NOT_NFC),\n         LintId::of(&unnested_or_patterns::UNNESTED_OR_PATTERNS),\n@@ -1362,6 +1374,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n         LintId::of(&utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n         LintId::of(&utils::internal_lints::PRODUCE_ICE),\n+        LintId::of(&utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n     ]);\n \n     store.register_group(true, \"clippy::all\", Some(\"clippy\"), vec![\n@@ -1384,6 +1397,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&booleans::LOGIC_BUG),\n         LintId::of(&booleans::NONMINIMAL_BOOL),\n         LintId::of(&bytecount::NAIVE_BYTECOUNT),\n+        LintId::of(&collapsible_if::COLLAPSIBLE_ELSE_IF),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n@@ -1545,6 +1559,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+        LintId::of(&needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(&needless_update::NEEDLESS_UPDATE),\n         LintId::of(&neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n         LintId::of(&neg_multiply::NEG_MULTIPLY),\n@@ -1636,6 +1651,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n         LintId::of(&vec::USELESS_VEC),\n+        LintId::of(&vec_init_then_push::VEC_INIT_THEN_PUSH),\n         LintId::of(&vec_resize_to_zero::VEC_RESIZE_TO_ZERO),\n         LintId::of(&write::PRINTLN_EMPTY_STRING),\n         LintId::of(&write::PRINT_LITERAL),\n@@ -1653,6 +1669,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::UNKNOWN_CLIPPY_LINTS),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n+        LintId::of(&collapsible_if::COLLAPSIBLE_ELSE_IF),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n@@ -1803,6 +1820,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+        LintId::of(&needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(&needless_update::NEEDLESS_UPDATE),\n         LintId::of(&neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n         LintId::of(&no_effect::NO_EFFECT),\n@@ -1935,6 +1953,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::BOX_VEC),\n         LintId::of(&types::REDUNDANT_ALLOCATION),\n         LintId::of(&vec::USELESS_VEC),\n+        LintId::of(&vec_init_then_push::VEC_INIT_THEN_PUSH),\n     ]);\n \n     store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), vec!["}, {"sha": "1c5ab2874b0481f92114eb50413e99bfec6f50f6", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -218,7 +218,7 @@ declare_clippy_lint! {\n     /// **Why is this bad?** The `while let` loop is usually shorter and more\n     /// readable.\n     ///\n-    /// **Known problems:** Sometimes the wrong binding is displayed (#383).\n+    /// **Known problems:** Sometimes the wrong binding is displayed ([#383](https://github.com/rust-lang/rust-clippy/issues/383)).\n     ///\n     /// **Example:**\n     /// ```rust,no_run"}, {"sha": "89f5b2ff31137f0fe949b6706823361939d5c140", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** It checks for manual implementations of `async` functions.\n@@ -137,7 +137,7 @@ fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'t\n         if let Some(args) = segment.args;\n         if args.bindings.len() == 1;\n         let binding = &args.bindings[0];\n-        if binding.ident.as_str() == \"Output\";\n+        if binding.ident.name == sym::Output;\n         if let TypeBindingKind::Equality{ty: output} = binding.kind;\n         then {\n             return Some(output)"}, {"sha": "1818836d5d5e836afa476aeb5da4564bf2278192", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n         if_chain! {\n             if let hir::ExprKind::MethodCall(ref method, _, ref args, _) = e.kind;\n             if args.len() == 2;\n-            if method.ident.as_str() == \"map\";\n+            if method.ident.name == sym::map;\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n             if is_type_diagnostic_item(cx, ty, sym::option_type) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;"}, {"sha": "9f9c108a85a0537610a14d98fb6547c43d9cc372", "filename": "clippy_lints/src/map_identity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> LateLintPass<'tcx> for MapIdentity {\n fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a [Expr<'a>]> {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n-        if args.len() == 2 && method.ident.as_str() == \"map\";\n+        if args.len() == 2 && method.ident.name == sym::map;\n         let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n         if match_trait_method(cx, expr, &paths::ITERATOR)\n             || is_type_diagnostic_item(cx, caller_ty, sym::result_type)"}, {"sha": "79aec928d298b7462e3fdc3e0e2356ccc331c9ce", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -3096,7 +3096,7 @@ fn lint_flat_map_identity<'tcx>(\n             if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = body.value.kind;\n \n             if path.segments.len() == 1;\n-            if path.segments[0].ident.as_str() == binding_ident.as_str();\n+            if path.segments[0].ident.name == binding_ident.name;\n \n             then {\n                 apply_lint(\"called `flat_map(|x| x)` on an `Iterator`\");"}, {"sha": "8d0c3b8e0fe89f39921c198656a553095e85e689", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -89,9 +89,9 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n                 if let [obj, _] = args;\n                 if cx.typeck_results().expr_ty(obj).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);\n                 then {\n-                    if path.ident.as_str() == sym!(max).as_str() {\n+                    if path.ident.name == sym!(max) {\n                         fetch_const(cx, args, MinMax::Max)\n-                    } else if path.ident.as_str() == sym!(min).as_str() {\n+                    } else if path.ident.name == sym!(min) {\n                         fetch_const(cx, args, MinMax::Min)\n                     } else {\n                         None"}, {"sha": "0e49eaab4368578a203c4f14600efa133267a17b", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -63,7 +63,7 @@ impl MissingDoc {\n             if let Some(meta) = list.get(0);\n             if let Some(name) = meta.ident();\n             then {\n-                name.as_str() == \"include\"\n+                name.name == sym::include\n             } else {\n                 false\n             }"}, {"sha": "d795f12645794e2a2f6de2389e62737e8b8ae919", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -3,9 +3,7 @@\n //! This lint is **warn** by default\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::{\n-    is_expn_of, parent_node_is_if_expr, snippet_with_applicability, span_lint, span_lint_and_sugg,\n-};\n+use crate::utils::{is_expn_of, parent_node_is_if_expr, snippet_with_applicability, span_lint, span_lint_and_sugg};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};"}, {"sha": "f1c06692e30d9efcff0840b66e40283a13dbc9ae", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -2,15 +2,14 @@\n //!\n //! This lint is **warn** by default\n \n-use crate::utils::{snippet_opt, span_lint_and_then};\n+use crate::utils::{is_automatically_derived, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BindingAnnotation, BorrowKind, Expr, ExprKind, HirId, Item, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -116,7 +115,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n     }\n \n     fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if item.attrs.iter().any(|a| a.has_name(sym::automatically_derived)) {\n+        if is_automatically_derived(item.attrs) {\n             debug_assert!(self.derived_item.is_none());\n             self.derived_item = Some(item.hir_id);\n         }"}, {"sha": "c8f89f8046c856b992ef771679026b0a1a1fc4bf", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -8,11 +8,12 @@ use rustc_ast::ast::Attribute;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{BindingAnnotation, Body, FnDecl, GenericArg, HirId, ItemKind, Impl, Node, PatKind, QPath, TyKind};\n+use rustc_hir::{BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Node, PatKind, QPath, TyKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::kw;\n use rustc_span::{sym, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n@@ -153,7 +154,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             // Ignore `self`s.\n             if idx == 0 {\n                 if let PatKind::Binding(.., ident, _) = arg.pat.kind {\n-                    if ident.as_str() == \"self\" {\n+                    if ident.name == kw::SelfLower {\n                         continue;\n                     }\n                 }"}, {"sha": "9e9b79ee1cf08c227e4209b764e8ca6d7b24fcce", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,232 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::DefIdTree;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n+\n+use crate::utils;\n+use if_chain::if_chain;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Suggests alternatives for useless applications of `?` in terminating expressions\n+    ///\n+    /// **Why is this bad?** There's no reason to use `?` to short-circuit when execution of the body will end there anyway.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct TO {\n+    ///     magic: Option<usize>,\n+    /// }\n+    ///\n+    /// fn f(to: TO) -> Option<usize> {\n+    ///     Some(to.magic?)\n+    /// }\n+    ///\n+    /// struct TR {\n+    ///     magic: Result<usize, bool>,\n+    /// }\n+    ///\n+    /// fn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    ///     tr.and_then(|t| Ok(t.magic?))\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct TO {\n+    ///     magic: Option<usize>,\n+    /// }\n+    ///\n+    /// fn f(to: TO) -> Option<usize> {\n+    ///    to.magic\n+    /// }\n+    ///\n+    /// struct TR {\n+    ///     magic: Result<usize, bool>,\n+    /// }\n+    ///\n+    /// fn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    ///     tr.and_then(|t| t.magic)\n+    /// }\n+    /// ```\n+    pub NEEDLESS_QUESTION_MARK,\n+    complexity,\n+    \"Suggest `value.inner_option` instead of `Some(value.inner_option?)`. The same goes for `Result<T, E>`.\"\n+}\n+\n+const NEEDLESS_QUESTION_MARK_RESULT_MSRV: RustcVersion = RustcVersion::new(1, 13, 0);\n+const NEEDLESS_QUESTION_MARK_OPTION_MSRV: RustcVersion = RustcVersion::new(1, 22, 0);\n+\n+pub struct NeedlessQuestionMark {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl NeedlessQuestionMark {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(NeedlessQuestionMark => [NEEDLESS_QUESTION_MARK]);\n+\n+#[derive(Debug)]\n+enum SomeOkCall<'a> {\n+    SomeCall(&'a Expr<'a>, &'a Expr<'a>),\n+    OkCall(&'a Expr<'a>, &'a Expr<'a>),\n+}\n+\n+impl LateLintPass<'_> for NeedlessQuestionMark {\n+    /*\n+     * The question mark operator is compatible with both Result<T, E> and Option<T>,\n+     * from Rust 1.13 and 1.22 respectively.\n+     */\n+\n+    /*\n+     * What do we match:\n+     * Expressions that look like this:\n+     * Some(option?), Ok(result?)\n+     *\n+     * Where do we match:\n+     *      Last expression of a body\n+     *      Return statement\n+     *      A body's value (single line closure)\n+     *\n+     * What do we not match:\n+     *      Implicit calls to `from(..)` on the error value\n+     */\n+\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n+        let e = match &expr.kind {\n+            ExprKind::Ret(Some(e)) => e,\n+            _ => return,\n+        };\n+\n+        if let Some(ok_some_call) = is_some_or_ok_call(self, cx, e) {\n+            emit_lint(cx, &ok_some_call);\n+        }\n+    }\n+\n+    fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n+        // Function / Closure block\n+        let expr_opt = if let ExprKind::Block(block, _) = &body.value.kind {\n+            block.expr\n+        } else {\n+            // Single line closure\n+            Some(&body.value)\n+        };\n+\n+        if_chain! {\n+            if let Some(expr) = expr_opt;\n+            if let Some(ok_some_call) = is_some_or_ok_call(self, cx, expr);\n+            then {\n+                emit_lint(cx, &ok_some_call);\n+            }\n+        };\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn emit_lint(cx: &LateContext<'_>, expr: &SomeOkCall<'_>) {\n+    let (entire_expr, inner_expr) = match expr {\n+        SomeOkCall::OkCall(outer, inner) | SomeOkCall::SomeCall(outer, inner) => (outer, inner),\n+    };\n+\n+    utils::span_lint_and_sugg(\n+        cx,\n+        NEEDLESS_QUESTION_MARK,\n+        entire_expr.span,\n+        \"Question mark operator is useless here\",\n+        \"try\",\n+        format!(\"{}\", utils::snippet(cx, inner_expr.span, r#\"\"...\"\"#)),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn is_some_or_ok_call<'a>(\n+    nqml: &NeedlessQuestionMark,\n+    cx: &'a LateContext<'_>,\n+    expr: &'a Expr<'_>,\n+) -> Option<SomeOkCall<'a>> {\n+    if_chain! {\n+        // Check outer expression matches CALL_IDENT(ARGUMENT) format\n+        if let ExprKind::Call(path, args) = &expr.kind;\n+        if let ExprKind::Path(QPath::Resolved(None, path)) = &path.kind;\n+        if is_some_ctor(cx, path.res) || is_ok_ctor(cx, path.res);\n+\n+        // Extract inner expression from ARGUMENT\n+        if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &args[0].kind;\n+        if let ExprKind::Call(called, args) = &inner_expr_with_q.kind;\n+        if args.len() == 1;\n+\n+        if let ExprKind::Path(QPath::LangItem(LangItem::TryIntoResult, _)) = &called.kind;\n+        then {\n+            // Extract inner expr type from match argument generated by\n+            // question mark operator\n+            let inner_expr = &args[0];\n+\n+            let inner_ty = cx.typeck_results().expr_ty(inner_expr);\n+            let outer_ty = cx.typeck_results().expr_ty(expr);\n+\n+            // Check if outer and inner type are Option\n+            let outer_is_some = utils::is_type_diagnostic_item(cx, outer_ty, sym::option_type);\n+            let inner_is_some = utils::is_type_diagnostic_item(cx, inner_ty, sym::option_type);\n+\n+            // Check for Option MSRV\n+            let meets_option_msrv = utils::meets_msrv(nqml.msrv.as_ref(), &NEEDLESS_QUESTION_MARK_OPTION_MSRV);\n+            if outer_is_some && inner_is_some && meets_option_msrv {\n+                return Some(SomeOkCall::SomeCall(expr, inner_expr));\n+            }\n+\n+            // Check if outer and inner type are Result\n+            let outer_is_result = utils::is_type_diagnostic_item(cx, outer_ty, sym::result_type);\n+            let inner_is_result = utils::is_type_diagnostic_item(cx, inner_ty, sym::result_type);\n+\n+            // Additional check: if the error type of the Result can be converted\n+            // via the From trait, then don't match\n+            let does_not_call_from = !has_implicit_error_from(cx, expr, inner_expr);\n+\n+            // Must meet Result MSRV\n+            let meets_result_msrv = utils::meets_msrv(nqml.msrv.as_ref(), &NEEDLESS_QUESTION_MARK_RESULT_MSRV);\n+            if outer_is_result && inner_is_result && does_not_call_from && meets_result_msrv {\n+                return Some(SomeOkCall::OkCall(expr, inner_expr));\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn has_implicit_error_from(cx: &LateContext<'_>, entire_expr: &Expr<'_>, inner_result_expr: &Expr<'_>) -> bool {\n+    return cx.typeck_results().expr_ty(entire_expr) != cx.typeck_results().expr_ty(inner_result_expr);\n+}\n+\n+fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == ok_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == some_id;\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "7bdf975ffd446f82a9c97d0009565f8e084c9364", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -66,7 +66,7 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n /// Returns true iff the given expression is the result of calling `Result::ok`\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n-        path.ident.name.to_ident_string() == \"ok\"\n+        path.ident.name.as_str() == \"ok\"\n             && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym::result_type)\n     } else {\n         false\n@@ -110,7 +110,7 @@ fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n fn should_wrap_in_braces(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     utils::get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n         let mut should_wrap = false;\n-        \n+\n         if let Some(Expr {\n             kind:\n                 ExprKind::Match(\n@@ -124,7 +124,11 @@ fn should_wrap_in_braces(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         }) = parent.expr\n         {\n             should_wrap = expr.hir_id == arms[1].body.hir_id;\n-        } else if let Some(Expr { kind: ExprKind::If(_, _, Some(else_clause)), .. }) = parent.expr {\n+        } else if let Some(Expr {\n+            kind: ExprKind::If(_, _, Some(else_clause)),\n+            ..\n+        }) = parent.expr\n+        {\n             should_wrap = expr.hir_id == else_clause.hir_id;\n         }\n "}, {"sha": "ed314937ce8beb219ef18d8c407f71acd048e870", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{is_automatically_derived, span_lint_hir};\n use if_chain::if_chain;\n-use rustc_hir::{Item, ItemKind, Impl};\n+use rustc_hir::{Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;"}, {"sha": "d96a9b025f0890e449db1954d9eca346e5cfeac2", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::attr;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, ItemKind, MutTy, Mutability, Node, PatKind, Impl};\n+use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, Impl, ItemKind, MutTy, Mutability, Node, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -63,7 +63,7 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** Arguments passed by value might result in an unnecessary\n     /// shallow copy, taking up more space in the stack and requiring a call to\n-    /// `memcpy`, which which can be expensive.\n+    /// `memcpy`, which can be expensive.\n     ///\n     /// **Example:**\n     ///"}, {"sha": "c6329a1381c909977e947e8f2cda63545bd1d590", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -8,8 +8,8 @@ use crate::utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n-    BinOpKind, BodyId, Expr, ExprKind, FnDecl, FnRetTy, GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Impl,\n-    Lifetime, MutTy, Mutability, Node, PathSegment, QPath, TraitFn, TraitItem, TraitItemKind, Ty, TyKind,\n+    BinOpKind, BodyId, Expr, ExprKind, FnDecl, FnRetTy, GenericArg, HirId, Impl, ImplItem, ImplItemKind, Item,\n+    ItemKind, Lifetime, MutTy, Mutability, Node, PathSegment, QPath, TraitFn, TraitItem, TraitItemKind, Ty, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;"}, {"sha": "8cd6692ce03a09ceb9b42647865d101ec3c42771", "filename": "clippy_lints/src/ref_option_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fref_option_ref.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -13,7 +13,7 @@ declare_clippy_lint! {\n     /// **Why is this bad?** Since `&` is Copy, it's useless to have a\n     /// reference on `Option<&T>`.\n     ///\n-    /// **Known problems:** It may be irrevelent to use this lint on\n+    /// **Known problems:** It may be irrelevant to use this lint on\n     /// public API code as it will make a breaking change to apply it.\n     ///\n     /// **Example:**"}, {"sha": "63548d8fdb438f9546ceba10953573319811118c", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -202,7 +202,7 @@ fn check_final_expr<'tcx>(\n                     check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n                 }\n             },\n-            | MatchSource::IfLetDesugar {\n+            MatchSource::IfLetDesugar {\n                 contains_else_clause: true,\n             } => {\n                 if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n@@ -217,6 +217,9 @@ fn check_final_expr<'tcx>(\n }\n \n fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n+    if ret_span.from_expansion() {\n+        return;\n+    }\n     match inner_span {\n         Some(inner_span) => {\n             if in_external_macro(cx.tcx.sess, inner_span) || inner_span.from_expansion() {"}, {"sha": "44e739725c82055a5f991fe7f41ccc630fe13590", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{get_trait_def_id, paths, span_lint};\n-use rustc_hir::{Item, ItemKind, Impl};\n+use rustc_hir::{Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n "}, {"sha": "24da056770c9d18366936e92f3440655ab70e1ae", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -396,5 +396,5 @@ fn is_self_shadow(name: Symbol, expr: &Expr<'_>) -> bool {\n }\n \n fn path_eq_name(name: Symbol, path: &Path<'_>) -> bool {\n-    !path.is_global() && path.segments.len() == 1 && path.segments[0].ident.as_str() == name.as_str()\n+    !path.is_global() && path.segments.len() == 1 && path.segments[0].ident.name == name\n }"}, {"sha": "699fd51ccc194e30d2f16bc978cef70cbb39aba7", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -91,7 +91,7 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if let ExprKind::Path(QPath::Resolved(None, ref rhs2)) = rhs2.kind;\n             if rhs2.segments.len() == 1;\n \n-            if ident.as_str() == rhs2.segments[0].ident.as_str();\n+            if ident.name == rhs2.segments[0].ident.name;\n             if eq_expr_value(cx, tmp_init, lhs1);\n             if eq_expr_value(cx, rhs1, lhs2);\n             then {"}, {"sha": "c53727ba160046861e6d446e428482f5b0986837", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::{match_def_path, match_trait_method, paths, qpath_res, span_lint};\n use if_chain::if_chain;\n use rustc_hir::def::Res;\n-use rustc_hir::{Expr, ExprKind, HirId, ImplItem, ImplItemKind, Item, ItemKind, Impl};\n+use rustc_hir::{Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n "}, {"sha": "3b5a83d2a0bec7f0767718965bf42d845c101520", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 119, "deletions": 15, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -8,7 +8,6 @@ use if_chain::if_chain;\n use rustc_ast::{FloatTy, IntTy, LitFloatType, LitIntType, LitKind, UintTy};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericBounds, GenericParamKind, HirId,\n@@ -19,7 +18,8 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::TypeFoldable;\n-use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeckResults};\n+use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeAndMut, TypeckResults};\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::Span;\n@@ -30,11 +30,13 @@ use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n+use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_type_diagnostic_item,\n-    last_path_segment, match_def_path, match_path, method_chain_args, multispan_sugg, numeric_literal::NumericLiteral,\n-    qpath_res, reindent_multiline, sext, snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n+    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_hir_ty_cfg_dependant,\n+    is_type_diagnostic_item, last_path_segment, match_def_path, match_path, meets_msrv, method_chain_args,\n+    multispan_sugg, numeric_literal::NumericLiteral, qpath_res, reindent_multiline, sext, snippet, snippet_opt,\n+    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n+    span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -73,7 +75,7 @@ declare_clippy_lint! {\n     /// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n     /// the heap. So if you `Box` its contents, you just add another level of indirection.\n     ///\n-    /// **Known problems:** Vec<Box<T: Sized>> makes sense if T is a large type (see #3530,\n+    /// **Known problems:** Vec<Box<T: Sized>> makes sense if T is a large type (see [#3530](https://github.com/rust-lang/rust-clippy/issues/3530),\n     /// 1st comment).\n     ///\n     /// **Example:**\n@@ -1279,8 +1281,8 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for casts from a less-strictly-aligned pointer to a\n-    /// more-strictly-aligned pointer\n+    /// **What it does:** Checks for casts, using `as` or `pointer::cast`,\n+    /// from a less-strictly-aligned pointer to a more-strictly-aligned pointer\n     ///\n     /// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n     /// behavior.\n@@ -1293,6 +1295,9 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let _ = (&1u8 as *const u8) as *const u16;\n     /// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n+    ///\n+    /// (&1u8 as *const u8).cast::<u16>();\n+    /// (&mut 1u8 as *mut u8).cast::<u16>();\n     /// ```\n     pub CAST_PTR_ALIGNMENT,\n     pedantic,\n@@ -1634,12 +1639,8 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             return;\n         }\n         if let ExprKind::Cast(ref ex, cast_to) = expr.kind {\n-            if let TyKind::Path(QPath::Resolved(_, path)) = cast_to.kind {\n-                if let Res::Def(_, def_id) = path.res {\n-                    if cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr) {\n-                        return;\n-                    }\n-                }\n+            if is_hir_ty_cfg_dependant(cx, cast_to) {\n+                return;\n             }\n             let (cast_from, cast_to) = (cx.typeck_results().expr_ty(ex), cx.typeck_results().expr_ty(expr));\n             lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n@@ -1689,6 +1690,19 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             }\n \n             lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+        } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n+            if_chain! {\n+            if method_path.ident.name == sym!(cast);\n+            if let Some(generic_args) = method_path.args;\n+            if let [GenericArg::Type(cast_to)] = generic_args.args;\n+            // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n+            if !is_hir_ty_cfg_dependant(cx, cast_to);\n+            then {\n+                let (cast_from, cast_to) =\n+                    (cx.typeck_results().expr_ty(&args[0]), cx.typeck_results().expr_ty(expr));\n+                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+            }\n+            }\n         }\n     }\n }\n@@ -2873,3 +2887,93 @@ impl<'tcx> LateLintPass<'tcx> for RefToMut {\n         }\n     }\n }\n+\n+const PTR_AS_PTR_MSRV: RustcVersion = RustcVersion::new(1, 38, 0);\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for `as` casts between raw pointers without changing its mutability,\n+    /// namely `*const T` to `*const U` and `*mut T` to `*mut U`.\n+    ///\n+    /// **Why is this bad?**\n+    /// Though `as` casts between raw pointers is not terrible, `pointer::cast` is safer because\n+    /// it cannot accidentally change the pointer's mutability nor cast the pointer to other types like `usize`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let ptr: *const u32 = &42_u32;\n+    /// let mut_ptr: *mut u32 = &mut 42_u32;\n+    /// let _ = ptr as *const i32;\n+    /// let _ = mut_ptr as *mut i32;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let ptr: *const u32 = &42_u32;\n+    /// let mut_ptr: *mut u32 = &mut 42_u32;\n+    /// let _ = ptr.cast::<i32>();\n+    /// let _ = mut_ptr.cast::<i32>();\n+    /// ```\n+    pub PTR_AS_PTR,\n+    pedantic,\n+    \"casting using `as` from and to raw pointers that doesn't change its mutability, where `pointer::cast` could take the place of `as`\"\n+}\n+\n+pub struct PtrAsPtr {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl PtrAsPtr {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(PtrAsPtr => [PTR_AS_PTR]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PtrAsPtr {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &PTR_AS_PTR_MSRV) {\n+            return;\n+        }\n+\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::Cast(cast_expr, cast_to_hir_ty) = expr.kind;\n+            let (cast_from, cast_to) = (cx.typeck_results().expr_ty(cast_expr), cx.typeck_results().expr_ty(expr));\n+            if let ty::RawPtr(TypeAndMut { mutbl: from_mutbl, .. }) = cast_from.kind();\n+            if let ty::RawPtr(TypeAndMut { ty: to_pointee_ty, mutbl: to_mutbl }) = cast_to.kind();\n+            if matches!((from_mutbl, to_mutbl),\n+                (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n+            // The `U` in `pointer::cast` have to be `Sized`\n+            // as explained here: https://github.com/rust-lang/rust/issues/60602.\n+            if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);\n+                let turbofish = match &cast_to_hir_ty.kind {\n+                        TyKind::Infer => Cow::Borrowed(\"\"),\n+                        TyKind::Ptr(mut_ty) if matches!(mut_ty.ty.kind, TyKind::Infer) => Cow::Borrowed(\"\"),\n+                        _ => Cow::Owned(format!(\"::<{}>\", to_pointee_ty)),\n+                    };\n+                span_lint_and_sugg(\n+                    cx,\n+                    PTR_AS_PTR,\n+                    expr.span,\n+                    \"`as` casting between raw pointers without changing its mutability\",\n+                    \"try `pointer::cast`, a safer alternative\",\n+                    format!(\"{}.cast{}()\", cast_expr_sugg.maybe_par(), turbofish),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}"}, {"sha": "9b45d38afd42f5eeed1a3064e2fbefd2845dd995", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -183,7 +183,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n         if let ExprKind::MethodCall(method_path, _, [ref left_expr, ref right_expr], _) = &closure_body.value.kind;\n-        if method_path.ident.name.to_ident_string() == \"cmp\";\n+        if method_path.ident.name == sym::cmp;\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n                 &cx,"}, {"sha": "8ac5dd696b7620d85216c281603c286582ed5411", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -5,7 +5,7 @@ use crate::utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, ExprKind, FnDecl, HirId, ItemKind, Impl, Node};\n+use rustc_hir::{Body, ExprKind, FnDecl, HirId, Impl, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};"}, {"sha": "5349c4f7eb8a78251c51bd412f3171afdb46dd1a", "filename": "clippy_lints/src/unused_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_self.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,7 +1,7 @@\n use if_chain::if_chain;\n use rustc_hir::def::Res;\n use rustc_hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n-use rustc_hir::{HirId, ImplItem, ImplItemKind, ItemKind, Impl, Path};\n+use rustc_hir::{HirId, Impl, ImplItem, ImplItemKind, ItemKind, Path};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};"}, {"sha": "b82909eaea604fd780e6709967469dd20b08c960", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,6 +1,5 @@\n use crate::utils::{\n-    differing_macro_contexts, is_type_diagnostic_item, span_lint_and_then,\n-    usage::is_potentially_mutated,\n+    differing_macro_contexts, is_type_diagnostic_item, span_lint_and_then, usage::is_potentially_mutated,\n };\n use if_chain::if_chain;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};"}, {"sha": "72d1ca7392913f77040ef91ef531418c14e91640", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -28,8 +28,8 @@ declare_clippy_lint! {\n     /// feels inconsistent.\n     ///\n     /// **Known problems:**\n-    /// - False positive when using associated types (#2843)\n-    /// - False positives in some situations when using generics (#3410)\n+    /// - False positive when using associated types ([#2843](https://github.com/rust-lang/rust-clippy/issues/2843))\n+    /// - False positives in some situations when using generics ([#3410](https://github.com/rust-lang/rust-clippy/issues/3410))\n     ///\n     /// **Example:**\n     /// ```rust"}, {"sha": "c53348539860524ce55b0e9db2fadfd55ca07314", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -80,10 +80,10 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         );\n                     }\n                 }\n-                if match_trait_method(cx, e, &paths::INTO_ITERATOR) && &*name.ident.as_str() == \"into_iter\" {\n+                if match_trait_method(cx, e, &paths::INTO_ITERATOR) && name.ident.name == sym::into_iter {\n                     if let Some(parent_expr) = get_parent_expr(cx, e) {\n                         if let ExprKind::MethodCall(ref parent_name, ..) = parent_expr.kind {\n-                            if &*parent_name.ident.as_str() != \"into_iter\" {\n+                            if parent_name.ident.name != sym::into_iter {\n                                 return;\n                             }\n                         }"}, {"sha": "8d28421d70d707fdec87dcbf03a059f5d63ada2c", "filename": "clippy_lints/src/utils/attrs.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,6 +1,7 @@\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_session::Session;\n+use rustc_span::sym;\n use std::str::FromStr;\n \n /// Deprecation status of attributes known by Clippy.\n@@ -64,11 +65,11 @@ pub fn get_attr<'a>(\n             return false;\n         };\n         let attr_segments = &attr.path.segments;\n-        if attr_segments.len() == 2 && attr_segments[0].ident.to_string() == \"clippy\" {\n+        if attr_segments.len() == 2 && attr_segments[0].ident.name == sym::clippy {\n             BUILTIN_ATTRIBUTES\n                 .iter()\n-                .find_map(|(builtin_name, deprecation_status)| {\n-                    if *builtin_name == attr_segments[1].ident.to_string() {\n+                .find_map(|&(builtin_name, ref deprecation_status)| {\n+                    if attr_segments[1].ident.name.as_str() == builtin_name {\n                         Some(deprecation_status)\n                     } else {\n                         None\n@@ -99,7 +100,7 @@ pub fn get_attr<'a>(\n                             },\n                             DeprecationStatus::None => {\n                                 diag.cancel();\n-                                attr_segments[1].ident.to_string() == name\n+                                attr_segments[1].ident.name.as_str() == name\n                             },\n                         }\n                     },"}, {"sha": "10120a8805db25b6c64b618fac0568a075458fb8", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 lb == rb && l_mut == r_mut && self.eq_expr(le, re)\n             },\n             (&ExprKind::Continue(li), &ExprKind::Continue(ri)) => {\n-                both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n+                both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n             },\n             (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n                 self.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                     })\n             },\n             (&ExprKind::Break(li, ref le), &ExprKind::Break(ri, ref re)) => {\n-                both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n+                both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n                     && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n             (&ExprKind::Loop(ref lb, ref ll, ref lls), &ExprKind::Loop(ref rb, ref rl, ref rls)) => {\n-                lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n+                lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n             },\n             (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n                 ls == rs\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n     pub fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n         let (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) = (&left, &right);\n-        li.name.as_str() == ri.name.as_str() && self.eq_pat(lp, rp)\n+        li.name == ri.name && self.eq_pat(lp, rp)\n     }\n \n     /// Checks whether two patterns are the same.\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n             (&PatKind::Binding(ref lb, .., ref li, ref lp), &PatKind::Binding(ref rb, .., ref ri, ref rp)) => {\n-                lb == rb && li.name.as_str() == ri.name.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n+                lb == rb && li.name == ri.name && both(lp, rp, |l, r| self.eq_pat(l, r))\n             },\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n@@ -266,8 +266,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn eq_path_segment(&mut self, left: &PathSegment<'_>, right: &PathSegment<'_>) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n-        left.ident.as_str() == right.ident.as_str()\n-            && both(&left.args, &right.args, |l, r| self.eq_path_parameters(l, r))\n+        left.ident.name == right.ident.name && both(&left.args, &right.args, |l, r| self.eq_path_parameters(l, r))\n     }\n \n     pub fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {"}, {"sha": "7aa17520ba79f3070d206eb851cb5aa8bfff6c42", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 168, "deletions": 16, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -10,9 +10,12 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind};\n+use rustc_hir::{\n+    BinOpKind, Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind, UnOp,\n+};\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::mir::interpret::ConstValue;\n@@ -272,6 +275,28 @@ declare_clippy_lint! {\n     \"interning a symbol that is pre-interned and defined as a constant\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for unnecessary conversion from Symbol to a string.\n+    ///\n+    /// **Why is this bad?** It's faster use symbols directly intead of strings.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// symbol.as_str() == \"clippy\";\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// symbol == sym::clippy;\n+    /// ```\n+    pub UNNECESSARY_SYMBOL_STR,\n+    internal,\n+    \"unnecessary conversion between Symbol and string\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -868,28 +893,30 @@ impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n \n #[derive(Default)]\n pub struct InterningDefinedSymbol {\n-    // Maps the symbol value to the constant name.\n-    symbol_map: FxHashMap<u32, String>,\n+    // Maps the symbol value to the constant DefId.\n+    symbol_map: FxHashMap<u32, DefId>,\n }\n \n-impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL]);\n+impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL, UNNECESSARY_SYMBOL_STR]);\n \n impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n     fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n         if !self.symbol_map.is_empty() {\n             return;\n         }\n \n-        if let Some(Res::Def(_, def_id)) = path_to_res(cx, &paths::SYM_MODULE) {\n-            for item in cx.tcx.item_children(def_id).iter() {\n-                if_chain! {\n-                    if let Res::Def(DefKind::Const, item_def_id) = item.res;\n-                    let ty = cx.tcx.type_of(item_def_id);\n-                    if match_type(cx, ty, &paths::SYMBOL);\n-                    if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n-                    if let Ok(value) = value.to_u32();\n-                    then {\n-                        self.symbol_map.insert(value, item.ident.to_string());\n+        for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n+            if let Some(Res::Def(_, def_id)) = path_to_res(cx, module) {\n+                for item in cx.tcx.item_children(def_id).iter() {\n+                    if_chain! {\n+                        if let Res::Def(DefKind::Const, item_def_id) = item.res;\n+                        let ty = cx.tcx.type_of(item_def_id);\n+                        if match_type(cx, ty, &paths::SYMBOL);\n+                        if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n+                        if let Ok(value) = value.to_u32();\n+                        then {\n+                            self.symbol_map.insert(value, item_def_id);\n+                        }\n                     }\n                 }\n             }\n@@ -903,18 +930,143 @@ impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n             if match_def_path(cx, *def_id, &paths::SYMBOL_INTERN);\n             if let Some(Constant::Str(arg)) = constant_simple(cx, cx.typeck_results(), arg);\n             let value = Symbol::intern(&arg).as_u32();\n-            if let Some(symbol_const) = self.symbol_map.get(&value);\n+            if let Some(&def_id) = self.symbol_map.get(&value);\n             then {\n                 span_lint_and_sugg(\n                     cx,\n                     INTERNING_DEFINED_SYMBOL,\n                     is_expn_of(expr.span, \"sym\").unwrap_or(expr.span),\n                     \"interning a defined symbol\",\n                     \"try\",\n-                    format!(\"rustc_span::symbol::sym::{}\", symbol_const),\n+                    cx.tcx.def_path_str(def_id),\n                     Applicability::MachineApplicable,\n                 );\n             }\n         }\n+        if let ExprKind::Binary(op, left, right) = expr.kind {\n+            if matches!(op.node, BinOpKind::Eq | BinOpKind::Ne) {\n+                let data = [\n+                    (left, self.symbol_str_expr(left, cx)),\n+                    (right, self.symbol_str_expr(right, cx)),\n+                ];\n+                match data {\n+                    // both operands are a symbol string\n+                    [(_, Some(left)), (_, Some(right))] => {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_SYMBOL_STR,\n+                            expr.span,\n+                            \"unnecessary `Symbol` to string conversion\",\n+                            \"try\",\n+                            format!(\n+                                \"{} {} {}\",\n+                                left.as_symbol_snippet(cx),\n+                                op.node.as_str(),\n+                                right.as_symbol_snippet(cx),\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                    // one of the operands is a symbol string\n+                    [(expr, Some(symbol)), _] | [_, (expr, Some(symbol))] => {\n+                        // creating an owned string for comparison\n+                        if matches!(symbol, SymbolStrExpr::Expr { is_to_owned: true, .. }) {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                UNNECESSARY_SYMBOL_STR,\n+                                expr.span,\n+                                \"unnecessary string allocation\",\n+                                \"try\",\n+                                format!(\"{}.as_str()\", symbol.as_symbol_snippet(cx)),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    },\n+                    // nothing found\n+                    [(_, None), (_, None)] => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl InterningDefinedSymbol {\n+    fn symbol_str_expr<'tcx>(&self, expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> Option<SymbolStrExpr<'tcx>> {\n+        static IDENT_STR_PATHS: &[&[&str]] = &[&paths::IDENT_AS_STR, &paths::TO_STRING_METHOD];\n+        static SYMBOL_STR_PATHS: &[&[&str]] = &[\n+            &paths::SYMBOL_AS_STR,\n+            &paths::SYMBOL_TO_IDENT_STRING,\n+            &paths::TO_STRING_METHOD,\n+        ];\n+        // SymbolStr might be de-referenced: `&*symbol.as_str()`\n+        let call = if_chain! {\n+            if let ExprKind::AddrOf(_, _, e) = expr.kind;\n+            if let ExprKind::Unary(UnOp::UnDeref, e) = e.kind;\n+            then { e } else { expr }\n+        };\n+        if_chain! {\n+            // is a method call\n+            if let ExprKind::MethodCall(_, _, [item], _) = call.kind;\n+            if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n+            let ty = cx.typeck_results().expr_ty(item);\n+            // ...on either an Ident or a Symbol\n+            if let Some(is_ident) = if match_type(cx, ty, &paths::SYMBOL) {\n+                Some(false)\n+            } else if match_type(cx, ty, &paths::IDENT) {\n+                Some(true)\n+            } else {\n+                None\n+            };\n+            // ...which converts it to a string\n+            let paths = if is_ident { IDENT_STR_PATHS } else { SYMBOL_STR_PATHS };\n+            if let Some(path) = paths.iter().find(|path| match_def_path(cx, did, path));\n+            then {\n+                let is_to_owned = path.last().unwrap().ends_with(\"string\");\n+                return Some(SymbolStrExpr::Expr {\n+                    item,\n+                    is_ident,\n+                    is_to_owned,\n+                });\n+            }\n+        }\n+        // is a string constant\n+        if let Some(Constant::Str(s)) = constant_simple(cx, cx.typeck_results(), expr) {\n+            let value = Symbol::intern(&s).as_u32();\n+            // ...which matches a symbol constant\n+            if let Some(&def_id) = self.symbol_map.get(&value) {\n+                return Some(SymbolStrExpr::Const(def_id));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+enum SymbolStrExpr<'tcx> {\n+    /// a string constant with a corresponding symbol constant\n+    Const(DefId),\n+    /// a \"symbol to string\" expression like `symbol.as_str()`\n+    Expr {\n+        /// part that evaluates to `Symbol` or `Ident`\n+        item: &'tcx Expr<'tcx>,\n+        is_ident: bool,\n+        /// whether an owned `String` is created like `to_ident_string()`\n+        is_to_owned: bool,\n+    },\n+}\n+\n+impl<'tcx> SymbolStrExpr<'tcx> {\n+    /// Returns a snippet that evaluates to a `Symbol` and is const if possible\n+    fn as_symbol_snippet(&self, cx: &LateContext<'_>) -> Cow<'tcx, str> {\n+        match *self {\n+            Self::Const(def_id) => cx.tcx.def_path_str(def_id).into(),\n+            Self::Expr { item, is_ident, .. } => {\n+                let mut snip = snippet(cx, item.span.source_callsite(), \"..\");\n+                if is_ident {\n+                    // get `Ident.name`\n+                    snip.to_mut().push_str(\".name\");\n+                }\n+                snip\n+            },\n+        }\n     }\n }"}, {"sha": "548c4f7510ad5f169554e50182faf0db7943934c", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,5 +1,5 @@\n #[macro_use]\n-pub mod sym;\n+pub mod sym_helper;\n \n #[allow(clippy::module_name_repetitions)]\n pub mod ast_utils;\n@@ -56,8 +56,8 @@ use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n-use rustc_span::sym as rustc_sym;\n-use rustc_span::symbol::{self, kw, Symbol};\n+use rustc_span::sym;\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n@@ -1121,7 +1121,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n /// implementations have.\n pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(rustc_sym::automatically_derived))\n+    attrs.iter().any(|attr| attr.has_name(sym::automatically_derived))\n }\n \n /// Remove blocks around an expression.\n@@ -1434,12 +1434,13 @@ pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n     let map = cx.tcx.hir();\n     let parent_id = map.get_parent_node(expr.hir_id);\n     let parent_node = map.get(parent_id);\n-    if let Node::Expr(Expr { kind: ExprKind::If(_, _, _), .. }) = parent_node {\n-        true\n-    }\n-    else {\n-        false\n-    }\n+    matches!(\n+        parent_node,\n+        Node::Expr(Expr {\n+            kind: ExprKind::If(_, _, _),\n+            ..\n+        })\n+    )\n }\n \n // Finds the attribute with the given name, if any\n@@ -1514,7 +1515,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n     krate.item.attrs.iter().any(|attr| {\n         if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n-            attr.path == symbol::sym::no_std\n+            attr.path == sym::no_std\n         } else {\n             false\n         }\n@@ -1686,6 +1687,18 @@ macro_rules! unwrap_cargo_metadata {\n     }};\n }\n \n+pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n+        if let Res::Def(_, def_id) = path.res;\n+        then {\n+            cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{reindent_multiline, without_block_comments};"}, {"sha": "c0b203b5388dce969ecb3a77662022d32d2532b8", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -54,6 +54,10 @@ pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHSET: [&str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const IDENT_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Ident\", \"as_str\"];\n pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n@@ -65,6 +69,8 @@ pub const IPADDR_V4: [&str; 4] = [\"std\", \"net\", \"IpAddr\", \"V4\"];\n pub const IPADDR_V6: [&str; 4] = [\"std\", \"net\", \"IpAddr\", \"V6\"];\n pub const ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\"];\n #[cfg(feature = \"internal-lints\")]\n+pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n #[cfg(feature = \"internal-lints\")]\n@@ -148,8 +154,12 @@ pub const STR_STARTS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"starts_wit\n #[cfg(feature = \"internal-lints\")]\n pub const SYMBOL: [&str; 3] = [\"rustc_span\", \"symbol\", \"Symbol\"];\n #[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"as_str\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const SYMBOL_INTERN: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"intern\"];\n #[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL_TO_IDENT_STRING: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"to_ident_string\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const SYM_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"sym\"];\n #[cfg(feature = \"internal-lints\")]\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];"}, {"sha": "f47dc80ebade8222716a721293eb00b50e80aa52", "filename": "clippy_lints/src/utils/sym_helper.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fsym_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fsym_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsym_helper.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,4 +1,5 @@\n #[macro_export]\n+/// Convenience wrapper around rustc's `Symbol::intern`\n macro_rules! sym {\n     ($tt:tt) => {\n         rustc_span::symbol::Symbol::intern(stringify!($tt))", "previous_filename": "clippy_lints/src/utils/sym.rs"}, {"sha": "ebf69df31ca41e3702b00a1a91461b980ede5e72", "filename": "clippy_lints/src/utils/visitors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -107,7 +107,7 @@ where\n                         if let Some(el) = else_opt {\n                             self.visit_expr(el);\n                         }\n-                    }\n+                    },\n                     hir::ExprKind::Match(cond, arms, _) => {\n                         self.inside_stmt(true).visit_expr(cond);\n                         for arm in arms {"}, {"sha": "e632a7e57ee87b22fd351a80a3497bec5804a4de", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,187 @@\n+use crate::utils::{is_type_diagnostic_item, match_def_path, paths, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Local, PatKind, QPath, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{symbol::sym, Span, Symbol};\n+use std::convert::TryInto;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `push` immediately after creating a new `Vec`.\n+    ///\n+    /// **Why is this bad?** The `vec![]` macro is both more performant and easier to read than\n+    /// multiple `push` calls.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let mut v = Vec::new();\n+    /// v.push(0);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let v = vec![0];\n+    /// ```\n+    pub VEC_INIT_THEN_PUSH,\n+    perf,\n+    \"`push` immediately after `Vec` creation\"\n+}\n+\n+impl_lint_pass!(VecInitThenPush => [VEC_INIT_THEN_PUSH]);\n+\n+#[derive(Default)]\n+pub struct VecInitThenPush {\n+    searcher: Option<VecPushSearcher>,\n+}\n+\n+#[derive(Clone, Copy)]\n+enum VecInitKind {\n+    New,\n+    WithCapacity(u64),\n+}\n+struct VecPushSearcher {\n+    init: VecInitKind,\n+    name: Symbol,\n+    lhs_is_local: bool,\n+    lhs_span: Span,\n+    err_span: Span,\n+    found: u64,\n+}\n+impl VecPushSearcher {\n+    fn display_err(&self, cx: &LateContext<'_>) {\n+        match self.init {\n+            _ if self.found == 0 => return,\n+            VecInitKind::WithCapacity(x) if x > self.found => return,\n+            _ => (),\n+        };\n+\n+        let mut s = if self.lhs_is_local {\n+            String::from(\"let \")\n+        } else {\n+            String::new()\n+        };\n+        s.push_str(&snippet(cx, self.lhs_span, \"..\"));\n+        s.push_str(\" = vec![..];\");\n+\n+        span_lint_and_sugg(\n+            cx,\n+            VEC_INIT_THEN_PUSH,\n+            self.err_span,\n+            \"calls to `push` immediately after creation\",\n+            \"consider using the `vec![]` macro\",\n+            s,\n+            Applicability::HasPlaceholders,\n+        );\n+    }\n+}\n+\n+impl LateLintPass<'_> for VecInitThenPush {\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n+        self.searcher = None;\n+        if_chain! {\n+            if !in_external_macro(cx.sess(), local.span);\n+            if let Some(init) = local.init;\n+            if let PatKind::Binding(BindingAnnotation::Mutable, _, ident, None) = local.pat.kind;\n+            if let Some(init_kind) = get_vec_init_kind(cx, init);\n+            then {\n+                self.searcher = Some(VecPushSearcher {\n+                        init: init_kind,\n+                        name: ident.name,\n+                        lhs_is_local: true,\n+                        lhs_span: local.ty.map_or(local.pat.span, |t| local.pat.span.to(t.span)),\n+                        err_span: local.span,\n+                        found: 0,\n+                    });\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if self.searcher.is_none() {\n+            if_chain! {\n+                if !in_external_macro(cx.sess(), expr.span);\n+                if let ExprKind::Assign(left, right, _) = expr.kind;\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = left.kind;\n+                if let Some(name) = path.segments.get(0);\n+                if let Some(init_kind) = get_vec_init_kind(cx, right);\n+                then {\n+                    self.searcher = Some(VecPushSearcher {\n+                        init: init_kind,\n+                        name: name.ident.name,\n+                        lhs_is_local: false,\n+                        lhs_span: left.span,\n+                        err_span: expr.span,\n+                        found: 0,\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        if let Some(searcher) = self.searcher.take() {\n+            if_chain! {\n+                if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = stmt.kind;\n+                if let ExprKind::MethodCall(path, _, [self_arg, _], _) = expr.kind;\n+                if path.ident.name.as_str() == \"push\";\n+                if let ExprKind::Path(QPath::Resolved(_, self_path)) = self_arg.kind;\n+                if let [self_name] = self_path.segments;\n+                if self_name.ident.name == searcher.name;\n+                then {\n+                    self.searcher = Some(VecPushSearcher {\n+                        found: searcher.found + 1,\n+                        err_span: searcher.err_span.to(stmt.span),\n+                        .. searcher\n+                    });\n+                } else {\n+                    searcher.display_err(cx);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_block_post(&mut self, cx: &LateContext<'tcx>, _: &'tcx Block<'tcx>) {\n+        if let Some(searcher) = self.searcher.take() {\n+            searcher.display_err(cx);\n+        }\n+    }\n+}\n+\n+fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n+    if let ExprKind::Call(func, args) = expr.kind {\n+        match func.kind {\n+            ExprKind::Path(QPath::TypeRelative(ty, name))\n+                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::vec_type) =>\n+            {\n+                if name.ident.name == sym::new {\n+                    return Some(VecInitKind::New);\n+                } else if name.ident.name.as_str() == \"with_capacity\" {\n+                    return args.get(0).and_then(|arg| {\n+                        if_chain! {\n+                            if let ExprKind::Lit(lit) = &arg.kind;\n+                            if let LitKind::Int(num, _) = lit.node;\n+                            then {\n+                                Some(VecInitKind::WithCapacity(num.try_into().ok()?))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    });\n+                }\n+            }\n+            ExprKind::Path(QPath::Resolved(_, path))\n+                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n+                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::vec_type) =>\n+            {\n+                return Some(VecInitKind::New);\n+            }\n+            _ => (),\n+        }\n+    }\n+    None\n+}"}, {"sha": "10005a7fc81ed1381abdada242234bcbbcb802de", "filename": "clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -7,7 +7,8 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::BytePos;\n+use rustc_span::symbol::kw;\n+use rustc_span::{sym, BytePos};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `use Enum::*`.\n@@ -198,12 +199,12 @@ impl WildcardImports {\n // Allow \"...prelude::..::*\" imports.\n // Many crates have a prelude, and it is imported as a glob by design.\n fn is_prelude_import(segments: &[PathSegment<'_>]) -> bool {\n-    segments.iter().any(|ps| ps.ident.as_str() == \"prelude\")\n+    segments.iter().any(|ps| ps.ident.name == sym::prelude)\n }\n \n // Allow \"super::*\" imports in tests.\n fn is_super_only_import(segments: &[PathSegment<'_>]) -> bool {\n-    segments.len() == 1 && segments[0].ident.as_str() == \"super\"\n+    segments.len() == 1 && segments[0].ident.name == kw::Super\n }\n \n fn is_test_module_or_function(item: &Item<'_>) -> bool {"}, {"sha": "af324f831dfa2e9fc16f9f412003a63d80585f42", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -10,7 +10,8 @@ use rustc_lexer::unescape::{self, EscapeError};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{sym, BytePos, Span, Symbol};\n+use rustc_span::symbol::kw;\n+use rustc_span::{sym, BytePos, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -301,7 +302,7 @@ impl EarlyLintPass for Write {\n             }\n         } else if mac.path == sym!(writeln) {\n             if let (Some(fmt_str), expr) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n-                if fmt_str.symbol == Symbol::intern(\"\") {\n+                if fmt_str.symbol == kw::Empty {\n                     let mut applicability = Applicability::MachineApplicable;\n                     // FIXME: remove this `#[allow(...)]` once the issue #5822 gets fixed\n                     #[allow(clippy::option_if_let_else)]\n@@ -484,7 +485,7 @@ impl Write {\n \n     fn lint_println_empty_string(&self, cx: &EarlyContext<'_>, mac: &MacCall) {\n         if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n-            if fmt_str.symbol == Symbol::intern(\"\") {\n+            if fmt_str.symbol == kw::Empty {\n                 let name = mac.path.segments[0].ident.name;\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "1a7a30c61be5b8fb9fc8987fc4fdc32667765165", "filename": "doc/adding_lints.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -147,10 +147,14 @@ add `// edition:2018` at the top of the test file (note that it's space-sensitiv\n \n Manually testing against an example file can be useful if you have added some\n `println!`s and the test suite output becomes unreadable. To try Clippy with\n-your local modifications, run `env CLIPPY_TESTS=true cargo run --bin\n-clippy-driver -- -L ./target/debug input.rs` from the working copy root.\n+your local modifications, run\n \n-With tests in place, let's have a look at implementing our lint now.\n+```\n+env __CLIPPY_INTERNAL_TESTS=true cargo run --bin clippy-driver -- -L ./target/debug input.rs\n+```\n+\n+from the working copy root. With tests in place, let's have a look at\n+implementing our lint now.\n \n ## Lint declaration\n "}, {"sha": "fe8b080f56f2bc0c518c7b3e2049def4eed5b9f1", "filename": "doc/roadmap-2021.md", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/doc%2Froadmap-2021.md", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/doc%2Froadmap-2021.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Froadmap-2021.md?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,235 @@\n+# Roadmap 2021\n+\n+# Summary\n+\n+This Roadmap lays out the plans for Clippy in 2021:\n+\n+- Improving usability and reliability\n+- Improving experience of contributors and maintainers\n+- Develop and specify processes\n+\n+Members of the Clippy team will be assigned tasks from one or more of these\n+topics. The team member is then responsible to complete the assigned tasks. This\n+can either be done by implementing them or by providing mentorship to interested\n+contributors.\n+\n+# Motivation\n+\n+With the ongoing growth of the Rust language and with that of the whole\n+ecosystem, also Clippy gets more and more users and contributors. This is good\n+for the project, but also brings challenges along. Some of these challenges are:\n+\n+- More issues about reliability or usability are popping up\n+- Traffic is hard to handle for a small team\n+- Bigger projects don't get completed due to the lack of processes and/or time\n+  of the team members\n+\n+Additionally, according to the [Rust Roadmap 2021], clear processes should be\n+defined by every team and unified across teams. This Roadmap is the first step\n+towards this.\n+\n+[Rust Roadmap 2021]: https://github.com/rust-lang/rfcs/pull/3037\n+\n+# Explanation\n+\n+This section will explain the things that should be done in 2021. It is\n+important to note, that this document focuses on the \"What?\", not the \"How?\".\n+The later will be addressed in follow-up tracking issue, with an assigned team\n+member.\n+\n+The following is split up in two major sections. The first section covers the\n+user facing plans, the second section the internal plans.\n+\n+## User Facing\n+\n+Clippy should be as pleasant to use and configure as possible. This section\n+covers plans that should be implemented to improve the situation of Clippy in\n+this regard.\n+\n+### Usability\n+\n+In the following, plans to improve the usability are covered.\n+\n+#### No Output After `cargo check`\n+\n+Currently when `cargo clippy` is run after `cargo check`, it does not produce\n+any output. This is especially problematic since `rust-analyzer` is on the rise\n+and it uses `cargo check` for checking code. A fix is already implemented, but\n+it still has to be pushed over the finish line. This also includes the\n+stabilization of the `cargo clippy --fix` command or the support of multi-span\n+suggestions in `rustfix`.\n+\n+- [#4612](https://github.com/rust-lang/rust-clippy/issues/4612)\n+\n+#### `lints.toml` Configuration\n+\n+This is something that comes up every now and then: a reusable configuration\n+file, where lint levels can be defined. Discussions about this often lead to\n+nothing specific or to \"we need an RFC for this\". And this is exactly what needs\n+to be done. Get together with the cargo team and write an RFC and implement such\n+a configuration file somehow and somewhere.\n+\n+- [#3164](https://github.com/rust-lang/rust-clippy/issues/3164)\n+- [cargo#5034](https://github.com/rust-lang/cargo/issues/5034)\n+- [IRLO](https://internals.rust-lang.org/t/proposal-cargo-lint-configuration/9135/8)\n+\n+#### Lint Groups\n+\n+There are more and more issues about managing lints in Clippy popping up. Lints\n+are hard to implement with a guarantee of no/few false positives (FPs). One way\n+to address this might be to introduce more lint groups to give users the ability\n+to better manage lints, or improve the process of classifying lints, so that\n+disabling lints due to FPs becomes rare. It is important to note, that Clippy\n+lints are less conservative than `rustc` lints, which won't change in the\n+future.\n+\n+- [#5537](https://github.com/rust-lang/rust-clippy/issues/5537)\n+- [#6366](https://github.com/rust-lang/rust-clippy/issues/6366)\n+\n+### Reliability\n+\n+In the following, plans to improve the reliability are covered.\n+\n+#### False Positive Rate\n+\n+In the worst case, new lints are only available in nightly for 2 weeks, before\n+hitting beta and ultimately stable. This and the fact that fewer people use\n+nightly Rust nowadays makes it more probable that a lint with many FPs hits\n+stable. This leads to annoyed users, that will disable these new lints in the\n+best case and to more annoyed users, that will stop using Clippy in the worst.\n+A process should be developed and implemented to prevent this from happening.\n+\n+- [#6429](https://github.com/rust-lang/rust-clippy/issues/6429)\n+\n+## Internal\n+\n+(The end of) 2020 has shown, that Clippy has to think about the available\n+resources, especially regarding management and maintenance of the project. This\n+section address issues affecting team members and contributors.\n+\n+### Management\n+\n+In 2020 Clippy achieved over 1000 open issues with regularly between 25-35 open\n+PRs. This is simultaneously a win and a loss. More issues and PRs means more\n+people are interested in Clippy and in contributing to it. On the other hand, it\n+means for team members more work and for contributors longer wait times for\n+reviews. The following will describe plans how to improve the situation for both\n+team members and contributors.\n+\n+#### Clear Expectations for Team Members\n+\n+According to the [Rust Roadmap 2021], a document specifying what it means to be\n+a member of the team should be produced. This should not put more pressure on\n+the team members, but rather help them and interested folks to know what the\n+expectations are. With this it should also be easier to recruit new team members\n+and may encourage people to get in touch, if they're interested to join.\n+\n+#### Scaling up the Team\n+\n+More people means less work for each individual. Together with the document\n+about expectations for team members, a document defining the process of how to\n+join the team should be produced. This can also increase the stability of the\n+team, in case of current members dropping out (temporarily). There can also be\n+different roles in the team, like people triaging vs. people reviewing.\n+\n+#### Regular Meetings\n+\n+Other teams have regular meetings. Clippy is big enough that it might be worth\n+to also do them. Especially if more people join the team, this can be important\n+for sync-ups. Besides the asynchronous communication, that works well for\n+working on separate lints, a meeting adds a synchronous alternative at a known\n+time. This is especially helpful if there are bigger things that need to be\n+discussed (like the projects in this roadmap). For starters bi-weekly meetings\n+before Rust syncs might make sense.\n+\n+#### Triaging\n+\n+To get a handle on the influx of open issues, a process for triaging issues and\n+PRs should be developed. Officially, Clippy follows the Rust triage process, but\n+currently no one enforces it. This can be improved by sharing triage teams\n+across projects or by implementing dashboards / tools which simplify triaging.\n+\n+### Development\n+\n+Improving the developer and contributor experience is something the Clippy team\n+works on regularly. Though, some things might need special attention and\n+planing. These topics are listed in the following.\n+\n+#### Process for New and Existing Lints\n+\n+As already mentioned above, classifying new lints gets quite hard, because the\n+probability of a buggy lint getting into stable is quite high. A process should\n+be implemented on how to classify lints. In addition, a test system should be\n+developed to find out which lints are currently problematic in real world code\n+to fix or disable them.\n+\n+- [#6429 (comment)](https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741056379)\n+- [#6429 (comment)](https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741153345)\n+\n+#### Processes\n+\n+Related to the point before, a process for suggesting and discussing major\n+changes should be implemented. It's also not clearly defined when a lint should\n+be enabled or disabled by default. This can also be improved by the test system\n+mentioned above.\n+\n+#### Dev-Tools\n+\n+There's already `cargo dev` which makes Clippy development easier and more\n+pleasant. This can still be expanded, so that it covers more areas of the\n+development process.\n+\n+- [#5394](https://github.com/rust-lang/rust-clippy/issues/5394)\n+\n+#### Contributor Guide\n+\n+Similar to a Clippy Book, which describes how to use Clippy, a book about how to\n+contribute to Clippy might be helpful for new and existing contributors. There's\n+already the `doc` directory in the Clippy repo, this can be turned into a\n+`mdbook`.\n+\n+#### `rustc` integration\n+\n+Recently Clippy was integrated with `git subtree` into the `rust-lang/rust`\n+repository. This made syncing between the two repositories easier. A\n+`#[non_exhaustive]` list of things that still can be improved is:\n+\n+1. Use the same `rustfmt` version and configuration as `rustc`.\n+2. Make `cargo dev` work in the Rust repo, just as it works in the Clippy repo.\n+   E.g. `cargo dev bless` or `cargo dev update_lints`. And even add more things\n+   to it that might be useful for the Rust repo, e.g. `cargo dev deprecate`.\n+3. Easier sync process. The `subtree` situation is not ideal.\n+\n+## Prioritization\n+\n+The most pressing issues for users of Clippy are of course the user facing\n+issues. So there should be a priority on those issues, but without losing track\n+of the internal issues listed in this document.\n+\n+Getting the FP rate of warn/deny-by-default lints under control should have the\n+highest priority. Other user facing issues should also get a high priority, but\n+shouldn't be in the way of addressing internal issues.\n+\n+To better manage the upcoming projects, the basic internal processes, like\n+meetings, tracking issues and documentation, should be established as soon as\n+possible. They might even be necessary to properly manage the projects,\n+regarding the user facing issues.\n+\n+# Prior Art\n+\n+## Rust Roadmap\n+\n+Rust's roadmap process was established by [RFC 1728] in 2016. Since then every\n+year a roadmap was published, that defined the bigger plans for the coming\n+years. This years roadmap can be found [here][Rust Roadmap 2021].\n+\n+[RFC 1728]: https://rust-lang.github.io/rfcs/1728-north-star.html\n+\n+# Drawbacks\n+\n+## Big Roadmap\n+\n+This roadmap is pretty big and not all items listed in this document might be\n+addressed during 2021. Because this is the first roadmap for Clippy, having open\n+tasks at the end of 2021 is fine, but they should be revisited in the 2022\n+roadmap."}, {"sha": "72935072f8cdd8197181979da474f679f87dd221", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-01-02\"\n+channel = \"nightly-2021-01-15\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\", \"rustfmt\"]"}, {"sha": "f5f6c09ed8e940e71b70469405950c3b9fe1f61d", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -298,7 +298,7 @@ pub fn main() {\n         // - IF Clippy is run on the main crate, not on deps (`!cap_lints_allow`) THEN\n         //    - IF `--no-deps` is not set (`!no_deps`) OR\n         //    - IF `--no-deps` is set and Clippy is run on the specified primary package\n-        let clippy_tests_set = env::var(\"CLIPPY_TESTS\").map_or(false, |val| val == \"true\");\n+        let clippy_tests_set = env::var(\"__CLIPPY_INTERNAL_TESTS\").map_or(false, |val| val == \"true\");\n         let cap_lints_allow = arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_some();\n         let in_primary_package = env::var(\"CARGO_PRIMARY_PACKAGE\").is_ok();\n "}, {"sha": "ea800336ef55046f489b47ccc80c58e38334f492", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -254,7 +254,7 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n \n fn prepare_env() {\n     set_var(\"CLIPPY_DISABLE_DOCS_LINKS\", \"true\");\n-    set_var(\"CLIPPY_TESTS\", \"true\");\n+    set_var(\"__CLIPPY_INTERNAL_TESTS\", \"true\");\n     //set_var(\"RUST_BACKTRACE\", \"0\");\n }\n "}, {"sha": "9ab845a573aca66fc880008bee4c0a9f791bda90", "filename": "tests/ui-internal/interning_defined_symbol.fixed", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Finterning_defined_symbol.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Finterning_defined_symbol.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finterning_defined_symbol.fixed?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -14,13 +14,16 @@ macro_rules! sym {\n \n fn main() {\n     // Direct use of Symbol::intern\n-    let _ = rustc_span::symbol::sym::f32;\n+    let _ = rustc_span::sym::f32;\n \n     // Using a sym macro\n-    let _ = rustc_span::symbol::sym::f32;\n+    let _ = rustc_span::sym::f32;\n \n     // Correct suggestion when symbol isn't stringified constant name\n-    let _ = rustc_span::symbol::sym::proc_dash_macro;\n+    let _ = rustc_span::sym::proc_dash_macro;\n+\n+    // interning a keyword\n+    let _ = rustc_span::symbol::kw::SelfLower;\n \n     // Interning a symbol that is not defined\n     let _ = Symbol::intern(\"xyz123\");"}, {"sha": "a58e182971d7323e63b595a9e501f0abb63a63f6", "filename": "tests/ui-internal/interning_defined_symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Finterning_defined_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Finterning_defined_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finterning_defined_symbol.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -22,6 +22,9 @@ fn main() {\n     // Correct suggestion when symbol isn't stringified constant name\n     let _ = Symbol::intern(\"proc-macro\");\n \n+    // interning a keyword\n+    let _ = Symbol::intern(\"self\");\n+\n     // Interning a symbol that is not defined\n     let _ = Symbol::intern(\"xyz123\");\n     let _ = sym!(xyz123);"}, {"sha": "50c1c268eb132e9fdaaab784fae4861be227eb9e", "filename": "tests/ui-internal/interning_defined_symbol.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Finterning_defined_symbol.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Finterning_defined_symbol.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finterning_defined_symbol.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -2,7 +2,7 @@ error: interning a defined symbol\n   --> $DIR/interning_defined_symbol.rs:17:13\n    |\n LL |     let _ = Symbol::intern(\"f32\");\n-   |             ^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::symbol::sym::f32`\n+   |             ^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::sym::f32`\n    |\n note: the lint level is defined here\n   --> $DIR/interning_defined_symbol.rs:2:9\n@@ -15,13 +15,19 @@ error: interning a defined symbol\n   --> $DIR/interning_defined_symbol.rs:20:13\n    |\n LL |     let _ = sym!(f32);\n-   |             ^^^^^^^^^ help: try: `rustc_span::symbol::sym::f32`\n+   |             ^^^^^^^^^ help: try: `rustc_span::sym::f32`\n \n error: interning a defined symbol\n   --> $DIR/interning_defined_symbol.rs:23:13\n    |\n LL |     let _ = Symbol::intern(\"proc-macro\");\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::symbol::sym::proc_dash_macro`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::sym::proc_dash_macro`\n \n-error: aborting due to 3 previous errors\n+error: interning a defined symbol\n+  --> $DIR/interning_defined_symbol.rs:26:13\n+   |\n+LL |     let _ = Symbol::intern(\"self\");\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::symbol::kw::SelfLower`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "2ec0efe4c10a5125ed60d9220ebdb419bc78214a", "filename": "tests/ui-internal/unnecessary_symbol_str.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Funnecessary_symbol_str.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Funnecessary_symbol_str.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_symbol_str.fixed?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![feature(rustc_private)]\n+#![deny(clippy::internal)]\n+#![allow(clippy::unnecessary_operation, unused_must_use)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::{Ident, Symbol};\n+\n+fn main() {\n+    Symbol::intern(\"foo\") == rustc_span::sym::clippy;\n+    Symbol::intern(\"foo\") == rustc_span::symbol::kw::SelfLower;\n+    Symbol::intern(\"foo\") != rustc_span::symbol::kw::SelfUpper;\n+    Ident::invalid().name == rustc_span::sym::clippy;\n+    rustc_span::sym::clippy == Ident::invalid().name;\n+}"}, {"sha": "87e1b3a2ee76a9ebd8d53268d29835a5a3904a34", "filename": "tests/ui-internal/unnecessary_symbol_str.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Funnecessary_symbol_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Funnecessary_symbol_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_symbol_str.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![feature(rustc_private)]\n+#![deny(clippy::internal)]\n+#![allow(clippy::unnecessary_operation, unused_must_use)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::{Ident, Symbol};\n+\n+fn main() {\n+    Symbol::intern(\"foo\").as_str() == \"clippy\";\n+    Symbol::intern(\"foo\").to_string() == \"self\";\n+    Symbol::intern(\"foo\").to_ident_string() != \"Self\";\n+    &*Ident::invalid().as_str() == \"clippy\";\n+    \"clippy\" == Ident::invalid().to_string();\n+}"}, {"sha": "b1284b7c8ffd036393046ea09ab8dcebd6abe0cd", "filename": "tests/ui-internal/unnecessary_symbol_str.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Funnecessary_symbol_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui-internal%2Funnecessary_symbol_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_symbol_str.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,39 @@\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:11:5\n+   |\n+LL |     Symbol::intern(\"foo\").as_str() == \"clippy\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Symbol::intern(\"foo\") == rustc_span::sym::clippy`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unnecessary_symbol_str.rs:3:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::unnecessary_symbol_str)]` implied by `#[deny(clippy::internal)]`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:12:5\n+   |\n+LL |     Symbol::intern(\"foo\").to_string() == \"self\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Symbol::intern(\"foo\") == rustc_span::symbol::kw::SelfLower`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:13:5\n+   |\n+LL |     Symbol::intern(\"foo\").to_ident_string() != \"Self\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Symbol::intern(\"foo\") != rustc_span::symbol::kw::SelfUpper`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:14:5\n+   |\n+LL |     &*Ident::invalid().as_str() == \"clippy\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Ident::invalid().name == rustc_span::sym::clippy`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:15:5\n+   |\n+LL |     \"clippy\" == Ident::invalid().to_string();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::sym::clippy == Ident::invalid().name`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "d6ecd8568ce78966249f5d2872b274e469ff80ce", "filename": "tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -94,3 +94,19 @@ macro_rules! large_enum_variant {\n         }\n     };\n }\n+\n+#[macro_export]\n+macro_rules! field_reassign_with_default {\n+    () => {\n+        #[derive(Default)]\n+        struct A {\n+            pub i: i32,\n+            pub j: i64,\n+        }\n+        fn lint() {\n+            let mut a: A = Default::default();\n+            a.i = 42;\n+            a;\n+        }\n+    };\n+}"}, {"sha": "24891682d368d0bfa2f167f88512040928442dab", "filename": "tests/ui/auxiliary/proc_macro_derive.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -4,6 +4,7 @@\n #![crate_type = \"proc-macro\"]\n #![feature(repr128, proc_macro_quote)]\n #![allow(incomplete_features)]\n+#![allow(clippy::field_reassign_with_default)]\n #![allow(clippy::eq_op)]\n \n extern crate proc_macro;\n@@ -23,3 +24,20 @@ pub fn derive(_: TokenStream) -> TokenStream {\n     };\n     output\n }\n+\n+#[proc_macro_derive(FieldReassignWithDefault)]\n+pub fn derive_foo(_input: TokenStream) -> TokenStream {\n+    quote! {\n+        #[derive(Default)]\n+        struct A {\n+            pub i: i32,\n+            pub j: i64,\n+        }\n+        #[automatically_derived]\n+        fn lint() {\n+            let mut a: A = Default::default();\n+            a.i = 42;\n+            a;\n+        }\n+    }\n+}"}, {"sha": "d011e84b115a7aee99a7f049af33f3fac36be4d2", "filename": "tests/ui/cast_alignment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcast_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcast_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_alignment.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -12,6 +12,10 @@ fn main() {\n     (&1u8 as *const u8) as *const u16;\n     (&mut 1u8 as *mut u8) as *mut u16;\n \n+    // cast to more-strictly-aligned type, but with the `pointer::cast` function.\n+    (&1u8 as *const u8).cast::<u16>();\n+    (&mut 1u8 as *mut u8).cast::<u16>();\n+\n     /* These should be ok */\n \n     // not a pointer type"}, {"sha": "7998b787b91fbd70cb353d0c1ef990d11e6018d7", "filename": "tests/ui/cast_alignment.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcast_alignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcast_alignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_alignment.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -12,5 +12,17 @@ error: casting from `*mut u8` to a more-strictly-aligned pointer (`*mut u16`) (1\n LL |     (&mut 1u8 as *mut u8) as *mut u16;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: casting from `*const u8` to a more-strictly-aligned pointer (`*const u16`) (1 < 2 bytes)\n+  --> $DIR/cast_alignment.rs:16:5\n+   |\n+LL |     (&1u8 as *const u8).cast::<u16>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting from `*mut u8` to a more-strictly-aligned pointer (`*mut u16`) (1 < 2 bytes)\n+  --> $DIR/cast_alignment.rs:17:5\n+   |\n+LL |     (&mut 1u8 as *mut u8).cast::<u16>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "d924625132eb0ccc48844f6cfce21e54302c5615", "filename": "tests/ui/clone_on_copy.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fclone_on_copy.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fclone_on_copy.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.fixed?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -5,7 +5,8 @@\n     clippy::redundant_clone,\n     clippy::deref_addrof,\n     clippy::no_effect,\n-    clippy::unnecessary_operation\n+    clippy::unnecessary_operation,\n+    clippy::vec_init_then_push\n )]\n \n use std::cell::RefCell;"}, {"sha": "97f4946724458d5955f1d82b7ade9345f0a750b8", "filename": "tests/ui/clone_on_copy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -5,7 +5,8 @@\n     clippy::redundant_clone,\n     clippy::deref_addrof,\n     clippy::no_effect,\n-    clippy::unnecessary_operation\n+    clippy::unnecessary_operation,\n+    clippy::vec_init_then_push\n )]\n \n use std::cell::RefCell;"}, {"sha": "7a706884fb0e7d74e71bba20d1b1ae331e4ca4f4", "filename": "tests/ui/clone_on_copy.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fclone_on_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fclone_on_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,31 +1,31 @@\n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:22:5\n+  --> $DIR/clone_on_copy.rs:23:5\n    |\n LL |     42.clone();\n    |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n    |\n    = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:26:5\n+  --> $DIR/clone_on_copy.rs:27:5\n    |\n LL |     (&42).clone();\n    |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:29:5\n+  --> $DIR/clone_on_copy.rs:30:5\n    |\n LL |     rc.borrow().clone();\n    |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n \n error: using `clone` on type `char` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:35:14\n+  --> $DIR/clone_on_copy.rs:36:14\n    |\n LL |     is_ascii('z'.clone());\n    |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:39:14\n+  --> $DIR/clone_on_copy.rs:40:14\n    |\n LL |     vec.push(42.clone());\n    |              ^^^^^^^^^^ help: try removing the `clone` call: `42`"}, {"sha": "fa4bc30e933a2a0ba4252edafe3b7ef9e9e5cbf7", "filename": "tests/ui/collapsible_else_if.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcollapsible_else_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcollapsible_else_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.fixed?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -3,6 +3,8 @@\n \n #[rustfmt::skip]\n #[warn(clippy::collapsible_if)]\n+#[warn(clippy::collapsible_else_if)]\n+\n fn main() {\n     let x = \"hello\";\n     let y = \"world\";"}, {"sha": "bf6c1d1f894d7807a5c03a00b5e08f02f6ffa30c", "filename": "tests/ui/collapsible_else_if.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcollapsible_else_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcollapsible_else_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -3,6 +3,8 @@\n \n #[rustfmt::skip]\n #[warn(clippy::collapsible_if)]\n+#[warn(clippy::collapsible_else_if)]\n+\n fn main() {\n     let x = \"hello\";\n     let y = \"world\";"}, {"sha": "ee3e11ae565d405435cafdbae0e27cf845698ee6", "filename": "tests/ui/collapsible_else_if.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcollapsible_else_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fcollapsible_else_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,5 +1,5 @@\n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:12:12\n+  --> $DIR/collapsible_else_if.rs:14:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -9,7 +9,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-   = note: `-D clippy::collapsible-if` implied by `-D warnings`\n+   = note: `-D clippy::collapsible-else-if` implied by `-D warnings`\n help: collapse nested if block\n    |\n LL |     } else if y == \"world\" {\n@@ -18,7 +18,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:20:12\n+  --> $DIR/collapsible_else_if.rs:22:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -36,7 +36,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:28:12\n+  --> $DIR/collapsible_else_if.rs:30:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -59,7 +59,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:39:12\n+  --> $DIR/collapsible_else_if.rs:41:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -82,7 +82,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:50:12\n+  --> $DIR/collapsible_else_if.rs:52:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -105,7 +105,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:61:12\n+  --> $DIR/collapsible_else_if.rs:63:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -128,7 +128,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:72:12\n+  --> $DIR/collapsible_else_if.rs:74:12\n    |\n LL |       } else {\n    |  ____________^"}, {"sha": "a2e5c13c45282c50b93ec0e00d6723660af34033", "filename": "tests/ui/empty_enum.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_enum.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,6 +1,7 @@\n #![allow(dead_code)]\n #![warn(clippy::empty_enum)]\n-\n+// Enable never type to test empty enum lint\n+#![feature(never_type)]\n enum Empty {}\n \n fn main() {}"}, {"sha": "7125e5f602b75ba962c400f6824b82e19b3d4bba", "filename": "tests/ui/empty_enum.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fempty_enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fempty_enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_enum.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,5 +1,5 @@\n error: enum with no variants\n-  --> $DIR/empty_enum.rs:4:1\n+  --> $DIR/empty_enum.rs:5:1\n    |\n LL | enum Empty {}\n    | ^^^^^^^^^^^^^"}, {"sha": "386677352e29be18d9b0876af6f3c89e10097091", "filename": "tests/ui/empty_enum_without_never_type.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fempty_enum_without_never_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fempty_enum_without_never_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_enum_without_never_type.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,7 @@\n+#![allow(dead_code)]\n+#![warn(clippy::empty_enum)]\n+\n+// `never_type` is not enabled; this test has no stderr file\n+enum Empty {}\n+\n+fn main() {}"}, {"sha": "d26f48fc68f85ebe4ebd07a4027c81539e311dad", "filename": "tests/ui/escape_analysis.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -182,3 +182,23 @@ pub extern \"C\" fn do_not_warn_me(_c_pointer: Box<String>) -> () {}\n \n #[rustfmt::skip] // Forces rustfmt to not add ABI\n pub extern fn do_not_warn_me_no_abi(_c_pointer: Box<String>) -> () {}\n+\n+// Issue #4804 - default implementation in trait\n+mod issue4804 {\n+    trait DefaultTraitImplTest {\n+        // don't warn on `self`\n+        fn default_impl(self: Box<Self>) -> u32 {\n+            5\n+        }\n+\n+        // warn on `x: Box<u32>`\n+        fn default_impl_x(self: Box<Self>, x: Box<u32>) -> u32 {\n+            4\n+        }\n+    }\n+\n+    trait WarnTrait {\n+        // warn on `x: Box<u32>`\n+        fn foo(x: Box<u32>) {}\n+    }\n+}"}, {"sha": "4a82b4419f9974488e68f4f7ec8d3a5932687fcd", "filename": "tests/ui/escape_analysis.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fescape_analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fescape_analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -12,5 +12,17 @@ error: local variable doesn't need to be boxed here\n LL | pub fn new(_needs_name: Box<PeekableSeekable<&()>>) -> () {}\n    |            ^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: local variable doesn't need to be boxed here\n+  --> $DIR/escape_analysis.rs:195:44\n+   |\n+LL |         fn default_impl_x(self: Box<Self>, x: Box<u32>) -> u32 {\n+   |                                            ^\n+\n+error: local variable doesn't need to be boxed here\n+  --> $DIR/escape_analysis.rs:202:16\n+   |\n+LL |         fn foo(x: Box<u32>) {}\n+   |                ^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "9fc208f5332a5ccbb9e9567425bac44d2ffb1dd7", "filename": "tests/ui/field_reassign_with_default.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ffield_reassign_with_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ffield_reassign_with_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,5 +1,18 @@\n+// aux-build:proc_macro_derive.rs\n+// aux-build:macro_rules.rs\n+\n #![warn(clippy::field_reassign_with_default)]\n \n+#[macro_use]\n+extern crate proc_macro_derive;\n+#[macro_use]\n+extern crate macro_rules;\n+\n+// Don't lint on derives that derive `Default`\n+// See https://github.com/rust-lang/rust-clippy/issues/6545\n+#[derive(FieldReassignWithDefault)]\n+struct DerivedStruct;\n+\n #[derive(Default)]\n struct A {\n     i: i32,\n@@ -11,6 +24,11 @@ struct B {\n     j: i64,\n }\n \n+#[derive(Default)]\n+struct C {\n+    i: Vec<i32>,\n+    j: i64,\n+}\n /// Implements .next() that returns a different number each time.\n struct SideEffect(i32);\n \n@@ -111,6 +129,13 @@ fn main() {\n     // don't lint - some private fields\n     let mut x = m::F::default();\n     x.a = 1;\n+\n+    // don't expand macros in the suggestion (#6522)\n+    let mut a: C = C::default();\n+    a.i = vec![1];\n+\n+    // Don't lint in external macros\n+    field_reassign_with_default!();\n }\n \n mod m {"}, {"sha": "2f0f28f7bb724f92422ce0e618423342880d8f1f", "filename": "tests/ui/field_reassign_with_default.stderr", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ffield_reassign_with_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ffield_reassign_with_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,75 +1,87 @@\n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:30:5\n+  --> $DIR/field_reassign_with_default.rs:48:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::field-reassign-with-default` implied by `-D warnings`\n-note: consider initializing the variable with `A { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:29:5\n+note: consider initializing the variable with `main::A { i: 42, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:47:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:70:5\n+  --> $DIR/field_reassign_with_default.rs:88:5\n    |\n LL |     a.j = 43;\n    |     ^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { j: 43, i: 42 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:69:5\n+note: consider initializing the variable with `main::A { j: 43, i: 42 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:87:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:75:5\n+  --> $DIR/field_reassign_with_default.rs:93:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { i: 42, j: 44 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:74:5\n+note: consider initializing the variable with `main::A { i: 42, j: 44 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:92:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:81:5\n+  --> $DIR/field_reassign_with_default.rs:99:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:80:5\n+note: consider initializing the variable with `main::A { i: 42, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:98:5\n    |\n LL |     let mut a = A::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:91:5\n+  --> $DIR/field_reassign_with_default.rs:109:5\n    |\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { i: Default::default(), ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:90:5\n+note: consider initializing the variable with `main::A { i: Default::default(), ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:108:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:95:5\n+  --> $DIR/field_reassign_with_default.rs:113:5\n    |\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { i: Default::default(), j: 45 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:94:5\n+note: consider initializing the variable with `main::A { i: Default::default(), j: 45 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:112:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:135:5\n+   |\n+LL |     a.i = vec![1];\n+   |     ^^^^^^^^^^^^^^\n+   |\n+note: consider initializing the variable with `C { i: vec![1], ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:134:5\n+   |\n+LL |     let mut a: C = C::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "b101d2704fbda52692767a9e2a2a67679bea3711", "filename": "tests/ui/from_over_into.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ffrom_over_into.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ffrom_over_into.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,12 +1,8 @@\n error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n   --> $DIR/from_over_into.rs:6:1\n    |\n-LL | / impl Into<StringWrapper> for String {\n-LL | |     fn into(self) -> StringWrapper {\n-LL | |         StringWrapper(self)\n-LL | |     }\n-LL | | }\n-   | |_^\n+LL | impl Into<StringWrapper> for String {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::from-over-into` implied by `-D warnings`\n    = help: consider to implement `From` instead"}, {"sha": "e83ce47e563080b5a25e0bad69d0d57fc3c581be", "filename": "tests/ui/if_same_then_else2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fif_same_then_else2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fif_same_then_else2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,6 +1,7 @@\n #![warn(clippy::if_same_then_else)]\n #![allow(\n     clippy::blacklisted_name,\n+    clippy::collapsible_else_if,\n     clippy::collapsible_if,\n     clippy::ifs_same_cond,\n     clippy::needless_return,"}, {"sha": "f98e30fa376fea22a8198cb4faffd5218ba94dad", "filename": "tests/ui/if_same_then_else2.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fif_same_then_else2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fif_same_then_else2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,5 +1,5 @@\n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:20:12\n+  --> $DIR/if_same_then_else2.rs:21:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -13,7 +13,7 @@ LL | |     }\n    |\n    = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:11:13\n+  --> $DIR/if_same_then_else2.rs:12:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -26,7 +26,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:34:12\n+  --> $DIR/if_same_then_else2.rs:35:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -36,7 +36,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:32:13\n+  --> $DIR/if_same_then_else2.rs:33:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -45,7 +45,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:41:12\n+  --> $DIR/if_same_then_else2.rs:42:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -55,7 +55,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:39:13\n+  --> $DIR/if_same_then_else2.rs:40:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -64,7 +64,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:91:12\n+  --> $DIR/if_same_then_else2.rs:92:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -74,7 +74,7 @@ LL | |     };\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:89:21\n+  --> $DIR/if_same_then_else2.rs:90:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n@@ -83,7 +83,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:98:12\n+  --> $DIR/if_same_then_else2.rs:99:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -93,7 +93,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:96:13\n+  --> $DIR/if_same_then_else2.rs:97:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -102,7 +102,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:123:12\n+  --> $DIR/if_same_then_else2.rs:124:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -112,7 +112,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:120:20\n+  --> $DIR/if_same_then_else2.rs:121:20\n    |\n LL |       } else if true {\n    |  ____________________^"}, {"sha": "70218f3f041d8675cbb8c5d74800e66462f904ed", "filename": "tests/ui/needless_question_mark.fixed", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_question_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_question_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.fixed?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,163 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_question_mark)]\n+#![allow(clippy::needless_return, clippy::unnecessary_unwrap, dead_code, unused_must_use)]\n+#![feature(custom_inner_attributes)]\n+\n+struct TO {\n+    magic: Option<usize>,\n+}\n+\n+struct TR {\n+    magic: Result<usize, bool>,\n+}\n+\n+fn simple_option_bad1(to: TO) -> Option<usize> {\n+    // return as a statement\n+    return to.magic;\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_option_bad2(to: TO) -> Option<usize> {\n+    // return as an expression\n+    return to.magic\n+}\n+\n+fn simple_option_bad3(to: TO) -> Option<usize> {\n+    // block value \"return\"\n+    to.magic\n+}\n+\n+fn simple_option_bad4(to: Option<TO>) -> Option<usize> {\n+    // single line closure\n+    to.and_then(|t| t.magic)\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_option_bad5(to: Option<TO>) -> Option<usize> {\n+    // closure with body\n+    to.and_then(|t| {\n+        t.magic\n+    })\n+}\n+\n+fn simple_result_bad1(tr: TR) -> Result<usize, bool> {\n+    return tr.magic;\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_result_bad2(tr: TR) -> Result<usize, bool> {\n+    return tr.magic\n+}\n+\n+fn simple_result_bad3(tr: TR) -> Result<usize, bool> {\n+    tr.magic\n+}\n+\n+fn simple_result_bad4(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| t.magic)\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_result_bad5(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| {\n+        t.magic\n+    })\n+}\n+\n+fn also_bad(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    if tr.is_ok() {\n+        let t = tr.unwrap();\n+        return t.magic;\n+    }\n+    Err(false)\n+}\n+\n+fn false_positive_test<U, T>(x: Result<(), U>) -> Result<(), T>\n+where\n+    T: From<U>,\n+{\n+    Ok(x?)\n+}\n+\n+fn main() {}\n+\n+mod question_mark_none {\n+    #![clippy::msrv = \"1.12.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should not be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_result {\n+    #![clippy::msrv = \"1.21.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        to.magic // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_both {\n+    #![clippy::msrv = \"1.22.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        to.magic // should be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        to.magic // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}"}, {"sha": "60ac2c8d72eac920afe0a46b4253f8ac5594b316", "filename": "tests/ui/needless_question_mark.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,163 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_question_mark)]\n+#![allow(clippy::needless_return, clippy::unnecessary_unwrap, dead_code, unused_must_use)]\n+#![feature(custom_inner_attributes)]\n+\n+struct TO {\n+    magic: Option<usize>,\n+}\n+\n+struct TR {\n+    magic: Result<usize, bool>,\n+}\n+\n+fn simple_option_bad1(to: TO) -> Option<usize> {\n+    // return as a statement\n+    return Some(to.magic?);\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_option_bad2(to: TO) -> Option<usize> {\n+    // return as an expression\n+    return Some(to.magic?)\n+}\n+\n+fn simple_option_bad3(to: TO) -> Option<usize> {\n+    // block value \"return\"\n+    Some(to.magic?)\n+}\n+\n+fn simple_option_bad4(to: Option<TO>) -> Option<usize> {\n+    // single line closure\n+    to.and_then(|t| Some(t.magic?))\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_option_bad5(to: Option<TO>) -> Option<usize> {\n+    // closure with body\n+    to.and_then(|t| {\n+        Some(t.magic?)\n+    })\n+}\n+\n+fn simple_result_bad1(tr: TR) -> Result<usize, bool> {\n+    return Ok(tr.magic?);\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_result_bad2(tr: TR) -> Result<usize, bool> {\n+    return Ok(tr.magic?)\n+}\n+\n+fn simple_result_bad3(tr: TR) -> Result<usize, bool> {\n+    Ok(tr.magic?)\n+}\n+\n+fn simple_result_bad4(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| Ok(t.magic?))\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_result_bad5(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| {\n+        Ok(t.magic?)\n+    })\n+}\n+\n+fn also_bad(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    if tr.is_ok() {\n+        let t = tr.unwrap();\n+        return Ok(t.magic?);\n+    }\n+    Err(false)\n+}\n+\n+fn false_positive_test<U, T>(x: Result<(), U>) -> Result<(), T>\n+where\n+    T: From<U>,\n+{\n+    Ok(x?)\n+}\n+\n+fn main() {}\n+\n+mod question_mark_none {\n+    #![clippy::msrv = \"1.12.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should not be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_result {\n+    #![clippy::msrv = \"1.21.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_both {\n+    #![clippy::msrv = \"1.22.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}"}, {"sha": "b4eb21882ece95a30fa14fe7493c991df2556887", "filename": "tests/ui/needless_question_mark.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_question_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_question_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,88 @@\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:17:12\n+   |\n+LL |     return Some(to.magic?);\n+   |            ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+   |\n+   = note: `-D clippy::needless-question-mark` implied by `-D warnings`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:25:12\n+   |\n+LL |     return Some(to.magic?)\n+   |            ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:30:5\n+   |\n+LL |     Some(to.magic?)\n+   |     ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:35:21\n+   |\n+LL |     to.and_then(|t| Some(t.magic?))\n+   |                     ^^^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:44:9\n+   |\n+LL |         Some(t.magic?)\n+   |         ^^^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:49:12\n+   |\n+LL |     return Ok(tr.magic?);\n+   |            ^^^^^^^^^^^^^ help: try: `tr.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:56:12\n+   |\n+LL |     return Ok(tr.magic?)\n+   |            ^^^^^^^^^^^^^ help: try: `tr.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:60:5\n+   |\n+LL |     Ok(tr.magic?)\n+   |     ^^^^^^^^^^^^^ help: try: `tr.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:64:21\n+   |\n+LL |     tr.and_then(|t| Ok(t.magic?))\n+   |                     ^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:72:9\n+   |\n+LL |         Ok(t.magic?)\n+   |         ^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:79:16\n+   |\n+LL |         return Ok(t.magic?);\n+   |                ^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:132:9\n+   |\n+LL |         Ok(to.magic?) // should be triggered\n+   |         ^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:148:9\n+   |\n+LL |         Some(to.magic?) // should be triggered\n+   |         ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:156:9\n+   |\n+LL |         Ok(to.magic?) // should be triggered\n+   |         ^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: aborting due to 14 previous errors\n+"}, {"sha": "86bfc5b4bb28377f1b462b6d87eb22de2bb8e2cb", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -86,6 +86,21 @@ fn borrows_but_not_last(value: bool) -> String {\n     }\n }\n \n+macro_rules! needed_return {\n+    ($e:expr) => {\n+        if $e > 3 {\n+            return;\n+        }\n+    };\n+}\n+\n+fn test_return_in_macro() {\n+    // This will return and the macro below won't be executed. Removing the `return` from the macro\n+    // will change semantics.\n+    needed_return!(10);\n+    needed_return!(0);\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "51061370dfe74a8f6f2f0d9388e94ebeb4cd99ec", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -86,6 +86,21 @@ fn borrows_but_not_last(value: bool) -> String {\n     }\n }\n \n+macro_rules! needed_return {\n+    ($e:expr) => {\n+        if $e > 3 {\n+            return;\n+        }\n+    };\n+}\n+\n+fn test_return_in_macro() {\n+    // This will return and the macro below won't be executed. Removing the `return` from the macro\n+    // will change semantics.\n+    needed_return!(10);\n+    needed_return!(0);\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "8346a9454f4eee45040c9bcae8905de7cd64c494", "filename": "tests/ui/ptr_as_ptr.fixed", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fptr_as_ptr.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fptr_as_ptr.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_as_ptr.fixed?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![warn(clippy::ptr_as_ptr)]\n+#![feature(custom_inner_attributes)]\n+\n+fn main() {\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    let _ = ptr.cast::<i32>();\n+    let _ = mut_ptr.cast::<i32>();\n+\n+    // Make sure the lint can handle the difference in their operator precedences.\n+    unsafe {\n+        let ptr_ptr: *const *const u32 = &ptr;\n+        let _ = (*ptr_ptr).cast::<i32>();\n+    }\n+\n+    // Changes in mutability. Do not lint this.\n+    let _ = ptr as *mut i32;\n+    let _ = mut_ptr as *const i32;\n+\n+    // `pointer::cast` cannot perform unsized coercions unlike `as`. Do not lint this.\n+    let ptr_of_array: *const [u32; 4] = &[1, 2, 3, 4];\n+    let _ = ptr_of_array as *const [u32];\n+    let _ = ptr_of_array as *const dyn std::fmt::Debug;\n+\n+    // Ensure the lint doesn't produce unnecessary turbofish for inferred types.\n+    let _: *const i32 = ptr.cast();\n+    let _: *mut i32 = mut_ptr.cast();\n+}\n+\n+fn _msrv_1_37() {\n+    #![clippy::msrv = \"1.37\"]\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    // `pointer::cast` was stabilized in 1.38. Do not lint this\n+    let _ = ptr as *const i32;\n+    let _ = mut_ptr as *mut i32;\n+}\n+\n+fn _msrv_1_38() {\n+    #![clippy::msrv = \"1.38\"]\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    let _ = ptr.cast::<i32>();\n+    let _ = mut_ptr.cast::<i32>();\n+}"}, {"sha": "b68d4bc0aaca1f91cc3ed1244953124fe29aaf49", "filename": "tests/ui/ptr_as_ptr.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_as_ptr.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![warn(clippy::ptr_as_ptr)]\n+#![feature(custom_inner_attributes)]\n+\n+fn main() {\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    let _ = ptr as *const i32;\n+    let _ = mut_ptr as *mut i32;\n+\n+    // Make sure the lint can handle the difference in their operator precedences.\n+    unsafe {\n+        let ptr_ptr: *const *const u32 = &ptr;\n+        let _ = *ptr_ptr as *const i32;\n+    }\n+\n+    // Changes in mutability. Do not lint this.\n+    let _ = ptr as *mut i32;\n+    let _ = mut_ptr as *const i32;\n+\n+    // `pointer::cast` cannot perform unsized coercions unlike `as`. Do not lint this.\n+    let ptr_of_array: *const [u32; 4] = &[1, 2, 3, 4];\n+    let _ = ptr_of_array as *const [u32];\n+    let _ = ptr_of_array as *const dyn std::fmt::Debug;\n+\n+    // Ensure the lint doesn't produce unnecessary turbofish for inferred types.\n+    let _: *const i32 = ptr as *const _;\n+    let _: *mut i32 = mut_ptr as _;\n+}\n+\n+fn _msrv_1_37() {\n+    #![clippy::msrv = \"1.37\"]\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    // `pointer::cast` was stabilized in 1.38. Do not lint this\n+    let _ = ptr as *const i32;\n+    let _ = mut_ptr as *mut i32;\n+}\n+\n+fn _msrv_1_38() {\n+    #![clippy::msrv = \"1.38\"]\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    let _ = ptr as *const i32;\n+    let _ = mut_ptr as *mut i32;\n+}"}, {"sha": "854906dc111dfec2bcd5a4dc3852ee99f5a2ec74", "filename": "tests/ui/ptr_as_ptr.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fptr_as_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fptr_as_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_as_ptr.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,46 @@\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:10:13\n+   |\n+LL |     let _ = ptr as *const i32;\n+   |             ^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `ptr.cast::<i32>()`\n+   |\n+   = note: `-D clippy::ptr-as-ptr` implied by `-D warnings`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:11:13\n+   |\n+LL |     let _ = mut_ptr as *mut i32;\n+   |             ^^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `mut_ptr.cast::<i32>()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:16:17\n+   |\n+LL |         let _ = *ptr_ptr as *const i32;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `(*ptr_ptr).cast::<i32>()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:29:25\n+   |\n+LL |     let _: *const i32 = ptr as *const _;\n+   |                         ^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `ptr.cast()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:30:23\n+   |\n+LL |     let _: *mut i32 = mut_ptr as _;\n+   |                       ^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `mut_ptr.cast()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:48:13\n+   |\n+LL |     let _ = ptr as *const i32;\n+   |             ^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `ptr.cast::<i32>()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:49:13\n+   |\n+LL |     let _ = mut_ptr as *mut i32;\n+   |             ^^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `mut_ptr.cast::<i32>()`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "5b96bb59c5f188beda95e9f595bb496114dd7706", "filename": "tests/ui/try_err.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ftry_err.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ftry_err.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.fixed?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -2,7 +2,7 @@\n // aux-build:macro_rules.rs\n \n #![deny(clippy::try_err)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(clippy::unnecessary_wraps, clippy::needless_question_mark)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "f220d697d2cd7e5e0592596605bb0b038ef6a468", "filename": "tests/ui/try_err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -2,7 +2,7 @@\n // aux-build:macro_rules.rs\n \n #![deny(clippy::try_err)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(clippy::unnecessary_wraps, clippy::needless_question_mark)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "b6a7bc5a1cc95466bd3f3d4fa0c28a6998053753", "filename": "tests/ui/unit_arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -5,7 +5,8 @@\n     unused_variables,\n     clippy::unused_unit,\n     clippy::unnecessary_wraps,\n-    clippy::or_fun_call\n+    clippy::or_fun_call,\n+    clippy::needless_question_mark\n )]\n \n use std::fmt::Debug;"}, {"sha": "094cff8c98591146dd7558d321afed17894cd9d6", "filename": "tests/ui/unit_arg.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -1,5 +1,5 @@\n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:30:5\n+  --> $DIR/unit_arg.rs:31:5\n    |\n LL | /     foo({\n LL | |         1;\n@@ -20,7 +20,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:33:5\n+  --> $DIR/unit_arg.rs:34:5\n    |\n LL |     foo(foo(1));\n    |     ^^^^^^^^^^^\n@@ -32,7 +32,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:34:5\n+  --> $DIR/unit_arg.rs:35:5\n    |\n LL | /     foo({\n LL | |         foo(1);\n@@ -54,7 +54,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:39:5\n+  --> $DIR/unit_arg.rs:40:5\n    |\n LL | /     b.bar({\n LL | |         1;\n@@ -74,7 +74,7 @@ LL |     b.bar(());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:42:5\n+  --> $DIR/unit_arg.rs:43:5\n    |\n LL |     taking_multiple_units(foo(0), foo(1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -87,7 +87,7 @@ LL |     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:43:5\n+  --> $DIR/unit_arg.rs:44:5\n    |\n LL | /     taking_multiple_units(foo(0), {\n LL | |         foo(1);\n@@ -110,7 +110,7 @@ LL |     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:47:5\n+  --> $DIR/unit_arg.rs:48:5\n    |\n LL | /     taking_multiple_units(\n LL | |         {\n@@ -140,7 +140,7 @@ LL |         foo(2);\n  ...\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:58:13\n+  --> $DIR/unit_arg.rs:59:13\n    |\n LL |     None.or(Some(foo(2)));\n    |             ^^^^^^^^^^^^\n@@ -154,7 +154,7 @@ LL |     });\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:61:5\n+  --> $DIR/unit_arg.rs:62:5\n    |\n LL |     foo(foo(()))\n    |     ^^^^^^^^^^^^\n@@ -166,7 +166,7 @@ LL |     foo(())\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:94:5\n+  --> $DIR/unit_arg.rs:95:5\n    |\n LL |     Some(foo(1))\n    |     ^^^^^^^^^^^^"}, {"sha": "642ce5040096eeab6356700737ebc203d30fe35d", "filename": "tests/ui/vec_init_then_push.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_init_then_push.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,21 @@\n+#![allow(unused_variables)]\n+#![warn(clippy::vec_init_then_push)]\n+\n+fn main() {\n+    let mut def_err: Vec<u32> = Default::default();\n+    def_err.push(0);\n+\n+    let mut new_err = Vec::<u32>::new();\n+    new_err.push(1);\n+\n+    let mut cap_err = Vec::with_capacity(2);\n+    cap_err.push(0);\n+    cap_err.push(1);\n+    cap_err.push(2);\n+\n+    let mut cap_ok = Vec::with_capacity(10);\n+    cap_ok.push(0);\n+\n+    new_err = Vec::new();\n+    new_err.push(0);\n+}"}, {"sha": "819ed47d0991989966686299a5455308042fb587", "filename": "tests/ui/vec_init_then_push.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fvec_init_then_push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fvec_init_then_push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_init_then_push.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -0,0 +1,34 @@\n+error: calls to `push` immediately after creation\n+  --> $DIR/vec_init_then_push.rs:5:5\n+   |\n+LL | /     let mut def_err: Vec<u32> = Default::default();\n+LL | |     def_err.push(0);\n+   | |____________________^ help: consider using the `vec![]` macro: `let mut def_err: Vec<u32> = vec![..];`\n+   |\n+   = note: `-D clippy::vec-init-then-push` implied by `-D warnings`\n+\n+error: calls to `push` immediately after creation\n+  --> $DIR/vec_init_then_push.rs:8:5\n+   |\n+LL | /     let mut new_err = Vec::<u32>::new();\n+LL | |     new_err.push(1);\n+   | |____________________^ help: consider using the `vec![]` macro: `let mut new_err = vec![..];`\n+\n+error: calls to `push` immediately after creation\n+  --> $DIR/vec_init_then_push.rs:11:5\n+   |\n+LL | /     let mut cap_err = Vec::with_capacity(2);\n+LL | |     cap_err.push(0);\n+LL | |     cap_err.push(1);\n+LL | |     cap_err.push(2);\n+   | |____________________^ help: consider using the `vec![]` macro: `let mut cap_err = vec![..];`\n+\n+error: calls to `push` immediately after creation\n+  --> $DIR/vec_init_then_push.rs:19:5\n+   |\n+LL | /     new_err = Vec::new();\n+LL | |     new_err.push(0);\n+   | |____________________^ help: consider using the `vec![]` macro: `new_err = vec![..];`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "6cfc0fcb4cae45edcd4f970215fa73898050358d", "filename": "tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.rs?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -94,7 +94,8 @@ mod issue6307 {\n     trait T: Sized {\n         fn as_i32(self) {}\n         fn as_u32(&self) {}\n-        fn into_i32(&self) {}\n+        fn into_i32(self) {}\n+        fn into_i32_ref(&self) {}\n         fn into_u32(self) {}\n         fn is_i32(self) {}\n         fn is_u32(&self) {}\n@@ -117,7 +118,32 @@ mod issue6307 {\n     trait U {\n         fn as_i32(self);\n         fn as_u32(&self);\n-        fn into_i32(&self);\n+        fn into_i32(self);\n+        fn into_i32_ref(&self);\n+        fn into_u32(self);\n+        fn is_i32(self);\n+        fn is_u32(&self);\n+        fn to_i32(self);\n+        fn to_u32(&self);\n+        fn from_i32(self);\n+        // check whether the lint can be allowed at the function level\n+        #[allow(clippy::wrong_self_convention)]\n+        fn from_cake(self);\n+\n+        // test for false positives\n+        fn as_(self);\n+        fn into_(&self);\n+        fn is_(self);\n+        fn to_(self);\n+        fn from_(self);\n+        fn to_mut(&mut self);\n+    }\n+\n+    trait C: Copy {\n+        fn as_i32(self);\n+        fn as_u32(&self);\n+        fn into_i32(self);\n+        fn into_i32_ref(&self);\n         fn into_u32(self);\n         fn is_i32(self);\n         fn is_u32(&self);"}, {"sha": "32bd9075bd5e14c0a399055c6deeaab65f218c45", "filename": "tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488153ff2ff678051f06a94dc4486632d788c328/tests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.stderr?ref=488153ff2ff678051f06a94dc4486632d788c328", "patch": "@@ -79,58 +79,70 @@ LL |         fn as_i32(self) {}\n    |                   ^^^^\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:97:21\n+  --> $DIR/wrong_self_convention.rs:98:25\n    |\n-LL |         fn into_i32(&self) {}\n-   |                     ^^^^^\n+LL |         fn into_i32_ref(&self) {}\n+   |                         ^^^^^\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:99:19\n+  --> $DIR/wrong_self_convention.rs:100:19\n    |\n LL |         fn is_i32(self) {}\n    |                   ^^^^\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:101:19\n+  --> $DIR/wrong_self_convention.rs:102:19\n    |\n LL |         fn to_i32(self) {}\n    |                   ^^^^\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:103:21\n+  --> $DIR/wrong_self_convention.rs:104:21\n    |\n LL |         fn from_i32(self) {}\n    |                     ^^^^\n \n error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:118:19\n+  --> $DIR/wrong_self_convention.rs:119:19\n    |\n LL |         fn as_i32(self);\n    |                   ^^^^\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:120:21\n+  --> $DIR/wrong_self_convention.rs:122:25\n    |\n-LL |         fn into_i32(&self);\n-   |                     ^^^^^\n+LL |         fn into_i32_ref(&self);\n+   |                         ^^^^^\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:122:19\n+  --> $DIR/wrong_self_convention.rs:124:19\n    |\n LL |         fn is_i32(self);\n    |                   ^^^^\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:124:19\n+  --> $DIR/wrong_self_convention.rs:126:19\n    |\n LL |         fn to_i32(self);\n    |                   ^^^^\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:126:21\n+  --> $DIR/wrong_self_convention.rs:128:21\n+   |\n+LL |         fn from_i32(self);\n+   |                     ^^^^\n+\n+error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:146:25\n+   |\n+LL |         fn into_i32_ref(&self);\n+   |                         ^^^^^\n+\n+error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:152:21\n    |\n LL |         fn from_i32(self);\n    |                     ^^^^\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n "}]}