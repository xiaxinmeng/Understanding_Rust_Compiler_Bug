{"sha": "33ae193a3c1a156e73bf6880366c9785dd4b7393", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYWUxOTNhM2MxYTE1NmU3M2JmNjg4MDM2NmM5Nzg1ZGQ0YjczOTM=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-17T19:35:27Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-17T19:35:41Z"}, "message": "Started to implemented UdpStream", "tree": {"sha": "54972af2c60f84112c7dd277d1c014471cfde406", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54972af2c60f84112c7dd277d1c014471cfde406"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33ae193a3c1a156e73bf6880366c9785dd4b7393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33ae193a3c1a156e73bf6880366c9785dd4b7393", "html_url": "https://github.com/rust-lang/rust/commit/33ae193a3c1a156e73bf6880366c9785dd4b7393", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33ae193a3c1a156e73bf6880366c9785dd4b7393/comments", "author": null, "committer": null, "parents": [{"sha": "e42f28c05cb8e579d06492c49822944946341c9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42f28c05cb8e579d06492c49822944946341c9f", "html_url": "https://github.com/rust-lang/rust/commit/e42f28c05cb8e579d06492c49822944946341c9f"}], "stats": {"total": 80, "additions": 80, "deletions": 0}, "files": [{"sha": "1274dbc3220cfa433547049e4c05ae853b0551de", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/33ae193a3c1a156e73bf6880366c9785dd4b7393/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ae193a3c1a156e73bf6880366c9785dd4b7393/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=33ae193a3c1a156e73bf6880366c9785dd4b7393", "patch": "@@ -433,6 +433,86 @@ impl RtioTcpStream for UvTcpStream {\n     }\n }\n \n+pub struct UvUdpStream {\n+    watcher: UdpWatcher,\n+    address: IpAddr\n+}\n+\n+impl UvUdpStream {\n+    fn watcher(&self) -> UdpWatcher { self.watcher }\n+    fn address(&self) -> IpAddr { self.address }\n+}\n+\n+impl Drop for UvUdpStream {\n+    fn finalize(&self) {\n+        rtdebug!(\"closing udp stream\");\n+        let watcher = self.watcher();\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell(task);\n+            do watcher.close {\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioUdpStream for UvUdpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        let result_cell = empty_cell();\n+        let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n+\n+        let scheduler = Local::take::<Scheduler>();\n+        assert!(scheduler.in_task_context());\n+        let watcher = self.watcher();\n+        let connection_address = self.address();\n+        let buf_ptr: *&mut [u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |sched, task| {\n+            rtdebug!(\"read: entered scheduler context\");\n+            assert!(!sched.in_task_context());\n+            let mut watcher = watcher;\n+            let task_cell = Cell(task);\n+            // XXX: see note in RtioTcpStream implementation for UvTcpStream\n+            let alloc: AllocCallback = |_| unsafe {\n+                slice_to_uv_buf(*buf_ptr)\n+            };\n+            do watcher.recv_start(alloc) |watcher, nread, _buf, addr, flags, status| {\n+                let _ = flags; // TODO actually use flags\n+\n+                // XXX: see note in RtioTcpStream implementation for UvTcpStream\n+                let mut watcher = watcher;\n+                watcher.recv_stop();\n+\n+                let incoming_address = net::uv_ip4_to_ip4(&addr);\n+                let result = if status.is_none() {\n+                    assert!(nread >= 0);\n+                    if incoming_address != connection_address {\n+                        Ok(0u)\n+                    } else {\n+                        Ok(nread as uint)\n+                    }\n+                } else {\n+                    Err(uv_error_to_io_error(status.unwrap()))\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> { \n+        let _ = buf;\n+        fail!() \n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {"}]}