{"sha": "e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6", "node_id": "C_kwDOAAsO6NoAKGU2MTgwN2M2YmYxZjk5Y2E5ZGQwNDE4Y2E3ZTg2MmYwYjM2NGYwYzY", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-06-02T11:37:09Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-06-10T08:09:50Z"}, "message": "update higher_ranked_sub docs", "tree": {"sha": "6870b65b14474e47ccb856954e64c7628238f373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6870b65b14474e47ccb856954e64c7628238f373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6", "html_url": "https://github.com/rust-lang/rust/commit/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54fac386a42b466b747c1611568a787f38b06432", "url": "https://api.github.com/repos/rust-lang/rust/commits/54fac386a42b466b747c1611568a787f38b06432", "html_url": "https://github.com/rust-lang/rust/commit/54fac386a42b466b747c1611568a787f38b06432"}], "stats": {"total": 62, "additions": 35, "deletions": 27}, "files": [{"sha": "3b1798ca73746cdb4361573527eb45adbfddb879", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6", "patch": "@@ -153,12 +153,12 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n     {\n         if a.skip_binder().has_escaping_bound_vars() || b.skip_binder().has_escaping_bound_vars() {\n             self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n-            self.fields.higher_ranked_sub(b, a, self.a_is_expected)\n+            self.fields.higher_ranked_sub(b, a, self.a_is_expected)?;\n         } else {\n             // Fast path for the common case.\n             self.relate(a.skip_binder(), b.skip_binder())?;\n-            Ok(a)\n         }\n+        Ok(a)\n     }\n }\n "}, {"sha": "017f265331c1691f5b34f2184029004288b9dc90", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6", "patch": "@@ -9,49 +9,56 @@ use rustc_middle::ty::{self, Binder, TypeFoldable};\n use std::cell::Cell;\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n+    /// Checks whether `for<..> sub <: for<..> sup` holds.\n+    ///\n+    /// For this to hold, **all** instantiations of the super type\n+    /// have to be a super type of **at least one** instantiation of\n+    /// the subtype.\n+    ///\n+    /// This is implemented by first entering a new universe.\n+    /// We then replace all bound variables in `sup` with placeholders,\n+    /// and all bound variables in `sup` with inference vars.\n+    /// We can then just relate the two resulting types as normal.\n+    ///\n+    /// Note: this is a subtle algorithm. For a full explanation, please see\n+    /// the [rustc dev guide][rd]\n+    ///\n+    /// [rd]: https://rustc-dev-guide.rust-lang.org/borrow_check/region_inference/placeholders_and_universes.html\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n-        a: Binder<'tcx, T>,\n-        b: Binder<'tcx, T>,\n-        a_is_expected: bool,\n-    ) -> RelateResult<'tcx, Binder<'tcx, T>>\n+        sub: Binder<'tcx, T>,\n+        sup: Binder<'tcx, T>,\n+        sub_is_expected: bool,\n+    ) -> RelateResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n-        // Rather than checking the subtype relationship between `a` and `b`\n-        // as-is, we need to do some extra work here in order to make sure\n-        // that function subtyping works correctly with respect to regions\n-        //\n-        // Note: this is a subtle algorithm.  For a full explanation, please see\n-        // the rustc dev guide:\n-        // <https://rustc-dev-guide.rust-lang.org/borrow_check/region_inference/placeholders_and_universes.html>\n-\n         let span = self.trace.cause.span;\n \n         self.infcx.commit_if_ok(|_| {\n             // First, we instantiate each bound region in the supertype with a\n-            // fresh placeholder region.\n-            let b_prime = self.infcx.replace_bound_vars_with_placeholders(b);\n+            // fresh placeholder region. Note that this automatically creates\n+            // a new universe if needed.\n+            let sup_prime = self.infcx.replace_bound_vars_with_placeholders(sup);\n \n             // Next, we instantiate each bound region in the subtype\n             // with a fresh region variable. These region variables --\n             // but no other pre-existing region variables -- can name\n             // the placeholders.\n-            let a_prime = self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, a);\n+            let sub_prime =\n+                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, sub);\n \n-            debug!(\"a_prime={:?}\", a_prime);\n-            debug!(\"b_prime={:?}\", b_prime);\n+            debug!(\"a_prime={:?}\", sub_prime);\n+            debug!(\"b_prime={:?}\", sup_prime);\n \n             // Compare types now that bound regions have been replaced.\n-            let result = self.sub(a_is_expected).relate(a_prime, b_prime)?;\n-\n-            debug!(\"higher_ranked_sub: OK result={:?}\", result);\n+            let result = self.sub(sub_is_expected).relate(sub_prime, sup_prime)?;\n \n-            // We related `a_prime` and `b_prime`, which just had any bound vars\n-            // replaced with placeholders or infer vars, respectively. Relating\n-            // them should not introduce new bound vars.\n-            Ok(ty::Binder::dummy(result))\n+            debug!(\"higher_ranked_sub: OK result={result:?}\");\n+            // NOTE: returning the result here would be dangerous as it contains\n+            // placeholders which **must not** be named after wards.\n+            Ok(())\n         })\n     }\n }"}, {"sha": "d0c6d8d16ebfa44fb3f4145b329b11391e50c945", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=e61807c6bf1f99ca9dd0418ca7e862f0b364f0c6", "patch": "@@ -198,7 +198,8 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        self.fields.higher_ranked_sub(a, b, self.a_is_expected)\n+        self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n+        Ok(a)\n     }\n }\n "}]}