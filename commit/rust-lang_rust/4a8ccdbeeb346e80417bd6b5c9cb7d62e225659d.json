{"sha": "4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhOGNjZGJlZWIzNDZlODA0MTdiZDZiNWM5Y2I3ZDYyZTIyNTY1OWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-08T02:12:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-08T02:12:24Z"}, "message": "Auto merge of #64044 - Mark-Simulacrum:rustdoc-clean-2, r=GuillaumeGomez\n\nRustdoc: formatting to buffers\n\nThis should be reviewed commit-by-commit.\n\nI've not attempted to fully flesh out what the end state of this PR could look like yet as I wanted to get it up for some early feedback (I already think this has some wins, too, so we could land it as-is).\n\nThe primary idea with `Buffer` is that it internally tracks whether we're printing to HTML or text, and the goal is that eventually instead of branch on `fmt.alternate()` anywhere, we'd call a helper like `buf.nbsp()` which would either return `&nbsp;` or ` ` depending on the target we're printing to. Obviously, that's not included in this PR, in part because it was already getting quite big.", "tree": {"sha": "c27ad2da51d49a096e50adacd33c067e320f61df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c27ad2da51d49a096e50adacd33c067e320f61df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d", "html_url": "https://github.com/rust-lang/rust/commit/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7b05af814f02681d8973438df4ed5792f581841", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7b05af814f02681d8973438df4ed5792f581841", "html_url": "https://github.com/rust-lang/rust/commit/f7b05af814f02681d8973438df4ed5792f581841"}, {"sha": "02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36", "html_url": "https://github.com/rust-lang/rust/commit/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36"}], "stats": {"total": 1780, "additions": 864, "deletions": 916}, "files": [{"sha": "dcd32192ff3842f54cec4a421bb3f2f039a74b6d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 102, "deletions": 8, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d", "patch": "@@ -18,6 +18,100 @@ use crate::clean::{self, PrimitiveType};\n use crate::html::item_type::ItemType;\n use crate::html::render::{self, cache, CURRENT_DEPTH};\n \n+pub trait Print {\n+    fn print(self, buffer: &mut Buffer);\n+}\n+\n+impl<F> Print for F\n+    where F: FnOnce(&mut Buffer),\n+{\n+    fn print(self, buffer: &mut Buffer) {\n+        (self)(buffer)\n+    }\n+}\n+\n+impl Print for String {\n+    fn print(self, buffer: &mut Buffer) {\n+        buffer.write_str(&self);\n+    }\n+}\n+\n+impl Print for &'_ str {\n+    fn print(self, buffer: &mut Buffer) {\n+        buffer.write_str(self);\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Buffer {\n+    for_html: bool,\n+    buffer: String,\n+}\n+\n+impl Buffer {\n+    crate fn empty_from(v: &Buffer) -> Buffer {\n+        Buffer {\n+            for_html: v.for_html,\n+            buffer: String::new(),\n+        }\n+    }\n+\n+    crate fn html() -> Buffer {\n+        Buffer {\n+            for_html: true,\n+            buffer: String::new(),\n+        }\n+    }\n+\n+    crate fn is_empty(&self) -> bool {\n+        self.buffer.is_empty()\n+    }\n+\n+    crate fn into_inner(self) -> String {\n+        self.buffer\n+    }\n+\n+    crate fn insert_str(&mut self, idx: usize, s: &str) {\n+        self.buffer.insert_str(idx, s);\n+    }\n+\n+    crate fn push_str(&mut self, s: &str) {\n+        self.buffer.push_str(s);\n+    }\n+\n+    // Intended for consumption by write! and writeln! (std::fmt) but without\n+    // the fmt::Result return type imposed by fmt::Write (and avoiding the trait\n+    // import).\n+    crate fn write_str(&mut self, s: &str) {\n+        self.buffer.push_str(s);\n+    }\n+\n+    // Intended for consumption by write! and writeln! (std::fmt) but without\n+    // the fmt::Result return type imposed by fmt::Write (and avoiding the trait\n+    // import).\n+    crate fn write_fmt(&mut self, v: fmt::Arguments<'_>) {\n+        use fmt::Write;\n+        self.buffer.write_fmt(v).unwrap();\n+    }\n+\n+    crate fn to_display<T: Print>(mut self, t: T) -> String {\n+        t.print(&mut self);\n+        self.into_inner()\n+    }\n+\n+    crate fn with_formatter<T: FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result>(&mut self, t: T) {\n+        self.from_display(display_fn(move |f| (t)(f)));\n+    }\n+\n+    crate fn from_display<T: std::fmt::Display>(&mut self, t: T) {\n+        if self.for_html {\n+            write!(self, \"{}\", t);\n+        } else {\n+            write!(self, \"{:#}\", t);\n+        }\n+    }\n+}\n+\n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n #[derive(Copy, Clone)]\n@@ -200,11 +294,11 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime, ref bounds } => {\n                     clause.push_str(&format!(\"{}: {}\",\n-                                             lifetime,\n-                                             bounds.iter()\n-                                                   .map(|b| b.to_string())\n-                                                   .collect::<Vec<_>>()\n-                                                   .join(\" + \")));\n+                                                lifetime,\n+                                                bounds.iter()\n+                                                    .map(|b| b.to_string())\n+                                                    .collect::<Vec<_>>()\n+                                                    .join(\" + \")));\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n                     if f.alternate() {\n@@ -778,9 +872,9 @@ impl fmt::Display for clean::Impl {\n \n // The difference from above is that trait is not hyperlinked.\n pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n-                               f: &mut fmt::Formatter<'_>,\n-                               use_absolute: bool) -> fmt::Result {\n-    fmt_impl(i, f, false, use_absolute)\n+                               f: &mut Buffer,\n+                               use_absolute: bool) {\n+    f.with_formatter(|f| fmt_impl(i, f, false, use_absolute))\n }\n \n impl fmt::Display for clean::Arguments {"}, {"sha": "56074f4ab1192de9a88c33be9cae8638a215767b", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d", "patch": "@@ -1,16 +1,21 @@\n-use std::fmt;\n-use std::io;\n use std::path::PathBuf;\n \n use crate::externalfiles::ExternalHtml;\n use crate::html::render::SlashChecker;\n+use crate::html::format::{Buffer, Print};\n \n #[derive(Clone)]\n pub struct Layout {\n     pub logo: String,\n     pub favicon: String,\n     pub external_html: ExternalHtml,\n     pub krate: String,\n+    /// The given user css file which allow to customize the generated\n+    /// documentation theme.\n+    pub css_file_extension: Option<PathBuf>,\n+    /// If false, the `select` element to have search filtering by crates on rendered docs\n+    /// won't be generated.\n+    pub generate_search_filter: bool,\n }\n \n pub struct Page<'a> {\n@@ -25,19 +30,15 @@ pub struct Page<'a> {\n     pub static_extra_scripts: &'a [&'a str],\n }\n \n-pub fn render<T: fmt::Display, S: fmt::Display>(\n-    dst: &mut dyn io::Write,\n+pub fn render<T: Print, S: Print>(\n     layout: &Layout,\n     page: &Page<'_>,\n-    sidebar: &S,\n-    t: &T,\n-    css_file_extension: bool,\n+    sidebar: S,\n+    t: T,\n     themes: &[PathBuf],\n-    generate_search_filter: bool,\n-) -> io::Result<()> {\n+) -> String {\n     let static_root_path = page.static_root_path.unwrap_or(page.root_path);\n-    write!(dst,\n-\"<!DOCTYPE html>\\\n+    format!(\"<!DOCTYPE html>\\\n <html lang=\\\"en\\\">\\\n <head>\\\n     <meta charset=\\\"utf-8\\\">\\\n@@ -164,7 +165,7 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     <script defer src=\\\"{root_path}search-index{suffix}.js\\\"></script>\\\n </body>\\\n </html>\",\n-    css_extension = if css_file_extension {\n+    css_extension = if layout.css_file_extension.is_some() {\n         format!(\"<link rel=\\\"stylesheet\\\" \\\n                        type=\\\"text/css\\\" \\\n                        href=\\\"{static_root_path}theme{suffix}.css\\\">\",\n@@ -173,7 +174,7 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     } else {\n         String::new()\n     },\n-    content   = *t,\n+    content   = Buffer::html().to_display(t),\n     static_root_path = static_root_path,\n     root_path = page.root_path,\n     css_class = page.css_class,\n@@ -207,7 +208,7 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     in_header = layout.external_html.in_header,\n     before_content = layout.external_html.before_content,\n     after_content = layout.external_html.after_content,\n-    sidebar   = *sidebar,\n+    sidebar   = Buffer::html().to_display(sidebar),\n     krate     = layout.krate,\n     themes = themes.iter()\n                    .filter_map(|t| t.file_stem())\n@@ -228,7 +229,7 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n                 root_path=page.root_path,\n                 extra_script=e)\n     }).collect::<String>(),\n-    filter_crates=if generate_search_filter {\n+    filter_crates=if layout.generate_search_filter {\n         \"<select id=\\\"crate-search\\\">\\\n             <option value=\\\"All crates\\\">All crates</option>\\\n         </select>\"\n@@ -238,9 +239,9 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     )\n }\n \n-pub fn redirect(dst: &mut dyn io::Write, url: &str) -> io::Result<()> {\n+pub fn redirect(url: &str) -> String {\n     // <script> triggers a redirect before refresh, so this is fine.\n-    write!(dst,\n+    format!(\n r##\"<!DOCTYPE html>\n <html lang=\"en\">\n <head>"}, {"sha": "9846073cad4bcf8752558510baf417e6a7df81a0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 725, "deletions": 860, "changes": 1585, "blob_url": "https://github.com/rust-lang/rust/blob/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d"}, {"sha": "d840683a7af87575bf6b367089969d07a02d1a8f", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=4a8ccdbeeb346e80417bd6b5c9cb7d62e225659d", "patch": "@@ -4,10 +4,10 @@ use crate::fold::DocFolder;\n use crate::html::layout;\n use crate::html::render::{Error, SharedContext, BASIC_KEYWORDS};\n use crate::html::highlight;\n+use crate::html::format::Buffer;\n use std::ffi::OsStr;\n use std::fs;\n use std::path::{Component, Path, PathBuf};\n-use std::fmt;\n use syntax::source_map::FileName;\n \n crate fn render(dst: &Path, scx: &mut SharedContext,\n@@ -105,7 +105,6 @@ impl<'a> SourceCollector<'a> {\n         cur.push(&fname);\n         href.push_str(&fname.to_string_lossy());\n \n-        let mut v = Vec::new();\n         let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n                                                .to_string_lossy());\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n@@ -120,15 +119,10 @@ impl<'a> SourceCollector<'a> {\n             extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n             static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n         };\n-        let result = layout::render(&mut v, &self.scx.layout,\n-                       &page, &(\"\"), &Source(contents),\n-                       self.scx.css_file_extension.is_some(),\n-                       &self.scx.themes,\n-                       self.scx.generate_search_filter);\n-        if let Err(e) = result {\n-            return Err(Error::new(e, &cur));\n-        }\n-        self.scx.fs.write(&cur, &v)?;\n+        let v = layout::render(&self.scx.layout,\n+                       &page, \"\", |buf: &mut _| print_src(buf, &contents),\n+                       &self.scx.themes);\n+        self.scx.fs.write(&cur, v.as_bytes())?;\n         self.scx.local_sources.insert(p.clone(), href);\n         Ok(())\n     }\n@@ -163,25 +157,19 @@ where\n \n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n-struct Source<'a>(&'a str);\n-\n-impl<'a> fmt::Display for Source<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let Source(s) = *self;\n-        let lines = s.lines().count();\n-        let mut cols = 0;\n-        let mut tmp = lines;\n-        while tmp > 0 {\n-            cols += 1;\n-            tmp /= 10;\n-        }\n-        write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n-        for i in 1..=lines {\n-            write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n-        }\n-        write!(fmt, \"</pre>\")?;\n-        write!(fmt, \"{}\",\n-               highlight::render_with_highlighting(s, None, None, None))?;\n-        Ok(())\n+fn print_src(buf: &mut Buffer, s: &str) {\n+    let lines = s.lines().count();\n+    let mut cols = 0;\n+    let mut tmp = lines;\n+    while tmp > 0 {\n+        cols += 1;\n+        tmp /= 10;\n+    }\n+    write!(buf, \"<pre class=\\\"line-numbers\\\">\");\n+    for i in 1..=lines {\n+        write!(buf, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols);\n     }\n+    write!(buf, \"</pre>\");\n+    write!(buf, \"{}\",\n+            highlight::render_with_highlighting(s, None, None, None));\n }"}]}