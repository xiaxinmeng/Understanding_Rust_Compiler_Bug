{"sha": "0b7b4f075a531eb160becf2818c1e9a63fa10cd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiN2I0ZjA3NWE1MzFlYjE2MGJlY2YyODE4YzFlOWE2M2ZhMTBjZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-16T22:36:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-16T22:36:50Z"}, "message": "auto merge of #18747 : csherratt/rust/ringbuf-remove-option, r=huonw\n\nFix for task in Metabug #18009 (Rebased version of https://github.com/rust-lang/rust/pull/18170)\r\n\r\nThis changes much of about how RingBuf functions. `lo`, `nelts` are replaced by a more traditional `head` and`tail`. The `Vec<Option<T>>` is replaced by a bare pointer that is managed by the `RingBuf` itself. This also expects the ring buffer to always be size that is a power of 2.\r\n\r\nThis change also includes a number of new tests to cover the some areas that could be of concern with manual memory management.\r\n\r\nThe benchmarks have been reworked since the old ones were benchmarking of the Ring buffers growth rather then the actual test.\r\n\r\nThe unit test suite have been expanded, and exposed some bugs in `fn get()` and `fn get_mut()`\r\n\r\n## Benchmark\r\n**Before:**\r\n```\r\ntest ring_buf::tests::bench_grow_1025                      ... bench:      8919 ns/iter (+/- 87)\r\ntest ring_buf::tests::bench_iter_1000                      ... bench:       924 ns/iter (+/- 28)\r\ntest ring_buf::tests::bench_mut_iter_1000                  ... bench:       918 ns/iter (+/- 6)\r\ntest ring_buf::tests::bench_new                            ... bench:        15 ns/iter (+/- 0)\r\ntest ring_buf::tests::bench_pop_100                        ... bench:       294 ns/iter (+/- 9)\r\ntest ring_buf::tests::bench_pop_front_100                  ... bench:       948 ns/iter (+/- 32)\r\ntest ring_buf::tests::bench_push_back_100                  ... bench:       291 ns/iter (+/- 16)\r\ntest ring_buf::tests::bench_push_front_100                 ... bench:       311 ns/iter (+/- 27\r\n```\r\n**After:**\r\n```\r\ntest ring_buf::tests::bench_grow_1025                      ... bench:      2209 ns/iter (+/- 169)\r\ntest ring_buf::tests::bench_iter_1000                      ... bench:       534 ns/iter (+/- 27)\r\ntest ring_buf::tests::bench_mut_iter_1000                  ... bench:       515 ns/iter (+/- 28)\r\ntest ring_buf::tests::bench_new                            ... bench:        11 ns/iter (+/- 0)\r\ntest ring_buf::tests::bench_pop_100                        ... bench:       170 ns/iter (+/- 5)\r\ntest ring_buf::tests::bench_pop_front_100                  ... bench:       171 ns/iter (+/- 11)\r\ntest ring_buf::tests::bench_push_back_100                  ... bench:       172 ns/iter (+/- 13)\r\ntest ring_buf::tests::bench_push_front_100                 ... bench:       158 ns/iter (+/- 12)\r\n\r\n```", "tree": {"sha": "771c4e48abc619c2ee7f116345044e985e41e6a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/771c4e48abc619c2ee7f116345044e985e41e6a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b7b4f075a531eb160becf2818c1e9a63fa10cd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7b4f075a531eb160becf2818c1e9a63fa10cd3", "html_url": "https://github.com/rust-lang/rust/commit/0b7b4f075a531eb160becf2818c1e9a63fa10cd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b7b4f075a531eb160becf2818c1e9a63fa10cd3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "245c7fbef5eda6f4f70c18f9aedbd62a6810dee8", "url": "https://api.github.com/repos/rust-lang/rust/commits/245c7fbef5eda6f4f70c18f9aedbd62a6810dee8", "html_url": "https://github.com/rust-lang/rust/commit/245c7fbef5eda6f4f70c18f9aedbd62a6810dee8"}, {"sha": "6277e3b2d9567a2f829862c713e78e4ac13bb600", "url": "https://api.github.com/repos/rust-lang/rust/commits/6277e3b2d9567a2f829862c713e78e4ac13bb600", "html_url": "https://github.com/rust-lang/rust/commit/6277e3b2d9567a2f829862c713e78e4ac13bb600"}], "stats": {"total": 711, "additions": 513, "deletions": 198}, "files": [{"sha": "e95660b546ebc5ddc8dcce48190dea06939f87b0", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 513, "deletions": 198, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b4f075a531eb160becf2818c1e9a63fa10cd3/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b4f075a531eb160becf2818c1e9a63fa10cd3/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=0b7b4f075a531eb160becf2818c1e9a63fa10cd3", "patch": "@@ -15,14 +15,19 @@\n \n use core::prelude::*;\n \n-use core::cmp;\n use core::default::Default;\n use core::fmt;\n use core::iter;\n-use core::slice;\n+use core::raw::Slice as RawSlice;\n+use core::ptr;\n+use core::kinds::marker;\n+use core::mem;\n+use core::num::{Int, UnsignedInt};\n+\n use std::hash::{Writer, Hash};\n+use std::cmp;\n \n-use vec::Vec;\n+use alloc::heap;\n \n static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n@@ -33,18 +38,72 @@ static MINIMUM_CAPACITY: uint = 2u;\n \n \n /// `RingBuf` is a circular buffer that implements `Deque`.\n-#[deriving(Clone)]\n pub struct RingBuf<T> {\n-    nelts: uint,\n-    lo: uint,\n-    elts: Vec<Option<T>>\n+    // tail and head are pointers into the buffer. Tail always points\n+    // to the first element that could be read, Head always points\n+    // to where data should be written.\n+    // If tail == head the buffer is empty. The length of the ringbuf\n+    // is defined as the distance between the two.\n+\n+    tail: uint,\n+    head: uint,\n+    cap: uint,\n+    ptr: *mut T\n+}\n+\n+impl<T: Clone> Clone for RingBuf<T> {\n+    fn clone(&self) -> RingBuf<T> {\n+        self.iter().map(|t| t.clone()).collect()\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for RingBuf<T> {\n+    fn drop(&mut self) {\n+        self.clear();\n+        unsafe {\n+            if mem::size_of::<T>() != 0 {\n+                heap::deallocate(self.ptr as *mut u8,\n+                                 self.cap * mem::size_of::<T>(),\n+                                 mem::min_align_of::<T>())\n+            }\n+        }\n+    }\n }\n \n impl<T> Default for RingBuf<T> {\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n }\n \n+impl<T> RingBuf<T> {\n+    /// Turn ptr into a slice\n+    #[inline]\n+    unsafe fn buffer_as_slice(&self) -> &[T] {\n+        mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n+    }\n+\n+    /// Moves an element out of the buffer\n+    #[inline]\n+    unsafe fn buffer_read(&mut self, off: uint) -> T {\n+        ptr::read(self.ptr.offset(off as int) as *const T)\n+    }\n+\n+    /// Writes an element into the buffer, moving it.\n+    #[inline]\n+    unsafe fn buffer_write(&mut self, off: uint, t: T) {\n+        ptr::write(self.ptr.offset(off as int), t);\n+    }\n+\n+    /// Returns true iff the buffer is at capacity\n+    #[inline]\n+    fn is_full(&self) -> bool { self.cap - self.len() == 1 }\n+\n+    /// Returns the index in the underlying buffer for a given logical element index.\n+    #[inline]\n+    fn wrap_index(&self, idx: uint) -> uint { wrap_index(idx, self.cap) }\n+}\n+\n impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n@@ -55,8 +114,27 @@ impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n-        RingBuf{nelts: 0, lo: 0,\n-              elts: Vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n+        // +1 since the ringbuffer always leaves one space empty\n+        let cap = cmp::max(n + 1, MINIMUM_CAPACITY).next_power_of_two();\n+        let size = cap.checked_mul(mem::size_of::<T>())\n+                      .expect(\"capacity overflow\");\n+\n+        let ptr = if mem::size_of::<T>() != 0 {\n+            unsafe {\n+                let ptr = heap::allocate(size, mem::min_align_of::<T>())  as *mut T;;\n+                if ptr.is_null() { ::alloc::oom() }\n+                ptr\n+            }\n+        } else {\n+            heap::EMPTY as *mut T\n+        };\n+\n+        RingBuf {\n+            tail: 0,\n+            head: 0,\n+            cap: cap,\n+            ptr: ptr\n+        }\n     }\n \n     /// Retrieves an element in the `RingBuf` by index.\n@@ -74,9 +152,11 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn get(&self, i: uint) -> Option<&T> {\n-        match self.elts.get(i) {\n-            None => None,\n-            Some(opt) => opt.as_ref(),\n+        if i < self.len() {\n+            let idx = self.wrap_index(self.tail + i);\n+            unsafe { Some(&*self.ptr.offset(idx as int)) }\n+        } else {\n+            None\n         }\n     }\n \n@@ -102,9 +182,11 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n-        match self.elts.get_mut(i) {\n-            None => None,\n-            Some(opt) => opt.as_mut(),\n+        if i < self.len() {\n+            let idx = self.wrap_index(self.tail + i);\n+            unsafe { Some(&mut *self.ptr.offset(idx as int)) }\n+        } else {\n+            None\n         }\n     }\n \n@@ -130,15 +212,11 @@ impl<T> RingBuf<T> {\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n-        let ri = self.raw_index(i);\n-        let rj = self.raw_index(j);\n-        self.elts.as_mut_slice().swap(ri, rj);\n-    }\n-\n-    /// Returns the index in the underlying `Vec` for a given logical element\n-    /// index.\n-    fn raw_index(&self, idx: uint) -> uint {\n-        raw_index(self.lo, self.elts.len(), idx)\n+        let ri = self.wrap_index(self.tail + i);\n+        let rj = self.wrap_index(self.tail + j);\n+        unsafe {\n+            ptr::swap(self.ptr.offset(ri as int), self.ptr.offset(rj as int))\n+        }\n     }\n \n     /// Returns the number of elements the `RingBuf` can hold without\n@@ -150,14 +228,11 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let buf: RingBuf<int> = RingBuf::with_capacity(10);\n-    /// assert_eq!(buf.capacity(), 10);\n+    /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn capacity(&self) -> uint {\n-        // FXIME(Gankro): not the actual usable capacity if you use reserve/reserve_exact\n-        self.elts.capacity()\n-    }\n+    pub fn capacity(&self) -> uint { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `RingBuf`. Does nothing if the capacity is already sufficient.\n@@ -181,8 +256,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve_exact(&mut self, additional: uint) {\n-        // FIXME(Gankro): this is just wrong. The ringbuf won't actually use this space\n-        self.elts.reserve_exact(additional);\n+        self.reserve(additional);\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n@@ -203,8 +277,69 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n-        // FIXME(Gankro): this is just wrong. The ringbuf won't actually use this space\n-        self.elts.reserve(additional);\n+        let new_len = self.len() + additional;\n+        assert!(new_len + 1 > self.len(), \"capacity overflow\");\n+        if new_len > self.capacity() {\n+            let count = (new_len + 1).next_power_of_two();\n+            assert!(count >= new_len + 1);\n+\n+            if mem::size_of::<T>() != 0 {\n+                let old = self.cap * mem::size_of::<T>();\n+                let new = count.checked_mul(mem::size_of::<T>())\n+                               .expect(\"capacity overflow\");\n+                unsafe {\n+                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n+                                                old,\n+                                                new,\n+                                                mem::min_align_of::<T>()) as *mut T;\n+                    if self.ptr.is_null() { ::alloc::oom() }\n+                }\n+            }\n+\n+            // Move the shortest contiguous section of the ring buffer\n+            //    T             H\n+            //   [o o o o o o o . ]\n+            //    T             H\n+            // A [o o o o o o o . . . . . . . . . ]\n+            //        H T\n+            //   [o o . o o o o o ]\n+            //          T             H\n+            // B [. . . o o o o o o o . . . . . . ]\n+            //              H T\n+            //   [o o o o o . o o ]\n+            //              H                 T\n+            // C [o o o o o . . . . . . . . . o o ]\n+\n+            let oldcap = self.cap;\n+            self.cap = count;\n+\n+            if self.tail <= self.head { // A\n+                // Nop\n+            } else if self.head < oldcap - self.tail { // B\n+                unsafe {\n+                    ptr::copy_nonoverlapping_memory(\n+                        self.ptr.offset(oldcap as int),\n+                        self.ptr as *const T,\n+                        self.head\n+                    );\n+                }\n+                self.head += oldcap;\n+                debug_assert!(self.head > self.tail);\n+            } else { // C\n+                unsafe {\n+                    ptr::copy_nonoverlapping_memory(\n+                        self.ptr.offset((count - (oldcap - self.tail)) as int),\n+                        self.ptr.offset(self.tail as int) as *const T,\n+                        oldcap - self.tail\n+                    );\n+                }\n+                self.tail = count - (oldcap - self.tail);\n+                debug_assert!(self.head < self.tail);\n+            }\n+            debug_assert!(self.head < self.cap);\n+            debug_assert!(self.tail < self.cap);\n+            debug_assert!(self.cap.count_ones() == 1);\n+        }\n     }\n \n     /// Returns a front-to-back iterator.\n@@ -223,7 +358,11 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter(&self) -> Items<T> {\n-        Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n+        Items {\n+            tail: self.tail,\n+            head: self.head,\n+            ring: unsafe { self.buffer_as_slice() }\n+        }\n     }\n \n     /// Returns a front-to-back iterator which returns mutable references.\n@@ -244,32 +383,14 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut(&mut self) -> MutItems<T> {\n-        let start_index = raw_index(self.lo, self.elts.len(), 0);\n-        let end_index = raw_index(self.lo, self.elts.len(), self.nelts);\n-\n-        // Divide up the array\n-        if end_index <= start_index {\n-            // Items to iterate goes from:\n-            //    start_index to self.elts.len()\n-            // and then\n-            //    0 to end_index\n-            let (temp, remaining1) = self.elts.split_at_mut(start_index);\n-            let (remaining2, _) = temp.split_at_mut(end_index);\n-            MutItems {\n-                remaining1: remaining1.iter_mut(),\n-                remaining2: remaining2.iter_mut(),\n-                nelts: self.nelts,\n-            }\n-        } else {\n-            // Items to iterate goes from start_index to end_index:\n-            let (empty, elts) = self.elts.split_at_mut(0);\n-            let remaining1 = elts[mut start_index..end_index];\n-            MutItems {\n-                remaining1: remaining1.iter_mut(),\n-                remaining2: empty.iter_mut(),\n-                nelts: self.nelts,\n-            }\n+    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+        MutItems {\n+            tail: self.tail,\n+            head: self.head,\n+            cap: self.cap,\n+            ptr: self.ptr,\n+            marker: marker::ContravariantLifetime::<'a>,\n+            marker2: marker::NoCopy\n         }\n     }\n \n@@ -286,7 +407,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn len(&self) -> uint { self.nelts }\n+    pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }\n \n     /// Returns true if the buffer contains no elements\n     ///\n@@ -317,9 +438,9 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n-        for x in self.elts.iter_mut() { *x = None }\n-        self.nelts = 0;\n-        self.lo = 0;\n+        while self.pop_front().is_some() {}\n+        self.head = 0;\n+        self.tail = 0;\n     }\n \n     /// Provides a reference to the front element, or `None` if the sequence is\n@@ -339,7 +460,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn front(&self) -> Option<&T> {\n-        if self.nelts > 0 { Some(&self[0]) } else { None }\n+        if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the\n@@ -363,7 +484,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        if self.nelts > 0 { Some(&mut self[0]) } else { None }\n+        if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n \n     /// Provides a reference to the back element, or `None` if the sequence is\n@@ -383,7 +504,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn back(&self) -> Option<&T> {\n-        if self.nelts > 0 { Some(&self[self.nelts - 1]) } else { None }\n+        if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n@@ -407,8 +528,8 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        let nelts = self.nelts;\n-        if nelts > 0 { Some(&mut self[nelts - 1]) } else { None }\n+        let len = self.len();\n+        if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n     }\n \n     /// Removes the first element and returns it, or `None` if the sequence is\n@@ -429,12 +550,13 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop_front(&mut self) -> Option<T> {\n-        let result = self.elts[self.lo].take();\n-        if result.is_some() {\n-            self.lo = (self.lo + 1u) % self.elts.len();\n-            self.nelts -= 1u;\n+        if self.is_empty() {\n+            None\n+        } else {\n+            let tail = self.tail;\n+            self.tail = self.wrap_index(self.tail + 1);\n+            unsafe { Some(self.buffer_read(tail)) }\n         }\n-        result\n     }\n \n     /// Inserts an element first in the sequence.\n@@ -451,14 +573,14 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push_front(&mut self, t: T) {\n-        if self.nelts == self.elts.len() {\n-            grow(self.nelts, &mut self.lo, &mut self.elts);\n+        if self.is_full() {\n+            self.reserve(1);\n+            debug_assert!(!self.is_full());\n         }\n-        if self.lo == 0u {\n-            self.lo = self.elts.len() - 1u;\n-        } else { self.lo -= 1u; }\n-        self.elts[self.lo] = Some(t);\n-        self.nelts += 1u;\n+\n+        self.tail = self.wrap_index(self.tail - 1);\n+        let tail = self.tail;\n+        unsafe { self.buffer_write(tail, t); }\n     }\n \n     /// Deprecated: Renamed to `push_back`.\n@@ -481,12 +603,14 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push_back(&mut self, t: T) {\n-        if self.nelts == self.elts.len() {\n-            grow(self.nelts, &mut self.lo, &mut self.elts);\n+        if self.is_full() {\n+            self.reserve(1);\n+            debug_assert!(!self.is_full());\n         }\n-        let hi = self.raw_index(self.nelts);\n-        self.elts[hi] = Some(t);\n-        self.nelts += 1u;\n+\n+        let head = self.head;\n+        self.head = self.wrap_index(self.head + 1);\n+        unsafe { self.buffer_write(head, t) }\n     }\n \n     /// Deprecated: Renamed to `pop_back`.\n@@ -511,168 +635,139 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop_back(&mut self) -> Option<T> {\n-        if self.nelts > 0 {\n-            self.nelts -= 1;\n-            let hi = self.raw_index(self.nelts);\n-            self.elts[hi].take()\n-        } else {\n+        if self.is_empty() {\n             None\n+        } else {\n+            self.head = self.wrap_index(self.head - 1);\n+            let head = self.head;\n+            unsafe { Some(self.buffer_read(head)) }\n         }\n     }\n }\n \n+/// Returns the index in the underlying buffer for a given logical element index.\n+#[inline]\n+fn wrap_index(index: uint, size: uint) -> uint {\n+    // size is always a power of 2\n+    index & (size - 1)\n+}\n+\n+/// Calculate the number of elements left to be read in the buffer\n+#[inline]\n+fn count(tail: uint, head: uint, size: uint) -> uint {\n+    // size is always a power of 2\n+    (head - tail) & (size - 1)\n+}\n+\n /// `RingBuf` iterator.\n pub struct Items<'a, T:'a> {\n-    lo: uint,\n-    index: uint,\n-    rindex: uint,\n-    elts: &'a [Option<T>],\n+    ring: &'a [T],\n+    tail: uint,\n+    head: uint\n }\n \n impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n-        if self.index == self.rindex {\n+        if self.tail == self.head {\n             return None;\n         }\n-        let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n-        self.index += 1;\n-        Some(self.elts[raw_index].as_ref().unwrap())\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail + 1, self.ring.len());\n+        unsafe { Some(self.ring.unsafe_get(tail)) }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        let len = self.rindex - self.index;\n+        let len = count(self.tail, self.head, self.ring.len());\n         (len, Some(len))\n     }\n }\n \n impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n-        if self.index == self.rindex {\n+        if self.tail == self.head {\n             return None;\n         }\n-        self.rindex -= 1;\n-        let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n-        Some(self.elts[raw_index].as_ref().unwrap())\n+        self.head = wrap_index(self.head - 1, self.ring.len());\n+        unsafe { Some(self.ring.unsafe_get(self.head)) }\n     }\n }\n \n+\n impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n \n impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint { self.rindex - self.index }\n+    fn indexable(&self) -> uint {\n+        let (len, _) = self.size_hint();\n+        len\n+    }\n \n     #[inline]\n     fn idx(&mut self, j: uint) -> Option<&'a T> {\n         if j >= self.indexable() {\n             None\n         } else {\n-            let raw_index = raw_index(self.lo, self.elts.len(), self.index + j);\n-            Some(self.elts[raw_index].as_ref().unwrap())\n+            let idx = wrap_index(self.tail + j, self.ring.len());\n+            unsafe { Some(self.ring.unsafe_get(idx)) }\n         }\n     }\n }\n \n+// FIXME This was implemented differently from Items because of a problem\n+//       with returning the mutable reference. I couldn't find a way to\n+//       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n pub struct MutItems<'a, T:'a> {\n-    remaining1: slice::MutItems<'a, Option<T>>,\n-    remaining2: slice::MutItems<'a, Option<T>>,\n-    nelts: uint,\n+    ptr: *mut T,\n+    tail: uint,\n+    head: uint,\n+    cap: uint,\n+    marker: marker::ContravariantLifetime<'a>,\n+    marker2: marker::NoCopy\n }\n \n impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n-        if self.nelts == 0 {\n+        if self.tail == self.head {\n             return None;\n         }\n-        self.nelts -= 1;\n-        match self.remaining1.next() {\n-            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n-            None => {}\n-        }\n-        match self.remaining2.next() {\n-            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n-            None => unreachable!(),\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail + 1, self.cap);\n+        if mem::size_of::<T>() != 0 {\n+            unsafe { Some(&mut *self.ptr.offset(tail as int)) }\n+        } else {\n+            // use a non-zero pointer\n+            Some(unsafe { mem::transmute(1u) })\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.nelts, Some(self.nelts))\n+        let len = count(self.tail, self.head, self.cap);\n+        (len, Some(len))\n     }\n }\n \n impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n-        if self.nelts == 0 {\n+        if self.tail == self.head {\n             return None;\n         }\n-        self.nelts -= 1;\n-        match self.remaining2.next_back() {\n-            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n-            None => {}\n-        }\n-        match self.remaining1.next_back() {\n-            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n-            None => unreachable!(),\n-        }\n+        self.head = wrap_index(self.head - 1, self.cap);\n+        unsafe { Some(&mut *self.ptr.offset(self.head as int)) }\n     }\n }\n \n impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n \n-/// Grow is only called on full elts, so nelts is also len(elts), unlike\n-/// elsewhere.\n-fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut Vec<Option<T>>) {\n-    assert_eq!(nelts, elts.len());\n-    let lo = *loptr;\n-    elts.reserve_exact(nelts);\n-    let newlen = elts.capacity();\n-\n-    /* fill with None */\n-    for _ in range(elts.len(), newlen) {\n-        elts.push(None);\n-    }\n-\n-    /*\n-      Move the shortest half into the newly reserved area.\n-      lo ---->|\n-      nelts ----------->|\n-        [o o o|o o o o o]\n-      A [. . .|o o o o o o o o|. . . . .]\n-      B [o o o|. . . . . . . .|o o o o o]\n-     */\n-\n-    assert!(newlen - nelts/2 >= nelts);\n-    if lo <= (nelts - lo) { // A\n-        for i in range(0u, lo) {\n-            elts.as_mut_slice().swap(i, nelts + i);\n-        }\n-    } else {                // B\n-        for i in range(lo, nelts) {\n-            elts.as_mut_slice().swap(i, newlen - nelts + i);\n-        }\n-        *loptr += newlen - nelts;\n-    }\n-}\n-\n-/// Returns the index in the underlying `Vec` for a given logical element index.\n-fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n-    if lo >= len - index {\n-        lo + index - len\n-    } else {\n-        lo + index\n-    }\n-}\n-\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n-        self.nelts == other.nelts &&\n+        self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n     fn ne(&self, other: &RingBuf<A>) -> bool {\n@@ -707,22 +802,14 @@ impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n impl<A> Index<uint, A> for RingBuf<A> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a A {\n-        let idx = self.raw_index(*i);\n-        match self.elts[idx] {\n-            None => panic!(),\n-            Some(ref v) => v,\n-        }\n+        self.get(*i).expect(\"Out of bounds access\")\n     }\n }\n \n impl<A> IndexMut<uint, A> for RingBuf<A> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut A {\n-        let idx = self.raw_index(*i);\n-        match *(&mut self.elts[idx]) {\n-            None => panic!(),\n-            Some(ref mut v) => v\n-        }\n+        self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n }\n \n@@ -888,36 +975,99 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut test::Bencher) {\n         b.iter(|| {\n-            let _: RingBuf<u64> = RingBuf::new();\n+            let ring: RingBuf<u64> = RingBuf::new();\n+            test::black_box(ring);\n         })\n     }\n \n     #[bench]\n-    fn bench_push_back(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::new();\n+    fn bench_push_back_100(b: &mut test::Bencher) {\n+        let mut deq = RingBuf::with_capacity(101);\n         b.iter(|| {\n-            deq.push_back(0i);\n+            for i in range(0i, 100) {\n+                deq.push_back(i);\n+            }\n+            deq.head = 0;\n+            deq.tail = 0;\n         })\n     }\n \n     #[bench]\n-    fn bench_push_front(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::new();\n+    fn bench_push_front_100(b: &mut test::Bencher) {\n+        let mut deq = RingBuf::with_capacity(101);\n         b.iter(|| {\n-            deq.push_front(0i);\n+            for i in range(0i, 100) {\n+                deq.push_front(i);\n+            }\n+            deq.head = 0;\n+            deq.tail = 0;\n         })\n     }\n \n     #[bench]\n-    fn bench_grow(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::new();\n+    fn bench_pop_back_100(b: &mut test::Bencher) {\n+        let mut deq: RingBuf<int> = RingBuf::with_capacity(101);\n+\n+        b.iter(|| {\n+            deq.head = 100;\n+            deq.tail = 0;\n+            while !deq.is_empty() {\n+                test::black_box(deq.pop_back());\n+            }\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_pop_front_100(b: &mut test::Bencher) {\n+        let mut deq: RingBuf<int> = RingBuf::with_capacity(101);\n+\n+        b.iter(|| {\n+            deq.head = 100;\n+            deq.tail = 0;\n+            while !deq.is_empty() {\n+                test::black_box(deq.pop_front());\n+            }\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_grow_1025(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            let mut deq = RingBuf::new();\n+            for i in range(0i, 1025) {\n+                deq.push_front(i);\n+            }\n+            test::black_box(deq);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_iter_1000(b: &mut test::Bencher) {\n+        let ring: RingBuf<int> = range(0i, 1000).collect();\n+\n         b.iter(|| {\n-            for _ in range(0i, 65) {\n-                deq.push_front(1i);\n+            let mut sum = 0;\n+            for &i in ring.iter() {\n+                sum += i;\n             }\n+            test::black_box(sum);\n         })\n     }\n \n+    #[bench]\n+    fn bench_mut_iter_1000(b: &mut test::Bencher) {\n+        let mut ring: RingBuf<int> = range(0i, 1000).collect();\n+\n+        b.iter(|| {\n+            let mut sum = 0;\n+            for i in ring.iter_mut() {\n+                sum += *i;\n+            }\n+            test::black_box(sum);\n+        })\n+    }\n+\n+\n     #[deriving(Clone, PartialEq, Show)]\n     enum Taggy {\n         One(int),\n@@ -1034,11 +1184,11 @@ mod tests {\n         let mut d = RingBuf::new();\n         d.push_back(0u64);\n         d.reserve(50);\n-        assert!(d.capacity() >= 64);\n+        assert!(d.capacity() >= 51);\n         let mut d = RingBuf::new();\n         d.push_back(0u32);\n         d.reserve(50);\n-        assert!(d.capacity() >= 64);\n+        assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n@@ -1257,4 +1407,169 @@ mod tests {\n                                                                         .collect();\n         assert!(format!(\"{}\", ringbuf).as_slice() == \"[just, one, test, more]\");\n     }\n+\n+    #[test]\n+    fn test_drop() {\n+        static mut drops: uint = 0;\n+        struct Elem;\n+        impl Drop for Elem {\n+            fn drop(&mut self) {\n+                unsafe { drops += 1; }\n+            }\n+        }\n+\n+        let mut ring = RingBuf::new();\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        drop(ring);\n+\n+        assert_eq!(unsafe {drops}, 4);\n+    }\n+\n+    #[test]\n+    fn test_drop_with_pop() {\n+        static mut drops: uint = 0;\n+        struct Elem;\n+        impl Drop for Elem {\n+            fn drop(&mut self) {\n+                unsafe { drops += 1; }\n+            }\n+        }\n+\n+        let mut ring = RingBuf::new();\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+\n+        drop(ring.pop_back());\n+        drop(ring.pop_front());\n+        assert_eq!(unsafe {drops}, 2);\n+\n+        drop(ring);\n+        assert_eq!(unsafe {drops}, 4);\n+    }\n+\n+    #[test]\n+    fn test_drop_clear() {\n+        static mut drops: uint = 0;\n+        struct Elem;\n+        impl Drop for Elem {\n+            fn drop(&mut self) {\n+                unsafe { drops += 1; }\n+            }\n+        }\n+\n+        let mut ring = RingBuf::new();\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        ring.clear();\n+        assert_eq!(unsafe {drops}, 4);\n+\n+        drop(ring);\n+        assert_eq!(unsafe {drops}, 4);\n+    }\n+\n+    #[test]\n+    fn test_reserve_grow() {\n+        // test growth path A\n+        // [T o o H] -> [T o o H . . . . ]\n+        let mut ring = RingBuf::with_capacity(4);\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+        }\n+        ring.reserve(7);\n+        for i in range(0i, 3) {\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+\n+        // test growth path B\n+        // [H T o o] -> [. T o o H . . . ]\n+        let mut ring = RingBuf::with_capacity(4);\n+        for i in range(0i, 1) {\n+            ring.push_back(i);\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+        }\n+        ring.reserve(7);\n+        for i in range(0i, 3) {\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+\n+        // test growth path C\n+        // [o o H T] -> [o o H . . . . T ]\n+        let mut ring = RingBuf::with_capacity(4);\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+        }\n+        ring.reserve(7);\n+        for i in range(0i, 3) {\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_get() {\n+        let mut ring = RingBuf::new();\n+        ring.push_back(0i);\n+        assert_eq!(ring.get(0), Some(&0));\n+        assert_eq!(ring.get(1), None);\n+\n+        ring.push_back(1);\n+        assert_eq!(ring.get(0), Some(&0));\n+        assert_eq!(ring.get(1), Some(&1));\n+        assert_eq!(ring.get(2), None);\n+\n+        ring.push_back(2);\n+        assert_eq!(ring.get(0), Some(&0));\n+        assert_eq!(ring.get(1), Some(&1));\n+        assert_eq!(ring.get(2), Some(&2));\n+        assert_eq!(ring.get(3), None);\n+\n+        assert_eq!(ring.pop_front(), Some(0));\n+        assert_eq!(ring.get(0), Some(&1));\n+        assert_eq!(ring.get(1), Some(&2));\n+        assert_eq!(ring.get(2), None);\n+\n+        assert_eq!(ring.pop_front(), Some(1));\n+        assert_eq!(ring.get(0), Some(&2));\n+        assert_eq!(ring.get(1), None);\n+\n+        assert_eq!(ring.pop_front(), Some(2));\n+        assert_eq!(ring.get(0), None);\n+        assert_eq!(ring.get(1), None);\n+    }\n+\n+    #[test]\n+    fn test_get_mut() {\n+        let mut ring = RingBuf::new();\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+        }\n+\n+        match ring.get_mut(1) {\n+            Some(x) => *x = -1,\n+            None => ()\n+        };\n+\n+        assert_eq!(ring.get_mut(0), Some(&mut 0));\n+        assert_eq!(ring.get_mut(1), Some(&mut -1));\n+        assert_eq!(ring.get_mut(2), Some(&mut 2));\n+        assert_eq!(ring.get_mut(3), None);\n+\n+        assert_eq!(ring.pop_front(), Some(0));\n+        assert_eq!(ring.get_mut(0), Some(&mut -1));\n+        assert_eq!(ring.get_mut(1), Some(&mut 2));\n+        assert_eq!(ring.get_mut(2), None);\n+    }\n }"}]}