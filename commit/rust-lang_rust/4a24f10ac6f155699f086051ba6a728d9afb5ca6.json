{"sha": "4a24f10ac6f155699f086051ba6a728d9afb5ca6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMjRmMTBhYzZmMTU1Njk5ZjA4NjA1MWJhNmE3MjhkOWFmYjVjYTY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-24T12:29:19Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-24T12:34:19Z"}, "message": "libcore: unify `gen_<type>` methods on `rand::RngUtil` into the generic `gen`.\n\nThis moves all the basic random value generation into the Rand instances for\neach type and then removes the `gen_int`, `gen_char` (etc) methods on RngUtil,\nleaving only the generic `gen` and the more specialised methods.\n\nAlso, removes some imports that are redundant due to a `use core::prelude::*`\nstatement.", "tree": {"sha": "c7711a4f4765283e35b2149d7e136afd3ab712a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7711a4f4765283e35b2149d7e136afd3ab712a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a24f10ac6f155699f086051ba6a728d9afb5ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a24f10ac6f155699f086051ba6a728d9afb5ca6", "html_url": "https://github.com/rust-lang/rust/commit/4a24f10ac6f155699f086051ba6a728d9afb5ca6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a24f10ac6f155699f086051ba6a728d9afb5ca6/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b009210c66d6b62ca6be123b752b464f8f178e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b009210c66d6b62ca6be123b752b464f8f178e5", "html_url": "https://github.com/rust-lang/rust/commit/7b009210c66d6b62ca6be123b752b464f8f178e5"}], "stats": {"total": 353, "additions": 106, "deletions": 247}, "files": [{"sha": "d2be0416371befb23665478bc867dfee58dab2f3", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -56,7 +56,7 @@ fn resize_at(capacity: uint) -> uint {\n pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n     initial_capacity: uint) -> HashMap<K, V> {\n     let r = rand::task_rng();\n-    linear_map_with_capacity_and_keys((*r).gen_u64(), (*r).gen_u64(),\n+    linear_map_with_capacity_and_keys(r.gen(), r.gen(),\n                                       initial_capacity)\n }\n "}, {"sha": "367278f66f321799c11a6db20b37636a4eb03346", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 75, "deletions": 178, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -8,7 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Random number generation\n+/*!\n+Random number generation.\n+\n+The key functions are `random()` and `RngUtil::gen()`. These are polymorphic\n+and so can be used to generate any type that implements `Rand`. Type inference\n+means that often a simple call to `rand::random()` or `rng.gen()` will\n+suffice, but sometimes an annotation is required, e.g. `rand::random::<float>()`.\n+\n+# Examples\n+~~~\n+use core::rand::RngUtil;\n+\n+fn main() {\n+    let rng = rand::rng();\n+    if rng.gen() { // bool\n+        println(fmt!(\"int: %d, uint: %u\", rng.gen(), rng.gen()))\n+    }\n+}\n+~~~\n+\n+~~~\n+fn main () {\n+    let tuple_ptr = rand::random::<~(f64, char)>();\n+    println(fmt!(\"%?\", tuple_ptr))\n+}\n+~~~\n+*/\n+\n \n use int;\n use prelude::*;\n@@ -20,98 +47,111 @@ use util;\n use vec;\n use libc::size_t;\n \n-/// A type that can be randomly generated using an RNG\n+/// A type that can be randomly generated using an Rng\n pub trait Rand {\n     fn rand<R: Rng>(rng: &R) -> Self;\n }\n \n impl Rand for int {\n     fn rand<R: Rng>(rng: &R) -> int {\n-        rng.gen_int()\n+        if int::bits == 32 {\n+            rng.next() as int\n+        } else {\n+            rng.gen::<i64>() as int\n+        }\n     }\n }\n \n impl Rand for i8 {\n     fn rand<R: Rng>(rng: &R) -> i8 {\n-        rng.gen_i8()\n+        rng.next() as i8\n     }\n }\n \n impl Rand for i16 {\n     fn rand<R: Rng>(rng: &R) -> i16 {\n-        rng.gen_i16()\n+        rng.next() as i16\n     }\n }\n \n impl Rand for i32 {\n     fn rand<R: Rng>(rng: &R) -> i32 {\n-        rng.gen_i32()\n+        rng.next() as i32\n     }\n }\n \n impl Rand for i64 {\n     fn rand<R: Rng>(rng: &R) -> i64 {\n-        rng.gen_i64()\n+        (rng.next() as i64 << 32) | rng.next() as i64\n     }\n }\n \n impl Rand for uint {\n     fn rand<R: Rng>(rng: &R) -> uint {\n-        rng.gen_uint()\n+        if uint::bits == 32 {\n+            rng.next() as uint\n+        } else {\n+            rng.gen::<u64>() as uint\n+        }\n     }\n }\n \n impl Rand for u8 {\n     fn rand<R: Rng>(rng: &R) -> u8 {\n-        rng.gen_u8()\n+        rng.next() as u8\n     }\n }\n \n impl Rand for u16 {\n     fn rand<R: Rng>(rng: &R) -> u16 {\n-        rng.gen_u16()\n+        rng.next() as u16\n     }\n }\n \n impl Rand for u32 {\n     fn rand<R: Rng>(rng: &R) -> u32 {\n-        rng.gen_u32()\n+        rng.next()\n     }\n }\n \n impl Rand for u64 {\n     fn rand<R: Rng>(rng: &R) -> u64 {\n-        rng.gen_u64()\n+        (rng.next() as u64 << 32) | rng.next() as u64\n     }\n }\n \n impl Rand for float {\n     fn rand<R: Rng>(rng: &R) -> float {\n-        rng.gen_float()\n+        rng.gen::<f64>() as float\n     }\n }\n \n impl Rand for f32 {\n     fn rand<R: Rng>(rng: &R) -> f32 {\n-        rng.gen_f32()\n+        rng.gen::<f64>() as f32\n     }\n }\n \n+static scale : f64 = (u32::max_value as f64) + 1.0f64;\n impl Rand for f64 {\n     fn rand<R: Rng>(rng: &R) -> f64 {\n-        rng.gen_f64()\n+        let u1 = rng.next() as f64;\n+        let u2 = rng.next() as f64;\n+        let u3 = rng.next() as f64;\n+\n+        ((u1 / scale + u2) / scale + u3) / scale\n     }\n }\n \n impl Rand for char {\n     fn rand<R: Rng>(rng: &R) -> char {\n-        rng.gen_char()\n+        rng.next() as char\n     }\n }\n \n impl Rand for bool {\n     fn rand<R: Rng>(rng: &R) -> bool {\n-        rng.gen_bool()\n+        rng.next() & 1u32 == 1u32\n     }\n }\n \n@@ -151,7 +191,7 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n \n impl<T:Rand> Rand for Option<T> {\n     fn rand<R: Rng>(rng: &R) -> Option<T> {\n-        if rng.gen_bool() {\n+        if rng.gen() {\n             Some(rng.gen())\n         } else {\n             None\n@@ -195,93 +235,24 @@ pub struct Weighted<T> {\n     weight: uint,\n     item: T,\n }\n-// this should be in gen_f64, but it causes an ICE there.\n-static scale : f64 = (u32::max_value as f64) + 1.0f64;\n+\n pub trait RngUtil {\n     /// Return a random value of a Rand type\n     fn gen<T:Rand>(&self) -> T;\n     /**\n-     * Return a random int\n-     *\n-     * *Example*\n-     *\n-     * ~~~\n-     *\n-     * use core::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     rng = rand::rng();\n-     *     println(fmt!(\"%d\",rng.gen_int()));\n-     * }\n-     * ~~~\n+     * Return a int randomly chosen from the range [start, end),\n+     * failing if start >= end\n      */\n-    fn gen_int(&self) -> int;\n     fn gen_int_range(&self, start: int, end: int) -> int;\n-    /// Return a random i8\n-    fn gen_i8(&self) -> i8;\n-    /// Return a random i16\n-    fn gen_i16(&self) -> i16;\n-    /// Return a random i32\n-    fn gen_i32(&self) -> i32;\n-    /// Return a random i64\n-    fn gen_i64(&self) -> i64;\n-    /// Return a random uint\n-    fn gen_uint(&self) -> uint;\n     /**\n      * Return a uint randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n     fn gen_uint_range(&self, start: uint, end: uint) -> uint;\n-    /// Return a random u8\n-    fn gen_u8(&self) -> u8;\n-    /// Return a random u16\n-    fn gen_u16(&self) -> u16;\n-    /// Return a random u32\n-    fn gen_u32(&self) -> u32;\n-    /// Return a random u64\n-    fn gen_u64(&self) -> u64;\n-    /**\n-     * Return random float in the interval [0,1]\n-     *\n-     * *Example*\n-     *\n-     * ~~~\n-     *\n-     * use core::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     rng = rand::rng();\n-     *     println(fmt!(\"%f\",rng.gen_float()));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_float(&self) -> float;\n-    /// Return a random f32 in the interval [0,1]\n-    fn gen_f32(&self) -> f32;\n-    /// Return a random f64 in the interval [0,1]\n-    fn gen_f64(&self) -> f64;\n-    /// Return a random char\n-    fn gen_char(&self) -> char;\n     /**\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n     fn gen_char_from(&self, chars: &str) -> char;\n-    /**\n-     * Return a random bool\n-     *\n-     * *Example*\n-     *\n-     * ~~~\n-     *\n-     * use core::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     rng = rand::rng();\n-     *     println(fmt!(\"%b\",rng.gen_bool()));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_bool(&self) -> bool;\n     /**\n      * Return a bool with a 1 in n chance of true\n      *\n@@ -453,43 +424,13 @@ impl<R: Rng> RngUtil for R {\n         Rand::rand(self)\n     }\n \n-    /// Return a random int\n-    fn gen_int(&self) -> int {\n-        self.gen_i64() as int\n-    }\n-\n     /**\n      * Return an int randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n     fn gen_int_range(&self, start: int, end: int) -> int {\n         assert!(start < end);\n-        start + int::abs(self.gen_int() % (end - start))\n-    }\n-\n-    /// Return a random i8\n-    fn gen_i8(&self) -> i8 {\n-        self.next() as i8\n-    }\n-\n-    /// Return a random i16\n-    fn gen_i16(&self) -> i16 {\n-        self.next() as i16\n-    }\n-\n-    /// Return a random i32\n-    fn gen_i32(&self) -> i32 {\n-        self.next() as i32\n-    }\n-\n-    /// Return a random i64\n-    fn gen_i64(&self) -> i64 {\n-        (self.next() as i64 << 32) | self.next() as i64\n-    }\n-\n-    /// Return a random uint\n-    fn gen_uint(&self) -> uint {\n-        self.gen_u64() as uint\n+        start + int::abs(self.gen::<int>() % (end - start))\n     }\n \n     /**\n@@ -498,51 +439,7 @@ impl<R: Rng> RngUtil for R {\n      */\n     fn gen_uint_range(&self, start: uint, end: uint) -> uint {\n         assert!(start < end);\n-        start + (self.gen_uint() % (end - start))\n-    }\n-\n-    /// Return a random u8\n-    fn gen_u8(&self) -> u8 {\n-        self.next() as u8\n-    }\n-\n-    /// Return a random u16\n-    fn gen_u16(&self) -> u16 {\n-        self.next() as u16\n-    }\n-\n-    /// Return a random u32\n-    fn gen_u32(&self) -> u32 {\n-        self.next()\n-    }\n-\n-    /// Return a random u64\n-    fn gen_u64(&self) -> u64 {\n-        (self.next() as u64 << 32) | self.next() as u64\n-    }\n-\n-    /// Return a random float in the interval [0,1]\n-    fn gen_float(&self) -> float {\n-        self.gen_f64() as float\n-    }\n-\n-    /// Return a random f32 in the interval [0,1]\n-    fn gen_f32(&self) -> f32 {\n-        self.gen_f64() as f32\n-    }\n-\n-    /// Return a random f64 in the interval [0,1]\n-    fn gen_f64(&self) -> f64 {\n-        let u1 = self.next() as f64;\n-        let u2 = self.next() as f64;\n-        let u3 = self.next() as f64;\n-\n-        return ((u1 / scale + u2) / scale + u3) / scale;\n-    }\n-\n-    /// Return a random char\n-    fn gen_char(&self) -> char {\n-        self.next() as char\n+        start + (self.gen::<uint>() % (end - start))\n     }\n \n     /**\n@@ -555,11 +452,6 @@ impl<R: Rng> RngUtil for R {\n         self.choose(cs)\n     }\n \n-    /// Return a random bool\n-    fn gen_bool(&self) -> bool {\n-        self.next() & 1u32 == 1u32\n-    }\n-\n     /// Return a bool with a 1-in-n chance of true\n     fn gen_weighted_bool(&self, n: uint) -> bool {\n         if n == 0u {\n@@ -588,7 +480,7 @@ impl<R: Rng> RngUtil for R {\n     /// Return a random byte string of the specified length\n     fn gen_bytes(&self, len: uint) -> ~[u8] {\n         do vec::from_fn(len) |_i| {\n-            self.gen_u8()\n+            self.gen()\n         }\n     }\n \n@@ -777,7 +669,7 @@ fn tls_rng_state(_v: @IsaacRng) {}\n /**\n  * Gives back a lazily initialized task-local random number generator,\n  * seeded by the system. Intended to be used in method chaining style, ie\n- * task_rng().gen_int().\n+ * `task_rng().gen::<int>()`.\n  */\n pub fn task_rng() -> @IsaacRng {\n     let r : Option<@IsaacRng>;\n@@ -796,6 +688,11 @@ pub fn task_rng() -> @IsaacRng {\n     }\n }\n \n+// Allow direct chaining with `task_rng`\n+impl<R: Rng> Rng for @R {\n+    fn next(&self) -> u32 { (*self).next() }\n+}\n+\n /**\n  * Returns a random value of a Rand type, using the task's random number\n  * generator.\n@@ -872,8 +769,8 @@ mod tests {\n     #[test]\n     fn test_gen_float() {\n         let r = rng();\n-        let a = r.gen_float();\n-        let b = r.gen_float();\n+        let a = r.gen::<float>();\n+        let b = r.gen::<float>();\n         debug!((a, b));\n     }\n \n@@ -966,9 +863,9 @@ mod tests {\n     #[test]\n     fn test_task_rng() {\n         let r = task_rng();\n-        (*r).gen_int();\n-        assert!((*r).shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n-        assert!((*r).gen_uint_range(0u, 1u) == 0u);\n+        r.gen::<int>();\n+        assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n+        assert!(r.gen_uint_range(0u, 1u) == 0u);\n     }\n \n     #[test]"}, {"sha": "cd9b44c278e46b6cf1e80c641e4ac811230632bf", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -73,8 +73,8 @@ pub fn normalize(p: ~Path) -> ~Path {\n mod test {\n     use core::{os, rand};\n     use core::path::Path;\n-    use core::rand::RngUtil;\n     use path_util::*;\n+    use core::rand::RngUtil;\n \n     // Helper function to create a directory name that doesn't exist\n     pub fn mk_nonexistent(tmpdir: &Path, suffix: &str) -> Path {"}, {"sha": "8bfa2013950692bf0641a372708bbf6926977645", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -1425,7 +1425,7 @@ mod tests {\n         assert!(a.capacity() == uint::bits);\n     }\n \n-    fn rng() -> rand::RandRes {\n+    fn rng() -> rand::IsaacRng {\n         let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n         rand::IsaacRng::new_seeded(seed)\n     }"}, {"sha": "db6efdf3f52aaf75160196a9eddbc7028e73cee8", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -902,12 +902,8 @@ mod tests {\n #[cfg(test)]\n mod test_tim_sort {\n     use core::prelude::*;\n-\n     use sort::tim_sort;\n-\n     use core::rand::RngUtil;\n-    use core::rand;\n-    use core::vec;\n \n     struct CVal {\n         val: float,\n@@ -916,7 +912,7 @@ mod test_tim_sort {\n     impl Ord for CVal {\n         fn lt(&self, other: &CVal) -> bool {\n             let rng = rand::rng();\n-            if rng.gen_float() > 0.995 { fail!(~\"It's happening!!!\"); }\n+            if rng.gen::<float>() > 0.995 { fail!(~\"It's happening!!!\"); }\n             (*self).val < other.val\n         }\n         fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n@@ -966,8 +962,7 @@ mod test_tim_sort {\n     fn crash_test() {\n         let rng = rand::rng();\n         let mut arr = do vec::from_fn(1000) |_i| {\n-            let randVal = rng.gen_float();\n-            CVal { val: randVal }\n+            CVal { val: rng.gen() }\n         };\n \n         tim_sort(arr);\n@@ -987,8 +982,7 @@ mod test_tim_sort {\n     fn test_bad_Ord_impl() {\n         let rng = rand::rng();\n         let mut arr = do vec::from_fn(500) |_i| {\n-            let randVal = rng.gen_uint();\n-            DVal { val: randVal }\n+            DVal { val: rng.gen() }\n         };\n \n         tim_sort(arr);\n@@ -998,14 +992,8 @@ mod test_tim_sort {\n #[cfg(test)]\n mod big_tests {\n     use core::prelude::*;\n-\n     use sort::*;\n-\n     use core::rand::RngUtil;\n-    use core::rand;\n-    use core::task;\n-    use core::uint;\n-    use core::vec;\n \n     #[test]\n     fn test_unique() {\n@@ -1049,10 +1037,9 @@ mod big_tests {\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;\n-            let arr = do vec::from_fn(n) |_i| {\n-                rng.gen_float()\n+            let mut arr: ~[float] = do vec::from_fn(n) |_i| {\n+                rng.gen()\n             };\n-            let mut arr = arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1076,7 +1063,7 @@ mod big_tests {\n                 let size = arr.len();\n                 let mut idx = 1;\n                 while idx <= 10 {\n-                    arr[size-idx] = rng.gen_float();\n+                    arr[size-idx] = rng.gen();\n                     idx += 1;\n                 }\n             }\n@@ -1085,7 +1072,7 @@ mod big_tests {\n \n             for (n/100).times {\n                 let idx = rng.gen_uint_range(0, n);\n-                arr[idx] = rng.gen_float();\n+                arr[idx] = rng.gen();\n             }\n             tim_sort(arr);\n             isSorted(arr);\n@@ -1121,8 +1108,8 @@ mod big_tests {\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;\n-            let arr = do vec::from_fn(n) |_i| {\n-                @rng.gen_float()\n+            let arr: ~[@float] = do vec::from_fn(n) |_i| {\n+                @rng.gen()\n             };\n             let mut arr = arr;\n \n@@ -1148,7 +1135,7 @@ mod big_tests {\n                 let size = arr.len();\n                 let mut idx = 1;\n                 while idx <= 10 {\n-                    arr[size-idx] = @rng.gen_float();\n+                    arr[size-idx] = @rng.gen();\n                     idx += 1;\n                 }\n             }\n@@ -1157,7 +1144,7 @@ mod big_tests {\n \n             for (n/100).times {\n                 let idx = rng.gen_uint_range(0, n);\n-                arr[idx] = @rng.gen_float();\n+                arr[idx] = @rng.gen();\n             }\n             tim_sort(arr);\n             isSorted(arr);"}, {"sha": "c9bcb3b8952be306571317bdc4f0e56161ecf9b9", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -10,10 +10,8 @@\n \n //! Temporary files and directories\n \n-use core::os;\n use core::prelude::*;\n use core::rand::RngUtil;\n-use core::rand;\n \n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n     let r = rand::rng();"}, {"sha": "f82cc25e0f618e6a657369b0f073d1cd5c56c7d5", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -19,20 +19,9 @@ use getopts;\n use sort;\n use term;\n \n-use core::cmp::Eq;\n-\n use core::to_str::ToStr;\n-use core::either::Either;\n-use core::either;\n-use core::io::WriterUtil;\n-use core::io;\n use core::comm::{stream, SharedChan};\n-use core::option;\n use core::prelude::*;\n-use core::result;\n-use core::str;\n-use core::task;\n-use core::vec;\n \n pub mod rustrt {\n     use core::libc::size_t;\n@@ -608,12 +597,8 @@ pub mod bench {\n     use time::precise_time_ns;\n     use test::{BenchHarness, BenchSamples};\n     use stats::Stats;\n-\n-    use core::num;\n+    use core::prelude::*;\n     use core::rand::RngUtil;\n-    use core::rand;\n-    use core::u64;\n-    use core::vec;\n \n     pub impl BenchHarness {\n "}, {"sha": "1e48ce5aa6f2eb65ba82dca9e1681f08148cfe96", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -175,11 +175,7 @@ mod test {\n \n     use timer::*;\n     use uv;\n-\n-    use core::iter;\n     use core::rand::RngUtil;\n-    use core::rand;\n-    use core::task;\n     use core::pipes::{stream, SharedChan};\n \n     #[test]"}, {"sha": "020f4daefd9d672612a1cbd4787a299aedff4dab", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -698,7 +698,6 @@ mod test_treemap {\n     use core::iterator::*;\n     use super::*;\n     use core::rand::RngUtil;\n-    use core::rand;\n \n     #[test]\n     fn find_empty() {\n@@ -839,8 +838,8 @@ mod test_treemap {\n \n         for 3.times {\n             for 90.times {\n-                let k = rng.gen_int();\n-                let v = rng.gen_int();\n+                let k = rng.gen();\n+                let v = rng.gen();\n                 if !ctrl.contains(&(k, v)) {\n                     assert!(map.insert(k, v));\n                     ctrl.push((k, v));"}, {"sha": "e216215ace7f9a6266c8c9b1292af7eda8f691e1", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -15,6 +15,7 @@ use std::time;\n use std::treemap::TreeMap;\n use core::hashmap::{HashMap, HashSet};\n use core::trie::TrieMap;\n+use core::rand::Rng;\n \n fn timed(label: &str, f: &fn()) {\n     let start = time::precise_time_s();"}, {"sha": "b3e3d295c0fad596d86aba2d4c559c7aa11f70df", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -12,7 +12,6 @@ extern mod std;\n use core::hashmap::HashSet;\n use std::bitv::BitvSet;\n use std::treemap::TreeSet;\n-use core::io::WriterUtil;\n \n struct Results {\n     sequential_ints: float,\n@@ -32,7 +31,7 @@ fn timed(result: &mut float, op: &fn()) {\n }\n \n pub impl Results {\n-    fn bench_int<T:Set<uint>>(&mut self, rng: &rand::Rng, num_keys: uint,\n+    fn bench_int<T:Set<uint>, R: rand::Rng>(&mut self, rng: &R, num_keys: uint,\n                                rand_cap: uint, f: &fn() -> T) {\n         {\n             let mut set = f();\n@@ -70,8 +69,8 @@ pub impl Results {\n         }\n     }\n \n-    fn bench_str<T:Set<~str>>(&mut self, rng: &rand::Rng, num_keys: uint,\n-                               f: &fn() -> T) {\n+    fn bench_str<T:Set<~str>, R: rand::Rng>(&mut self, rng: &R, num_keys: uint,\n+                                            f: &fn() -> T) {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_strings) {\n@@ -166,15 +165,15 @@ fn main() {\n     {\n         let rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(rng, num_keys, max, || TreeSet::new::<uint>());\n-        results.bench_str(rng, num_keys, || TreeSet::new::<~str>());\n+        results.bench_int(&rng, num_keys, max, || TreeSet::new::<uint>());\n+        results.bench_str(&rng, num_keys, || TreeSet::new::<~str>());\n         write_results(\"std::treemap::TreeSet\", &results);\n     }\n \n     {\n         let rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(rng, num_keys, max, || BitvSet::new());\n+        results.bench_int(&rng, num_keys, max, || BitvSet::new());\n         write_results(\"std::bitv::BitvSet\", &results);\n     }\n }"}, {"sha": "1af3538a0219d1e2abf19afb459f82041705c816", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -13,8 +13,6 @@\n extern mod std;\n \n use std::time::precise_time_s;\n-\n-use core::io::{Reader, ReaderUtil};\n use core::rand::RngUtil;\n \n macro_rules! bench (\n@@ -77,7 +75,7 @@ fn vec_plus() {\n     let mut i = 0;\n     while i < 1500 {\n         let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n-        if r.gen_bool() {\n+        if r.gen() {\n             v += rv;\n         }\n         else {\n@@ -94,7 +92,7 @@ fn vec_append() {\n     let mut i = 0;\n     while i < 1500 {\n         let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n-        if r.gen_bool() {\n+        if r.gen() {\n             v = vec::append(v, rv);\n         }\n         else {\n@@ -110,7 +108,7 @@ fn vec_push_all() {\n     let mut v = ~[];\n     for uint::range(0, 1500) |i| {\n         let mut rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n-        if r.gen_bool() {\n+        if r.gen() {\n             v.push_all(rv);\n         }\n         else {"}, {"sha": "bd3de4a1b8aba7aa6af14dc7ef8d6d32a371a36d", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -25,7 +25,6 @@ use std::time;\n use std::deque::Deque;\n use std::par;\n use core::hashmap::{HashMap, HashSet};\n-use core::io::WriterUtil;\n use core::int::abs;\n use core::rand::RngUtil;\n \n@@ -51,7 +50,7 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n             let j = j * 2i64;\n             let scale = scale - 1u;\n \n-            let x = r.gen_float();\n+            let x = r.gen::<float>();\n \n             if x < A {\n                 choose_edge(i, j, scale, r)"}, {"sha": "0da3a2e5d68d06fdd7d175d09df14459069983fa", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -13,8 +13,8 @@ fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n #[inline(always)]\n fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }\n \n-fn random_gradient(r: &Rng) -> Vec2 {\n-    let v = r.gen_float() * float::consts::pi * 2.0;\n+fn random_gradient<R:Rng>(r: &R) -> Vec2 {\n+    let v = 2.0 * float::consts::pi * r.gen();\n     Vec2 {\n         x: float::cos(v) as f32,\n         y: float::sin(v) as f32,"}, {"sha": "0fcf8341ac8524b1534ddba9a94ca34a6f0c5bc8", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a24f10ac6f155699f086051ba6a728d9afb5ca6/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=4a24f10ac6f155699f086051ba6a728d9afb5ca6", "patch": "@@ -16,7 +16,7 @@\n  * http://shootout.alioth.debian.org/\n  */\n extern mod std;\n-use core::io::WriterUtil;\n+use core::rand::Rng;\n \n fn LINE_LENGTH() -> uint { return 60u; }\n "}]}