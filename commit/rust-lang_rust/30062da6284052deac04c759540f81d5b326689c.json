{"sha": "30062da6284052deac04c759540f81d5b326689c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMDYyZGE2Mjg0MDUyZGVhYzA0Yzc1OTU0MGY4MWQ1YjMyNjY4OWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-09T08:50:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-09T08:50:19Z"}, "message": "Merge #3516\n\n3516: Handle visibility in more cases in completion r=matklad a=flodiebold\n\nThis means we don't show private items when completing paths or method calls.\r\n\r\nWe might want to show private items if we can edit their definition and provide a \"make public\" assist, but I feel like we'd need better sorting of completion items for that, so they can be not shown or sorted to the bottom by default. Until then, they're usually more of a distraction to me.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "12f56d863263283c42d20fd337957d3980e5481b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12f56d863263283c42d20fd337957d3980e5481b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30062da6284052deac04c759540f81d5b326689c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeZgNLCRBK7hj4Ov3rIwAAdHIIAGN5Luiy2nBTuWO5b1GRzg0R\n5AvsktyqG4UzvwSnd9SM5hUkZ42Ex8Bp2Hrk2I6O/R6OtSzrFC71uuxdAWSLH9ys\ndrE31dkeOWbHbwPbemM9VWpd6EX1ZqOVY0LbUmVg1sqtNpCuTkguvr7CV3trtHaa\nPWBd4rPb9JEmpwUQPC9/upqVH6pM7WlSD4kMgi5qZM37e1A9/Vbk70mcSdJQI5Nq\na42+Z+M4eGD1AkoSgkM6EzDSAVw+XMmagza8uEjn+itcQrWY1vBLgX4cL35Y9lyT\n1jsUBiVxln5LN8UZ1Xy9sbcEGmO45WJOnDSYEC7w14UcSqrqy1yMHwKiCY842qQ=\n=bUly\n-----END PGP SIGNATURE-----\n", "payload": "tree 12f56d863263283c42d20fd337957d3980e5481b\nparent 0363c9495a6a07db276dce4c67fa35fbfc20153c\nparent 05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1583743819 +0000\ncommitter GitHub <noreply@github.com> 1583743819 +0000\n\nMerge #3516\n\n3516: Handle visibility in more cases in completion r=matklad a=flodiebold\n\nThis means we don't show private items when completing paths or method calls.\r\n\r\nWe might want to show private items if we can edit their definition and provide a \"make public\" assist, but I feel like we'd need better sorting of completion items for that, so they can be not shown or sorted to the bottom by default. Until then, they're usually more of a distraction to me.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30062da6284052deac04c759540f81d5b326689c", "html_url": "https://github.com/rust-lang/rust/commit/30062da6284052deac04c759540f81d5b326689c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30062da6284052deac04c759540f81d5b326689c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0363c9495a6a07db276dce4c67fa35fbfc20153c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0363c9495a6a07db276dce4c67fa35fbfc20153c", "html_url": "https://github.com/rust-lang/rust/commit/0363c9495a6a07db276dce4c67fa35fbfc20153c"}, {"sha": "05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7", "html_url": "https://github.com/rust-lang/rust/commit/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7"}], "stats": {"total": 236, "additions": 217, "deletions": 19}, "files": [{"sha": "911c809fdde5a04741a6d9109f8e443487a84352", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/30062da6284052deac04c759540f81d5b326689c/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30062da6284052deac04c759540f81d5b326689c/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=30062da6284052deac04c759540f81d5b326689c", "patch": "@@ -204,10 +204,26 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef)> {\n+    pub fn scope(\n+        self,\n+        db: &impl HirDatabase,\n+        visible_from: Option<Module>,\n+    ) -> Vec<(Name, ScopeDef)> {\n         db.crate_def_map(self.id.krate)[self.id.local_id]\n             .scope\n             .entries()\n+            .filter_map(|(name, def)| {\n+                if let Some(m) = visible_from {\n+                    let filtered = def.filter_visibility(|vis| vis.is_visible_from(db, m.id));\n+                    if filtered.is_none() && !def.is_none() {\n+                        None\n+                    } else {\n+                        Some((name, filtered))\n+                    }\n+                } else {\n+                    Some((name, def))\n+                }\n+            })\n             .map(|(name, def)| (name.clone(), def.into()))\n             .collect()\n     }\n@@ -571,6 +587,14 @@ impl Function {\n     }\n }\n \n+impl HasVisibility for Function {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+        let function_data = db.function_data(self.id);\n+        let visibility = &function_data.visibility;\n+        visibility.resolve(db, &self.id.resolver(db))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Const {\n     pub(crate) id: ConstId,\n@@ -590,6 +614,14 @@ impl Const {\n     }\n }\n \n+impl HasVisibility for Const {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+        let function_data = db.const_data(self.id);\n+        let visibility = &function_data.visibility;\n+        visibility.resolve(db, &self.id.resolver(db))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Static {\n     pub(crate) id: StaticId,\n@@ -664,6 +696,14 @@ impl TypeAlias {\n     }\n }\n \n+impl HasVisibility for TypeAlias {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+        let function_data = db.type_alias_data(self.id);\n+        let visibility = &function_data.visibility;\n+        visibility.resolve(db, &self.id.resolver(db))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroDef {\n     pub(crate) id: MacroDefId,\n@@ -751,6 +791,16 @@ impl AssocItem {\n     }\n }\n \n+impl HasVisibility for AssocItem {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+        match self {\n+            AssocItem::Function(f) => f.visibility(db),\n+            AssocItem::Const(c) => c.visibility(db),\n+            AssocItem::TypeAlias(t) => t.visibility(db),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n pub enum GenericDef {\n     Function(Function),"}, {"sha": "a72eb53690a5df58ad8a978e99956fd29e57492c", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/30062da6284052deac04c759540f81d5b326689c/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30062da6284052deac04c759540f81d5b326689c/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=30062da6284052deac04c759540f81d5b326689c", "patch": "@@ -7,13 +7,16 @@ use hir_expand::{\n     AstId, InFile,\n };\n use ra_prof::profile;\n-use ra_syntax::ast::{self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner};\n+use ra_syntax::ast::{\n+    self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, VisibilityOwner,\n+};\n \n use crate::{\n     db::DefDatabase,\n     path::{path, GenericArgs, Path},\n     src::HasSource,\n     type_ref::{Mutability, TypeBound, TypeRef},\n+    visibility::RawVisibility,\n     AssocContainerId, AssocItemId, ConstId, ConstLoc, Expander, FunctionId, FunctionLoc, HasModule,\n     ImplId, Intern, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n@@ -26,6 +29,7 @@ pub struct FunctionData {\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n     pub has_self_param: bool,\n+    pub visibility: RawVisibility,\n }\n \n impl FunctionData {\n@@ -72,7 +76,9 @@ impl FunctionData {\n             ret_type\n         };\n \n-        let sig = FunctionData { name, params, ret_type, has_self_param };\n+        let visibility = RawVisibility::from_ast(db, src.map(|s| s.visibility()));\n+\n+        let sig = FunctionData { name, params, ret_type, has_self_param, visibility };\n         Arc::new(sig)\n     }\n }\n@@ -91,17 +97,19 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n pub struct TypeAliasData {\n     pub name: Name,\n     pub type_ref: Option<TypeRef>,\n+    pub visibility: RawVisibility,\n }\n \n impl TypeAliasData {\n     pub(crate) fn type_alias_data_query(\n         db: &impl DefDatabase,\n         typ: TypeAliasId,\n     ) -> Arc<TypeAliasData> {\n-        let node = typ.lookup(db).source(db).value;\n-        let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n-        let type_ref = node.type_ref().map(TypeRef::from_ast);\n-        Arc::new(TypeAliasData { name, type_ref })\n+        let node = typ.lookup(db).source(db);\n+        let name = node.value.name().map_or_else(Name::missing, |n| n.as_name());\n+        let type_ref = node.value.type_ref().map(TypeRef::from_ast);\n+        let visibility = RawVisibility::from_ast(db, node.map(|n| n.visibility()));\n+        Arc::new(TypeAliasData { name, type_ref, visibility })\n     }\n }\n \n@@ -217,23 +225,28 @@ pub struct ConstData {\n     /// const _: () = ();\n     pub name: Option<Name>,\n     pub type_ref: TypeRef,\n+    pub visibility: RawVisibility,\n }\n \n impl ConstData {\n     pub(crate) fn const_data_query(db: &impl DefDatabase, konst: ConstId) -> Arc<ConstData> {\n-        let node = konst.lookup(db).source(db).value;\n-        Arc::new(ConstData::new(&node))\n+        let node = konst.lookup(db).source(db);\n+        Arc::new(ConstData::new(db, node))\n     }\n \n     pub(crate) fn static_data_query(db: &impl DefDatabase, konst: StaticId) -> Arc<ConstData> {\n-        let node = konst.lookup(db).source(db).value;\n-        Arc::new(ConstData::new(&node))\n+        let node = konst.lookup(db).source(db);\n+        Arc::new(ConstData::new(db, node))\n     }\n \n-    fn new<N: NameOwner + TypeAscriptionOwner>(node: &N) -> ConstData {\n-        let name = node.name().map(|n| n.as_name());\n-        let type_ref = TypeRef::from_ast_opt(node.ascribed_type());\n-        ConstData { name, type_ref }\n+    fn new<N: NameOwner + TypeAscriptionOwner + VisibilityOwner>(\n+        db: &impl DefDatabase,\n+        node: InFile<N>,\n+    ) -> ConstData {\n+        let name = node.value.name().map(|n| n.as_name());\n+        let type_ref = TypeRef::from_ast_opt(node.value.ascribed_type());\n+        let visibility = RawVisibility::from_ast(db, node.map(|n| n.visibility()));\n+        ConstData { name, type_ref, visibility }\n     }\n }\n "}, {"sha": "acada48ae1102e652e369180767aa8d4b5ee446d", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/30062da6284052deac04c759540f81d5b326689c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30062da6284052deac04c759540f81d5b326689c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=30062da6284052deac04c759540f81d5b326689c", "patch": "@@ -57,7 +57,10 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n         let mut seen_methods = FxHashSet::default();\n         let traits_in_scope = ctx.scope().traits_in_scope();\n         receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n-            if func.has_self_param(ctx.db) && seen_methods.insert(func.name(ctx.db)) {\n+            if func.has_self_param(ctx.db)\n+                && ctx.scope().module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n+                && seen_methods.insert(func.name(ctx.db))\n+            {\n                 acc.add_function(ctx, func);\n             }\n             None::<()>\n@@ -307,6 +310,39 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_method_completion_private() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+            struct A {}\n+            mod m {\n+                impl super::A {\n+                    fn private_method(&self) {}\n+                    pub(super) fn the_method(&self) {}\n+                }\n+            }\n+            fn foo(a: A) {\n+               a.<|>\n+            }\n+            \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_method()\",\n+                source_range: [256; 256),\n+                delete: [256; 256),\n+                insert: \"the_method()$0\",\n+                kind: Method,\n+                lookup: \"the_method\",\n+                detail: \"pub(super) fn the_method(&self)\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_trait_method_completion() {\n         assert_debug_snapshot!("}, {"sha": "d2c75857126eba77e83f33fa0ce1699a7fff5415", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/30062da6284052deac04c759540f81d5b326689c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30062da6284052deac04c759540f81d5b326689c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=30062da6284052deac04c759540f81d5b326689c", "patch": "@@ -1,6 +1,6 @@\n //! Completion of paths, including when writing a single name.\n \n-use hir::{Adt, PathResolution, ScopeDef};\n+use hir::{Adt, HasVisibility, PathResolution, ScopeDef};\n use ra_syntax::AstNode;\n use test_utils::tested_by;\n \n@@ -15,9 +15,10 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(PathResolution::Def(def)) => def,\n         _ => return,\n     };\n+    let context_module = ctx.scope().module();\n     match def {\n         hir::ModuleDef::Module(module) => {\n-            let module_scope = module.scope(ctx.db);\n+            let module_scope = module.scope(ctx.db, context_module);\n             for (name, def) in module_scope {\n                 if ctx.use_item_syntax.is_some() {\n                     if let ScopeDef::Unknown = def {\n@@ -51,6 +52,9 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             if let Some(krate) = krate {\n                 let traits_in_scope = ctx.scope().traits_in_scope();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n+                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                        return None;\n+                    }\n                     match item {\n                         hir::AssocItem::Function(func) => {\n                             if !func.has_self_param(ctx.db) {\n@@ -64,6 +68,9 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 });\n \n                 ty.iterate_impl_items(ctx.db, krate, |item| {\n+                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                        return None;\n+                    }\n                     match item {\n                         hir::AssocItem::Function(_) | hir::AssocItem::Const(_) => {}\n                         hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n@@ -74,6 +81,9 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n         hir::ModuleDef::Trait(t) => {\n             for item in t.items(ctx.db) {\n+                if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                    continue;\n+                }\n                 match item {\n                     hir::AssocItem::Function(func) => {\n                         if !func.has_self_param(ctx.db) {\n@@ -169,6 +179,41 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn path_visibility() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                use self::my::<|>;\n+\n+                mod my {\n+                    struct Bar;\n+                    pub struct Foo;\n+                    pub use Bar as PublicBar;\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Foo\",\n+                source_range: [31; 31),\n+                delete: [31; 31),\n+                insert: \"Foo\",\n+                kind: Struct,\n+            },\n+            CompletionItem {\n+                label: \"PublicBar\",\n+                source_range: [31; 31),\n+                delete: [31; 31),\n+                insert: \"PublicBar\",\n+                kind: Struct,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_use_item_starting_with_self() {\n         assert_debug_snapshot!(\n@@ -177,7 +222,7 @@ mod tests {\n                 use self::m::<|>;\n \n                 mod m {\n-                    struct Bar;\n+                    pub struct Bar;\n                 }\n                 \"\n             ),\n@@ -501,6 +546,60 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn associated_item_visibility() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                \"\n+                //- /lib.rs\n+                struct S;\n+\n+                mod m {\n+                    impl super::S {\n+                        pub(super) fn public_method() { }\n+                        fn private_method() { }\n+                        pub(super) type PublicType = u32;\n+                        type PrivateType = u32;\n+                        pub(super) const PUBLIC_CONST: u32 = 1;\n+                        const PRIVATE_CONST: u32 = 1;\n+                    }\n+                }\n+\n+                fn foo() { let _ = S::<|> }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"PUBLIC_CONST\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"PUBLIC_CONST\",\n+                kind: Const,\n+                detail: \"pub(super) const PUBLIC_CONST: u32 = 1;\",\n+            },\n+            CompletionItem {\n+                label: \"PublicType\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"PublicType\",\n+                kind: TypeAlias,\n+                detail: \"pub(super) type PublicType = u32;\",\n+            },\n+            CompletionItem {\n+                label: \"public_method()\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"public_method()$0\",\n+                kind: Function,\n+                lookup: \"public_method\",\n+                detail: \"pub(super) fn public_method()\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_enum_associated_method() {\n         assert_debug_snapshot!("}]}