{"sha": "5336bdcab1b452e2192332b3397f315d4ee51e51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMzZiZGNhYjFiNDUyZTIxOTIzMzJiMzM5N2YzMTVkNGVlNTFlNTE=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-21T17:31:40Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-21T17:31:40Z"}, "message": "dlist: Simplify match clauses to use Option methods\n\nMake the core Deque implementation a bit simpler by using Option methods\nwhen we simply map on a Some value, and deduplicate some common lines.", "tree": {"sha": "7d0a59e743c28930926d4aca8da7b448e4077182", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d0a59e743c28930926d4aca8da7b448e4077182"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5336bdcab1b452e2192332b3397f315d4ee51e51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5336bdcab1b452e2192332b3397f315d4ee51e51", "html_url": "https://github.com/rust-lang/rust/commit/5336bdcab1b452e2192332b3397f315d4ee51e51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5336bdcab1b452e2192332b3397f315d4ee51e51/comments", "author": null, "committer": null, "parents": [{"sha": "60cb9c003c48f29396470611e0caa544f3acea89", "url": "https://api.github.com/repos/rust-lang/rust/commits/60cb9c003c48f29396470611e0caa544f3acea89", "html_url": "https://github.com/rust-lang/rust/commit/60cb9c003c48f29396470611e0caa544f3acea89"}], "stats": {"total": 98, "additions": 33, "deletions": 65}, "files": [{"sha": "6d9b9f8efad1e3281566ed316e7a47f818d12088", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 33, "deletions": 65, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5336bdcab1b452e2192332b3397f315d4ee51e51/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5336bdcab1b452e2192332b3397f315d4ee51e51/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=5336bdcab1b452e2192332b3397f315d4ee51e51", "patch": "@@ -175,21 +175,12 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_back(&mut self) -> Option<T> {\n-        match self.list_tail.resolve() {\n-            None => None,\n-            Some(tail) => {\n-                self.length -= 1;\n-                let tail_own = match tail.prev.resolve() {\n-                    None => {\n-                        self.list_tail = Rawlink::none();\n-                        self.list_head.take_unwrap()\n-                    },\n-                    Some(tail_prev) => {\n-                        self.list_tail = tail.prev;\n-                        tail_prev.next.take_unwrap()\n-                    }\n-                };\n-                Some(tail_own.value)\n+        do self.list_tail.resolve().map_consume |tail| {\n+            self.length -= 1;\n+            self.list_tail = tail.prev;\n+            match tail.prev.resolve() {\n+                None => self.list_head.take_unwrap().value,\n+                Some(tail_prev) => tail_prev.next.take_unwrap().value\n             }\n         }\n     }\n@@ -217,21 +208,13 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_front(&mut self) -> Option<T> {\n-        match self.list_head.take() {\n-            None => None,\n-            Some(old_head) => {\n-                self.length -= 1;\n-                match *old_head {\n-                    Node{value: value, next: Some(next), prev: _} => {\n-                        self.list_head = link_with_prev(next, Rawlink::none());\n-                        Some(value)\n-                    }\n-                    Node{value: value, next: None, prev: _} => {\n-                        self.list_tail = Rawlink::none();\n-                        Some(value)\n-                    }\n-                }\n+        do self.list_head.take().map_consume |~Node{value, next, _}| {\n+            self.length -= 1;\n+            match next {\n+                Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),\n+                None => self.list_tail = Rawlink::none()\n             }\n+            value\n         }\n     }\n }\n@@ -251,7 +234,7 @@ impl<T> DList<T> {\n             None => *self = other,\n             Some(tail) => {\n                 match other {\n-                    DList{list_head: None, list_tail: _, length: _} => return,\n+                    DList{list_head: None, _} => return,\n                     DList{list_head: Some(node), list_tail: o_tail, length: o_length} => {\n                         tail.next = link_with_prev(node, self.list_tail);\n                         self.list_tail = o_tail;\n@@ -377,13 +360,10 @@ impl<'self, A> Iterator<&'self A> for DListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        match *self.head {\n-            None => None,\n-            Some(ref head) => {\n-                self.nelem -= 1;\n-                self.head = &head.next;\n-                Some(&head.value)\n-            }\n+        do self.head.map |head| {\n+            self.nelem -= 1;\n+            self.head = &head.next;\n+            &head.value\n         }\n     }\n \n@@ -399,13 +379,10 @@ impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        match self.tail.resolve() {\n-            None => None,\n-            Some(prev) => {\n-                self.nelem -= 1;\n-                self.tail = prev.prev;\n-                Some(&prev.value)\n-            }\n+        do self.tail.resolve().map_consume |prev| {\n+            self.nelem -= 1;\n+            self.tail = prev.prev;\n+            &prev.value\n         }\n     }\n }\n@@ -416,16 +393,13 @@ impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        match self.head.resolve() {\n-            None => None,\n-            Some(next) => {\n-                self.nelem -= 1;\n-                self.head = match next.next {\n-                    Some(ref mut node) => Rawlink::some(&mut **node),\n-                    None => Rawlink::none(),\n-                };\n-                Some(&mut next.value)\n-            }\n+        do self.head.resolve().map_consume |next| {\n+            self.nelem -= 1;\n+            self.head = match next.next {\n+                Some(ref mut node) => Rawlink::some(&mut **node),\n+                None => Rawlink::none(),\n+            };\n+            &mut next.value\n         }\n     }\n \n@@ -441,13 +415,10 @@ impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A>\n         if self.nelem == 0 {\n             return None;\n         }\n-        match self.tail.resolve() {\n-            None => None,\n-            Some(prev) => {\n-                self.nelem -= 1;\n-                self.tail = prev.prev;\n-                Some(&mut prev.value)\n-            }\n+        do self.tail.resolve().map_consume |prev| {\n+            self.nelem -= 1;\n+            self.tail = prev.prev;\n+            &mut prev.value\n         }\n     }\n }\n@@ -484,10 +455,7 @@ impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n \n     #[inline]\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n-        match self.head.resolve() {\n-            None => None,\n-            Some(head) => Some(&mut head.value),\n-        }\n+        self.head.resolve().map_consume(|head| &mut head.value)\n     }\n }\n "}]}