{"sha": "e34792b181ab6af0221c0fb35940b1cc5dc476e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNDc5MmIxODFhYjZhZjAyMjFjMGZiMzU5NDBiMWNjNWRjNDc2ZTE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-28T10:55:49Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-28T10:55:49Z"}, "message": "rustc: move the MIR map into TyCtxt.", "tree": {"sha": "f30ff4e3b3a569749726c45e2322169ee4ea3cdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f30ff4e3b3a569749726c45e2322169ee4ea3cdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e34792b181ab6af0221c0fb35940b1cc5dc476e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e34792b181ab6af0221c0fb35940b1cc5dc476e1", "html_url": "https://github.com/rust-lang/rust/commit/e34792b181ab6af0221c0fb35940b1cc5dc476e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e34792b181ab6af0221c0fb35940b1cc5dc476e1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36340ba994a8e5b12df70f0889eeb7d58e2705fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/36340ba994a8e5b12df70f0889eeb7d58e2705fe", "html_url": "https://github.com/rust-lang/rust/commit/36340ba994a8e5b12df70f0889eeb7d58e2705fe"}], "stats": {"total": 639, "additions": 231, "deletions": 408}, "files": [{"sha": "c88af45124b18980741cc97d89f0b190696fa4df", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -30,7 +30,6 @@ use hir::svh::Svh;\n use middle::lang_items;\n use ty::{self, Ty, TyCtxt};\n use mir::Mir;\n-use mir::mir_map::MirMap;\n use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n@@ -209,8 +208,7 @@ pub trait CrateStore<'tcx> {\n     fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId>;\n     fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId>;\n \n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<Mir<'tcx>>;\n+    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n     // This is basically a 1-based range of ints, which is a little\n@@ -228,8 +226,7 @@ pub trait CrateStore<'tcx> {\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n-                           reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>) -> Vec<u8>;\n+                           reachable: &NodeSet) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -390,8 +387,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"defid_for_inlined_node\")\n     }\n \n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n+    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                        -> Mir<'tcx> { bug!(\"get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n@@ -412,8 +409,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n-                           reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>) -> Vec<u8> { vec![] }\n+                           reachable: &NodeSet) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n "}, {"sha": "56355941b57063d0d4a22f39a53b21913d774486", "filename": "src/librustc/mir/mir_map.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/36340ba994a8e5b12df70f0889eeb7d58e2705fe/src%2Flibrustc%2Fmir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36340ba994a8e5b12df70f0889eeb7d58e2705fe/src%2Flibrustc%2Fmir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmir_map.rs?ref=36340ba994a8e5b12df70f0889eeb7d58e2705fe", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n-use hir::def_id::DefId;\n-use mir::Mir;\n-use std::marker::PhantomData;\n-\n-pub struct MirMap<'tcx> {\n-    pub map: DepTrackingMap<MirMapConfig<'tcx>>,\n-}\n-\n-impl<'tcx> MirMap<'tcx> {\n-    pub fn new(graph: DepGraph) -> Self {\n-        MirMap {\n-            map: DepTrackingMap::new(graph)\n-        }\n-    }\n-}\n-\n-pub struct MirMapConfig<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for MirMapConfig<'tcx> {\n-    type Key = DefId;\n-    type Value = Mir<'tcx>;\n-    fn to_dep_node(key: &DefId) -> DepNode<DefId> {\n-        DepNode::Mir(*key)\n-    }\n-}"}, {"sha": "994316d05ec78c99c6d95294660f3d758b1894dd", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -37,7 +37,6 @@ pub mod tcx;\n pub mod visit;\n pub mod transform;\n pub mod traversal;\n-pub mod mir_map;\n \n macro_rules! newtype_index {\n     ($name:ident, $debug_name:expr) => ("}, {"sha": "3576ae662a005033e1a5f200327b9d03228dfa75", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -11,7 +11,6 @@\n use dep_graph::DepNode;\n use hir;\n use hir::map::DefPathData;\n-use mir::mir_map::MirMap;\n use mir::{Mir, Promoted};\n use ty::TyCtxt;\n use syntax::ast::NodeId;\n@@ -85,12 +84,11 @@ pub trait Pass {\n     fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> { None }\n }\n \n-/// A pass which inspects the whole MirMap.\n+/// A pass which inspects the whole Mir map.\n pub trait MirMapPass<'tcx>: Pass {\n     fn run_pass<'a>(\n         &mut self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        map: &mut MirMap<'tcx>,\n         hooks: &mut [Box<for<'s> MirPassHook<'s>>]);\n }\n \n@@ -114,13 +112,18 @@ pub trait MirPass<'tcx>: Pass {\n impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n     fn run_pass<'a>(&mut self,\n                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    map: &mut MirMap<'tcx>,\n                     hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n     {\n-        let def_ids = map.map.keys();\n+        let def_ids = tcx.mir_map.borrow().keys();\n         for def_id in def_ids {\n+            if !def_id.is_local() {\n+                continue;\n+            }\n+\n             let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mir = map.map.get_mut(&def_id).unwrap();\n+            let mir = &mut tcx.mir_map.borrow()[&def_id].borrow_mut();\n+            tcx.dep_graph.write(DepNode::Mir(def_id));\n+\n             let id = tcx.map.as_local_node_id(def_id).unwrap();\n             let src = MirSource::from_node(tcx, id);\n \n@@ -163,11 +166,11 @@ impl<'a, 'tcx> Passes {\n         passes\n     }\n \n-    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n+    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let Passes { ref mut passes, ref mut plugin_passes, ref mut pass_hooks } = *self;\n         for pass in plugin_passes.iter_mut().chain(passes.iter_mut()) {\n             time(tcx.sess.time_passes(), &*pass.name(),\n-                 || pass.run_pass(tcx, map, pass_hooks));\n+                 || pass.run_pass(tcx, pass_hooks));\n         }\n     }\n "}, {"sha": "62cc78141db468847f0cd70c59b390addb611e62", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -22,6 +22,7 @@ use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n use middle::stability;\n+use mir::Mir;\n use ty::subst::{Kind, Substs};\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n@@ -65,8 +66,9 @@ pub struct CtxtArenas<'tcx> {\n \n     // references\n     generics: TypedArena<ty::Generics<'tcx>>,\n-    trait_defs: TypedArena<ty::TraitDef<'tcx>>,\n-    adt_defs: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n+    trait_def: TypedArena<ty::TraitDef<'tcx>>,\n+    adt_def: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n+    mir: TypedArena<RefCell<Mir<'tcx>>>,\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -81,8 +83,9 @@ impl<'tcx> CtxtArenas<'tcx> {\n             layout: TypedArena::new(),\n \n             generics: TypedArena::new(),\n-            trait_defs: TypedArena::new(),\n-            adt_defs: TypedArena::new()\n+            trait_def: TypedArena::new(),\n+            adt_def: TypedArena::new(),\n+            mir: TypedArena::new()\n         }\n     }\n }\n@@ -358,6 +361,15 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub map: ast_map::Map<'tcx>,\n \n+    /// Maps from the def-id of a function/method or const/static\n+    /// to its MIR. Mutation is done at an item granularity to\n+    /// allow MIR optimization passes to function and still\n+    /// access cross-crate MIR (e.g. inlining or const eval).\n+    ///\n+    /// Note that cross-crate MIR appears to be always borrowed\n+    /// (in the `RefCell` sense) to prevent accidental mutation.\n+    pub mir_map: RefCell<DepTrackingMap<maps::Mir<'tcx>>>,\n+\n     // Records the free variables refrenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n@@ -604,6 +616,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_interners.arenas.generics.alloc(generics)\n     }\n \n+    pub fn alloc_mir(self, mir: Mir<'gcx>) -> &'gcx RefCell<Mir<'gcx>> {\n+        self.global_interners.arenas.mir.alloc(RefCell::new(mir))\n+    }\n+\n     pub fn intern_trait_def(self, def: ty::TraitDef<'gcx>)\n                             -> &'gcx ty::TraitDef<'gcx> {\n         let did = def.trait_ref.def_id;\n@@ -617,7 +633,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn alloc_trait_def(self, def: ty::TraitDef<'gcx>)\n                            -> &'gcx ty::TraitDef<'gcx> {\n-        self.global_interners.arenas.trait_defs.alloc(def)\n+        self.global_interners.arenas.trait_def.alloc(def)\n     }\n \n     pub fn insert_adt_def(self, did: DefId, adt_def: ty::AdtDefMaster<'gcx>) {\n@@ -633,7 +649,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                           variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n                           -> ty::AdtDefMaster<'gcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n-        let interned = self.global_interners.arenas.adt_defs.alloc(def);\n+        let interned = self.global_interners.arenas.adt_def.alloc(def);\n         self.insert_adt_def(did, interned);\n         interned\n     }\n@@ -738,6 +754,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             map: map,\n+            mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             freevars: RefCell::new(freevars),\n             maybe_unused_trait_imports: maybe_unused_trait_imports,\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),"}, {"sha": "cad87081a93b4a59e3dc63bab26fe8552a6bc0ac", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -10,7 +10,10 @@\n \n use dep_graph::{DepNode, DepTrackingMapConfig};\n use hir::def_id::DefId;\n+use mir;\n use ty::{self, Ty};\n+\n+use std::cell::RefCell;\n use std::marker::PhantomData;\n use std::rc::Rc;\n use syntax::{attr, ast};\n@@ -43,3 +46,4 @@ dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n dep_map_ty! { InlinedClosures: Hir(DefId) -> ast::NodeId }\n+dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }"}, {"sha": "588857e557c22fce71271141a104d135918afb1e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -24,6 +24,7 @@ use hir::def::{Def, CtorKind, PathResolution, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n+use mir::Mir;\n use traits;\n use ty;\n use ty::subst::{Subst, Substs};\n@@ -34,7 +35,7 @@ use util::nodemap::FnvHashMap;\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n use std::iter;\n use std::ops::Deref;\n@@ -2519,6 +2520,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n     }\n \n+    /// Given the did of an item, returns its MIR, borrowed immutably.\n+    pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n+        lookup_locally_or_in_crate_store(\"mir_map\", did, &self.mir_map, || {\n+            let mir = self.sess.cstore.get_item_mir(self.global_tcx(), did);\n+            let mir = self.alloc_mir(mir);\n+\n+            // Perma-borrow MIR from extern crates to prevent mutation.\n+            mem::forget(mir.borrow());\n+\n+            mir\n+        }).borrow()\n+    }\n+\n     /// If `type_needs_drop` returns true, then `ty` is definitely\n     /// non-copy and *might* have a destructor attached; if it returns\n     /// false, then `ty` definitely has no destructor (i.e. no drop glue)."}, {"sha": "cea9170da9ffd86265f8016ee13c57735aff5a69", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -55,15 +55,13 @@ pub struct MoveDataParamEnv<'tcx> {\n     param_env: ty::ParameterEnvironment<'tcx>,\n }\n \n-pub fn borrowck_mir<'a, 'tcx: 'a>(\n-    bcx: &mut BorrowckCtxt<'a, 'tcx>,\n-    fk: FnKind,\n-    _decl: &hir::FnDecl,\n-    mir: &'a Mir<'tcx>,\n-    body: &hir::Block,\n-    _sp: Span,\n-    id: ast::NodeId,\n-    attributes: &[ast::Attribute]) {\n+pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n+                    fk: FnKind,\n+                    _decl: &hir::FnDecl,\n+                    body: &hir::Block,\n+                    _sp: Span,\n+                    id: ast::NodeId,\n+                    attributes: &[ast::Attribute]) {\n     match fk {\n         FnKind::ItemFn(name, ..) |\n         FnKind::Method(name, ..) => {\n@@ -75,8 +73,10 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n     }\n \n     let tcx = bcx.tcx;\n-\n     let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+\n+    let mir = &tcx.item_mir(tcx.map.local_def_id(id));\n+\n     let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n     let flow_inits =\n@@ -170,8 +170,8 @@ pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n     mir: &'b Mir<'tcx>,\n     node_id: ast::NodeId,\n     move_data: MoveData<'tcx>,\n-    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n-    flow_uninits: DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>\n+    flow_inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n+    flow_uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>\n }\n \n impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {"}, {"sha": "ef6936b6e7db3184894abb60cf72d047cb1ee46f", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -51,8 +51,6 @@ use rustc::hir::{FnDecl, Block};\n use rustc::hir::intravisit;\n use rustc::hir::intravisit::{Visitor, FnKind};\n \n-use rustc::mir::mir_map::MirMap;\n-\n pub mod check_loans;\n \n pub mod gather_loans;\n@@ -102,10 +100,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &MirMap<'tcx>) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        mir_map: Some(mir_map),\n         free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n@@ -168,12 +165,9 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n \n-    let def_id = this.tcx.map.local_def_id(id);\n-\n     if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n-        let mir = this.mir_map.unwrap().map.get(&def_id).unwrap();\n         this.with_temp_region_map(id, |this| {\n-            mir::borrowck_mir(this, fk, decl, mir, body, sp, id, attributes)\n+            mir::borrowck_mir(this, fk, decl, body, sp, id, attributes)\n         });\n     }\n \n@@ -249,15 +243,13 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir_map: Option<&'a MirMap<'tcx>>,\n     fn_parts: FnParts<'a>,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        mir_map: mir_map,\n         free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n@@ -297,10 +289,7 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     free_region_map: FreeRegionMap,\n \n     // Statistics:\n-    stats: BorrowStats,\n-\n-    // NodeId to MIR mapping (for methods that carry the #[rustc_mir] attribute).\n-    mir_map: Option<&'a MirMap<'tcx>>,\n+    stats: BorrowStats\n }\n \n #[derive(Clone)]"}, {"sha": "5a7fc0bdb966ed3b2b4e147b35c7eb8ac7310576", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -13,7 +13,6 @@ use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n use rustc::hir::def::DefMap;\n use rustc::hir::lowering::lower_crate;\n use rustc_mir as mir;\n-use rustc::mir::mir_map::MirMap;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n use rustc::session::config::{self, Input, OutputFilenames, OutputType,\n                              OutputTypes};\n@@ -175,7 +174,7 @@ pub fn compile_input(sess: &Session,\n                                     resolutions,\n                                     &arenas,\n                                     &crate_name,\n-                                    |tcx, mir_map, analysis, incremental_hashes_map, result| {\n+                                    |tcx, analysis, incremental_hashes_map, result| {\n             {\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n@@ -187,7 +186,6 @@ pub fn compile_input(sess: &Session,\n                                                                    opt_crate,\n                                                                    tcx.map.krate(),\n                                                                    &analysis,\n-                                                                   mir_map.as_ref(),\n                                                                    tcx,\n                                                                    &crate_name);\n                 (control.after_analysis.callback)(&mut state);\n@@ -203,10 +201,7 @@ pub fn compile_input(sess: &Session,\n                 println!(\"Pre-trans\");\n                 tcx.print_debug_stats();\n             }\n-            let trans = phase_4_translate_to_llvm(tcx,\n-                                                  mir_map.unwrap(),\n-                                                  analysis,\n-                                                  &incremental_hashes_map);\n+            let trans = phase_4_translate_to_llvm(tcx, analysis, &incremental_hashes_map);\n \n             if log_enabled!(::log::INFO) {\n                 println!(\"Post-trans\");\n@@ -348,7 +343,6 @@ pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n     pub hir_crate: Option<&'a hir::Crate>,\n     pub ast_map: Option<&'a hir_map::Map<'ast>>,\n     pub resolutions: Option<&'a Resolutions>,\n-    pub mir_map: Option<&'b MirMap<'tcx>>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n     pub tcx: Option<TyCtxt<'b, 'tcx, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n@@ -375,7 +369,6 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n             ast_map: None,\n             resolutions: None,\n             analysis: None,\n-            mir_map: None,\n             tcx: None,\n             trans: None,\n         }\n@@ -449,13 +442,11 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis<'a>,\n-                            mir_map: Option<&'b MirMap<'tcx>>,\n                             tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                             crate_name: &'a str)\n                             -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n-            mir_map: mir_map,\n             tcx: Some(tcx),\n             expanded_crate: krate,\n             hir_crate: Some(hir_crate),\n@@ -812,17 +803,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n-                            Option<MirMap<'tcx>>,\n                             ty::CrateAnalysis,\n                             IncrementalHashesMap,\n                             CompileResult) -> R\n {\n     macro_rules! try_with_f {\n-        ($e: expr, ($t: expr, $m: expr, $a: expr, $h: expr)) => {\n+        ($e: expr, ($t: expr, $a: expr, $h: expr)) => {\n             match $e {\n                 Ok(x) => x,\n                 Err(x) => {\n-                    f($t, $m, $a, $h, Err(x));\n+                    f($t, $a, $h, Err(x));\n                     return Err(x);\n                 }\n             }\n@@ -888,7 +878,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n \n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx), (tcx, None, analysis, incremental_hashes_map));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n \n         time(time_passes,\n              \"const checking\",\n@@ -928,28 +918,28 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"rvalue checking\",\n              || rvalues::check_crate(tcx));\n \n-        let mut mir_map =\n-            time(time_passes,\n-                 \"MIR dump\",\n-                 || mir::mir_map::build_mir_for_crate(tcx));\n+        time(time_passes,\n+             \"MIR dump\",\n+             || mir::mir_map::build_mir_for_crate(tcx));\n \n         time(time_passes, \"MIR passes\", || {\n             let mut passes = sess.mir_passes.borrow_mut();\n             // Push all the built-in passes.\n             passes.push_hook(box mir::transform::dump_mir::DumpMir);\n             passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"initial\"));\n-            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n+            passes.push_pass(\n+                box mir::transform::qualify_consts::QualifyAndPromoteConstants::default());\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n             passes.push_pass(\n                 box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n             passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"qualify-consts\"));\n             // And run everything.\n-            passes.run_passes(tcx, &mut mir_map);\n+            passes.run_passes(tcx);\n         });\n \n         time(time_passes,\n              \"borrow checking\",\n-             || borrowck::check_crate(tcx, &mir_map));\n+             || borrowck::check_crate(tcx));\n \n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids\n@@ -958,11 +948,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx,\n-                        Some(mir_map),\n-                        analysis,\n-                        incremental_hashes_map,\n-                        Err(sess.err_count())));\n+            return Ok(f(tcx, analysis, incremental_hashes_map, Err(sess.err_count())));\n         }\n \n         analysis.reachable =\n@@ -990,20 +976,15 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         // The above three passes generate errors w/o aborting\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx,\n-                        Some(mir_map),\n-                        analysis,\n-                        incremental_hashes_map,\n-                        Err(sess.err_count())));\n+            return Ok(f(tcx, analysis, incremental_hashes_map, Err(sess.err_count())));\n         }\n \n-        Ok(f(tcx, Some(mir_map), analysis, incremental_hashes_map, Ok(())))\n+        Ok(f(tcx, analysis, incremental_hashes_map, Ok(())))\n     })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           mut mir_map: MirMap<'tcx>,\n                                            analysis: ty::CrateAnalysis,\n                                            incremental_hashes_map: &IncrementalHashesMap)\n                                            -> trans::CrateTranslation {\n@@ -1037,13 +1018,13 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));\n \n-        passes.run_passes(tcx, &mut mir_map);\n+        passes.run_passes(tcx);\n     });\n \n     let translation =\n         time(time_passes,\n              \"translation\",\n-             move || trans::trans_crate(tcx, &mir_map, analysis, &incremental_hashes_map));\n+             move || trans::trans_crate(tcx, analysis, &incremental_hashes_map));\n \n     time(time_passes,\n          \"assert dep graph\","}, {"sha": "10ff7dc89f9a33e5ddf38ac5ff728afb4e34fa23", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -52,8 +52,6 @@ use rustc::hir::map::{blocks, NodePrinter};\n use rustc::hir;\n use rustc::hir::print as pprust_hir;\n \n-use rustc::mir::mir_map::MirMap;\n-\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n     PpmNormal,\n@@ -234,7 +232,7 @@ impl PpSourceMode {\n                                                                  resolutions.clone(),\n                                                                  arenas,\n                                                                  id,\n-                                                                 |tcx, _, _, _, _| {\n+                                                                 |tcx, _, _, _| {\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n                     };\n@@ -695,7 +693,6 @@ impl fold::Folder for ReplaceBodyWithLoop {\n \n fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       mir_map: Option<&MirMap<'tcx>>,\n                                        code: blocks::Code,\n                                        mode: PpFlowGraphMode,\n                                        mut out: W)\n@@ -725,7 +722,6 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n         blocks::FnLikeCode(fn_like) => {\n             let (bccx, analysis_data) =\n                 borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n-                                                              mir_map,\n                                                               fn_like.to_fn_parts(),\n                                                               &cfg);\n \n@@ -952,32 +948,28 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                      resolutions.clone(),\n                                                      arenas,\n                                                      crate_name,\n-                                                     |tcx, mir_map, _, _, _| {\n+                                                     |tcx, _, _, _| {\n         match ppm {\n             PpmMir | PpmMirCFG => {\n-                if let Some(mir_map) = mir_map {\n-                    if let Some(nodeid) = nodeid {\n-                        let def_id = tcx.map.local_def_id(nodeid);\n-                        match ppm {\n-                            PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mir_map, &mut out),\n-                            PpmMirCFG => {\n-                                write_mir_graphviz(tcx, iter::once(def_id), &mir_map, &mut out)\n-                            }\n-                            _ => unreachable!(),\n-                        }?;\n-                    } else {\n-                        match ppm {\n-                            PpmMir => write_mir_pretty(tcx,\n-                                                       mir_map.map.keys().into_iter(),\n-                                                       &mir_map,\n-                                                       &mut out),\n-                            PpmMirCFG => write_mir_graphviz(tcx,\n-                                                            mir_map.map.keys().into_iter(),\n-                                                            &mir_map,\n-                                                            &mut out),\n-                            _ => unreachable!(),\n-                        }?;\n-                    }\n+                if let Some(nodeid) = nodeid {\n+                    let def_id = tcx.map.local_def_id(nodeid);\n+                    match ppm {\n+                        PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mut out),\n+                        PpmMirCFG => {\n+                            write_mir_graphviz(tcx, iter::once(def_id), &mut out)\n+                        }\n+                        _ => unreachable!(),\n+                    }?;\n+                } else {\n+                    match ppm {\n+                        PpmMir => write_mir_pretty(tcx,\n+                                                   tcx.mir_map.borrow().keys().into_iter(),\n+                                                   &mut out),\n+                        PpmMirCFG => write_mir_graphviz(tcx,\n+                                                        tcx.mir_map.borrow().keys().into_iter(),\n+                                                        &mut out),\n+                        _ => unreachable!(),\n+                    }?;\n                 }\n                 Ok(())\n             }\n@@ -995,12 +987,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n \n                         let out: &mut Write = &mut out;\n \n-                        print_flowgraph(variants,\n-                                        tcx,\n-                                        mir_map.as_ref(),\n-                                        code,\n-                                        mode,\n-                                        out)\n+                        print_flowgraph(variants, tcx, code, mode, out)\n                     }\n                     None => {\n                         let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\"}, {"sha": "13ffc04a89879511d656f034ffeb1a75c731a093", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -24,7 +24,6 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::DefKey;\n use rustc::mir::Mir;\n-use rustc::mir::mir_map::MirMap;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n@@ -467,10 +466,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.defid_for_inlined_node.borrow().get(&node_id).map(|x| *x)\n     }\n \n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<Mir<'tcx>> {\n+    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).maybe_get_item_mir(tcx, def.index)\n+        self.get_crate_data(def.krate).maybe_get_item_mir(tcx, def.index).unwrap_or_else(|| {\n+            bug!(\"get_item_mir: missing MIR for {}\", tcx.item_path_str(def))\n+        })\n     }\n \n     fn is_item_mir_available(&self, def: DefId) -> bool {\n@@ -523,10 +523,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n-                           reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>) -> Vec<u8>\n+                           reachable: &NodeSet) -> Vec<u8>\n     {\n-        encoder::encode_metadata(tcx, self, reexports, link_meta, reachable, mir_map)\n+        encoder::encode_metadata(tcx, self, reexports, link_meta, reachable)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]"}, {"sha": "e8734e4275712411cb2894021fcec54a2be3cd79", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -22,7 +22,6 @@ use rustc::mir;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n \n-use rustc::mir::mir_map::MirMap;\n use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n@@ -51,7 +50,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     link_meta: &'a LinkMeta,\n     cstore: &'a cstore::CStore,\n     reachable: &'a NodeSet,\n-    mir_map: &'a MirMap<'tcx>,\n \n     lazy_state: LazyState,\n     type_shorthands: FnvHashMap<Ty<'tcx>, usize>,\n@@ -606,7 +604,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n-        self.mir_map.map.get(&def_id).map(|mir| self.lazy(mir))\n+        self.tcx.mir_map.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n@@ -1346,8 +1344,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  cstore: &cstore::CStore,\n                                  reexports: &def::ExportMap,\n                                  link_meta: &LinkMeta,\n-                                 reachable: &NodeSet,\n-                                 mir_map: &MirMap<'tcx>)\n+                                 reachable: &NodeSet)\n                                  -> Vec<u8> {\n     let mut cursor = Cursor::new(vec![]);\n     cursor.write_all(METADATA_HEADER).unwrap();\n@@ -1362,7 +1359,6 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             link_meta: link_meta,\n             cstore: cstore,\n             reachable: reachable,\n-            mir_map: mir_map,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),"}, {"sha": "dd4dd4699d858f95a0a546a33c5fcdcbaade1881", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -11,7 +11,6 @@\n use dot;\n use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n-use rustc::mir::mir_map::MirMap;\n use rustc::ty::TyCtxt;\n use std::fmt::Debug;\n use std::io::{self, Write};\n@@ -22,14 +21,13 @@ use rustc_data_structures::indexed_vec::Idx;\n /// Write a graphviz DOT graph of a list of MIRs.\n pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                               iter: I,\n-                                              mir_map: &MirMap<'tcx>,\n                                               w: &mut W)\n                                               -> io::Result<()>\n     where W: Write, I: Iterator<Item=DefId>\n {\n     for def_id in iter {\n         let nodeid = tcx.map.as_local_node_id(def_id).unwrap();\n-        let mir = &mir_map.map[&def_id];\n+        let mir = &tcx.item_mir(def_id);\n \n         writeln!(w, \"digraph Mir_{} {{\", nodeid)?;\n "}, {"sha": "b0e2d6e73d37aa0c3f19d7da16f893a2a4c47bef", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -25,7 +25,6 @@ use rustc::mir::visit::MutVisitor;\n use pretty;\n use hair::cx::Cx;\n \n-use rustc::mir::mir_map::MirMap;\n use rustc::infer::InferCtxtBuilder;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -37,16 +36,10 @@ use syntax_pos::Span;\n \n use std::mem;\n \n-pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MirMap<'tcx> {\n-    let mut map = MirMap::new(tcx.dep_graph.clone());\n-    {\n-        let mut dump = BuildMir {\n-            tcx: tcx,\n-            map: &mut map,\n-        };\n-        tcx.visit_all_items_in_krate(DepNode::Mir, &mut dump);\n-    }\n-    map\n+pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.visit_all_items_in_krate(DepNode::Mir, &mut BuildMir {\n+        tcx: tcx\n+    });\n }\n \n /// A pass to lift all the types and substitutions in a Mir\n@@ -83,8 +76,7 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n struct BuildMir<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    map: &'a mut MirMap<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n /// Helper type of a temporary returned by BuildMir::cx(...).\n@@ -93,8 +85,7 @@ struct BuildMir<'a, 'tcx: 'a> {\n struct CxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     src: MirSource,\n     def_id: DefId,\n-    infcx: InferCtxtBuilder<'a, 'gcx, 'tcx>,\n-    map: &'a mut MirMap<'gcx>,\n+    infcx: InferCtxtBuilder<'a, 'gcx, 'tcx>\n }\n \n impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n@@ -104,8 +95,7 @@ impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n         CxBuilder {\n             src: src,\n             infcx: self.tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable),\n-            def_id: def_id,\n-            map: self.map\n+            def_id: def_id\n         }\n     }\n }\n@@ -114,27 +104,26 @@ impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n     fn build<F>(&'tcx mut self, f: F)\n         where F: for<'b> FnOnce(Cx<'b, 'gcx, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n     {\n-        let src = self.src;\n-        let mir = self.infcx.enter(|infcx| {\n+        let (src, def_id) = (self.src, self.def_id);\n+        self.infcx.enter(|infcx| {\n             let (mut mir, scope_auxiliary) = f(Cx::new(&infcx, src));\n \n             // Convert the Mir to global types.\n+            let tcx = infcx.tcx.global_tcx();\n             let mut globalizer = GlobalizeMir {\n-                tcx: infcx.tcx.global_tcx(),\n+                tcx: tcx,\n                 span: mir.span\n             };\n             globalizer.visit_mir(&mut mir);\n             let mir = unsafe {\n                 mem::transmute::<Mir, Mir<'gcx>>(mir)\n             };\n \n-            pretty::dump_mir(infcx.tcx.global_tcx(), \"mir_map\", &0,\n-                             src, &mir, Some(&scope_auxiliary));\n+            pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n \n-            mir\n+            let mir = tcx.alloc_mir(mir);\n+            assert!(tcx.mir_map.borrow_mut().insert(def_id, mir).is_none());\n         });\n-\n-        assert!(self.map.map.insert(self.def_id, mir).is_none())\n     }\n }\n "}, {"sha": "d2fc8aeaa2eea743b2497e2da46a0e68bb0909fe", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -12,7 +12,6 @@ use build::{ScopeAuxiliaryVec, ScopeId};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n-use rustc::mir::mir_map::MirMap;\n use rustc::mir::transform::MirSource;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n@@ -90,14 +89,13 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Write out a human-readable textual representation for the given MIR.\n pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                          iter: I,\n-                                         mir_map: &MirMap<'tcx>,\n                                          w: &mut Write)\n                                          -> io::Result<()>\n     where I: Iterator<Item=DefId>, 'tcx: 'a\n {\n     let mut first = true;\n     for def_id in iter {\n-        let mir = &mir_map.map[&def_id];\n+        let mir = &tcx.item_mir(def_id);\n \n         if first {\n             first = false;"}, {"sha": "b33a7060e37537df665b2fca2c26d30a74537ba3", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 74, "deletions": 105, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -16,7 +16,6 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n@@ -26,9 +25,8 @@ use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::cast::CastTy;\n use rustc::mir::*;\n-use rustc::mir::mir_map::MirMap;\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::mir::transform::{Pass, MirMapPass, MirPassHook, MirSource};\n+use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::util::nodemap::DefIdMap;\n use syntax::abi::Abi;\n@@ -142,7 +140,6 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParameterEnvironment<'tcx>,\n     qualif_map: &'a mut DefIdMap<Qualif>,\n-    mir_map: Option<&'a MirMap<'tcx>>,\n     temp_qualif: IndexVec<Local, Option<Qualif>>,\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n@@ -155,7 +152,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            param_env: ty::ParameterEnvironment<'tcx>,\n            qualif_map: &'a mut DefIdMap<Qualif>,\n-           mir_map: Option<&'a MirMap<'tcx>>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n@@ -172,7 +168,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             tcx: tcx,\n             param_env: param_env,\n             qualif_map: qualif_map,\n-            mir_map: mir_map,\n             temp_qualif: IndexVec::from_elem(None, &mir.local_decls),\n             return_qualif: None,\n             qualif: Qualif::empty(),\n@@ -595,7 +590,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     } else {\n                         let qualif = qualify_const_item_cached(self.tcx,\n                                                                self.qualif_map,\n-                                                               self.mir_map,\n                                                                def_id);\n                         self.add(qualif);\n                     }\n@@ -949,7 +943,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        qualif_map: &mut DefIdMap<Qualif>,\n-                                       mir_map: Option<&MirMap<'tcx>>,\n                                        def_id: DefId)\n                                        -> Qualif {\n     match qualif_map.entry(def_id) {\n@@ -960,124 +953,100 @@ fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let extern_mir;\n-    let param_env_and_mir = if def_id.is_local() {\n-        mir_map.and_then(|map| map.map.get(&def_id)).map(|mir| {\n-            let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n-            (ty::ParameterEnvironment::for_item(tcx, node_id), mir)\n-        })\n-    } else if let Some(mir) = tcx.sess.cstore.maybe_get_item_mir(tcx, def_id) {\n-        // These should only be monomorphic constants.\n-        extern_mir = mir;\n-        Some((tcx.empty_parameter_environment(), &extern_mir))\n+    let param_env = if def_id.is_local() {\n+        let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n+        ty::ParameterEnvironment::for_item(tcx, node_id)\n     } else {\n-        None\n+        // These should only be monomorphic constants.\n+        tcx.empty_parameter_environment()\n     };\n \n-    let (param_env, mir) = param_env_and_mir.unwrap_or_else(|| {\n-        bug!(\"missing constant MIR for {}\", tcx.item_path_str(def_id))\n-    });\n-\n-    let mut qualifier = Qualifier::new(tcx, param_env, qualif_map, mir_map,\n-                                       def_id, mir, Mode::Const);\n+    let mir = &tcx.item_mir(def_id);\n+    let mut qualifier = Qualifier::new(tcx, param_env, qualif_map, def_id, mir, Mode::Const);\n     let qualif = qualifier.qualify_const();\n     qualifier.qualif_map.insert(def_id, qualif);\n     qualif\n }\n \n-pub struct QualifyAndPromoteConstants;\n+#[derive(Default)]\n+pub struct QualifyAndPromoteConstants {\n+    qualif_map: DefIdMap<Qualif>\n+}\n \n impl Pass for QualifyAndPromoteConstants {}\n \n-impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    map: &mut MirMap<'tcx>,\n-                    hooks: &mut [Box<for<'s> MirPassHook<'s>>]) {\n-        let mut qualif_map = DefIdMap();\n-\n-        // First, visit `const` items, potentially recursing, to get\n-        // accurate MUTABLE_INTERIOR and NEEDS_DROP qualifications.\n-        let keys = map.map.keys();\n-        for &def_id in &keys {\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let id = tcx.map.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-            if let MirSource::Const(_) = src {\n-                qualify_const_item_cached(tcx, &mut qualif_map, Some(map), def_id);\n+impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>) {\n+        let id = src.item_id();\n+        let def_id = tcx.map.local_def_id(id);\n+        let mode = match src {\n+            MirSource::Fn(_) => {\n+                if is_const_fn(tcx, def_id) {\n+                    Mode::ConstFn\n+                } else {\n+                    Mode::Fn\n+                }\n             }\n-        }\n-\n-        // Then, handle everything else, without recursing,\n-        // as the MIR map is not shared, since promotion\n-        // in functions (including `const fn`) mutates it.\n-        for &def_id in &keys {\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let id = tcx.map.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-            let mode = match src {\n-                MirSource::Fn(_) => {\n-                    if is_const_fn(tcx, def_id) {\n-                        Mode::ConstFn\n-                    } else {\n-                        Mode::Fn\n+            MirSource::Const(_) => {\n+                match self.qualif_map.entry(def_id) {\n+                    Entry::Occupied(_) => return,\n+                    Entry::Vacant(entry) => {\n+                        // Guard against `const` recursion.\n+                        entry.insert(Qualif::RECURSIVE);\n                     }\n                 }\n-                MirSource::Const(_) => continue,\n-                MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n-                MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n-                MirSource::Promoted(..) => bug!()\n-            };\n-            let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n-\n-            let mir = map.map.get_mut(&def_id).unwrap();\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, false);\n+                Mode::Const\n             }\n-\n-            if mode == Mode::Fn || mode == Mode::ConstFn {\n-                // This is ugly because Qualifier holds onto mir,\n-                // which can't be mutated until its scope ends.\n-                let (temps, candidates) = {\n-                    let mut qualifier = Qualifier::new(tcx, param_env, &mut qualif_map,\n-                                                       None, def_id, mir, mode);\n-                    if mode == Mode::ConstFn {\n-                        // Enforce a constant-like CFG for `const fn`.\n-                        qualifier.qualify_const();\n-                    } else {\n-                        while let Some((bb, data)) = qualifier.rpo.next() {\n-                            qualifier.visit_basic_block_data(bb, data);\n-                        }\n+            MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n+            MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n+            MirSource::Promoted(..) => return\n+        };\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+\n+        if mode == Mode::Fn || mode == Mode::ConstFn {\n+            // This is ugly because Qualifier holds onto mir,\n+            // which can't be mutated until its scope ends.\n+            let (temps, candidates) = {\n+                let mut qualifier = Qualifier::new(tcx, param_env,\n+                                                   &mut self.qualif_map,\n+                                                   def_id, mir, mode);\n+                if mode == Mode::ConstFn {\n+                    // Enforce a constant-like CFG for `const fn`.\n+                    qualifier.qualify_const();\n+                } else {\n+                    while let Some((bb, data)) = qualifier.rpo.next() {\n+                        qualifier.visit_basic_block_data(bb, data);\n                     }\n+                }\n \n-                    (qualifier.temp_promotion_state,\n-                     qualifier.promotion_candidates)\n-                };\n+                (qualifier.temp_promotion_state, qualifier.promotion_candidates)\n+            };\n \n-                // Do the actual promotion, now that we know what's viable.\n-                promote_consts::promote_candidates(mir, tcx, temps, candidates);\n-            } else {\n-                let mut qualifier = Qualifier::new(tcx, param_env, &mut qualif_map,\n-                                                   None, def_id, mir, mode);\n-                qualifier.qualify_const();\n-            }\n+            // Do the actual promotion, now that we know what's viable.\n+            promote_consts::promote_candidates(mir, tcx, temps, candidates);\n+        } else {\n+            let mut qualifier = Qualifier::new(tcx, param_env,\n+                                               &mut self.qualif_map,\n+                                               def_id, mir, mode);\n+            let qualif = qualifier.qualify_const();\n \n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, true);\n+            if mode == Mode::Const {\n+                qualifier.qualif_map.insert(def_id, qualif);\n             }\n+        }\n \n-            // Statics must be Sync.\n-            if mode == Mode::Static {\n-                let ty = mir.return_ty;\n-                tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n-                    let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n-                    let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                    fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-                    if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-                        infcx.report_fulfillment_errors(&err);\n-                    }\n-                });\n-            }\n+        // Statics must be Sync.\n+        if mode == Mode::Static {\n+            let ty = mir.return_ty;\n+            tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+                let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n+                let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+                if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n+                    infcx.report_fulfillment_errors(&err);\n+                }\n+            });\n         }\n     }\n }"}, {"sha": "14b2a2f55afb6c8a3c83aa4fd97e5329b5eb9209", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -44,7 +44,6 @@ use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n-use rustc::mir::mir_map::MirMap;\n use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n use session::Session;\n@@ -866,7 +865,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             false\n         };\n \n-        let mir = def_id.and_then(|id| ccx.get_mir(id));\n+        let mir = def_id.map(|id| ccx.tcx().item_mir(id));\n \n         let debug_context = if let (false, Some((instance, sig, abi)), &Some(ref mir)) =\n                 (no_debug, definition, &mir) {\n@@ -1278,8 +1277,7 @@ fn write_metadata(cx: &SharedCrateContext,\n     let metadata = cstore.encode_metadata(cx.tcx(),\n                                           cx.export_map(),\n                                           cx.link_meta(),\n-                                          reachable_ids,\n-                                          cx.mir_map());\n+                                          reachable_ids);\n     if kind == MetadataKind::Uncompressed {\n         return metadata;\n     }\n@@ -1527,7 +1525,6 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n }\n \n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             mir_map: &MirMap<'tcx>,\n                              analysis: ty::CrateAnalysis,\n                              incremental_hashes_map: &IncrementalHashesMap)\n                              -> CrateTranslation {\n@@ -1551,7 +1548,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let link_meta = link::build_link_meta(incremental_hashes_map, name);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n-                                             &mir_map,\n                                              export_map,\n                                              Sha256::new(),\n                                              link_meta.clone(),"}, {"sha": "8348da9f7b7bfe05cd49d19adcd9331e5620fb59", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -205,7 +205,6 @@ use rustc::mir::visit::Visitor as MirVisitor;\n use rustc_const_eval as const_eval;\n \n use syntax::abi::Abi;\n-use errors;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n@@ -346,8 +345,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             // Scan the MIR in order to find function calls, closures, and\n             // drop-glue\n-            let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(def_id),\n-                || format!(\"Could not find MIR for static: {:?}\", def_id));\n+            let mir = scx.tcx().item_mir(def_id);\n \n             let empty_substs = scx.empty_substs_for_def_id(def_id);\n             let visitor = MirNeighborCollector {\n@@ -367,8 +365,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             // Scan the MIR in order to find function calls, closures, and\n             // drop-glue\n-            let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(instance.def),\n-                || format!(\"Could not find MIR for function: {}\", instance));\n+            let mir = scx.tcx().item_mir(instance.def);\n \n             let visitor = MirNeighborCollector {\n                 scx: scx,\n@@ -451,11 +448,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *rvalue {\n             mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n                                                                ref substs), _) => {\n-                let mir = errors::expect(self.scx.sess().diagnostic(),\n-                                         self.scx.get_mir(def_id),\n-                                         || {\n-                    format!(\"Could not find MIR for closure: {:?}\", def_id)\n-                });\n+                let mir = self.scx.tcx().item_mir(def_id);\n \n                 let concrete_substs = monomorphize::apply_param_substs(self.scx,\n                                                                        self.param_substs,\n@@ -1248,8 +1241,7 @@ fn collect_const_item_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n {\n     // Scan the MIR in order to find function calls, closures, and\n     // drop-glue\n-    let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(def_id),\n-        || format!(\"Could not find MIR for const: {:?}\", def_id));\n+    let mir = scx.tcx().item_mir(def_id);\n \n     let visitor = MirNeighborCollector {\n         scx: scx,"}, {"sha": "464b261b08e05e81005b791346f6883fafd8eb82", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -19,6 +19,7 @@ use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n+use rustc::mir::Mir;\n use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n use rustc::ty::subst::Substs;\n@@ -32,7 +33,6 @@ use consts;\n use debuginfo::{self, DebugLoc};\n use declare;\n use machine;\n-use mir::CachedMir;\n use monomorphize;\n use type_::Type;\n use value::Value;\n@@ -46,7 +46,7 @@ use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ops::Deref;\n use std::ffi::CString;\n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref};\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -250,10 +250,8 @@ pub fn validate_substs(substs: &Substs) {\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n-    // The MIR for this function. At present, this is optional because\n-    // we only have MIR available for things that are local to the\n-    // crate.\n-    pub mir: Option<CachedMir<'a, 'tcx>>,\n+    // The MIR for this function.\n+    pub mir: Option<Ref<'tcx, Mir<'tcx>>>,\n \n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n@@ -313,8 +311,8 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    pub fn mir(&self) -> CachedMir<'a, 'tcx> {\n-        self.mir.clone().expect(\"fcx.mir was empty\")\n+    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n+        self.mir.as_ref().map(Ref::clone).expect(\"fcx.mir was empty\")\n     }\n \n     pub fn cleanup(&self) {\n@@ -490,7 +488,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.set_lpad_ref(lpad.map(|p| &*self.fcx().lpad_arena.alloc(p)))\n     }\n \n-    pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n+    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n         self.fcx.mir()\n     }\n \n@@ -609,7 +607,7 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         self.bcx.llbb\n     }\n \n-    pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n+    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n         self.bcx.mir()\n     }\n "}, {"sha": "42773a8cd2c442d8cfabf5be839b4833e8c1567b", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -15,15 +15,12 @@ use middle::cstore::LinkMeta;\n use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n-use rustc::mir::mir_map::MirMap;\n-use rustc::mir;\n use base;\n use builder::Builder;\n use common::BuilderRef_res;\n use debuginfo;\n use declare;\n use glue::DropGlueKind;\n-use mir::CachedMir;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n@@ -76,8 +73,6 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n-    mir_map: &'a MirMap<'tcx>,\n-    mir_cache: RefCell<DepTrackingMap<MirCache<'tcx>>>,\n \n     use_dll_storage_attrs: bool,\n \n@@ -184,19 +179,6 @@ impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     }\n }\n \n-// Cache for mir loaded from metadata\n-struct MirCache<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for MirCache<'tcx> {\n-    type Key = DefId;\n-    type Value = Rc<mir::Mir<'tcx>>;\n-    fn to_dep_node(key: &DefId) -> DepNode<DefId> {\n-        DepNode::Mir(*key)\n-    }\n-}\n-\n // # Global Cache\n \n pub struct ProjectionCache<'gcx> {\n@@ -453,7 +435,6 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-               mir_map: &'b MirMap<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n@@ -517,8 +498,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             link_meta: link_meta,\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n-            mir_map: mir_map,\n-            mir_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n             stats: Stats {\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n@@ -582,23 +561,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         self.use_dll_storage_attrs\n     }\n \n-    pub fn get_mir(&self, def_id: DefId) -> Option<CachedMir<'b, 'tcx>> {\n-        if def_id.is_local() {\n-            self.mir_map.map.get(&def_id).map(CachedMir::Ref)\n-        } else {\n-            if let Some(mir) = self.mir_cache.borrow().get(&def_id).cloned() {\n-                return Some(CachedMir::Owned(mir));\n-            }\n-\n-            let mir = self.sess().cstore.maybe_get_item_mir(self.tcx, def_id);\n-            let cached = mir.map(Rc::new);\n-            if let Some(ref mir) = cached {\n-                self.mir_cache.borrow_mut().insert(def_id, mir.clone());\n-            }\n-            cached.map(CachedMir::Owned)\n-        }\n-    }\n-\n     pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n         &self.translation_items\n     }\n@@ -617,10 +579,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.symbol_hasher\n     }\n \n-    pub fn mir_map(&self) -> &MirMap<'tcx> {\n-        &self.mir_map\n-    }\n-\n     pub fn metadata_symbol_name(&self) -> String {\n         format!(\"rust_metadata_{}_{}\",\n                 self.link_meta().crate_name,\n@@ -1008,10 +966,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    pub fn get_mir(&self, def_id: DefId) -> Option<CachedMir<'b, 'tcx>> {\n-        self.shared.get_mir(def_id)\n-    }\n-\n     pub fn symbol_map(&self) -> &SymbolMap<'tcx> {\n         &*self.local().symbol_map\n     }"}, {"sha": "e0c1a80be394d047f7b7b3e78044c7a3080ddfd4", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -45,7 +45,7 @@ impl MirDebugScope {\n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, MirDebugScope> {\n-    let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n+    let mir = fcx.mir();\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n         file_start_pos: BytePos(0),"}, {"sha": "07acc54962b877cbecd12d5dc14f33021e2647df", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -25,6 +25,7 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(cell_extras)]\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n #![feature(dotdot_in_tuple_patterns)]"}, {"sha": "3d0d889760943b5592867e5372bde94008bab7e8", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -261,9 +261,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             }\n         }\n \n-        let mir = ccx.get_mir(instance.def).unwrap_or_else(|| {\n-            bug!(\"missing constant MIR for {}\", instance)\n-        });\n+        let mir = ccx.tcx().item_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }\n "}, {"sha": "d2adf88c9168356fad72266a2088d87160b1b170", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -23,8 +23,7 @@ use type_of;\n use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::parse::token::keywords;\n \n-use std::ops::Deref;\n-use std::rc::Rc;\n+use std::cell::Ref;\n use std::iter;\n \n use basic_block::BasicBlock;\n@@ -39,25 +38,9 @@ use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n \n-#[derive(Clone)]\n-pub enum CachedMir<'mir, 'tcx: 'mir> {\n-    Ref(&'mir mir::Mir<'tcx>),\n-    Owned(Rc<mir::Mir<'tcx>>)\n-}\n-\n-impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n-    type Target = mir::Mir<'tcx>;\n-    fn deref(&self) -> &mir::Mir<'tcx> {\n-        match *self {\n-            CachedMir::Ref(r) => r,\n-            CachedMir::Owned(ref rc) => rc\n-        }\n-    }\n-}\n-\n /// Master context for translating MIR.\n pub struct MirContext<'bcx, 'tcx:'bcx> {\n-    mir: CachedMir<'bcx, 'tcx>,\n+    mir: Ref<'tcx, mir::Mir<'tcx>>,\n \n     /// Function context\n     fcx: &'bcx common::FunctionContext<'bcx, 'tcx>,\n@@ -223,7 +206,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let scopes = debuginfo::create_mir_scopes(fcx);\n \n     let mut mircx = MirContext {\n-        mir: mir.clone(),\n+        mir: Ref::clone(&mir),\n         fcx: fcx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,"}, {"sha": "2881ba53f725428068741d8e323b714bccca9d88", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34792b181ab6af0221c0fb35940b1cc5dc476e1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e34792b181ab6af0221c0fb35940b1cc5dc476e1", "patch": "@@ -189,7 +189,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                      resolutions,\n                                                      &arenas,\n                                                      &name,\n-                                                     |tcx, _, analysis, _, result| {\n+                                                     |tcx, analysis, _, result| {\n         if let Err(_) = result {\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }"}]}