{"sha": "a6af0272f7bf129a3063cdd7096f685fc58438e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YWYwMjcyZjdiZjEyOWEzMDYzY2RkNzA5NmY2ODVmYzU4NDM4ZTY=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-07-23T14:11:37Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-08-10T12:46:34Z"}, "message": "Move semantic logic into Semantics, fix missing tag for safe amp operator, using functional methods rather than clunky inline closure", "tree": {"sha": "8a7041a76beb5df60742ad16b6325938efd4b3da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a7041a76beb5df60742ad16b6325938efd4b3da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6af0272f7bf129a3063cdd7096f685fc58438e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6af0272f7bf129a3063cdd7096f685fc58438e6", "html_url": "https://github.com/rust-lang/rust/commit/a6af0272f7bf129a3063cdd7096f685fc58438e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6af0272f7bf129a3063cdd7096f685fc58438e6/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87cb09365cf841b559e76951eedb826f2d4d3dfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/87cb09365cf841b559e76951eedb826f2d4d3dfd", "html_url": "https://github.com/rust-lang/rust/commit/87cb09365cf841b559e76951eedb826f2d4d3dfd"}], "stats": {"total": 217, "additions": 112, "deletions": 105}, "files": [{"sha": "f706a186e7f8190cea00d875f050d910194d23fb", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 75, "deletions": 35, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=a6af0272f7bf129a3063cdd7096f685fc58438e6", "patch": "@@ -25,7 +25,8 @@ use crate::{\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n     AssocItem, Callable, Crate, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef,\n-    Module, ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    Module, ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, TypeRef,\n+    VariantDef,\n };\n use resolver::TypeNs;\n \n@@ -280,45 +281,84 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.assert_contains_node(node)\n     }\n \n-    pub fn is_unsafe_pat(&self, pat: &ast::Pat) -> bool {\n-        let ty = (|| {\n-            let parent = match pat {\n-                ast::Pat::BindPat(bind_pat) => bind_pat.syntax().parent()?,\n-                _ => return None,\n-            };\n-\n-            // `BindPat` can live under `RecordPat` directly under `RecordFieldPat` or\n-            // `RecordFieldPatList`. `RecordFieldPat` also lives under `RecordFieldPatList`,\n-            // so this tries to lookup the `BindPat` anywhere along that structure to the\n-            // `RecordPat` so we can get the containing type.\n-            let record_pat = ast::RecordFieldPat::cast(parent.clone())\n-                .and_then(|record_pat| record_pat.syntax().parent())\n-                .or_else(|| Some(parent.clone()))\n-                .and_then(|parent| {\n-                    ast::RecordFieldPatList::cast(parent)?\n-                        .syntax()\n-                        .parent()\n-                        .and_then(ast::RecordPat::cast)\n-                });\n-\n-            // If this doesn't match a `RecordPat`, fallback to a `LetStmt` to see if\n-            // this is initialized from a `FieldExpr`.\n-            if let Some(record_pat) = record_pat {\n-                self.type_of_pat(&ast::Pat::RecordPat(record_pat))\n-            } else if let Some(let_stmt) = ast::LetStmt::cast(parent) {\n-                let field_expr = match let_stmt.initializer()? {\n-                    ast::Expr::FieldExpr(field_expr) => field_expr,\n-                    _ => return None,\n-                };\n+    pub fn is_unsafe_method_call(&self, method_call_expr: ast::MethodCallExpr) -> Option<()> {\n+        let expr = method_call_expr.expr()?;\n+        let field_expr =\n+            if let ast::Expr::FieldExpr(field_expr) = expr { field_expr } else { return None };\n+        let ty = self.type_of_expr(&field_expr.expr()?)?;\n+        if !ty.is_packed(self.db) {\n+            return None;\n+        }\n \n-                self.type_of_expr(&field_expr.expr()?)\n+        let func = self.resolve_method_call(&method_call_expr)?;\n+        if func.has_self_param(self.db) {\n+            let params = func.params(self.db);\n+            if matches!(params.into_iter().next(), Some(TypeRef::Reference(..))) {\n+                Some(())\n             } else {\n                 None\n             }\n-        })();\n+        } else {\n+            None\n+        }\n+    }\n \n-        // Binding a reference to a packed type is possibly unsafe.\n-        ty.map(|ty| ty.is_packed(self.db)).unwrap_or(false)\n+    pub fn is_unsafe_ref_expr(&self, ref_expr: &ast::RefExpr) -> bool {\n+        ref_expr\n+            .expr()\n+            .and_then(|expr| {\n+                let field_expr = match expr {\n+                    ast::Expr::FieldExpr(field_expr) => field_expr,\n+                    _ => return None,\n+                };\n+                let expr = field_expr.expr()?;\n+                self.type_of_expr(&expr)\n+            })\n+            // Binding a reference to a packed type is possibly unsafe.\n+            .map(|ty| ty.is_packed(self.db))\n+            .unwrap_or(false)\n+\n+        // FIXME This needs layout computation to be correct. It will highlight\n+        // more than it should with the current implementation.\n+    }\n+\n+    pub fn is_unsafe_bind_pat(&self, bind_pat: &ast::BindPat) -> bool {\n+        bind_pat\n+            .syntax()\n+            .parent()\n+            .and_then(|parent| {\n+                // `BindPat` can live under `RecordPat` directly under `RecordFieldPat` or\n+                // `RecordFieldPatList`. `RecordFieldPat` also lives under `RecordFieldPatList`,\n+                // so this tries to lookup the `BindPat` anywhere along that structure to the\n+                // `RecordPat` so we can get the containing type.\n+                let record_pat = ast::RecordFieldPat::cast(parent.clone())\n+                    .and_then(|record_pat| record_pat.syntax().parent())\n+                    .or_else(|| Some(parent.clone()))\n+                    .and_then(|parent| {\n+                        ast::RecordFieldPatList::cast(parent)?\n+                            .syntax()\n+                            .parent()\n+                            .and_then(ast::RecordPat::cast)\n+                    });\n+\n+                // If this doesn't match a `RecordPat`, fallback to a `LetStmt` to see if\n+                // this is initialized from a `FieldExpr`.\n+                if let Some(record_pat) = record_pat {\n+                    self.type_of_pat(&ast::Pat::RecordPat(record_pat))\n+                } else if let Some(let_stmt) = ast::LetStmt::cast(parent) {\n+                    let field_expr = match let_stmt.initializer()? {\n+                        ast::Expr::FieldExpr(field_expr) => field_expr,\n+                        _ => return None,\n+                    };\n+\n+                    self.type_of_expr(&field_expr.expr()?)\n+                } else {\n+                    None\n+                }\n+            })\n+            // Binding a reference to a packed type is possibly unsafe.\n+            .map(|ty| ty.is_packed(self.db))\n+            .unwrap_or(false)\n     }\n }\n "}, {"sha": "e29f65a7849e3c125a54e766aae06cd44c444667", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 28, "deletions": 61, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=a6af0272f7bf129a3063cdd7096f685fc58438e6", "patch": "@@ -565,29 +565,21 @@ fn highlight_element(\n                 _ => h,\n             }\n         }\n-        T![&] => {\n-            let ref_expr = element.parent().and_then(ast::RefExpr::cast)?;\n-            let expr = ref_expr.expr()?;\n-            let field_expr = match expr {\n-                ast::Expr::FieldExpr(fe) => fe,\n-                _ => return None,\n-            };\n-\n-            let expr = field_expr.expr()?;\n-            let ty = sema.type_of_expr(&expr)?;\n-            if !ty.is_packed(db) {\n-                return None;\n-            }\n-\n-            // FIXME This needs layout computation to be correct. It will highlight\n-            // more than it should with the current implementation.\n-\n-            HighlightTag::Operator | HighlightModifier::Unsafe\n-        }\n         p if p.is_punct() => match p {\n-            T![::] | T![->] | T![=>] | T![&] | T![..] | T![=] | T![@] => {\n-                HighlightTag::Operator.into()\n+            T![&] => {\n+                let h = HighlightTag::Operator.into();\n+                let is_unsafe = element\n+                    .parent()\n+                    .and_then(ast::RefExpr::cast)\n+                    .map(|ref_expr| sema.is_unsafe_ref_expr(&ref_expr))\n+                    .unwrap_or(false);\n+                if is_unsafe {\n+                    h | HighlightModifier::Unsafe\n+                } else {\n+                    h\n+                }\n             }\n+            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] => HighlightTag::Operator.into(),\n             T![!] if element.parent().and_then(ast::MacroCall::cast).is_some() => {\n                 HighlightTag::Macro.into()\n             }\n@@ -668,22 +660,18 @@ fn highlight_element(\n                         HighlightTag::SelfKeyword.into()\n                     }\n                 }\n-                T![ref] => {\n-                    let modifier: Option<HighlightModifier> = (|| {\n-                        let bind_pat = element.parent().and_then(ast::BindPat::cast)?;\n-                        if sema.is_unsafe_pat(&ast::Pat::BindPat(bind_pat)) {\n+                T![ref] => element\n+                    .parent()\n+                    .and_then(ast::BindPat::cast)\n+                    .and_then(|bind_pat| {\n+                        if sema.is_unsafe_bind_pat(&bind_pat) {\n                             Some(HighlightModifier::Unsafe)\n                         } else {\n                             None\n                         }\n-                    })();\n-\n-                    if let Some(modifier) = modifier {\n-                        h | modifier\n-                    } else {\n-                        h\n-                    }\n-                }\n+                    })\n+                    .map(|modifier| h | modifier)\n+                    .unwrap_or(h),\n                 _ => h,\n             }\n         }\n@@ -713,31 +701,6 @@ fn is_child_of_impl(element: &SyntaxElement) -> bool {\n     }\n }\n \n-fn is_method_call_unsafe(\n-    sema: &Semantics<RootDatabase>,\n-    method_call_expr: ast::MethodCallExpr,\n-) -> Option<()> {\n-    let expr = method_call_expr.expr()?;\n-    let field_expr =\n-        if let ast::Expr::FieldExpr(field_expr) = expr { field_expr } else { return None };\n-    let ty = sema.type_of_expr(&field_expr.expr()?)?;\n-    if !ty.is_packed(sema.db) {\n-        return None;\n-    }\n-\n-    let func = sema.resolve_method_call(&method_call_expr)?;\n-    if func.has_self_param(sema.db) {\n-        let params = func.params(sema.db);\n-        if matches!(params.into_iter().next(), Some(TypeRef::Reference(..))) {\n-            Some(())\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n fn highlight_name(\n     sema: &Semantics<RootDatabase>,\n     db: &RootDatabase,\n@@ -767,7 +730,7 @@ fn highlight_name(\n                     let is_unsafe = name_ref\n                         .and_then(|name_ref| name_ref.syntax().parent())\n                         .and_then(ast::MethodCallExpr::cast)\n-                        .and_then(|method_call_expr| is_method_call_unsafe(sema, method_call_expr));\n+                        .and_then(|method_call_expr| sema.is_unsafe_method_call(method_call_expr));\n                     if is_unsafe.is_some() {\n                         h |= HighlightModifier::Unsafe;\n                     }\n@@ -846,7 +809,7 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n         METHOD_CALL_EXPR => {\n             let mut h = Highlight::new(HighlightTag::Function);\n             let is_unsafe = ast::MethodCallExpr::cast(parent)\n-                .and_then(|method_call_expr| is_method_call_unsafe(sema, method_call_expr));\n+                .and_then(|method_call_expr| sema.is_unsafe_method_call(method_call_expr));\n \n             if is_unsafe.is_some() {\n                 h |= HighlightModifier::Unsafe;\n@@ -866,7 +829,11 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n                     })\n                 })\n                 .unwrap_or(false);\n-            if is_union { h | HighlightModifier::Unsafe } else { h.into() }\n+            if is_union {\n+                h | HighlightModifier::Unsafe\n+            } else {\n+                h.into()\n+            }\n         }\n         PATH_SEGMENT => {\n             let path = match parent.parent().and_then(ast::Path::cast) {"}, {"sha": "6322d404fba5c6c7cab62278eecce9b22af4b45c", "filename": "crates/ra_ide/test_data/highlight_doctest.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlight_doctest.html?ref=a6af0272f7bf129a3063cdd7096f685fc58438e6", "patch": "@@ -87,7 +87,7 @@\n     <span class=\"comment documentation\">/// ```sh</span>\n     <span class=\"comment documentation\">/// echo 1</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function declaration\">foo</span><span class=\"punctuation\">(</span>&<span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">bool</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function declaration\">foo</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">bool</span> <span class=\"punctuation\">{</span>\n         <span class=\"bool_literal\">true</span>\n     <span class=\"punctuation\">}</span>\n <span class=\"punctuation\">}</span>"}, {"sha": "18addd00d283c68b13aa8dbd99b5b964c3e1d0c1", "filename": "crates/ra_ide/test_data/highlight_injection.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Ftest_data%2Fhighlight_injection.html", "raw_url": "https://github.com/rust-lang/rust/raw/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Ftest_data%2Fhighlight_injection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlight_injection.html?ref=a6af0272f7bf129a3063cdd7096f685fc58438e6", "patch": "@@ -35,7 +35,7 @@\n \n .unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n </style>\n-<pre><code><span class=\"keyword\">fn</span> <span class=\"function declaration\">fixture</span><span class=\"punctuation\">(</span><span class=\"value_param declaration\">ra_fixture</span><span class=\"punctuation\">:</span> &<span class=\"builtin_type\">str</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+<pre><code><span class=\"keyword\">fn</span> <span class=\"function declaration\">fixture</span><span class=\"punctuation\">(</span><span class=\"value_param declaration\">ra_fixture</span><span class=\"punctuation\">:</span> <span class=\"operator\">&</span><span class=\"builtin_type\">str</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n     <span class=\"function\">fixture</span><span class=\"punctuation\">(</span><span class=\"string_literal\">r#\"</span>"}, {"sha": "a2df2c27e6bb60594d6534731368447aa6601d10", "filename": "crates/ra_ide/test_data/highlight_unsafe.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Ftest_data%2Fhighlight_unsafe.html", "raw_url": "https://github.com/rust-lang/rust/raw/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Ftest_data%2Fhighlight_unsafe.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlight_unsafe.html?ref=a6af0272f7bf129a3063cdd7096f685fc58438e6", "patch": "@@ -45,7 +45,7 @@\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">HasUnsafeFn</span><span class=\"punctuation\">;</span>\n \n <span class=\"keyword\">impl</span> <span class=\"struct\">HasUnsafeFn</span> <span class=\"punctuation\">{</span>\n-    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_method</span><span class=\"punctuation\">(</span>&<span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_method</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n <span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">TypeForStaticMut</span> <span class=\"punctuation\">{</span>\n@@ -55,7 +55,7 @@\n <span class=\"keyword\">static</span> <span class=\"keyword\">mut</span> <span class=\"static declaration mutable unsafe\">global_mut</span><span class=\"punctuation\">:</span> <span class=\"struct\">TypeForStaticMut</span> <span class=\"operator\">=</span> <span class=\"struct\">TypeForStaticMut</span> <span class=\"punctuation\">{</span> <span class=\"field\">a</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n-    <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> <span class=\"operator\">=</span> &<span class=\"numeric_literal\">5</span> <span class=\"keyword\">as</span> <span class=\"keyword\">*</span><span class=\"keyword\">const</span> <span class=\"punctuation\">_</span> <span class=\"keyword\">as</span> <span class=\"keyword\">*</span><span class=\"keyword\">const</span> <span class=\"builtin_type\">usize</span><span class=\"punctuation\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> <span class=\"operator\">=</span> <span class=\"operator\">&</span><span class=\"numeric_literal\">5</span> <span class=\"keyword\">as</span> <span class=\"keyword\">*</span><span class=\"keyword\">const</span> <span class=\"punctuation\">_</span> <span class=\"keyword\">as</span> <span class=\"keyword\">*</span><span class=\"keyword\">const</span> <span class=\"builtin_type\">usize</span><span class=\"punctuation\">;</span>\n     <span class=\"keyword\">let</span> <span class=\"variable declaration\">u</span> <span class=\"operator\">=</span> <span class=\"union\">Union</span> <span class=\"punctuation\">{</span> <span class=\"field\">b</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n     <span class=\"keyword unsafe\">unsafe</span> <span class=\"punctuation\">{</span>\n         <span class=\"comment\">// unsafe fn and method calls</span>"}, {"sha": "8e0160eee5b47dd945c106d23d47e4933f4e8b53", "filename": "crates/ra_ide/test_data/highlighting.html", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Ftest_data%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/a6af0272f7bf129a3063cdd7096f685fc58438e6/crates%2Fra_ide%2Ftest_data%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Ftest_data%2Fhighlighting.html?ref=a6af0272f7bf129a3063cdd7096f685fc58438e6", "patch": "@@ -45,11 +45,11 @@\n <span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">trait</span> <span class=\"trait declaration\">Bar</span> <span class=\"punctuation\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span><span class=\"punctuation\">(</span>&<span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span><span class=\"punctuation\">;</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span><span class=\"punctuation\">;</span>\n <span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"trait\">Bar</span> <span class=\"keyword\">for</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span><span class=\"punctuation\">(</span>&<span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"punctuation\">{</span>\n         <span class=\"self_keyword\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span>\n     <span class=\"punctuation\">}</span>\n <span class=\"punctuation\">}</span>\n@@ -59,7 +59,7 @@\n         <span class=\"self_keyword\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span>\n     <span class=\"punctuation\">}</span>\n \n-    <span class=\"keyword\">fn</span> <span class=\"function declaration\">qux</span><span class=\"punctuation\">(</span>&<span class=\"keyword\">mut</span> <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">qux</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n         <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"punctuation\">;</span>\n     <span class=\"punctuation\">}</span>\n <span class=\"punctuation\">}</span>\n@@ -107,8 +107,8 @@\n     <span class=\"macro\">noop!</span><span class=\"punctuation\">(</span><span class=\"macro\">noop</span><span class=\"macro\">!</span><span class=\"punctuation\">(</span><span class=\"numeric_literal\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n \n     <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">x</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">42</span><span class=\"punctuation\">;</span>\n-    <span class=\"keyword\">let</span> <span class=\"variable declaration mutable\">y</span> <span class=\"operator\">=</span> &<span class=\"keyword\">mut</span> <span class=\"variable mutable\">x</span><span class=\"punctuation\">;</span>\n-    <span class=\"keyword\">let</span> <span class=\"variable declaration\">z</span> <span class=\"operator\">=</span> &<span class=\"variable mutable\">y</span><span class=\"punctuation\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration mutable\">y</span> <span class=\"operator\">=</span> <span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"variable mutable\">x</span><span class=\"punctuation\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">z</span> <span class=\"operator\">=</span> <span class=\"operator\">&</span><span class=\"variable mutable\">y</span><span class=\"punctuation\">;</span>\n \n     <span class=\"keyword\">let</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span> <span class=\"field\">x</span><span class=\"punctuation\">:</span> <span class=\"variable declaration\">z</span><span class=\"punctuation\">,</span> <span class=\"field\">y</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span> <span class=\"field\">x</span><span class=\"punctuation\">:</span> <span class=\"variable\">z</span><span class=\"punctuation\">,</span> <span class=\"field\">y</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n "}]}