{"sha": "42357d772b8a3a1ce4395deeac0a5cf1f66e951d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMzU3ZDc3MmI4YTNhMWNlNDM5NWRlZWFjMGE1Y2YxZjY2ZTk1MWQ=", "commit": {"author": {"name": "root", "email": "root@localhost", "date": "2014-07-17T17:34:07Z"}, "committer": {"name": "root", "email": "root@localhost", "date": "2014-07-17T18:22:40Z"}, "message": "core::str: Implement Chars iterator using slice::Items\n\nRe-use the vector iterator to implement the chars iterator.\n\nThe iterator uses our guarantee that the string contains valid UTF-8,\nbut its only unsafe code is transmuting the decoded u32 into char.", "tree": {"sha": "22fafdc4b2cc9356f3344e625fb6afc9fb21c426", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22fafdc4b2cc9356f3344e625fb6afc9fb21c426"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42357d772b8a3a1ce4395deeac0a5cf1f66e951d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42357d772b8a3a1ce4395deeac0a5cf1f66e951d", "html_url": "https://github.com/rust-lang/rust/commit/42357d772b8a3a1ce4395deeac0a5cf1f66e951d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42357d772b8a3a1ce4395deeac0a5cf1f66e951d/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6b42c2463ddfc7d16b9199f7725e704c94c2acf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b42c2463ddfc7d16b9199f7725e704c94c2acf", "html_url": "https://github.com/rust-lang/rust/commit/d6b42c2463ddfc7d16b9199f7725e704c94c2acf"}], "stats": {"total": 158, "additions": 114, "deletions": 44}, "files": [{"sha": "9711d2e3bcc129b4f54eca462fba9de4a917611a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 114, "deletions": 44, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/42357d772b8a3a1ce4395deeac0a5cf1f66e951d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42357d772b8a3a1ce4395deeac0a5cf1f66e951d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=42357d772b8a3a1ce4395deeac0a5cf1f66e951d", "patch": "@@ -97,47 +97,121 @@ impl<'a> CharEq for &'a [char] {\n Section: Iterators\n */\n \n-/// External iterator for a string's characters.\n-/// Use with the `std::iter` module.\n+/// Iterator for the char (representing *Unicode Scalar Values*) of a string\n+///\n+/// Created with the method `.chars()`.\n #[deriving(Clone)]\n pub struct Chars<'a> {\n-    /// The slice remaining to be iterated\n-    string: &'a str,\n+    iter: slice::Items<'a, u8>\n+}\n+\n+// Return the initial codepoint accumulator for the first byte.\n+// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+// for width 3, and 3 bits for width 4\n+macro_rules! utf8_first_byte(\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n+)\n+\n+// return the value of $ch updated with continuation byte $byte\n+macro_rules! utf8_acc_cont_byte(\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n+)\n+\n+macro_rules! utf8_is_cont_byte(\n+    ($byte:expr) => (($byte & 192u8) == 128)\n+)\n+\n+#[inline]\n+fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n+    match opt {\n+        Some(&byte) => byte,\n+        None => 0,\n+    }\n }\n \n impl<'a> Iterator<char> for Chars<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        // Decode the next codepoint, then update\n-        // the slice to be just the remaining part\n-        if self.string.len() != 0 {\n-            let CharRange {ch, next} = self.string.char_range_at(0);\n+        // Decode UTF-8, using the valid UTF-8 invariant\n+        #[inline]\n+        fn decode_multibyte<'a>(x: u8, it: &mut slice::Items<'a, u8>) -> char {\n+            // NOTE: Performance is very sensitive to the exact formulation here\n+            // Decode from a byte combination out of: [[[x y] z] w]\n+            let cont_mask = 0x3F; // continuation byte mask\n+            let init = utf8_first_byte!(x, 2);\n+            let y = unwrap_or_0(it.next());\n+            let mut ch = utf8_acc_cont_byte!(init, y);\n+            if x >= 0xE0 {\n+                /* [[x y z] w] case */\n+                let z = unwrap_or_0(it.next());\n+\n+                let y_z = (((y & cont_mask) as u32) << 6) | (z & cont_mask) as u32;\n+                ch = init << 12 | y_z;\n+                if x >= 0xF0 {\n+                    /* [x y z w] case */\n+                    let w = unwrap_or_0(it.next());\n+                    ch = (init & 7) << 18 | y_z << 6 | (w & cont_mask) as u32;\n+                }\n+            }\n             unsafe {\n-                self.string = raw::slice_unchecked(self.string, next, self.string.len());\n+                mem::transmute(ch)\n+            }\n+        }\n+\n+        match self.iter.next() {\n+            None => None,\n+            Some(&next_byte) => {\n+                if next_byte < 128 {\n+                    Some(next_byte as char)\n+                } else {\n+                    Some(decode_multibyte(next_byte, &mut self.iter))\n+                }\n             }\n-            Some(ch)\n-        } else {\n-            None\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.string.len().saturating_add(3)/4, Some(self.string.len()))\n+        let (len, _) = self.iter.size_hint();\n+        (len.saturating_add(3) / 4, Some(len))\n     }\n }\n \n impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n-        if self.string.len() != 0 {\n-            let CharRange {ch, next} = self.string.char_range_at_reverse(self.string.len());\n+        #[inline]\n+        fn decode_multibyte_back<'a>(w: u8, it: &mut slice::Items<'a, u8>) -> char {\n+            // Decode from a byte combination out of: [x [y [z w]]]\n+            let mut ch;\n+            let z = unwrap_or_0(it.next_back());\n+            ch = utf8_first_byte!(z, 2);\n+            if utf8_is_cont_byte!(z) {\n+                let y = unwrap_or_0(it.next_back());\n+                ch = utf8_first_byte!(y, 3);\n+                if utf8_is_cont_byte!(y) {\n+                    let x = unwrap_or_0(it.next_back());\n+                    ch = utf8_first_byte!(x, 4);\n+                    ch = utf8_acc_cont_byte!(ch, y);\n+                }\n+                ch = utf8_acc_cont_byte!(ch, z);\n+            }\n+            ch = utf8_acc_cont_byte!(ch, w);\n+\n             unsafe {\n-                self.string = raw::slice_unchecked(self.string, 0, next);\n+                mem::transmute(ch)\n+            }\n+        }\n+\n+        match self.iter.next_back() {\n+            None => None,\n+            Some(&back_byte) => {\n+                if back_byte < 128 {\n+                    Some(back_byte as char)\n+                } else {\n+                    Some(decode_multibyte_back(back_byte, &mut self.iter))\n+                }\n             }\n-            Some(ch)\n-        } else {\n-            None\n         }\n     }\n }\n@@ -146,18 +220,23 @@ impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n pub struct CharOffsets<'a> {\n-    /// The original string to be iterated\n-    string: &'a str,\n+    front: uint,\n+    back: uint,\n     iter: Chars<'a>,\n }\n \n impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, char)> {\n-        // Compute the byte offset by using the pointer offset between\n-        // the original string slice and the iterator's remaining part\n-        let offset = self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n-        self.iter.next().map(|ch| (offset, ch))\n+        match self.iter.next() {\n+            None => None,\n+            Some(ch) => {\n+                let index = self.front;\n+                let (len, _) = self.iter.iter.size_hint();\n+                self.front += self.back - self.front - len;\n+                Some((index, ch))\n+            }\n+        }\n     }\n \n     #[inline]\n@@ -169,11 +248,14 @@ impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n-        self.iter.next_back().map(|ch| {\n-            let offset = self.iter.string.len() +\n-                    self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n-            (offset, ch)\n-        })\n+        match self.iter.next_back() {\n+            None => None,\n+            Some(ch) => {\n+                let (len, _) = self.iter.iter.size_hint();\n+                self.back -= self.back - self.front - len;\n+                Some((self.back, ch))\n+            }\n+        }\n     }\n }\n \n@@ -880,18 +962,6 @@ pub struct CharRange {\n     pub next: uint,\n }\n \n-// Return the initial codepoint accumulator for the first byte.\n-// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-// for width 3, and 3 bits for width 4\n-macro_rules! utf8_first_byte(\n-    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n-)\n-\n-// return the value of $ch updated with continuation byte $byte\n-macro_rules! utf8_acc_cont_byte(\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n-)\n-\n static TAG_CONT_U8: u8 = 128u8;\n \n /// Unsafe operations\n@@ -1608,7 +1678,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn chars(&self) -> Chars<'a> {\n-        Chars{string: *self}\n+        Chars{iter: self.as_bytes().iter()}\n     }\n \n     #[inline]\n@@ -1618,7 +1688,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn char_indices(&self) -> CharOffsets<'a> {\n-        CharOffsets{string: *self, iter: self.chars()}\n+        CharOffsets{front: 0, back: self.len(), iter: self.chars()}\n     }\n \n     #[inline]"}]}