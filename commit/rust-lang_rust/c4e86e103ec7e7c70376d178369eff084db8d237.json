{"sha": "c4e86e103ec7e7c70376d178369eff084db8d237", "node_id": "C_kwDOAAsO6NoAKGM0ZTg2ZTEwM2VjN2U3YzcwMzc2ZDE3ODM2OWVmZjA4NGRiOGQyMzc", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-29T21:53:09Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-29T22:22:30Z"}, "message": "add option for recursive field retagging", "tree": {"sha": "5430262967da01d6dd12540e7e8e07a0d613cb5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5430262967da01d6dd12540e7e8e07a0d613cb5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4e86e103ec7e7c70376d178369eff084db8d237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4e86e103ec7e7c70376d178369eff084db8d237", "html_url": "https://github.com/rust-lang/rust/commit/c4e86e103ec7e7c70376d178369eff084db8d237", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4e86e103ec7e7c70376d178369eff084db8d237/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "328a8c7a1e9dbf3b86e867982f26ad3df5d38436", "url": "https://api.github.com/repos/rust-lang/rust/commits/328a8c7a1e9dbf3b86e867982f26ad3df5d38436", "html_url": "https://github.com/rust-lang/rust/commit/328a8c7a1e9dbf3b86e867982f26ad3df5d38436"}], "stats": {"total": 152, "additions": 146, "deletions": 6}, "files": [{"sha": "bfc32d04a9d14fe8d8da36c556436c59625ed6fd", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -369,6 +369,9 @@ to Miri failing to detect cases of undefined behavior in a program.\n   application instead of raising an error within the context of Miri (and halting\n   execution). Note that code might not expect these operations to ever panic, so\n   this flag can lead to strange (mis)behavior.\n+* `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into fields.\n+  This means that references in fields of structs/enums/tuples/arrays/... are retagged,\n+  and in particular, they are protected when passed as function arguments.\n * `-Zmiri-track-alloc-id=<id1>,<id2>,...` shows a backtrace when the given allocations are\n   being allocated or freed.  This helps in debugging memory leaks and\n   use after free bugs. Specifying this argument multiple times does not overwrite the previous"}, {"sha": "323af716826d967b57cc8e611e059374dd867b34", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -1 +1 @@\n-493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0\n+ddcbba036aee08f0709f98a92a342a278eae5c05"}, {"sha": "4f00e4be18ab416cb6bea05b6a22f68f7eb0404a", "filename": "src/bin/miri.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -383,6 +383,8 @@ fn main() {\n             miri_config.provenance_mode = ProvenanceMode::Permissive;\n         } else if arg == \"-Zmiri-mute-stdout-stderr\" {\n             miri_config.mute_stdout_stderr = true;\n+        } else if arg == \"-Zmiri-retag-fields\" {\n+            miri_config.retag_fields = true;\n         } else if arg == \"-Zmiri-track-raw-pointers\" {\n             eprintln!(\n                 \"WARNING: `-Zmiri-track-raw-pointers` has no effect; it is enabled by default\""}, {"sha": "c9fc05500a3c605fbc5e08abd90830fe2e1cc0f7", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -124,6 +124,8 @@ pub struct MiriConfig {\n     pub preemption_rate: f64,\n     /// Report the current instruction being executed every N basic blocks.\n     pub report_progress: Option<u32>,\n+    /// Whether Stacked Borrows retagging should recurse into fields of datatypes.\n+    pub retag_fields: bool,\n }\n \n impl Default for MiriConfig {\n@@ -154,6 +156,7 @@ impl Default for MiriConfig {\n             mute_stdout_stderr: false,\n             preemption_rate: 0.01, // 1%\n             report_progress: None,\n+            retag_fields: false,\n         }\n     }\n }"}, {"sha": "4aeb42d3d0fe3e0a0afdfc6941335347561158d2", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -354,6 +354,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             Some(RefCell::new(stacked_borrows::GlobalStateInner::new(\n                 config.tracked_pointer_tags.clone(),\n                 config.tracked_call_ids.clone(),\n+                config.retag_fields,\n             )))\n         } else {\n             None"}, {"sha": "3fc0eaf10c094398475e3055616985bbad8078f9", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -156,6 +156,8 @@ pub struct GlobalStateInner {\n     tracked_pointer_tags: HashSet<SbTag>,\n     /// The call ids to trace\n     tracked_call_ids: HashSet<CallId>,\n+    /// Whether to recurse into datatypes when searching for pointers to retag.\n+    retag_fields: bool,\n }\n \n /// We need interior mutable access to the global state.\n@@ -204,14 +206,19 @@ impl fmt::Display for RefKind {\n \n /// Utilities for initialization and ID generation\n impl GlobalStateInner {\n-    pub fn new(tracked_pointer_tags: HashSet<SbTag>, tracked_call_ids: HashSet<CallId>) -> Self {\n+    pub fn new(\n+        tracked_pointer_tags: HashSet<SbTag>,\n+        tracked_call_ids: HashSet<CallId>,\n+        retag_fields: bool,\n+    ) -> Self {\n         GlobalStateInner {\n             next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n             base_ptr_tags: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: FxHashSet::default(),\n             tracked_pointer_tags,\n             tracked_call_ids,\n+            retag_fields,\n         }\n     }\n \n@@ -1035,17 +1042,69 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n \n-        // We only reborrow \"bare\" references/boxes.\n-        // Not traversing into fields helps with <https://github.com/rust-lang/unsafe-code-guidelines/issues/125>,\n-        // but might also cost us optimization and analyses. We will have to experiment more with this.\n+        // We need a visitor to visit all references. However, that requires\n+        // a `MPlaceTy` (or `OpTy), so we have a fast path for reference types that\n+        // avoids allocating.\n+\n         if let Some((mutbl, protector)) = qualify(place.layout.ty, kind) {\n             // Fast path.\n             let val = this.read_immediate(&this.place_to_op(place)?)?;\n             let val = this.retag_reference(&val, mutbl, protector)?;\n             this.write_immediate(*val, place)?;\n+            return Ok(());\n         }\n \n-        Ok(())\n+        // If we don't want to recurse, we are already done.\n+        if !this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields {\n+            return Ok(());\n+        }\n+\n+        // Skip some types that have no further structure we might care about.\n+        if matches!(\n+            place.layout.ty.kind(),\n+            ty::RawPtr(..)\n+                | ty::Ref(..)\n+                | ty::Int(..)\n+                | ty::Uint(..)\n+                | ty::Float(..)\n+                | ty::Bool\n+                | ty::Char\n+        ) {\n+            return Ok(());\n+        }\n+        // Now go visit this thing.\n+        let place = this.force_allocation(place)?;\n+\n+        let mut visitor = RetagVisitor { ecx: this, kind };\n+        return visitor.visit_value(&place);\n+\n+        // The actual visitor.\n+        struct RetagVisitor<'ecx, 'mir, 'tcx> {\n+            ecx: &'ecx mut MiriEvalContext<'mir, 'tcx>,\n+            kind: RetagKind,\n+        }\n+        impl<'ecx, 'mir, 'tcx> MutValueVisitor<'mir, 'tcx, Evaluator<'mir, 'tcx>>\n+            for RetagVisitor<'ecx, 'mir, 'tcx>\n+        {\n+            type V = MPlaceTy<'tcx, Tag>;\n+\n+            #[inline(always)]\n+            fn ecx(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n+                &mut self.ecx\n+            }\n+\n+            fn visit_value(&mut self, place: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+                if let Some((mutbl, protector)) = qualify(place.layout.ty, self.kind) {\n+                    let val = self.ecx.read_immediate(&place.into())?;\n+                    let val = self.ecx.retag_reference(&val, mutbl, protector)?;\n+                    self.ecx.write_immediate(*val, &(*place).into())?;\n+                } else {\n+                    // Maybe we need to go deeper.\n+                    self.walk_value(place)?;\n+                }\n+                Ok(())\n+            }\n+        }\n     }\n \n     /// After a stack frame got pushed, retag the return place so that we are sure"}, {"sha": "8f932f08086ac3d49318d73214a839b9078f89cb", "filename": "tests/fail/stacked_borrows/newtype_retagging.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Zmiri-retag-fields\n+// error-pattern: incompatible item is protected\n+struct Newtype<'a>(&'a mut i32);\n+\n+fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+    dealloc();\n+}\n+\n+// Make sure that we protect references inside structs.\n+fn main() {\n+    let ptr = Box::into_raw(Box::new(0i32));\n+    #[rustfmt::skip] // I like my newlines\n+    unsafe {\n+        dealloc_while_running(\n+            Newtype(&mut *ptr),\n+            || drop(Box::from_raw(ptr)),\n+        )\n+    };\n+}"}, {"sha": "f65231b661f9727600af1cdb4a50958e98d1a5ad", "filename": "tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -0,0 +1,50 @@\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+  --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   |\n+LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n+  --> $DIR/newtype_retagging.rs:LL:CC\n+   |\n+LL |     let ptr = Box::into_raw(Box::new(0i32));\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: <TAG> was protected due to <TAG> which was created here\n+  --> $DIR/newtype_retagging.rs:LL:CC\n+   |\n+LL |             Newtype(&mut *ptr),\n+   |             ^^^^^^^^^^^^^^^^^^\n+help: this protector is live for this call\n+  --> $DIR/newtype_retagging.rs:LL:CC\n+   |\n+LL | / fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+LL | |     dealloc();\n+LL | | }\n+   | |_^\n+   = note: inside `std::boxed::Box::<i32>::from_raw_in` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   = note: inside `std::boxed::Box::<i32>::from_raw` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+note: inside closure at $DIR/newtype_retagging.rs:LL:CC\n+  --> $DIR/newtype_retagging.rs:LL:CC\n+   |\n+LL |             || drop(Box::from_raw(ptr)),\n+   |                     ^^^^^^^^^^^^^^^^^^\n+note: inside `dealloc_while_running::<[closure@$DIR/newtype_retagging.rs:LL:CC]>` at $DIR/newtype_retagging.rs:LL:CC\n+  --> $DIR/newtype_retagging.rs:LL:CC\n+   |\n+LL |     dealloc();\n+   |     ^^^^^^^^^\n+note: inside `main` at $DIR/newtype_retagging.rs:LL:CC\n+  --> $DIR/newtype_retagging.rs:LL:CC\n+   |\n+LL | /         dealloc_while_running(\n+LL | |             Newtype(&mut *ptr),\n+LL | |             || drop(Box::from_raw(ptr)),\n+LL | |         )\n+   | |_________^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "6ac364b716c55536b5381d6261f9d05d4a44bc06", "filename": "tests/pass/stacked-borrows/interior_mutability.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-retag-fields\n use std::cell::{Cell, RefCell, UnsafeCell};\n use std::mem::{self, MaybeUninit};\n "}, {"sha": "e9d7f671528802e18c6d65ba363d9d94c7815f0e", "filename": "tests/pass/stacked-borrows/refcell.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Fpass%2Fstacked-borrows%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Fpass%2Fstacked-borrows%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Frefcell.rs?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-retag-fields\n use std::cell::{Ref, RefCell, RefMut};\n \n fn main() {"}, {"sha": "3669a08a1bc4b62dd00280a391cff8298510edd3", "filename": "tests/pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-retag-fields\n use std::ptr;\n \n // Test various stacked-borrows-related things."}]}