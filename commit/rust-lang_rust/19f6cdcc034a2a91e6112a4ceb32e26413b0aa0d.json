{"sha": "19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZjZjZGNjMDM0YTJhOTFlNjExMmE0Y2ViMzJlMjY0MTNiMGFhMGQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-09T11:00:56Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-09T11:00:56Z"}, "message": "Merge #268\n\n268: WIP: resolve imports across crates r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "548400065966f715ae203e6f6e0fcfd9f12e4470", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/548400065966f715ae203e6f6e0fcfd9f12e4470"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "html_url": "https://github.com/rust-lang/rust/commit/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "34956b7823d72467fbf4fa62bd4413dfb680f78d", "url": "https://api.github.com/repos/rust-lang/rust/commits/34956b7823d72467fbf4fa62bd4413dfb680f78d", "html_url": "https://github.com/rust-lang/rust/commit/34956b7823d72467fbf4fa62bd4413dfb680f78d"}, {"sha": "7784c7a701ba944decf671f80dea581d68667663", "url": "https://api.github.com/repos/rust-lang/rust/commits/7784c7a701ba944decf671f80dea581d68667663", "html_url": "https://github.com/rust-lang/rust/commit/7784c7a701ba944decf671f80dea581d68667663"}], "stats": {"total": 542, "additions": 373, "deletions": 169}, "files": [{"sha": "5cfc064b51ff157ed11fa35358f39ad43cc9abff", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -1,6 +1,5 @@\n [workspace]\n members = [ \"crates/*\" ]\n-exclude = [ \"crates/rowan\"]\n \n [profile.release]\n debug = true"}, {"sha": "ac144b991836f6278142963a21a6796abf9d3252", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n-use rustc_hash::FxHashMap;\n-use rustc_hash::FxHashSet;\n+use rustc_hash::{FxHashSet, FxHashMap};\n+use ra_syntax::SmolStr;\n use salsa;\n \n use crate::file_resolver::FileResolverImp;\n@@ -20,25 +20,32 @@ pub struct CrateGraph {\n #[derive(Debug, Clone, PartialEq, Eq)]\n struct CrateData {\n     file_id: FileId,\n-    deps: Vec<Dependency>,\n+    dependencies: Vec<Dependency>,\n }\n \n impl CrateData {\n     fn new(file_id: FileId) -> CrateData {\n         CrateData {\n             file_id,\n-            deps: Vec::new(),\n+            dependencies: Vec::new(),\n         }\n     }\n \n-    fn add_dep(&mut self, dep: CrateId) {\n-        self.deps.push(Dependency { crate_: dep })\n+    fn add_dep(&mut self, name: SmolStr, crate_id: CrateId) {\n+        self.dependencies.push(Dependency { name, crate_id })\n     }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Dependency {\n-    crate_: CrateId,\n+    pub crate_id: CrateId,\n+    pub name: SmolStr,\n+}\n+\n+impl Dependency {\n+    pub fn crate_id(&self) -> CrateId {\n+        self.crate_id\n+    }\n }\n \n impl CrateGraph {\n@@ -48,8 +55,11 @@ impl CrateGraph {\n         assert!(prev.is_none());\n         crate_id\n     }\n-    pub fn add_dep(&mut self, from: CrateId, to: CrateId) {\n-        self.arena.get_mut(&from).unwrap().add_dep(to)\n+    //FIXME: check that we don't have cycles here.\n+    // Just a simple depth first search from `to` should work,\n+    // the graph is small.\n+    pub fn add_dep(&mut self, from: CrateId, name: SmolStr, to: CrateId) {\n+        self.arena.get_mut(&from).unwrap().add_dep(name, to)\n     }\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n         self.arena[&crate_id].file_id\n@@ -61,6 +71,12 @@ impl CrateGraph {\n             .find(|(_crate_id, data)| data.file_id == file_id)?;\n         Some(crate_id)\n     }\n+    pub fn dependencies<'a>(\n+        &'a self,\n+        crate_id: CrateId,\n+    ) -> impl Iterator<Item = &'a Dependency> + 'a {\n+        self.arena[&crate_id].dependencies.iter()\n+    }\n }\n \n salsa::query_group! {"}, {"sha": "2f7551597fc6150bef8f72449448128bbcfc5dee", "filename": "crates/ra_db/src/mock.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_db%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_db%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fmock.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -5,7 +5,7 @@ use relative_path::{RelativePath, RelativePathBuf};\n \n use crate::{FileId, FileResolver, SourceRoot, FileResolverImp};\n \n-#[derive(Default, Debug)]\n+#[derive(Default, Debug, Clone)]\n pub struct FileMap(Vec<(FileId, RelativePathBuf)>);\n \n impl FileMap {\n@@ -28,6 +28,11 @@ impl FileMap {\n         self.iter().map(|(id, _)| id).collect()\n     }\n \n+    pub fn file_id(&self, path: &str) -> FileId {\n+        assert!(path.starts_with('/'));\n+        self.iter().find(|(_, p)| p == &path[1..]).unwrap().0\n+    }\n+\n     fn iter<'a>(&'a self) -> impl Iterator<Item = (FileId, &'a RelativePath)> + 'a {\n         self.0\n             .iter()"}, {"sha": "1196dcef17a81269de3c74991e8908cacb54033c", "filename": "crates/ra_hir/src/krate.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fkrate.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -0,0 +1,48 @@\n+use ra_syntax::SmolStr;\n+pub use ra_db::CrateId;\n+\n+use crate::{HirDatabase, Module, Cancelable};\n+\n+/// hir::Crate describes a single crate. It's the main inteface with which\n+/// crate's dependencies interact. Mostly, it should be just a proxy for the\n+/// root module.\n+#[derive(Debug)]\n+pub struct Crate {\n+    crate_id: CrateId,\n+}\n+\n+#[derive(Debug)]\n+pub struct CrateDependency {\n+    pub krate: Crate,\n+    pub name: SmolStr,\n+}\n+\n+impl Crate {\n+    pub(crate) fn new(crate_id: CrateId) -> Crate {\n+        Crate { crate_id }\n+    }\n+    pub fn dependencies(&self, db: &impl HirDatabase) -> Vec<CrateDependency> {\n+        let crate_graph = db.crate_graph();\n+        crate_graph\n+            .dependencies(self.crate_id)\n+            .map(|dep| {\n+                let krate = Crate::new(dep.crate_id());\n+                let name = dep.name.clone();\n+                CrateDependency { krate, name }\n+            })\n+            .collect()\n+    }\n+    pub fn root_module(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n+        let crate_graph = db.crate_graph();\n+        let file_id = crate_graph.crate_root(self.crate_id);\n+        let source_root_id = db.file_source_root(file_id);\n+        let module_tree = db.module_tree(source_root_id)?;\n+        // FIXME: teach module tree about crate roots instead of guessing\n+        let (module_id, _) = ctry!(module_tree\n+            .modules_with_sources()\n+            .find(|(_, src)| src.file_id() == file_id));\n+\n+        let module = Module::new(db, source_root_id, module_id)?;\n+        Ok(Some(module))\n+    }\n+}"}, {"sha": "578fde2595f1d0f2ebef1e54e82ddca50a5f28a5", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -18,12 +18,14 @@ pub mod db;\n #[cfg(test)]\n mod mock;\n mod query_definitions;\n-mod function;\n-mod module;\n mod path;\n mod arena;\n pub mod source_binder;\n \n+mod krate;\n+mod module;\n+mod function;\n+\n use std::ops::Index;\n \n use ra_syntax::{SyntaxNodeRef, SyntaxNode};\n@@ -36,6 +38,7 @@ use crate::{\n \n pub use self::{\n     path::{Path, PathKind},\n+    krate::Crate,\n     module::{Module, ModuleId, Problem, nameres::ItemMap},\n     function::{Function, FnScopes},\n };"}, {"sha": "b7193c4f3f7808c7a4503ae932ebd189d47ec4bb", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -2,7 +2,7 @@ use std::sync::Arc;\n \n use parking_lot::Mutex;\n use salsa::{self, Database};\n-use ra_db::{LocationIntener, BaseDatabase, FilePosition, mock::FileMap, FileId, WORKSPACE};\n+use ra_db::{LocationIntener, BaseDatabase, FilePosition, mock::FileMap, FileId, WORKSPACE, CrateGraph};\n use relative_path::RelativePathBuf;\n use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n \n@@ -16,7 +16,24 @@ pub(crate) struct MockDatabase {\n }\n \n impl MockDatabase {\n+    pub(crate) fn with_files(fixture: &str) -> (MockDatabase, FileMap) {\n+        let (db, file_map, position) = MockDatabase::from_fixture(fixture);\n+        assert!(position.is_none());\n+        (db, file_map)\n+    }\n+\n     pub(crate) fn with_position(fixture: &str) -> (MockDatabase, FilePosition) {\n+        let (db, _, position) = MockDatabase::from_fixture(fixture);\n+        let position = position.expect(\"expected a marker ( <|> )\");\n+        (db, position)\n+    }\n+\n+    pub(crate) fn set_crate_graph(&mut self, crate_graph: CrateGraph) {\n+        self.query_mut(ra_db::CrateGraphQuery)\n+            .set((), Arc::new(crate_graph));\n+    }\n+\n+    fn from_fixture(fixture: &str) -> (MockDatabase, FileMap, Option<FilePosition>) {\n         let mut db = MockDatabase::default();\n \n         let mut position = None;\n@@ -32,11 +49,10 @@ impl MockDatabase {\n                 db.add_file(&mut file_map, &entry.meta, &entry.text);\n             }\n         }\n-        let position = position.expect(\"expected a marker (<|>)\");\n-        let source_root = file_map.into_source_root();\n+        let source_root = file_map.clone().into_source_root();\n         db.query_mut(ra_db::SourceRootQuery)\n             .set(WORKSPACE, Arc::new(source_root));\n-        (db, position)\n+        (db, file_map, position)\n     }\n \n     fn add_file(&mut self, file_map: &mut FileMap, path: &str, text: &str) -> FileId {"}, {"sha": "c6bb76d56dfebdef4e76706450c7973de6974ead", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -12,7 +12,7 @@ use ra_db::{SourceRootId, FileId, Cancelable};\n use relative_path::RelativePathBuf;\n \n use crate::{\n-    DefKind, DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId,\n+    DefKind, DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n     arena::{Arena, Id},\n };\n \n@@ -64,6 +64,15 @@ impl Module {\n         })\n     }\n \n+    /// Returns the crate this module is part of.\n+    pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n+        let root_id = self.module_id.crate_root(&self.tree);\n+        let file_id = root_id.source(&self.tree).file_id();\n+        let crate_graph = db.crate_graph();\n+        let crate_id = crate_graph.crate_id_for_crate_root(file_id)?;\n+        Some(Crate::new(crate_id))\n+    }\n+\n     /// The root of the tree this module is part of\n     pub fn crate_root(&self) -> Module {\n         let root_id = self.module_id.crate_root(&self.tree);"}, {"sha": "9afeade9e5c1295a06dd1a96a5357743755d203e", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 69, "deletions": 130, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -31,7 +31,7 @@ use crate::{\n     DefId, DefLoc, DefKind,\n     SourceItemId, SourceFileItemId, SourceFileItems,\n     Path, PathKind,\n-    HirDatabase,\n+    HirDatabase, Crate,\n     module::{ModuleId, ModuleTree},\n };\n \n@@ -200,34 +200,63 @@ impl ModuleItem {\n }\n \n pub(crate) struct Resolver<'a, DB> {\n-    pub(crate) db: &'a DB,\n-    pub(crate) input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n-    pub(crate) source_root: SourceRootId,\n-    pub(crate) module_tree: Arc<ModuleTree>,\n-    pub(crate) result: ItemMap,\n+    db: &'a DB,\n+    input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n+    source_root: SourceRootId,\n+    module_tree: Arc<ModuleTree>,\n+    result: ItemMap,\n }\n \n impl<'a, DB> Resolver<'a, DB>\n where\n     DB: HirDatabase,\n {\n+    pub(crate) fn new(\n+        db: &'a DB,\n+        input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n+        source_root: SourceRootId,\n+        module_tree: Arc<ModuleTree>,\n+    ) -> Resolver<'a, DB> {\n+        Resolver {\n+            db,\n+            input,\n+            source_root,\n+            module_tree,\n+            result: ItemMap::default(),\n+        }\n+    }\n+\n     pub(crate) fn resolve(mut self) -> Cancelable<ItemMap> {\n         for (&module_id, items) in self.input.iter() {\n-            self.populate_module(module_id, items)\n+            self.populate_module(module_id, items)?;\n         }\n \n         for &module_id in self.input.keys() {\n             self.db.check_canceled()?;\n-            self.resolve_imports(module_id);\n+            self.resolve_imports(module_id)?;\n         }\n         Ok(self.result)\n     }\n \n-    fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) {\n+    fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) -> Cancelable<()> {\n         let file_id = module_id.source(&self.module_tree).file_id();\n \n         let mut module_items = ModuleScope::default();\n \n+        // Populate extern crates prelude\n+        {\n+            let root_id = module_id.crate_root(&self.module_tree);\n+            let file_id = root_id.source(&self.module_tree).file_id();\n+            let crate_graph = self.db.crate_graph();\n+            if let Some(crate_id) = crate_graph.crate_id_for_crate_root(file_id) {\n+                let krate = Crate::new(crate_id);\n+                for dep in krate.dependencies(self.db) {\n+                    if let Some(module) = dep.krate.root_module(self.db)? {\n+                        self.add_module_item(&mut module_items, dep.name, module.module_id);\n+                    }\n+                }\n+            };\n+        }\n         for import in input.imports.iter() {\n             if let Some(name) = import.path.segments.iter().last() {\n                 if let ImportKind::Named(import) = import.kind {\n@@ -241,10 +270,9 @@ where\n                 }\n             }\n         }\n-\n+        // Populate explicitelly declared items, except modules\n         for item in input.items.iter() {\n             if item.kind == MODULE {\n-                // handle submodules separatelly\n                 continue;\n             }\n             let def_loc = DefLoc {\n@@ -264,45 +292,50 @@ where\n             module_items.items.insert(item.name.clone(), resolution);\n         }\n \n+        // Populate modules\n         for (name, module_id) in module_id.children(&self.module_tree) {\n-            let def_loc = DefLoc {\n-                kind: DefKind::Module,\n-                source_root_id: self.source_root,\n-                module_id,\n-                source_item_id: module_id.source(&self.module_tree).0,\n-            };\n-            let def_id = def_loc.id(self.db);\n-            let resolution = Resolution {\n-                def_id: Some(def_id),\n-                import: None,\n-            };\n-            module_items.items.insert(name, resolution);\n+            self.add_module_item(&mut module_items, name, module_id);\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n+        Ok(())\n     }\n \n-    fn resolve_imports(&mut self, module_id: ModuleId) {\n+    fn add_module_item(&self, module_items: &mut ModuleScope, name: SmolStr, module_id: ModuleId) {\n+        let def_loc = DefLoc {\n+            kind: DefKind::Module,\n+            source_root_id: self.source_root,\n+            module_id,\n+            source_item_id: module_id.source(&self.module_tree).0,\n+        };\n+        let def_id = def_loc.id(self.db);\n+        let resolution = Resolution {\n+            def_id: Some(def_id),\n+            import: None,\n+        };\n+        module_items.items.insert(name, resolution);\n+    }\n+\n+    fn resolve_imports(&mut self, module_id: ModuleId) -> Cancelable<()> {\n         for import in self.input[&module_id].imports.iter() {\n-            self.resolve_import(module_id, import);\n+            self.resolve_import(module_id, import)?;\n         }\n+        Ok(())\n     }\n \n-    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) {\n+    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> Cancelable<()> {\n         let ptr = match import.kind {\n-            ImportKind::Glob => return,\n+            ImportKind::Glob => return Ok(()),\n             ImportKind::Named(ptr) => ptr,\n         };\n \n         let mut curr = match import.path.kind {\n-            // TODO: handle extern crates\n-            PathKind::Plain => return,\n-            PathKind::Self_ => module_id,\n+            PathKind::Plain | PathKind::Self_ => module_id,\n             PathKind::Super => {\n                 match module_id.parent(&self.module_tree) {\n                     Some(it) => it,\n                     // TODO: error\n-                    None => return,\n+                    None => return Ok(()),\n                 }\n             }\n             PathKind::Crate => module_id.crate_root(&self.module_tree),\n@@ -312,10 +345,10 @@ where\n             let is_last = i == import.path.segments.len() - 1;\n \n             let def_id = match self.result.per_module[&curr].items.get(name) {\n-                None => return,\n+                None => return Ok(()),\n                 Some(res) => match res.def_id {\n                     Some(it) => it,\n-                    None => return,\n+                    None => return Ok(()),\n                 },\n             };\n \n@@ -326,7 +359,7 @@ where\n                         module_id,\n                         ..\n                     } => module_id,\n-                    _ => return,\n+                    _ => return Ok(()),\n                 }\n             } else {\n                 self.update(module_id, |items| {\n@@ -338,6 +371,7 @@ where\n                 })\n             }\n         }\n+        Ok(())\n     }\n \n     fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n@@ -347,99 +381,4 @@ where\n }\n \n #[cfg(test)]\n-mod tests {\n-    use std::sync::Arc;\n-\n-    use salsa::Database;\n-    use ra_db::FilesDatabase;\n-    use ra_syntax::SmolStr;\n-\n-    use crate::{\n-        self as hir,\n-        db::HirDatabase,\n-        mock::MockDatabase,\n-};\n-\n-    fn item_map(fixture: &str) -> (Arc<hir::ItemMap>, hir::ModuleId) {\n-        let (db, pos) = MockDatabase::with_position(fixture);\n-        let source_root = db.file_source_root(pos.file_id);\n-        let module = hir::source_binder::module_from_position(&db, pos)\n-            .unwrap()\n-            .unwrap();\n-        let module_id = module.module_id;\n-        (db.item_map(source_root).unwrap(), module_id)\n-    }\n-\n-    #[test]\n-    fn test_item_map() {\n-        let (item_map, module_id) = item_map(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-            <|>\n-\n-            //- /foo/mod.rs\n-            pub mod bar;\n-\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-        );\n-        let name = SmolStr::from(\"Baz\");\n-        let resolution = &item_map.per_module[&module_id].items[&name];\n-        assert!(resolution.def_id.is_some());\n-    }\n-\n-    #[test]\n-    fn typing_inside_a_function_should_not_invalidate_item_map() {\n-        let (mut db, pos) = MockDatabase::with_position(\n-            \"\n-            //- /lib.rs\n-            mod foo;<|>\n-\n-            use crate::foo::bar::Baz;\n-\n-            fn foo() -> i32 {\n-                1 + 1\n-            }\n-            //- /foo/mod.rs\n-            pub mod bar;\n-\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-        );\n-        let source_root = db.file_source_root(pos.file_id);\n-        {\n-            let events = db.log_executed(|| {\n-                db.item_map(source_root).unwrap();\n-            });\n-            assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n-        }\n-\n-        let new_text = \"\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-\n-            fn foo() -> i32 { 92 }\n-        \"\n-        .to_string();\n-\n-        db.query_mut(ra_db::FileTextQuery)\n-            .set(pos.file_id, Arc::new(new_text));\n-\n-        {\n-            let events = db.log_executed(|| {\n-                db.item_map(source_root).unwrap();\n-            });\n-            assert!(\n-                !format!(\"{:?}\", events).contains(\"_item_map\"),\n-                \"{:#?}\",\n-                events\n-            )\n-        }\n-    }\n-}\n+mod tests;"}, {"sha": "9ddc32dcd9a8cb307ee53522a70210258702f798", "filename": "crates/ra_hir/src/module/nameres/tests.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -0,0 +1,127 @@\n+use std::sync::Arc;\n+\n+use salsa::Database;\n+use ra_db::{FilesDatabase, CrateGraph};\n+use ra_syntax::SmolStr;\n+\n+use crate::{\n+    self as hir,\n+    db::HirDatabase,\n+    mock::MockDatabase,\n+};\n+\n+fn item_map(fixture: &str) -> (Arc<hir::ItemMap>, hir::ModuleId) {\n+    let (db, pos) = MockDatabase::with_position(fixture);\n+    let source_root = db.file_source_root(pos.file_id);\n+    let module = hir::source_binder::module_from_position(&db, pos)\n+        .unwrap()\n+        .unwrap();\n+    let module_id = module.module_id;\n+    (db.item_map(source_root).unwrap(), module_id)\n+}\n+\n+#[test]\n+fn item_map_smoke_test() {\n+    let (item_map, module_id) = item_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+\n+        use crate::foo::bar::Baz;\n+        <|>\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+    \",\n+    );\n+    let name = SmolStr::from(\"Baz\");\n+    let resolution = &item_map.per_module[&module_id].items[&name];\n+    assert!(resolution.def_id.is_some());\n+}\n+\n+#[test]\n+fn item_map_across_crates() {\n+    let (mut db, files) = MockDatabase::with_files(\n+        \"\n+        //- /main.rs\n+        use test_crate::Baz;\n+\n+        //- /lib.rs\n+        pub struct Baz;\n+    \",\n+    );\n+    let main_id = files.file_id(\"/main.rs\");\n+    let lib_id = files.file_id(\"/lib.rs\");\n+\n+    let mut crate_graph = CrateGraph::default();\n+    let main_crate = crate_graph.add_crate_root(main_id);\n+    let lib_crate = crate_graph.add_crate_root(lib_id);\n+    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate);\n+\n+    db.set_crate_graph(crate_graph);\n+\n+    let source_root = db.file_source_root(main_id);\n+    let module = hir::source_binder::module_from_file_id(&db, main_id)\n+        .unwrap()\n+        .unwrap();\n+    let module_id = module.module_id;\n+    let item_map = db.item_map(source_root).unwrap();\n+\n+    let name = SmolStr::from(\"Baz\");\n+    let resolution = &item_map.per_module[&module_id].items[&name];\n+    assert!(resolution.def_id.is_some());\n+}\n+\n+#[test]\n+fn typing_inside_a_function_should_not_invalidate_item_map() {\n+    let (mut db, pos) = MockDatabase::with_position(\n+        \"\n+        //- /lib.rs\n+        mod foo;<|>\n+\n+        use crate::foo::bar::Baz;\n+\n+        fn foo() -> i32 {\n+            1 + 1\n+        }\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+    \",\n+    );\n+    let source_root = db.file_source_root(pos.file_id);\n+    {\n+        let events = db.log_executed(|| {\n+            db.item_map(source_root).unwrap();\n+        });\n+        assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n+    }\n+\n+    let new_text = \"\n+        mod foo;\n+\n+        use crate::foo::bar::Baz;\n+\n+        fn foo() -> i32 { 92 }\n+    \"\n+    .to_string();\n+\n+    db.query_mut(ra_db::FileTextQuery)\n+        .set(pos.file_id, Arc::new(new_text));\n+\n+    {\n+        let events = db.log_executed(|| {\n+            db.item_map(source_root).unwrap();\n+        });\n+        assert!(\n+            !format!(\"{:?}\", events).contains(\"_item_map\"),\n+            \"{:#?}\",\n+            events\n+        )\n+    }\n+}"}, {"sha": "37c4f9e4fc921aa9c6349e558fc124d90a56bc54", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -141,13 +141,8 @@ pub(super) fn item_map(\n             Ok((id, items))\n         })\n         .collect::<Cancelable<FxHashMap<_, _>>>()?;\n-    let resolver = Resolver {\n-        db: db,\n-        input: &input,\n-        source_root,\n-        module_tree,\n-        result: ItemMap::default(),\n-    };\n+\n+    let resolver = Resolver::new(db, &input, source_root, module_tree);\n     let res = resolver.resolve()?;\n     let elapsed = start.elapsed();\n     log::info!(\"item_map: {:?}\", elapsed);"}, {"sha": "cb91ada90ac6257ef7fba617701f8f85101236fd", "filename": "crates/ra_lsp_server/src/project_model.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -1,6 +1,5 @@\n use std::path::{Path, PathBuf};\n \n-use serde_derive::Serialize;\n use cargo_metadata::{metadata_run, CargoOpt};\n use ra_syntax::SmolStr;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -11,15 +10,22 @@ use crate::{\n     thread_watcher::{ThreadWatcher, Worker},\n };\n \n+/// `CargoWorksapce` represents the logical structure of, well, a Cargo\n+/// workspace. It pretty closely mirrors `cargo metadata` output.\n+///\n+/// Note that internally, rust analyzer uses a differnet structure:\n+/// `CrateGraph`. `CrateGraph` is lower-level: it knows only about the crates,\n+/// while this knows about `Pacakges` & `Targets`: purely cargo-related\n+/// concepts.\n #[derive(Debug, Clone)]\n pub struct CargoWorkspace {\n     packages: Vec<PackageData>,\n     targets: Vec<TargetData>,\n }\n \n-#[derive(Clone, Copy, Debug, Serialize)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Package(usize);\n-#[derive(Clone, Copy, Debug, Serialize)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Target(usize);\n \n #[derive(Debug, Clone)]\n@@ -28,6 +34,13 @@ struct PackageData {\n     manifest: PathBuf,\n     targets: Vec<Target>,\n     is_member: bool,\n+    dependencies: Vec<PackageDependency>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct PackageDependency {\n+    pub pkg: Package,\n+    pub name: SmolStr,\n }\n \n #[derive(Debug, Clone)]\n@@ -61,6 +74,12 @@ impl Package {\n     pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n         ws.pkg(self).is_member\n     }\n+    pub fn dependencies<'a>(\n+        self,\n+        ws: &'a CargoWorkspace,\n+    ) -> impl Iterator<Item = &'a PackageDependency> + 'a {\n+        ws.pkg(self).dependencies.iter()\n+    }\n }\n \n impl Target {\n@@ -106,6 +125,7 @@ impl CargoWorkspace {\n                 manifest: PathBuf::from(meta_pkg.manifest_path),\n                 targets: Vec::new(),\n                 is_member,\n+                dependencies: Vec::new(),\n             };\n             for meta_tgt in meta_pkg.targets {\n                 let tgt = Target(targets.len());\n@@ -119,6 +139,16 @@ impl CargoWorkspace {\n             }\n             packages.push(pkg_data)\n         }\n+        let resolve = meta.resolve.expect(\"metadata executed with deps\");\n+        for node in resolve.nodes {\n+            let source = pkg_by_id[&node.id];\n+            for id in node.dependencies {\n+                let target = pkg_by_id[&id];\n+                let name: SmolStr = packages[target.0].name.replace('-', \"_\").into();\n+                let dep = PackageDependency { name, pkg: target };\n+                packages[source.0].dependencies.push(dep);\n+            }\n+        }\n \n         Ok(CargoWorkspace { packages, targets })\n     }"}, {"sha": "ab4c2c8aad639f2b44c7ef2801e8c472fd76cc73", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=19f6cdcc034a2a91e6112a4ceb32e26413b0aa0d", "patch": "@@ -13,7 +13,7 @@ use failure::{bail, format_err};\n \n use crate::{\n     path_map::{PathMap, Root},\n-    project_model::CargoWorkspace,\n+    project_model::{CargoWorkspace, TargetKind},\n     vfs::{FileEvent, FileEventKind},\n     Result,\n };\n@@ -142,17 +142,34 @@ impl ServerWorldState {\n     }\n     pub fn set_workspaces(&mut self, ws: Vec<CargoWorkspace>) {\n         let mut crate_graph = CrateGraph::default();\n-        ws.iter()\n-            .flat_map(|ws| {\n-                ws.packages()\n-                    .flat_map(move |pkg| pkg.targets(ws))\n-                    .map(move |tgt| tgt.root(ws))\n-            })\n-            .for_each(|root| {\n-                if let Some(file_id) = self.path_map.get_id(root) {\n-                    crate_graph.add_crate_root(file_id);\n+        let mut pkg_to_lib_crate = FxHashMap::default();\n+        let mut pkg_crates = FxHashMap::default();\n+        for ws in ws.iter() {\n+            for pkg in ws.packages() {\n+                for tgt in pkg.targets(ws) {\n+                    let root = tgt.root(ws);\n+                    if let Some(file_id) = self.path_map.get_id(root) {\n+                        let crate_id = crate_graph.add_crate_root(file_id);\n+                        if tgt.kind(ws) == TargetKind::Lib {\n+                            pkg_to_lib_crate.insert(pkg, crate_id);\n+                        }\n+                        pkg_crates\n+                            .entry(pkg)\n+                            .or_insert_with(Vec::new)\n+                            .push(crate_id);\n+                    }\n+                }\n+            }\n+            for pkg in ws.packages() {\n+                for dep in pkg.dependencies(ws) {\n+                    if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                        for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                            crate_graph.add_dep(from, dep.name.clone(), to);\n+                        }\n+                    }\n                 }\n-            });\n+            }\n+        }\n         self.workspaces = Arc::new(ws);\n         let mut change = AnalysisChange::new();\n         change.set_crate_graph(crate_graph);"}]}