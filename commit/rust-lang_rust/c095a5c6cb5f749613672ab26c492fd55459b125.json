{"sha": "c095a5c6cb5f749613672ab26c492fd55459b125", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwOTVhNWM2Y2I1Zjc0OTYxMzY3MmFiMjZjNDkyZmQ1NTQ1OWIxMjU=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-12T02:23:15Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-13T02:31:13Z"}, "message": "dlist: Use a DoubleEndedIterator for .mut_iter() and .mut_rev_iter()\n\nUnify the mutable iterators too. Switch the ListInsertion trait to use\nmethod .insert_next() and .peek_next() for list mutation. .insert_next()\ninserts an element into the list that will not appear in iteration, of\ncourse; so the length of the iteration can not change during iteration.", "tree": {"sha": "5873ac27749640a6aa9d1541ba16c2765298a64b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5873ac27749640a6aa9d1541ba16c2765298a64b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c095a5c6cb5f749613672ab26c492fd55459b125", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c095a5c6cb5f749613672ab26c492fd55459b125", "html_url": "https://github.com/rust-lang/rust/commit/c095a5c6cb5f749613672ab26c492fd55459b125", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c095a5c6cb5f749613672ab26c492fd55459b125/comments", "author": null, "committer": null, "parents": [{"sha": "e1d5d1c049608cf182ddc91c98d9700089a35600", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d5d1c049608cf182ddc91c98d9700089a35600", "html_url": "https://github.com/rust-lang/rust/commit/e1d5d1c049608cf182ddc91c98d9700089a35600"}], "stats": {"total": 188, "additions": 109, "deletions": 79}, "files": [{"sha": "283a726988ba228651cf5c24e29ef8568e8a373d", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 109, "deletions": 79, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/c095a5c6cb5f749613672ab26c492fd55459b125/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c095a5c6cb5f749613672ab26c492fd55459b125/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=c095a5c6cb5f749613672ab26c492fd55459b125", "patch": "@@ -53,17 +53,11 @@ pub struct DListIterator<'self, T> {\n     priv nelem: uint,\n }\n \n-/// DList mutable iterator\n-pub struct MutForwardIterator<'self, T> {\n+/// Double-ended mutable DList iterator\n+pub struct MutDListIterator<'self, T> {\n     priv list: &'self mut DList<T>,\n-    priv curs: Rawlink<Node<T>>,\n-    priv nelem: uint,\n-}\n-\n-/// DList mutable reverse iterator\n-pub struct MutReverseIterator<'self, T> {\n-    priv list: &'self mut DList<T>,\n-    priv next: Rawlink<Node<T>>,\n+    priv head: Rawlink<Node<T>>,\n+    priv tail: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n@@ -279,13 +273,14 @@ impl<T> DList<T> {\n         {\n             let mut it = self.mut_iter();\n             loop {\n-                match it.next() {\n+                match it.peek_next() {\n                     None => break,\n-                    Some(x) => if f(x, &elt) { it.insert_before(elt); return }\n+                    Some(x) => if f(x, &elt) { break }\n                 }\n+                it.next();\n             }\n+            it.insert_next(elt);\n         }\n-        self.push_back(elt);\n     }\n \n     /// Merge DList `other` into this DList, using the function `f`.\n@@ -296,17 +291,16 @@ impl<T> DList<T> {\n     pub fn merge(&mut self, mut other: DList<T>, f: &fn(&T, &T) -> bool) {\n         {\n             let mut it = self.mut_iter();\n-            let mut elt = it.next();\n             loop {\n-                let take_a = match (&mut elt, other.front()) {\n-                    (_    , None) => return,\n-                    (&None, _   ) => break,\n-                    (&Some(ref mut x), Some(y)) => f(*x, y),\n+                let take_a = match (it.peek_next(), other.front()) {\n+                    (_   , None) => return,\n+                    (None, _   ) => break,\n+                    (Some(ref mut x), Some(y)) => f(*x, y),\n                 };\n                 if take_a {\n-                    elt = it.next()\n+                    it.next();\n                 } else {\n-                    it.insert_before(other.pop_front().unwrap());\n+                    it.insert_next(other.pop_front().unwrap());\n                 }\n             }\n         }\n@@ -325,13 +319,22 @@ impl<T> DList<T> {\n     }\n \n     /// Provide a forward iterator with mutable references\n-    pub fn mut_iter<'a>(&'a mut self) -> MutForwardIterator<'a, T> {\n-        MutForwardIterator{nelem: self.len(), list: self, curs: Rawlink::none()}\n+    pub fn mut_iter<'a>(&'a mut self) -> MutDListIterator<'a, T> {\n+        let head_raw = match self.list_head {\n+            Some(ref mut h) => Rawlink::some(*h),\n+            None => Rawlink::none(),\n+        };\n+        MutDListIterator{\n+            nelem: self.len(),\n+            head: head_raw,\n+            tail: self.list_tail,\n+            list: self\n+        }\n     }\n-\n     /// Provide a reverse iterator with mutable references\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> MutReverseIterator<'a, T> {\n-        MutReverseIterator{nelem: self.len(), list: self, next: self.list_tail}\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> InvertIterator<&'a mut T,\n+                                                MutDListIterator<'a, T>> {\n+        self.mut_iter().invert()\n     }\n \n \n@@ -392,31 +395,21 @@ impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n     }\n }\n \n-// MutForwardIterator is different because it implements ListInsertion,\n-// and can modify the list during traversal, used in insert_when and merge.\n-impl<'self, A> Iterator<&'self mut A> for MutForwardIterator<'self, A> {\n+impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self mut A> {\n-        match self.curs.resolve() {\n-            None => {\n-                match self.list.list_head {\n-                    None => None,\n-                    Some(ref mut head) => {\n-                        self.nelem -= 1;\n-                        self.curs = Rawlink::some(*head);\n-                        Some(&mut head.value)\n-                    }\n-                }\n-            }\n-            Some(curs) => {\n-                match curs.next {\n-                    None => None,\n-                    Some(ref mut head) => {\n-                        self.nelem -= 1;\n-                        self.curs = Rawlink::some(*head);\n-                        Some(&mut head.value)\n-                    }\n-                }\n+        if self.nelem == 0 {\n+            return None;\n+        }\n+        match self.head.resolve() {\n+            None => None,\n+            Some(next) => {\n+                self.nelem -= 1;\n+                self.head = match next.next {\n+                    Some(ref mut node) => Rawlink::some(&mut **node),\n+                    None => Rawlink::none(),\n+                };\n+                Some(&mut next.value)\n             }\n         }\n     }\n@@ -426,37 +419,39 @@ impl<'self, A> Iterator<&'self mut A> for MutForwardIterator<'self, A> {\n     }\n }\n \n-impl<'self, A> Iterator<&'self mut A> for MutReverseIterator<'self, A> {\n+impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self mut A> {\n-        match self.next.resolve() {\n+    fn next_back(&mut self) -> Option<&'self mut A> {\n+        if self.nelem == 0 {\n+            return None;\n+        }\n+        match self.tail.resolve() {\n             None => None,\n             Some(prev) => {\n                 self.nelem -= 1;\n-                self.next = prev.prev;\n+                self.tail = prev.prev;\n                 Some(&mut prev.value)\n             }\n         }\n     }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.nelem, Some(self.nelem))\n-    }\n }\n \n+\n /// Allow mutating the DList while iterating\n pub trait ListInsertion<A> {\n-    /// Insert `elt` just previous to the most recently yielded element\n-    fn insert_before(&mut self, elt: A);\n+    /// Insert `elt` just after to the most recently yielded element\n+    fn insert_next(&mut self, elt: A);\n \n     /// Provide a reference to the next element, without changing the iterator\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n \n-impl<'self, A> ListInsertion<A> for MutForwardIterator<'self, A> {\n-    fn insert_before(&mut self, elt: A) {\n-        match self.curs.resolve() {\n-            None => { self.list.push_front(elt); self.next(); }\n+impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n+    fn insert_next(&mut self, elt: A) {\n+        // Insert an element before `self.head` so that it is between the\n+        // previously yielded element and self.head.\n+        match self.head.resolve() {\n+            None => { self.list.push_back(elt); }\n             Some(node) => {\n                 let prev_node = match node.prev.resolve() {\n                     None => return self.list.push_front(elt),\n@@ -472,12 +467,9 @@ impl<'self, A> ListInsertion<A> for MutForwardIterator<'self, A> {\n     }\n \n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n-        match self.curs.resolve() {\n-            None => self.list.front_mut(),\n-            Some(curs) => match curs.next {\n-                None => None,\n-                Some(ref mut node) => Some(&mut node.value),\n-            }\n+        match self.head.resolve() {\n+            None => None,\n+            Some(head) => Some(&mut head.value),\n         }\n     }\n }\n@@ -680,6 +672,24 @@ mod tests {\n         assert_eq!(it.next(), None);\n     }\n \n+    #[test]\n+    fn test_iterator_double_end() {\n+        let mut n = DList::new();\n+        assert_eq!(n.iter().next(), None);\n+        n.push_front(4);\n+        n.push_front(5);\n+        n.push_front(6);\n+        let mut it = n.iter();\n+        assert_eq!(it.size_hint(), (3, Some(3)));\n+        assert_eq!(it.next().unwrap(), &6);\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n+        assert_eq!(it.next_back().unwrap(), &4);\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next_back().unwrap(), &5);\n+        assert_eq!(it.next_back(), None);\n+        assert_eq!(it.next(), None);\n+    }\n+\n     #[test]\n     fn test_rev_iter() {\n         let m = generate_test();\n@@ -708,38 +718,58 @@ mod tests {\n         let mut n = DList::new();\n         assert!(n.mut_iter().next().is_none());\n         n.push_front(4);\n+        n.push_back(5);\n         let mut it = n.mut_iter();\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n+        assert!(it.next().is_some());\n         assert!(it.next().is_some());\n         assert_eq!(it.size_hint(), (0, Some(0)));\n         assert!(it.next().is_none());\n     }\n \n+    #[test]\n+    fn test_iterator_mut_double_end() {\n+        let mut n = DList::new();\n+        assert!(n.mut_iter().next_back().is_none());\n+        n.push_front(4);\n+        n.push_front(5);\n+        n.push_front(6);\n+        let mut it = n.mut_iter();\n+        assert_eq!(it.size_hint(), (3, Some(3)));\n+        assert_eq!(*it.next().unwrap(), 6);\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n+        assert_eq!(*it.next_back().unwrap(), 4);\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(*it.next_back().unwrap(), 5);\n+        assert!(it.next_back().is_none());\n+        assert!(it.next().is_none());\n+    }\n+\n     #[test]\n     fn test_insert_prev() {\n         let mut m = list_from(&[0,2,4,6,8]);\n         let len = m.len();\n         {\n             let mut it = m.mut_iter();\n-            it.insert_before(-2);\n+            it.insert_next(-2);\n             loop {\n                 match it.next() {\n                     None => break,\n                     Some(elt) => {\n-                        it.insert_before(*elt + 1);\n+                        it.insert_next(*elt + 1);\n                         match it.peek_next() {\n                             Some(x) => assert_eq!(*x, *elt + 2),\n                             None => assert_eq!(8, *elt),\n                         }\n                     }\n                 }\n             }\n-            it.insert_before(0);\n-            it.insert_before(1);\n+            it.insert_next(0);\n+            it.insert_next(1);\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.consume_iter().collect::<~[int]>(), ~[-2,1,0,3,2,5,4,7,6,9,0,1,8]);\n+        assert_eq!(m.consume_iter().collect::<~[int]>(), ~[-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n     #[test]\n@@ -853,7 +883,7 @@ mod tests {\n     fn bench_collect_into(b: &mut test::BenchHarness) {\n         let v = &[0, ..64];\n         do b.iter {\n-            let _: DList<int> = v.iter().transform(|&x|x).collect();\n+            let _: DList<int> = v.iter().transform(|x| *x).collect();\n         }\n     }\n     #[bench]\n@@ -917,31 +947,31 @@ mod tests {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n-            for m.iter().advance |_| {}\n+            assert!(m.iter().len_() == 128);\n         }\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n-            for m.mut_iter().advance |_| {}\n+            assert!(m.mut_iter().len_() == 128);\n         }\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n-            for m.rev_iter().advance |_| {}\n+            assert!(m.rev_iter().len_() == 128);\n         }\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n-            for m.mut_rev_iter().advance |_| {}\n+            assert!(m.mut_rev_iter().len_() == 128);\n         }\n     }\n     #[bench]"}]}