{"sha": "2a827635ba65e3d40af8643373e4584858eecc7d", "node_id": "C_kwDOAAsO6NoAKDJhODI3NjM1YmE2NWUzZDQwYWY4NjQzMzczZTQ1ODQ4NThlZWNjN2Q", "commit": {"author": {"name": "Declan Kelly", "email": "dkelly.home@gmail.com", "date": "2022-04-01T07:19:10Z"}, "committer": {"name": "Declan Kelly", "email": "dkelly.home@gmail.com", "date": "2022-04-01T07:23:09Z"}, "message": "Implement provenance preserving method on NonNull\n\n**Description**\n Add the `addr`, `with_addr, `map_addr` methods to the `NonNull` type,\n and map the address type to `NonZeroUsize`.\n\n **Motiviation**\n The `NonNull` type is useful for implementing pointer types which have\n the 0-niche. It is currently possible to implement these provenance\n preserving functions by calling `NonNull::as_ptr` and `new_unchecked`.\n The addition of these methods simply make it more ergonomic to use.\n\n **Testing**\n Added a unit test of a nonnull tagged pointer type. This is based on\n some real code I have elsewhere, that currently routes the pointer\n through a `NonZeroUsize` and back out to produce a usable pointer.", "tree": {"sha": "391d17d9099b9f37cecb5ad58e2fb3b58691a947", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/391d17d9099b9f37cecb5ad58e2fb3b58691a947"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a827635ba65e3d40af8643373e4584858eecc7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a827635ba65e3d40af8643373e4584858eecc7d", "html_url": "https://github.com/rust-lang/rust/commit/2a827635ba65e3d40af8643373e4584858eecc7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a827635ba65e3d40af8643373e4584858eecc7d/comments", "author": {"login": "declanvk", "id": 7276122, "node_id": "MDQ6VXNlcjcyNzYxMjI=", "avatar_url": "https://avatars.githubusercontent.com/u/7276122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/declanvk", "html_url": "https://github.com/declanvk", "followers_url": "https://api.github.com/users/declanvk/followers", "following_url": "https://api.github.com/users/declanvk/following{/other_user}", "gists_url": "https://api.github.com/users/declanvk/gists{/gist_id}", "starred_url": "https://api.github.com/users/declanvk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/declanvk/subscriptions", "organizations_url": "https://api.github.com/users/declanvk/orgs", "repos_url": "https://api.github.com/users/declanvk/repos", "events_url": "https://api.github.com/users/declanvk/events{/privacy}", "received_events_url": "https://api.github.com/users/declanvk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "declanvk", "id": 7276122, "node_id": "MDQ6VXNlcjcyNzYxMjI=", "avatar_url": "https://avatars.githubusercontent.com/u/7276122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/declanvk", "html_url": "https://github.com/declanvk", "followers_url": "https://api.github.com/users/declanvk/followers", "following_url": "https://api.github.com/users/declanvk/following{/other_user}", "gists_url": "https://api.github.com/users/declanvk/gists{/gist_id}", "starred_url": "https://api.github.com/users/declanvk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/declanvk/subscriptions", "organizations_url": "https://api.github.com/users/declanvk/orgs", "repos_url": "https://api.github.com/users/declanvk/repos", "events_url": "https://api.github.com/users/declanvk/events{/privacy}", "received_events_url": "https://api.github.com/users/declanvk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0677edc86e342f333d4828b0ee1ef395a4e70fe5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0677edc86e342f333d4828b0ee1ef395a4e70fe5", "html_url": "https://github.com/rust-lang/rust/commit/0677edc86e342f333d4828b0ee1ef395a4e70fe5"}], "stats": {"total": 127, "additions": 127, "deletions": 0}, "files": [{"sha": "7516d4bba4cdfcd98a6d94c08eb65785879a571c", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2a827635ba65e3d40af8643373e4584858eecc7d/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a827635ba65e3d40af8643373e4584858eecc7d/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=2a827635ba65e3d40af8643373e4584858eecc7d", "patch": "@@ -4,6 +4,7 @@ use crate::fmt;\n use crate::hash;\n use crate::marker::Unsize;\n use crate::mem::{self, MaybeUninit};\n+use crate::num::NonZeroUsize;\n use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n use crate::slice::{self, SliceIndex};\n@@ -253,6 +254,53 @@ impl<T: ?Sized> NonNull<T> {\n         (self.cast(), super::metadata(self.as_ptr()))\n     }\n \n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn addr(self) -> NonZeroUsize\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: The pointer is guaranteed by the type to be non-null,\n+        // meaning that the address will be non-zero.\n+        unsafe { NonZeroUsize::new_unchecked(self.pointer.addr()) }\n+    }\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn with_addr(self, addr: NonZeroUsize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: The result of `ptr::from::with_addr` is non-null because `addr` is guaranteed to be non-zero.\n+        unsafe { NonNull::new_unchecked(self.pointer.with_addr(addr.get()) as *mut _) }\n+    }\n+\n+    /// Creates a new pointer by mapping `self`'s address to a new one.\n+    ///\n+    /// This is a convenience for [`with_addr`][Self::with_addr], see that method for details.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn map_addr(self, f: impl FnOnce(NonZeroUsize) -> NonZeroUsize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        self.with_addr(f(self.addr()))\n+    }\n+\n     /// Acquires the underlying `*mut` pointer.\n     ///\n     /// # Examples"}, {"sha": "42d31c44deee7ac15ee170309268c8b93f082c60", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a827635ba65e3d40af8643373e4584858eecc7d/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a827635ba65e3d40af8643373e4584858eecc7d/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=2a827635ba65e3d40af8643373e4584858eecc7d", "patch": "@@ -87,6 +87,7 @@\n #![feature(int_roundings)]\n #![feature(slice_group_by)]\n #![feature(split_array)]\n+#![feature(strict_provenance)]\n #![feature(trusted_random_access)]\n #![feature(unsize)]\n #![feature(unzip_option)]"}, {"sha": "75857e29ae1cdb5ec628040991def534bf804cb4", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2a827635ba65e3d40af8643373e4584858eecc7d/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a827635ba65e3d40af8643373e4584858eecc7d/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=2a827635ba65e3d40af8643373e4584858eecc7d", "patch": "@@ -1,4 +1,5 @@\n use core::cell::RefCell;\n+use core::num::NonZeroUsize;\n use core::ptr;\n use core::ptr::*;\n use std::fmt::{Debug, Display};\n@@ -691,3 +692,80 @@ fn thin_box() {\n         }\n     }\n }\n+\n+#[test]\n+fn nonnull_tagged_pointer_with_provenance() {\n+    let raw_pointer = Box::into_raw(Box::new(10));\n+\n+    let mut p = TaggedPointer::new(raw_pointer).unwrap();\n+    assert_eq!(p.tag(), 0);\n+\n+    p.set_tag(1);\n+    assert_eq!(p.tag(), 1);\n+    assert_eq!(unsafe { *p.pointer().as_ptr() }, 10);\n+\n+    p.set_tag(3);\n+    assert_eq!(p.tag(), 3);\n+    assert_eq!(unsafe { *p.pointer().as_ptr() }, 10);\n+\n+    unsafe { Box::from_raw(p.pointer().as_ptr()) };\n+\n+    /// A non-null pointer type which carries several bits of metadata and maintains provenance.\n+    #[repr(transparent)]\n+    pub struct TaggedPointer<T>(NonNull<T>);\n+\n+    impl<T> Clone for TaggedPointer<T> {\n+        fn clone(&self) -> Self {\n+            Self(self.0)\n+        }\n+    }\n+\n+    impl<T> Copy for TaggedPointer<T> {}\n+\n+    impl<T> TaggedPointer<T> {\n+        /// The ABI-required minimum alignment of the `P` type.\n+        pub const ALIGNMENT: usize = core::mem::align_of::<T>();\n+        /// A mask for data-carrying bits of the address.\n+        pub const DATA_MASK: usize = !Self::ADDRESS_MASK;\n+        /// Number of available bits of storage in the address.\n+        pub const NUM_BITS: u32 = Self::ALIGNMENT.trailing_zeros();\n+        /// A mask for the non-data-carrying bits of the address.\n+        pub const ADDRESS_MASK: usize = usize::MAX << Self::NUM_BITS;\n+\n+        /// Create a new tagged pointer from a possibly null pointer.\n+        pub fn new(pointer: *mut T) -> Option<TaggedPointer<T>> {\n+            Some(TaggedPointer(NonNull::new(pointer)?))\n+        }\n+\n+        /// Consume this tagged pointer and produce a raw mutable pointer to the\n+        /// memory location.\n+        pub fn pointer(self) -> NonNull<T> {\n+            // SAFETY: The `addr` guaranteed to have bits set in the Self::ADDRESS_MASK, so the result will be non-null.\n+            self.0.map_addr(|addr| unsafe {\n+                NonZeroUsize::new_unchecked(addr.get() & Self::ADDRESS_MASK)\n+            })\n+        }\n+\n+        /// Consume this tagged pointer and produce the data it carries.\n+        pub fn tag(&self) -> usize {\n+            self.0.addr().get() & Self::DATA_MASK\n+        }\n+\n+        /// Update the data this tagged pointer carries to a new value.\n+        pub fn set_tag(&mut self, data: usize) {\n+            assert_eq!(\n+                data & Self::ADDRESS_MASK,\n+                0,\n+                \"cannot set more data beyond the lowest NUM_BITS\"\n+            );\n+            let data = data & Self::DATA_MASK;\n+\n+            // SAFETY: This value will always be non-zero because the upper bits (from\n+            // ADDRESS_MASK) will always be non-zero. This a property of the type and its\n+            // construction.\n+            self.0 = self.0.map_addr(|addr| unsafe {\n+                NonZeroUsize::new_unchecked((addr.get() & Self::ADDRESS_MASK) | data)\n+            })\n+        }\n+    }\n+}"}]}