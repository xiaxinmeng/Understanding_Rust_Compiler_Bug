{"sha": "e825e21e7adc5573bb8f19c5fa104ef666398746", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MjVlMjFlN2FkYzU1NzNiYjhmMTljNWZhMTA0ZWY2NjYzOTg3NDY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-21T20:00:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-21T20:00:49Z"}, "message": "Rollup merge of #65621 - RalfJung:write_bytes, r=oli-obk\n\nmiri: add write_bytes method to Memory doing bounds-checks and supporting iterators\n\nThis lets us avoid some direct `Allocation` accesses in Miri.", "tree": {"sha": "79b82c39fcf77356c0228f0398660bff698e2d91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79b82c39fcf77356c0228f0398660bff698e2d91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e825e21e7adc5573bb8f19c5fa104ef666398746", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdrg5xCRBK7hj4Ov3rIwAAdHIIAFNCmkhpA5OXsK2tRJFASsCG\nddUP9HKlgL/0EKinVb3wXIPsIutJEfivXwJa5gnjkJjtQTBFIoqu759EvlxcHLQr\nq9JXWVrWE+M7gEnSt1R2jCQFKOmtWEc2Rqpjk/QiUE8QY5ukojNujrf03KSojF/2\nnU25etnnTL1lVDDn9NU7tTq6sG/AzqG2RlGe26yx3INpCLIyzBNBoUQ0DufQXVeF\nZfauMdrFpty+i7t5sVN7T+s/x1wAHuGKqgpwJdNEr/yIJpgOAcen0pwlx28EeTlV\n1qNc3Y+UsmlrG8ue4DeTpNof1yfgJIo9fr9Tka8+rzmhacD2QcXj9BbNnWNwV1E=\n=e95n\n-----END PGP SIGNATURE-----\n", "payload": "tree 79b82c39fcf77356c0228f0398660bff698e2d91\nparent a160258927804710e8732ec1ec655160489f460f\nparent f6d70b42b8d6d299fe5621ac9170f69c511c8ddc\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571688049 +0200\ncommitter GitHub <noreply@github.com> 1571688049 +0200\n\nRollup merge of #65621 - RalfJung:write_bytes, r=oli-obk\n\nmiri: add write_bytes method to Memory doing bounds-checks and supporting iterators\n\nThis lets us avoid some direct `Allocation` accesses in Miri.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e825e21e7adc5573bb8f19c5fa104ef666398746", "html_url": "https://github.com/rust-lang/rust/commit/e825e21e7adc5573bb8f19c5fa104ef666398746", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e825e21e7adc5573bb8f19c5fa104ef666398746/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a160258927804710e8732ec1ec655160489f460f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a160258927804710e8732ec1ec655160489f460f", "html_url": "https://github.com/rust-lang/rust/commit/a160258927804710e8732ec1ec655160489f460f"}, {"sha": "f6d70b42b8d6d299fe5621ac9170f69c511c8ddc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d70b42b8d6d299fe5621ac9170f69c511c8ddc", "html_url": "https://github.com/rust-lang/rust/commit/f6d70b42b8d6d299fe5621ac9170f69c511c8ddc"}], "stats": {"total": 59, "additions": 39, "deletions": 20}, "files": [{"sha": "3b0ac9ada8f65894e7cc52fbcbd6f0c73e3fd6fa", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e825e21e7adc5573bb8f19c5fa104ef666398746/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e825e21e7adc5573bb8f19c5fa104ef666398746/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e825e21e7adc5573bb8f19c5fa104ef666398746", "patch": "@@ -43,6 +43,7 @@\n #![feature(nll)]\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n+#![feature(option_expect_none)]\n #![feature(range_is_empty)]\n #![feature(slice_patterns)]\n #![feature(specialization)]"}, {"sha": "796d293e2c63cb72c1e05c32ed6c3a6618ef819b", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e825e21e7adc5573bb8f19c5fa104ef666398746/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e825e21e7adc5573bb8f19c5fa104ef666398746/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=e825e21e7adc5573bb8f19c5fa104ef666398746", "patch": "@@ -245,6 +245,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// as a slice.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n+    /// on `InterpCx` instead.\n     #[inline]\n     pub fn get_bytes(\n         &self,\n@@ -275,6 +277,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// so be sure to actually put data there!\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n+    /// on `InterpCx` instead.\n     pub fn get_bytes_mut(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -297,6 +301,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n+    ///\n+    /// Most likely, you want to call `Memory::read_c_str` instead of this method.\n     pub fn read_c_str(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -342,33 +348,22 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Writes `src` to the memory starting at `ptr.offset`.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `Memory::write_bytes` instead of this method.\n     pub fn write_bytes(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        src: &[u8],\n+        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n     ) -> InterpResult<'tcx>\n     {\n+        let mut src = src.into_iter();\n         let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n-        bytes.clone_from_slice(src);\n-        Ok(())\n-    }\n-\n-    /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    pub fn write_repeat(\n-        &mut self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        val: u8,\n-        count: Size\n-    ) -> InterpResult<'tcx>\n-    {\n-        let bytes = self.get_bytes_mut(cx, ptr, count)?;\n-        for b in bytes {\n-            *b = val;\n+        // `zip` would stop when the first iterator ends; we want to definitely\n+        // cover all of `bytes`.\n+        for dest in bytes {\n+            *dest = src.next().expect(\"iterator was shorter than it said it would be\");\n         }\n+        src.next().expect_none(\"iterator was longer than it said it would be\");\n         Ok(())\n     }\n \n@@ -380,6 +375,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::read_scalar` instead of this method.\n     pub fn read_scalar(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -418,6 +414,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::read_scalar` instead of this method.\n     pub fn read_ptr_sized(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -435,6 +432,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -477,6 +475,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Writes a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n     pub fn write_ptr_sized(\n         &mut self,\n         cx: &impl HasDataLayout,"}, {"sha": "0b65e9742b6a5d1a347ccbaf3c0d9f9a66a44168", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e825e21e7adc5573bb8f19c5fa104ef666398746/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e825e21e7adc5573bb8f19c5fa104ef666398746/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=e825e21e7adc5573bb8f19c5fa104ef666398746", "patch": "@@ -7,7 +7,7 @@\n //! short-circuiting the empty case!\n \n use std::collections::VecDeque;\n-use std::ptr;\n+use std::{ptr, iter};\n use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n@@ -785,6 +785,25 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.get(ptr.alloc_id)?.read_c_str(self, ptr)\n     }\n \n+    /// Writes the given stream of bytes into memory.\n+    ///\n+    /// Performs appropriate bounds checks.\n+    pub fn write_bytes(\n+        &mut self,\n+        ptr: Scalar<M::PointerTag>,\n+        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n+    ) -> InterpResult<'tcx>\n+    {\n+        let src = src.into_iter();\n+        let size = Size::from_bytes(src.len() as u64);\n+        let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n+            Some(ptr) => ptr,\n+            None => return Ok(()), // zero-sized access\n+        };\n+        let tcx = self.tcx.tcx;\n+        self.get_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n+    }\n+\n     /// Expects the caller to have checked bounds and alignment.\n     pub fn copy(\n         &mut self,"}]}