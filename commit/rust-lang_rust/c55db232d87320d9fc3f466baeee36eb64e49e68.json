{"sha": "c55db232d87320d9fc3f466baeee36eb64e49e68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NWRiMjMyZDg3MzIwZDlmYzNmNDY2YmFlZWUzNmViNjRlNDllNjg=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-07-09T06:37:37Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-07-09T07:32:04Z"}, "message": "Cleanup and code comments", "tree": {"sha": "aa8a64f7df46bb944e65b146106730138be8aa9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa8a64f7df46bb944e65b146106730138be8aa9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c55db232d87320d9fc3f466baeee36eb64e49e68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c55db232d87320d9fc3f466baeee36eb64e49e68", "html_url": "https://github.com/rust-lang/rust/commit/c55db232d87320d9fc3f466baeee36eb64e49e68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c55db232d87320d9fc3f466baeee36eb64e49e68/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4f28ca61139bf06153d20b4cc60ac6c5552234a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f28ca61139bf06153d20b4cc60ac6c5552234a", "html_url": "https://github.com/rust-lang/rust/commit/c4f28ca61139bf06153d20b4cc60ac6c5552234a"}], "stats": {"total": 73, "additions": 39, "deletions": 34}, "files": [{"sha": "6360eccb6f6f81e5f2aa8c6d01f44953a7f492cd", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c55db232d87320d9fc3f466baeee36eb64e49e68/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55db232d87320d9fc3f466baeee36eb64e49e68/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=c55db232d87320d9fc3f466baeee36eb64e49e68", "patch": "@@ -148,9 +148,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             fcx: self,\n             closure_def_id,\n             closure_span: span,\n-            capture_clause,\n-            _current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n-            _current_origin: None,\n             capture_information: Default::default(),\n             fake_reads: Default::default(),\n         };\n@@ -309,6 +306,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n+    /// Adjusts the closure capture information to ensure that the operations aren't unasfe,\n+    /// and that the path can be captured with required capture kind (depending on use in closure,\n+    /// move closure etc.)\n+    ///\n+    /// Returns the set of of adjusted information along with the inferred closure kind and span\n+    /// associated with the closure kind inference.\n+    ///\n+    /// Note that we *always* infer a minimal kind, even if\n+    /// we don't always *use* that in the final result (i.e., sometimes\n+    /// we've taken the closure kind from the expectations instead, and\n+    /// for generators we don't even implement the closure traits\n+    /// really).\n+    ///\n+    /// If we inferred that the closure needs to be FnMut/FnOnce, last element of the returned tuplle\n+    /// contains a `Some()` with the `Place` that caused us to do so.\n     fn process_collected_capture_information(\n         &self,\n         capture_clause: hir::CaptureBy,\n@@ -320,7 +332,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut origin: Option<(Span, Place<'tcx>)> = None;\n \n         for (place, mut capture_info) in capture_information.into_iter() {\n-            let place = restrict_capture_precision(capture_clause, place);\n+            // Apply rules for safety before inferring closure kind\n+            let place = restrict_capture_precision(place);\n+\n             let usage_span = if let Some(usage_expr) = capture_info.path_expr_id {\n                 self.tcx.hir().span(usage_expr)\n             } else {\n@@ -356,8 +370,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             origin = updated.1;\n \n             let (place, capture_kind) = match capture_clause {\n-                hir::CaptureBy::Value => process_for_move(place, capture_info.capture_kind),\n-                hir::CaptureBy::Ref => process_for_ref(place, capture_info.capture_kind),\n+                hir::CaptureBy::Value => adjust_for_move_closure(place, capture_info.capture_kind),\n+                hir::CaptureBy::Ref => {\n+                    adjust_for_non_move_closure(place, capture_info.capture_kind)\n+                }\n             };\n \n             capture_info.capture_kind = capture_kind;\n@@ -1386,20 +1402,6 @@ struct InferBorrowKind<'a, 'tcx> {\n \n     closure_span: Span,\n \n-    capture_clause: hir::CaptureBy,\n-\n-    // The kind that we have inferred that the current closure\n-    // requires. Note that we *always* infer a minimal kind, even if\n-    // we don't always *use* that in the final result (i.e., sometimes\n-    // we've taken the closure kind from the expectations instead, and\n-    // for generators we don't even implement the closure traits\n-    // really).\n-    _current_closure_kind: ty::ClosureKind,\n-\n-    // If we modified `current_closure_kind`, this field contains a `Some()` with the\n-    // variable access that caused us to do so.\n-    _current_origin: Option<(Span, Place<'tcx>)>,\n-\n     /// For each Place that is captured by the closure, we track the minimal kind of\n     /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n     ///\n@@ -1442,7 +1444,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, mode\n         );\n \n-        // AMAN: Don't upgrade copy types to ByValue\n+        // Copy type being used as ByValue are equivalent to ImmBorrow and don't require any\n+        // escalation.\n         match mode {\n             euv::ConsumeMode::Copy => return,\n             euv::ConsumeMode::Move => {}\n@@ -1589,8 +1592,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n \n-            // AMAN: Always initialize to ImmBorrow\n-            // We will increase the CaptureKind in process_collected_capture_information.\n+            // Initialize to ImmBorrow\n+            // We will escalate the CaptureKind based on any uses we see or in `process_collected_capture_information`.\n             let origin = UpvarRegion(upvar_id, self.closure_span);\n             let upvar_region = self.fcx.next_region_var(origin);\n             let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n@@ -1617,7 +1620,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(_) = place.base {\n             // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n             // such as deref of a raw pointer.\n-            let place = restrict_capture_precision(self.capture_clause, place);\n+            let place = restrict_capture_precision(place);\n             let place =\n                 restrict_repr_packed_field_ref_capture(self.fcx.tcx, self.fcx.param_env, &place);\n             self.fake_reads.push((place, cause, diag_expr_id));\n@@ -1659,7 +1662,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         );\n \n         // We only want repr packed restriction to be applied to reading references into a packed\n-        // struct, and not when the data is being moved. There for we call this method here instead\n+        // struct, and not when the data is being moved. Therefore we call this method here instead\n         // of in `restrict_capture_precision`.\n         let place = restrict_repr_packed_field_ref_capture(\n             self.fcx.tcx,\n@@ -1697,10 +1700,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No Index projections are captured, since arrays are captured completely.\n-fn restrict_capture_precision<'tcx>(\n-    _capture_clause: hir::CaptureBy,\n-    mut place: Place<'tcx>,\n-) -> Place<'tcx> {\n+fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n     if place.projections.is_empty() {\n         // Nothing to do here\n         return place;\n@@ -1738,19 +1738,22 @@ fn restrict_capture_precision<'tcx>(\n     place\n }\n \n-fn process_for_move<'tcx>(\n+/// Take ownership if data being accessed is owned by the variable used to access it\n+/// (or if closure attempts to move data that it doesn\u2019t own).\n+/// Note: When taking ownership, only capture data found on the stack.\n+fn adjust_for_move_closure<'tcx>(\n     mut place: Place<'tcx>,\n     kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let contains_deref_of_ref = place.deref_tys().any(|ty| ty.is_ref());\n+    let first_deref = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n+\n     match kind {\n         ty::UpvarCapture::ByRef(..) if contains_deref_of_ref => (place, kind),\n \n         // If there's any Deref and the data needs to be moved into the closure body,\n         // or it's a Deref of a Box, truncate the path to the first deref\n-        _ if place.deref_tys().next().is_some() => {\n-            let first_deref =\n-                place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n+        _ if first_deref.is_some() => {\n             let place = match first_deref {\n                 Some(idx) => {\n                     place.projections.truncate(idx);\n@@ -1768,7 +1771,9 @@ fn process_for_move<'tcx>(\n     }\n }\n \n-fn process_for_ref<'tcx>(\n+/// Adjust closure capture just that if taking ownership of data, only move data\n+/// from enclosing stack frame.\n+fn adjust_for_non_move_closure<'tcx>(\n     mut place: Place<'tcx>,\n     kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {"}]}