{"sha": "afb3980f29a1a23cf6510b4e6132dbcaa2fd837c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYjM5ODBmMjlhMWEyM2NmNjUxMGI0ZTYxMzJkYmNhYTJmZDgzN2M=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-04T08:50:51Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-04T08:50:51Z"}, "message": "tutorial: More improvements to closure section", "tree": {"sha": "55a75fbff6aa4380b829ccce214127773a320aec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55a75fbff6aa4380b829ccce214127773a320aec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afb3980f29a1a23cf6510b4e6132dbcaa2fd837c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afb3980f29a1a23cf6510b4e6132dbcaa2fd837c", "html_url": "https://github.com/rust-lang/rust/commit/afb3980f29a1a23cf6510b4e6132dbcaa2fd837c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afb3980f29a1a23cf6510b4e6132dbcaa2fd837c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f06a8c8d5e9bdb8ac466134bee2e69978cd3a2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f06a8c8d5e9bdb8ac466134bee2e69978cd3a2e", "html_url": "https://github.com/rust-lang/rust/commit/3f06a8c8d5e9bdb8ac466134bee2e69978cd3a2e"}], "stats": {"total": 100, "additions": 63, "deletions": 37}, "files": [{"sha": "e7558368b59ca366e2ba594ad40ac67b4b387e96", "filename": "doc/tutorial.md", "status": "modified", "additions": 63, "deletions": 37, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/afb3980f29a1a23cf6510b4e6132dbcaa2fd837c/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/afb3980f29a1a23cf6510b4e6132dbcaa2fd837c/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=afb3980f29a1a23cf6510b4e6132dbcaa2fd837c", "patch": "@@ -1012,67 +1012,90 @@ call_twice(bare_function);\n \n ### Do syntax\n \n-Because closures in Rust are frequently used in combination with\n-higher-order functions to simulate control structures like `if` and\n-`loop`. For example, this one iterates over a vector of integers\n-backwards:\n+Closures in Rust are frequently used in combination with higher-order\n+functions to simulate control structures like `if` and\n+`loop`. Consider this function that iterates over a vector of\n+integers, applying an operator to each:\n \n ~~~~\n-fn for_rev(v: ~[int], act: fn(int)) {\n-    let mut i = vec::len(v);\n-    while (i > 0u) {\n-        i -= 1u;\n-        act(v[i]);\n-    }\n+fn each(v: ~[int], op: fn(int)) {\n+   let mut n = 0;\n+   while n < v.len() {\n+       op(v[n]);\n+       n += 1;\n+   }\n }\n ~~~~\n \n-To run such an iteration on a block of code, you could call\n-it with a closure containing a block of code.\n+As a caller, if we use a closure to provide the final operator\n+argument, we can write it in a way that has a pleasant, block-like\n+structure.\n \n ~~~~\n-# fn for_rev(v: ~[int], act: fn(int)) {}\n+# fn each(v: ~[int], op: fn(int)) {}\n # fn do_some_work(i: int) { }\n-for_rev(~[1, 2, 3], |n| {\n+each(~[1, 2, 3], |n| {\n     #debug(\"%i\", n);\n     do_some_work(n);\n });\n ~~~~\n \n-Because this is such a common pattern Rust has a special form\n-of function call that can be written more like a built-in control\n-structure:\n+This is such a useful pattern that Rust has a special form of function\n+call that can be written more like a built-in control structure:\n \n ~~~~\n-# fn for_rev(v: [int], act: fn(int)) {}\n+# fn each(v: ~[int], op: fn(int)) {}\n # fn do_some_work(i: int) { }\n-do for_rev(~[1, 2, 3]) |n| {\n+do each(~[1, 2, 3]) |n| {\n     #debug(\"%i\", n);\n     do_some_work(n);\n }\n ~~~~\n \n-Notice that the call is prefixed with the keyword `do` and, instead of\n-writing the final closure inside the argument list it is moved outside\n-of the parenthesis where it looks visually more like a typical block\n-of code. The `do` expression is purely syntactic sugar for a call\n-that takes a final closure argument.\n+The call is prefixed with the keyword `do` and, instead of writing the\n+final closure inside the argument list it is moved outside of the\n+parenthesis where it looks visually more like a typical block of\n+code. The `do` expression is purely syntactic sugar for a call that\n+takes a final closure argument.\n+\n+`do` is often used for task spawning.\n+\n+~~~~\n+import task::spawn;\n+\n+do spawn() || {\n+    #debug(\"I'm a task, whatever\");\n+}\n+~~~~\n+\n+That's nice, but look at all those bars and parentheses - that's two empty\n+argument lists back to back. Wouldn't it be great if they weren't\n+there?\n+\n+~~~~\n+# import task::spawn;\n+do spawn {\n+   #debug(\"Kablam!\");\n+}\n+~~~~\n+\n+Empty argument lists can be omitted from `do` expressions.\n \n ### For loops\n \n-`for` loops, like `do` expressions, allow functions to be used as\n-as control structures. `for` loops can be used to treat functions\n-with the proper signature as looping constructs, supporting\n-`break`, `cont` and early returns.\n+Most iteration in Rust is done with `for` loops. Like `do`,\n+`for` is a nice syntax for doing control flow with closures.\n+Additionally, within a `for` loop, `break, `cont`, and `ret`\n+work just as they do with `while` and `loop`.\n \n-Take for example this `each` function that iterates over a vector,\n-breaking early when the iteratee returns `false`:\n+Consider again our `each` function, this time improved to\n+break early when the iteratee returns `false`:\n \n ~~~~\n-fn each<T>(v: &[T], f: fn(T) -> bool) {\n+fn each(v: ~[int], op: fn(int) -> bool) {\n    let mut n = 0;\n    while n < v.len() {\n-       if !f(v[n]) {\n+       if !op(v[n]) {\n            break;\n        }\n        n += 1;\n@@ -1093,10 +1116,11 @@ each(~[2, 4, 8, 5, 16], |n| {\n });\n ~~~~\n \n-You can see how that gets noisy. As a syntactic convenience, if the\n-call is preceded by the keyword `for`, the block will implicitly\n-return `true`, and `break` and `cont` can be used, much like in a\n-`while` loop, to explicitly return `false` or `true`.\n+With `for`, functions like `each` can be treated more\n+like builtin looping structures. When calling `each`\n+in a `for` loop, instead of returning `false` to break\n+out of the loop, you just write `break`. To continue\n+to the next iteration, write `cont`.\n \n ~~~~\n # import each = vec::each;\n@@ -1110,7 +1134,7 @@ for each(~[2, 4, 8, 5, 16]) |n| {\n ~~~~\n \n As an added bonus, you can use the `ret` keyword, which is not\n-normally allowed in blocks, in a block that appears as the body of a\n+normally allowed in closures, in a block that appears as the body of a\n `for` loop \u2014 this will cause a return to happen from the outer\n function, not just the loop body.\n \n@@ -1124,6 +1148,8 @@ fn contains(v: ~[int], elt: int) -> bool {\n }\n ~~~~\n \n+`for` syntax only works with stack closures.\n+\n \n # Datatypes\n "}]}