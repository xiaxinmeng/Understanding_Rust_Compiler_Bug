{"sha": "7af840f62e95f0a4300cdef2a623c0b6b59c524c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZjg0MGY2MmU5NWYwYTQzMDBjZGVmMmE2MjNjMGI2YjU5YzUyNGM=", "commit": {"author": {"name": "surechen", "email": "surechen17@huawei.com", "date": "2021-07-21T03:35:06Z"}, "committer": {"name": "surechen", "email": "surechen17@huawei.com", "date": "2021-07-21T03:35:06Z"}, "message": "Simplify the collecting of `? Trait` bounds in where clause", "tree": {"sha": "e3ed4ef6c5e05dfa2ab4c06ec1063e4e74c4fb64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3ed4ef6c5e05dfa2ab4c06ec1063e4e74c4fb64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7af840f62e95f0a4300cdef2a623c0b6b59c524c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7af840f62e95f0a4300cdef2a623c0b6b59c524c", "html_url": "https://github.com/rust-lang/rust/commit/7af840f62e95f0a4300cdef2a623c0b6b59c524c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7af840f62e95f0a4300cdef2a623c0b6b59c524c/comments", "author": null, "committer": null, "parents": [{"sha": "b41936b92cd8463020207cb2f62a4247942ef2e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b41936b92cd8463020207cb2f62a4247942ef2e4", "html_url": "https://github.com/rust-lang/rust/commit/b41936b92cd8463020207cb2f62a4247942ef2e4"}], "stats": {"total": 53, "additions": 20, "deletions": 33}, "files": [{"sha": "d1428f3b6c12f9084525f1d24500dab40ecb4846", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7af840f62e95f0a4300cdef2a623c0b6b59c524c/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7af840f62e95f0a4300cdef2a623c0b6b59c524c/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=7af840f62e95f0a4300cdef2a623c0b6b59c524c", "patch": "@@ -1373,50 +1373,37 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         itctx: ImplTraitContext<'_, 'hir>,\n     ) -> GenericsCtor<'hir> {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n-        // FIXME: this could probably be done with less rightward drift. It also looks like two\n-        // control paths where `report_error` is called are the only paths that advance to after the\n-        // match statement, so the error reporting could probably just be moved there.\n         let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n         for pred in &generics.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n                 'next_bound: for bound in &bound_pred.bounds {\n                     if let GenericBound::Trait(_, TraitBoundModifier::Maybe) = *bound {\n-                        let report_error = |this: &mut Self| {\n-                            this.diagnostic().span_err(\n-                                bound_pred.bounded_ty.span,\n-                                \"`?Trait` bounds are only permitted at the \\\n-                                 point where a type parameter is declared\",\n-                            );\n-                        };\n                         // Check if the where clause type is a plain type parameter.\n-                        match bound_pred.bounded_ty.kind {\n-                            TyKind::Path(None, ref path)\n-                                if path.segments.len() == 1\n-                                    && bound_pred.bound_generic_params.is_empty() =>\n-                            {\n-                                if let Some(Res::Def(DefKind::TyParam, def_id)) = self\n-                                    .resolver\n-                                    .get_partial_res(bound_pred.bounded_ty.id)\n-                                    .map(|d| d.base_res())\n+                        match self\n+                            .resolver\n+                            .get_partial_res(bound_pred.bounded_ty.id)\n+                            .map(|d| (d.base_res(), d.unresolved_segments()))\n+                        {\n+                            Some((Res::Def(DefKind::TyParam, def_id), 0))\n+                            if bound_pred.bound_generic_params.is_empty() =>\n                                 {\n-                                    if let Some(def_id) = def_id.as_local() {\n-                                        for param in &generics.params {\n-                                            if let GenericParamKind::Type { .. } = param.kind {\n-                                                if def_id == self.resolver.local_def_id(param.id) {\n-                                                    add_bounds\n-                                                        .entry(param.id)\n-                                                        .or_default()\n-                                                        .push(bound.clone());\n-                                                    continue 'next_bound;\n-                                                }\n-                                            }\n+                                    for param in &generics.params {\n+                                        if def_id == self.resolver.local_def_id(param.id).to_def_id() {\n+                                            add_bounds\n+                                                .entry(param.id)\n+                                                .or_default()\n+                                                .push(bound.clone());\n+                                            continue 'next_bound;\n                                         }\n                                     }\n                                 }\n-                                report_error(self)\n-                            }\n-                            _ => report_error(self),\n+                            _ => {}\n                         }\n+                        self.diagnostic().span_err(\n+                            bound_pred.bounded_ty.span,\n+                            \"`?Trait` bounds are only permitted at the \\\n+                                 point where a type parameter is declared\",\n+                        );\n                     }\n                 }\n             }"}]}