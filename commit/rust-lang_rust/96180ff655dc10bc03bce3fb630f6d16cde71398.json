{"sha": "96180ff655dc10bc03bce3fb630f6d16cde71398", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MTgwZmY2NTVkYzEwYmMwM2JjZTNmYjYzMGY2ZDE2Y2RlNzEzOTg=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-30T13:22:46Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-01T12:20:18Z"}, "message": "Move late lint machanism in librustc_lint.", "tree": {"sha": "4a8f98acd27bdd6675f853ea5edae6a2a1db801b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a8f98acd27bdd6675f853ea5edae6a2a1db801b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96180ff655dc10bc03bce3fb630f6d16cde71398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96180ff655dc10bc03bce3fb630f6d16cde71398", "html_url": "https://github.com/rust-lang/rust/commit/96180ff655dc10bc03bce3fb630f6d16cde71398", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96180ff655dc10bc03bce3fb630f6d16cde71398/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a350e1a39a47f33653be1ced1f3ccb940adeb54", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a350e1a39a47f33653be1ced1f3ccb940adeb54", "html_url": "https://github.com/rust-lang/rust/commit/3a350e1a39a47f33653be1ced1f3ccb940adeb54"}], "stats": {"total": 941, "additions": 486, "deletions": 455}, "files": [{"sha": "e1350ad03a10f3406e56558a7bc53a75ac01d1e1", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 8, "deletions": 451, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=96180ff655dc10bc03bce3fb630f6d16cde71398", "patch": "@@ -17,23 +17,20 @@\n use self::TargetLint::*;\n \n use crate::hir;\n-use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use crate::hir::intravisit as hir_visit;\n-use crate::hir::intravisit::Visitor;\n+use crate::hir::def_id::{CrateNum, DefId};\n use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n-use crate::lint::{EarlyLintPassObject, LateLintPass, LateLintPassObject};\n-use crate::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId, LintPass};\n+use crate::lint::{EarlyLintPassObject, LateLintPassObject};\n+use crate::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use crate::middle::privacy::AccessLevels;\n use crate::session::Session;\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use crate::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n-use crate::util::common::time;\n use crate::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n-use rustc_data_structures::sync::{self, join, par_iter, ParallelIterator};\n+use rustc_data_structures::sync;\n use rustc_span::{symbol::Symbol, MultiSpan, Span};\n use std::slice;\n use syntax::ast;\n@@ -57,9 +54,9 @@ pub struct LintStore {\n     /// necessarily in a sane manner. This is safe though.)\n     pub pre_expansion_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n     pub early_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n-    late_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n+    pub late_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n     /// This is unique in that we construct them per-module, so not once.\n-    late_module_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n+    pub late_module_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n@@ -446,9 +443,9 @@ pub struct LateContext<'a, 'tcx> {\n     pub access_levels: &'a AccessLevels,\n \n     /// The store of registered lints and the lint levels.\n-    lint_store: &'tcx LintStore,\n+    pub lint_store: &'tcx LintStore,\n \n-    last_node_with_lint_attrs: hir::HirId,\n+    pub last_node_with_lint_attrs: hir::HirId,\n \n     /// Generic type parameters in scope for the item we are in.\n     pub generics: Option<&'tcx hir::Generics<'tcx>>,\n@@ -457,11 +454,6 @@ pub struct LateContext<'a, 'tcx> {\n     pub only_module: bool,\n }\n \n-pub struct LateContextAndPass<'a, 'tcx, T: LateLintPass<'a, 'tcx>> {\n-    context: LateContext<'a, 'tcx>,\n-    pass: T,\n-}\n-\n /// Context for lint checking of the AST, after expansion, before lowering to\n /// HIR.\n pub struct EarlyContext<'a> {\n@@ -578,10 +570,6 @@ impl<'a> EarlyContext<'a> {\n     }\n }\n \n-macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    $cx.pass.$f(&$cx.context, $($args),*);\n-}) }\n-\n impl LintContext for LateContext<'_, '_> {\n     type PassObject = LateLintPassObject;\n \n@@ -783,434 +771,3 @@ impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n }\n-\n-impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n-    /// Merge the lints specified by any lint attributes into the\n-    /// current lint context, call the provided function, then reset the\n-    /// lints in effect to their previous state.\n-    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &'tcx [ast::Attribute], f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let prev = self.context.last_node_with_lint_attrs;\n-        self.context.last_node_with_lint_attrs = id;\n-        self.enter_attrs(attrs);\n-        f(self);\n-        self.exit_attrs(attrs);\n-        self.context.last_node_with_lint_attrs = prev;\n-    }\n-\n-    fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let old_param_env = self.context.param_env;\n-        self.context.param_env =\n-            self.context.tcx.param_env(self.context.tcx.hir().local_def_id(id));\n-        f(self);\n-        self.context.param_env = old_param_env;\n-    }\n-\n-    fn process_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n-        lint_callback!(self, check_mod, m, s, n);\n-        hir_visit::walk_mod(self, m, n);\n-        lint_callback!(self, check_mod_post, m, s, n);\n-    }\n-\n-    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: enter_attrs({:?})\", attrs);\n-        lint_callback!(self, enter_lint_attrs, attrs);\n-    }\n-\n-    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: exit_attrs({:?})\", attrs);\n-        lint_callback!(self, exit_lint_attrs, attrs);\n-    }\n-}\n-\n-impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n-    for LateContextAndPass<'a, 'tcx, T>\n-{\n-    /// Because lints are scoped lexically, we want to walk nested\n-    /// items in the context of the outer item, so enable\n-    /// deep-walking.\n-    fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n-        hir_visit::NestedVisitorMap::All(&self.context.tcx.hir())\n-    }\n-\n-    fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.context.tables;\n-        self.context.tables = self.context.tcx.body_tables(body);\n-        let body = self.context.tcx.hir().body(body);\n-        self.visit_body(body);\n-        self.context.tables = old_tables;\n-    }\n-\n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n-            lint_callback!(cx, check_param, param);\n-            hir_visit::walk_param(cx, param);\n-        });\n-    }\n-\n-    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n-        lint_callback!(self, check_body, body);\n-        hir_visit::walk_body(self, body);\n-        lint_callback!(self, check_body_post, body);\n-    }\n-\n-    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        let generics = self.context.generics.take();\n-        self.context.generics = it.kind.generics();\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.hir_id, |cx| {\n-                lint_callback!(cx, check_item, it);\n-                hir_visit::walk_item(cx, it);\n-                lint_callback!(cx, check_item_post, it);\n-            });\n-        });\n-        self.context.generics = generics;\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.hir_id, |cx| {\n-                lint_callback!(cx, check_foreign_item, it);\n-                hir_visit::walk_foreign_item(cx, it);\n-                lint_callback!(cx, check_foreign_item_post, it);\n-            });\n-        })\n-    }\n-\n-    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n-        lint_callback!(self, check_pat, p);\n-        hir_visit::walk_pat(self, p);\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n-            lint_callback!(cx, check_expr, e);\n-            hir_visit::walk_expr(cx, e);\n-            lint_callback!(cx, check_expr_post, e);\n-        })\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-        // statement attributes are actually just attributes on one of\n-        // - item\n-        // - local\n-        // - expression\n-        // so we keep track of lint levels there\n-        lint_callback!(self, check_stmt, s);\n-        hir_visit::walk_stmt(self, s);\n-    }\n-\n-    fn visit_fn(\n-        &mut self,\n-        fk: hir_visit::FnKind<'tcx>,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n-        body_id: hir::BodyId,\n-        span: Span,\n-        id: hir::HirId,\n-    ) {\n-        // Wrap in tables here, not just in visit_nested_body,\n-        // in order for `check_fn` to be able to use them.\n-        let old_tables = self.context.tables;\n-        self.context.tables = self.context.tcx.body_tables(body_id);\n-        let body = self.context.tcx.hir().body(body_id);\n-        lint_callback!(self, check_fn, fk, decl, body, span, id);\n-        hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n-        lint_callback!(self, check_fn_post, fk, decl, body, span, id);\n-        self.context.tables = old_tables;\n-    }\n-\n-    fn visit_variant_data(\n-        &mut self,\n-        s: &'tcx hir::VariantData<'tcx>,\n-        _: ast::Name,\n-        _: &'tcx hir::Generics<'tcx>,\n-        _: hir::HirId,\n-        _: Span,\n-    ) {\n-        lint_callback!(self, check_struct_def, s);\n-        hir_visit::walk_struct_def(self, s);\n-        lint_callback!(self, check_struct_def_post, s);\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n-            lint_callback!(cx, check_struct_field, s);\n-            hir_visit::walk_struct_field(cx, s);\n-        })\n-    }\n-\n-    fn visit_variant(\n-        &mut self,\n-        v: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics<'tcx>,\n-        item_id: hir::HirId,\n-    ) {\n-        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            lint_callback!(cx, check_variant, v);\n-            hir_visit::walk_variant(cx, v, g, item_id);\n-            lint_callback!(cx, check_variant_post, v);\n-        })\n-    }\n-\n-    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n-        lint_callback!(self, check_ty, t);\n-        hir_visit::walk_ty(self, t);\n-    }\n-\n-    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        lint_callback!(self, check_name, sp, name);\n-    }\n-\n-    fn visit_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n-        if !self.context.only_module {\n-            self.process_mod(m, s, n);\n-        }\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n-            lint_callback!(cx, check_local, l);\n-            hir_visit::walk_local(cx, l);\n-        })\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n-        lint_callback!(self, check_block, b);\n-        hir_visit::walk_block(self, b);\n-        lint_callback!(self, check_block_post, b);\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        lint_callback!(self, check_arm, a);\n-        hir_visit::walk_arm(self, a);\n-    }\n-\n-    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n-        lint_callback!(self, check_generic_param, p);\n-        hir_visit::walk_generic_param(self, p);\n-    }\n-\n-    fn visit_generics(&mut self, g: &'tcx hir::Generics<'tcx>) {\n-        lint_callback!(self, check_generics, g);\n-        hir_visit::walk_generics(self, g);\n-    }\n-\n-    fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate<'tcx>) {\n-        lint_callback!(self, check_where_predicate, p);\n-        hir_visit::walk_where_predicate(self, p);\n-    }\n-\n-    fn visit_poly_trait_ref(\n-        &mut self,\n-        t: &'tcx hir::PolyTraitRef<'tcx>,\n-        m: hir::TraitBoundModifier,\n-    ) {\n-        lint_callback!(self, check_poly_trait_ref, t, m);\n-        hir_visit::walk_poly_trait_ref(self, t, m);\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        let generics = self.context.generics.take();\n-        self.context.generics = Some(&trait_item.generics);\n-        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n-            cx.with_param_env(trait_item.hir_id, |cx| {\n-                lint_callback!(cx, check_trait_item, trait_item);\n-                hir_visit::walk_trait_item(cx, trait_item);\n-                lint_callback!(cx, check_trait_item_post, trait_item);\n-            });\n-        });\n-        self.context.generics = generics;\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        let generics = self.context.generics.take();\n-        self.context.generics = Some(&impl_item.generics);\n-        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n-            cx.with_param_env(impl_item.hir_id, |cx| {\n-                lint_callback!(cx, check_impl_item, impl_item);\n-                hir_visit::walk_impl_item(cx, impl_item);\n-                lint_callback!(cx, check_impl_item_post, impl_item);\n-            });\n-        });\n-        self.context.generics = generics;\n-    }\n-\n-    fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n-        lint_callback!(self, check_lifetime, lt);\n-        hir_visit::walk_lifetime(self, lt);\n-    }\n-\n-    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n-        lint_callback!(self, check_path, p, id);\n-        hir_visit::walk_path(self, p);\n-    }\n-\n-    fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n-        lint_callback!(self, check_attribute, attr);\n-    }\n-}\n-\n-struct LateLintPassObjects<'a> {\n-    lints: &'a mut [LateLintPassObject],\n-}\n-\n-#[allow(rustc::lint_pass_impl_without_macro)]\n-impl LintPass for LateLintPassObjects<'_> {\n-    fn name(&self) -> &'static str {\n-        panic!()\n-    }\n-}\n-\n-macro_rules! expand_late_lint_pass_impl_methods {\n-    ([$a:tt, $hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(fn $name(&mut self, context: &LateContext<$a, $hir>, $($param: $arg),*) {\n-            for obj in self.lints.iter_mut() {\n-                obj.$name(context, $($param),*);\n-            }\n-        })*\n-    )\n-}\n-\n-macro_rules! late_lint_pass_impl {\n-    ([], [$hir:tt], $methods:tt) => (\n-        impl LateLintPass<'a, $hir> for LateLintPassObjects<'_> {\n-            expand_late_lint_pass_impl_methods!(['a, $hir], $methods);\n-        }\n-    )\n-}\n-\n-late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n-\n-fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx>,\n-    module_def_id: DefId,\n-    pass: T,\n-) {\n-    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n-\n-    let context = LateContext {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        param_env: ty::ParamEnv::empty(),\n-        access_levels,\n-        lint_store: &tcx.lint_store,\n-        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n-        generics: None,\n-        only_module: true,\n-    };\n-\n-    let mut cx = LateContextAndPass { context, pass };\n-\n-    let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n-    cx.process_mod(module, span, hir_id);\n-\n-    // Visit the crate attributes\n-    if hir_id == hir::CRATE_HIR_ID {\n-        walk_list!(cx, visit_attribute, tcx.hir().attrs(hir::CRATE_HIR_ID));\n-    }\n-}\n-\n-pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx>,\n-    module_def_id: DefId,\n-    builtin_lints: T,\n-) {\n-    if tcx.sess.opts.debugging_opts.no_interleave_lints {\n-        // These passes runs in late_lint_crate with -Z no_interleave_lints\n-        return;\n-    }\n-\n-    late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n-\n-    let mut passes: Vec<_> =\n-        tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n-\n-    if !passes.is_empty() {\n-        late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n-    }\n-}\n-\n-fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n-    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n-\n-    let krate = tcx.hir().krate();\n-\n-    let context = LateContext {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        param_env: ty::ParamEnv::empty(),\n-        access_levels,\n-        lint_store: &tcx.lint_store,\n-        last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n-        generics: None,\n-        only_module: false,\n-    };\n-\n-    let mut cx = LateContextAndPass { context, pass };\n-\n-    // Visit the whole crate.\n-    cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n-        // since the root module isn't visited as an item (because it isn't an\n-        // item), warn for it here.\n-        lint_callback!(cx, check_crate, krate);\n-\n-        hir_visit::walk_crate(cx, krate);\n-\n-        lint_callback!(cx, check_crate_post, krate);\n-    })\n-}\n-\n-fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n-    let mut passes = tcx.lint_store.late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n-\n-    if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n-        if !passes.is_empty() {\n-            late_lint_pass_crate(tcx, LateLintPassObjects { lints: &mut passes[..] });\n-        }\n-\n-        late_lint_pass_crate(tcx, builtin_lints);\n-    } else {\n-        for pass in &mut passes {\n-            time(tcx.sess, &format!(\"running late lint: {}\", pass.name()), || {\n-                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-            });\n-        }\n-\n-        let mut passes: Vec<_> =\n-            tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n-\n-        for pass in &mut passes {\n-            time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n-                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-            });\n-        }\n-    }\n-}\n-\n-/// Performs lint checking on a crate.\n-pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx>,\n-    builtin_lints: impl FnOnce() -> T + Send,\n-) {\n-    join(\n-        || {\n-            time(tcx.sess, \"crate lints\", || {\n-                // Run whole crate non-incremental lints\n-                late_lint_crate(tcx, builtin_lints());\n-            });\n-        },\n-        || {\n-            time(tcx.sess, \"module lints\", || {\n-                // Run per-module lints\n-                par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                    tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n-                });\n-            });\n-        },\n-    );\n-}"}, {"sha": "ba9076f2e35b2425d973689f13f3b05452c186b3", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=96180ff655dc10bc03bce3fb630f6d16cde71398", "patch": "@@ -39,8 +39,7 @@ use syntax::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n use syntax::symbol::Symbol;\n \n pub use crate::lint::context::{\n-    check_crate, late_lint_mod, BufferedEarlyLint, CheckLintNameResult, EarlyContext, LateContext,\n-    LintContext, LintStore,\n+    BufferedEarlyLint, CheckLintNameResult, EarlyContext, LateContext, LintContext, LintStore,\n };\n \n pub use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintId};"}, {"sha": "a796408491f9f3dad2c3c9b66e9c795089293157", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=96180ff655dc10bc03bce3fb630f6d16cde71398", "patch": "@@ -886,7 +886,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                     },\n                     {\n                         time(sess, \"lint checking\", || {\n-                            lint::check_crate(tcx, || {\n+                            rustc_lint::check_crate(tcx, || {\n                                 rustc_lint::BuiltinCombinedLateLintPass::new()\n                             });\n                         });"}, {"sha": "1248cfd3bc26910adb65021ce665dfdddac0f737", "filename": "src/librustc_lint/late.rs", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=96180ff655dc10bc03bce3fb630f6d16cde71398", "patch": "@@ -0,0 +1,473 @@\n+//! Implementation of lint checking.\n+//!\n+//! The lint checking is mostly consolidated into one pass which runs\n+//! after all other analyses. Throughout compilation, lint warnings\n+//! can be added via the `add_lint` method on the Session structure. This\n+//! requires a span and an ID of the node that the lint is being added to. The\n+//! lint isn't actually emitted at that time because it is unknown what the\n+//! actual lint level at that location is.\n+//!\n+//! To actually emit lint warnings/errors, a separate pass is used.\n+//! A context keeps track of the current state of all lint levels.\n+//! Upon entering a node of the ast which can modify the lint settings, the\n+//! previous lint state is pushed onto a stack and the ast is then recursed\n+//! upon. As the ast is traversed, this keeps track of the current lint level\n+//! for all lint attributes.\n+\n+use rustc::hir;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::intravisit as hir_visit;\n+use rustc::hir::intravisit::Visitor;\n+use rustc::lint::LateContext;\n+use rustc::lint::LintPass;\n+use rustc::lint::{LateLintPass, LateLintPassObject};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::util::common::time;\n+\n+use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n+use rustc_span::Span;\n+use std::slice;\n+use syntax::ast;\n+\n+use log::debug;\n+use syntax::walk_list;\n+\n+macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    $cx.pass.$f(&$cx.context, $($args),*);\n+}) }\n+\n+struct LateContextAndPass<'a, 'tcx, T: LateLintPass<'a, 'tcx>> {\n+    context: LateContext<'a, 'tcx>,\n+    pass: T,\n+}\n+\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n+    /// Merge the lints specified by any lint attributes into the\n+    /// current lint context, call the provided function, then reset the\n+    /// lints in effect to their previous state.\n+    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &'tcx [ast::Attribute], f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let prev = self.context.last_node_with_lint_attrs;\n+        self.context.last_node_with_lint_attrs = id;\n+        self.enter_attrs(attrs);\n+        f(self);\n+        self.exit_attrs(attrs);\n+        self.context.last_node_with_lint_attrs = prev;\n+    }\n+\n+    fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let old_param_env = self.context.param_env;\n+        self.context.param_env =\n+            self.context.tcx.param_env(self.context.tcx.hir().local_def_id(id));\n+        f(self);\n+        self.context.param_env = old_param_env;\n+    }\n+\n+    fn process_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n+        lint_callback!(self, check_mod, m, s, n);\n+        hir_visit::walk_mod(self, m, n);\n+        lint_callback!(self, check_mod_post, m, s, n);\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: enter_attrs({:?})\", attrs);\n+        lint_callback!(self, enter_lint_attrs, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: exit_attrs({:?})\", attrs);\n+        lint_callback!(self, exit_lint_attrs, attrs);\n+    }\n+}\n+\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n+    for LateContextAndPass<'a, 'tcx, T>\n+{\n+    /// Because lints are scoped lexically, we want to walk nested\n+    /// items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n+        hir_visit::NestedVisitorMap::All(&self.context.tcx.hir())\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body);\n+        let body = self.context.tcx.hir().body(body);\n+        self.visit_body(body);\n+        self.context.tables = old_tables;\n+    }\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n+            lint_callback!(cx, check_param, param);\n+            hir_visit::walk_param(cx, param);\n+        });\n+    }\n+\n+    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n+        lint_callback!(self, check_body, body);\n+        hir_visit::walk_body(self, body);\n+        lint_callback!(self, check_body_post, body);\n+    }\n+\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n+        let generics = self.context.generics.take();\n+        self.context.generics = it.kind.generics();\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n+                lint_callback!(cx, check_item, it);\n+                hir_visit::walk_item(cx, it);\n+                lint_callback!(cx, check_item_post, it);\n+            });\n+        });\n+        self.context.generics = generics;\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n+                lint_callback!(cx, check_foreign_item, it);\n+                hir_visit::walk_foreign_item(cx, it);\n+                lint_callback!(cx, check_foreign_item_post, it);\n+            });\n+        })\n+    }\n+\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n+        lint_callback!(self, check_pat, p);\n+        hir_visit::walk_pat(self, p);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n+        self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n+            lint_callback!(cx, check_expr, e);\n+            hir_visit::walk_expr(cx, e);\n+            lint_callback!(cx, check_expr_post, e);\n+        })\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n+        // statement attributes are actually just attributes on one of\n+        // - item\n+        // - local\n+        // - expression\n+        // so we keep track of lint levels there\n+        lint_callback!(self, check_stmt, s);\n+        hir_visit::walk_stmt(self, s);\n+    }\n+\n+    fn visit_fn(\n+        &mut self,\n+        fk: hir_visit::FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n+        body_id: hir::BodyId,\n+        span: Span,\n+        id: hir::HirId,\n+    ) {\n+        // Wrap in tables here, not just in visit_nested_body,\n+        // in order for `check_fn` to be able to use them.\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body_id);\n+        let body = self.context.tcx.hir().body(body_id);\n+        lint_callback!(self, check_fn, fk, decl, body, span, id);\n+        hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n+        lint_callback!(self, check_fn_post, fk, decl, body, span, id);\n+        self.context.tables = old_tables;\n+    }\n+\n+    fn visit_variant_data(\n+        &mut self,\n+        s: &'tcx hir::VariantData<'tcx>,\n+        _: ast::Name,\n+        _: &'tcx hir::Generics<'tcx>,\n+        _: hir::HirId,\n+        _: Span,\n+    ) {\n+        lint_callback!(self, check_struct_def, s);\n+        hir_visit::walk_struct_def(self, s);\n+        lint_callback!(self, check_struct_def_post, s);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n+        self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n+            lint_callback!(cx, check_struct_field, s);\n+            hir_visit::walk_struct_field(cx, s);\n+        })\n+    }\n+\n+    fn visit_variant(\n+        &mut self,\n+        v: &'tcx hir::Variant<'tcx>,\n+        g: &'tcx hir::Generics<'tcx>,\n+        item_id: hir::HirId,\n+    ) {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+            lint_callback!(cx, check_variant, v);\n+            hir_visit::walk_variant(cx, v, g, item_id);\n+            lint_callback!(cx, check_variant_post, v);\n+        })\n+    }\n+\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n+        lint_callback!(self, check_ty, t);\n+        hir_visit::walk_ty(self, t);\n+    }\n+\n+    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n+        lint_callback!(self, check_name, sp, name);\n+    }\n+\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n+        if !self.context.only_module {\n+            self.process_mod(m, s, n);\n+        }\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n+        self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n+            lint_callback!(cx, check_local, l);\n+            hir_visit::walk_local(cx, l);\n+        })\n+    }\n+\n+    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n+        lint_callback!(self, check_block, b);\n+        hir_visit::walk_block(self, b);\n+        lint_callback!(self, check_block_post, b);\n+    }\n+\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n+        lint_callback!(self, check_arm, a);\n+        hir_visit::walk_arm(self, a);\n+    }\n+\n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n+        lint_callback!(self, check_generic_param, p);\n+        hir_visit::walk_generic_param(self, p);\n+    }\n+\n+    fn visit_generics(&mut self, g: &'tcx hir::Generics<'tcx>) {\n+        lint_callback!(self, check_generics, g);\n+        hir_visit::walk_generics(self, g);\n+    }\n+\n+    fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate<'tcx>) {\n+        lint_callback!(self, check_where_predicate, p);\n+        hir_visit::walk_where_predicate(self, p);\n+    }\n+\n+    fn visit_poly_trait_ref(\n+        &mut self,\n+        t: &'tcx hir::PolyTraitRef<'tcx>,\n+        m: hir::TraitBoundModifier,\n+    ) {\n+        lint_callback!(self, check_poly_trait_ref, t, m);\n+        hir_visit::walk_poly_trait_ref(self, t, m);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&trait_item.generics);\n+        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n+            cx.with_param_env(trait_item.hir_id, |cx| {\n+                lint_callback!(cx, check_trait_item, trait_item);\n+                hir_visit::walk_trait_item(cx, trait_item);\n+                lint_callback!(cx, check_trait_item_post, trait_item);\n+            });\n+        });\n+        self.context.generics = generics;\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&impl_item.generics);\n+        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n+            cx.with_param_env(impl_item.hir_id, |cx| {\n+                lint_callback!(cx, check_impl_item, impl_item);\n+                hir_visit::walk_impl_item(cx, impl_item);\n+                lint_callback!(cx, check_impl_item_post, impl_item);\n+            });\n+        });\n+        self.context.generics = generics;\n+    }\n+\n+    fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n+        lint_callback!(self, check_lifetime, lt);\n+        hir_visit::walk_lifetime(self, lt);\n+    }\n+\n+    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n+        lint_callback!(self, check_path, p, id);\n+        hir_visit::walk_path(self, p);\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n+        lint_callback!(self, check_attribute, attr);\n+    }\n+}\n+\n+struct LateLintPassObjects<'a> {\n+    lints: &'a mut [LateLintPassObject],\n+}\n+\n+#[allow(rustc::lint_pass_impl_without_macro)]\n+impl LintPass for LateLintPassObjects<'_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! expand_late_lint_pass_impl_methods {\n+    ([$a:tt, $hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &LateContext<$a, $hir>, $($param: $arg),*) {\n+            for obj in self.lints.iter_mut() {\n+                obj.$name(context, $($param),*);\n+            }\n+        })*\n+    )\n+}\n+\n+macro_rules! late_lint_pass_impl {\n+    ([], [$hir:tt], $methods:tt) => (\n+        impl<'a, $hir> LateLintPass<'a, $hir> for LateLintPassObjects<'_> {\n+            expand_late_lint_pass_impl_methods!(['a, $hir], $methods);\n+        }\n+    )\n+}\n+\n+late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n+\n+fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    module_def_id: DefId,\n+    pass: T,\n+) {\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n+\n+    let context = LateContext {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        param_env: ty::ParamEnv::empty(),\n+        access_levels,\n+        lint_store: &tcx.lint_store,\n+        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n+        generics: None,\n+        only_module: true,\n+    };\n+\n+    let mut cx = LateContextAndPass { context, pass };\n+\n+    let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n+    cx.process_mod(module, span, hir_id);\n+\n+    // Visit the crate attributes\n+    if hir_id == hir::CRATE_HIR_ID {\n+        walk_list!(cx, visit_attribute, tcx.hir().attrs(hir::CRATE_HIR_ID));\n+    }\n+}\n+\n+pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    module_def_id: DefId,\n+    builtin_lints: T,\n+) {\n+    if tcx.sess.opts.debugging_opts.no_interleave_lints {\n+        // These passes runs in late_lint_crate with -Z no_interleave_lints\n+        return;\n+    }\n+\n+    late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n+\n+    let mut passes: Vec<_> =\n+        tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n+\n+    if !passes.is_empty() {\n+        late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n+    }\n+}\n+\n+fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n+\n+    let krate = tcx.hir().krate();\n+\n+    let context = LateContext {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        param_env: ty::ParamEnv::empty(),\n+        access_levels,\n+        lint_store: &tcx.lint_store,\n+        last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n+        generics: None,\n+        only_module: false,\n+    };\n+\n+    let mut cx = LateContextAndPass { context, pass };\n+\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        lint_callback!(cx, check_crate, krate);\n+\n+        hir_visit::walk_crate(cx, krate);\n+\n+        lint_callback!(cx, check_crate_post, krate);\n+    })\n+}\n+\n+fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n+    let mut passes = tcx.lint_store.late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n+\n+    if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n+        if !passes.is_empty() {\n+            late_lint_pass_crate(tcx, LateLintPassObjects { lints: &mut passes[..] });\n+        }\n+\n+        late_lint_pass_crate(tcx, builtin_lints);\n+    } else {\n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n+\n+        let mut passes: Vec<_> =\n+            tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n+\n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n+    }\n+}\n+\n+/// Performs lint checking on a crate.\n+pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    builtin_lints: impl FnOnce() -> T + Send,\n+) {\n+    join(\n+        || {\n+            time(tcx.sess, \"crate lints\", || {\n+                // Run whole crate non-incremental lints\n+                late_lint_crate(tcx, builtin_lints());\n+            });\n+        },\n+        || {\n+            time(tcx.sess, \"module lints\", || {\n+                // Run per-module lints\n+                par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n+                    tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+                });\n+            });\n+        },\n+    );\n+}"}, {"sha": "42fc353b2b064995a0004d4ebf3ed9c408a05d61", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96180ff655dc10bc03bce3fb630f6d16cde71398/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=96180ff655dc10bc03bce3fb630f6d16cde71398", "patch": "@@ -25,6 +25,7 @@ extern crate rustc_session;\n mod array_into_iter;\n pub mod builtin;\n mod early;\n+mod late;\n mod non_ascii_idents;\n mod nonstandard_style;\n mod redundant_semicolon;\n@@ -59,13 +60,14 @@ use unused::*;\n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n pub use early::check_ast_crate;\n+pub use late::check_crate;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { lint_mod, ..*providers };\n }\n \n fn lint_mod(tcx: TyCtxt<'_>, module_def_id: DefId) {\n-    lint::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n+    late::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n \n macro_rules! pre_expansion_lint_passes {"}]}