{"sha": "d68b0eceaaf719a4702ab13a7ca62dea5d966082", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OGIwZWNlYWFmNzE5YTQ3MDJhYjEzYTdjYTYyZGVhNWQ5NjYwODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-03T11:52:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-03T11:52:03Z"}, "message": "Auto merge of #50030 - flip1995:rfc2103, r=petrochenkov\n\nImplement tool_attributes feature (RFC 2103)\n\ncc #44690\n\nThis is currently just a rebased and compiling (hopefully) version of #47773.\n\nLet's see if travis likes this. I will add the implementation for `tool_lints` this week.", "tree": {"sha": "c7a351327d19c398532f139444d4cc652070318d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7a351327d19c398532f139444d4cc652070318d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d68b0eceaaf719a4702ab13a7ca62dea5d966082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d68b0eceaaf719a4702ab13a7ca62dea5d966082", "html_url": "https://github.com/rust-lang/rust/commit/d68b0eceaaf719a4702ab13a7ca62dea5d966082", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d68b0eceaaf719a4702ab13a7ca62dea5d966082/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "698b956a9fca9688632d617dd6d73cae834237a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/698b956a9fca9688632d617dd6d73cae834237a3", "html_url": "https://github.com/rust-lang/rust/commit/698b956a9fca9688632d617dd6d73cae834237a3"}, {"sha": "84f450866041e0269875acb1350920308cdc109f", "url": "https://api.github.com/repos/rust-lang/rust/commits/84f450866041e0269875acb1350920308cdc109f", "html_url": "https://github.com/rust-lang/rust/commit/84f450866041e0269875acb1350920308cdc109f"}], "stats": {"total": 693, "additions": 391, "deletions": 302}, "files": [{"sha": "15fc84a3e2a3dad17eb2f2a2115c6c6f45fc6f02", "filename": "src/doc/unstable-book/src/language-features/tool-attributes.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-attributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-attributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-attributes.md?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -0,0 +1,26 @@\n+# `tool_attributes`\n+\n+The tracking issue for this feature is: [#44690]\n+\n+[#44690]: https://github.com/rust-lang/rust/issues/44690\n+\n+------------------------\n+\n+Tool attributes let you use scoped attributes to control the behavior\n+of certain tools.\n+\n+Currently tool names which can be appear in scoped attributes are restricted to\n+`clippy` and `rustfmt`.\n+\n+## An example\n+\n+```rust\n+#![feature(tool_attributes)]\n+\n+#[rustfmt::skip]\n+fn foo() { println!(\"hello, world\"); }\n+\n+fn main() {\n+    foo();\n+}\n+```"}, {"sha": "24a1256c9d35bdf16bdaccd11a99c563f1a99f33", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -153,10 +153,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // ```\n         let hints: Vec<_> = item.attrs\n             .iter()\n-            .filter(|attr| match attr.name() {\n-                Some(name) => name == \"repr\",\n-                None => false,\n-            })\n+            .filter(|attr| attr.name() == \"repr\")\n             .filter_map(|attr| attr.meta_item_list())\n             .flat_map(|hints| hints)\n             .collect();\n@@ -311,7 +308,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_used(&self, item: &hir::Item, target: Target) {\n         for attr in &item.attrs {\n-            if attr.name().map(|name| name == \"used\").unwrap_or(false) && target != Target::Static {\n+            if attr.name() == \"used\" && target != Target::Static {\n                 self.tcx.sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n             }"}, {"sha": "1cf9b7bf4780e785a8a2b52a4035201fc7e465ce", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -199,8 +199,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n         let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n             .iter()\n             .filter(|attr| {\n-                !attr.is_sugared_doc &&\n-                attr.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true)\n+                !attr.is_sugared_doc && !hcx.is_ignored_attr(attr.name())\n             })\n             .collect();\n \n@@ -211,12 +210,23 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     }\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Path {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.segments.len().hash_stable(hcx, hasher);\n+        for segment in &self.segments {\n+            segment.ident.name.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n-        debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n+        debug_assert!(!hcx.is_ignored_attr(self.name()));\n         debug_assert!(!self.is_sugared_doc);\n \n         let ast::Attribute {\n@@ -229,10 +239,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n         } = *self;\n \n         style.hash_stable(hcx, hasher);\n-        path.segments.len().hash_stable(hcx, hasher);\n-        for segment in &path.segments {\n-            segment.ident.name.hash_stable(hcx, hasher);\n-        }\n+        path.hash_stable(hcx, hasher);\n         for tt in tokens.trees() {\n             tt.hash_stable(hcx, hasher);\n         }"}, {"sha": "d158f52c643ceca2c2896acabe6c8cf02bd21add", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -198,7 +198,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                       \"malformed lint attribute\");\n         };\n         for attr in attrs {\n-            let level = match attr.name().and_then(|name| Level::from_str(&name.as_str())) {\n+            let level = match Level::from_str(&attr.name().as_str()) {\n                 None => continue,\n                 Some(lvl) => lvl,\n             };\n@@ -221,7 +221,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         continue\n                     }\n                 };\n-                let name = word.ident.name;\n+                let name = word.name();\n                 match store.check_lint_name(&name.as_str()) {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintSource::Node(name, li.span);\n@@ -260,7 +260,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                 Some(li.span.into()),\n                                                 &msg);\n                         if name.as_str().chars().any(|c| c.is_uppercase()) {\n-                            let name_lower = name.as_str().to_lowercase();\n+                            let name_lower = name.as_str().to_lowercase().to_string();\n                             if let CheckLintNameResult::NoLint =\n                                     store.check_lint_name(&name_lower) {\n                                 db.emit();"}, {"sha": "279908d2b675fae372bbb13780bf293d39fc7220", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n         } else {\n             // Emit errors for non-staged-api crates.\n             for attr in attrs {\n-                let tag = unwrap_or!(attr.name(), continue);\n+                let tag = attr.name();\n                 if tag == \"unstable\" || tag == \"stable\" || tag == \"rustc_deprecated\" {\n                     attr::mark_used(attr);\n                     self.tcx.sess.span_err(attr.span(), \"stability attributes may not be used \\"}, {"sha": "dc97c941567059cd5912250a945af3fdc4f0e938", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -1683,7 +1683,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n                 early_error(ErrorOutputType::default(), &msg)\n             }\n \n-            (meta_item.ident.name, meta_item.value_str())\n+            (meta_item.name(), meta_item.value_str())\n         })\n         .collect::<ast::CrateConfig>()\n }"}, {"sha": "3cf7af30b3d551a0442f509f2a5279f2494cd5a3", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n             if let Some(ref condition) = command.condition {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n-                    options.contains(&(c.ident.name.as_str().to_string(),\n+                    options.contains(&(c.name().as_str().to_string(),\n                                       match c.value_str().map(|s| s.as_str().to_string()) {\n                                           Some(s) => Some(s),\n                                           None => None"}, {"sha": "a1052ca6c3ca9520fc7cf8f4e38ebc106f8263a7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -1060,7 +1060,7 @@ impl RustcDefaultCalls {\n                     let mut cfgs = Vec::new();\n                     for &(name, ref value) in sess.parse_sess.config.iter() {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            ident: ast::Ident::with_empty_ctxt(name),\n+                            ident: ast::Path::from_ident(name.to_ident()),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "38e891008f7308c073fb30b82c976418a4760b4e", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n             match list_item.word() {\n                 Some(word) if value.is_none() =>\n-                    value = Some(word.ident.name),\n+                    value = Some(word.name()),\n                 _ =>\n                     // FIXME better-encapsulate meta_item (don't directly access `node`)\n                     span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node),"}, {"sha": "f06062fa4ac83091dddc7945df8660ef7672d202", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -675,9 +675,8 @@ impl LintPass for DeprecatedAttr {\n \n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext, attr: &ast::Attribute) {\n-        let name = unwrap_or!(attr.name(), return);\n         for &&(n, _, ref g) in &self.depr_attrs {\n-            if name == n {\n+            if attr.name() == n {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link),\n                                              ref name,\n                                              ref reason,"}, {"sha": "4f6d23dce6dbb835c27a520e48737323c3ff8d9c", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -30,7 +30,6 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n \n-#[macro_use]\n extern crate syntax;\n #[macro_use]\n extern crate rustc;"}, {"sha": "8df40b62ddd1253d66cfd874ecce18377502ba69", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -192,8 +192,6 @@ impl LintPass for UnusedAttributes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n         debug!(\"checking attribute: {:?}\", attr);\n-        let name = unwrap_or!(attr.name(), return);\n-\n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in BUILTIN_ATTRIBUTES {\n             match ty {\n@@ -213,6 +211,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n             }\n         }\n \n+        let name = attr.name();\n         if !attr::is_used(attr) {\n             debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");"}, {"sha": "ef5cc95828372f46f5499c65913324a001a3b11f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -706,7 +706,7 @@ impl<'a> Resolver<'a> {\n                 match attr.meta_item_list() {\n                     Some(names) => for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.imports.push((word.ident.name, attr.span()));\n+                            imports.imports.push((word.name(), attr.span()));\n                         } else {\n                             span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n                         }"}, {"sha": "4afc621ad8b3e2751c8d6cccd2daac8ef9c2e51b", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -209,7 +209,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>, allow_derive: bool)\n                               -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n-            let name = unwrap_or!(attrs[i].name(), continue);\n+            let name = attrs[i].name();\n \n             if self.session.plugin_attributes.borrow().iter()\n                     .any(|&(ref attr_nm, _)| name == &**attr_nm) {\n@@ -231,7 +231,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         // Check for legacy derives\n         for i in 0..attrs.len() {\n-            let name = unwrap_or!(attrs[i].name(), continue);\n+            let name = attrs[i].name();\n \n             if name == \"derive\" {\n                 let result = attrs[i].parse_list(&self.session.parse_sess, |parser| {"}, {"sha": "d5e0f95ddf4356ac3396314dc6614889c9095418", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 63, "deletions": 179, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -67,7 +67,7 @@ impl Cfg {\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n     pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n-        let name = cfg.ident.name;\n+        let name = cfg.name();\n         match cfg.node {\n             MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n             MetaItemKind::NameValue(ref lit) => match lit.node {\n@@ -436,6 +436,42 @@ mod test {\n         Cfg::Cfg(Symbol::intern(name), Some(Symbol::intern(value)))\n     }\n \n+    fn dummy_meta_item_word(name: &str) -> MetaItem {\n+        MetaItem {\n+            ident: Path::from_ident(Ident::from_str(name)),\n+            node: MetaItemKind::Word,\n+            span: DUMMY_SP,\n+        }\n+    }\n+\n+    macro_rules! dummy_meta_item_list {\n+        ($name:ident, [$($list:ident),* $(,)*]) => {\n+            MetaItem {\n+                ident: Path::from_ident(Ident::from_str(stringify!($name))),\n+                node: MetaItemKind::List(vec![\n+                    $(\n+                        dummy_spanned(NestedMetaItemKind::MetaItem(\n+                            dummy_meta_item_word(stringify!($list)),\n+                        )),\n+                    )*\n+                ]),\n+                span: DUMMY_SP,\n+            }\n+        };\n+\n+        ($name:ident, [$($list:expr),* $(,)*]) => {\n+            MetaItem {\n+                ident: Path::from_ident(Ident::from_str(stringify!($name))),\n+                node: MetaItemKind::List(vec![\n+                    $(\n+                        dummy_spanned(NestedMetaItemKind::MetaItem($list)),\n+                    )*\n+                ]),\n+                span: DUMMY_SP,\n+            }\n+        };\n+    }\n+\n     #[test]\n     fn test_cfg_not() {\n         with_globals(|| {\n@@ -561,15 +597,11 @@ mod test {\n     #[test]\n     fn test_parse_ok() {\n         with_globals(|| {\n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n-                node: MetaItemKind::Word,\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_word(\"all\");\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n             let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n+                ident: Path::from_ident(Ident::from_str(\"all\")),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n                     Symbol::intern(\"done\"),\n                     StrStyle::Cooked,\n@@ -578,111 +610,24 @@ mod test {\n             };\n             assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(all, [a, b]);\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"any\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(any, [a, b]);\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(not, [a]);\n             assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"any\"),\n-                        node: MetaItemKind::List(vec![\n-                            dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                ident: Ident::from_str(\"a\"),\n-                                node: MetaItemKind::Word,\n-                                span: DUMMY_SP,\n-                            })),\n-                            dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                ident: Ident::from_str(\"all\"),\n-                                node: MetaItemKind::List(vec![\n-                                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                        ident: Ident::from_str(\"b\"),\n-                                        node: MetaItemKind::Word,\n-                                        span: DUMMY_SP,\n-                                    })),\n-                                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                        ident: Ident::from_str(\"c\"),\n-                                        node: MetaItemKind::Word,\n-                                        span: DUMMY_SP,\n-                                    })),\n-                                ]),\n-                                span: DUMMY_SP,\n-                            })),\n-                        ]),\n-                        span: DUMMY_SP,\n-                    })),\n+            let mi = dummy_meta_item_list!(not, [\n+                dummy_meta_item_list!(any, [\n+                    dummy_meta_item_word(\"a\"),\n+                    dummy_meta_item_list!(all, [b, c]),\n                 ]),\n-                span: DUMMY_SP,\n-            };\n+            ]);\n             assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"c\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(all, [a, b, c]);\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\")));\n         })\n     }\n@@ -691,97 +636,36 @@ mod test {\n     fn test_parse_err() {\n         with_globals(|| {\n             let mi = MetaItem {\n-                ident: Ident::from_str(\"foo\"),\n+                ident: Path::from_ident(Ident::from_str(\"foo\")),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n                 span: DUMMY_SP,\n             };\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(not, [a, b]);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(not, []);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"foo\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(foo, []);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"foo\"),\n-                        node: MetaItemKind::List(vec![]),\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(all, [\n+                dummy_meta_item_list!(foo, []),\n+                dummy_meta_item_word(\"b\"),\n+            ]);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"any\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"foo\"),\n-                        node: MetaItemKind::List(vec![]),\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(any, [\n+                dummy_meta_item_word(\"a\"),\n+                dummy_meta_item_list!(foo, []),\n+            ]);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"foo\"),\n-                        node: MetaItemKind::List(vec![]),\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(not, [\n+                dummy_meta_item_list!(foo, []),\n+            ]);\n             assert!(Cfg::parse(&mi).is_err());\n         })\n     }"}, {"sha": "d124a17b421d140bcedc53f65b99a53e830ef5d0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -3661,7 +3661,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n-            a.name().unwrap() == \"doc\" && match a.meta_item_list() {\n+            a.name() == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n                            attr::list_contains_name(&l, \"hidden\"),\n                 None => false,"}, {"sha": "e9520573f8bd6dca32321b0e4275ee9c1d9f6a6c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -3284,7 +3284,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n }\n \n fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n-    let name = attr.ident.name;\n+    let name = attr.name();\n \n     if attr.is_word() {\n         Some(format!(\"{}\", name))\n@@ -3319,7 +3319,7 @@ fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n-        let name = attr.name().unwrap();\n+        let name = attr.name();\n         if !ATTRIBUTE_WHITELIST.contains(&&*name.as_str()) {\n             continue;\n         }"}, {"sha": "f8cd6103bdfa110e4e421ba0e5c129b1b2f4115c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -474,10 +474,10 @@ pub enum NestedMetaItemKind {\n \n /// A spanned compile-time attribute item.\n ///\n-/// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n+/// E.g. `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MetaItem {\n-    pub ident: Ident,\n+    pub ident: Path,\n     pub node: MetaItemKind,\n     pub span: Span,\n }"}, {"sha": "ace9904e0c021e57b39ff6005883d6afbaa80d19", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 101, "deletions": 49, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -15,10 +15,10 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Name, Ident};\n+use ast::{AttrId, Attribute, Name, Ident, Path, PathSegment};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind};\n-use codemap::{Spanned, respan, dummy_spanned};\n+use codemap::{BytePos, Spanned, respan, dummy_spanned};\n use syntax_pos::Span;\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n@@ -107,6 +107,14 @@ pub fn is_known(attr: &Attribute) -> bool {\n     })\n }\n \n+const RUST_KNOWN_TOOL: &[&str] = &[\"clippy\", \"rustfmt\"];\n+\n+pub fn is_known_tool(attr: &Attribute) -> bool {\n+    let tool_name =\n+        attr.path.segments.iter().next().expect(\"empty path in attribute\").ident.name;\n+    RUST_KNOWN_TOOL.contains(&tool_name.as_str().as_ref())\n+}\n+\n impl NestedMetaItem {\n     /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n     pub fn meta_item(&self) -> Option<&MetaItem> {\n@@ -137,7 +145,7 @@ impl NestedMetaItem {\n     /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n     /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n     pub fn name(&self) -> Option<Name> {\n-        self.meta_item().and_then(|meta_item| Some(meta_item.ident.name))\n+        self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -154,7 +162,7 @@ impl NestedMetaItem {\n                     if meta_item_list.len() == 1 {\n                         let nested_item = &meta_item_list[0];\n                         if nested_item.is_literal() {\n-                            Some((meta_item.ident.name, nested_item.literal().unwrap()))\n+                            Some((meta_item.name(), nested_item.literal().unwrap()))\n                         } else {\n                             None\n                         }\n@@ -204,6 +212,10 @@ impl NestedMetaItem {\n     }\n }\n \n+fn name_from_path(path: &Path) -> Name {\n+    path.segments.last().expect(\"empty path in attribute\").ident.name\n+}\n+\n impl Attribute {\n     pub fn check_name(&self, name: &str) -> bool {\n         let matches = self.path == name;\n@@ -213,11 +225,10 @@ impl Attribute {\n         matches\n     }\n \n-    pub fn name(&self) -> Option<Name> {\n-        match self.path.segments.len() {\n-            1 => Some(self.path.segments[0].ident.name),\n-            _ => None,\n-        }\n+    /// Returns the **last** segment of the name of this attribute.\n+    /// E.g. `foo` for `#[foo]`, `skip` for `#[rustfmt::skip]`.\n+    pub fn name(&self) -> Name {\n+        name_from_path(&self.path)\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n@@ -247,9 +258,17 @@ impl Attribute {\n     pub fn is_value_str(&self) -> bool {\n         self.value_str().is_some()\n     }\n+\n+    pub fn is_scoped(&self) -> bool {\n+        self.path.segments.len() > 1\n+    }\n }\n \n impl MetaItem {\n+    pub fn name(&self) -> Name {\n+        name_from_path(&self.ident)\n+    }\n+\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self.node {\n             MetaItemKind::NameValue(ref v) => {\n@@ -279,7 +298,7 @@ impl MetaItem {\n     pub fn span(&self) -> Span { self.span }\n \n     pub fn check_name(&self, name: &str) -> bool {\n-        self.ident.name == name\n+        self.name() == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -296,10 +315,7 @@ impl Attribute {\n     pub fn meta(&self) -> Option<MetaItem> {\n         let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n-            ident: match self.path.segments.len() {\n-                1 => self.path.segments[0].ident,\n-                _ => return None,\n-            },\n+            ident: self.path.clone(),\n             node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n                 if tokens.peek().is_some() {\n                     return None;\n@@ -344,12 +360,8 @@ impl Attribute {\n     }\n \n     pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n-        if self.path.segments.len() > 1 {\n-            sess.span_diagnostic.span_err(self.path.span, \"expected ident, found path\");\n-        }\n-\n         Ok(MetaItem {\n-            ident: self.path.segments.last().unwrap().ident,\n+            ident: self.path.clone(),\n             node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n             span: self.span,\n         })\n@@ -387,16 +399,17 @@ pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem\n }\n \n pub fn mk_name_value_item(span: Span, ident: Ident, value: ast::Lit) -> MetaItem {\n-    MetaItem { ident, span, node: MetaItemKind::NameValue(value) }\n+    MetaItem { ident: Path::from_ident(ident), span, node: MetaItemKind::NameValue(value) }\n }\n \n pub fn mk_list_item(span: Span, ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { ident, span, node: MetaItemKind::List(items) }\n+    MetaItem { ident: Path::from_ident(ident), span, node: MetaItemKind::List(items) }\n }\n \n pub fn mk_word_item(ident: Ident) -> MetaItem {\n-    MetaItem { ident, span: ident.span, node: MetaItemKind::Word }\n+    MetaItem { ident: Path::from_ident(ident), span: ident.span, node: MetaItemKind::Word }\n }\n+\n pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n     respan(ident.span, NestedMetaItemKind::MetaItem(mk_word_item(ident)))\n }\n@@ -422,7 +435,7 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Inner,\n-        path: ast::Path::from_ident(item.ident),\n+        path: item.ident,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -440,7 +453,7 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Outer,\n-        path: ast::Path::from_ident(item.ident),\n+        path: item.ident,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -453,7 +466,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     Attribute {\n         id,\n         style,\n-        path: ast::Path::from_ident(Ident::from_str(\"doc\").with_span_pos(span)),\n+        path: Path::from_ident(Ident::from_str(\"doc\").with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,\n@@ -489,7 +502,7 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n         item.check_name(\"feature\") &&\n         item.meta_item_list().map(|list| {\n             list.iter().any(|mi| {\n-                mi.word().map(|w| w.ident.name == feature_name)\n+                mi.word().map(|w| w.name() == feature_name)\n                          .unwrap_or(false)\n             })\n         }).unwrap_or(false)\n@@ -562,7 +575,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n         if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n             gated_cfg.check_and_emit(sess, feats);\n         }\n-        sess.config.contains(&(cfg.ident.name, cfg.value_str()))\n+        sess.config.contains(&(cfg.name(), cfg.value_str()))\n     })\n }\n \n@@ -583,7 +596,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &*cfg.ident.name.as_str() {\n+            match &*cfg.name().as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n@@ -676,7 +689,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -695,14 +708,14 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     )+\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.ident.name.as_str() {\n+                            match &*mi.name().as_str() {\n                                 $(\n                                     stringify!($name)\n                                         => if !get(mi, &mut $name) { continue 'outer },\n                                 )+\n                                 _ => {\n                                     handle_errors(diagnostic, mi.span,\n-                                                  AttrError::UnknownMetaItem(mi.ident.name));\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n                                     continue 'outer\n                                 }\n                             }\n@@ -714,7 +727,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             }\n \n-            match &*meta.ident.name.as_str() {\n+            match &*meta.name().as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -769,13 +782,13 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.ident.name.as_str() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.ident.name));\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n                                     continue 'outer\n                                 }\n                             }\n@@ -825,12 +838,12 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     for meta in metas {\n                         if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.ident.name.as_str() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.ident.name));\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n                                     continue 'outer\n                                 }\n                             }\n@@ -917,7 +930,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         depr = if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -933,12 +946,12 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut note = None;\n             for meta in metas {\n                 if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.ident.name.as_str() {\n+                    match &*mi.name().as_str() {\n                         \"since\" => if !get(mi, &mut since) { continue 'outer },\n                         \"note\" => if !get(mi, &mut note) { continue 'outer },\n                         _ => {\n                             handle_errors(diagnostic, meta.span,\n-                                          AttrError::UnknownMetaItem(mi.ident.name));\n+                                          AttrError::UnknownMetaItem(mi.name()));\n                             continue 'outer\n                         }\n                     }\n@@ -990,7 +1003,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n \n                 let mut recognised = false;\n                 if let Some(mi) = item.word() {\n-                    let word = &*mi.ident.name.as_str();\n+                    let word = &*mi.name().as_str();\n                     let hint = match word {\n                         \"C\" => Some(ReprC),\n                         \"packed\" => Some(ReprPacked(1)),\n@@ -1047,7 +1060,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                     }\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.ident.name == \"align\" {\n+                        if meta_item.name() == \"align\" {\n                             if let MetaItemKind::NameValue(ref value) = meta_item.node {\n                                 recognised = true;\n                                 let mut err = struct_span_err!(diagnostic, item.span, E0693,\n@@ -1127,18 +1140,56 @@ impl IntType {\n \n impl MetaItem {\n     fn tokens(&self) -> TokenStream {\n-        let ident = TokenTree::Token(self.span, Token::from_ast_ident(self.ident));\n-        TokenStream::concat(vec![ident.into(), self.node.tokens(self.span)])\n+        let mut idents = vec![];\n+        let mut last_pos = BytePos(0 as u32);\n+        for (i, segment) in self.ident.segments.iter().enumerate() {\n+            let is_first = i == 0;\n+            if !is_first {\n+                let mod_sep_span = Span::new(last_pos,\n+                                             segment.ident.span.lo(),\n+                                             segment.ident.span.ctxt());\n+                idents.push(TokenTree::Token(mod_sep_span, Token::ModSep).into());\n+            }\n+            idents.push(TokenTree::Token(segment.ident.span,\n+                                         Token::from_ast_ident(segment.ident)).into());\n+            last_pos = segment.ident.span.hi();\n+        }\n+        idents.push(self.node.tokens(self.span));\n+        TokenStream::concat(idents)\n     }\n \n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n         where I: Iterator<Item = TokenTree>,\n     {\n-        let (span, ident) = match tokens.next() {\n-            Some(TokenTree::Token(span, Token::Ident(ident, _))) => (span, ident),\n+        // FIXME: Share code with `parse_path`.\n+        let ident = match tokens.next() {\n+            Some(TokenTree::Token(span, Token::Ident(ident, _))) => {\n+                if let Some(TokenTree::Token(_, Token::ModSep)) = tokens.peek() {\n+                    let mut segments = vec![PathSegment::from_ident(ident.with_span_pos(span))];\n+                    tokens.next();\n+                    loop {\n+                        if let Some(TokenTree::Token(span,\n+                                                     Token::Ident(ident, _))) = tokens.next() {\n+                            segments.push(PathSegment::from_ident(ident.with_span_pos(span)));\n+                        } else {\n+                            return None;\n+                        }\n+                        if let Some(TokenTree::Token(_, Token::ModSep)) = tokens.peek() {\n+                            tokens.next();\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n+                    Path { span, segments }\n+                } else {\n+                    Path::from_ident(ident.with_span_pos(span))\n+                }\n+            }\n             Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match nt.0 {\n-                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident),\n+                token::Nonterminal::NtIdent(ident, _) => Path::from_ident(ident),\n                 token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n+                token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,\n             },\n             _ => return None,\n@@ -1147,10 +1198,11 @@ impl MetaItem {\n         let node = MetaItemKind::from_tokens(tokens)?;\n         let hi = match node {\n             MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n-            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi()),\n-            _ => span.hi(),\n+            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(ident.span.hi()),\n+            _ => ident.span.hi(),\n         };\n-        Some(MetaItem { ident, node, span: span.with_hi(hi) })\n+        let span = ident.span.with_hi(hi);\n+        Some(MetaItem { ident, node, span })\n     }\n }\n "}, {"sha": "5f940437ab3fbc37395fc0d007be2defdc9afaa9", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -336,4 +336,5 @@ register_diagnostics! {\n     E0629, // missing 'feature' (rustc_const_unstable)\n     E0630, // rustc_const_unstable attribute must be paired with stable/unstable attribute\n     E0693, // incorrect `repr(align)` attribute format\n+    E0694, // an unknown tool name found in scoped attributes\n }"}, {"sha": "584b9455a93ada1e39174e6ed92c7ae2ab2eaf50", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -810,7 +810,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    ident: keywords::Invalid.ident(),\n+                    ident: Path::from_ident(keywords::Invalid.ident()),\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n@@ -1017,7 +1017,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n         let features = self.cx.ecfg.features.unwrap();\n         for attr in attrs.iter() {\n-            feature_gate::check_attribute(attr, self.cx.parse_sess, features);\n+            self.check_attribute_inner(attr, features);\n \n             // macros are expanded before any lint passes so this warning has to be hardcoded\n             if attr.path == \"derive\" {\n@@ -1030,6 +1030,10 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn check_attribute(&mut self, at: &ast::Attribute) {\n         let features = self.cx.ecfg.features.unwrap();\n+        self.check_attribute_inner(at, features);\n+    }\n+\n+    fn check_attribute_inner(&mut self, at: &ast::Attribute, features: &Features) {\n         feature_gate::check_attribute(at, self.cx.parse_sess, features);\n     }\n }"}, {"sha": "d8db76a95ff38ef1fde952f99658dd42e6d2d7b9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -460,6 +460,9 @@ declare_features! (\n \n     // Access to crate names passed via `--extern` through prelude\n     (active, extern_prelude, \"1.27.0\", Some(44660), Some(Edition::Edition2018)),\n+\n+    // Scoped attributes\n+    (active, tool_attributes, \"1.25.0\", Some(44690), None),\n );\n \n declare_features! (\n@@ -1079,7 +1082,7 @@ pub struct GatedCfg {\n \n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        let name = cfg.ident.name.as_str();\n+        let name = cfg.name().as_str();\n         GATED_CFGS.iter()\n                   .position(|info| info.0 == name)\n                   .map(|idx| {\n@@ -1132,7 +1135,7 @@ macro_rules! gate_feature {\n impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n-        let name = unwrap_or!(attr.name(), return).as_str();\n+        let name = attr.name().as_str();\n         for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n             if name == n {\n                 if let Gated(_, name, desc, ref has_feature) = *gateage {\n@@ -1172,12 +1175,28 @@ impl<'a> Context<'a> {\n             // before the plugin attributes are registered\n             // so we skip this then\n             if !is_macro {\n-                gate_feature!(self, custom_attribute, attr.span,\n-                              &format!(\"The attribute `{}` is currently \\\n-                                        unknown to the compiler and \\\n-                                        may have meaning \\\n-                                        added to it in the future\",\n-                                       attr.path));\n+                if attr.is_scoped() {\n+                    gate_feature!(self, tool_attributes, attr.span,\n+                                  &format!(\"scoped attribute `{}` is experimental\", attr.path));\n+                    if attr::is_known_tool(attr) {\n+                        attr::mark_used(attr);\n+                    } else {\n+                        span_err!(\n+                            self.parse_sess.span_diagnostic,\n+                            attr.span,\n+                            E0694,\n+                            \"an unknown tool name found in scoped attribute: `{}`.\",\n+                            attr.path\n+                        );\n+                    }\n+                } else {\n+                    gate_feature!(self, custom_attribute, attr.span,\n+                                  &format!(\"The attribute `{}` is currently \\\n+                                            unknown to the compiler and \\\n+                                            may have meaning \\\n+                                            added to it in the future\",\n+                                           attr.path));\n+                }\n             }\n         }\n     }\n@@ -1843,7 +1862,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n                 for mi in list {\n \n                     let name = if let Some(word) = mi.word() {\n-                        word.ident.name\n+                        word.name()\n                     } else {\n                         span_err!(span_handler, mi.span, E0556,\n                                   \"malformed feature, expected just one word\");"}, {"sha": "cceed589212561c06d0482a79b7f011222956156", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -149,7 +149,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(if let Some(meta) = meta {\n             self.bump();\n-            (ast::Path::from_ident(meta.ident), meta.node.tokens(meta.span))\n+            (meta.ident, meta.node.tokens(meta.span))\n         } else {\n             (self.parse_path(PathStyle::Mod)?, self.parse_tokens())\n         })\n@@ -225,9 +225,10 @@ impl<'a> Parser<'a> {\n         }\n \n         let lo = self.span;\n-        let ident = self.parse_ident()?;\n+        let ident = self.parse_path(PathStyle::Mod)?;\n         let node = self.parse_meta_item_kind()?;\n-        Ok(ast::MetaItem { ident, node: node, span: lo.to(self.prev_span) })\n+        let span = lo.to(self.prev_span);\n+        Ok(ast::MetaItem { ident, node, span })\n     }\n \n     pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {"}, {"sha": "0e3bced3222f6d489c27cf7f0b4c9b787f242e7c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -1958,16 +1958,16 @@ impl<'a> Parser<'a> {\n         let meta_ident = match self.token {\n             token::Interpolated(ref nt) => match nt.0 {\n                 token::NtMeta(ref meta) => match meta.node {\n-                    ast::MetaItemKind::Word => Some(meta.ident),\n+                    ast::MetaItemKind::Word => Some(meta.ident.clone()),\n                     _ => None,\n                 },\n                 _ => None,\n             },\n             _ => None,\n         };\n-        if let Some(ident) = meta_ident {\n+        if let Some(path) = meta_ident {\n             self.bump();\n-            return Ok(ast::Path::from_ident(ident));\n+            return Ok(path);\n         }\n         self.parse_path(style)\n     }"}, {"sha": "d8228e2b28be71ac39ed3dfdeb54ab0aef50805f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -714,6 +714,22 @@ pub trait PrintState<'a> {\n         Ok(())\n     }\n \n+    fn print_attribute_path(&mut self, path: &ast::Path) -> io::Result<()> {\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            if i > 0 {\n+                self.writer().word(\"::\")?\n+            }\n+            if segment.ident.name != keywords::CrateRoot.name() &&\n+               segment.ident.name != keywords::DollarCrate.name()\n+            {\n+                self.writer().word(&segment.ident.name.as_str())?;\n+            } else if segment.ident.name == keywords::DollarCrate.name() {\n+                self.print_dollar_crate(segment.ident.span.ctxt())?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn print_attribute(&mut self, attr: &ast::Attribute) -> io::Result<()> {\n         self.print_attribute_inline(attr, false)\n     }\n@@ -735,17 +751,7 @@ pub trait PrintState<'a> {\n             if let Some(mi) = attr.meta() {\n                 self.print_meta_item(&mi)?\n             } else {\n-                for (i, segment) in attr.path.segments.iter().enumerate() {\n-                    if i > 0 {\n-                        self.writer().word(\"::\")?\n-                    }\n-                    if segment.ident.name != keywords::CrateRoot.name() &&\n-                       segment.ident.name != keywords::DollarCrate.name() {\n-                        self.writer().word(&segment.ident.name.as_str())?;\n-                    } else if segment.ident.name == keywords::DollarCrate.name() {\n-                        self.print_dollar_crate(segment.ident.span.ctxt())?;\n-                    }\n-                }\n+                self.print_attribute_path(&attr.path)?;\n                 self.writer().space()?;\n                 self.print_tts(attr.tokens.clone())?;\n             }\n@@ -767,16 +773,15 @@ pub trait PrintState<'a> {\n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n         match item.node {\n-            ast::MetaItemKind::Word => {\n-                self.writer().word(&item.ident.name.as_str())?;\n-            }\n+            ast::MetaItemKind::Word => self.print_attribute_path(&item.ident)?,\n             ast::MetaItemKind::NameValue(ref value) => {\n-                self.word_space(&item.ident.name.as_str())?;\n+                self.print_attribute_path(&item.ident)?;\n+                self.writer().space()?;\n                 self.word_space(\"=\")?;\n                 self.print_literal(value)?;\n             }\n             ast::MetaItemKind::List(ref items) => {\n-                self.writer().word(&item.ident.name.as_str())?;\n+                self.print_attribute_path(&item.ident)?;\n                 self.popen()?;\n                 self.commasep(Consistent,\n                               &items[..],"}, {"sha": "76da1746a0397a100b4901f9e55d4dcd0b997800", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -22,11 +22,9 @@ struct MarkAttrs<'a>(&'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n-        if let Some(name) = attr.name() {\n-            if self.0.contains(&name) {\n-                mark_used(attr);\n-                mark_known(attr);\n-            }\n+        if self.0.contains(&attr.name()) {\n+            mark_used(attr);\n+            mark_known(attr);\n         }\n     }\n "}, {"sha": "80f65957c39a2e3935c41ef99b961c2c083e50bd", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -472,7 +472,7 @@ impl<'a> TraitDef<'a> {\n                 attrs.extend(item.attrs\n                     .iter()\n                     .filter(|a| {\n-                        a.name().is_some() && match &*a.name().unwrap().as_str() {\n+                        match &*a.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n                             _ => false,\n                         }"}, {"sha": "fb0f9105b0d8a949cf2501a33bafd242c95fe443", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -117,7 +117,7 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                word.ident\n+                word.ident.segments.last().unwrap().ident\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "5a7536ca3304bd090bc33a5b1a637bbd3b2b9767", "filename": "src/test/compile-fail/feature-gate-tool_attributes.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fcompile-fail%2Ffeature-gate-tool_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fcompile-fail%2Ffeature-gate-tool_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-tool_attributes.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    #[rustfmt::skip] //~ ERROR scoped attribute `rustfmt::skip` is experimental\n+    let x =\n+        3;\n+}"}, {"sha": "c2192a21d90501026685cdeadd82c30dff2e3086", "filename": "src/test/compile-fail/unknown-tool-name.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fcompile-fail%2Funknown-tool-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fcompile-fail%2Funknown-tool-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funknown-tool-name.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(tool_attributes)]\n+\n+#![foo::bar] //~ ERROR an unknown tool name found in scoped attribute: `foo::bar`. [E0694]\n+\n+#[foo::bar] //~ ERROR an unknown tool name found in scoped attribute: `foo::bar`. [E0694]\n+fn main() {}"}, {"sha": "ba38c297a1127924e9d5cd62778ca254f8baeba8", "filename": "src/test/compile-fail/unknown_tool_attributes-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fcompile-fail%2Funknown_tool_attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fcompile-fail%2Funknown_tool_attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funknown_tool_attributes-1.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure that 'custom_attributes' feature does not allow scoped attributes.\n+\n+#![feature(custom_attributes)]\n+\n+#[foo::bar]\n+//~^ ERROR scoped attribute `foo::bar` is experimental (see issue #44690) [E0658]\n+//~^^ ERROR an unknown tool name found in scoped attribute: `foo::bar`. [E0694]\n+fn main() {}"}, {"sha": "d698af50579ad91de914d062717fb131dd8077c6", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -112,7 +112,7 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                word.ident\n+                word.ident.segments.last().unwrap().ident\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "eb13930de403f2877c73e01aa8b37149a3b1c333", "filename": "src/test/run-pass/tool_attributes.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Frun-pass%2Ftool_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Frun-pass%2Ftool_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftool_attributes.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Scoped attributes should not trigger an unused attributes lint.\n+\n+#![feature(tool_attributes)]\n+#![deny(unused_attributes)]\n+\n+fn main() {\n+    #[rustfmt::skip]\n+    foo ();\n+}\n+\n+fn foo() {\n+    assert!(true);\n+}"}, {"sha": "2b7cf56d9381291f1aed2a4fa13af3dc1a0677c4", "filename": "src/test/ui/feature-gate-tool_attributes.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.rs?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    #[rustfmt::skip] //~ ERROR scoped attribute `rustfmt::skip` is experimental\n+    let x = 3\n+        ;\n+}"}, {"sha": "da89c4a5ef692634badba632f031afb2c0009dcb", "filename": "src/test/ui/feature-gate-tool_attributes.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d68b0eceaaf719a4702ab13a7ca62dea5d966082/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-tool_attributes.stderr?ref=d68b0eceaaf719a4702ab13a7ca62dea5d966082", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: scoped attribute `rustfmt::skip` is experimental (see issue #44690)\n+  --> $DIR/feature-gate-tool_attributes.rs:12:5\n+   |\n+LL |     #[rustfmt::skip] //~ ERROR scoped attribute `rustfmt::skip` is experimental\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(tool_attributes)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}]}