{"sha": "4076ba8a77326c70645f6c4a4351b0d84c5c898f", "node_id": "C_kwDOAAsO6NoAKDQwNzZiYThhNzczMjZjNzA2NDVmNmM0YTQzNTFiMGQ4NGM1Yzg5OGY", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-06-23T05:21:58Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-10-29T15:55:01Z"}, "message": "Implement scatter/gather with new pointer vector and add tests", "tree": {"sha": "d523bd93ee272e435a9badfc6a27c5106145ac33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d523bd93ee272e435a9badfc6a27c5106145ac33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4076ba8a77326c70645f6c4a4351b0d84c5c898f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4076ba8a77326c70645f6c4a4351b0d84c5c898f", "html_url": "https://github.com/rust-lang/rust/commit/4076ba8a77326c70645f6c4a4351b0d84c5c898f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4076ba8a77326c70645f6c4a4351b0d84c5c898f/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e96f5dbea3fd2291f0e835a21ed0c41f6ef086e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e96f5dbea3fd2291f0e835a21ed0c41f6ef086e", "html_url": "https://github.com/rust-lang/rust/commit/7e96f5dbea3fd2291f0e835a21ed0c41f6ef086e"}], "stats": {"total": 438, "additions": 277, "deletions": 161}, "files": [{"sha": "d62d3f6635d5322b570263e4028617f11b17cb1d", "filename": "crates/core_simd/src/cast.rs", "status": "modified", "additions": 108, "deletions": 24, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcast.rs?ref=4076ba8a77326c70645f6c4a4351b0d84c5c898f", "patch": "@@ -1,25 +1,41 @@\n-use crate::simd::SimdElement;\n+use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SupportedLaneCount};\n \n /// Supporting trait for `Simd::cast`.  Typically doesn't need to be used directly.\n-pub trait SimdCast<Target: SimdElement>: SimdElement {}\n+pub trait SimdCast<Target: SimdElement>: SimdElement {\n+    #[doc(hidden)]\n+    fn cast<const LANES: usize>(x: Simd<Self, LANES>) -> Simd<Target, LANES>\n+    where\n+        LaneCount<LANES>: SupportedLaneCount;\n+}\n \n macro_rules! into_number {\n+    { $from:ty, $to:ty } => {\n+        impl SimdCast<$to> for $from {\n+            fn cast<const LANES: usize>(x: Simd<Self, LANES>) -> Simd<$to, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                // Safety: simd_as can handle numeric conversions\n+                unsafe { intrinsics::simd_as(x) }\n+            }\n+        }\n+    };\n     { $($type:ty),* } => {\n         $(\n-        impl SimdCast<i8> for $type {}\n-        impl SimdCast<i16> for $type {}\n-        impl SimdCast<i32> for $type {}\n-        impl SimdCast<i64> for $type {}\n-        impl SimdCast<isize> for $type {}\n-\n-        impl SimdCast<u8> for $type {}\n-        impl SimdCast<u16> for $type {}\n-        impl SimdCast<u32> for $type {}\n-        impl SimdCast<u64> for $type {}\n-        impl SimdCast<usize> for $type {}\n-\n-        impl SimdCast<f32> for $type {}\n-        impl SimdCast<f64> for $type {}\n+        into_number! { $type, i8 }\n+        into_number! { $type, i16 }\n+        into_number! { $type, i32 }\n+        into_number! { $type, i64 }\n+        into_number! { $type, isize }\n+\n+        into_number! { $type, u8 }\n+        into_number! { $type, u16 }\n+        into_number! { $type, u32 }\n+        into_number! { $type, u64 }\n+        into_number! { $type, usize }\n+\n+        into_number! { $type, f32 }\n+        into_number! { $type, f64 }\n         )*\n     }\n }\n@@ -29,17 +45,85 @@ into_number! { i8, i16, i32, i64, isize, u8, u16, u32, u64, usize, f32, f64 }\n macro_rules! into_pointer {\n     { $($type:ty),* } => {\n         $(\n-        impl<T> SimdCast<$type> for *const T {}\n-        impl<T> SimdCast<$type> for *mut T {}\n-        impl<T> SimdCast<*const T> for $type {}\n-        impl<T> SimdCast<*mut T> for $type {}\n+        impl<T> SimdCast<$type> for *const T {\n+            fn cast<const LANES: usize>(x: Simd<Self, LANES>) -> Simd<$type, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                // Safety: transmuting isize to pointers is safe\n+                let x: Simd<isize, LANES> = unsafe { core::mem::transmute_copy(&x) };\n+                x.cast()\n+            }\n+        }\n+        impl<T> SimdCast<$type> for *mut T {\n+            fn cast<const LANES: usize>(x: Simd<Self, LANES>) -> Simd<$type, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                // Safety: transmuting isize to pointers is safe\n+                let x: Simd<isize, LANES> = unsafe { core::mem::transmute_copy(&x) };\n+                x.cast()\n+            }\n+        }\n+        impl<T> SimdCast<*const T> for $type {\n+            fn cast<const LANES: usize>(x: Simd<$type, LANES>) -> Simd<*const T, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                let x: Simd<isize, LANES> = x.cast();\n+                // Safety: transmuting isize to pointers is safe\n+                unsafe { core::mem::transmute_copy(&x) }\n+            }\n+        }\n+        impl<T> SimdCast<*mut T> for $type {\n+            fn cast<const LANES: usize>(x: Simd<$type, LANES>) -> Simd<*mut T, LANES>\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                let x: Simd<isize, LANES> = x.cast();\n+                // Safety: transmuting isize to pointers is safe\n+                unsafe { core::mem::transmute_copy(&x) }\n+            }\n+        }\n         )*\n     }\n }\n \n into_pointer! { i8, i16, i32, i64, isize, u8, u16, u32, u64, usize }\n \n-impl<T, U> SimdCast<*const T> for *const U {}\n-impl<T, U> SimdCast<*const T> for *mut U {}\n-impl<T, U> SimdCast<*mut T> for *const U {}\n-impl<T, U> SimdCast<*mut T> for *mut U {}\n+impl<T, U> SimdCast<*const T> for *const U {\n+    fn cast<const LANES: usize>(x: Simd<*const U, LANES>) -> Simd<*const T, LANES>\n+    where\n+        LaneCount<LANES>: SupportedLaneCount,\n+    {\n+        // Safety: transmuting pointers is safe\n+        unsafe { core::mem::transmute_copy(&x) }\n+    }\n+}\n+impl<T, U> SimdCast<*const T> for *mut U {\n+    fn cast<const LANES: usize>(x: Simd<*mut U, LANES>) -> Simd<*const T, LANES>\n+    where\n+        LaneCount<LANES>: SupportedLaneCount,\n+    {\n+        // Safety: transmuting pointers is safe\n+        unsafe { core::mem::transmute_copy(&x) }\n+    }\n+}\n+impl<T, U> SimdCast<*mut T> for *const U {\n+    fn cast<const LANES: usize>(x: Simd<*const U, LANES>) -> Simd<*mut T, LANES>\n+    where\n+        LaneCount<LANES>: SupportedLaneCount,\n+    {\n+        // Safety: transmuting pointers is safe\n+        unsafe { core::mem::transmute_copy(&x) }\n+    }\n+}\n+impl<T, U> SimdCast<*mut T> for *mut U {\n+    fn cast<const LANES: usize>(x: Simd<*mut U, LANES>) -> Simd<*mut T, LANES>\n+    where\n+        LaneCount<LANES>: SupportedLaneCount,\n+    {\n+        // Safety: transmuting pointers is safe\n+        unsafe { core::mem::transmute_copy(&x) }\n+    }\n+}"}, {"sha": "c4a254f5ab1fac165618e29522f17d32e8a1f73f", "filename": "crates/core_simd/src/elements/const_ptr.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs?ref=4076ba8a77326c70645f6c4a4351b0d84c5c898f", "patch": "@@ -3,8 +3,8 @@ use crate::simd::{LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n \n /// Operations on SIMD vectors of constant pointers.\n pub trait SimdConstPtr: Copy + Sealed {\n-    /// Vector type representing the pointers as bits.\n-    type Bits;\n+    /// Vector of usize with the same number of lanes.\n+    type Usize;\n \n     /// Vector of mutable pointers to the same type.\n     type MutPtr;\n@@ -18,11 +18,15 @@ pub trait SimdConstPtr: Copy + Sealed {\n     /// Changes constness without changing the type.\n     fn as_mut(self) -> Self::MutPtr;\n \n-    /// Cast pointers to raw bits.\n-    fn to_bits(self) -> Self::Bits;\n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::addr`] on each lane.\n+    fn addr(self) -> Self::Usize;\n \n-    /// Cast raw bits to pointers.\n-    fn from_bits(bits: Self::Bits) -> Self;\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_add`] on each lane.\n+    fn wrapping_add(self, count: Self::Usize) -> Self;\n }\n \n impl<T, const LANES: usize> Sealed for Simd<*const T, LANES> where\n@@ -34,23 +38,29 @@ impl<T, const LANES: usize> SimdConstPtr for Simd<*const T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    type Bits = Simd<usize, LANES>;\n+    type Usize = Simd<usize, LANES>;\n     type MutPtr = Simd<*mut T, LANES>;\n     type Mask = Mask<isize, LANES>;\n \n+    #[inline]\n     fn is_null(self) -> Self::Mask {\n         Simd::splat(core::ptr::null()).simd_eq(self)\n     }\n \n+    #[inline]\n     fn as_mut(self) -> Self::MutPtr {\n         self.cast()\n     }\n \n-    fn to_bits(self) -> Self::Bits {\n+    #[inline]\n+    fn addr(self) -> Self::Usize {\n         self.cast()\n     }\n \n-    fn from_bits(bits: Self::Bits) -> Self {\n-        bits.cast()\n+    #[inline]\n+    fn wrapping_add(self, count: Self::Usize) -> Self {\n+        let addr = self.addr() + (count * Simd::splat(core::mem::size_of::<T>()));\n+        // Safety: transmuting usize to pointers is safe, even if accessing those pointers isn't.\n+        unsafe { core::mem::transmute_copy(&addr) }\n     }\n }"}, {"sha": "5920960c49ceab143a5613eb5b22d77a2a3f3260", "filename": "crates/core_simd/src/elements/mut_ptr.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs?ref=4076ba8a77326c70645f6c4a4351b0d84c5c898f", "patch": "@@ -3,8 +3,8 @@ use crate::simd::{LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n \n /// Operations on SIMD vectors of mutable pointers.\n pub trait SimdMutPtr: Copy + Sealed {\n-    /// Vector type representing the pointers as bits.\n-    type Bits;\n+    /// Vector of usize with the same number of lanes.\n+    type Usize;\n \n     /// Vector of constant pointers to the same type.\n     type ConstPtr;\n@@ -18,11 +18,15 @@ pub trait SimdMutPtr: Copy + Sealed {\n     /// Changes constness without changing the type.\n     fn as_const(self) -> Self::ConstPtr;\n \n-    /// Cast pointers to raw bits.\n-    fn to_bits(self) -> Self::Bits;\n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::addr`] on each lane.\n+    fn addr(self) -> Self::Usize;\n \n-    /// Cast raw bits to pointers.\n-    fn from_bits(bits: Self::Bits) -> Self;\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_add`] on each lane.\n+    fn wrapping_add(self, count: Self::Usize) -> Self;\n }\n \n impl<T, const LANES: usize> Sealed for Simd<*mut T, LANES> where LaneCount<LANES>: SupportedLaneCount\n@@ -32,23 +36,29 @@ impl<T, const LANES: usize> SimdMutPtr for Simd<*mut T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    type Bits = Simd<usize, LANES>;\n+    type Usize = Simd<usize, LANES>;\n     type ConstPtr = Simd<*const T, LANES>;\n     type Mask = Mask<isize, LANES>;\n \n+    #[inline]\n     fn is_null(self) -> Self::Mask {\n         Simd::splat(core::ptr::null_mut()).simd_eq(self)\n     }\n \n+    #[inline]\n     fn as_const(self) -> Self::ConstPtr {\n         self.cast()\n     }\n \n-    fn to_bits(self) -> Self::Bits {\n+    #[inline]\n+    fn addr(self) -> Self::Usize {\n         self.cast()\n     }\n \n-    fn from_bits(bits: Self::Bits) -> Self {\n-        bits.cast()\n+    #[inline]\n+    fn wrapping_add(self, count: Self::Usize) -> Self {\n+        let addr = self.addr() + (count * Simd::splat(core::mem::size_of::<T>()));\n+        // Safety: transmuting usize to pointers is safe, even if accessing those pointers isn't.\n+        unsafe { core::mem::transmute_copy(&addr) }\n     }\n }"}, {"sha": "80763c07272781d7e370fa788249e0b26382dded", "filename": "crates/core_simd/src/eq.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Feq.rs?ref=4076ba8a77326c70645f6c4a4351b0d84c5c898f", "patch": "@@ -1,4 +1,6 @@\n-use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdConstPtr, SimdElement, SimdMutPtr, SupportedLaneCount,\n+};\n \n /// Parallel `PartialEq`.\n pub trait SimdPartialEq {\n@@ -80,16 +82,12 @@ where\n \n     #[inline]\n     fn simd_eq(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n+        self.addr().simd_eq(other.addr())\n     }\n \n     #[inline]\n     fn simd_ne(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n+        self.addr().simd_ne(other.addr())\n     }\n }\n \n@@ -101,15 +99,11 @@ where\n \n     #[inline]\n     fn simd_eq(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n+        self.addr().simd_eq(other.addr())\n     }\n \n     #[inline]\n     fn simd_ne(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n+        self.addr().simd_ne(other.addr())\n     }\n }"}, {"sha": "1ae9cd061fb2d23f731655bfc82e736cdbe20ec9", "filename": "crates/core_simd/src/ord.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ford.rs?ref=4076ba8a77326c70645f6c4a4351b0d84c5c898f", "patch": "@@ -1,4 +1,6 @@\n-use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdConstPtr, SimdMutPtr, SimdPartialEq, SupportedLaneCount,\n+};\n \n /// Parallel `PartialOrd`.\n pub trait SimdPartialOrd: SimdPartialEq {\n@@ -218,30 +220,22 @@ where\n {\n     #[inline]\n     fn simd_lt(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n+        self.addr().simd_lt(other.addr())\n     }\n \n     #[inline]\n     fn simd_le(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n+        self.addr().simd_le(other.addr())\n     }\n \n     #[inline]\n     fn simd_gt(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n+        self.addr().simd_gt(other.addr())\n     }\n \n     #[inline]\n     fn simd_ge(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n+        self.addr().simd_ge(other.addr())\n     }\n }\n \n@@ -275,30 +269,22 @@ where\n {\n     #[inline]\n     fn simd_lt(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n+        self.addr().simd_lt(other.addr())\n     }\n \n     #[inline]\n     fn simd_le(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n+        self.addr().simd_le(other.addr())\n     }\n \n     #[inline]\n     fn simd_gt(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n+        self.addr().simd_gt(other.addr())\n     }\n \n     #[inline]\n     fn simd_ge(self, other: Self) -> Self::Mask {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n+        self.addr().simd_ge(other.addr())\n     }\n }\n "}, {"sha": "145394a519d129b5a12cfe5a7cf566e23a18b281", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=4076ba8a77326c70645f6c4a4351b0d84c5c898f", "patch": "@@ -1,8 +1,6 @@\n-// Vectors of pointers are not for public use at the current time.\n-pub(crate) mod ptr;\n-\n use crate::simd::{\n-    intrinsics, LaneCount, Mask, MaskElement, SimdCast, SimdPartialOrd, SupportedLaneCount, Swizzle,\n+    intrinsics, LaneCount, Mask, MaskElement, SimdCast, SimdConstPtr, SimdMutPtr, SimdPartialOrd,\n+    SupportedLaneCount, Swizzle,\n };\n \n /// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n@@ -215,8 +213,7 @@ where\n     where\n         T: SimdCast<U>,\n     {\n-        // Safety: The input argument is a vector of a valid SIMD element type.\n-        unsafe { intrinsics::simd_as(self) }\n+        SimdCast::cast(self)\n     }\n \n     /// Rounds toward zero and converts to the same-width integer type, assuming that\n@@ -352,7 +349,7 @@ where\n         idxs: Simd<usize, LANES>,\n         or: Self,\n     ) -> Self {\n-        let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n+        let base_ptr = Simd::<*const T, LANES>::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n         // Safety: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n@@ -460,7 +457,7 @@ where\n         // 3. &mut [T] which will become our base ptr.\n         unsafe {\n             // Now Entering \u2622\ufe0f *mut T Zone\n-            let base_ptr = crate::simd::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n+            let base_ptr = Simd::<*mut T, LANES>::splat(slice.as_mut_ptr());\n             // Ferris forgive me, I have done pointer arithmetic here.\n             let ptrs = base_ptr.wrapping_add(idxs);\n             // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah"}, {"sha": "fa756344db91ae3d57b1096848849fe957e18345", "filename": "crates/core_simd/src/vector/ptr.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7e96f5dbea3fd2291f0e835a21ed0c41f6ef086e/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e96f5dbea3fd2291f0e835a21ed0c41f6ef086e/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=7e96f5dbea3fd2291f0e835a21ed0c41f6ef086e", "patch": "@@ -1,51 +0,0 @@\n-//! Private implementation details of public gather/scatter APIs.\n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n-\n-/// A vector of *const T.\n-#[derive(Debug, Copy, Clone)]\n-#[repr(simd)]\n-pub(crate) struct SimdConstPtr<T, const LANES: usize>([*const T; LANES]);\n-\n-impl<T, const LANES: usize> SimdConstPtr<T, LANES>\n-where\n-    LaneCount<LANES>: SupportedLaneCount,\n-    T: Sized,\n-{\n-    #[inline]\n-    #[must_use]\n-    pub fn splat(ptr: *const T) -> Self {\n-        Self([ptr; LANES])\n-    }\n-\n-    #[inline]\n-    #[must_use]\n-    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n-        // Safety: this intrinsic doesn't have a precondition\n-        unsafe { intrinsics::simd_arith_offset(self, addend) }\n-    }\n-}\n-\n-/// A vector of *mut T. Be very careful around potential aliasing.\n-#[derive(Debug, Copy, Clone)]\n-#[repr(simd)]\n-pub(crate) struct SimdMutPtr<T, const LANES: usize>([*mut T; LANES]);\n-\n-impl<T, const LANES: usize> SimdMutPtr<T, LANES>\n-where\n-    LaneCount<LANES>: SupportedLaneCount,\n-    T: Sized,\n-{\n-    #[inline]\n-    #[must_use]\n-    pub fn splat(ptr: *mut T) -> Self {\n-        Self([ptr; LANES])\n-    }\n-\n-    #[inline]\n-    #[must_use]\n-    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n-        // Safety: this intrinsic doesn't have a precondition\n-        unsafe { intrinsics::simd_arith_offset(self, addend) }\n-    }\n-}"}, {"sha": "df26c462f93d0002ed5f069280422509bebb5453", "filename": "crates/core_simd/tests/pointers.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Ftests%2Fpointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Fcore_simd%2Ftests%2Fpointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fpointers.rs?ref=4076ba8a77326c70645f6c4a4351b0d84c5c898f", "patch": "@@ -0,0 +1,43 @@\n+#![feature(portable_simd, strict_provenance)]\n+\n+use core_simd::{Simd, SimdConstPtr, SimdMutPtr};\n+\n+macro_rules! common_tests {\n+    { $constness:ident } => {\n+        test_helpers::test_lanes! {\n+            fn is_null<const LANES: usize>() {\n+                test_helpers::test_unary_mask_elementwise(\n+                    &Simd::<*$constness (), LANES>::is_null,\n+                    &<*$constness ()>::is_null,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn addr<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    &Simd::<*$constness (), LANES>::addr,\n+                    &<*$constness ()>::addr,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn wrapping_add<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness (), LANES>::wrapping_add,\n+                    &<*$constness ()>::wrapping_add,\n+                    &|_, _| true,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+mod const_ptr {\n+    use super::*;\n+    common_tests! { const }\n+}\n+\n+mod mut_ptr {\n+    use super::*;\n+    common_tests! { mut }\n+}"}, {"sha": "7d91260d838a63b6be90f19e0e1de9d0e45d3eb0", "filename": "crates/test_helpers/src/biteq.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=4076ba8a77326c70645f6c4a4351b0d84c5c898f", "patch": "@@ -55,6 +55,26 @@ macro_rules! impl_float_biteq {\n \n impl_float_biteq! { f32, f64 }\n \n+impl<T> BitEq for *const T {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n+impl<T> BitEq for *mut T {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n impl<T: BitEq, const N: usize> BitEq for [T; N] {\n     fn biteq(&self, other: &Self) -> bool {\n         self.iter()"}, {"sha": "5f2a928b5e4bb29bb526231eef6cbf29c3155dd5", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4076ba8a77326c70645f6c4a4351b0d84c5c898f/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=4076ba8a77326c70645f6c4a4351b0d84c5c898f", "patch": "@@ -38,6 +38,28 @@ impl_num! { usize }\n impl_num! { f32 }\n impl_num! { f64 }\n \n+impl<T> DefaultStrategy for *const T {\n+    type Strategy = proptest::strategy::Map<proptest::num::isize::Any, fn(isize) -> *const T>;\n+    fn default_strategy() -> Self::Strategy {\n+        fn map<T>(x: isize) -> *const T {\n+            x as _\n+        }\n+        use proptest::strategy::Strategy;\n+        proptest::num::isize::ANY.prop_map(map)\n+    }\n+}\n+\n+impl<T> DefaultStrategy for *mut T {\n+    type Strategy = proptest::strategy::Map<proptest::num::isize::Any, fn(isize) -> *mut T>;\n+    fn default_strategy() -> Self::Strategy {\n+        fn map<T>(x: isize) -> *mut T {\n+            x as _\n+        }\n+        use proptest::strategy::Strategy;\n+        proptest::num::isize::ANY.prop_map(map)\n+    }\n+}\n+\n #[cfg(not(target_arch = \"wasm32\"))]\n impl DefaultStrategy for u128 {\n     type Strategy = proptest::num::u128::Any;\n@@ -135,21 +157,21 @@ pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const\n     fs: &dyn Fn(Scalar) -> ScalarResult,\n     check: &dyn Fn([Scalar; LANES]) -> bool,\n ) where\n-    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Scalar: Copy + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n     Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_1(&|x: [Scalar; LANES]| {\n         proptest::prop_assume!(check(x));\n         let result_1: [ScalarResult; LANES] = fv(x.into()).into();\n-        let result_2: [ScalarResult; LANES] = {\n-            let mut result = [ScalarResult::default(); LANES];\n-            for (i, o) in x.iter().zip(result.iter_mut()) {\n-                *o = fs(*i);\n-            }\n-            result\n-        };\n+        let result_2: [ScalarResult; LANES] = x\n+            .iter()\n+            .copied()\n+            .map(fs)\n+            .collect::<Vec<_>>()\n+            .try_into()\n+            .unwrap();\n         crate::prop_assert_biteq!(result_1, result_2);\n         Ok(())\n     });\n@@ -162,7 +184,7 @@ pub fn test_unary_mask_elementwise<Scalar, Vector, Mask, const LANES: usize>(\n     fs: &dyn Fn(Scalar) -> bool,\n     check: &dyn Fn([Scalar; LANES]) -> bool,\n ) where\n-    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar: Copy + core::fmt::Debug + DefaultStrategy,\n     Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n     Mask: Into<[bool; LANES]> + From<[bool; LANES]> + Copy,\n {\n@@ -196,23 +218,24 @@ pub fn test_binary_elementwise<\n     fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n     check: &dyn Fn([Scalar1; LANES], [Scalar2; LANES]) -> bool,\n ) where\n-    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Scalar1: Copy + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n     Vector1: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n     Vector2: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_2(&|x: [Scalar1; LANES], y: [Scalar2; LANES]| {\n         proptest::prop_assume!(check(x, y));\n         let result_1: [ScalarResult; LANES] = fv(x.into(), y.into()).into();\n-        let result_2: [ScalarResult; LANES] = {\n-            let mut result = [ScalarResult::default(); LANES];\n-            for ((i1, i2), o) in x.iter().zip(y.iter()).zip(result.iter_mut()) {\n-                *o = fs(*i1, *i2);\n-            }\n-            result\n-        };\n+        let result_2: [ScalarResult; LANES] = x\n+            .iter()\n+            .copied()\n+            .zip(y.iter().copied())\n+            .map(|(x, y)| fs(x, y))\n+            .collect::<Vec<_>>()\n+            .try_into()\n+            .unwrap();\n         crate::prop_assert_biteq!(result_1, result_2);\n         Ok(())\n     });"}]}