{"sha": "166a558da6793a040657efdcb5fad13cedc6ea15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NmE1NThkYTY3OTNhMDQwNjU3ZWZkY2I1ZmFkMTNjZWRjNmVhMTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-01T15:35:45Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-05T06:33:09Z"}, "message": "resolve: revamp already-bound check -- fix some bugs.", "tree": {"sha": "cd22e5458d804946227d117056235d48f27b8cb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd22e5458d804946227d117056235d48f27b8cb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/166a558da6793a040657efdcb5fad13cedc6ea15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/166a558da6793a040657efdcb5fad13cedc6ea15", "html_url": "https://github.com/rust-lang/rust/commit/166a558da6793a040657efdcb5fad13cedc6ea15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/166a558da6793a040657efdcb5fad13cedc6ea15/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70cae78387034d04a5a43360744266d3657a1884", "url": "https://api.github.com/repos/rust-lang/rust/commits/70cae78387034d04a5a43360744266d3657a1884", "html_url": "https://github.com/rust-lang/rust/commit/70cae78387034d04a5a43360744266d3657a1884"}], "stats": {"total": 138, "additions": 79, "deletions": 59}, "files": [{"sha": "0b5d926d83d69174366f9e87e01fd68c8dbb4d67", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/166a558da6793a040657efdcb5fad13cedc6ea15/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166a558da6793a040657efdcb5fad13cedc6ea15/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=166a558da6793a040657efdcb5fad13cedc6ea15", "patch": "@@ -18,8 +18,7 @@ use rustc::hir::def::{self, PartialRes, DefKind, CtorKind, PerNS};\n use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::TraitCandidate;\n-use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::fx::FxIndexMap;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use smallvec::{smallvec, SmallVec};\n use syntax::{unwrap_or, walk_list};\n use syntax::ast::*;\n@@ -409,7 +408,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n-    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, _: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, _: Span, _: NodeId) {\n         debug!(\"(resolving function) entering function\");\n         let rib_kind = match fn_kind {\n             FnKind::ItemFn(..) => FnItemRibKind,\n@@ -421,7 +420,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             // Create a label rib for the function.\n             this.with_label_rib(rib_kind, |this| {\n                 // Add each argument to the rib.\n-                this.resolve_params(&declaration.inputs, id);\n+                this.resolve_params(&declaration.inputs);\n \n                 visit::walk_fn_ret_ty(this, &declaration.output);\n \n@@ -1109,10 +1108,10 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn resolve_params(&mut self, params: &[Param], id: NodeId) {\n-        let mut bindings = FxIndexMap::default();\n+    fn resolve_params(&mut self, params: &[Param]) {\n+        let mut bindings = smallvec![(false, <_>::default())];\n         for Param { pat, ty, .. } in params {\n-            self.resolve_pattern(pat, PatternSource::FnParam, &mut smallvec![id], &mut bindings);\n+            self.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n             self.visit_ty(ty);\n             debug!(\"(resolving function / closure) recorded parameter\");\n         }\n@@ -1220,9 +1219,12 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     /// Arising from `source`, resolve a sequence of patterns (top level or-patterns).\n     fn resolve_pats(&mut self, pats: &[P<Pat>], source: PatternSource) {\n-        let mut bindings_list = FxIndexMap::default();\n+        let mut bindings = smallvec![(true, <_>::default())];\n         for pat in pats {\n-            self.resolve_pattern(pat, source, &mut smallvec![pat.id], &mut bindings_list);\n+            bindings.push((false, <_>::default()));\n+            self.resolve_pattern(pat, source, &mut bindings);\n+            let collected = bindings.pop().unwrap().1;\n+            bindings.last_mut().unwrap().1.extend(collected);\n         }\n         // This has to happen *after* we determine which pat_idents are variants\n         if pats.len() > 1 {\n@@ -1231,26 +1233,24 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     fn resolve_pattern_top(&mut self, pat: &Pat, pat_src: PatternSource) {\n-        self.resolve_pattern(pat, pat_src, &mut smallvec![pat.id], &mut FxIndexMap::default());\n+        self.resolve_pattern(pat, pat_src, &mut smallvec![(false, <_>::default())]);\n     }\n \n     fn resolve_pattern(\n         &mut self,\n         pat: &Pat,\n         pat_src: PatternSource,\n-        prod_ids: &mut SmallVec<[NodeId; 1]>,\n-        bindings: &mut FxIndexMap<Ident, NodeId>,\n+        bindings: &mut SmallVec<[(bool, FxHashSet<Ident>); 1]>,\n     ) {\n-        self.resolve_pattern_inner(pat, pat_src, prod_ids, bindings);\n+        self.resolve_pattern_inner(pat, pat_src, bindings);\n         visit::walk_pat(self, pat);\n     }\n \n     fn resolve_pattern_inner(\n         &mut self,\n         pat: &Pat,\n         pat_src: PatternSource,\n-        prod_ids: &mut SmallVec<[NodeId; 1]>,\n-        bindings: &mut FxIndexMap<Ident, NodeId>,\n+        bindings: &mut SmallVec<[(bool, FxHashSet<Ident>); 1]>,\n     ) {\n         // Visit all direct subpatterns of this pattern.\n         pat.walk(&mut |pat| {\n@@ -1261,9 +1261,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     // then fall back to a fresh binding.\n                     let has_sub = sub.is_some();\n                     let res = self.try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n-                        .unwrap_or_else(|| {\n-                            self.fresh_binding(ident, pat.id, pat_src, prod_ids, bindings)\n-                        });\n+                        .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n                 PatKind::TupleStruct(ref path, ..) => {\n@@ -1276,23 +1274,26 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n                 }\n                 PatKind::Or(ref ps) => {\n-                    let len_before = bindings.len();\n+                    // Add a new set of bindings to the stack. `true` here records that when a\n+                    // binding already exists in this set, it should not result in an error because\n+                    // `V1(a) | V2(a)` must be allowed and are checked for consistency later.\n+                    bindings.push((true, <_>::default()));\n                     for p in ps {\n-                        // We need to change `prod_ids.last()` at this point so that overlapping\n-                        // bindings across the summands in the or-pattern do not result in an error.\n-                        // The idea is that in `V1(a) | V2(a)`, the `a` in `V1` will be inserted\n-                        // with a different id than the one in `V2`. As a result, `V1(a) | V2(a)`\n-                        // compiles as it should. We will later check or-patterns for consistency.\n-                        prod_ids.push(p.id);\n-                        self.resolve_pattern_inner(p, pat_src, prod_ids, bindings);\n-                        prod_ids.pop();\n+                        // Now we need to switch back to a product context so that each\n+                        // part of the or-pattern internally rejects already bound names.\n+                        // For example, `V1(a) | V2(a, a)` and `V1(a, a) | V2(a)` are bad.\n+                        bindings.push((false, <_>::default()));\n+                        self.resolve_pattern_inner(p, pat_src, bindings);\n+                        // Move up the non-overlapping bindings to the or-pattern.\n+                        // Existing bindings just get \"merged\".\n+                        let collected = bindings.pop().unwrap().1;\n+                        bindings.last_mut().unwrap().1.extend(collected);\n                     }\n-\n-                    // We've rejected overlap in each product in the sum.\n-                    // Now we must account for the possibility that the or-pattern is a factor\n-                    // in a product. A basic case to reject here is `(V1(a) | V2(a), a)`.\n-                    let last_id = *prod_ids.last().unwrap();\n-                    bindings.values_mut().skip(len_before).for_each(|val| *val = last_id);\n+                    // This or-pattern itself can itself be part of a product,\n+                    // e.g. `(V1(a) | V2(a), a)` or `(a, V1(a) | V2(a))`.\n+                    // Both cases bind `a` again in a product pattern and must be rejected.\n+                    let collected = bindings.pop().unwrap().1;\n+                    bindings.last_mut().unwrap().1.extend(collected);\n \n                     // Prevent visiting `ps` as we've already done so above.\n                     return false;\n@@ -1308,40 +1309,59 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         ident: Ident,\n         pat_id: NodeId,\n         pat_src: PatternSource,\n-        prod_ids: &[NodeId],\n-        bindings: &mut FxIndexMap<Ident, NodeId>,\n+        bindings: &mut SmallVec<[(bool, FxHashSet<Ident>); 1]>,\n     ) -> Res {\n         // Add the binding to the local ribs, if it doesn't already exist in the bindings map.\n         // (We must not add it if it's in the bindings map because that breaks the assumptions\n         // later passes make about or-patterns.)\n         let ident = ident.modern_and_legacy();\n-        let res = Res::Local(pat_id);\n-        match bindings.get(&ident).cloned() {\n-            Some(id) if prod_ids.contains(&id) => {\n-                // We have some overlap in a product pattern, e.g. `(a, a)` which is not allowed.\n-                use ResolutionError::*;\n-                let error = match pat_src {\n-                    // `fn f(a: u8, a: u8)`:\n-                    PatternSource::FnParam => IdentifierBoundMoreThanOnceInParameterList,\n-                    // `Variant(a, a)`:\n-                    _ => IdentifierBoundMoreThanOnceInSamePattern,\n-                };\n-                self.r.report_error(ident.span, error(&ident.as_str()));\n-            }\n-            Some(..) => {\n-                // `Variant1(a) | Variant2(a)`, ok\n-                // Reuse definition from the first `a`.\n-                return self.innermost_rib_bindings(ValueNS)[&ident];\n+\n+        // Walk outwards the stack of products / or-patterns and\n+        // find out if the identifier has been bound in any of these.\n+        let mut already_bound_and = false;\n+        let mut already_bound_or = false;\n+        for (is_sum, set) in bindings.iter_mut().rev() {\n+            match (is_sum, set.get(&ident).cloned()) {\n+                // Already bound in a product pattern, e.g. `(a, a)` which is not allowed.\n+                (false, Some(..)) => already_bound_and = true,\n+                // Already bound in an or-pattern, e.g. `V1(a) | V2(a)`.\n+                // This is *required* for consistency which is checked later.\n+                (true, Some(..)) => already_bound_or = true,\n+                // Not already bound here.\n+                _ => {}\n             }\n-            // A completely fresh binding, add to the lists if it's valid.\n-            None if ident.name != kw::Invalid => {\n-                bindings.insert(ident, *prod_ids.last().unwrap());\n+        }\n+\n+        if already_bound_and {\n+            // Overlap in a product pattern somewhere; report an error.\n+            use ResolutionError::*;\n+            let error = match pat_src {\n+                // `fn f(a: u8, a: u8)`:\n+                PatternSource::FnParam => IdentifierBoundMoreThanOnceInParameterList,\n+                // `Variant(a, a)`:\n+                _ => IdentifierBoundMoreThanOnceInSamePattern,\n+            };\n+            self.r.report_error(ident.span, error(&ident.as_str()));\n+        }\n+\n+        // Record as bound if it's valid:\n+        let ident_valid = ident.name != kw::Invalid;\n+        if ident_valid {\n+            bindings.last_mut().unwrap().1.insert(ident);\n+        }\n+\n+        if already_bound_or {\n+            // `Variant1(a) | Variant2(a)`, ok\n+            // Reuse definition from the first `a`.\n+            self.innermost_rib_bindings(ValueNS)[&ident]\n+        } else {\n+            let res = Res::Local(pat_id);\n+            if ident_valid {\n+                // A completely fresh binding add to the set if it's valid.\n                 self.innermost_rib_bindings(ValueNS).insert(ident, res);\n             }\n-            None => {}\n+            res\n         }\n-\n-        res\n     }\n \n     fn innermost_rib_bindings(&mut self, ns: Namespace) -> &mut IdentMap<Res> {\n@@ -1873,7 +1893,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             ExprKind::Closure(_, IsAsync::Async { .. }, _, ref fn_decl, ref body, _span) => {\n                 self.with_rib(ValueNS, NormalRibKind, |this| {\n                     // Resolve arguments:\n-                    this.resolve_params(&fn_decl.inputs, expr.id);\n+                    this.resolve_params(&fn_decl.inputs);\n                     // No need to resolve return type --\n                     // the outer closure return type is `FunctionRetTy::Default`.\n "}]}