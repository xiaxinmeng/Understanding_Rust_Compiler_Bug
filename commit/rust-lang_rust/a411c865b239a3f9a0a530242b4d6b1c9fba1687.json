{"sha": "a411c865b239a3f9a0a530242b4d6b1c9fba1687", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MTFjODY1YjIzOWEzZjlhMGE1MzAyNDJiNGQ2YjFjOWZiYTE2ODc=", "commit": {"author": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-07-16T06:01:10Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-16T22:57:24Z"}, "message": "Make clear the differentiation between char pos and byte pos in filemaps. Fix up error printing for files with multi-byte characters.", "tree": {"sha": "1268bc7902e3b9195869fb0f0113cb2f7a2c8589", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1268bc7902e3b9195869fb0f0113cb2f7a2c8589"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a411c865b239a3f9a0a530242b4d6b1c9fba1687", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a411c865b239a3f9a0a530242b4d6b1c9fba1687", "html_url": "https://github.com/rust-lang/rust/commit/a411c865b239a3f9a0a530242b4d6b1c9fba1687", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a411c865b239a3f9a0a530242b4d6b1c9fba1687/comments", "author": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ce43f37d2ba033ff7f4bfddff6edc59ff8aabc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce43f37d2ba033ff7f4bfddff6edc59ff8aabc6", "html_url": "https://github.com/rust-lang/rust/commit/3ce43f37d2ba033ff7f4bfddff6edc59ff8aabc6"}], "stats": {"total": 98, "additions": 64, "deletions": 34}, "files": [{"sha": "b8db7ad3fd3bde84d26e0310e23eb369841882d7", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=a411c865b239a3f9a0a530242b4d6b1c9fba1687", "patch": "@@ -103,7 +103,7 @@ obj session(@config targ_cfg,\n     fn unimpl(str msg) -> ! { self.bug(\"unimplemented \" + msg); }\n     fn get_codemap() -> codemap::codemap { ret parse_sess.cm; }\n     fn lookup_pos(uint pos) -> codemap::loc {\n-        ret codemap::lookup_pos(parse_sess.cm, pos);\n+        ret codemap::lookup_char_pos(parse_sess.cm, pos);\n     }\n     fn get_parse_sess() -> parse_sess { ret parse_sess; }\n     fn next_node_id() -> ast::node_id {"}, {"sha": "9ace3934199cf30282b26d6d2877ab1fca91629e", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=a411c865b239a3f9a0a530242b4d6b1c9fba1687", "patch": "@@ -9,50 +9,69 @@ import std::option::none;\n \n type filename = str;\n \n+type file_pos = rec(uint ch, uint byte);\n+\n /* A codemap is a thing that maps uints to file/line/column positions\n  * in a crate. This to make it possible to represent the positions\n  * with single-word things, rather than passing records all over the\n  * compiler.\n  */\n-type filemap = @rec(filename name, uint start_pos, mutable uint[] lines);\n+type filemap = @rec(filename name, file_pos start_pos,\n+                    mutable file_pos[] lines);\n \n type codemap = @rec(mutable filemap[] files);\n \n type loc = rec(filename filename, uint line, uint col);\n \n fn new_codemap() -> codemap {\n-    let filemap[] files = ~[];\n-    ret @rec(mutable files=files);\n+    ret @rec(mutable files=~[]);\n+}\n+\n+fn new_filemap(filename filename, uint start_pos_ch, uint start_pos_byte)\n+        -> filemap {\n+    ret @rec(name=filename, start_pos=rec(ch=start_pos_ch,\n+                                          byte=start_pos_byte),\n+             mutable lines=~[rec(ch=start_pos_ch, byte=start_pos_byte)]);\n }\n \n-fn new_filemap(filename filename, uint start_pos) -> filemap {\n-    ret @rec(name=filename, start_pos=start_pos, mutable lines=[start_pos]);\n+fn next_line(filemap file, uint chpos, uint byte_pos) {\n+    file.lines += ~[rec(ch=chpos, byte=byte_pos)];\n }\n \n-fn next_line(filemap file, uint pos) { file.lines += ~[pos]; }\n+type lookup_fn = fn (file_pos pos) -> uint;\n \n-fn lookup_pos(codemap map, uint pos) -> loc {\n+fn lookup_pos(codemap map, uint pos, lookup_fn lookup) -> loc {\n     auto a = 0u;\n-    auto b = ivec::len[filemap](map.files);\n+    auto b = ivec::len(map.files);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n-        if (map.files.(m).start_pos > pos) { b = m; } else { a = m; }\n+        if (lookup(map.files.(m).start_pos) > pos) { b = m; } else { a = m; }\n     }\n     auto f = map.files.(a);\n     a = 0u;\n-    b = ivec::len[uint](f.lines);\n+    b = ivec::len(f.lines);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n-        if (f.lines.(m) > pos) { b = m; } else { a = m; }\n+        if (lookup(f.lines.(m)) > pos) { b = m; } else { a = m; }\n     }\n-    ret rec(filename=f.name, line=a + 1u, col=pos - f.lines.(a));\n+    ret rec(filename=f.name, line=a + 1u, col=pos - lookup(f.lines.(a)));\n+}\n+\n+fn lookup_char_pos(codemap map, uint pos) -> loc {\n+    fn lookup(file_pos pos) -> uint { ret pos.ch; }\n+    ret lookup_pos(map, pos, lookup);\n+}\n+\n+fn lookup_byte_pos(codemap map, uint pos) -> loc {\n+    fn lookup(file_pos pos) -> uint { ret pos.byte; }\n+    ret lookup_pos(map, pos, lookup);\n }\n \n type span = rec(uint lo, uint hi);\n \n fn span_to_str(&span sp, &codemap cm) -> str {\n-    auto lo = lookup_pos(cm, sp.lo);\n-    auto hi = lookup_pos(cm, sp.hi);\n+    auto lo = lookup_char_pos(cm, sp.lo);\n+    auto hi = lookup_char_pos(cm, sp.hi);\n     ret #fmt(\"%s:%u:%u:%u:%u\", lo.filename, lo.line, lo.col, hi.line, hi.col);\n }\n \n@@ -115,8 +134,7 @@ fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n \n             // If there's one line at fault we can easily point to the problem\n             if (ivec::len(lines.lines) == 1u) {\n-                auto lo = codemap::lookup_pos(cm, option::get(sp).lo);\n-                auto lo = lookup_pos(cm, option::get(sp).lo);\n+                auto lo = lookup_char_pos(cm, option::get(sp).lo);\n                 auto digits = 0u;\n                 auto num = lines.lines.(0) / 10u;\n \n@@ -129,7 +147,7 @@ fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n                 while (left > 0u) { str::push_char(s, ' '); left -= 1u; }\n \n                 s += \"^\";\n-                auto hi = lookup_pos(cm, option::get(sp).hi);\n+                auto hi = lookup_char_pos(cm, option::get(sp).hi);\n                 if (hi.col != lo.col) {\n                     // the ^ already takes up one space\n                     auto width = hi.col - lo.col - 1u;\n@@ -158,8 +176,8 @@ fn emit_note(&option::t[span] sp, &str msg, &codemap cm) {\n type file_lines = rec(str name, uint[] lines);\n \n fn span_to_lines(span sp, codemap::codemap cm) -> @file_lines {\n-    auto lo = codemap::lookup_pos(cm, sp.lo);\n-    auto hi = codemap::lookup_pos(cm, sp.hi);\n+    auto lo = lookup_char_pos(cm, sp.lo);\n+    auto hi = lookup_char_pos(cm, sp.hi);\n     auto lines = ~[];\n     for each (uint i in uint::range(lo.line - 1u, hi.line as uint)) {\n         lines += ~[i];\n@@ -168,10 +186,10 @@ fn span_to_lines(span sp, codemap::codemap cm) -> @file_lines {\n }\n \n fn get_line(filemap fm, int line, &str file) -> str {\n-    let uint begin = fm.lines.(line) - fm.start_pos;\n+    let uint begin = fm.lines.(line).byte - fm.start_pos.byte;\n     let uint end;\n     if (line as uint < ivec::len(fm.lines) - 1u) {\n-        end = fm.lines.(line + 1) - fm.start_pos;\n+        end = fm.lines.(line + 1).byte - fm.start_pos.byte;\n     } else {\n         // If we're not done parsing the file, we're at the limit of what's\n         // parsed. If we just slice the rest of the string, we'll print out"}, {"sha": "45bc78cdc613f67c95902b00070f2320ec731d8f", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=a411c865b239a3f9a0a530242b4d6b1c9fba1687", "patch": "@@ -21,6 +21,7 @@ type ctx =\n          mutable str[] deps,\n          parser::parse_sess sess,\n          mutable uint chpos,\n+         mutable uint byte_pos,\n          ast::crate_cfg cfg);\n \n fn eval_crate_directives(ctx cx, &(@ast::crate_directive)[] cdirs,\n@@ -56,7 +57,8 @@ fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n             };\n             if (cx.mode == mode_depend) { cx.deps += ~[full_path]; ret; }\n             auto p0 =\n-                new_parser_from_file(cx.sess, cx.cfg, full_path, cx.chpos);\n+                new_parser_from_file(cx.sess, cx.cfg, full_path, cx.chpos,\n+                                     cx.byte_pos);\n             auto inner_attrs = parse_inner_attrs_and_next(p0);\n             auto mod_attrs = attrs + inner_attrs._0;\n             auto first_item_outer_attrs = inner_attrs._1;\n@@ -65,8 +67,9 @@ fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n             auto i = syntax::parse::parser::mk_item\n                 (p0, cdir.span.lo, cdir.span.hi, id, ast::item_mod(m0),\n                  mod_attrs);\n-            // Thread defids and chpos through the parsers\n+            // Thread defids, chpos and byte_pos through the parsers\n             cx.chpos = p0.get_chpos();\n+            cx.byte_pos = p0.get_byte_pos();\n             items += ~[i];\n         }\n         case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs, ?attrs)) {"}, {"sha": "491ce2b1bbc63428970b687974554c228d10e63e", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=a411c865b239a3f9a0a530242b4d6b1c9fba1687", "patch": "@@ -24,6 +24,7 @@ type reader =\n         fn get_mark_str() -> str ;\n         fn get_interner() -> @interner::interner[str] ;\n         fn get_chpos() -> uint ;\n+        fn get_byte_pos() -> uint ;\n         fn get_col() -> uint ;\n         fn get_filemap() -> codemap::filemap ;\n         fn err(str) ;\n@@ -53,6 +54,7 @@ fn new_reader(&codemap::codemap cm, str src, codemap::filemap filemap,\n         }\n         fn get_mark_chpos() -> uint { ret mark_chpos; }\n         fn get_chpos() -> uint { ret chpos; }\n+        fn get_byte_pos() -> uint { ret pos; }\n         fn curr() -> char { ret ch; }\n         fn next() -> char {\n             if (pos < len) {\n@@ -70,7 +72,10 @@ fn new_reader(&codemap::codemap cm, str src, codemap::filemap filemap,\n             if (pos < len) {\n                 col += 1u;\n                 chpos += 1u;\n-                if (ch == '\\n') { codemap::next_line(fm, chpos); col = 0u; }\n+                if (ch == '\\n') {\n+                    codemap::next_line(fm, chpos, pos + fm.start_pos.byte);\n+                    col = 0u;\n+                }\n                 auto next = str::char_range_at(src, pos);\n                 pos = next._1;\n                 ch = next._0;\n@@ -86,7 +91,8 @@ fn new_reader(&codemap::codemap cm, str src, codemap::filemap filemap,\n     let str[] strs = ~[];\n     auto rd =\n         reader(cm, src, str::byte_len(src), 0u, 0u, -1 as char, 0u,\n-               filemap.start_pos, filemap.start_pos, strs, filemap, itr);\n+               filemap.start_pos.ch, filemap.start_pos.ch, strs, filemap,\n+               itr);\n     rd.init();\n     ret rd;\n }\n@@ -737,7 +743,7 @@ fn gather_comments_and_literals(&codemap::codemap cm, str path)\n     auto srdr = ioivec::file_reader(path);\n     auto src = str::unsafe_from_bytes_ivec(srdr.read_whole_stream());\n     auto itr = @interner::mk[str](str::hash, str::eq);\n-    auto rdr = new_reader(cm, src, codemap::new_filemap(path, 0u), itr);\n+    auto rdr = new_reader(cm, src, codemap::new_filemap(path, 0u, 0u), itr);\n     let cmnt[] comments = ~[];\n     let lit[] literals = ~[];\n     let bool first_read = true;"}, {"sha": "183c9ce0c47b73f6e3cb05dd55d0c1afd091a0d5", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=a411c865b239a3f9a0a530242b4d6b1c9fba1687", "patch": "@@ -50,17 +50,18 @@ type parser =\n         fn get_filemap() -> codemap::filemap ;\n         fn get_bad_expr_words() -> hashmap[str, ()] ;\n         fn get_chpos() -> uint ;\n+        fn get_byte_pos() -> uint ;\n         fn get_id() -> ast::node_id ;\n         fn get_sess() -> parse_sess;\n     };\n \n fn new_parser_from_file(parse_sess sess, ast::crate_cfg cfg,\n-                        str path, uint pos) -> parser {\n+                        str path, uint chpos, uint byte_pos) -> parser {\n     auto ftype = SOURCE_FILE;\n     if (str::ends_with(path, \".rc\")) { ftype = CRATE_FILE; }\n     auto srdr = ioivec::file_reader(path);\n     auto src = str::unsafe_from_bytes_ivec(srdr.read_whole_stream());\n-    auto filemap = codemap::new_filemap(path, pos);\n+    auto filemap = codemap::new_filemap(path, chpos, byte_pos);\n     sess.cm.files += ~[filemap];\n     auto itr = @interner::mk(str::hash, str::eq);\n     auto rdr = lexer::new_reader(sess.cm, src, filemap, itr);\n@@ -114,6 +115,7 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n         fn get_filemap() -> codemap::filemap { ret rdr.get_filemap(); }\n         fn get_bad_expr_words() -> hashmap[str, ()] { ret bad_words; }\n         fn get_chpos() -> uint { ret rdr.get_chpos(); }\n+        fn get_byte_pos() -> uint { ret rdr.get_byte_pos(); }\n         fn get_id() -> ast::node_id { ret next_node_id(sess); }\n         fn get_sess() -> parse_sess { ret sess; }\n     }\n@@ -2378,15 +2380,15 @@ fn parse_native_view(&parser p) -> (@ast::view_item)[] {\n \n fn parse_crate_from_source_file(&str input, &ast::crate_cfg cfg,\n                                 &parse_sess sess) -> @ast::crate {\n-    auto p = new_parser_from_file(sess, cfg, input, 0u);\n+    auto p = new_parser_from_file(sess, cfg, input, 0u, 0u);\n     ret parse_crate_mod(p, cfg, sess);\n }\n \n fn parse_crate_from_source_str(&str name, &str source, &ast::crate_cfg cfg,\n                                &codemap::codemap cm) -> @ast::crate {\n     auto sess = @rec(cm=cm, mutable next_id=0);\n     auto ftype = SOURCE_FILE;\n-    auto filemap = codemap::new_filemap(name, 0u);\n+    auto filemap = codemap::new_filemap(name, 0u, 0u);\n     sess.cm.files += ~[filemap];\n     auto itr = @interner::mk(str::hash, str::eq);\n     auto rdr = lexer::new_reader(sess.cm, source, filemap, itr);\n@@ -2504,7 +2506,7 @@ fn parse_crate_directives(&parser p, token::token term,\n \n fn parse_crate_from_crate_file(&str input, &ast::crate_cfg cfg,\n                                &parse_sess sess) -> @ast::crate {\n-    auto p = new_parser_from_file(sess, cfg, input, 0u);\n+    auto p = new_parser_from_file(sess, cfg, input, 0u, 0u);\n     auto lo = p.get_lo_pos();\n     auto prefix = std::fs::dirname(p.get_filemap().name);\n     auto leading_attrs = parse_inner_attrs_and_next(p);\n@@ -2517,6 +2519,7 @@ fn parse_crate_from_crate_file(&str input, &ast::crate_cfg cfg,\n                    mutable deps=deps,\n                    sess=sess,\n                    mutable chpos=p.get_chpos(),\n+                   mutable byte_pos=p.get_byte_pos(),\n                    cfg = p.get_cfg());\n     auto m = eval::eval_crate_directives_to_mod(cx, cdirs, prefix);\n     auto hi = p.get_hi_pos();"}, {"sha": "facf0152430a38df399e54d9b426f3a31ff6e567", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a411c865b239a3f9a0a530242b4d6b1c9fba1687/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=a411c865b239a3f9a0a530242b4d6b1c9fba1687", "patch": "@@ -1345,8 +1345,8 @@ fn maybe_print_trailing_comment(&ps s, codemap::span span,\n     alt (next_comment(s)) {\n         case (some(?cmnt)) {\n             if (cmnt.style != lexer::trailing) { ret; }\n-            auto span_line = codemap::lookup_pos(cm, span.hi);\n-            auto comment_line = codemap::lookup_pos(cm, cmnt.pos);\n+            auto span_line = codemap::lookup_char_pos(cm, span.hi);\n+            auto comment_line = codemap::lookup_char_pos(cm, cmnt.pos);\n             auto next = cmnt.pos + 1u;\n             alt (next_pos) { case (none) { } case (some(?p)) { next = p; } }\n             if (span.hi < cmnt.pos && cmnt.pos < next &&"}]}