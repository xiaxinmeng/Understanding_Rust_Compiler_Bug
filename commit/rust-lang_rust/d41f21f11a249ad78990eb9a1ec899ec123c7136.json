{"sha": "d41f21f11a249ad78990eb9a1ec899ec123c7136", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MWYyMWYxMWEyNDlhZDc4OTkwZWI5YTFlYzg5OWVjMTIzYzcxMzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-24T19:21:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-24T19:21:27Z"}, "message": "Auto merge of #53460 - JoshBrudnak:master, r=estebank\n\nFix compile panic on non existent type return\n\nReverted the change https://github.com/rust-lang/rust/commit/28a76a90009d605349babcd2755962ab93913327#diff-4ed25c00aceb84666fca639cf8101c7cL1069 which was panicking when returning a type that cannot be found in the current scope and added testing for the compile error.\n\nFor example:\n```rust\nfn addition() -> Wrapper<impl A> {}\n```\nWhere Wrapper is undefined in the scope.", "tree": {"sha": "9a4c2a6e83f0d4bb63dcc502ff47bc69008287e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a4c2a6e83f0d4bb63dcc502ff47bc69008287e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d41f21f11a249ad78990eb9a1ec899ec123c7136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d41f21f11a249ad78990eb9a1ec899ec123c7136", "html_url": "https://github.com/rust-lang/rust/commit/d41f21f11a249ad78990eb9a1ec899ec123c7136", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d41f21f11a249ad78990eb9a1ec899ec123c7136/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "727eabd68143e968d8826ee29b8ea7792d29fa96", "url": "https://api.github.com/repos/rust-lang/rust/commits/727eabd68143e968d8826ee29b8ea7792d29fa96", "html_url": "https://github.com/rust-lang/rust/commit/727eabd68143e968d8826ee29b8ea7792d29fa96"}, {"sha": "264d0a2e5c7291dc2dd2701b8e990c6fb58b54ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/264d0a2e5c7291dc2dd2701b8e990c6fb58b54ed", "html_url": "https://github.com/rust-lang/rust/commit/264d0a2e5c7291dc2dd2701b8e990c6fb58b54ed"}], "stats": {"total": 1459, "additions": 847, "deletions": 612}, "files": [{"sha": "e404eb4ecca4955e2458f002441c72b474d48d82", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 816, "deletions": 612, "changes": 1428, "blob_url": "https://github.com/rust-lang/rust/blob/d41f21f11a249ad78990eb9a1ec899ec123c7136/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d41f21f11a249ad78990eb9a1ec899ec123c7136/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d41f21f11a249ad78990eb9a1ec899ec123c7136", "patch": "@@ -25,17 +25,17 @@\n //! crate as a kind of pass. This should eventually be factored away.\n \n use astconv::{AstConv, Bounds};\n-use lint;\n use constrained_type_params as ctp;\n+use lint;\n use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime as rl;\n use rustc::mir::mono::Linkage;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{ToPredicate, ReprOptions};\n-use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::query::Providers;\n-use rustc::ty::util::IntTypeExt;\n+use rustc::ty::subst::Substs;\n use rustc::ty::util::Discr;\n+use rustc::ty::util::IntTypeExt;\n+use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::{ReprOptions, ToPredicate};\n use rustc::util::captures::Captures;\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::abi;\n@@ -44,22 +44,24 @@ use syntax::ast;\n use syntax::ast::MetaItemKind;\n use syntax::attr::{InlineAttr, list_contains_name, mark_used};\n use syntax::source_map::Spanned;\n-use syntax::symbol::{Symbol, keywords};\n use syntax::feature_gate;\n+use syntax::symbol::{keywords, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc::hir::{self, map as hir_map, CodegenFnAttrs, CodegenFnAttrFlags, Unsafety};\n-use rustc::hir::GenericParamKind;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::{CtorKind, Def};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::GenericParamKind;\n+use rustc::hir::{self, map as hir_map, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n pub fn collect_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = CollectItemTypesVisitor { tcx: tcx };\n-    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+    tcx.hir\n+        .krate()\n+        .visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -93,15 +95,15 @@ pub fn provide(providers: &mut Providers) {\n /// `ItemCtxt` is parameterized by a `DefId` that it uses to satisfy\n /// `get_type_parameter_bounds` requests, drawing the information from\n /// the AST (`hir::Generics`), recursively.\n-pub struct ItemCtxt<'a,'tcx:'a> {\n+pub struct ItemCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     item_def_id: DefId,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n \n struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n@@ -118,7 +120,9 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n         for param in &generics.params {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n-                hir::GenericParamKind::Type { default: Some(_), .. } => {\n+                hir::GenericParamKind::Type {\n+                    default: Some(_), ..\n+                } => {\n                     let def_id = self.tcx.hir.local_def_id(param.id);\n                     self.tcx.type_of(def_id);\n                 }\n@@ -152,34 +156,33 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n // Utility types and common code for the above passes.\n \n impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n-           -> ItemCtxt<'a,'tcx> {\n-        ItemCtxt {\n-            tcx,\n-            item_def_id,\n-        }\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId) -> ItemCtxt<'a, 'tcx> {\n+        ItemCtxt { tcx, item_def_id }\n     }\n }\n \n-impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n+impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n     pub fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n \n impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n \n-    fn get_type_parameter_bounds(&self,\n-                                 span: Span,\n-                                 def_id: DefId)\n-                                 -> ty::GenericPredicates<'tcx>\n-    {\n-        self.tcx.at(span).type_param_predicates((self.item_def_id, def_id))\n+    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n+        self.tcx\n+            .at(span)\n+            .type_param_predicates((self.item_def_id, def_id))\n     }\n \n-    fn re_infer(&self, _span: Span, _def: Option<&ty::GenericParamDef>)\n-                -> Option<ty::Region<'tcx>> {\n+    fn re_infer(\n+        &self,\n+        _span: Span,\n+        _def: Option<&ty::GenericParamDef>,\n+    ) -> Option<ty::Region<'tcx>> {\n         None\n     }\n \n@@ -190,23 +193,27 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n             E0121,\n             \"the type placeholder `_` is not allowed within types on item signatures\"\n         ).span_label(span, \"not allowed in type signatures\")\n-        .emit();\n+            .emit();\n         self.tcx().types.err\n     }\n \n-    fn projected_ty_from_poly_trait_ref(&self,\n-                                        span: Span,\n-                                        item_def_id: DefId,\n-                                        poly_trait_ref: ty::PolyTraitRef<'tcx>)\n-                                        -> Ty<'tcx>\n-    {\n+    fn projected_ty_from_poly_trait_ref(\n+        &self,\n+        span: Span,\n+        item_def_id: DefId,\n+        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Ty<'tcx> {\n         if let Some(trait_ref) = poly_trait_ref.no_late_bound_regions() {\n             self.tcx().mk_projection(item_def_id, trait_ref.substs)\n         } else {\n             // no late-bound regions, we can just ignore the binder\n-            span_err!(self.tcx().sess, span, E0212,\n+            span_err!(\n+                self.tcx().sess,\n+                span,\n+                E0212,\n                 \"cannot extract an associated type from a higher-ranked trait bound \\\n-                 in this context\");\n+                 in this context\"\n+            );\n             self.tcx().types.err\n         }\n     }\n@@ -226,9 +233,10 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n }\n \n-fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   (item_def_id, def_id): (DefId, DefId))\n-                                   -> ty::GenericPredicates<'tcx> {\n+fn type_param_predicates<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    (item_def_id, def_id): (DefId, DefId),\n+) -> ty::GenericPredicates<'tcx> {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n@@ -250,13 +258,16 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.generics_of(item_def_id).parent\n     };\n \n-    let mut result = parent.map_or(ty::GenericPredicates {\n-        parent: None,\n-        predicates: vec![]\n-    }, |parent| {\n-        let icx = ItemCtxt::new(tcx, parent);\n-        icx.get_type_parameter_bounds(DUMMY_SP, def_id)\n-    });\n+    let mut result = parent.map_or(\n+        ty::GenericPredicates {\n+            parent: None,\n+            predicates: vec![],\n+        },\n+        |parent| {\n+            let icx = ItemCtxt::new(tcx, parent);\n+            icx.get_type_parameter_bounds(DUMMY_SP, def_id)\n+        },\n+    );\n \n     let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n     let ast_generics = match tcx.hir.get(item_node_id) {\n@@ -266,39 +277,42 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemKind::Fn(.., ref generics, _) |\n-                ItemKind::Impl(_, _, _, ref generics, ..) |\n-                ItemKind::Ty(_, ref generics) |\n-                ItemKind::Existential(ExistTy { ref generics, impl_trait_fn: None, ..}) |\n-                ItemKind::Enum(_, ref generics) |\n-                ItemKind::Struct(_, ref generics) |\n-                ItemKind::Union(_, ref generics) => generics,\n+                ItemKind::Fn(.., ref generics, _)\n+                | ItemKind::Impl(_, _, _, ref generics, ..)\n+                | ItemKind::Ty(_, ref generics)\n+                | ItemKind::Existential(ExistTy {\n+                    ref generics,\n+                    impl_trait_fn: None,\n+                    ..\n+                })\n+                | ItemKind::Enum(_, ref generics)\n+                | ItemKind::Struct(_, ref generics)\n+                | ItemKind::Union(_, ref generics) => generics,\n                 ItemKind::Trait(_, _, ref generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_node_id {\n-                        result.predicates.push(\n-                            ty::TraitRef::identity(tcx, item_def_id).to_predicate()\n-                        );\n+                        result\n+                            .predicates\n+                            .push(ty::TraitRef::identity(tcx, item_def_id).to_predicate());\n                     }\n                     generics\n                 }\n-                _ => return result\n+                _ => return result,\n             }\n         }\n \n-        NodeForeignItem(item) => {\n-            match item.node {\n-                ForeignItemKind::Fn(_, _, ref generics) => generics,\n-                _ => return result\n-            }\n-        }\n+        NodeForeignItem(item) => match item.node {\n+            ForeignItemKind::Fn(_, _, ref generics) => generics,\n+            _ => return result,\n+        },\n \n-        _ => return result\n+        _ => return result,\n     };\n \n     let icx = ItemCtxt::new(tcx, item_def_id);\n-    result.predicates.extend(\n-        icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty));\n+    result\n+        .predicates\n+        .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty));\n     result\n }\n \n@@ -307,32 +321,33 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n     /// AST. We do this to avoid having to convert *all* the bounds, which\n     /// would create artificial cycles. Instead we can only convert the\n     /// bounds for a type parameter `X` if `X::Foo` is used.\n-    fn type_parameter_bounds_in_generics(&self,\n-                                         ast_generics: &hir::Generics,\n-                                         param_id: ast::NodeId,\n-                                         ty: Ty<'tcx>)\n-                                         -> Vec<ty::Predicate<'tcx>>\n-    {\n-        let from_ty_params =\n-            ast_generics.params.iter()\n-                .filter_map(|param| match param.kind {\n-                    GenericParamKind::Type { .. } if param.id == param_id => Some(&param.bounds),\n-                    _ => None\n-                })\n-                .flat_map(|bounds| bounds.iter())\n-                .flat_map(|b| predicates_from_bound(self, ty, b));\n-\n-        let from_where_clauses =\n-            ast_generics.where_clause\n-                .predicates\n-                .iter()\n-                .filter_map(|wp| match *wp {\n-                    hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n-                    _ => None\n-                })\n-                .filter(|bp| is_param(self.tcx, &bp.bounded_ty, param_id))\n-                .flat_map(|bp| bp.bounds.iter())\n-                .flat_map(|b| predicates_from_bound(self, ty, b));\n+    fn type_parameter_bounds_in_generics(\n+        &self,\n+        ast_generics: &hir::Generics,\n+        param_id: ast::NodeId,\n+        ty: Ty<'tcx>,\n+    ) -> Vec<ty::Predicate<'tcx>> {\n+        let from_ty_params = ast_generics\n+            .params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Type { .. } if param.id == param_id => Some(&param.bounds),\n+                _ => None,\n+            })\n+            .flat_map(|bounds| bounds.iter())\n+            .flat_map(|b| predicates_from_bound(self, ty, b));\n+\n+        let from_where_clauses = ast_generics\n+            .where_clause\n+            .predicates\n+            .iter()\n+            .filter_map(|wp| match *wp {\n+                hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n+                _ => None,\n+            })\n+            .filter(|bp| is_param(self.tcx, &bp.bounded_ty, param_id))\n+            .flat_map(|bp| bp.bounds.iter())\n+            .flat_map(|b| predicates_from_bound(self, ty, b));\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n@@ -342,18 +357,17 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n /// parameter with id `param_id`. We use this so as to avoid running\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n-fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                      ast_ty: &hir::Ty,\n-                      param_id: ast::NodeId)\n-                      -> bool\n-{\n+fn is_param<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ast_ty: &hir::Ty,\n+    param_id: ast::NodeId,\n+) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.def {\n-            Def::SelfTy(Some(def_id), None) |\n-            Def::TyParam(def_id) => {\n+            Def::SelfTy(Some(def_id), None) | Def::TyParam(def_id) => {\n                 def_id == tcx.hir.local_def_id(param_id)\n             }\n-            _ => false\n+            _ => false,\n         }\n     } else {\n         false\n@@ -366,10 +380,10 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(item_id);\n     match it.node {\n         // These don't define types.\n-        hir::ItemKind::ExternCrate(_) |\n-        hir::ItemKind::Use(..) |\n-        hir::ItemKind::Mod(_) |\n-        hir::ItemKind::GlobalAsm(_) => {}\n+        hir::ItemKind::ExternCrate(_)\n+        | hir::ItemKind::Use(..)\n+        | hir::ItemKind::Mod(_)\n+        | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n                 let def_id = tcx.hir.local_def_id(item.id);\n@@ -386,25 +400,28 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n             convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n-        },\n+        }\n         hir::ItemKind::Impl(..) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.impl_trait_ref(def_id);\n             tcx.predicates_of(def_id);\n-        },\n+        }\n         hir::ItemKind::Trait(..) => {\n             tcx.generics_of(def_id);\n             tcx.trait_def(def_id);\n             tcx.at(it.span).super_predicates_of(def_id);\n             tcx.predicates_of(def_id);\n-        },\n+        }\n         hir::ItemKind::TraitAlias(..) => {\n-            span_err!(tcx.sess, it.span, E0645,\n-                      \"trait aliases are not yet implemented (see issue #41517)\");\n-        },\n-        hir::ItemKind::Struct(ref struct_def, _) |\n-        hir::ItemKind::Union(ref struct_def, _) => {\n+            span_err!(\n+                tcx.sess,\n+                it.span,\n+                E0645,\n+                \"trait aliases are not yet implemented (see issue #41517)\"\n+            );\n+        }\n+        hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n@@ -419,16 +436,19 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n             if !struct_def.is_struct() {\n                 convert_variant_ctor(tcx, struct_def.id());\n             }\n-        },\n+        }\n \n         // Desugared from `impl Trait` -> visited by the function's return type\n-        hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {}\n-\n-        hir::ItemKind::Existential(..) |\n-        hir::ItemKind::Ty(..) |\n-        hir::ItemKind::Static(..) |\n-        hir::ItemKind::Const(..) |\n-        hir::ItemKind::Fn(..) => {\n+        hir::ItemKind::Existential(hir::ExistTy {\n+            impl_trait_fn: Some(_),\n+            ..\n+        }) => {}\n+\n+        hir::ItemKind::Existential(..)\n+        | hir::ItemKind::Ty(..)\n+        | hir::ItemKind::Static(..)\n+        | hir::ItemKind::Const(..)\n+        | hir::ItemKind::Fn(..) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n@@ -445,9 +465,9 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast:\n     tcx.generics_of(def_id);\n \n     match trait_item.node {\n-        hir::TraitItemKind::Const(..) |\n-        hir::TraitItemKind::Type(_, Some(_)) |\n-        hir::TraitItemKind::Method(..) => {\n+        hir::TraitItemKind::Const(..)\n+        | hir::TraitItemKind::Type(_, Some(_))\n+        | hir::TraitItemKind::Method(..) => {\n             tcx.type_of(def_id);\n             if let hir::TraitItemKind::Method(..) = trait_item.node {\n                 tcx.fn_sig(def_id);\n@@ -470,17 +490,18 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: ast::N\n     }\n }\n \n-fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  ctor_id: ast::NodeId) {\n+fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ctor_id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(ctor_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        def_id: DefId,\n-                                        variants: &[hir::Variant]) {\n+fn convert_enum_variant_types<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    variants: &[hir::Variant],\n+) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr.discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n@@ -489,21 +510,30 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // fill the discriminant values and field types\n     for variant in variants {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n-        prev_discr = Some(if let Some(ref e) = variant.node.disr_expr {\n-            let expr_did = tcx.hir.local_def_id(e.id);\n-            def.eval_explicit_discr(tcx, expr_did)\n-        } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n-            Some(discr)\n-        } else {\n-            struct_span_err!(tcx.sess, variant.span, E0370,\n-                             \"enum discriminant overflowed\")\n-                .span_label(variant.span, format!(\"overflowed on value after {}\",\n-                                                   prev_discr.unwrap()))\n-                .note(&format!(\"explicitly set `{} = {}` if that is desired outcome\",\n-                               variant.node.name, wrapped_discr))\n-                .emit();\n-            None\n-        }.unwrap_or(wrapped_discr));\n+        prev_discr = Some(\n+            if let Some(ref e) = variant.node.disr_expr {\n+                let expr_did = tcx.hir.local_def_id(e.id);\n+                def.eval_explicit_discr(tcx, expr_did)\n+            } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n+                Some(discr)\n+            } else {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    variant.span,\n+                    E0370,\n+                    \"enum discriminant overflowed\"\n+                ).span_label(\n+                    variant.span,\n+                    format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n+                )\n+                    .note(&format!(\n+                        \"explicitly set `{} = {}` if that is desired outcome\",\n+                        variant.node.name, wrapped_discr\n+                    ))\n+                    .emit();\n+                None\n+            }.unwrap_or(wrapped_discr),\n+        );\n \n         for f in variant.node.data.fields() {\n             let def_id = tcx.hir.local_def_id(f.id);\n@@ -518,34 +548,42 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    did: DefId,\n-                                    name: ast::Name,\n-                                    discr: ty::VariantDiscr,\n-                                    def: &hir::VariantData)\n-                                    -> ty::VariantDef {\n+fn convert_struct_variant<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    did: DefId,\n+    name: ast::Name,\n+    discr: ty::VariantDiscr,\n+    def: &hir::VariantData,\n+) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = FxHashMap();\n     let node_id = tcx.hir.as_local_node_id(did).unwrap();\n-    let fields = def.fields().iter().map(|f| {\n-        let fid = tcx.hir.local_def_id(f.id);\n-        let dup_span = seen_fields.get(&f.ident.modern()).cloned();\n-        if let Some(prev_span) = dup_span {\n-            struct_span_err!(tcx.sess, f.span, E0124,\n-                             \"field `{}` is already declared\",\n-                             f.ident)\n-                .span_label(f.span, \"field already declared\")\n-                .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n-                .emit();\n-        } else {\n-            seen_fields.insert(f.ident.modern(), f.span);\n-        }\n+    let fields = def\n+        .fields()\n+        .iter()\n+        .map(|f| {\n+            let fid = tcx.hir.local_def_id(f.id);\n+            let dup_span = seen_fields.get(&f.ident.modern()).cloned();\n+            if let Some(prev_span) = dup_span {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    f.span,\n+                    E0124,\n+                    \"field `{}` is already declared\",\n+                    f.ident\n+                ).span_label(f.span, \"field already declared\")\n+                    .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n+                    .emit();\n+            } else {\n+                seen_fields.insert(f.ident.modern(), f.span);\n+            }\n \n-        ty::FieldDef {\n-            did: fid,\n-            ident: f.ident,\n-            vis: ty::Visibility::from_hir(&f.vis, node_id, tcx)\n-        }\n-    }).collect();\n+            ty::FieldDef {\n+                did: fid,\n+                ident: f.ident,\n+                vis: ty::Visibility::from_hir(&f.vis, node_id, tcx),\n+            }\n+        })\n+        .collect();\n     ty::VariantDef {\n         did,\n         name,\n@@ -555,34 +593,38 @@ fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                     def_id: DefId)\n-                     -> &'tcx ty::AdtDef {\n+fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = match tcx.hir.get(node_id) {\n         NodeItem(item) => item,\n-        _ => bug!()\n+        _ => bug!(),\n     };\n \n     let repr = ReprOptions::new(tcx, def_id);\n     let (kind, variants) = match item.node {\n         ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n-            (AdtKind::Enum, def.variants.iter().map(|v| {\n-                let did = tcx.hir.local_def_id(v.node.data.id());\n-                let discr = if let Some(ref e) = v.node.disr_expr {\n-                    distance_from_explicit = 0;\n-                    ty::VariantDiscr::Explicit(tcx.hir.local_def_id(e.id))\n-                } else {\n-                    ty::VariantDiscr::Relative(distance_from_explicit)\n-                };\n-                distance_from_explicit += 1;\n+            (\n+                AdtKind::Enum,\n+                def.variants\n+                    .iter()\n+                    .map(|v| {\n+                        let did = tcx.hir.local_def_id(v.node.data.id());\n+                        let discr = if let Some(ref e) = v.node.disr_expr {\n+                            distance_from_explicit = 0;\n+                            ty::VariantDiscr::Explicit(tcx.hir.local_def_id(e.id))\n+                        } else {\n+                            ty::VariantDiscr::Relative(distance_from_explicit)\n+                        };\n+                        distance_from_explicit += 1;\n \n-                convert_struct_variant(tcx, did, v.node.name, discr, &v.node.data)\n-            }).collect())\n+                        convert_struct_variant(tcx, did, v.node.name, discr, &v.node.data)\n+                    })\n+                    .collect(),\n+            )\n         }\n         ItemKind::Struct(ref def, _) => {\n             // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n@@ -591,52 +633,58 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             } else {\n                 None\n             };\n-            (AdtKind::Struct, vec![\n-                convert_struct_variant(tcx, ctor_id.unwrap_or(def_id), item.name,\n-                                       ty::VariantDiscr::Relative(0), def)\n-            ])\n-        }\n-        ItemKind::Union(ref def, _) => {\n-            (AdtKind::Union, vec![\n-                convert_struct_variant(tcx, def_id, item.name,\n-                                       ty::VariantDiscr::Relative(0), def)\n-            ])\n+            (\n+                AdtKind::Struct,\n+                vec![convert_struct_variant(\n+                    tcx,\n+                    ctor_id.unwrap_or(def_id),\n+                    item.name,\n+                    ty::VariantDiscr::Relative(0),\n+                    def,\n+                )],\n+            )\n         }\n-        _ => bug!()\n+        ItemKind::Union(ref def, _) => (\n+            AdtKind::Union,\n+            vec![convert_struct_variant(\n+                tcx,\n+                def_id,\n+                item.name,\n+                ty::VariantDiscr::Relative(0),\n+                def,\n+            )],\n+        ),\n+        _ => bug!(),\n     };\n     tcx.alloc_adt_def(def_id, kind, variants, repr)\n }\n \n /// Ensures that the super-predicates of the trait with def-id\n /// trait_def_id are converted and stored. This also ensures that\n /// the transitive super-predicates are converted;\n-fn super_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 trait_def_id: DefId)\n-                                 -> ty::GenericPredicates<'tcx> {\n+fn super_predicates_of<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_def_id: DefId,\n+) -> ty::GenericPredicates<'tcx> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n     let trait_node_id = tcx.hir.as_local_node_id(trait_def_id).unwrap();\n \n     let item = match tcx.hir.get(trait_node_id) {\n         hir_map::NodeItem(item) => item,\n-        _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n+        _ => bug!(\"trait_node_id {} is not an item\", trait_node_id),\n     };\n \n     let (generics, bounds) = match item.node {\n         hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n         hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n-        _ => span_bug!(item.span,\n-                       \"super_predicates invoked on non-trait\"),\n+        _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n     };\n \n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n     // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n     let self_param_ty = tcx.mk_self_type();\n-    let superbounds1 = compute_bounds(&icx,\n-                                      self_param_ty,\n-                                      bounds,\n-                                      SizedByDefault::No,\n-                                      item.span);\n+    let superbounds1 = compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n \n     let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n@@ -655,13 +703,11 @@ fn super_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     ty::GenericPredicates {\n         parent: None,\n-        predicates: superbounds\n+        predicates: superbounds,\n     }\n }\n \n-fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       def_id: DefId)\n-                       -> &'tcx ty::TraitDef {\n+fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = tcx.hir.expect_item(node_id);\n \n@@ -676,25 +722,25 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut err = tcx.sess.struct_span_err(\n             item.span,\n             \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n-             which traits can use parenthetical notation\");\n-        help!(&mut err,\n+             which traits can use parenthetical notation\",\n+        );\n+        help!(\n+            &mut err,\n             \"add `#![feature(unboxed_closures)]` to \\\n-             the crate attributes to use it\");\n+             the crate attributes to use it\"\n+        );\n         err.emit();\n     }\n \n     let def_path_hash = tcx.def_path_hash(def_id);\n-    let def = ty::TraitDef::new(def_id,\n-                                unsafety,\n-                                paren_sugar,\n-                                is_auto,\n-                                def_path_hash);\n+    let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, is_auto, def_path_hash);\n     tcx.alloc_trait_def(def)\n }\n \n-fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    node: hir_map::Node<'tcx>)\n-                                    -> Option<Span> {\n+fn has_late_bound_regions<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    node: hir_map::Node<'tcx>,\n+) -> Option<Span> {\n     struct LateBoundRegionsDetector<'a, 'tcx: 'a> {\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         outer_index: ty::DebruijnIndex,\n@@ -707,49 +753,57 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-            if self.has_late_bound_regions.is_some() { return }\n+            if self.has_late_bound_regions.is_some() {\n+                return;\n+            }\n             match ty.node {\n                 hir::TyKind::BareFn(..) => {\n                     self.outer_index.shift_in(1);\n                     intravisit::walk_ty(self, ty);\n                     self.outer_index.shift_out(1);\n                 }\n-                _ => intravisit::walk_ty(self, ty)\n+                _ => intravisit::walk_ty(self, ty),\n             }\n         }\n \n-        fn visit_poly_trait_ref(&mut self,\n-                                tr: &'tcx hir::PolyTraitRef,\n-                                m: hir::TraitBoundModifier) {\n-            if self.has_late_bound_regions.is_some() { return }\n+        fn visit_poly_trait_ref(\n+            &mut self,\n+            tr: &'tcx hir::PolyTraitRef,\n+            m: hir::TraitBoundModifier,\n+        ) {\n+            if self.has_late_bound_regions.is_some() {\n+                return;\n+            }\n             self.outer_index.shift_in(1);\n             intravisit::walk_poly_trait_ref(self, tr, m);\n             self.outer_index.shift_out(1);\n         }\n \n         fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n-            if self.has_late_bound_regions.is_some() { return }\n+            if self.has_late_bound_regions.is_some() {\n+                return;\n+            }\n \n             let hir_id = self.tcx.hir.node_to_hir_id(lt.id);\n             match self.tcx.named_region(hir_id) {\n                 Some(rl::Region::Static) | Some(rl::Region::EarlyBound(..)) => {}\n-                Some(rl::Region::LateBound(debruijn, _, _)) |\n-                Some(rl::Region::LateBoundAnon(debruijn, _))\n-                    if debruijn < self.outer_index => {}\n-                Some(rl::Region::LateBound(..)) |\n-                Some(rl::Region::LateBoundAnon(..)) |\n-                Some(rl::Region::Free(..)) |\n-                None => {\n+                Some(rl::Region::LateBound(debruijn, _, _))\n+                | Some(rl::Region::LateBoundAnon(debruijn, _)) if debruijn < self.outer_index => {}\n+                Some(rl::Region::LateBound(..))\n+                | Some(rl::Region::LateBoundAnon(..))\n+                | Some(rl::Region::Free(..))\n+                | None => {\n                     self.has_late_bound_regions = Some(lt.span);\n                 }\n             }\n         }\n     }\n \n-    fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        generics: &'tcx hir::Generics,\n-                                        decl: &'tcx hir::FnDecl)\n-                                        -> Option<Span> {\n+    fn has_late_bound_regions<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        generics: &'tcx hir::Generics,\n+        decl: &'tcx hir::FnDecl,\n+    ) -> Option<Span> {\n         let mut visitor = LateBoundRegionsDetector {\n             tcx,\n             outer_index: ty::INNERMOST,\n@@ -763,7 +817,7 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         return Some(param.span);\n                     }\n                 }\n-                _ => {},\n+                _ => {}\n             }\n         }\n         visitor.visit_fn_decl(decl);\n@@ -772,57 +826,54 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     match node {\n         hir_map::NodeTraitItem(item) => match item.node {\n-            hir::TraitItemKind::Method(ref sig, _) =>\n-                has_late_bound_regions(tcx, &item.generics, &sig.decl),\n+            hir::TraitItemKind::Method(ref sig, _) => {\n+                has_late_bound_regions(tcx, &item.generics, &sig.decl)\n+            }\n             _ => None,\n         },\n         hir_map::NodeImplItem(item) => match item.node {\n-            hir::ImplItemKind::Method(ref sig, _) =>\n-                has_late_bound_regions(tcx, &item.generics, &sig.decl),\n+            hir::ImplItemKind::Method(ref sig, _) => {\n+                has_late_bound_regions(tcx, &item.generics, &sig.decl)\n+            }\n             _ => None,\n         },\n         hir_map::NodeForeignItem(item) => match item.node {\n-            hir::ForeignItemKind::Fn(ref fn_decl, _, ref generics) =>\n-                has_late_bound_regions(tcx, generics, fn_decl),\n+            hir::ForeignItemKind::Fn(ref fn_decl, _, ref generics) => {\n+                has_late_bound_regions(tcx, generics, fn_decl)\n+            }\n             _ => None,\n         },\n         hir_map::NodeItem(item) => match item.node {\n-            hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) =>\n-                has_late_bound_regions(tcx, generics, fn_decl),\n+            hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) => {\n+                has_late_bound_regions(tcx, generics, fn_decl)\n+            }\n             _ => None,\n         },\n-        _ => None\n+        _ => None,\n     }\n }\n \n-fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         def_id: DefId)\n-                         -> &'tcx ty::Generics {\n+fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n     let node = tcx.hir.get(node_id);\n     let parent_def_id = match node {\n-        NodeImplItem(_) |\n-        NodeTraitItem(_) |\n-        NodeVariant(_) |\n-        NodeStructCtor(_) |\n-        NodeField(_) => {\n+        NodeImplItem(_) | NodeTraitItem(_) | NodeVariant(_) | NodeStructCtor(_) | NodeField(_) => {\n             let parent_id = tcx.hir.get_parent(node_id);\n             Some(tcx.hir.local_def_id(parent_id))\n         }\n-        NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(..), .. }) => {\n-            Some(tcx.closure_base_def_id(def_id))\n-        }\n-        NodeItem(item) => {\n-            match item.node {\n-                ItemKind::Existential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n-                _ => None,\n-            }\n+        NodeExpr(&hir::Expr {\n+            node: hir::ExprKind::Closure(..),\n+            ..\n+        }) => Some(tcx.closure_base_def_id(def_id)),\n+        NodeItem(item) => match item.node {\n+            ItemKind::Existential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n+            _ => None,\n         },\n-        _ => None\n+        _ => None,\n     };\n \n     let mut opt_self = None;\n@@ -836,20 +887,21 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemKind::Fn(.., ref generics, _) |\n-                ItemKind::Impl(_, _, _, ref generics, ..) => generics,\n-\n-                ItemKind::Ty(_, ref generics) |\n-                ItemKind::Enum(_, ref generics) |\n-                ItemKind::Struct(_, ref generics) |\n-                ItemKind::Existential(hir::ExistTy { ref generics, .. }) |\n-                ItemKind::Union(_, ref generics) => {\n+                ItemKind::Fn(.., ref generics, _) | ItemKind::Impl(_, _, _, ref generics, ..) => {\n+                    generics\n+                }\n+\n+                ItemKind::Ty(_, ref generics)\n+                | ItemKind::Enum(_, ref generics)\n+                | ItemKind::Struct(_, ref generics)\n+                | ItemKind::Existential(hir::ExistTy { ref generics, .. })\n+                | ItemKind::Union(_, ref generics) => {\n                     allow_defaults = true;\n                     generics\n                 }\n \n-                ItemKind::Trait(_, _, ref generics, ..) |\n-                ItemKind::TraitAlias(ref generics, ..) => {\n+                ItemKind::Trait(_, _, ref generics, ..)\n+                | ItemKind::TraitAlias(ref generics, ..) => {\n                     // Add in the self type parameter.\n                     //\n                     // Something of a hack: use the node id for the trait, also as\n@@ -876,13 +928,11 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        NodeForeignItem(item) => {\n-            match item.node {\n-                ForeignItemKind::Static(..) => &no_generics,\n-                ForeignItemKind::Fn(_, _, ref generics) => generics,\n-                ForeignItemKind::Type => &no_generics,\n-            }\n-        }\n+        NodeForeignItem(item) => match item.node {\n+            ForeignItemKind::Static(..) => &no_generics,\n+            ForeignItemKind::Fn(_, _, ref generics) => generics,\n+            ForeignItemKind::Type => &no_generics,\n+        },\n \n         _ => &no_generics,\n     };\n@@ -901,70 +951,94 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut params: Vec<_> = opt_self.into_iter().collect();\n \n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n-    params.extend(early_lifetimes.enumerate().map(|(i, param)| {\n-        ty::GenericParamDef {\n-            name: param.name.ident().as_interned_str(),\n-            index: own_start + i as u32,\n-            def_id: tcx.hir.local_def_id(param.id),\n-            pure_wrt_drop: param.pure_wrt_drop,\n-            kind: ty::GenericParamDefKind::Lifetime,\n-        }\n-    }));\n+    params.extend(\n+        early_lifetimes\n+            .enumerate()\n+            .map(|(i, param)| ty::GenericParamDef {\n+                name: param.name.ident().as_interned_str(),\n+                index: own_start + i as u32,\n+                def_id: tcx.hir.local_def_id(param.id),\n+                pure_wrt_drop: param.pure_wrt_drop,\n+                kind: ty::GenericParamDefKind::Lifetime,\n+            }),\n+    );\n \n     let hir_id = tcx.hir.node_to_hir_id(node_id);\n     let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n \n     // Now create the real type parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n     let mut i = 0;\n-    params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n-        GenericParamKind::Type { ref default, synthetic, .. } => {\n-            if param.name.ident().name == keywords::SelfType.name() {\n-                span_bug!(param.span,  \"`Self` should not be the name of a regular parameter\");\n-            }\n+    params.extend(\n+        ast_generics\n+            .params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Type {\n+                    ref default,\n+                    synthetic,\n+                    ..\n+                } => {\n+                    if param.name.ident().name == keywords::SelfType.name() {\n+                        span_bug!(\n+                            param.span,\n+                            \"`Self` should not be the name of a regular parameter\"\n+                        );\n+                    }\n \n-            if !allow_defaults && default.is_some() {\n-                if !tcx.features().default_type_parameter_fallback {\n-                    tcx.lint_node(\n-                        lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                        param.id,\n-                        param.span,\n-                        &format!(\"defaults for type parameters are only allowed in \\\n-                                    `struct`, `enum`, `type`, or `trait` definitions.\"));\n-                }\n-            }\n+                    if !allow_defaults && default.is_some() {\n+                        if !tcx.features().default_type_parameter_fallback {\n+                            tcx.lint_node(\n+                                lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n+                                param.id,\n+                                param.span,\n+                                &format!(\n+                                    \"defaults for type parameters are only allowed in \\\n+                                     `struct`, `enum`, `type`, or `trait` definitions.\"\n+                                ),\n+                            );\n+                        }\n+                    }\n \n-            let ty_param = ty::GenericParamDef {\n-                index: type_start + i as u32,\n-                name: param.name.ident().as_interned_str(),\n-                def_id: tcx.hir.local_def_id(param.id),\n-                pure_wrt_drop: param.pure_wrt_drop,\n-                kind: ty::GenericParamDefKind::Type {\n-                    has_default: default.is_some(),\n-                    object_lifetime_default:\n-                        object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n-                    synthetic,\n-                },\n-            };\n-            i += 1;\n-            Some(ty_param)\n-        }\n-        _ => None,\n-    }));\n+                    let ty_param = ty::GenericParamDef {\n+                        index: type_start + i as u32,\n+                        name: param.name.ident().as_interned_str(),\n+                        def_id: tcx.hir.local_def_id(param.id),\n+                        pure_wrt_drop: param.pure_wrt_drop,\n+                        kind: ty::GenericParamDefKind::Type {\n+                            has_default: default.is_some(),\n+                            object_lifetime_default: object_lifetime_defaults\n+                                .as_ref()\n+                                .map_or(rl::Set1::Empty, |o| o[i]),\n+                            synthetic,\n+                        },\n+                    };\n+                    i += 1;\n+                    Some(ty_param)\n+                }\n+                _ => None,\n+            }),\n+    );\n \n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n-    if let NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., gen), .. }) = node {\n+    if let NodeExpr(&hir::Expr {\n+        node: hir::ExprKind::Closure(.., gen),\n+        ..\n+    }) = node\n+    {\n         let dummy_args = if gen.is_some() {\n             &[\"<yield_ty>\", \"<return_ty>\", \"<witness>\"][..]\n         } else {\n             &[\"<closure_kind>\", \"<closure_signature>\"][..]\n         };\n \n         params.extend(\n-            dummy_args.iter().enumerate().map(|(i, &arg)|\n-                ty::GenericParamDef {\n+            dummy_args\n+                .iter()\n+                .enumerate()\n+                .map(|(i, &arg)| ty::GenericParamDef {\n                     index: type_start + i as u32,\n                     name: Symbol::intern(arg).as_interned_str(),\n                     def_id,\n@@ -974,8 +1048,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         object_lifetime_default: rl::Set1::Empty,\n                         synthetic: None,\n                     },\n-                }\n-            )\n+                }),\n         );\n \n         tcx.with_freevars(node_id, |fv| {\n@@ -995,9 +1068,10 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         });\n     }\n \n-    let param_def_id_to_index = params.iter()\n-                                      .map(|param| (param.def_id, param.index))\n-                                      .collect();\n+    let param_def_id_to_index = params\n+        .iter()\n+        .map(|param| (param.def_id, param.index))\n+        .collect();\n \n     tcx.alloc_generics(ty::Generics {\n         parent: parent_def_id,\n@@ -1009,16 +1083,16 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    span: Span,\n-) {\n-    span_err!(tcx.sess, span, E0202, \"associated types are not allowed in inherent impls\");\n+fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) {\n+    span_err!(\n+        tcx.sess,\n+        span,\n+        E0202,\n+        \"associated types are not allowed in inherent impls\"\n+    );\n }\n \n-fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                     def_id: DefId)\n-                     -> Ty<'tcx> {\n+fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n@@ -1027,109 +1101,132 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     match tcx.hir.get(node_id) {\n-        NodeTraitItem(item) => {\n-            match item.node {\n-                TraitItemKind::Method(..) => {\n-                    let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs)\n-                }\n-                TraitItemKind::Const(ref ty, _) |\n-                TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n-                TraitItemKind::Type(_, None) => {\n-                    span_bug!(item.span, \"associated type missing default\");\n-                }\n+        NodeTraitItem(item) => match item.node {\n+            TraitItemKind::Method(..) => {\n+                let substs = Substs::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n             }\n-        }\n+            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n+            TraitItemKind::Type(_, None) => {\n+                span_bug!(item.span, \"associated type missing default\");\n+            }\n+        },\n \n-        NodeImplItem(item) => {\n-            match item.node {\n-                ImplItemKind::Method(..) => {\n-                    let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs)\n+        NodeImplItem(item) => match item.node {\n+            ImplItemKind::Method(..) => {\n+                let substs = Substs::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+            ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n+            ImplItemKind::Existential(_) => {\n+                if tcx\n+                    .impl_trait_ref(tcx.hir.get_parent_did(node_id))\n+                    .is_none()\n+                {\n+                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n                 }\n-                ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n-                ImplItemKind::Existential(_) => {\n-                    if tcx.impl_trait_ref(tcx.hir.get_parent_did(node_id)).is_none() {\n-                        report_assoc_ty_on_inherent_impl(tcx, item.span);\n-                    }\n \n-                    find_existential_constraints(tcx, def_id)\n+                find_existential_constraints(tcx, def_id)\n+            }\n+            ImplItemKind::Type(ref ty) => {\n+                if tcx\n+                    .impl_trait_ref(tcx.hir.get_parent_did(node_id))\n+                    .is_none()\n+                {\n+                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n                 }\n-                ImplItemKind::Type(ref ty) => {\n-                    if tcx.impl_trait_ref(tcx.hir.get_parent_did(node_id)).is_none() {\n-                        report_assoc_ty_on_inherent_impl(tcx, item.span);\n-                    }\n \n-                    icx.to_ty(ty)\n-                }\n+                icx.to_ty(ty)\n             }\n-        }\n+        },\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemKind::Static(ref t, ..) | ItemKind::Const(ref t, _) |\n-                ItemKind::Ty(ref t, _) | ItemKind::Impl(.., ref t, _) => {\n-                    icx.to_ty(t)\n-                }\n+                ItemKind::Static(ref t, ..)\n+                | ItemKind::Const(ref t, _)\n+                | ItemKind::Ty(ref t, _)\n+                | ItemKind::Impl(.., ref t, _) => icx.to_ty(t),\n                 ItemKind::Fn(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_fn_def(def_id, substs)\n                 }\n-                ItemKind::Enum(..) |\n-                ItemKind::Struct(..) |\n-                ItemKind::Union(..) => {\n+                ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) => {\n                     let def = tcx.adt_def(def_id);\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n-                ItemKind::Existential(hir::ExistTy { impl_trait_fn: None, .. }) => {\n-                    find_existential_constraints(tcx, def_id)\n-                },\n+                ItemKind::Existential(hir::ExistTy {\n+                    impl_trait_fn: None,\n+                    ..\n+                }) => find_existential_constraints(tcx, def_id),\n                 // existential types desugared from impl Trait\n-                ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(owner), .. }) => {\n-                    tcx.typeck_tables_of(owner).concrete_existential_types[&def_id]\n-                },\n-                ItemKind::Trait(..) | ItemKind::TraitAlias(..) |\n-                ItemKind::Mod(..) |\n-                ItemKind::ForeignMod(..) |\n-                ItemKind::GlobalAsm(..) |\n-                ItemKind::ExternCrate(..) |\n-                ItemKind::Use(..) => {\n+                ItemKind::Existential(hir::ExistTy {\n+                    impl_trait_fn: Some(owner),\n+                    ..\n+                }) => {\n+                    tcx.typeck_tables_of(owner)\n+                        .concrete_existential_types\n+                        .get(&def_id)\n+                        .cloned()\n+                        .unwrap_or_else(|| {\n+                            // This can occur if some error in the\n+                            // owner fn prevented us from populating\n+                            // the `concrete_existential_types` table.\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\n+                                    \"owner {:?} has no existential type for {:?} in its tables\",\n+                                    owner, def_id,\n+                                ),\n+                            );\n+                            tcx.types.err\n+                        })\n+                }\n+                ItemKind::Trait(..)\n+                | ItemKind::TraitAlias(..)\n+                | ItemKind::Mod(..)\n+                | ItemKind::ForeignMod(..)\n+                | ItemKind::GlobalAsm(..)\n+                | ItemKind::ExternCrate(..)\n+                | ItemKind::Use(..) => {\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n-                        item.node);\n+                        item.node\n+                    );\n                 }\n             }\n         }\n \n-        NodeForeignItem(foreign_item) => {\n-            match foreign_item.node {\n-                ForeignItemKind::Fn(..) => {\n-                    let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs)\n-                }\n-                ForeignItemKind::Static(ref t, _) => icx.to_ty(t),\n-                ForeignItemKind::Type => tcx.mk_foreign(def_id),\n+        NodeForeignItem(foreign_item) => match foreign_item.node {\n+            ForeignItemKind::Fn(..) => {\n+                let substs = Substs::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n             }\n-        }\n+            ForeignItemKind::Static(ref t, _) => icx.to_ty(t),\n+            ForeignItemKind::Type => tcx.mk_foreign(def_id),\n+        },\n \n-        NodeStructCtor(&ref def) |\n-        NodeVariant(&Spanned { node: hir::VariantKind { data: ref def, .. }, .. }) => {\n-            match *def {\n-                VariantData::Unit(..) | VariantData::Struct(..) => {\n-                    tcx.type_of(tcx.hir.get_parent_did(node_id))\n-                }\n-                VariantData::Tuple(..) => {\n-                    let substs = Substs::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs)\n-                }\n+        NodeStructCtor(&ref def)\n+        | NodeVariant(&Spanned {\n+            node: hir::VariantKind { data: ref def, .. },\n+            ..\n+        }) => match *def {\n+            VariantData::Unit(..) | VariantData::Struct(..) => {\n+                tcx.type_of(tcx.hir.get_parent_did(node_id))\n             }\n-        }\n+            VariantData::Tuple(..) => {\n+                let substs = Substs::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+        },\n \n         NodeField(field) => icx.to_ty(&field.ty),\n \n-        NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., gen), .. }) => {\n+        NodeExpr(&hir::Expr {\n+            node: hir::ExprKind::Closure(.., gen),\n+            ..\n+        }) => {\n             if gen.is_some() {\n                 let hir_id = tcx.hir.node_to_hir_id(node_id);\n                 return tcx.typeck_tables_of(def_id).node_id_to_type(hir_id);\n@@ -1143,30 +1240,49 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         NodeAnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n-            NodeTy(&hir::Ty { node: hir::TyKind::Array(_, ref constant), .. }) |\n-            NodeTy(&hir::Ty { node: hir::TyKind::Typeof(ref constant), .. }) |\n-            NodeExpr(&hir::Expr { node: ExprKind::Repeat(_, ref constant), .. })\n-                if constant.id == node_id => tcx.types.usize,\n-\n-            NodeVariant(&Spanned { node: VariantKind { disr_expr: Some(ref e), .. }, .. })\n-                if e.id == node_id => {\n-                    tcx.adt_def(tcx.hir.get_parent_did(node_id))\n-                        .repr.discr_type().to_ty(tcx)\n-                }\n+            NodeTy(&hir::Ty {\n+                node: hir::TyKind::Array(_, ref constant),\n+                ..\n+            })\n+            | NodeTy(&hir::Ty {\n+                node: hir::TyKind::Typeof(ref constant),\n+                ..\n+            })\n+            | NodeExpr(&hir::Expr {\n+                node: ExprKind::Repeat(_, ref constant),\n+                ..\n+            }) if constant.id == node_id =>\n+            {\n+                tcx.types.usize\n+            }\n+\n+            NodeVariant(&Spanned {\n+                node:\n+                    VariantKind {\n+                        disr_expr: Some(ref e),\n+                        ..\n+                    },\n+                ..\n+            }) if e.id == node_id =>\n+            {\n+                tcx.adt_def(tcx.hir.get_parent_did(node_id))\n+                    .repr\n+                    .discr_type()\n+                    .to_ty(tcx)\n+            }\n \n             x => {\n                 bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n             }\n         },\n \n-        NodeGenericParam(param) => {\n-            match param.kind {\n-                hir::GenericParamKind::Type { default: Some(ref ty), .. } => {\n-                    icx.to_ty(ty)\n-                }\n-                _ => bug!(\"unexpected non-type NodeGenericParam\"),\n-            }\n-        }\n+        NodeGenericParam(param) => match param.kind {\n+            hir::GenericParamKind::Type {\n+                default: Some(ref ty),\n+                ..\n+            } => icx.to_ty(ty),\n+            _ => bug!(\"unexpected non-type NodeGenericParam\"),\n+        },\n \n         x => {\n             bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n@@ -1245,7 +1361,11 @@ fn find_existential_constraints<'a, 'tcx>(\n             intravisit::walk_trait_item(self, it);\n         }\n     }\n-    let mut locator = ConstraintLocator { def_id, tcx, found: None };\n+    let mut locator = ConstraintLocator {\n+        def_id,\n+        tcx,\n+        found: None,\n+    };\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let parent = tcx.hir.get_parent(node_id);\n     trace!(\"parent_id: {:?}\", parent);\n@@ -1257,7 +1377,10 @@ fn find_existential_constraints<'a, 'tcx>(\n             NodeItem(ref it) => intravisit::walk_item(&mut locator, it),\n             NodeImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n             NodeTraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n-            other => bug!(\"{:?} is not a valid parent of an existential type item\", other),\n+            other => bug!(\n+                \"{:?} is not a valid parent of an existential type item\",\n+                other\n+            ),\n         }\n     }\n     match locator.found {\n@@ -1270,9 +1393,7 @@ fn find_existential_constraints<'a, 'tcx>(\n     }\n }\n \n-fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    def_id: DefId)\n-                    -> ty::PolyFnSig<'tcx> {\n+fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n@@ -1281,38 +1402,54 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     match tcx.hir.get(node_id) {\n-        NodeTraitItem(hir::TraitItem { node: TraitItemKind::Method(sig, _), .. }) |\n-        NodeImplItem(hir::ImplItem { node: ImplItemKind::Method(sig, _), .. }) => {\n-            AstConv::ty_of_fn(&icx, sig.header.unsafety, sig.header.abi, &sig.decl)\n-        }\n-\n-        NodeItem(hir::Item { node: ItemKind::Fn(decl, header, _, _), .. }) => {\n-            AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl)\n-        }\n-\n-        NodeForeignItem(&hir::ForeignItem { node: ForeignItemKind::Fn(ref fn_decl, _, _), .. }) => {\n+        NodeTraitItem(hir::TraitItem {\n+            node: TraitItemKind::Method(sig, _),\n+            ..\n+        })\n+        | NodeImplItem(hir::ImplItem {\n+            node: ImplItemKind::Method(sig, _),\n+            ..\n+        }) => AstConv::ty_of_fn(&icx, sig.header.unsafety, sig.header.abi, &sig.decl),\n+\n+        NodeItem(hir::Item {\n+            node: ItemKind::Fn(decl, header, _, _),\n+            ..\n+        }) => AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl),\n+\n+        NodeForeignItem(&hir::ForeignItem {\n+            node: ForeignItemKind::Fn(ref fn_decl, _, _),\n+            ..\n+        }) => {\n             let abi = tcx.hir.get_foreign_abi(node_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n-        NodeStructCtor(&VariantData::Tuple(ref fields, _)) |\n-        NodeVariant(&Spanned { node: hir::VariantKind {\n-            data: VariantData::Tuple(ref fields, _), ..\n-        }, .. }) => {\n+        NodeStructCtor(&VariantData::Tuple(ref fields, _))\n+        | NodeVariant(&Spanned {\n+            node:\n+                hir::VariantKind {\n+                    data: VariantData::Tuple(ref fields, _),\n+                    ..\n+                },\n+            ..\n+        }) => {\n             let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n-            let inputs = fields.iter().map(|f| {\n-                tcx.type_of(tcx.hir.local_def_id(f.id))\n-            });\n+            let inputs = fields\n+                .iter()\n+                .map(|f| tcx.type_of(tcx.hir.local_def_id(f.id)));\n             ty::Binder::bind(tcx.mk_fn_sig(\n                 inputs,\n                 ty,\n                 false,\n                 hir::Unsafety::Normal,\n-                abi::Abi::Rust\n+                abi::Abi::Rust,\n             ))\n         }\n \n-        NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(..), .. }) => {\n+        NodeExpr(&hir::Expr {\n+            node: hir::ExprKind::Closure(..),\n+            ..\n+        }) => {\n             // Closure signatures are not like other function\n             // signatures and cannot be accessed through `fn_sig`. For\n             // example, a closure signature excludes the `self`\n@@ -1337,9 +1474,10 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def_id: DefId)\n-                            -> Option<ty::TraitRef<'tcx>> {\n+fn impl_trait_ref<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> Option<ty::TraitRef<'tcx>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -1350,37 +1488,40 @@ fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n             })\n         }\n-        _ => bug!()\n+        _ => bug!(),\n     }\n }\n \n-fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           def_id: DefId)\n-                           -> hir::ImplPolarity {\n+fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> hir::ImplPolarity {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     match tcx.hir.expect_item(node_id).node {\n         hir::ItemKind::Impl(_, polarity, ..) => polarity,\n-        ref item => bug!(\"impl_polarity: {:?} not an impl\", item)\n+        ref item => bug!(\"impl_polarity: {:?} not an impl\", item),\n     }\n }\n \n // Is it marked with ?Sized\n-fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &dyn AstConv<'gcx, 'tcx>,\n-                                ast_bounds: &[hir::GenericBound],\n-                                span: Span) -> bool\n-{\n+fn is_unsized<'gcx: 'tcx, 'tcx>(\n+    astconv: &dyn AstConv<'gcx, 'tcx>,\n+    ast_bounds: &[hir::GenericBound],\n+    span: Span,\n+) -> bool {\n     let tcx = astconv.tcx();\n \n     // Try to find an unbound in bounds.\n     let mut unbound = None;\n     for ab in ast_bounds {\n-        if let &hir::GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = ab  {\n+        if let &hir::GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = ab {\n             if unbound.is_none() {\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n-                span_err!(tcx.sess, span, E0203,\n-                          \"type parameter has more than one relaxed default \\\n-                                                bound, only one is supported\");\n+                span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0203,\n+                    \"type parameter has more than one relaxed default \\\n+                     bound, only one is supported\"\n+                );\n             }\n         }\n     }\n@@ -1391,10 +1532,12 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &dyn AstConv<'gcx, 'tcx>,\n             // FIXME(#8559) currently requires the unbound to be built-in.\n             if let Ok(kind_id) = kind_id {\n                 if tpb.path.def != Def::Trait(kind_id) {\n-                    tcx.sess.span_warn(span,\n-                                       \"default bound relaxed for a type parameter, but \\\n-                                       this does nothing because the given bound is not \\\n-                                       a default. Only `?Sized` is supported\");\n+                    tcx.sess.span_warn(\n+                        span,\n+                        \"default bound relaxed for a type parameter, but \\\n+                         this does nothing because the given bound is not \\\n+                         a default. Only `?Sized` is supported\",\n+                    );\n                 }\n             }\n         }\n@@ -1415,37 +1558,48 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &dyn AstConv<'gcx, 'tcx>,\n /// `resolve_lifetime::early_bound_lifetimes`.\n fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    generics: &'a hir::Generics)\n-    -> impl Iterator<Item=&'a hir::GenericParam> + Captures<'tcx>\n-{\n-    generics.params.iter().filter(move |param| match param.kind {\n-        GenericParamKind::Lifetime { .. } => {\n-            let hir_id = tcx.hir.node_to_hir_id(param.id);\n-            !tcx.is_late_bound(hir_id)\n-        }\n-        _ => false,\n-    })\n+    generics: &'a hir::Generics,\n+) -> impl Iterator<Item = &'a hir::GenericParam> + Captures<'tcx> {\n+    generics\n+        .params\n+        .iter()\n+        .filter(move |param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => {\n+                let hir_id = tcx.hir.node_to_hir_id(param.id);\n+                !tcx.is_late_bound(hir_id)\n+            }\n+            _ => false,\n+        })\n }\n \n-fn predicates_defined_on<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   def_id: DefId)\n-                                   -> ty::GenericPredicates<'tcx> {\n+fn predicates_defined_on<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> ty::GenericPredicates<'tcx> {\n     let explicit = tcx.explicit_predicates_of(def_id);\n     let predicates = if tcx.sess.features_untracked().infer_outlives_requirements {\n-        [&explicit.predicates[..], &tcx.inferred_outlives_of(def_id)[..]].concat()\n-    } else { explicit.predicates };\n+        [\n+            &explicit.predicates[..],\n+            &tcx.inferred_outlives_of(def_id)[..],\n+        ].concat()\n+    } else {\n+        explicit.predicates\n+    };\n \n     ty::GenericPredicates {\n         parent: explicit.parent,\n         predicates: predicates,\n     }\n }\n \n-fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           def_id: DefId)\n-                           -> ty::GenericPredicates<'tcx> {\n-    let ty::GenericPredicates { parent, mut predicates } =\n-        tcx.predicates_defined_on(def_id);\n+fn predicates_of<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> ty::GenericPredicates<'tcx> {\n+    let ty::GenericPredicates {\n+        parent,\n+        mut predicates,\n+    } = tcx.predicates_defined_on(def_id);\n \n     if tcx.is_trait(def_id) {\n         // For traits, add `Self: Trait` predicate. This is\n@@ -1487,27 +1641,27 @@ fn explicit_predicates_of<'a, 'tcx>(\n     let mut predicates = vec![];\n \n     let ast_generics = match node {\n-        NodeTraitItem(item) => {\n-            &item.generics\n-        }\n+        NodeTraitItem(item) => &item.generics,\n \n         NodeImplItem(item) => match item.node {\n             ImplItemKind::Existential(ref bounds) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 let anon_ty = tcx.mk_anon(def_id, substs);\n \n                 // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n-                let bounds = compute_bounds(&icx,\n-                                            anon_ty,\n-                                            bounds,\n-                                            SizedByDefault::Yes,\n-                                            tcx.def_span(def_id));\n+                let bounds = compute_bounds(\n+                    &icx,\n+                    anon_ty,\n+                    bounds,\n+                    SizedByDefault::Yes,\n+                    tcx.def_span(def_id),\n+                );\n \n                 predicates.extend(bounds.predicates(tcx, anon_ty));\n                 &item.generics\n-            },\n+            }\n             _ => &item.generics,\n-        }\n+        },\n \n         NodeItem(item) => {\n             match item.node {\n@@ -1517,26 +1671,32 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     }\n                     generics\n                 }\n-                ItemKind::Fn(.., ref generics, _) |\n-                ItemKind::Ty(_, ref generics) |\n-                ItemKind::Enum(_, ref generics) |\n-                ItemKind::Struct(_, ref generics) |\n-                ItemKind::Union(_, ref generics) => generics,\n+                ItemKind::Fn(.., ref generics, _)\n+                | ItemKind::Ty(_, ref generics)\n+                | ItemKind::Enum(_, ref generics)\n+                | ItemKind::Struct(_, ref generics)\n+                | ItemKind::Union(_, ref generics) => generics,\n \n                 ItemKind::Trait(_, _, ref generics, .., ref items) => {\n                     is_trait = Some((ty::TraitRef::identity(tcx, def_id), items));\n                     generics\n                 }\n-                ItemKind::Existential(ExistTy { ref bounds, impl_trait_fn, ref generics }) => {\n+                ItemKind::Existential(ExistTy {\n+                    ref bounds,\n+                    impl_trait_fn,\n+                    ref generics,\n+                }) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     let anon_ty = tcx.mk_anon(def_id, substs);\n \n                     // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n-                    let bounds = compute_bounds(&icx,\n-                                                anon_ty,\n-                                                bounds,\n-                                                SizedByDefault::Yes,\n-                                                tcx.def_span(def_id));\n+                    let bounds = compute_bounds(\n+                        &icx,\n+                        anon_ty,\n+                        bounds,\n+                        SizedByDefault::Yes,\n+                        tcx.def_span(def_id),\n+                    );\n \n                     if impl_trait_fn.is_some() {\n                         // impl Trait\n@@ -1555,13 +1715,11 @@ fn explicit_predicates_of<'a, 'tcx>(\n             }\n         }\n \n-        NodeForeignItem(item) => {\n-            match item.node {\n-                ForeignItemKind::Static(..) => &no_generics,\n-                ForeignItemKind::Fn(_, _, ref generics) => generics,\n-                ForeignItemKind::Type => &no_generics,\n-            }\n-        }\n+        NodeForeignItem(item) => match item.node {\n+            ForeignItemKind::Static(..) => &no_generics,\n+            ForeignItemKind::Fn(_, _, ref generics) => generics,\n+            ForeignItemKind::Type => &no_generics,\n+        },\n \n         _ => &no_generics,\n     };\n@@ -1612,7 +1770,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     }\n                     _ => bug!(),\n                 });\n-            },\n+            }\n             _ => bug!(),\n         }\n     }\n@@ -1646,20 +1804,19 @@ fn explicit_predicates_of<'a, 'tcx>(\n                         &hir::GenericBound::Trait(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n-                            let trait_ref =\n-                                AstConv::instantiate_poly_trait_ref(&icx,\n-                                                                    poly_trait_ref,\n-                                                                    ty,\n-                                                                    &mut projections);\n+                            let trait_ref = AstConv::instantiate_poly_trait_ref(\n+                                &icx,\n+                                poly_trait_ref,\n+                                ty,\n+                                &mut projections,\n+                            );\n \n                             predicates.push(trait_ref.to_predicate());\n                             predicates.extend(projections.iter().map(|p| p.to_predicate()));\n                         }\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n-                            let region = AstConv::ast_region_to_region(&icx,\n-                                                                       lifetime,\n-                                                                       None);\n+                            let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             let pred = ty::Binder::bind(ty::OutlivesPredicate(ty, region));\n                             predicates.push(ty::Predicate::TypeOutlives(pred))\n                         }\n@@ -1698,16 +1855,16 @@ fn explicit_predicates_of<'a, 'tcx>(\n                 }\n             };\n \n-            let assoc_ty = tcx.mk_projection(\n-                tcx.hir.local_def_id(trait_item.id),\n-                self_trait_ref.substs,\n-            );\n+            let assoc_ty =\n+                tcx.mk_projection(tcx.hir.local_def_id(trait_item.id), self_trait_ref.substs);\n \n-            let bounds = compute_bounds(&ItemCtxt::new(tcx, def_id),\n-                                        assoc_ty,\n-                                        bounds,\n-                                        SizedByDefault::Yes,\n-                                        trait_item.span);\n+            let bounds = compute_bounds(\n+                &ItemCtxt::new(tcx, def_id),\n+                assoc_ty,\n+                bounds,\n+                SizedByDefault::Yes,\n+                trait_item.span,\n+            );\n \n             bounds.predicates(tcx, assoc_ty).into_iter()\n         }))\n@@ -1718,13 +1875,19 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // before uses of `U`.  This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n-    if let NodeItem(&Item { node: ItemKind::Impl(..), .. }) = node {\n+    if let NodeItem(&Item {\n+        node: ItemKind::Impl(..),\n+        ..\n+    }) = node\n+    {\n         let self_ty = tcx.type_of(def_id);\n         let trait_ref = tcx.impl_trait_ref(def_id);\n-        ctp::setup_constraining_predicates(tcx,\n-                                           &mut predicates,\n-                                           trait_ref,\n-                                           &mut ctp::parameters_for_impl(self_ty, trait_ref));\n+        ctp::setup_constraining_predicates(\n+            tcx,\n+            &mut predicates,\n+            trait_ref,\n+            &mut ctp::parameters_for_impl(self_ty, trait_ref),\n+        );\n     }\n \n     ty::GenericPredicates {\n@@ -1733,18 +1896,21 @@ fn explicit_predicates_of<'a, 'tcx>(\n     }\n }\n \n-pub enum SizedByDefault { Yes, No, }\n+pub enum SizedByDefault {\n+    Yes,\n+    No,\n+}\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &dyn AstConv<'gcx, 'tcx>,\n-                                        param_ty: Ty<'tcx>,\n-                                        ast_bounds: &[hir::GenericBound],\n-                                        sized_by_default: SizedByDefault,\n-                                        span: Span)\n-                                        -> Bounds<'tcx>\n-{\n+pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n+    astconv: &dyn AstConv<'gcx, 'tcx>,\n+    param_ty: Ty<'tcx>,\n+    ast_bounds: &[hir::GenericBound],\n+    sized_by_default: SizedByDefault,\n+    span: Span,\n+) -> Bounds<'tcx> {\n     let mut region_bounds = vec![];\n     let mut trait_bounds = vec![];\n     for ast_bound in ast_bounds {\n@@ -1757,13 +1923,15 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &dyn AstConv<'gcx, 'tcx>,\n \n     let mut projection_bounds = vec![];\n \n-    let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds)\n-    }).collect();\n+    let mut trait_bounds: Vec<_> = trait_bounds\n+        .iter()\n+        .map(|&bound| astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds))\n+        .collect();\n \n-    let region_bounds = region_bounds.into_iter().map(|r| {\n-        astconv.ast_region_to_region(r, None)\n-    }).collect();\n+    let region_bounds = region_bounds\n+        .into_iter()\n+        .map(|r| astconv.ast_region_to_region(r, None))\n+        .collect();\n \n     trait_bounds.sort_by_key(|t| t.def_id());\n \n@@ -1786,21 +1954,20 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &dyn AstConv<'gcx, 'tcx>,\n /// because this can be anywhere from 0 predicates (`T:?Sized` adds no\n /// predicates) to 1 (`T:Foo`) to many (`T:Bar<X=i32>` adds `T:Bar`\n /// and `<T as Bar>::X == i32`).\n-fn predicates_from_bound<'tcx>(astconv: &dyn AstConv<'tcx, 'tcx>,\n-                               param_ty: Ty<'tcx>,\n-                               bound: &hir::GenericBound)\n-                               -> Vec<ty::Predicate<'tcx>>\n-{\n+fn predicates_from_bound<'tcx>(\n+    astconv: &dyn AstConv<'tcx, 'tcx>,\n+    param_ty: Ty<'tcx>,\n+    bound: &hir::GenericBound,\n+) -> Vec<ty::Predicate<'tcx>> {\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n-            let pred = astconv.instantiate_poly_trait_ref(tr,\n-                                                          param_ty,\n-                                                          &mut projections);\n-            projections.into_iter()\n-                       .map(|p| p.to_predicate())\n-                       .chain(Some(pred.to_predicate()))\n-                       .collect()\n+            let pred = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut projections);\n+            projections\n+                .into_iter()\n+                .map(|p| p.to_predicate())\n+                .chain(Some(pred.to_predicate()))\n+                .collect()\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n@@ -1815,21 +1982,32 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     decl: &hir::FnDecl,\n-    abi: abi::Abi)\n-    -> ty::PolyFnSig<'tcx>\n-{\n-    let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), hir::Unsafety::Unsafe, abi, decl);\n+    abi: abi::Abi,\n+) -> ty::PolyFnSig<'tcx> {\n+    let fty = AstConv::ty_of_fn(\n+        &ItemCtxt::new(tcx, def_id),\n+        hir::Unsafety::Unsafe,\n+        abi,\n+        decl,\n+    );\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly.\n-    if abi != abi::Abi::RustIntrinsic && abi != abi::Abi::PlatformIntrinsic\n-            && !tcx.features().simd_ffi {\n+    if abi != abi::Abi::RustIntrinsic\n+        && abi != abi::Abi::PlatformIntrinsic\n+        && !tcx.features().simd_ffi\n+    {\n         let check = |ast_ty: &hir::Ty, ty: Ty| {\n             if ty.is_simd() {\n-                tcx.sess.struct_span_err(ast_ty.span,\n-                              &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n-                                        may result in invalid code\",\n-                                       tcx.hir.node_to_pretty_string(ast_ty.id)))\n+                tcx.sess\n+                    .struct_span_err(\n+                        ast_ty.span,\n+                        &format!(\n+                            \"use of SIMD type `{}` in FFI is highly experimental and \\\n+                             may result in invalid code\",\n+                            tcx.hir.node_to_pretty_string(ast_ty.id)\n+                        ),\n+                    )\n                     .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n                     .emit();\n             }\n@@ -1845,13 +2023,11 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     fty\n }\n \n-fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             def_id: DefId)\n-                             -> bool {\n+fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     match tcx.hir.get_if_local(def_id) {\n         Some(hir_map::NodeForeignItem(..)) => true,\n         Some(_) => false,\n-        _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id)\n+        _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id),\n     }\n }\n \n@@ -1868,7 +2044,7 @@ fn from_target_feature(\n             let msg = \"#[target_feature] attribute must be of the form \\\n                        #[target_feature(..)]\";\n             tcx.sess.span_err(attr.span, &msg);\n-            return\n+            return;\n         }\n     };\n     let rust_features = tcx.features();\n@@ -1878,7 +2054,7 @@ fn from_target_feature(\n             let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n                        currently\";\n             tcx.sess.span_err(item.span, &msg);\n-            continue\n+            continue;\n         }\n \n         // Must be of the form `enable = \"...\"` ( a string)\n@@ -1888,19 +2064,21 @@ fn from_target_feature(\n                 let msg = \"#[target_feature] attribute must be of the form \\\n                            #[target_feature(enable = \\\"..\\\")]\";\n                 tcx.sess.span_err(item.span, &msg);\n-                continue\n+                continue;\n             }\n         };\n \n         // We allow comma separation to enable multiple features\n         for feature in value.as_str().split(',') {\n-\n             // Only allow whitelisted features per platform\n             let feature_gate = match whitelist.get(feature) {\n                 Some(g) => g,\n                 None => {\n-                    let msg = format!(\"the feature named `{}` is not valid for \\\n-                                       this target\", feature);\n+                    let msg = format!(\n+                        \"the feature named `{}` is not valid for \\\n+                         this target\",\n+                        feature\n+                    );\n                     let mut err = tcx.sess.struct_span_err(item.span, &msg);\n \n                     if feature.starts_with(\"+\") {\n@@ -1910,7 +2088,7 @@ fn from_target_feature(\n                         }\n                     }\n                     err.emit();\n-                    continue\n+                    continue;\n                 }\n             };\n \n@@ -1935,10 +2113,9 @@ fn from_target_feature(\n                     feature_gate.as_ref().unwrap(),\n                     item.span,\n                     feature_gate::GateIssue::Language,\n-                    &format!(\"the target feature `{}` is currently unstable\",\n-                             feature),\n+                    &format!(\"the target feature `{}` is currently unstable\", feature),\n                 );\n-                continue\n+                continue;\n             }\n             target_features.push(Symbol::intern(feature));\n         }\n@@ -1973,7 +2150,8 @@ fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &\n             if let Some(span) = span {\n                 tcx.sess.span_fatal(span, \"invalid linkage specified\")\n             } else {\n-                tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+                tcx.sess\n+                    .fatal(&format!(\"invalid linkage specified: {}\", name))\n             }\n         }\n     }\n@@ -2026,16 +2204,24 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                         mark_used(attr);\n                         inline_span = Some(attr.span);\n                         if items.len() != 1 {\n-                            span_err!(tcx.sess.diagnostic(), attr.span, E0534,\n-                                        \"expected one argument\");\n+                            span_err!(\n+                                tcx.sess.diagnostic(),\n+                                attr.span,\n+                                E0534,\n+                                \"expected one argument\"\n+                            );\n                             InlineAttr::None\n                         } else if list_contains_name(&items[..], \"always\") {\n                             InlineAttr::Always\n                         } else if list_contains_name(&items[..], \"never\") {\n                             InlineAttr::Never\n                         } else {\n-                            span_err!(tcx.sess.diagnostic(), items[0].span, E0535,\n-                                        \"invalid argument\");\n+                            span_err!(\n+                                tcx.sess.diagnostic(),\n+                                items[0].span,\n+                                E0535,\n+                                \"invalid argument\"\n+                            );\n \n                             InlineAttr::None\n                         }\n@@ -2048,15 +2234,21 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 if s.as_str().contains(\"\\0\") {\n                     // `#[export_name = ...]` will be converted to a null-terminated string,\n                     // so it may not contain any null characters.\n-                    struct_span_err!(tcx.sess, attr.span, E0648,\n-                                     \"`export_name` may not contain null characters\")\n-                        .emit();\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        attr.span,\n+                        E0648,\n+                        \"`export_name` may not contain null characters\"\n+                    ).emit();\n                 }\n                 codegen_fn_attrs.export_name = Some(s);\n             } else {\n-                struct_span_err!(tcx.sess, attr.span, E0558,\n-                                 \"`export_name` attribute has invalid format\")\n-                    .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0558,\n+                    \"`export_name` attribute has invalid format\"\n+                ).span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n                     .emit();\n             }\n         } else if attr.check_name(\"target_feature\") {\n@@ -2065,16 +2257,25 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                            `unsafe` function\";\n                 tcx.sess.span_err(attr.span, msg);\n             }\n-            from_target_feature(tcx, id, attr, &whitelist, &mut codegen_fn_attrs.target_features);\n+            from_target_feature(\n+                tcx,\n+                id,\n+                attr,\n+                &whitelist,\n+                &mut codegen_fn_attrs.target_features,\n+            );\n         } else if attr.check_name(\"linkage\") {\n             if let Some(val) = attr.value_str() {\n                 codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n             }\n         } else if attr.check_name(\"link_section\") {\n             if let Some(val) = attr.value_str() {\n                 if val.as_str().bytes().any(|b| b == 0) {\n-                    let msg = format!(\"illegal null byte in link_section \\\n-                                       value: `{}`\", &val);\n+                    let msg = format!(\n+                        \"illegal null byte in link_section \\\n+                         value: `{}`\",\n+                        &val\n+                    );\n                     tcx.sess.span_err(attr.span, &msg);\n                 } else {\n                     codegen_fn_attrs.link_section = Some(val);\n@@ -2090,8 +2291,11 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n     if codegen_fn_attrs.target_features.len() > 0 {\n         if codegen_fn_attrs.inline == InlineAttr::Always {\n             if let Some(span) = inline_span {\n-                tcx.sess.span_err(span, \"cannot use #[inline(always)] with \\\n-                                         #[target_feature]\");\n+                tcx.sess.span_err(\n+                    span,\n+                    \"cannot use #[inline(always)] with \\\n+                     #[target_feature]\",\n+                );\n             }\n         }\n     }"}, {"sha": "d055a6f12c17ffbf184bff0b63eda15c852801ed", "filename": "src/test/ui/issue-53300.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d41f21f11a249ad78990eb9a1ec899ec123c7136/src%2Ftest%2Fui%2Fissue-53300.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d41f21f11a249ad78990eb9a1ec899ec123c7136/src%2Ftest%2Fui%2Fissue-53300.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53300.rs?ref=d41f21f11a249ad78990eb9a1ec899ec123c7136", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// issue 53300\n+\n+pub trait A {\n+    fn add(&self, b: i32) -> i32;\n+}\n+\n+fn addition() -> Wrapper<impl A> {}\n+//~^ ERROR cannot find type `Wrapper` in this scope [E0412]\n+\n+fn main() {\n+    let res = addition();\n+}"}, {"sha": "920287a32d69d1955d9bbdc7bfe0e99c2a1fcbb0", "filename": "src/test/ui/issue-53300.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d41f21f11a249ad78990eb9a1ec899ec123c7136/src%2Ftest%2Fui%2Fissue-53300.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d41f21f11a249ad78990eb9a1ec899ec123c7136/src%2Ftest%2Fui%2Fissue-53300.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53300.stderr?ref=d41f21f11a249ad78990eb9a1ec899ec123c7136", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `Wrapper` in this scope\n+  --> $DIR/issue-53300.rs:17:18\n+   |\n+LL | fn addition() -> Wrapper<impl A> {}\n+   |                  ^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}]}