{"sha": "547504795ce95493bb2d55835e0f7567660a8b76", "node_id": "C_kwDOAAsO6NoAKDU0NzUwNDc5NWNlOTU0OTNiYjJkNTU4MzVlMGY3NTY3NjYwYThiNzY", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-03-30T07:02:21Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-03-30T10:19:51Z"}, "message": "Synchronize asynchronous pipe reads and writes", "tree": {"sha": "985c07bef28dd696f571071823d34800d34e0fdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/985c07bef28dd696f571071823d34800d34e0fdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/547504795ce95493bb2d55835e0f7567660a8b76", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmJELsgACgkQcTRy8vRW\nJ96qbg/+Jv/sD5voyzKklF8Y8jRGkN5t7jFvOW+deezQEe7YimOXaOwfvHaGJd9j\n6GDiyTmr7u3VEwsBLWYucpJ4bbVhqyo4SHWHQRoEmtQRufk0OnQKMha9/rMvRk9N\nWpY+9Ulmqakhgc7ZJG1tJBJ/VPI9xpQrg0qIMdLhLlqPR5ygPVrdlXrsMn99piFA\n+X3ModWy6S1lafdUBqT9aCJ8a0zpVV2dG7K1P5L9KkkGA1GI7riAYpbgLUy5TxEQ\nfLEsLfT9xm3Dza/maPY1QnTvtUsdQ0v/1AQwB81eFifunyY3lvAfMuTURHuVq8zq\n7BkUXQ4/dTizyQCSpSycNt0xT6X1Xni94v4f/UW+5mULun63hu2z+ltQK10S6azk\n+rAsvrGxwHFXmR4nuE+g1FIsHYRvnzmhJr1OPcXp9Orf/L9RQd9BB51dDHY/qh81\n5V4kNXGodYkY51lh7iZ1CKTCnGl5d7E1ji3his5FROX9u/cc1dlbweSlHaOcqmjF\noXAnMl0oQ8lYSEWtsRZrXUydS1Ao9yHZS884DqKkL6AmYkpDd8pecDguGcBUo7ru\nPB4P1SenMP3MHhAMhMvMjIyMDxdHVCdFAq62udfYk9b7M5SRRyb6xhQ9URB7GiTS\nHeeaLU/cfkL060Q3u8XK+0GG/tjenvFzYryH/MI2OSSVRKD0X20=\n=dk8k\n-----END PGP SIGNATURE-----", "payload": "tree 985c07bef28dd696f571071823d34800d34e0fdd\nparent 05142a7e4495f09141fdd65f140fe44d8c200a9e\nauthor Chris Denton <christophersdenton@gmail.com> 1648623741 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1648635591 +0100\n\nSynchronize asynchronous pipe reads and writes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/547504795ce95493bb2d55835e0f7567660a8b76", "html_url": "https://github.com/rust-lang/rust/commit/547504795ce95493bb2d55835e0f7567660a8b76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/547504795ce95493bb2d55835e0f7567660a8b76/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05142a7e4495f09141fdd65f140fe44d8c200a9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/05142a7e4495f09141fdd65f140fe44d8c200a9e", "html_url": "https://github.com/rust-lang/rust/commit/05142a7e4495f09141fdd65f140fe44d8c200a9e"}], "stats": {"total": 140, "additions": 138, "deletions": 2}, "files": [{"sha": "70ce990132698b987a897a1c3643698b4091cd6b", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/547504795ce95493bb2d55835e0f7567660a8b76/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547504795ce95493bb2d55835e0f7567660a8b76/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=547504795ce95493bb2d55835e0f7567660a8b76", "patch": "@@ -326,6 +326,12 @@ impl Default for IO_STATUS_BLOCK {\n     }\n }\n \n+pub type LPOVERLAPPED_COMPLETION_ROUTINE = unsafe extern \"C\" fn(\n+    dwErrorCode: DWORD,\n+    dwNumberOfBytesTransfered: DWORD,\n+    lpOverlapped: *mut OVERLAPPED,\n+);\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -891,6 +897,7 @@ extern \"system\" {\n     pub fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n     pub fn SwitchToThread() -> BOOL;\n     pub fn Sleep(dwMilliseconds: DWORD);\n+    pub fn SleepEx(dwMilliseconds: DWORD, bAlertable: BOOL) -> DWORD;\n     pub fn GetProcessId(handle: HANDLE) -> DWORD;\n     pub fn CopyFileExW(\n         lpExistingFileName: LPCWSTR,\n@@ -957,13 +964,27 @@ extern \"system\" {\n         lpNumberOfBytesRead: LPDWORD,\n         lpOverlapped: LPOVERLAPPED,\n     ) -> BOOL;\n+    pub fn ReadFileEx(\n+        hFile: BorrowedHandle<'_>,\n+        lpBuffer: LPVOID,\n+        nNumberOfBytesToRead: DWORD,\n+        lpOverlapped: LPOVERLAPPED,\n+        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,\n+    ) -> BOOL;\n     pub fn WriteFile(\n         hFile: BorrowedHandle<'_>,\n         lpBuffer: LPVOID,\n         nNumberOfBytesToWrite: DWORD,\n         lpNumberOfBytesWritten: LPDWORD,\n         lpOverlapped: LPOVERLAPPED,\n     ) -> BOOL;\n+    pub fn WriteFileEx(\n+        hFile: BorrowedHandle<'_>,\n+        lpBuffer: LPVOID,\n+        nNumberOfBytesToWrite: DWORD,\n+        lpOverlapped: LPOVERLAPPED,\n+        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,\n+    ) -> BOOL;\n     pub fn CloseHandle(hObject: HANDLE) -> BOOL;\n     pub fn MoveFileExW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD)\n     -> BOOL;"}, {"sha": "94a2051478989f5ae16d7ce24198ad90403fd96a", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 117, "deletions": 2, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/547504795ce95493bb2d55835e0f7567660a8b76/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547504795ce95493bb2d55835e0f7567660a8b76/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=547504795ce95493bb2d55835e0f7567660a8b76", "patch": "@@ -173,6 +173,15 @@ fn random_number() -> usize {\n     }\n }\n \n+// Abstracts over `ReadFileEx` and `WriteFileEx`\n+type AlertableIoFn = unsafe extern \"system\" fn(\n+    BorrowedHandle<'_>,\n+    c::LPVOID,\n+    c::DWORD,\n+    c::LPOVERLAPPED,\n+    c::LPOVERLAPPED_COMPLETION_ROUTINE,\n+) -> c::BOOL;\n+\n impl AnonPipe {\n     pub fn handle(&self) -> &Handle {\n         &self.inner\n@@ -182,7 +191,19 @@ impl AnonPipe {\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.inner.read(buf)\n+        let result = unsafe {\n+            let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n+            self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n+        };\n+\n+        match result {\n+            // The special treatment of BrokenPipe is to deal with Windows\n+            // pipe semantics, which yields this error when *reading* from\n+            // a pipe after the other end has closed; we interpret that as\n+            // EOF on the pipe.\n+            Err(ref e) if e.kind() == io::ErrorKind::BrokenPipe => Ok(0),\n+            _ => result,\n+        }\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n@@ -195,7 +216,10 @@ impl AnonPipe {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.inner.write(buf)\n+        unsafe {\n+            let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n+            self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n+        }\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n@@ -206,6 +230,97 @@ impl AnonPipe {\n     pub fn is_write_vectored(&self) -> bool {\n         self.inner.is_write_vectored()\n     }\n+\n+    /// Synchronizes asynchronous reads or writes using our anonymous pipe.\n+    ///\n+    /// This is a wrapper around [`ReadFileEx`] or [`WriteFileEx`] that uses\n+    /// [Asynchronous Procedure Call] (APC) to synchronize reads or writes.\n+    ///\n+    /// Note: This should not be used for handles we don't create.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `buf` must be a pointer to a buffer that's valid for reads or writes\n+    /// up to `len` bytes. The `AlertableIoFn` must be either `ReadFileEx` or `WriteFileEx`\n+    ///\n+    /// [`ReadFileEx`]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfileex\n+    /// [`WriteFileEx`]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefileex\n+    /// [Asynchronous Procedure Call]: https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls\n+    unsafe fn alertable_io_internal(\n+        &self,\n+        io: AlertableIoFn,\n+        buf: c::LPVOID,\n+        len: c::DWORD,\n+    ) -> io::Result<usize> {\n+        // Use \"alertable I/O\" to synchronize the pipe I/O.\n+        // This has four steps.\n+        //\n+        // STEP 1: Start the asynchronous I/O operation.\n+        //         This simply calls either `ReadFileEx` or `WriteFileEx`,\n+        //         giving it a pointer to the buffer and callback function.\n+        //\n+        // STEP 2: Enter an alertable state.\n+        //         The callback set in step 1 will not be called until the thread\n+        //         enters an \"alertable\" state. This can be done using `SleepEx`.\n+        //\n+        // STEP 3: The callback\n+        //         Once the I/O is complete and the thread is in an alertable state,\n+        //         the callback will be run on the same thread as the call to\n+        //         `ReadFileEx` or `WriteFileEx` done in step 1.\n+        //         In the callback we simply set the result of the async operation.\n+        //\n+        // STEP 4: Return the result.\n+        //         At this point we'll have a result from the callback function\n+        //         and can simply return it. Note that we must not return earlier,\n+        //         while the I/O is still in progress.\n+\n+        // The result that will be set from the asynchronous callback.\n+        let mut async_result: Option<AsyncResult> = None;\n+        struct AsyncResult {\n+            error: u32,\n+            transfered: u32,\n+        }\n+\n+        // STEP 3: The callback.\n+        unsafe extern \"C\" fn callback(\n+            dwErrorCode: u32,\n+            dwNumberOfBytesTransfered: u32,\n+            lpOverlapped: *mut c::OVERLAPPED,\n+        ) {\n+            // Set `async_result` using a pointer smuggled through `hEvent`.\n+            let result = AsyncResult { error: dwErrorCode, transfered: dwNumberOfBytesTransfered };\n+            *(*lpOverlapped).hEvent.cast::<Option<AsyncResult>>() = Some(result);\n+        }\n+\n+        // STEP 1: Start the I/O operation.\n+        let mut overlapped: c::OVERLAPPED = crate::mem::zeroed();\n+        // `hEvent` is unused by `ReadFileEx` and `WriteFileEx`.\n+        // Therefore the documentation suggests using it to smuggle a pointer to the callback.\n+        overlapped.hEvent = &mut async_result as *mut _ as *mut _;\n+\n+        // Asynchronous read of the pipe.\n+        // If successful, `callback` will be called once it completes.\n+        let result = io(self.inner.as_handle(), buf, len, &mut overlapped, callback);\n+        if result == c::FALSE {\n+            // We can return here because the call failed.\n+            // After this we must not return until the I/O completes.\n+            return Err(io::Error::last_os_error());\n+        }\n+\n+        // Wait indefinitely for the result.\n+        while async_result.is_none() {\n+            // STEP 2: Enter an alertable state.\n+            // The second parameter of `SleepEx` is used to make this sleep alertable.\n+            c::SleepEx(c::INFINITE, c::TRUE);\n+        }\n+        // STEP 4: Return the result.\n+        // `async_result` is always `Some` at this point.\n+        let result = async_result.unwrap();\n+        match result.error {\n+            c::ERROR_SUCCESS => Ok(result.transfered as usize),\n+            error => Err(io::Error::from_raw_os_error(error as _)),\n+        }\n+    }\n }\n \n pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {"}]}