{"sha": "71abc9565f037c3c9da5814c23857545abb0aaab", "node_id": "C_kwDOAAsO6NoAKDcxYWJjOTU2NWYwMzdjM2M5ZGE1ODE0YzIzODU3NTQ1YWJiMGFhYWI", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T23:00:08Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T23:30:38Z"}, "message": "Replace `Pat` with a new intermediate representation", "tree": {"sha": "970d4313d37ef8967f84e3e13c23d89d6318fc8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/970d4313d37ef8967f84e3e13c23d89d6318fc8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71abc9565f037c3c9da5814c23857545abb0aaab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71abc9565f037c3c9da5814c23857545abb0aaab", "html_url": "https://github.com/rust-lang/rust/commit/71abc9565f037c3c9da5814c23857545abb0aaab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71abc9565f037c3c9da5814c23857545abb0aaab/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fde45e96b87616bfecb630c748a58856febcad34", "url": "https://api.github.com/repos/rust-lang/rust/commits/fde45e96b87616bfecb630c748a58856febcad34", "html_url": "https://github.com/rust-lang/rust/commit/fde45e96b87616bfecb630c748a58856febcad34"}], "stats": {"total": 1171, "additions": 667, "deletions": 504}, "files": [{"sha": "08f8850e78ed252cab51e8b323ffda0cbd912588", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 74, "deletions": 84, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/71abc9565f037c3c9da5814c23857545abb0aaab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71abc9565f037c3c9da5814c23857545abb0aaab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=71abc9565f037c3c9da5814c23857545abb0aaab", "patch": "@@ -1,6 +1,6 @@\n+use super::deconstruct_pat::{Constructor, DeconstructedPat};\n use super::usefulness::{\n-    compute_match_usefulness, expand_pattern, is_wildcard, MatchArm, MatchCheckCtxt, Reachability,\n-    UsefulnessReport,\n+    compute_match_usefulness, MatchArm, MatchCheckCtxt, Reachability, UsefulnessReport,\n };\n use super::{PatCtxt, PatternError};\n \n@@ -12,26 +12,25 @@ use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n-use rustc_middle::thir::PatKind;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_session::lint::builtin::{\n     BINDINGS_WITH_VARIANT_NAME, IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS,\n };\n use rustc_session::Session;\n use rustc_span::{DesugaringKind, ExpnKind, Span};\n-use std::slice;\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n         None => return,\n         Some(id) => tcx.hir().body_owned_by(tcx.hir().local_def_id_to_hir_id(id)),\n     };\n \n+    let pattern_arena = TypedArena::default();\n     let mut visitor = MatchVisitor {\n         tcx,\n         typeck_results: tcx.typeck_body(body_id),\n         param_env: tcx.param_env(def_id),\n-        pattern_arena: TypedArena::default(),\n+        pattern_arena: &pattern_arena,\n     };\n     visitor.visit_body(tcx.hir().body(body_id));\n }\n@@ -40,14 +39,14 @@ fn create_e0004(sess: &Session, sp: Span, error_message: String) -> DiagnosticBu\n     struct_span_err!(sess, sp, E0004, \"{}\", &error_message)\n }\n \n-struct MatchVisitor<'a, 'tcx> {\n+struct MatchVisitor<'a, 'p, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    pattern_arena: TypedArena<super::Pat<'tcx>>,\n+    pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n }\n \n-impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n     type Map = intravisit::ErasedMap<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n@@ -113,31 +112,30 @@ impl PatCtxt<'_, '_> {\n     }\n }\n \n-impl<'tcx> MatchVisitor<'_, 'tcx> {\n+impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n     fn check_patterns(&self, pat: &Pat<'_>) {\n         pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         check_for_bindings_named_same_as_variants(self, pat);\n     }\n \n-    fn lower_pattern<'p>(\n+    fn lower_pattern(\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         pat: &'tcx hir::Pat<'tcx>,\n         have_errors: &mut bool,\n-    ) -> (&'p super::Pat<'tcx>, Ty<'tcx>) {\n+    ) -> &'p DeconstructedPat<'p, 'tcx> {\n         let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.typeck_results);\n         patcx.include_lint_checks();\n         let pattern = patcx.lower_pattern(pat);\n-        let pattern_ty = pattern.ty;\n-        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(pattern));\n+        let pattern: &_ = cx.pattern_arena.alloc(DeconstructedPat::from_pat(cx, &pattern));\n         if !patcx.errors.is_empty() {\n             *have_errors = true;\n             patcx.report_inlining_errors();\n         }\n-        (pattern, pattern_ty)\n+        pattern\n     }\n \n-    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'_, 'tcx> {\n+    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'p, 'tcx> {\n         MatchCheckCtxt {\n             tcx: self.tcx,\n             param_env: self.param_env,\n@@ -149,8 +147,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, expr: &hir::Expr<'_>, span: Span) {\n         self.check_patterns(pat);\n         let mut cx = self.new_cx(expr.hir_id);\n-        let tpat = self.lower_pattern(&mut cx, pat, &mut false).0;\n-        check_let_reachability(&mut cx, pat.hir_id, &tpat, span);\n+        let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n+        check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n     }\n \n     fn check_match(\n@@ -166,8 +164,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             self.check_patterns(&arm.pat);\n             if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n                 self.check_patterns(pat);\n-                let tpat = self.lower_pattern(&mut cx, pat, &mut false).0;\n-                check_let_reachability(&mut cx, pat.hir_id, &tpat, tpat.span);\n+                let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n+                check_let_reachability(&mut cx, pat.hir_id, tpat, tpat.span());\n             }\n         }\n \n@@ -176,7 +174,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         let arms: Vec<_> = arms\n             .iter()\n             .map(|hir::Arm { pat, guard, .. }| MatchArm {\n-                pat: self.lower_pattern(&mut cx, pat, &mut have_errors).0,\n+                pat: self.lower_pattern(&mut cx, pat, &mut have_errors),\n                 hir_id: pat.hir_id,\n                 has_guard: guard.is_some(),\n             })\n@@ -210,7 +208,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(pat.hir_id);\n \n-        let (pattern, pattern_ty) = self.lower_pattern(&mut cx, pat, &mut false);\n+        let pattern = self.lower_pattern(&mut cx, pat, &mut false);\n+        let pattern_ty = pattern.ty();\n         let arms = vec![MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false }];\n         let report = compute_match_usefulness(&cx, &arms, pat.hir_id, pattern_ty);\n \n@@ -222,7 +221,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             return;\n         }\n \n-        let joined_patterns = joined_uncovered_patterns(&witnesses);\n+        let joined_patterns = joined_uncovered_patterns(&cx, &witnesses);\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             pat.span,\n@@ -298,7 +297,7 @@ fn const_not_var(\n     }\n }\n \n-fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n+fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_, '_>, pat: &Pat<'_>) {\n     pat.walk_always(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(ty::BindByValue(hir::Mutability::Not)) =\n@@ -340,12 +339,11 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(pat: &super::Pat<'_>) -> bool {\n-    use PatKind::*;\n-    match &*pat.kind {\n-        Binding { subpattern: None, .. } => true,\n-        Binding { subpattern: Some(s), .. } | Deref { subpattern: s } => pat_is_catchall(s),\n-        Leaf { subpatterns: s } => s.iter().all(|p| pat_is_catchall(&p.pattern)),\n+fn pat_is_catchall(pat: &DeconstructedPat<'_, '_>) -> bool {\n+    use Constructor::*;\n+    match pat.ctor() {\n+        Wildcard => true,\n+        Single => pat.iter_fields().all(|pat| pat_is_catchall(pat)),\n         _ => false,\n     }\n }\n@@ -424,11 +422,11 @@ fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n fn check_let_reachability<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     pat_id: HirId,\n-    pat: &'p super::Pat<'tcx>,\n+    pat: &'p DeconstructedPat<'p, 'tcx>,\n     span: Span,\n ) {\n     let arms = [MatchArm { pat, hir_id: pat_id, has_guard: false }];\n-    let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty);\n+    let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty());\n \n     // Report if the pattern is unreachable, which can only occur when the type is uninhabited.\n     // This also reports unreachable sub-patterns though, so we can't just replace it with an\n@@ -450,7 +448,7 @@ fn report_arm_reachability<'p, 'tcx>(\n     let mut catchall = None;\n     for (arm, is_useful) in report.arm_usefulness.iter() {\n         match is_useful {\n-            Unreachable => unreachable_pattern(cx.tcx, arm.pat.span, arm.hir_id, catchall),\n+            Unreachable => unreachable_pattern(cx.tcx, arm.pat.span(), arm.hir_id, catchall),\n             Reachable(unreachables) if unreachables.is_empty() => {}\n             // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n             Reachable(unreachables) => {\n@@ -463,7 +461,7 @@ fn report_arm_reachability<'p, 'tcx>(\n             }\n         }\n         if !arm.has_guard && catchall.is_none() && pat_is_catchall(arm.pat) {\n-            catchall = Some(arm.pat.span);\n+            catchall = Some(arm.pat.span());\n         }\n     }\n }\n@@ -473,7 +471,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n-    witnesses: Vec<super::Pat<'tcx>>,\n+    witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n     is_empty_match: bool,\n ) {\n     let non_empty_enum = match scrut_ty.kind() {\n@@ -490,7 +488,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n             format!(\"non-exhaustive patterns: type `{}` is non-empty\", scrut_ty),\n         );\n     } else {\n-        let joined_patterns = joined_uncovered_patterns(&witnesses);\n+        let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n         err = create_e0004(\n             cx.tcx.sess,\n             sp,\n@@ -517,7 +515,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     if (scrut_ty == cx.tcx.types.usize || scrut_ty == cx.tcx.types.isize)\n         && !is_empty_match\n         && witnesses.len() == 1\n-        && is_wildcard(&witnesses[0])\n+        && matches!(witnesses[0].ctor(), Constructor::NonExhaustive)\n     {\n         err.note(&format!(\n             \"`{}` does not have a fixed maximum value, \\\n@@ -540,33 +538,40 @@ fn non_exhaustive_match<'p, 'tcx>(\n     err.emit();\n }\n \n-crate fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n+crate fn joined_uncovered_patterns<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    witnesses: &[DeconstructedPat<'p, 'tcx>],\n+) -> String {\n     const LIMIT: usize = 3;\n+    let pat_to_str = |pat: &DeconstructedPat<'p, 'tcx>| pat.to_pat(cx).to_string();\n     match witnesses {\n         [] => bug!(),\n-        [witness] => format!(\"`{}`\", witness),\n+        [witness] => format!(\"`{}`\", witness.to_pat(cx)),\n         [head @ .., tail] if head.len() < LIMIT => {\n-            let head: Vec<_> = head.iter().map(<_>::to_string).collect();\n-            format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n+            let head: Vec<_> = head.iter().map(pat_to_str).collect();\n+            format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail.to_pat(cx))\n         }\n         _ => {\n             let (head, tail) = witnesses.split_at(LIMIT);\n-            let head: Vec<_> = head.iter().map(<_>::to_string).collect();\n+            let head: Vec<_> = head.iter().map(pat_to_str).collect();\n             format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n         }\n     }\n }\n \n-crate fn pattern_not_covered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n+crate fn pattern_not_covered_label(\n+    witnesses: &[DeconstructedPat<'_, '_>],\n+    joined_patterns: &str,\n+) -> String {\n     format!(\"pattern{} {} not covered\", rustc_errors::pluralize!(witnesses.len()), joined_patterns)\n }\n \n /// Point at the definition of non-covered `enum` variants.\n-fn adt_defined_here(\n-    cx: &MatchCheckCtxt<'_, '_>,\n+fn adt_defined_here<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n     err: &mut DiagnosticBuilder<'_>,\n-    ty: Ty<'_>,\n-    witnesses: &[super::Pat<'_>],\n+    ty: Ty<'tcx>,\n+    witnesses: &[DeconstructedPat<'p, 'tcx>],\n ) {\n     let ty = ty.peel_refs();\n     if let ty::Adt(def, _) = ty.kind() {\n@@ -575,57 +580,42 @@ fn adt_defined_here(\n         }\n \n         if witnesses.len() < 4 {\n-            for sp in maybe_point_at_variant(ty, &witnesses) {\n+            for sp in maybe_point_at_variant(cx, def, witnesses.iter()) {\n                 err.span_label(sp, \"not covered\");\n             }\n         }\n     }\n }\n \n-fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span> {\n+fn maybe_point_at_variant<'a, 'p: 'a, 'tcx: 'a>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    def: &AdtDef,\n+    patterns: impl Iterator<Item = &'a DeconstructedPat<'p, 'tcx>>,\n+) -> Vec<Span> {\n+    use Constructor::*;\n     let mut covered = vec![];\n-    if let ty::Adt(def, _) = ty.kind() {\n-        // Don't point at variants that have already been covered due to other patterns to avoid\n-        // visual clutter.\n-        for pattern in patterns {\n-            use PatKind::{AscribeUserType, Deref, Leaf, Or, Variant};\n-            match &*pattern.kind {\n-                AscribeUserType { subpattern, .. } | Deref { subpattern } => {\n-                    covered.extend(maybe_point_at_variant(ty, slice::from_ref(&subpattern)));\n-                }\n-                Variant { adt_def, variant_index, subpatterns, .. } if adt_def.did == def.did => {\n-                    let sp = def.variants[*variant_index].ident.span;\n-                    if covered.contains(&sp) {\n-                        continue;\n-                    }\n-                    covered.push(sp);\n-\n-                    let pats = subpatterns\n-                        .iter()\n-                        .map(|field_pattern| field_pattern.pattern.clone())\n-                        .collect::<Box<[_]>>();\n-                    covered.extend(maybe_point_at_variant(ty, &pats));\n-                }\n-                Leaf { subpatterns } => {\n-                    let pats = subpatterns\n-                        .iter()\n-                        .map(|field_pattern| field_pattern.pattern.clone())\n-                        .collect::<Box<[_]>>();\n-                    covered.extend(maybe_point_at_variant(ty, &pats));\n+    for pattern in patterns {\n+        if let Variant(variant_index) = pattern.ctor() {\n+            if let ty::Adt(this_def, _) = pattern.ty().kind() {\n+                if this_def.did != def.did {\n+                    continue;\n                 }\n-                Or { pats } => {\n-                    let pats = pats.iter().cloned().collect::<Box<[_]>>();\n-                    covered.extend(maybe_point_at_variant(ty, &pats));\n-                }\n-                _ => {}\n             }\n+            let sp = def.variants[*variant_index].ident.span;\n+            if covered.contains(&sp) {\n+                // Don't point at variants that have already been covered due to other patterns to avoid\n+                // visual clutter.\n+                continue;\n+            }\n+            covered.push(sp);\n         }\n+        covered.extend(maybe_point_at_variant(cx, def, pattern.iter_fields()));\n     }\n     covered\n }\n \n /// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n-fn is_binding_by_move(cx: &MatchVisitor<'_, '_>, hir_id: HirId, span: Span) -> bool {\n+fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId, span: Span) -> bool {\n     !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx.at(span), cx.param_env)\n }\n \n@@ -639,7 +629,7 @@ fn is_binding_by_move(cx: &MatchVisitor<'_, '_>, hir_id: HirId, span: Span) -> b\n /// - `x @ Some(ref mut? y)`.\n ///\n /// This analysis is *not* subsumed by NLL.\n-fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n+fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pat<'_>) {\n     // Extract `sub` in `binding @ sub`.\n     let (name, sub) = match &pat.kind {\n         hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),"}, {"sha": "b217aa7cc3f39533650f171f3799c54fb843cd1a", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 477, "deletions": 244, "changes": 721, "blob_url": "https://github.com/rust-lang/rust/blob/71abc9565f037c3c9da5814c23857545abb0aaab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71abc9565f037c3c9da5814c23857545abb0aaab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=71abc9565f037c3c9da5814c23857545abb0aaab", "patch": "@@ -46,7 +46,7 @@ use self::Constructor::*;\n use self::SliceKind::*;\n \n use super::compare_const_vals;\n-use super::usefulness::{is_wildcard, MatchCheckCtxt, PatCtxt};\n+use super::usefulness::{MatchCheckCtxt, PatCtxt};\n \n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n@@ -62,10 +62,29 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n+use std::borrow::Cow;\n use std::cmp::{self, max, min, Ordering};\n+use std::fmt;\n use std::iter::{once, IntoIterator};\n use std::ops::RangeInclusive;\n \n+/// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n+fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n+    fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n+        if let PatKind::Or { pats } = pat.kind.as_ref() {\n+            for pat in pats {\n+                expand(pat, vec);\n+            }\n+        } else {\n+            vec.push(pat)\n+        }\n+    }\n+\n+    let mut pats = Vec::new();\n+    expand(pat, &mut pats);\n+    pats\n+}\n+\n /// An inclusive interval, used for precise integer exhaustiveness checking.\n /// `IntRange`s always store a contiguous range. This means that values are\n /// encoded such that `0` encodes the minimum value for the integer,\n@@ -76,9 +95,13 @@ use std::ops::RangeInclusive;\n ///\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq)]\n pub(super) struct IntRange {\n     range: RangeInclusive<u128>,\n+    /// Keeps the bias used for encoding the range. It depends on the type of the range and\n+    /// possibly the pointer size of the current architecture. The algorithm ensures we never\n+    /// compare `IntRange`s with different types/architectures.\n+    bias: u128,\n }\n \n impl IntRange {\n@@ -131,7 +154,7 @@ impl IntRange {\n                 value.try_eval_bits(tcx, param_env, ty)\n             })()?;\n             let val = val ^ bias;\n-            Some(IntRange { range: val..=val })\n+            Some(IntRange { range: val..=val, bias })\n         } else {\n             None\n         }\n@@ -155,7 +178,7 @@ impl IntRange {\n                 // This should have been caught earlier by E0030.\n                 bug!(\"malformed range pattern: {}..={}\", lo, (hi - offset));\n             }\n-            Some(IntRange { range: lo..=(hi - offset) })\n+            Some(IntRange { range: lo..=(hi - offset), bias })\n         } else {\n             None\n         }\n@@ -180,7 +203,7 @@ impl IntRange {\n         let (lo, hi) = self.boundaries();\n         let (other_lo, other_hi) = other.boundaries();\n         if lo <= other_hi && other_lo <= hi {\n-            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi) })\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), bias: self.bias })\n         } else {\n             None\n         }\n@@ -203,10 +226,11 @@ impl IntRange {\n         (lo == other_hi || hi == other_lo) && !self.is_singleton() && !other.is_singleton()\n     }\n \n+    /// Only used for displaying the range properly.\n     fn to_pat<'tcx>(&self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n         let (lo, hi) = self.boundaries();\n \n-        let bias = IntRange::signed_bias(tcx, ty);\n+        let bias = self.bias;\n         let (lo, hi) = (lo ^ bias, hi ^ bias);\n \n         let env = ty::ParamEnv::empty().and(ty);\n@@ -223,10 +247,10 @@ impl IntRange {\n     }\n \n     /// Lint on likely incorrect range patterns (#63987)\n-    pub(super) fn lint_overlapping_range_endpoints<'a, 'tcx: 'a>(\n+    pub(super) fn lint_overlapping_range_endpoints<'a, 'p: 'a, 'tcx: 'a>(\n         &self,\n-        pcx: PatCtxt<'_, '_, 'tcx>,\n-        ctors: impl Iterator<Item = (&'a Constructor<'tcx>, Span)>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pats: impl Iterator<Item = &'a DeconstructedPat<'p, 'tcx>>,\n         column_count: usize,\n         hir_id: HirId,\n     ) {\n@@ -248,8 +272,8 @@ impl IntRange {\n             return;\n         }\n \n-        let overlaps: Vec<_> = ctors\n-            .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)))\n+        let overlaps: Vec<_> = pats\n+            .filter_map(|pat| Some((pat.ctor().as_int_range()?, pat.span())))\n             .filter(|(range, _)| self.suspicious_intersection(range))\n             .map(|(range, span)| (self.intersection(&range).unwrap(), span))\n             .collect();\n@@ -291,6 +315,19 @@ impl IntRange {\n     }\n }\n \n+/// Note: this is often not what we want: e.g. `false` is converted into the range `0..=0` and\n+/// would be displayed as such. To render properly, convert to a pattern first.\n+impl fmt::Debug for IntRange {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let (lo, hi) = self.boundaries();\n+        let bias = self.bias;\n+        let (lo, hi) = (lo ^ bias, hi ^ bias);\n+        write!(f, \"{}\", lo)?;\n+        write!(f, \"{}\", RangeEnd::Included)?;\n+        write!(f, \"{}\", hi)\n+    }\n+}\n+\n /// Represents a border between 2 integers. Because the intervals spanning borders must be able to\n /// cover every integer, we need to be able to represent 2^128 + 1 such borders.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n@@ -375,13 +412,13 @@ impl SplitIntRange {\n             // Skip duplicates.\n             .filter(|(prev_border, border)| prev_border != border)\n             // Finally, convert to ranges.\n-            .map(|(prev_border, border)| {\n+            .map(move |(prev_border, border)| {\n                 let range = match (prev_border, border) {\n                     (JustBefore(n), JustBefore(m)) if n < m => n..=(m - 1),\n                     (JustBefore(n), AfterMax) => n..=u128::MAX,\n                     _ => unreachable!(), // Ruled out by the sorting and filtering we did\n                 };\n-                IntRange { range }\n+                IntRange { range, bias: self.range.bias }\n             })\n     }\n }\n@@ -611,6 +648,8 @@ pub(super) enum Constructor<'tcx> {\n     Missing { nonexhaustive_enum_missing_real_variants: bool },\n     /// Wildcard pattern.\n     Wildcard,\n+    /// Or-pattern.\n+    Or,\n }\n \n impl<'tcx> Constructor<'tcx> {\n@@ -647,61 +686,34 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n-    /// Determines the constructor that the given pattern can be specialized to.\n-    pub(super) fn from_pat<'p>(cx: &MatchCheckCtxt<'p, 'tcx>, pat: &'p Pat<'tcx>) -> Self {\n-        match pat.kind.as_ref() {\n-            PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n-            PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n-            PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n-            &PatKind::Variant { variant_index, .. } => Variant(variant_index),\n-            PatKind::Constant { value } => {\n-                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value) {\n-                    IntRange(int_range)\n-                } else {\n-                    match pat.ty.kind() {\n-                        ty::Float(_) => FloatRange(value, value, RangeEnd::Included),\n-                        // We make `&str` constants behave like `Deref` patterns, to be compatible\n-                        // with other `Deref` patterns. See also `Fields::extract_pattern_arguments`.\n-                        ty::Ref(_, t, _) if t.is_str() => Single,\n-                        // In truth this carries a constant of type `&str`.\n-                        ty::Str => Str(value),\n-                        // All constants that can be structurally matched have already been expanded\n-                        // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n-                        // opaque.\n-                        _ => Opaque,\n+    /// The number of fields for this constructor. This must be kept in sync with\n+    /// `Fields::wildcards`.\n+    pub(super) fn arity(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> usize {\n+        match self {\n+            Single | Variant(_) => match pcx.ty.kind() {\n+                ty::Tuple(fs) => fs.len(),\n+                ty::Ref(..) => 1,\n+                ty::Adt(adt, ..) => {\n+                    if adt.is_box() {\n+                        // The only legal patterns of type `Box` (outside `std`) are `_` and box\n+                        // patterns. If we're here we can assume this is a box pattern.\n+                        1\n+                    } else {\n+                        let variant = &adt.variants[self.variant_index_for_adt(adt)];\n+                        Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant).count()\n                     }\n                 }\n-            }\n-            &PatKind::Range(PatRange { lo, hi, end }) => {\n-                let ty = lo.ty;\n-                if let Some(int_range) = IntRange::from_range(\n-                    cx.tcx,\n-                    lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n-                    hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n-                    ty,\n-                    &end,\n-                ) {\n-                    IntRange(int_range)\n-                } else {\n-                    FloatRange(lo, hi, end)\n-                }\n-            }\n-            PatKind::Array { prefix, slice, suffix } | PatKind::Slice { prefix, slice, suffix } => {\n-                let array_len = match pat.ty.kind() {\n-                    ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env) as usize),\n-                    ty::Slice(_) => None,\n-                    _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n-                };\n-                let prefix = prefix.len();\n-                let suffix = suffix.len();\n-                let kind = if slice.is_some() {\n-                    VarLen(prefix, suffix)\n-                } else {\n-                    FixedLen(prefix + suffix)\n-                };\n-                Slice(Slice::new(array_len, kind))\n-            }\n-            PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n+                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", pcx.ty),\n+            },\n+            Slice(slice) => slice.arity(),\n+            Str(..)\n+            | FloatRange(..)\n+            | IntRange(..)\n+            | NonExhaustive\n+            | Opaque\n+            | Missing { .. }\n+            | Wildcard => 0,\n+            Or => bug!(\"The `Or` constructor doesn't have a fixed arity\"),\n         }\n     }\n \n@@ -824,7 +836,7 @@ impl<'tcx> Constructor<'tcx> {\n         match self {\n             // If `self` is `Single`, `used_ctors` cannot contain anything else than `Single`s.\n             Single => !used_ctors.is_empty(),\n-            Variant(_) => used_ctors.iter().any(|c| c == self),\n+            Variant(vid) => used_ctors.iter().any(|c| matches!(c, Variant(i) if i == vid)),\n             IntRange(range) => used_ctors\n                 .iter()\n                 .filter_map(|c| c.as_int_range())\n@@ -835,7 +847,7 @@ impl<'tcx> Constructor<'tcx> {\n                 .any(|other| slice.is_covered_by(other)),\n             // This constructor is never covered by anything else\n             NonExhaustive => false,\n-            Str(..) | FloatRange(..) | Opaque | Missing { .. } | Wildcard => {\n+            Str(..) | FloatRange(..) | Opaque | Missing { .. } | Wildcard | Or => {\n                 span_bug!(pcx.span, \"found unexpected ctor in all_ctors: {:?}\", self)\n             }\n         }\n@@ -1097,27 +1109,38 @@ impl<'tcx> SplitWildcard<'tcx> {\n /// `index_with_declared_idx`.\n #[derive(Debug, Clone)]\n pub(super) struct Fields<'p, 'tcx> {\n-    fields: SmallVec<[&'p Pat<'tcx>; 2]>,\n+    fields: SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]>,\n }\n \n impl<'p, 'tcx> Fields<'p, 'tcx> {\n     fn empty() -> Self {\n         Fields { fields: SmallVec::new() }\n     }\n \n-    fn from_iter(\n+    fn singleton(cx: &MatchCheckCtxt<'p, 'tcx>, field: DeconstructedPat<'p, 'tcx>) -> Self {\n+        let field: &_ = cx.pattern_arena.alloc(field);\n+        Fields { fields: smallvec![field] }\n+    }\n+\n+    pub(super) fn from_iter(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n-        fields: impl IntoIterator<Item = Pat<'tcx>>,\n+        fields: impl IntoIterator<Item = DeconstructedPat<'p, 'tcx>>,\n     ) -> Self {\n         let fields: &_ = cx.pattern_arena.alloc_from_iter(fields);\n-        Fields { fields: fields.iter().collect() }\n+        Fields { fields: fields.into_iter().collect() }\n+    }\n+\n+    pub(super) fn from_ref_iter(\n+        fields: impl IntoIterator<Item = &'p DeconstructedPat<'p, 'tcx>>,\n+    ) -> Self {\n+        Fields { fields: fields.into_iter().collect() }\n     }\n \n     fn wildcards_from_tys(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         tys: impl IntoIterator<Item = Ty<'tcx>>,\n     ) -> Self {\n-        Fields::from_iter(cx, tys.into_iter().map(Pat::wildcard_from_ty))\n+        Fields::from_iter(cx, tys.into_iter().map(DeconstructedPat::wildcard))\n     }\n \n     // In the cases of either a `#[non_exhaustive]` field list or a non-public field, we hide\n@@ -1148,23 +1171,21 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         })\n     }\n \n-    /// Creates a new list of wildcard fields for a given constructor.\n+    /// Creates a new list of wildcard fields for a given constructor. The result must have a\n+    /// length of `constructor.arity()`.\n     pub(super) fn wildcards(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         ty: Ty<'tcx>,\n         constructor: &Constructor<'tcx>,\n     ) -> Self {\n         let ret = match constructor {\n             Single | Variant(_) => match ty.kind() {\n-                ty::Tuple(ref fs) => {\n-                    Fields::wildcards_from_tys(cx, fs.into_iter().map(|ty| ty.expect_ty()))\n-                }\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(cx, fs.iter().map(|ty| ty.expect_ty())),\n                 ty::Ref(_, rty, _) => Fields::wildcards_from_tys(cx, once(*rty)),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n-                        // Use T as the sub pattern type of Box<T>.\n-                        // FIXME(Nadrieril): This is to make box-patterns work even though `Box` is\n-                        // actually a struct with 2 private fields. Hacky.\n+                        // The only legal patterns of type `Box` (outside `std`) are `_` and box\n+                        // patterns. If we're here we can assume this is a box pattern.\n                         Fields::wildcards_from_tys(cx, once(substs.type_at(0)))\n                     } else {\n                         let variant = &adt.variants[constructor.variant_index_for_adt(adt)];\n@@ -1189,47 +1210,193 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n             | Opaque\n             | Missing { .. }\n             | Wildcard => Fields::empty(),\n+            Or => {\n+                bug!(\"called `Fields::wildcards` on an `Or` ctor\")\n+            }\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n     }\n \n-    /// Returns the number of patterns. This is the same as the arity of the constructor used to\n-    /// construct `self`.\n-    pub(super) fn len(&self) -> usize {\n-        self.fields.len()\n-    }\n-\n     /// Returns the list of patterns.\n     pub(super) fn iter_patterns<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = &'p Pat<'tcx>> + Captures<'a> {\n+    ) -> impl Iterator<Item = &'p DeconstructedPat<'p, 'tcx>> + Captures<'a> {\n         self.fields.iter().copied()\n     }\n+}\n \n-    /// Apply a constructor to a list of patterns, yielding a new pattern. `self`\n-    /// must have as many elements as this constructor's arity.\n-    ///\n-    /// This is roughly the inverse of `specialize_constructor`.\n-    ///\n-    /// Examples:\n-    ///\n-    /// ```text\n-    /// ctor: `Constructor::Single`\n-    /// ty: `Foo(u32, u32, u32)`\n-    /// self: `[10, 20, _]`\n-    /// returns `Foo(10, 20, _)`\n-    ///\n-    /// ctor: `Constructor::Variant(Option::Some)`\n-    /// ty: `Option<bool>`\n-    /// self: `[false]`\n-    /// returns `Some(false)`\n-    /// ```\n-    pub(super) fn apply(self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Pat<'tcx> {\n-        let mut subpatterns = self.iter_patterns().cloned();\n-\n-        let pat = match ctor {\n-            Single | Variant(_) => match pcx.ty.kind() {\n+#[derive(Clone)]\n+pub(crate) struct DeconstructedPat<'p, 'tcx> {\n+    ctor: Constructor<'tcx>,\n+    fields: Fields<'p, 'tcx>,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+}\n+\n+impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n+    pub(super) fn wildcard(ty: Ty<'tcx>) -> Self {\n+        Self::new(Wildcard, Fields::empty(), ty)\n+    }\n+\n+    pub(super) fn new(ctor: Constructor<'tcx>, fields: Fields<'p, 'tcx>, ty: Ty<'tcx>) -> Self {\n+        DeconstructedPat { ctor, fields, ty, span: DUMMY_SP }\n+    }\n+\n+    pub(crate) fn from_pat(cx: &MatchCheckCtxt<'p, 'tcx>, pat: &Pat<'tcx>) -> Self {\n+        let mkpat = |pat| DeconstructedPat::from_pat(cx, pat);\n+        let allocpat = |pat| &*cx.pattern_arena.alloc(mkpat(pat));\n+        let ctor;\n+        let mut fields;\n+        match pat.kind.as_ref() {\n+            PatKind::AscribeUserType { subpattern, .. } => return mkpat(subpattern),\n+            PatKind::Binding { subpattern: Some(subpat), .. } => return mkpat(subpat),\n+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild => {\n+                ctor = Wildcard;\n+                fields = Fields::empty();\n+            }\n+            PatKind::Deref { subpattern } => {\n+                ctor = Single;\n+                fields = Fields::singleton(cx, mkpat(subpattern));\n+            }\n+            PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n+                match pat.ty.kind() {\n+                    ty::Tuple(fs) => {\n+                        ctor = Single;\n+                        fields = Fields::wildcards_from_tys(cx, fs.iter().map(|ty| ty.expect_ty()));\n+                        for pat in subpatterns {\n+                            fields.fields[pat.field.index()] = allocpat(&pat.pattern);\n+                        }\n+                    }\n+                    ty::Adt(adt, substs) if adt.is_box() => {\n+                        // The only legal patterns of type `Box` (outside `std`) are `_` and box\n+                        // patterns. If we're here we can assume this is a box pattern.\n+                        // FIXME(Nadrieril): A `Box` can in theory be matched either with `Box(_,\n+                        // _)` or a box pattern. As a hack to avoid an ICE with the former, we\n+                        // ignore other fields than the first one. This will trigger an error later\n+                        // anyway.\n+                        // See https://github.com/rust-lang/rust/issues/82772 ,\n+                        // explanation: https://github.com/rust-lang/rust/pull/82789#issuecomment-796921977\n+                        // The problem is that we can't know from the type whether we'll match\n+                        // normally or through box-patterns. We'll have to figure out a proper\n+                        // solution when we introduce generalized deref patterns. Also need to\n+                        // prevent mixing of those two options.\n+                        let pat = subpatterns.into_iter().find(|pat| pat.field.index() == 0);\n+                        let pat = if let Some(pat) = pat {\n+                            mkpat(&pat.pattern)\n+                        } else {\n+                            DeconstructedPat::wildcard(substs.type_at(0))\n+                        };\n+                        ctor = Single;\n+                        fields = Fields::singleton(cx, pat);\n+                    }\n+                    ty::Adt(adt, _) => {\n+                        ctor = match pat.kind.as_ref() {\n+                            PatKind::Leaf { .. } => Single,\n+                            PatKind::Variant { variant_index, .. } => Variant(*variant_index),\n+                            _ => bug!(),\n+                        };\n+                        let variant = &adt.variants[ctor.variant_index_for_adt(adt)];\n+                        // For each field in the variant, we store the relevant index into `self.fields` if any.\n+                        let mut field_id_to_id: Vec<Option<usize>> =\n+                            (0..variant.fields.len()).map(|_| None).collect();\n+                        let tys = Fields::list_variant_nonhidden_fields(cx, pat.ty, variant)\n+                            .enumerate()\n+                            .map(|(i, (field, ty))| {\n+                                field_id_to_id[field.index()] = Some(i);\n+                                ty\n+                            });\n+                        fields = Fields::wildcards_from_tys(cx, tys);\n+                        for pat in subpatterns {\n+                            if let Some(i) = field_id_to_id[pat.field.index()] {\n+                                fields.fields[i] = allocpat(&pat.pattern);\n+                            }\n+                        }\n+                    }\n+                    _ => bug!(\"pattern has unexpected type: pat: {:?}, ty: {:?}\", pat, pat.ty),\n+                }\n+            }\n+            PatKind::Constant { value } => {\n+                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value) {\n+                    ctor = IntRange(int_range);\n+                    fields = Fields::empty();\n+                } else {\n+                    match pat.ty.kind() {\n+                        ty::Float(_) => {\n+                            ctor = FloatRange(value, value, RangeEnd::Included);\n+                            fields = Fields::empty();\n+                        }\n+                        ty::Ref(_, t, _) if t.is_str() => {\n+                            // We want a `&str` constant to behave like a `Deref` pattern, to be compatible\n+                            // with other `Deref` patterns. This could have been done in `const_to_pat`,\n+                            // but that causes issues with the rest of the matching code.\n+                            // So here, the constructor for a `\"foo\"` pattern is `&` (represented by\n+                            // `Single`), and has one field. That field has constructor `Str(value)` and no\n+                            // fields.\n+                            let subpattern = DeconstructedPat {\n+                                ctor: Str(value),\n+                                fields: Fields::empty(),\n+                                ty: t, // `t` is `str`, not `&str`\n+                                span: pat.span,\n+                            };\n+                            ctor = Single;\n+                            fields = Fields::singleton(cx, subpattern)\n+                        }\n+                        // All constants that can be structurally matched have already been expanded\n+                        // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n+                        // opaque.\n+                        _ => {\n+                            ctor = Opaque;\n+                            fields = Fields::empty();\n+                        }\n+                    }\n+                }\n+            }\n+            &PatKind::Range(PatRange { lo, hi, end }) => {\n+                let ty = lo.ty;\n+                ctor = if let Some(int_range) = IntRange::from_range(\n+                    cx.tcx,\n+                    lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n+                    hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n+                    ty,\n+                    &end,\n+                ) {\n+                    IntRange(int_range)\n+                } else {\n+                    FloatRange(lo, hi, end)\n+                };\n+                fields = Fields::empty();\n+            }\n+            PatKind::Array { prefix, slice, suffix } | PatKind::Slice { prefix, slice, suffix } => {\n+                let array_len = match pat.ty.kind() {\n+                    ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env) as usize),\n+                    ty::Slice(_) => None,\n+                    _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n+                };\n+                let kind = if slice.is_some() {\n+                    VarLen(prefix.len(), suffix.len())\n+                } else {\n+                    FixedLen(prefix.len() + suffix.len())\n+                };\n+                ctor = Slice(Slice::new(array_len, kind));\n+                fields = Fields::from_iter(cx, prefix.iter().chain(suffix).map(mkpat));\n+            }\n+            PatKind::Or { .. } => {\n+                ctor = Or;\n+                let pats = expand_or_pat(pat);\n+                fields = Fields::from_iter(cx, pats.into_iter().map(mkpat));\n+            }\n+        }\n+        DeconstructedPat { ctor, fields, ty: pat.ty, span: pat.span }\n+    }\n+\n+    pub(crate) fn to_pat(&self, cx: &MatchCheckCtxt<'p, 'tcx>) -> Pat<'tcx> {\n+        let is_wildcard = |pat: &Pat<'_>| {\n+            matches!(*pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n+        };\n+        let mut subpatterns = self.iter_fields().map(|p| p.to_pat(cx));\n+        let pat = match &self.ctor {\n+            Single | Variant(_) => match self.ty.kind() {\n                 ty::Tuple(..) => PatKind::Leaf {\n                     subpatterns: subpatterns\n                         .enumerate()\n@@ -1242,173 +1409,239 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                     // the pattern is a box pattern.\n                     PatKind::Deref { subpattern: subpatterns.next().unwrap() }\n                 }\n-                ty::Adt(adt, substs) => {\n-                    let variant_index = ctor.variant_index_for_adt(adt);\n-                    let variant = &adt.variants[variant_index];\n-                    let subpatterns =\n-                        Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant)\n-                            .zip(subpatterns)\n-                            .map(|((field, _ty), pattern)| FieldPat { field, pattern })\n-                            .collect();\n-\n-                    if adt.is_enum() {\n-                        PatKind::Variant {\n-                            adt_def: adt,\n-                            substs,\n-                            variant_index: ctor.variant_index_for_adt(adt),\n-                            subpatterns,\n-                        }\n+                ty::Adt(adt_def, substs) => {\n+                    let variant_index = self.ctor.variant_index_for_adt(adt_def);\n+                    let variant = &adt_def.variants[variant_index];\n+                    let subpatterns = Fields::list_variant_nonhidden_fields(cx, self.ty, variant)\n+                        .zip(subpatterns)\n+                        .map(|((field, _ty), pattern)| FieldPat { field, pattern })\n+                        .collect();\n+\n+                    if adt_def.is_enum() {\n+                        PatKind::Variant { adt_def, substs, variant_index, subpatterns }\n                     } else {\n                         PatKind::Leaf { subpatterns }\n                     }\n                 }\n                 // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n                 // be careful to reconstruct the correct constant pattern here. However a string\n                 // literal pattern will never be reported as a non-exhaustiveness witness, so we\n-                // can ignore this issue.\n+                // ignore this issue.\n                 ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n-                _ => bug!(\"unexpected ctor for type {:?} {:?}\", ctor, pcx.ty),\n+                _ => bug!(\"unexpected ctor for type {:?} {:?}\", self.ctor, self.ty),\n             },\n-            Slice(slice) => match slice.kind {\n-                FixedLen(_) => {\n-                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-                }\n-                VarLen(prefix, _) => {\n-                    let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix).collect();\n-                    if slice.array_len.is_some() {\n-                        // Improves diagnostics a bit: if the type is a known-size array, instead\n-                        // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n-                        // This is incorrect if the size is not known, since `[_, ..]` captures\n-                        // arrays of lengths `>= 1` whereas `[..]` captures any length.\n-                        while !prefix.is_empty() && is_wildcard(prefix.last().unwrap()) {\n-                            prefix.pop();\n+            Slice(slice) => {\n+                match slice.kind {\n+                    FixedLen(_) => PatKind::Slice {\n+                        prefix: subpatterns.collect(),\n+                        slice: None,\n+                        suffix: vec![],\n+                    },\n+                    VarLen(prefix, _) => {\n+                        let mut subpatterns = subpatterns.peekable();\n+                        let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix).collect();\n+                        if slice.array_len.is_some() {\n+                            // Improves diagnostics a bit: if the type is a known-size array, instead\n+                            // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n+                            // This is incorrect if the size is not known, since `[_, ..]` captures\n+                            // arrays of lengths `>= 1` whereas `[..]` captures any length.\n+                            while !prefix.is_empty() && is_wildcard(prefix.last().unwrap()) {\n+                                prefix.pop();\n+                            }\n+                            while subpatterns.peek().is_some()\n+                                && is_wildcard(subpatterns.peek().unwrap())\n+                            {\n+                                subpatterns.next();\n+                            }\n                         }\n+                        let suffix: Vec<_> = subpatterns.collect();\n+                        let wild = Pat::wildcard_from_ty(self.ty);\n+                        PatKind::Slice { prefix, slice: Some(wild), suffix }\n                     }\n-                    let suffix: Vec<_> = if slice.array_len.is_some() {\n-                        // Same as above.\n-                        subpatterns.skip_while(is_wildcard).collect()\n-                    } else {\n-                        subpatterns.collect()\n-                    };\n-                    let wild = Pat::wildcard_from_ty(pcx.ty);\n-                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n                 }\n-            },\n+            }\n             &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n-            IntRange(range) => return range.to_pat(pcx.cx.tcx, pcx.ty),\n-            NonExhaustive => PatKind::Wild,\n-            Wildcard => return Pat::wildcard_from_ty(pcx.ty),\n-            Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n+            IntRange(range) => return range.to_pat(cx.tcx, self.ty),\n+            Wildcard | NonExhaustive => PatKind::Wild,\n             Missing { .. } => bug!(\n-                \"trying to apply the `Missing` constructor; this should have been done in `apply_constructors`\"\n+                \"trying to convert a `Missing` constructor into a `Pat`; this is probably a bug,\n+                `Missing` should have been processed in `apply_constructors`\"\n             ),\n+            Opaque | Or => {\n+                bug!(\"can't convert to pattern: {:?}\", self)\n+            }\n         };\n \n-        Pat { ty: pcx.ty, span: DUMMY_SP, kind: Box::new(pat) }\n+        Pat { ty: self.ty, span: DUMMY_SP, kind: Box::new(pat) }\n     }\n \n-    /// Replaces contained fields with the given list of patterns. There must be `len()` patterns\n-    /// in `pats`.\n-    pub(super) fn replace_fields(\n-        self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        pats: impl IntoIterator<Item = Pat<'tcx>>,\n-    ) -> Self {\n-        Self::from_iter(cx, pats)\n+    /// Construct a pattern that matches everything that starts with this constructor.\n+    // For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n+    // `Some(_)`.\n+    pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n+        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n+        DeconstructedPat::new(ctor, fields, pcx.ty)\n+    }\n+\n+    pub(super) fn is_or_pat(&self) -> bool {\n+        matches!(self.ctor, Or)\n+    }\n+\n+    pub(super) fn ctor(&self) -> &Constructor<'tcx> {\n+        &self.ctor\n+    }\n+    pub(super) fn ty(&self) -> Ty<'tcx> {\n+        self.ty\n+    }\n+    pub(super) fn span(&self) -> Span {\n+        self.span\n     }\n \n-    /// Replaces contained fields with the arguments of the given pattern. Only use on a pattern\n-    /// that is compatible with the constructor used to build `self`.\n-    /// This is meant to be used on the result of `Fields::wildcards()`. See the comment above\n-    /// `Fields` for details\n-    /// This is guaranteed to preserve the number of patterns in `self`.\n-    pub(super) fn extract_pattern_arguments(\n-        mut self,\n+    pub(super) fn iter_fields<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = &'p DeconstructedPat<'p, 'tcx>> + Captures<'a> {\n+        self.fields.iter_patterns()\n+    }\n+\n+    /// Specialize this pattern with a constructor.\n+    /// `other_ctor` can be different from `self.ctor`, but must be covered by it.\n+    pub(super) fn specialize<'a>(\n+        &'a self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n-        pat: &'p Pat<'tcx>,\n-    ) -> Self {\n-        match pat.kind.as_ref() {\n-            PatKind::Deref { subpattern } => {\n-                assert_eq!(self.len(), 1);\n-                self.fields[0] = subpattern;\n+        other_ctor: &Constructor<'tcx>,\n+    ) -> Cow<'a, Fields<'p, 'tcx>> {\n+        match (&self.ctor, other_ctor) {\n+            (Wildcard, _) => {\n+                // We return a wildcard for each field of `other_ctor`.\n+                Cow::Owned(Fields::wildcards(cx, self.ty, other_ctor))\n             }\n-            PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n-                match pat.ty.kind() {\n-                    ty::Adt(adt, _) if adt.is_box() => {\n-                        // FIXME(Nadrieril): A `Box` can in theory be matched either with `Box(_,\n-                        // _)` or a box pattern. As a hack to avoid an ICE with the former, we\n-                        // ignore other fields than the first one. This will trigger an error later\n-                        // anyway.\n-                        // See https://github.com/rust-lang/rust/issues/82772 ,\n-                        // explanation: https://github.com/rust-lang/rust/pull/82789#issuecomment-796921977\n-                        // The problem is that we can't know from the type whether we'll match\n-                        // normally or through box-patterns. We'll have to figure out a proper\n-                        // solution when we introduce generalized deref patterns. Also need to\n-                        // prevent mixing of those two options.\n-                        assert_eq!(self.len(), 1);\n-                        let pat = subpatterns.into_iter().find(|pat| pat.field.index() == 0);\n-                        if let Some(pat) = pat {\n-                            self.fields[0] = &pat.pattern;\n-                        }\n-                    }\n-                    ty::Adt(adt, _) => {\n-                        let variant_index = match pat.kind.as_ref() {\n-                            PatKind::Leaf { .. } => VariantIdx::new(0),\n-                            PatKind::Variant { variant_index, .. } => *variant_index,\n-                            _ => bug!(),\n+            (Slice(self_slice), Slice(other_slice))\n+                if self_slice.arity() != other_slice.arity() =>\n+            {\n+                // The only tricky case: two slices of different arity. Since `self_slice` covers\n+                // `other_slice`, `self_slice` must be `VarLen`, i.e. of the form\n+                // `[prefix, .., suffix]`. Moreover `other_slice` is guaranteed to have a larger\n+                // arity. We fill the middle part with enough wildcards to reach the length of the\n+                // new, larger slice.\n+                match self_slice.kind {\n+                    FixedLen(_) => bug!(\"{:?} doesn't cover {:?}\", self_slice, other_slice),\n+                    VarLen(prefix, suffix) => {\n+                        let inner_ty = match *self.ty.kind() {\n+                            ty::Slice(ty) | ty::Array(ty, _) => ty,\n+                            _ => bug!(\"bad slice pattern {:?} {:?}\", self.ctor, self.ty),\n                         };\n-                        let variant = &adt.variants[variant_index];\n-                        // For each field in the variant, we store the relevant index into `self.fields` if any.\n-                        let mut field_id_to_id: Vec<Option<usize>> =\n-                            (0..variant.fields.len()).map(|_| None).collect();\n-                        for (i, (field, _ty)) in\n-                            Fields::list_variant_nonhidden_fields(cx, pat.ty, variant).enumerate()\n-                        {\n-                            field_id_to_id[field.index()] = Some(i);\n+                        let prefix = self.fields.fields[..prefix].iter().copied();\n+                        let suffix =\n+                            self.fields.fields[self_slice.arity() - suffix..].iter().copied();\n+                        let extra_wildcards = other_slice.arity() - self_slice.arity();\n+                        let extra_wildcards: &[_] = cx.pattern_arena.alloc_from_iter(\n+                            (0..extra_wildcards).map(|_| DeconstructedPat::wildcard(inner_ty)),\n+                        );\n+                        let fields = prefix.chain(extra_wildcards).chain(suffix);\n+                        Cow::Owned(Fields::from_ref_iter(fields))\n+                    }\n+                }\n+            }\n+            _ => Cow::Borrowed(&self.fields),\n+        }\n+    }\n+}\n+\n+/// This is mostly copied from the `Pat` impl. This is best effort and not good enough for a\n+/// `Display` impl.\n+impl<'p, 'tcx> fmt::Debug for DeconstructedPat<'p, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Printing lists is a chore.\n+        let mut first = true;\n+        let mut start_or_continue = |s| {\n+            if first {\n+                first = false;\n+                \"\"\n+            } else {\n+                s\n+            }\n+        };\n+        let mut start_or_comma = || start_or_continue(\", \");\n+\n+        match &self.ctor {\n+            Single | Variant(_) => match self.ty.kind() {\n+                ty::Adt(def, _) if def.is_box() => {\n+                    // Without `box_patterns`, the only legal pattern of type `Box` is `_` (outside\n+                    // of `std`). So this branch is only reachable when the feature is enabled and\n+                    // the pattern is a box pattern.\n+                    let subpattern = self.iter_fields().next().unwrap();\n+                    write!(f, \"box {:?}\", subpattern)\n+                }\n+                ty::Adt(..) | ty::Tuple(..) => {\n+                    let variant = match self.ty.kind() {\n+                        ty::Adt(adt, _) => {\n+                            Some(&adt.variants[self.ctor.variant_index_for_adt(adt)])\n                         }\n-                        for pat in subpatterns {\n-                            if let Some(i) = field_id_to_id[pat.field.index()] {\n-                                self.fields[i] = &pat.pattern;\n-                            }\n+                        ty::Tuple(_) => None,\n+                        _ => unreachable!(),\n+                    };\n+\n+                    if let Some(variant) = variant {\n+                        write!(f, \"{}\", variant.ident)?;\n+                    }\n+\n+                    // Without `cx`, we can't know which field corresponds to which, so we can't\n+                    // get the names of the fields. Instead we just display everything as a suple\n+                    // struct, which should be good enough.\n+                    write!(f, \"(\")?;\n+                    for p in self.iter_fields() {\n+                        write!(f, \"{}\", start_or_comma())?;\n+                        write!(f, \"{:?}\", p)?;\n+                    }\n+                    write!(f, \")\")\n+                }\n+                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n+                // be careful to detect strings here. However a string literal pattern will never\n+                // be reported as a non-exhaustiveness witness, so we can ignore this issue.\n+                ty::Ref(_, _, mutbl) => {\n+                    let subpattern = self.iter_fields().next().unwrap();\n+                    write!(f, \"&{}{:?}\", mutbl.prefix_str(), subpattern)\n+                }\n+                _ => write!(f, \"_\"),\n+            },\n+            Slice(slice) => {\n+                let mut subpatterns = self.fields.iter_patterns();\n+                write!(f, \"[\")?;\n+                match slice.kind {\n+                    FixedLen(_) => {\n+                        for p in subpatterns {\n+                            write!(f, \"{}{:?}\", start_or_comma(), p)?;\n                         }\n                     }\n-                    _ => {\n-                        for pat in subpatterns {\n-                            self.fields[pat.field.index()] = &pat.pattern;\n+                    VarLen(prefix_len, _) => {\n+                        for p in subpatterns.by_ref().take(prefix_len) {\n+                            write!(f, \"{}{:?}\", start_or_comma(), p)?;\n+                        }\n+                        write!(f, \"{}\", start_or_comma())?;\n+                        write!(f, \"..\")?;\n+                        for p in subpatterns {\n+                            write!(f, \"{}{:?}\", start_or_comma(), p)?;\n                         }\n                     }\n                 }\n+                write!(f, \"]\")\n             }\n-            PatKind::Array { prefix, suffix, .. } | PatKind::Slice { prefix, suffix, .. } => {\n-                // Number of subpatterns for the constructor\n-                let ctor_arity = self.len();\n-\n-                // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n-                // the middle if there was a subslice pattern `..`.\n-                let prefix = prefix.iter().enumerate();\n-                let suffix =\n-                    suffix.iter().enumerate().map(|(i, p)| (ctor_arity - suffix.len() + i, p));\n-\n-                for (i, pat) in prefix.chain(suffix) {\n-                    self.fields[i] = pat\n-                }\n+            &FloatRange(lo, hi, end) => {\n+                write!(f, \"{}\", lo)?;\n+                write!(f, \"{}\", end)?;\n+                write!(f, \"{}\", hi)\n             }\n-            PatKind::Constant { .. } => match pat.ty.kind() {\n-                ty::Ref(_, t, _) if t.is_str() => {\n-                    assert_eq!(self.len(), 1);\n-                    // We want a `&str` constant to behave like a `Deref` pattern, to be compatible\n-                    // with other `Deref` patterns. This could have been done in `const_to_pat`,\n-                    // but that causes issues with the rest of the matching code.\n-                    // The outer constructor is `&`, and the inner one carries the str value.\n-                    let mut new_pat = pat.clone();\n-                    new_pat.ty = t; // `t` is `str`, not `&str`\n-                    self.fields[0] = &*cx.pattern_arena.alloc(new_pat);\n+            IntRange(range) => write!(f, \"{:?}\", range), // Best-effort, will render e.g. `false` as `0..=0`\n+            Wildcard | Missing { .. } | NonExhaustive => write!(f, \"_\"),\n+            Or => {\n+                for pat in self.iter_fields() {\n+                    write!(f, \"{}{:?}\", start_or_continue(\" | \"), pat)?;\n                 }\n-                _ => {}\n-            },\n-            _ => {}\n-        };\n-        self\n+                Ok(())\n+            }\n+            Str(value) => write!(f, \"{}\", value),\n+            Opaque => write!(f, \"<constant pattern>\"),\n+        }\n     }\n }"}, {"sha": "1cadc4a0ba65eef803509a3aa2fcce5a47f2fb75", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 64, "deletions": 161, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/71abc9565f037c3c9da5814c23857545abb0aaab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71abc9565f037c3c9da5814c23857545abb0aaab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=71abc9565f037c3c9da5814c23857545abb0aaab", "patch": "@@ -284,27 +284,23 @@ use self::ArmType::*;\n use self::Usefulness::*;\n \n use super::check_match::{joined_uncovered_patterns, pattern_not_covered_label};\n-use super::deconstruct_pat::{Constructor, Fields, SplitWildcard};\n-use super::{PatternFoldable, PatternFolder};\n+use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n \n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n \n-use hir::def_id::DefId;\n-use hir::HirId;\n use rustc_arena::TypedArena;\n-use rustc_hir as hir;\n-use rustc_middle::thir::{Pat, PatKind};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n use std::fmt;\n use std::iter::IntoIterator;\n-use std::lazy::OnceCell;\n \n-crate struct MatchCheckCtxt<'a, 'tcx> {\n+crate struct MatchCheckCtxt<'p, 'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n@@ -313,7 +309,7 @@ crate struct MatchCheckCtxt<'a, 'tcx> {\n     /// outside its module and should not be matchable with an empty match statement.\n     crate module: DefId,\n     crate param_env: ty::ParamEnv<'tcx>,\n-    crate pattern_arena: &'a TypedArena<Pat<'tcx>>,\n+    crate pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -356,64 +352,20 @@ impl<'a, 'p, 'tcx> fmt::Debug for PatCtxt<'a, 'p, 'tcx> {\n     }\n }\n \n-crate fn expand_pattern<'tcx>(pat: Pat<'tcx>) -> Pat<'tcx> {\n-    LiteralExpander.fold_pattern(&pat)\n-}\n-\n-struct LiteralExpander;\n-\n-impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n-    fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n-        debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n-        match pat.kind.as_ref() {\n-            PatKind::Binding { subpattern: Some(s), .. } => s.fold_with(self),\n-            PatKind::AscribeUserType { subpattern: s, .. } => s.fold_with(self),\n-            _ => pat.super_fold_with(self),\n-        }\n-    }\n-}\n-\n-pub(super) fn is_wildcard(pat: &Pat<'_>) -> bool {\n-    matches!(*pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n-}\n-\n-fn is_or_pat(pat: &Pat<'_>) -> bool {\n-    matches!(*pat.kind, PatKind::Or { .. })\n-}\n-\n-/// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n-fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n-    fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n-        if let PatKind::Or { pats } = pat.kind.as_ref() {\n-            for pat in pats {\n-                expand(pat, vec);\n-            }\n-        } else {\n-            vec.push(pat)\n-        }\n-    }\n-\n-    let mut pats = Vec::new();\n-    expand(pat, &mut pats);\n-    pats\n-}\n-\n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n #[derive(Clone)]\n struct PatStack<'p, 'tcx> {\n-    pats: SmallVec<[&'p Pat<'tcx>; 2]>,\n-    /// Cache for the constructor of the head\n-    head_ctor: OnceCell<Constructor<'tcx>>,\n+    pats: SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]>,\n }\n \n impl<'p, 'tcx> PatStack<'p, 'tcx> {\n-    fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n+    fn from_pattern(pat: &'p DeconstructedPat<'p, 'tcx>) -> Self {\n         Self::from_vec(smallvec![pat])\n     }\n \n-    fn from_vec(vec: SmallVec<[&'p Pat<'tcx>; 2]>) -> Self {\n-        PatStack { pats: vec, head_ctor: OnceCell::new() }\n+    fn from_vec(vec: SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]>) -> Self {\n+        PatStack { pats: vec }\n     }\n \n     fn is_empty(&self) -> bool {\n@@ -424,30 +376,25 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         self.pats.len()\n     }\n \n-    fn head(&self) -> &'p Pat<'tcx> {\n+    fn head(&self) -> &'p DeconstructedPat<'p, 'tcx> {\n         self.pats[0]\n     }\n \n-    #[inline]\n-    fn head_ctor<'a>(&'a self, cx: &MatchCheckCtxt<'p, 'tcx>) -> &'a Constructor<'tcx> {\n-        self.head_ctor.get_or_init(|| Constructor::from_pat(cx, self.head()))\n-    }\n-\n-    fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {\n+    fn iter(&self) -> impl Iterator<Item = &DeconstructedPat<'p, 'tcx>> {\n         self.pats.iter().copied()\n     }\n \n     // Recursively expand the first pattern into its subpatterns. Only useful if the pattern is an\n     // or-pattern. Panics if `self` is empty.\n     fn expand_or_pat<'a>(&'a self) -> impl Iterator<Item = PatStack<'p, 'tcx>> + Captures<'a> {\n-        expand_or_pat(self.head()).into_iter().map(move |pat| {\n+        self.head().iter_fields().map(move |pat| {\n             let mut new_patstack = PatStack::from_pattern(pat);\n             new_patstack.pats.extend_from_slice(&self.pats[1..]);\n             new_patstack\n         })\n     }\n \n-    /// This computes `S(self.head_ctor(), self)`. See top of the file for explanations.\n+    /// This computes `S(self.head().ctor(), self)`. See top of the file for explanations.\n     ///\n     /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n     /// fields filled with wild patterns.\n@@ -456,45 +403,30 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     fn pop_head_constructor(\n         &self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n-        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+        ctor: &Constructor<'tcx>,\n     ) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields: SmallVec<[_; 2]> = ctor_wild_subpatterns\n-            .clone()\n-            .extract_pattern_arguments(cx, self.head())\n-            .iter_patterns()\n-            .collect();\n+        let mut new_fields: SmallVec<[_; 2]> =\n+            self.head().specialize(cx, ctor).iter_patterns().collect();\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n }\n \n-impl<'p, 'tcx> Default for PatStack<'p, 'tcx> {\n-    fn default() -> Self {\n-        Self::from_vec(smallvec![])\n-    }\n-}\n-\n-impl<'p, 'tcx> PartialEq for PatStack<'p, 'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.pats == other.pats\n-    }\n-}\n-\n /// Pretty-printing for matrix row.\n impl<'p, 'tcx> fmt::Debug for PatStack<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"+\")?;\n         for pat in self.iter() {\n-            write!(f, \" {} +\", pat)?;\n+            write!(f, \" {:?} +\", pat)?;\n         }\n         Ok(())\n     }\n }\n \n /// A 2D matrix.\n-#[derive(Clone, PartialEq)]\n+#[derive(Clone)]\n pub(super) struct Matrix<'p, 'tcx> {\n     patterns: Vec<PatStack<'p, 'tcx>>,\n }\n@@ -512,7 +444,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this recursively\n     /// expands it.\n     fn push(&mut self, row: PatStack<'p, 'tcx>) {\n-        if !row.is_empty() && is_or_pat(row.head()) {\n+        if !row.is_empty() && row.head().is_or_pat() {\n             for row in row.expand_or_pat() {\n                 self.patterns.push(row);\n             }\n@@ -522,37 +454,22 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     }\n \n     /// Iterate over the first component of each row\n-    fn heads<'a>(&'a self) -> impl Iterator<Item = &'a Pat<'tcx>> + Captures<'p> {\n-        self.patterns.iter().map(|r| r.head())\n-    }\n-\n-    /// Iterate over the first constructor of each row.\n-    pub(super) fn head_ctors<'a>(\n+    fn heads<'a>(\n         &'a self,\n-        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> + Clone {\n-        self.patterns.iter().map(move |r| r.head_ctor(cx))\n-    }\n-\n-    /// Iterate over the first constructor and the corresponding span of each row.\n-    pub(super) fn head_ctors_and_spans<'a>(\n-        &'a self,\n-        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    ) -> impl Iterator<Item = (&'a Constructor<'tcx>, Span)> + Captures<'p> {\n-        self.patterns.iter().map(move |r| (r.head_ctor(cx), r.head().span))\n+    ) -> impl Iterator<Item = &'p DeconstructedPat<'p, 'tcx>> + Clone + Captures<'a> {\n+        self.patterns.iter().map(|r| r.head())\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n         let mut matrix = Matrix::empty();\n         for row in &self.patterns {\n-            if ctor.is_covered_by(pcx, row.head_ctor(pcx.cx)) {\n-                let new_row = row.pop_head_constructor(pcx.cx, ctor_wild_subpatterns);\n+            if ctor.is_covered_by(pcx, row.head().ctor()) {\n+                let new_row = row.pop_head_constructor(pcx.cx, ctor);\n                 matrix.push(new_row);\n             }\n         }\n@@ -575,7 +492,7 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n \n         let Matrix { patterns: m, .. } = self;\n         let pretty_printed_matrix: Vec<Vec<String>> =\n-            m.iter().map(|row| row.iter().map(|pat| format!(\"{}\", pat)).collect()).collect();\n+            m.iter().map(|row| row.iter().map(|pat| format!(\"{:?}\", pat)).collect()).collect();\n \n         let column_count = m.iter().map(|row| row.len()).next().unwrap_or(0);\n         assert!(m.iter().all(|row| row.len() == column_count));\n@@ -791,7 +708,7 @@ impl SubPatSet {\n     }\n \n     /// When `self` refers to a patstack that was obtained from splitting an or-pattern, after\n-    /// running `unspecialize` it will refer to the original patstack before splitting.\n+    /// running `unsplit_or_pat` it will refer to the original patstack before splitting.\n     ///\n     /// For example:\n     /// ```\n@@ -839,7 +756,7 @@ impl SubPatSet {\n /// witnesses of non-exhaustiveness when there are any.\n /// Which variant to use is dictated by `ArmType`.\n #[derive(Clone, Debug)]\n-enum Usefulness<'tcx> {\n+enum Usefulness<'p, 'tcx> {\n     /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n     /// the whole pattern is unreachable. If not, this indicates that the pattern is reachable but\n     /// that some sub-patterns may be unreachable (due to or-patterns). In the absence of\n@@ -848,10 +765,10 @@ enum Usefulness<'tcx> {\n     NoWitnesses(SubPatSet),\n     /// Carries a list of witnesses of non-exhaustiveness. If empty, indicates that the whole\n     /// pattern is unreachable.\n-    WithWitnesses(Vec<Witness<'tcx>>),\n+    WithWitnesses(Vec<Witness<'p, 'tcx>>),\n }\n \n-impl<'tcx> Usefulness<'tcx> {\n+impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n     fn new_useful(preference: ArmType) -> Self {\n         match preference {\n             FakeExtraWildcard => WithWitnesses(vec![Witness(vec![])]),\n@@ -896,12 +813,11 @@ impl<'tcx> Usefulness<'tcx> {\n     /// After calculating usefulness after a specialization, call this to reconstruct a usefulness\n     /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n     /// with the results of specializing with the other constructors.\n-    fn apply_constructor<'p>(\n+    fn apply_constructor(\n         self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         matrix: &Matrix<'p, 'tcx>, // used to compute missing ctors\n         ctor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         match self {\n             WithWitnesses(witnesses) if witnesses.is_empty() => WithWitnesses(witnesses),\n@@ -912,23 +828,18 @@ impl<'tcx> Usefulness<'tcx> {\n                     let new_patterns = if pcx.is_non_exhaustive {\n                         // Here we don't want the user to try to list all variants, we want them to add\n                         // a wildcard, so we only suggest that.\n-                        vec![\n-                            Fields::wildcards(pcx.cx, pcx.ty, &Constructor::NonExhaustive)\n-                                .apply(pcx, &Constructor::NonExhaustive),\n-                        ]\n+                        vec![DeconstructedPat::wildcard(pcx.ty)]\n                     } else {\n                         let mut split_wildcard = SplitWildcard::new(pcx);\n-                        split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                        split_wildcard.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n                         // Construct for each missing constructor a \"wild\" version of this\n                         // constructor, that matches everything that can be built with\n                         // it. For example, if `ctor` is a `Constructor::Variant` for\n                         // `Option::Some`, we get the pattern `Some(_)`.\n                         split_wildcard\n                             .iter_missing(pcx)\n-                            .map(|missing_ctor| {\n-                                Fields::wildcards(pcx.cx, pcx.ty, missing_ctor)\n-                                    .apply(pcx, missing_ctor)\n-                            })\n+                            .cloned()\n+                            .map(|missing_ctor| DeconstructedPat::wild_from_ctor(pcx, missing_ctor))\n                             .collect()\n                     };\n \n@@ -945,12 +856,12 @@ impl<'tcx> Usefulness<'tcx> {\n                 } else {\n                     witnesses\n                         .into_iter()\n-                        .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n+                        .map(|witness| witness.apply_constructor(pcx, &ctor))\n                         .collect()\n                 };\n                 WithWitnesses(new_witnesses)\n             }\n-            NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor_wild_subpatterns.len())),\n+            NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor.arity(pcx))),\n         }\n     }\n }\n@@ -995,11 +906,11 @@ enum ArmType {\n ///\n /// The final `Pair(Some(_), true)` is then the resulting witness.\n #[derive(Clone, Debug)]\n-crate struct Witness<'tcx>(Vec<Pat<'tcx>>);\n+crate struct Witness<'p, 'tcx>(Vec<DeconstructedPat<'p, 'tcx>>);\n \n-impl<'tcx> Witness<'tcx> {\n+impl<'p, 'tcx> Witness<'p, 'tcx> {\n     /// Asserts that the witness contains a single pattern, and returns it.\n-    fn single_pattern(self) -> Pat<'tcx> {\n+    fn single_pattern(self) -> DeconstructedPat<'p, 'tcx> {\n         assert_eq!(self.0.len(), 1);\n         self.0.into_iter().next().unwrap()\n     }\n@@ -1017,17 +928,13 @@ impl<'tcx> Witness<'tcx> {\n     ///\n     /// left_ty: struct X { a: (bool, &'static str), b: usize}\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-    fn apply_constructor<'p>(\n-        mut self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        ctor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-    ) -> Self {\n+    fn apply_constructor(mut self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Self {\n         let pat = {\n             let len = self.0.len();\n-            let arity = ctor_wild_subpatterns.len();\n+            let arity = ctor.arity(pcx);\n             let pats = self.0.drain((len - arity)..).rev();\n-            ctor_wild_subpatterns.clone().replace_fields(pcx.cx, pats).apply(pcx, ctor)\n+            let fields = Fields::from_iter(pcx.cx, pats);\n+            DeconstructedPat::new(ctor.clone(), fields, pcx.ty)\n         };\n \n         self.0.push(pat);\n@@ -1045,9 +952,9 @@ fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n     hir_id: HirId,\n-    witnesses: Vec<Pat<'tcx>>,\n+    witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n ) {\n-    let joined_patterns = joined_uncovered_patterns(&witnesses);\n+    let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n     cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, |build| {\n         let mut lint = build.build(\"some variants are not matched explicitly\");\n         lint.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n@@ -1096,7 +1003,7 @@ fn is_useful<'p, 'tcx>(\n     hir_id: HirId,\n     is_under_guard: bool,\n     is_top_level: bool,\n-) -> Usefulness<'tcx> {\n+) -> Usefulness<'p, 'tcx> {\n     debug!(\"matrix,v={:?}{:?}\", matrix, v);\n     let Matrix { patterns: rows, .. } = matrix;\n \n@@ -1118,16 +1025,16 @@ fn is_useful<'p, 'tcx>(\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n-    let ty = matrix.heads().next().map_or(v.head().ty, |r| r.ty);\n+    let ty = matrix.heads().next().map_or(v.head().ty(), |r| r.ty());\n     let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n-    let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level, is_non_exhaustive };\n+    let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n \n     // If the first pattern is an or-pattern, expand it.\n     let mut ret = Usefulness::new_not_useful(witness_preference);\n-    if is_or_pat(v.head()) {\n+    if v.head().is_or_pat() {\n         debug!(\"expanding or-pattern\");\n+        let spans: Vec<_> = v.head().iter_fields().map(|pat| pat.span()).collect();\n         let vs: Vec<_> = v.expand_or_pat().collect();\n-        let spans: Vec<_> = vs.iter().map(|pat| pat.head().span).collect();\n         // We try each or-pattern branch in turn.\n         let mut matrix = matrix.clone();\n         for (i, v) in vs.into_iter().enumerate() {\n@@ -1143,33 +1050,30 @@ fn is_useful<'p, 'tcx>(\n             }\n         }\n     } else {\n-        let v_ctor = v.head_ctor(cx);\n+        let v_ctor = v.head().ctor();\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n             // Lint on likely incorrect range patterns (#63987)\n             ctor_range.lint_overlapping_range_endpoints(\n                 pcx,\n-                matrix.head_ctors_and_spans(cx),\n+                matrix.heads(),\n                 matrix.column_count().unwrap_or(0),\n                 hir_id,\n             )\n         }\n         // We split the head constructor of `v`.\n-        let split_ctors = v_ctor.split(pcx, matrix.head_ctors(cx));\n+        let split_ctors = v_ctor.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n         let is_non_exhaustive_and_wild = is_non_exhaustive && v_ctor.is_wildcard();\n         // For each constructor, we compute whether there's a value that starts with it that would\n         // witness the usefulness of `v`.\n         let start_matrix = &matrix;\n         for ctor in split_ctors {\n             debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n-            let ctor_wild_subpatterns = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n-            let spec_matrix =\n-                start_matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n-            let v = v.pop_head_constructor(cx, &ctor_wild_subpatterns);\n+            let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n+            let v = v.pop_head_constructor(cx, &ctor);\n             let usefulness =\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            let usefulness =\n-                usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns);\n+            let usefulness = usefulness.apply_constructor(pcx, start_matrix, &ctor);\n \n             // When all the conditions are met we have a match with a `non_exhaustive` enum\n             // that has the potential to trigger the `non_exhaustive_omitted_patterns` lint.\n@@ -1186,19 +1090,18 @@ fn is_useful<'p, 'tcx>(\n             {\n                 let patterns = {\n                     let mut split_wildcard = SplitWildcard::new(pcx);\n-                    split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                    split_wildcard.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n                     // Construct for each missing constructor a \"wild\" version of this\n                     // constructor, that matches everything that can be built with\n                     // it. For example, if `ctor` is a `Constructor::Variant` for\n                     // `Option::Some`, we get the pattern `Some(_)`.\n                     split_wildcard\n                         .iter_missing(pcx)\n-                        // Filter out the `Constructor::NonExhaustive` variant it's meaningless\n-                        // to our lint\n+                        // Filter out the `NonExhaustive` because we want to list only real\n+                        // variants.\n                         .filter(|c| !c.is_non_exhaustive())\n-                        .map(|missing_ctor| {\n-                            Fields::wildcards(pcx.cx, pcx.ty, missing_ctor).apply(pcx, missing_ctor)\n-                        })\n+                        .cloned()\n+                        .map(|missing_ctor| DeconstructedPat::wild_from_ctor(pcx, missing_ctor))\n                         .collect::<Vec<_>>()\n                 };\n \n@@ -1217,7 +1120,7 @@ fn is_useful<'p, 'tcx>(\n #[derive(Clone, Copy)]\n crate struct MatchArm<'p, 'tcx> {\n     /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n-    crate pat: &'p Pat<'tcx>,\n+    crate pat: &'p DeconstructedPat<'p, 'tcx>,\n     crate hir_id: HirId,\n     crate has_guard: bool,\n }\n@@ -1239,7 +1142,7 @@ crate struct UsefulnessReport<'p, 'tcx> {\n     crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Reachability)>,\n     /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n     /// exhaustiveness.\n-    crate non_exhaustiveness_witnesses: Vec<Pat<'tcx>>,\n+    crate non_exhaustiveness_witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n }\n \n /// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n@@ -1274,7 +1177,7 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n         })\n         .collect();\n \n-    let wild_pattern = cx.pattern_arena.alloc(Pat::wildcard_from_ty(scrut_ty));\n+    let wild_pattern = cx.pattern_arena.alloc(DeconstructedPat::wildcard(scrut_ty));\n     let v = PatStack::from_pattern(wild_pattern);\n     let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, scrut_hir_id, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {"}, {"sha": "35619594f75b86546248042bb6fb9004240e7c3c", "filename": "src/test/ui/consts/const_in_pattern/issue-78057.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71abc9565f037c3c9da5814c23857545abb0aaab/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71abc9565f037c3c9da5814c23857545abb0aaab/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr?ref=71abc9565f037c3c9da5814c23857545abb0aaab", "patch": "@@ -7,8 +7,11 @@ LL |         FOO => {},\n error: unreachable pattern\n   --> $DIR/issue-78057.rs:14:9\n    |\n+LL |         FOO => {},\n+   |         --- matches any value\n+LL |\n LL |         _ => {}\n-   |         ^\n+   |         ^ unreachable pattern\n    |\n note: the lint level is defined here\n   --> $DIR/issue-78057.rs:1:9"}, {"sha": "05c009a6f3fe147b15eca27fbedade1cb8b4889d", "filename": "src/test/ui/pattern/usefulness/consts-opaque.stderr", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/71abc9565f037c3c9da5814c23857545abb0aaab/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71abc9565f037c3c9da5814c23857545abb0aaab/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr?ref=71abc9565f037c3c9da5814c23857545abb0aaab", "patch": "@@ -7,8 +7,11 @@ LL |         FOO => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:32:9\n    |\n+LL |         FOO => {}\n+   |         --- matches any value\n+LL |\n LL |         _ => {} // should not be emitting unreachable warning\n-   |         ^\n+   |         ^ unreachable pattern\n    |\n note: the lint level is defined here\n   --> $DIR/consts-opaque.rs:6:9\n@@ -25,8 +28,11 @@ LL |         FOO_REF => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:39:9\n    |\n+LL |         FOO_REF => {}\n+   |         ------- matches any value\n+LL |\n LL |         Foo(_) => {} // should not be emitting unreachable warning\n-   |         ^^^^^^\n+   |         ^^^^^^ unreachable pattern\n \n warning: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:45:9\n@@ -70,15 +76,18 @@ LL |         BAR => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:63:9\n    |\n+LL |         BAR => {}\n+   |         --- matches any value\n+LL |\n LL |         Bar => {} // should not be emitting unreachable warning\n-   |         ^^^\n+   |         ^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:65:9\n    |\n-LL |         Bar => {} // should not be emitting unreachable warning\n+LL |         BAR => {}\n    |         --- matches any value\n-LL |\n+...\n LL |         _ => {}\n    |         ^ unreachable pattern\n \n@@ -97,14 +106,20 @@ LL |         BAR => {} // should not be emitting unreachable warning\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:72:9\n    |\n+LL |         BAR => {}\n+   |         --- matches any value\n+LL |\n LL |         BAR => {} // should not be emitting unreachable warning\n-   |         ^^^\n+   |         ^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:75:9\n    |\n+LL |         BAR => {}\n+   |         --- matches any value\n+...\n LL |         _ => {} // should not be emitting unreachable warning\n-   |         ^\n+   |         ^ unreachable pattern\n \n error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:80:9\n@@ -115,14 +130,20 @@ LL |         BAZ => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:82:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+LL |\n LL |         Baz::Baz1 => {} // should not be emitting unreachable warning\n-   |         ^^^^^^^^^\n+   |         ^^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:84:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+...\n LL |         _ => {}\n-   |         ^\n+   |         ^ unreachable pattern\n \n error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:90:9\n@@ -133,8 +154,11 @@ LL |         BAZ => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:92:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+LL |\n LL |         _ => {}\n-   |         ^\n+   |         ^ unreachable pattern\n \n error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:97:9\n@@ -145,20 +169,28 @@ LL |         BAZ => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:99:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+LL |\n LL |         Baz::Baz2 => {} // should not be emitting unreachable warning\n-   |         ^^^^^^^^^\n+   |         ^^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:101:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+...\n LL |         _ => {} // should not be emitting unreachable warning\n-   |         ^\n+   |         ^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:127:9\n    |\n+LL |         Wrap(_) => {}\n+   |         ------- matches any value\n LL |         WRAPQUUX => {} // detected unreachable because we do inspect the `Wrap` layer\n-   |         ^^^^^^^^\n+   |         ^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:141:9"}, {"sha": "0ffb0ffd82aa0f6735b19c09b065240cd2aa573c", "filename": "src/test/ui/pattern/usefulness/integer-ranges/reachability.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71abc9565f037c3c9da5814c23857545abb0aaab/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71abc9565f037c3c9da5814c23857545abb0aaab/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.stderr?ref=71abc9565f037c3c9da5814c23857545abb0aaab", "patch": "@@ -133,8 +133,10 @@ LL |         5..15 => {},\n error: unreachable pattern\n   --> $DIR/reachability.rs:83:9\n    |\n+LL |         _ => {},\n+   |         - matches any value\n LL |         '\\u{D7FF}'..='\\u{E000}' => {},\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/reachability.rs:104:9"}]}