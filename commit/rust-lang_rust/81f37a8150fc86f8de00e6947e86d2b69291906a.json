{"sha": "81f37a8150fc86f8de00e6947e86d2b69291906a", "node_id": "C_kwDOAAsO6NoAKDgxZjM3YTgxNTBmYzg2ZjhkZTAwZTY5NDdlODZkMmI2OTI5MTkwNmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-23T10:27:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-23T10:27:12Z"}, "message": "Auto merge of #8025 - flip1995:rustup, r=flip1995\n\nRustup\n\nRe-sync, because I didn't get to syncing things back to rustc.\n\nr? `@ghost`\n\nchangelog: none", "tree": {"sha": "350154f19e43871b6e0e66788e81b21edb79c772", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/350154f19e43871b6e0e66788e81b21edb79c772"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81f37a8150fc86f8de00e6947e86d2b69291906a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81f37a8150fc86f8de00e6947e86d2b69291906a", "html_url": "https://github.com/rust-lang/rust/commit/81f37a8150fc86f8de00e6947e86d2b69291906a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81f37a8150fc86f8de00e6947e86d2b69291906a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6c707db532a160485fcbdaa001a76644a81c85c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c707db532a160485fcbdaa001a76644a81c85c", "html_url": "https://github.com/rust-lang/rust/commit/d6c707db532a160485fcbdaa001a76644a81c85c"}, {"sha": "c46c8c58e948b48505bdef3aef67d4d609356b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/c46c8c58e948b48505bdef3aef67d4d609356b97", "html_url": "https://github.com/rust-lang/rust/commit/c46c8c58e948b48505bdef3aef67d4d609356b97"}], "stats": {"total": 407, "additions": 123, "deletions": 284}, "files": [{"sha": "e0150990cfe5fb42ee247f996df71f33d101893b", "filename": "clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -1,6 +1,4 @@\n-use super::{\n-    get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor, EXPLICIT_COUNTER_LOOP,\n-};\n+use super::{make_iterator_snippet, IncrementVisitor, InitializeVisitor, EXPLICIT_COUNTER_LOOP};\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{get_enclosing_block, is_integer_const};\n@@ -38,15 +36,13 @@ pub(super) fn check<'tcx>(\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    let for_span = get_span_of_entire_for_loop(expr);\n-\n                     let int_name = match ty.map(ty::TyS::kind) {\n                         // usize or inferred\n                         Some(ty::Uint(UintTy::Usize)) | None => {\n                             span_lint_and_sugg(\n                                 cx,\n                                 EXPLICIT_COUNTER_LOOP,\n-                                for_span.with_hi(arg.span.hi()),\n+                                expr.span.with_hi(arg.span.hi()),\n                                 &format!(\"the variable `{}` is used as a loop counter\", name),\n                                 \"consider using\",\n                                 format!(\n@@ -67,11 +63,11 @@ pub(super) fn check<'tcx>(\n                     span_lint_and_then(\n                         cx,\n                         EXPLICIT_COUNTER_LOOP,\n-                        for_span.with_hi(arg.span.hi()),\n+                        expr.span.with_hi(arg.span.hi()),\n                         &format!(\"the variable `{}` is used as a loop counter\", name),\n                         |diag| {\n                             diag.span_suggestion(\n-                                for_span.with_hi(arg.span.hi()),\n+                                expr.span.with_hi(arg.span.hi()),\n                                 \"consider using\",\n                                 format!(\n                                     \"for ({}, {}) in (0_{}..).zip({})\","}, {"sha": "aa382f8a974b8dfaa9a55ce8e3be3c72d1b50fbe", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -1,4 +1,4 @@\n-use super::{get_span_of_entire_for_loop, IncrementVisitor, InitializeVisitor, MANUAL_MEMCPY};\n+use super::{IncrementVisitor, InitializeVisitor, MANUAL_MEMCPY};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n@@ -86,7 +86,7 @@ pub(super) fn check<'tcx>(\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_MEMCPY,\n-                    get_span_of_entire_for_loop(expr),\n+                    expr.span,\n                     \"it looks like you're manually copying between slices\",\n                     \"try replacing the loop by\",\n                     big_sugg,"}, {"sha": "e2f9aee063dd2f8dea4f553ff7e3b5af1c77b64b", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -23,7 +23,7 @@ use rustc_hir::{Expr, ExprKind, LoopSource, Pat};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use utils::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n+use utils::{make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -584,14 +584,25 @@ declare_lint_pass!(Loops => [\n impl<'tcx> LateLintPass<'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(higher::ForLoop { pat, arg, body, span }) = higher::ForLoop::hir(expr) {\n+        let for_loop = higher::ForLoop::hir(expr);\n+        if let Some(higher::ForLoop {\n+            pat,\n+            arg,\n+            body,\n+            loop_id,\n+            span,\n+        }) = for_loop\n+        {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n             // since higher::for_loop expressions are marked as expansions\n             if body.span.from_expansion() {\n                 return;\n             }\n             check_for_loop(cx, pat, arg, body, expr, span);\n+            if let ExprKind::Block(block, _) = body.kind {\n+                never_loop::check(cx, block, loop_id, span, for_loop.as_ref());\n+            }\n         }\n \n         // we don't want to check expanded macros\n@@ -600,7 +611,9 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         }\n \n         // check for never_loop\n-        never_loop::check(cx, expr);\n+        if let ExprKind::Loop(block, ..) = expr.kind {\n+            never_loop::check(cx, block, expr.hir_id, expr.span, None);\n+        }\n \n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")"}, {"sha": "86b7d6d989acc75fd6fc3dde238947886588aa51", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -4,35 +4,41 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, Node, Pat, Stmt, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Pat, Stmt, StmtKind};\n use rustc_lint::LateContext;\n+use rustc_span::Span;\n use std::iter::{once, Iterator};\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Loop(block, _, source, _) = expr.kind {\n-        match never_loop_block(block, expr.hir_id) {\n-            NeverLoopResult::AlwaysBreak => {\n-                span_lint_and_then(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\", |diag| {\n-                    if_chain! {\n-                        if source == LoopSource::ForLoop;\n-                        if let Some((_, Node::Expr(parent_match))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n-                        if let Some(ForLoop { arg: iterator, pat, span: for_span, .. }) = ForLoop::hir(parent_match);\n-                        then {\n-                            // Suggests using an `if let` instead. This is `Unspecified` because the\n-                            // loop may (probably) contain `break` statements which would be invalid\n-                            // in an `if let`.\n-                            diag.span_suggestion_verbose(\n-                                for_span.with_hi(iterator.span.hi()),\n-                                \"if you need the first element of the iterator, try writing\",\n-                                for_to_if_let_sugg(cx, iterator, pat),\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n-                    };\n-                });\n-            },\n-            NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n-        }\n+pub(super) fn check(\n+    cx: &LateContext<'tcx>,\n+    block: &'tcx Block<'_>,\n+    loop_id: HirId,\n+    span: Span,\n+    for_loop: Option<&ForLoop<'_>>,\n+) {\n+    match never_loop_block(block, loop_id) {\n+        NeverLoopResult::AlwaysBreak => {\n+            span_lint_and_then(cx, NEVER_LOOP, span, \"this loop never actually loops\", |diag| {\n+                if let Some(ForLoop {\n+                    arg: iterator,\n+                    pat,\n+                    span: for_span,\n+                    ..\n+                }) = for_loop\n+                {\n+                    // Suggests using an `if let` instead. This is `Unspecified` because the\n+                    // loop may (probably) contain `break` statements which would be invalid\n+                    // in an `if let`.\n+                    diag.span_suggestion_verbose(\n+                        for_span.with_hi(iterator.span.hi()),\n+                        \"if you need the first element of the iterator, try writing\",\n+                        for_to_if_let_sugg(cx, iterator, pat),\n+                        Applicability::Unspecified,\n+                    );\n+                }\n+            });\n+        },\n+        NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n     }\n }\n "}, {"sha": "e39605f3e7d621d79ede824a4c62b37603e1b8b7", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -1,4 +1,4 @@\n-use super::{get_span_of_entire_for_loop, SINGLE_ELEMENT_LOOP};\n+use super::SINGLE_ELEMENT_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::single_segment_path;\n use clippy_utils::source::{indent_of, snippet};\n@@ -30,7 +30,6 @@ pub(super) fn check<'tcx>(\n         if !block.stmts.is_empty();\n \n         then {\n-            let for_span = get_span_of_entire_for_loop(expr);\n             let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n             block_str.remove(0);\n             block_str.pop();\n@@ -39,7 +38,7 @@ pub(super) fn check<'tcx>(\n             span_lint_and_sugg(\n                 cx,\n                 SINGLE_ELEMENT_LOOP,\n-                for_span,\n+                expr.span,\n                 \"for loop over a single element\",\n                 \"try\",\n                 format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),"}, {"sha": "f6b7e1bc353fd24c6b9c736a52a93fb7d2823f88", "filename": "clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -8,7 +8,6 @@ use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, HirIdMap, Local, M\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::Ty;\n-use rustc_span::source_map::Span;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_typeck::hir_ty_to_ty;\n@@ -330,17 +329,6 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     }\n }\n \n-// this function assumes the given expression is a `for` loop.\n-pub(super) fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n-    // for some reason this is the only way to get the `Span`\n-    // of the entire `for` loop\n-    if let ExprKind::Match(_, arms, _) = &expr.kind {\n-        arms[0].body.span\n-    } else {\n-        unreachable!()\n-    }\n-}\n-\n /// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n /// actual `Iterator` that the loop uses.\n pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {"}, {"sha": "2299a09991091a60914bdb32cebe8cf752efeb2e", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -20,8 +20,8 @@ use rustc_span::symbol::sym;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    expr_path_res, get_item_name, get_parent_expr, higher, in_constant, is_diag_trait_item, is_integer_const,\n-    iter_input_pats, last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n+    expr_path_res, get_item_name, get_parent_expr, in_constant, is_diag_trait_item, is_integer_const, iter_input_pats,\n+    last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -321,7 +321,6 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             if let StmtKind::Local(local) = stmt.kind;\n             if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n             if let Some(init) = local.init;\n-            if !higher::is_from_for_desugar(local);\n             if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut;\n             then {\n                 // use the macro callsite when the init span (but not the whole local span)"}, {"sha": "c7d77d30927f854e2836665b13a65c43c5ebd53c", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 43, "deletions": 164, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -1,16 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::last_path_segment;\n use rustc_hir::{\n-    intravisit, Body, Expr, ExprKind, FnDecl, HirId, LocalSource, MatchSource, Mutability, Pat, PatField, PatKind,\n-    QPath, Stmt, StmtKind,\n+    intravisit, Body, Expr, ExprKind, FnDecl, HirId, LocalSource, Mutability, Pat, PatKind, Stmt, StmtKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{AdtDef, FieldDef, Ty, TyKind, VariantDef};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -88,43 +84,28 @@ declare_lint_pass!(PatternTypeMismatch => [PATTERN_TYPE_MISMATCH]);\n impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(local) = stmt.kind {\n-            if let Some(init) = &local.init {\n-                if let Some(init_ty) = cx.typeck_results().node_type_opt(init.hir_id) {\n-                    let pat = &local.pat;\n-                    if in_external_macro(cx.sess(), pat.span) {\n-                        return;\n-                    }\n-                    let deref_possible = match local.source {\n-                        LocalSource::Normal => DerefPossible::Possible,\n-                        _ => DerefPossible::Impossible,\n-                    };\n-                    apply_lint(cx, pat, init_ty, deref_possible);\n-                }\n+            if in_external_macro(cx.sess(), local.pat.span) {\n+                return;\n             }\n+            let deref_possible = match local.source {\n+                LocalSource::Normal => DerefPossible::Possible,\n+                _ => DerefPossible::Impossible,\n+            };\n+            apply_lint(cx, local.pat, deref_possible);\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = expr.kind {\n-            if let Some(expr_ty) = cx.typeck_results().node_type_opt(scrutinee.hir_id) {\n-                'pattern_checks: for arm in arms {\n-                    let pat = &arm.pat;\n-                    if in_external_macro(cx.sess(), pat.span) {\n-                        continue 'pattern_checks;\n-                    }\n-                    if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n-                        break 'pattern_checks;\n-                    }\n+        if let ExprKind::Match(_, arms, _) = expr.kind {\n+            for arm in arms {\n+                let pat = &arm.pat;\n+                if apply_lint(cx, pat, DerefPossible::Possible) {\n+                    break;\n                 }\n             }\n         }\n-        if let ExprKind::Let(let_pat, let_expr, _) = expr.kind {\n-            if let Some(expr_ty) = cx.typeck_results().node_type_opt(let_expr.hir_id) {\n-                if in_external_macro(cx.sess(), let_pat.span) {\n-                    return;\n-                }\n-                apply_lint(cx, let_pat, expr_ty, DerefPossible::Possible);\n-            }\n+        if let ExprKind::Let(let_pat, ..) = expr.kind {\n+            apply_lint(cx, let_pat, DerefPossible::Possible);\n         }\n     }\n \n@@ -135,12 +116,10 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n         _: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n         _: Span,\n-        hir_id: HirId,\n+        _: HirId,\n     ) {\n-        if let Some(fn_sig) = cx.typeck_results().liberated_fn_sigs().get(hir_id) {\n-            for (param, ty) in iter::zip(body.params, fn_sig.inputs()) {\n-                apply_lint(cx, param.pat, ty, DerefPossible::Impossible);\n-            }\n+        for param in body.params {\n+            apply_lint(cx, param.pat, DerefPossible::Impossible);\n         }\n     }\n }\n@@ -151,8 +130,8 @@ enum DerefPossible {\n     Impossible,\n }\n \n-fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, expr_ty: Ty<'tcx>, deref_possible: DerefPossible) -> bool {\n-    let maybe_mismatch = find_first_mismatch(cx, pat, expr_ty, Level::Top);\n+fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, deref_possible: DerefPossible) -> bool {\n+    let maybe_mismatch = find_first_mismatch(cx, pat);\n     if let Some((span, mutability, level)) = maybe_mismatch {\n         span_lint_and_help(\n             cx,\n@@ -185,132 +164,32 @@ enum Level {\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-fn find_first_mismatch<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &Pat<'_>,\n-    ty: Ty<'tcx>,\n-    level: Level,\n-) -> Option<(Span, Mutability, Level)> {\n-    if let PatKind::Ref(sub_pat, _) = pat.kind {\n-        if let TyKind::Ref(_, sub_ty, _) = ty.kind() {\n-            return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n-        }\n-    }\n-\n-    if let TyKind::Ref(_, _, mutability) = *ty.kind() {\n-        if is_non_ref_pattern(&pat.kind) {\n-            return Some((pat.span, mutability, level));\n-        }\n-    }\n-\n-    if let PatKind::Struct(ref qpath, field_pats, _) = pat.kind {\n-        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n-            if let Some(variant) = get_variant(adt_def, qpath) {\n-                let field_defs = &variant.fields;\n-                return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n-            }\n+fn find_first_mismatch<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> Option<(Span, Mutability, Level)> {\n+    let mut result = None;\n+    pat.walk(|p| {\n+        if result.is_some() {\n+            return false;\n         }\n-    }\n-\n-    if let PatKind::TupleStruct(ref qpath, pats, _) = pat.kind {\n-        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n-            if let Some(variant) = get_variant(adt_def, qpath) {\n-                let field_defs = &variant.fields;\n-                let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n-                return find_first_mismatch_in_tuple(cx, pats, ty_iter);\n-            }\n-        }\n-    }\n-\n-    if let PatKind::Tuple(pats, _) = pat.kind {\n-        if let TyKind::Tuple(..) = ty.kind() {\n-            return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n+        if in_external_macro(cx.sess(), p.span) {\n+            return true;\n         }\n-    }\n-\n-    if let PatKind::Or(sub_pats) = pat.kind {\n-        for pat in sub_pats {\n-            let maybe_mismatch = find_first_mismatch(cx, pat, ty, level);\n-            if let Some(mismatch) = maybe_mismatch {\n-                return Some(mismatch);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn get_variant<'a>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {\n-    if adt_def.is_struct() {\n-        if let Some(variant) = adt_def.variants.iter().next() {\n-            return Some(variant);\n-        }\n-    }\n-\n-    if adt_def.is_enum() {\n-        let pat_ident = last_path_segment(qpath).ident;\n-        for variant in &adt_def.variants {\n-            if variant.ident == pat_ident {\n-                return Some(variant);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn find_first_mismatch_in_tuple<'tcx, I>(\n-    cx: &LateContext<'tcx>,\n-    pats: &[Pat<'_>],\n-    ty_iter_src: I,\n-) -> Option<(Span, Mutability, Level)>\n-where\n-    I: IntoIterator<Item = Ty<'tcx>>,\n-{\n-    let mut field_tys = ty_iter_src.into_iter();\n-    'fields: for pat in pats {\n-        let field_ty = if let Some(ty) = field_tys.next() {\n-            ty\n-        } else {\n-            break 'fields;\n+        let adjust_pat = match p.kind {\n+            PatKind::Or([p, ..]) => p,\n+            _ => p,\n         };\n-\n-        let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n-        if let Some(mismatch) = maybe_mismatch {\n-            return Some(mismatch);\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn find_first_mismatch_in_struct<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    field_pats: &[PatField<'_>],\n-    field_defs: &[FieldDef],\n-    substs_ref: SubstsRef<'tcx>,\n-) -> Option<(Span, Mutability, Level)> {\n-    for field_pat in field_pats {\n-        'definitions: for field_def in field_defs {\n-            if field_pat.ident == field_def.ident {\n-                let field_ty = field_def.ty(cx.tcx, substs_ref);\n-                let pat = &field_pat.pat;\n-                let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n-                if let Some(mismatch) = maybe_mismatch {\n-                    return Some(mismatch);\n+        if let Some(adjustments) = cx.typeck_results().pat_adjustments().get(adjust_pat.hir_id) {\n+            if let [first, ..] = **adjustments {\n+                if let ty::Ref(.., mutability) = *first.kind() {\n+                    let level = if p.hir_id == pat.hir_id {\n+                        Level::Top\n+                    } else {\n+                        Level::Lower\n+                    };\n+                    result = Some((p.span, mutability, level));\n                 }\n-                break 'definitions;\n             }\n         }\n-    }\n-\n-    None\n-}\n-\n-fn is_non_ref_pattern(pat_kind: &PatKind<'_>) -> bool {\n-    match pat_kind {\n-        PatKind::Struct(..) | PatKind::Tuple(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => true,\n-        PatKind::Or(sub_pats) => sub_pats.iter().any(|pat| is_non_ref_pattern(&pat.kind)),\n-        _ => false,\n-    }\n+        result.is_none()\n+    });\n+    result\n }"}, {"sha": "63ad65b8afd9f6ffda92e75f326825448cb1df36", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -3,10 +3,8 @@ use clippy_utils::source::snippet;\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{\n-    self as hir, GenericArg, GenericBounds, GenericParamKind, HirId, Lifetime, MutTy, Mutability, Node, QPath,\n-    SyntheticTyParamKind, TyKind,\n-};\n+use rustc_hir::{self as hir, GenericArg, GenericBounds, GenericParamKind};\n+use rustc_hir::{HirId, Lifetime, MutTy, Mutability, Node, QPath, TyKind};\n use rustc_lint::LateContext;\n \n use super::BORROWED_BOX;\n@@ -105,7 +103,7 @@ fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id:\n         if let Some(did) = cx.qpath_res(qpath, id).opt_def_id();\n         if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n         if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n-        if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n+        if synthetic;\n         then {\n             Some(generic_param.bounds)\n         } else {"}, {"sha": "b25a6e3375bb4176b3d45f610e633a8f9ce1086b", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::higher;\n use clippy_utils::source::snippet_with_macro_callsite;\n use rustc_errors::Applicability;\n use rustc_hir::{Stmt, StmtKind};\n@@ -14,9 +13,6 @@ pub(super) fn check(cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n             if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n                 return;\n             }\n-            if higher::is_from_for_desugar(local) {\n-                return;\n-            }\n             span_lint_and_then(\n                 cx,\n                 LET_UNIT_VALUE,"}, {"sha": "7297265d08cfbf214db556486f3d96289454b521", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 15, "deletions": 47, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -22,31 +22,31 @@ pub struct ForLoop<'tcx> {\n     pub arg: &'tcx hir::Expr<'tcx>,\n     /// `for` loop body\n     pub body: &'tcx hir::Expr<'tcx>,\n+    /// Compare this against `hir::Destination.target`\n+    pub loop_id: HirId,\n     /// entire `for` loop span\n     pub span: Span,\n }\n \n impl<'tcx> ForLoop<'tcx> {\n-    #[inline]\n     /// Parses a desugared `for` loop\n     pub fn hir(expr: &Expr<'tcx>) -> Option<Self> {\n         if_chain! {\n-            if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-            if let Some(first_arm) = arms.get(0);\n-            if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n-            if let Some(first_arg) = iterargs.get(0);\n-            if iterargs.len() == 1 && arms.len() == 1 && first_arm.guard.is_none();\n-            if let hir::ExprKind::Loop(block, ..) = first_arm.body.kind;\n-            if block.expr.is_none();\n-            if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-            if let hir::StmtKind::Local(local) = let_stmt.kind;\n-            if let hir::StmtKind::Expr(body_expr) = body.kind;\n+            if let hir::ExprKind::DropTemps(e) = expr.kind;\n+            if let hir::ExprKind::Match(iterexpr, [arm], hir::MatchSource::ForLoopDesugar) = e.kind;\n+            if let hir::ExprKind::Call(_, [arg]) = iterexpr.kind;\n+            if let hir::ExprKind::Loop(block, ..) = arm.body.kind;\n+            if let [stmt] = &*block.stmts;\n+            if let hir::StmtKind::Expr(e) = stmt.kind;\n+            if let hir::ExprKind::Match(_, [_, some_arm], _) = e.kind;\n+            if let hir::PatKind::Struct(_, [field], _) = some_arm.pat.kind;\n             then {\n                 return Some(Self {\n-                    pat: &*local.pat,\n-                    arg: first_arg,\n-                    body: body_expr,\n-                    span: first_arm.span\n+                    pat: field.pat,\n+                    arg,\n+                    body: some_arm.body,\n+                    loop_id: arm.body.hir_id,\n+                    span: expr.span.ctxt().outer_expn_data().call_site,\n                 });\n             }\n         }\n@@ -678,38 +678,6 @@ impl<'tcx> FormatArgsArg<'tcx> {\n     }\n }\n \n-/// Checks if a `let` statement is from a `for` loop desugaring.\n-pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n-    // This will detect plain for-loops without an actual variable binding:\n-    //\n-    // ```\n-    // for x in some_vec {\n-    //     // do stuff\n-    // }\n-    // ```\n-    if_chain! {\n-        if let Some(expr) = local.init;\n-        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    // This detects a variable binding in for loop to avoid `let_unit_value`\n-    // lint (see issue #1964).\n-    //\n-    // ```\n-    // for _ in vec![()] {\n-    //     // anything\n-    // }\n-    // ```\n-    if let hir::LocalSource::ForLoopDesugar = local.source {\n-        return true;\n-    }\n-\n-    false\n-}\n-\n /// A parsed `panic!` expansion\n pub struct PanicExpn<'tcx> {\n     /// Span of `panic!(..)`"}, {"sha": "f02d0b18ddc7ee63a2200e1b09725da0c0d30c68", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-11-18\"\n+channel = \"nightly-2021-11-23\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "3d9560f697a79ee7b3d5416960f9f2e27a4218d5", "filename": "tests/ui/author/loop.stdout", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81f37a8150fc86f8de00e6947e86d2b69291906a/tests%2Fui%2Fauthor%2Floop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/81f37a8150fc86f8de00e6947e86d2b69291906a/tests%2Fui%2Fauthor%2Floop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Floop.stdout?ref=81f37a8150fc86f8de00e6947e86d2b69291906a", "patch": "@@ -1,6 +1,5 @@\n if_chain! {\n-    if let ExprKind::DropTemps(expr1) = expr.kind;\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr1);\n+    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = pat.kind;\n     if name.as_str() == \"y\";\n     if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n@@ -26,8 +25,7 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let ExprKind::DropTemps(expr1) = expr.kind;\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr1);\n+    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n     if let PatKind::Wild = pat.kind;\n     if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n     if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n@@ -49,8 +47,7 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let ExprKind::DropTemps(expr1) = expr.kind;\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr1);\n+    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n     if let PatKind::Wild = pat.kind;\n     if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n     if matches!(qpath, QPath::LangItem(LangItem::Range, _));"}]}