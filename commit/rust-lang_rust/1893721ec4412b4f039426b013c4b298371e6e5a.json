{"sha": "1893721ec4412b4f039426b013c4b298371e6e5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OTM3MjFlYzQ0MTJiNGYwMzk0MjZiMDEzYzRiMjk4MzcxZTZlNWE=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-18T23:26:18Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-18T23:26:18Z"}, "message": "Fixes the issue with uncovered source in async function bodies\n\nThe body_span was assumed to be in the Span root context, but this was\nnot the case for async function bodies.", "tree": {"sha": "4d584560b151e87b72a6772f06bd0b7cb290088e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d584560b151e87b72a6772f06bd0b7cb290088e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1893721ec4412b4f039426b013c4b298371e6e5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1893721ec4412b4f039426b013c4b298371e6e5a", "html_url": "https://github.com/rust-lang/rust/commit/1893721ec4412b4f039426b013c4b298371e6e5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1893721ec4412b4f039426b013c4b298371e6e5a/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ece6061b4af39c331b8c2768d278af04a62ab97", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ece6061b4af39c331b8c2768d278af04a62ab97", "html_url": "https://github.com/rust-lang/rust/commit/3ece6061b4af39c331b8c2768d278af04a62ab97"}], "stats": {"total": 160, "additions": 71, "deletions": 89}, "files": [{"sha": "6b140296a8e761b45ff0158a5c5e854ca2831d7a", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1893721ec4412b4f039426b013c4b298371e6e5a/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1893721ec4412b4f039426b013c4b298371e6e5a/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=1893721ec4412b4f039426b013c4b298371e6e5a", "patch": "@@ -246,8 +246,8 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     ) -> Vec<CoverageSpan> {\n         let mut coverage_spans = CoverageSpans {\n             mir_body,\n-            fn_sig_span,\n-            body_span,\n+            fn_sig_span: fn_sig_span.with_ctxt(SyntaxContext::root()),\n+            body_span: body_span.with_ctxt(SyntaxContext::root()),\n             basic_coverage_blocks,\n             sorted_spans_iter: None,\n             refined_spans: Vec::with_capacity(basic_coverage_blocks.num_nodes() * 2),"}, {"sha": "8a445433ab65fd61af91d318f8751b4581cc107b", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.async2.txt", "status": "modified", "additions": 68, "deletions": 77, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/1893721ec4412b4f039426b013c4b298371e6e5a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1893721ec4412b4f039426b013c4b298371e6e5a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt?ref=1893721ec4412b4f039426b013c4b298371e6e5a", "patch": "@@ -18,8 +18,8 @@\n    18|       |// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n    19|       |// non-async function above, unless the `println!()` is inside a covered block.\n    20|      1|async fn async_func() {\n-   21|       |    println!(\"async_func was covered\");\n-   22|       |    let b = true;\n+   21|      1|    println!(\"async_func was covered\");\n+   22|      1|    let b = true;\n    23|      1|    if b {\n    24|      1|        println!(\"async_func println in block\");\n    25|      1|    }\n@@ -30,8 +30,8 @@\n    29|       |// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n    30|       |// It's only certain kinds of lines and/or their context that results in missing coverage.\n    31|      1|async fn async_func_just_println() {\n-   32|       |    println!(\"async_func_just_println was covered\");\n-   33|       |}\n+   32|      1|    println!(\"async_func_just_println was covered\");\n+   33|      1|}\n    34|       |\n    35|      1|fn main() {\n    36|      1|    println!(\"codecovsample::main\");\n@@ -40,85 +40,76 @@\n    39|      1|\n    40|      1|    executor::block_on(async_func());\n    41|      1|    executor::block_on(async_func_just_println());\n-   42|      1|\n-   43|      1|    // let mut future = Box::pin(async_func());\n-   44|      1|    // executor::block_on(future.as_mut());\n-   45|      1|\n-   46|      1|    // let mut future = Box::pin(async_func());\n-   47|      1|    // executor::block_on(future.as_mut());\n-   48|      1|\n-   49|      1|    // let mut future = Box::pin(async_func_just_println());\n-   50|      1|    // executor::block_on(future.as_mut());\n-   51|      1|}\n-   52|       |\n-   53|       |mod executor {\n-   54|       |    use core::{\n-   55|       |        future::Future,\n-   56|       |        pin::Pin,\n-   57|       |        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n-   58|       |    };\n-   59|       |\n-   60|      2|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n-   61|      2|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n-   62|      2|        use std::hint::unreachable_unchecked;\n-   63|      2|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n-   64|      2|            |_| unsafe { unreachable_unchecked() }, // clone\n+   42|      1|}\n+   43|       |\n+   44|       |mod executor {\n+   45|       |    use core::{\n+   46|       |        future::Future,\n+   47|       |        pin::Pin,\n+   48|       |        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+   49|       |    };\n+   50|       |\n+   51|      2|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+   52|      2|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+   53|      2|        use std::hint::unreachable_unchecked;\n+   54|      2|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+   55|      2|            |_| unsafe { unreachable_unchecked() }, // clone\n                               ^0\n-   65|      2|            |_| unsafe { unreachable_unchecked() }, // wake\n+   56|      2|            |_| unsafe { unreachable_unchecked() }, // wake\n                               ^0\n-   66|      2|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+   57|      2|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n                               ^0\n-   67|      2|            |_| (),\n-   68|      2|        );\n-   69|      2|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n-   70|      2|        let mut context = Context::from_waker(&waker);\n-   71|       |\n-   72|       |        loop {\n-   73|      2|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n-   74|      2|                break val;\n-   75|      0|            }\n-   76|       |        }\n-   77|      2|    }\n+   58|      2|            |_| (),\n+   59|      2|        );\n+   60|      2|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+   61|      2|        let mut context = Context::from_waker(&waker);\n+   62|       |\n+   63|       |        loop {\n+   64|      2|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+   65|      2|                break val;\n+   66|      0|            }\n+   67|       |        }\n+   68|      2|    }\n   ------------------\n   | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func::{closure#0}>>:\n-  |   60|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n-  |   61|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n-  |   62|      1|        use std::hint::unreachable_unchecked;\n-  |   63|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n-  |   64|      1|            |_| unsafe { unreachable_unchecked() }, // clone\n-  |   65|      1|            |_| unsafe { unreachable_unchecked() }, // wake\n-  |   66|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n-  |   67|      1|            |_| (),\n-  |   68|      1|        );\n-  |   69|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n-  |   70|      1|        let mut context = Context::from_waker(&waker);\n-  |   71|       |\n-  |   72|       |        loop {\n-  |   73|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n-  |   74|      1|                break val;\n-  |   75|      0|            }\n-  |   76|       |        }\n-  |   77|      1|    }\n+  |   51|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+  |   52|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+  |   53|      1|        use std::hint::unreachable_unchecked;\n+  |   54|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+  |   55|      1|            |_| unsafe { unreachable_unchecked() }, // clone\n+  |   56|      1|            |_| unsafe { unreachable_unchecked() }, // wake\n+  |   57|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+  |   58|      1|            |_| (),\n+  |   59|      1|        );\n+  |   60|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+  |   61|      1|        let mut context = Context::from_waker(&waker);\n+  |   62|       |\n+  |   63|       |        loop {\n+  |   64|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+  |   65|      1|                break val;\n+  |   66|      0|            }\n+  |   67|       |        }\n+  |   68|      1|    }\n   ------------------\n   | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func_just_println::{closure#0}>>:\n-  |   60|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n-  |   61|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n-  |   62|      1|        use std::hint::unreachable_unchecked;\n-  |   63|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n-  |   64|      1|            |_| unsafe { unreachable_unchecked() }, // clone\n-  |   65|      1|            |_| unsafe { unreachable_unchecked() }, // wake\n-  |   66|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n-  |   67|      1|            |_| (),\n-  |   68|      1|        );\n-  |   69|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n-  |   70|      1|        let mut context = Context::from_waker(&waker);\n-  |   71|       |\n-  |   72|       |        loop {\n-  |   73|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n-  |   74|      1|                break val;\n-  |   75|      0|            }\n-  |   76|       |        }\n-  |   77|      1|    }\n+  |   51|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+  |   52|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+  |   53|      1|        use std::hint::unreachable_unchecked;\n+  |   54|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+  |   55|      1|            |_| unsafe { unreachable_unchecked() }, // clone\n+  |   56|      1|            |_| unsafe { unreachable_unchecked() }, // wake\n+  |   57|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+  |   58|      1|            |_| (),\n+  |   59|      1|        );\n+  |   60|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+  |   61|      1|        let mut context = Context::from_waker(&waker);\n+  |   62|       |\n+  |   63|       |        loop {\n+  |   64|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+  |   65|      1|                break val;\n+  |   66|      0|            }\n+  |   67|       |        }\n+  |   68|      1|    }\n   ------------------\n-   78|       |}\n+   69|       |}\n "}, {"sha": "9d3600822c5310e7901fbf76a753c484bd9e2447", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.partial_eq.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1893721ec4412b4f039426b013c4b298371e6e5a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.partial_eq.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1893721ec4412b4f039426b013c4b298371e6e5a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.partial_eq.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.partial_eq.txt?ref=1893721ec4412b4f039426b013c4b298371e6e5a", "patch": "@@ -2,7 +2,7 @@\n     2|       |// structure of this test.\n     3|       |\n     4|      2|#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-                       ^0            ^0      ^0 ^0  ^1       ^1 ^0^0\n+                       ^0            ^0         ^0  ^1          ^0\n   ------------------\n   | Unexecuted instantiation: <partial_eq::Version as core::cmp::PartialEq>::ne\n   ------------------"}, {"sha": "6171d95ff5543d458b6f0f657b2c771a7cbae541", "filename": "src/test/run-make-fulldeps/coverage/async2.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1893721ec4412b4f039426b013c4b298371e6e5a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1893721ec4412b4f039426b013c4b298371e6e5a/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs?ref=1893721ec4412b4f039426b013c4b298371e6e5a", "patch": "@@ -39,15 +39,6 @@ fn main() {\n \n     executor::block_on(async_func());\n     executor::block_on(async_func_just_println());\n-\n-    // let mut future = Box::pin(async_func());\n-    // executor::block_on(future.as_mut());\n-\n-    // let mut future = Box::pin(async_func());\n-    // executor::block_on(future.as_mut());\n-\n-    // let mut future = Box::pin(async_func_just_println());\n-    // executor::block_on(future.as_mut());\n }\n \n mod executor {"}]}