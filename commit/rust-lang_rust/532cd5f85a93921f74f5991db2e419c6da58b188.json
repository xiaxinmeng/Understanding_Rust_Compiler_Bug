{"sha": "532cd5f85a93921f74f5991db2e419c6da58b188", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMmNkNWY4NWE5MzkyMWY3NGY1OTkxZGIyZTQxOWM2ZGE1OGIxODg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-02-25T11:44:44Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-02-28T04:33:59Z"}, "message": "Separate most of rustc::lint::builtin into a separate crate.\n\nThis pulls out the implementations of most built-in lints into a\nseparate crate, to reduce edit-compile-test iteration times with\nlibrustc_lint and increase parallelism. This should enable lints to be\nrefactored, added and deleted much more easily as it slashes the\nedit-compile cycle to get a minimal working compiler to test with (`make\nrustc-stage1`) from\n\n    librustc -> librustc_typeck -> ... -> librustc_driver ->\n        libcore -> ... -> libstd\n\nto\n\n    librustc_lint -> librustc_driver -> libcore -> ... libstd\n\nwhich is significantly faster, mainly due to avoiding the librustc build\nitself.\n\nThe intention would be to move as much as possible of the infrastructure\ninto the crate too, but the plumbing is deeply intertwined with librustc\nitself at the moment. Also, there are lints for which diagnostics are\nregistered directly in the compiler code, not in their own crate\ntraversal, and their definitions have to remain in librustc.\n\nThis is a [breaking-change] for direct users of the compiler APIs:\ncallers of `rustc::session::build_session` or\n`rustc::session::build_session_` need to manually call\n`rustc_lint::register_builtins` on their return value.\n\nThis should make #22206 easier.", "tree": {"sha": "d97c5cc6150c3cb49ae6d0d05af6479d42987fde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d97c5cc6150c3cb49ae6d0d05af6479d42987fde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532cd5f85a93921f74f5991db2e419c6da58b188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532cd5f85a93921f74f5991db2e419c6da58b188", "html_url": "https://github.com/rust-lang/rust/commit/532cd5f85a93921f74f5991db2e419c6da58b188", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532cd5f85a93921f74f5991db2e419c6da58b188/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e233987ce1de88a48db2ce612019ba644d3cf5dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e233987ce1de88a48db2ce612019ba644d3cf5dd", "html_url": "https://github.com/rust-lang/rust/commit/e233987ce1de88a48db2ce612019ba644d3cf5dd"}], "stats": {"total": 4404, "additions": 2252, "deletions": 2152}, "files": [{"sha": "13e4d8cdeb824af3b5b831cd30418dc27c6f0eb9", "filename": "mk/crates.mk", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -54,7 +54,7 @@ TARGET_CRATES := libc std flate arena term \\\n                  log graphviz core rbml alloc \\\n                  unicode rustc_bitflags\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n-                rustc_trans rustc_back rustc_llvm rustc_privacy\n+                rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc rustbook\n@@ -70,20 +70,21 @@ DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_resolve log syntax serialize rustc_llvm \\\n-\t\t     rustc_trans rustc_privacy\n+\t\t     rustc_trans rustc_privacy rustc_lint\n \n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n \t                log syntax serialize rustc_llvm\n DEPS_rustc_typeck := rustc syntax\n DEPS_rustc_borrowck := rustc log graphviz syntax\n DEPS_rustc_resolve := rustc log syntax\n DEPS_rustc_privacy := rustc log syntax\n+DEPS_rustc_lint := rustc log syntax\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               log graphviz rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n-                test\n+                test rustc_lint\n DEPS_rustc_bitflags := core\n DEPS_flate := std native:miniz\n DEPS_arena := std\n@@ -128,11 +129,13 @@ DOC_CRATES := $(filter-out rustc, \\\n               $(filter-out rustc_resolve, \\\n               $(filter-out rustc_driver, \\\n               $(filter-out rustc_privacy, \\\n+              $(filter-out rustc_lint, \\\n               $(filter-out log, \\\n               $(filter-out getopts, \\\n-              $(filter-out syntax, $(CRATES)))))))))))\n+              $(filter-out syntax, $(CRATES))))))))))))\n COMPILER_DOC_CRATES := rustc rustc_trans rustc_borrowck rustc_resolve \\\n-                       rustc_typeck rustc_driver syntax rustc_privacy\n+                       rustc_typeck rustc_driver syntax rustc_privacy \\\n+                       rustc_lint\n \n # This macro creates some simple definitions for each crate being built, just\n # some munging of all of the parameters above."}, {"sha": "ca2d1a45d571f3a0317ebfe6268a6dbb971a115c", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -21,7 +21,7 @@ $(eval $(call RUST_CRATE,coretest))\n \n TEST_TARGET_CRATES = $(filter-out core unicode,$(TARGET_CRATES)) coretest\n TEST_DOC_CRATES = $(DOC_CRATES)\n-TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve rustc_trans,\\\n+TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve rustc_trans rustc_lint,\\\n                      $(HOST_CRATES))\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n "}, {"sha": "0b95b38722c18ec834cb268e7439efb09cf59d2d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -39,7 +39,6 @@\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(unicode)]\n #![feature(os)]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "b0be94cd18bd1ef0ac131c20dce9f6e24ea48d66", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 2064, "changes": 2065, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -24,1986 +24,8 @@\n //! `add_builtin!` or `add_builtin_with_new!` invocation in `context.rs`.\n //! Use the former for unit-like structs and the latter for structs with\n //! a `pub fn new()`.\n-use self::MethodContext::*;\n \n-use metadata::{csearch, decoder};\n-use middle::def::*;\n-use middle::subst::Substs;\n-use middle::ty::{self, Ty};\n-use middle::{def, pat_util, stability};\n-use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n-use middle::cfg;\n-use util::ppaux::{ty_to_string};\n-use util::nodemap::{FnvHashMap, NodeSet};\n-use lint::{Level, Context, LintPass, LintArray, Lint};\n-\n-use std::collections::BitSet;\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::num::SignedInt;\n-use std::{cmp, slice};\n-use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n-\n-use syntax::{abi, ast, ast_map};\n-use syntax::ast_util::is_shift_binop;\n-use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::{self, Span};\n-use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n-use syntax::parse::token;\n-use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n-use syntax::ast_util;\n-use syntax::ptr::P;\n-use syntax::visit::{self, Visitor};\n-\n-declare_lint! {\n-    WHILE_TRUE,\n-    Warn,\n-    \"suggest using `loop { }` instead of `while true { }`\"\n-}\n-\n-#[derive(Copy)]\n-pub struct WhileTrue;\n-\n-impl LintPass for WhileTrue {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(WHILE_TRUE)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprWhile(ref cond, _, _) = e.node {\n-            if let ast::ExprLit(ref lit) = cond.node {\n-                if let ast::LitBool(true) = lit.node {\n-                    cx.span_lint(WHILE_TRUE, e.span,\n-                                 \"denote infinite loops with loop { ... }\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_TYPECASTS,\n-    Allow,\n-    \"detects unnecessary type casts that can be removed\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnusedCasts;\n-\n-impl LintPass for UnusedCasts {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_TYPECASTS)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprCast(ref expr, ref ty) = e.node {\n-            let t_t = ty::expr_ty(cx.tcx, e);\n-            if ty::expr_ty(cx.tcx, &**expr) == t_t {\n-                cx.span_lint(UNUSED_TYPECASTS, ty.span, \"unnecessary type cast\");\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNSIGNED_NEGATION,\n-    Warn,\n-    \"using an unary minus operator on unsigned type\"\n-}\n-\n-declare_lint! {\n-    UNUSED_COMPARISONS,\n-    Warn,\n-    \"comparisons made useless by limits of the types involved\"\n-}\n-\n-declare_lint! {\n-    OVERFLOWING_LITERALS,\n-    Warn,\n-    \"literal out of range for its type\"\n-}\n-\n-declare_lint! {\n-    EXCEEDING_BITSHIFTS,\n-    Deny,\n-    \"shift exceeds the type's number of bits\"\n-}\n-\n-#[derive(Copy)]\n-pub struct TypeLimits {\n-    /// Id of the last visited negated expression\n-    negated_expr_id: ast::NodeId,\n-}\n-\n-impl TypeLimits {\n-    pub fn new() -> TypeLimits {\n-        TypeLimits {\n-            negated_expr_id: -1,\n-        }\n-    }\n-}\n-\n-impl LintPass for TypeLimits {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSIGNED_NEGATION, UNUSED_COMPARISONS, OVERFLOWING_LITERALS,\n-                    EXCEEDING_BITSHIFTS)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n-            ast::ExprUnary(ast::UnNeg, ref expr) => {\n-                match expr.node  {\n-                    ast::ExprLit(ref lit) => {\n-                        match lit.node {\n-                            ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n-                                cx.span_lint(UNSIGNED_NEGATION, e.span,\n-                                             \"negation of unsigned int literal may \\\n-                                             be unintentional\");\n-                            },\n-                            _ => ()\n-                        }\n-                    },\n-                    _ => {\n-                        let t = ty::expr_ty(cx.tcx, &**expr);\n-                        match t.sty {\n-                            ty::ty_uint(_) => {\n-                                cx.span_lint(UNSIGNED_NEGATION, e.span,\n-                                             \"negation of unsigned int variable may \\\n-                                             be unintentional\");\n-                            },\n-                            _ => ()\n-                        }\n-                    }\n-                };\n-                // propagate negation, if the negation itself isn't negated\n-                if self.negated_expr_id != e.id {\n-                    self.negated_expr_id = expr.id;\n-                }\n-            },\n-            ast::ExprParen(ref expr) if self.negated_expr_id == e.id => {\n-                self.negated_expr_id = expr.id;\n-            },\n-            ast::ExprBinary(binop, ref l, ref r) => {\n-                if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n-                    cx.span_lint(UNUSED_COMPARISONS, e.span,\n-                                 \"comparison is useless due to type limits\");\n-                }\n-\n-                if is_shift_binop(binop.node) {\n-                    let opt_ty_bits = match ty::expr_ty(cx.tcx, &**l).sty {\n-                        ty::ty_int(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n-                        ty::ty_uint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n-                        _ => None\n-                    };\n-\n-                    if let Some(bits) = opt_ty_bits {\n-                        let exceeding = if let ast::ExprLit(ref lit) = r.node {\n-                            if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n-                            else { false }\n-                        } else {\n-                            match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.uint)) {\n-                                Ok(const_int(shift)) => { shift as u64 >= bits },\n-                                Ok(const_uint(shift)) => { shift >= bits },\n-                                _ => { false }\n-                            }\n-                        };\n-                        if exceeding {\n-                            cx.span_lint(EXCEEDING_BITSHIFTS, e.span,\n-                                         \"bitshift exceeds the type's number of bits\");\n-                        }\n-                    };\n-                }\n-            },\n-            ast::ExprLit(ref lit) => {\n-                match ty::expr_ty(cx.tcx, e).sty {\n-                    ty::ty_int(t) => {\n-                        match lit.node {\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                                let int_type = if let ast::TyIs(_) = t {\n-                                    cx.sess().target.int_type\n-                                } else { t };\n-                                let (min, max) = int_ty_range(int_type);\n-                                let negative = self.negated_expr_id == e.id;\n-\n-                                if (negative && v > (min.abs() as u64)) ||\n-                                   (!negative && v > (max.abs() as u64)) {\n-                                    cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                                 &*format!(\"literal out of range for {:?}\", t));\n-                                    return;\n-                                }\n-                            }\n-                            _ => panic!()\n-                        };\n-                    },\n-                    ty::ty_uint(t) => {\n-                        let uint_type = if let ast::TyUs(_) = t {\n-                            cx.sess().target.uint_type\n-                        } else { t };\n-                        let (min, max) = uint_ty_range(uint_type);\n-                        let lit_val: u64 = match lit.node {\n-                            ast::LitByte(_v) => return,  // _v is u8, within range by definition\n-                            ast::LitInt(v, _) => v,\n-                            _ => panic!()\n-                        };\n-                        if  lit_val < min || lit_val > max {\n-                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                         &*format!(\"literal out of range for {:?}\", t));\n-                        }\n-                    },\n-                    ty::ty_float(t) => {\n-                        let (min, max) = float_ty_range(t);\n-                        let lit_val: f64 = match lit.node {\n-                            ast::LitFloat(ref v, _) |\n-                            ast::LitFloatUnsuffixed(ref v) => {\n-                                match v.parse().ok() {\n-                                    Some(f) => f,\n-                                    None => return\n-                                }\n-                            }\n-                            _ => panic!()\n-                        };\n-                        if lit_val < min || lit_val > max {\n-                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                         &*format!(\"literal out of range for {:?}\", t));\n-                        }\n-                    },\n-                    _ => ()\n-                };\n-            },\n-            _ => ()\n-        };\n-\n-        fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n-                                min: T, max: T) -> bool {\n-            match binop.node {\n-                ast::BiLt => v >  min && v <= max,\n-                ast::BiLe => v >= min && v <  max,\n-                ast::BiGt => v >= min && v <  max,\n-                ast::BiGe => v >  min && v <= max,\n-                ast::BiEq | ast::BiNe => v >= min && v <= max,\n-                _ => panic!()\n-            }\n-        }\n-\n-        fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n-            codemap::respan(binop.span, match binop.node {\n-                ast::BiLt => ast::BiGt,\n-                ast::BiLe => ast::BiGe,\n-                ast::BiGt => ast::BiLt,\n-                ast::BiGe => ast::BiLe,\n-                _ => return binop\n-            })\n-        }\n-\n-        // for int & uint, be conservative with the warnings, so that the\n-        // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n-            match int_ty {\n-                ast::TyIs(_) =>    (i64::MIN,        i64::MAX),\n-                ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n-                ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n-                ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n-                ast::TyI64 =>  (i64::MIN,        i64::MAX)\n-            }\n-        }\n-\n-        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n-            match uint_ty {\n-                ast::TyUs(_) =>   (u64::MIN,         u64::MAX),\n-                ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n-                ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n-                ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n-                ast::TyU64 => (u64::MIN,         u64::MAX)\n-            }\n-        }\n-\n-        fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n-            match float_ty {\n-                ast::TyF32  => (f32::MIN as f64, f32::MAX as f64),\n-                ast::TyF64  => (f64::MIN,        f64::MAX)\n-            }\n-        }\n-\n-        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n-            match int_ty {\n-                ast::TyIs(_) =>    int_ty_bits(target_int_ty, target_int_ty),\n-                ast::TyI8 =>   i8::BITS  as u64,\n-                ast::TyI16 =>  i16::BITS as u64,\n-                ast::TyI32 =>  i32::BITS as u64,\n-                ast::TyI64 =>  i64::BITS as u64\n-            }\n-        }\n-\n-        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n-            match uint_ty {\n-                ast::TyUs(_) =>    uint_ty_bits(target_uint_ty, target_uint_ty),\n-                ast::TyU8 =>   u8::BITS  as u64,\n-                ast::TyU16 =>  u16::BITS as u64,\n-                ast::TyU32 =>  u32::BITS as u64,\n-                ast::TyU64 =>  u64::BITS as u64\n-            }\n-        }\n-\n-        fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n-                        l: &ast::Expr, r: &ast::Expr) -> bool {\n-            let (lit, expr, swap) = match (&l.node, &r.node) {\n-                (&ast::ExprLit(_), _) => (l, r, true),\n-                (_, &ast::ExprLit(_)) => (r, l, false),\n-                _ => return true\n-            };\n-            // Normalize the binop so that the literal is always on the RHS in\n-            // the comparison\n-            let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match ty::expr_ty(tcx, expr).sty {\n-                ty::ty_int(int_ty) => {\n-                    let (min, max) = int_ty_range(int_ty);\n-                    let lit_val: i64 = match lit.node {\n-                        ast::ExprLit(ref li) => match li.node {\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => v as i64,\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Minus)) => -(v as i64),\n-                            _ => return true\n-                        },\n-                        _ => panic!()\n-                    };\n-                    is_valid(norm_binop, lit_val, min, max)\n-                }\n-                ty::ty_uint(uint_ty) => {\n-                    let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n-                    let lit_val: u64 = match lit.node {\n-                        ast::ExprLit(ref li) => match li.node {\n-                            ast::LitInt(v, _) => v,\n-                            _ => return true\n-                        },\n-                        _ => panic!()\n-                    };\n-                    is_valid(norm_binop, lit_val, min, max)\n-                }\n-                _ => true\n-            }\n-        }\n-\n-        fn is_comparison(binop: ast::BinOp) -> bool {\n-            match binop.node {\n-                ast::BiEq | ast::BiLt | ast::BiLe |\n-                ast::BiNe | ast::BiGe | ast::BiGt => true,\n-                _ => false\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    IMPROPER_CTYPES,\n-    Warn,\n-    \"proper use of libc types in foreign modules\"\n-}\n-\n-struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n-    cx: &'a Context<'a, 'tcx>\n-}\n-\n-impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n-    fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n-        match self.cx.tcx.def_map.borrow()[id].full_def() {\n-            def::DefPrimTy(ast::TyInt(ast::TyIs(_))) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                  \"found rust type `isize` in foreign module, while \\\n-                                   libc::c_int or libc::c_long should be used\");\n-            }\n-            def::DefPrimTy(ast::TyUint(ast::TyUs(_))) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                  \"found rust type `usize` in foreign module, while \\\n-                                   libc::c_uint or libc::c_ulong should be used\");\n-            }\n-            def::DefTy(..) => {\n-                let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n-                    Some(&ty::atttce_resolved(t)) => t,\n-                    _ => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n-                };\n-\n-                if !ty::is_ffi_safe(self.cx.tcx, tty) {\n-                    self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                      \"found type without foreign-function-safe\n-                                      representation annotation in foreign module, consider \\\n-                                      adding a #[repr(...)] attribute to the type\");\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &ast::Ty) {\n-        if let ast::TyPath(..) = ty.node {\n-            self.check_def(ty.span, ty.id);\n-        }\n-        visit::walk_ty(self, ty);\n-    }\n-}\n-\n-#[derive(Copy)]\n-pub struct ImproperCTypes;\n-\n-impl LintPass for ImproperCTypes {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(IMPROPER_CTYPES)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        fn check_ty(cx: &Context, ty: &ast::Ty) {\n-            let mut vis = ImproperCTypesVisitor { cx: cx };\n-            vis.visit_ty(ty);\n-        }\n-\n-        fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n-            for input in &decl.inputs {\n-                check_ty(cx, &*input.ty);\n-            }\n-            if let ast::Return(ref ret_ty) = decl.output {\n-                check_ty(cx, &**ret_ty);\n-            }\n-        }\n-\n-        match it.node {\n-            ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n-                for ni in &nmod.items {\n-                    match ni.node {\n-                        ast::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n-                        ast::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n-                    }\n-                }\n-            }\n-            _ => (),\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    BOX_POINTERS,\n-    Allow,\n-    \"use of owned (Box type) heap memory\"\n-}\n-\n-#[derive(Copy)]\n-pub struct BoxPointers;\n-\n-impl BoxPointers {\n-    fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n-                                 span: Span, ty: Ty<'tcx>) {\n-        let mut n_uniq: usize = 0;\n-        ty::fold_ty(cx.tcx, ty, |t| {\n-            match t.sty {\n-                ty::ty_uniq(_) => {\n-                    n_uniq += 1;\n-                }\n-                _ => ()\n-            };\n-            t\n-        });\n-\n-        if n_uniq > 0 {\n-            let s = ty_to_string(cx.tcx, ty);\n-            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(BOX_POINTERS, span, &m[..]);\n-        }\n-    }\n-}\n-\n-impl LintPass for BoxPointers {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(BOX_POINTERS)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        match it.node {\n-            ast::ItemFn(..) |\n-            ast::ItemTy(..) |\n-            ast::ItemEnum(..) |\n-            ast::ItemStruct(..) =>\n-                self.check_heap_type(cx, it.span,\n-                                     ty::node_id_to_type(cx.tcx, it.id)),\n-            _ => ()\n-        }\n-\n-        // If it's a struct, we also have to check the fields' types\n-        match it.node {\n-            ast::ItemStruct(ref struct_def, _) => {\n-                for struct_field in &struct_def.fields {\n-                    self.check_heap_type(cx, struct_field.span,\n-                                         ty::node_id_to_type(cx.tcx, struct_field.node.id));\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        let ty = ty::expr_ty(cx.tcx, e);\n-        self.check_heap_type(cx, e.span, ty);\n-    }\n-}\n-\n-declare_lint! {\n-    RAW_POINTER_DERIVE,\n-    Warn,\n-    \"uses of #[derive] with raw pointers are rarely correct\"\n-}\n-\n-struct RawPtrDeriveVisitor<'a, 'tcx: 'a> {\n-    cx: &'a Context<'a, 'tcx>\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDeriveVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &ast::Ty) {\n-        static MSG: &'static str = \"use of `#[derive]` with a raw pointer\";\n-        if let ast::TyPtr(..) = ty.node {\n-            self.cx.span_lint(RAW_POINTER_DERIVE, ty.span, MSG);\n-        }\n-        visit::walk_ty(self, ty);\n-    }\n-    // explicit override to a no-op to reduce code bloat\n-    fn visit_expr(&mut self, _: &ast::Expr) {}\n-    fn visit_block(&mut self, _: &ast::Block) {}\n-}\n-\n-pub struct RawPointerDerive {\n-    checked_raw_pointers: NodeSet,\n-}\n-\n-impl RawPointerDerive {\n-    pub fn new() -> RawPointerDerive {\n-        RawPointerDerive {\n-            checked_raw_pointers: NodeSet(),\n-        }\n-    }\n-}\n-\n-impl LintPass for RawPointerDerive {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(RAW_POINTER_DERIVE)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n-            return\n-        }\n-        let did = match item.node {\n-            ast::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n-                // Deriving the Copy trait does not cause a warning\n-                if let &Some(ref trait_ref) = t_ref_opt {\n-                    let def_id = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n-                    if Some(def_id) == cx.tcx.lang_items.copy_trait() {\n-                        return\n-                    }\n-                }\n-\n-                match ty::node_id_to_type(cx.tcx, item.id).sty {\n-                    ty::ty_enum(did, _) => did,\n-                    ty::ty_struct(did, _) => did,\n-                    _ => return,\n-                }\n-            }\n-            _ => return,\n-        };\n-        if !ast_util::is_local(did) { return }\n-        let item = match cx.tcx.map.find(did.node) {\n-            Some(ast_map::NodeItem(item)) => item,\n-            _ => return,\n-        };\n-        if !self.checked_raw_pointers.insert(item.id) { return }\n-        match item.node {\n-            ast::ItemStruct(..) | ast::ItemEnum(..) => {\n-                let mut visitor = RawPtrDeriveVisitor { cx: cx };\n-                visit::walk_item(&mut visitor, &*item);\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_ATTRIBUTES,\n-    Warn,\n-    \"detects attributes that were not used by the compiler\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnusedAttributes;\n-\n-impl LintPass for UnusedAttributes {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ATTRIBUTES)\n-    }\n-\n-    fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n-        for &(ref name, ty) in KNOWN_ATTRIBUTES {\n-            match ty {\n-                AttributeType::Whitelisted\n-                | AttributeType::Gated(_, _) if attr.check_name(name) => {\n-                    break;\n-                },\n-                _ => ()\n-            }\n-        }\n-\n-        if !attr::is_used(attr) {\n-            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n-            if KNOWN_ATTRIBUTES.contains(&(&attr.name(), AttributeType::CrateLevel)) {\n-                let msg = match attr.node.style {\n-                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n-                                       attribute: add an exclamation mark: #![foo]\",\n-                    ast::AttrInner => \"crate-level attribute should be in the \\\n-                                       root module\",\n-                };\n-                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub PATH_STATEMENTS,\n-    Warn,\n-    \"path statements with no effect\"\n-}\n-\n-#[derive(Copy)]\n-pub struct PathStatements;\n-\n-impl LintPass for PathStatements {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(PATH_STATEMENTS)\n-    }\n-\n-    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n-        match s.node {\n-            ast::StmtSemi(ref expr, _) => {\n-                match expr.node {\n-                    ast::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n-                                                      \"path statement with no effect\"),\n-                    _ => ()\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub UNUSED_MUST_USE,\n-    Warn,\n-    \"unused result of a type flagged as #[must_use]\"\n-}\n-\n-declare_lint! {\n-    pub UNUSED_RESULTS,\n-    Allow,\n-    \"unused result of an expression in a statement\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnusedResults;\n-\n-impl LintPass for UnusedResults {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n-    }\n-\n-    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n-        let expr = match s.node {\n-            ast::StmtSemi(ref expr, _) => &**expr,\n-            _ => return\n-        };\n-\n-        if let ast::ExprRet(..) = expr.node {\n-            return;\n-        }\n-\n-        let t = ty::expr_ty(cx.tcx, expr);\n-        let mut warned = false;\n-        match t.sty {\n-            ty::ty_tup(ref tys) if tys.is_empty() => return,\n-            ty::ty_bool => return,\n-            ty::ty_struct(did, _) |\n-            ty::ty_enum(did, _) => {\n-                if ast_util::is_local(did) {\n-                    if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, &it.attrs, s.span);\n-                    }\n-                } else {\n-                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n-                    warned |= check_must_use(cx, &attrs[..], s.span);\n-                }\n-            }\n-            _ => {}\n-        }\n-        if !warned {\n-            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n-        }\n-\n-        fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n-            for attr in attrs {\n-                if attr.check_name(\"must_use\") {\n-                    let mut msg = \"unused result which must be used\".to_string();\n-                    // check for #[must_use=\"...\"]\n-                    match attr.value_str() {\n-                        None => {}\n-                        Some(s) => {\n-                            msg.push_str(\": \");\n-                            msg.push_str(&s);\n-                        }\n-                    }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n-                    return true;\n-                }\n-            }\n-            false\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub NON_CAMEL_CASE_TYPES,\n-    Warn,\n-    \"types, variants, traits and type parameters should have camel case names\"\n-}\n-\n-#[derive(Copy)]\n-pub struct NonCamelCaseTypes;\n-\n-impl NonCamelCaseTypes {\n-    fn check_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-        fn is_camel_case(ident: ast::Ident) -> bool {\n-            let ident = token::get_ident(ident);\n-            if ident.is_empty() { return true; }\n-            let ident = ident.trim_matches('_');\n-\n-            // start with a non-lowercase letter rather than non-uppercase\n-            // ones (some scripts don't have a concept of upper/lowercase)\n-            ident.len() > 0 && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n-        }\n-\n-        fn to_camel_case(s: &str) -> String {\n-            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-                if i == 0 { c.to_uppercase() }\n-                else { c }\n-            )).collect()\n-        }\n-\n-        let s = token::get_ident(ident);\n-\n-        if !is_camel_case(ident) {\n-            let c = to_camel_case(&s);\n-            let m = if c.is_empty() {\n-                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n-            } else {\n-                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n-            };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n-        }\n-    }\n-}\n-\n-impl LintPass for NonCamelCaseTypes {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_CAMEL_CASE_TYPES)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        let has_extern_repr = it.attrs.iter().map(|attr| {\n-            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n-                .any(|r| r == &attr::ReprExtern)\n-        }).any(|x| x);\n-        if has_extern_repr { return }\n-\n-        match it.node {\n-            ast::ItemTy(..) | ast::ItemStruct(..) => {\n-                self.check_case(cx, \"type\", it.ident, it.span)\n-            }\n-            ast::ItemTrait(..) => {\n-                self.check_case(cx, \"trait\", it.ident, it.span)\n-            }\n-            ast::ItemEnum(ref enum_definition, _) => {\n-                if has_extern_repr { return }\n-                self.check_case(cx, \"type\", it.ident, it.span);\n-                for variant in &enum_definition.variants {\n-                    self.check_case(cx, \"variant\", variant.node.name, variant.span);\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    fn check_generics(&mut self, cx: &Context, it: &ast::Generics) {\n-        for gen in &*it.ty_params {\n-            self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n-        }\n-    }\n-}\n-\n-#[derive(PartialEq)]\n-enum MethodContext {\n-    TraitDefaultImpl,\n-    TraitImpl,\n-    PlainImpl\n-}\n-\n-fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n-    let did = ast::DefId {\n-        krate: ast::LOCAL_CRATE,\n-        node: m.id\n-    };\n-\n-    match cx.tcx.impl_or_trait_items.borrow().get(&did).cloned() {\n-        None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n-        Some(md) => {\n-            match md {\n-                ty::MethodTraitItem(md) => {\n-                    match md.container {\n-                        ty::TraitContainer(..) => TraitDefaultImpl,\n-                        ty::ImplContainer(cid) => {\n-                            match ty::impl_trait_ref(cx.tcx, cid) {\n-                                Some(..) => TraitImpl,\n-                                None => PlainImpl\n-                            }\n-                        }\n-                    }\n-                }\n-                ty::TypeTraitItem(typedef) => {\n-                    match typedef.container {\n-                        ty::TraitContainer(..) => TraitDefaultImpl,\n-                        ty::ImplContainer(cid) => {\n-                            match ty::impl_trait_ref(cx.tcx, cid) {\n-                                Some(..) => TraitImpl,\n-                                None => PlainImpl\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub NON_SNAKE_CASE,\n-    Warn,\n-    \"methods, functions, lifetime parameters and modules should have snake case names\"\n-}\n-\n-#[derive(Copy)]\n-pub struct NonSnakeCase;\n-\n-impl NonSnakeCase {\n-    fn to_snake_case(mut str: &str) -> String {\n-        let mut words = vec![];\n-        // Preserve leading underscores\n-        str = str.trim_left_matches(|c: char| {\n-            if c == '_' {\n-                words.push(String::new());\n-                true\n-            } else { false }\n-        });\n-        for s in str.split('_') {\n-            let mut last_upper = false;\n-            let mut buf = String::new();\n-            if s.is_empty() { continue; }\n-            for ch in s.chars() {\n-                if !buf.is_empty() && buf != \"'\"\n-                                   && ch.is_uppercase()\n-                                   && !last_upper {\n-                    words.push(buf);\n-                    buf = String::new();\n-                }\n-                last_upper = ch.is_uppercase();\n-                buf.push(ch.to_lowercase());\n-            }\n-            words.push(buf);\n-        }\n-        words.connect(\"_\")\n-    }\n-\n-    fn check_snake_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-        fn is_snake_case(ident: ast::Ident) -> bool {\n-            let ident = token::get_ident(ident);\n-            if ident.is_empty() { return true; }\n-            let ident = ident.trim_left_matches('\\'');\n-            let ident = ident.trim_matches('_');\n-\n-            let mut allow_underscore = true;\n-            ident.chars().all(|c| {\n-                allow_underscore = match c {\n-                    '_' if !allow_underscore => return false,\n-                    '_' => false,\n-                    c if !c.is_uppercase() => true,\n-                    _ => return false,\n-                };\n-                true\n-            })\n-        }\n-\n-        let s = token::get_ident(ident);\n-\n-        if !is_snake_case(ident) {\n-            let sc = NonSnakeCase::to_snake_case(&s);\n-            if sc != &s[..] {\n-                cx.span_lint(NON_SNAKE_CASE, span,\n-                    &*format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                            sort, s, sc));\n-            } else {\n-                cx.span_lint(NON_SNAKE_CASE, span,\n-                    &*format!(\"{} `{}` should have a snake case name\",\n-                            sort, s));\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for NonSnakeCase {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_SNAKE_CASE)\n-    }\n-\n-    fn check_fn(&mut self, cx: &Context,\n-                fk: visit::FnKind, _: &ast::FnDecl,\n-                _: &ast::Block, span: Span, _: ast::NodeId) {\n-        match fk {\n-            visit::FkMethod(ident, _, m) => match method_context(cx, m) {\n-                PlainImpl\n-                    => self.check_snake_case(cx, \"method\", ident, span),\n-                TraitDefaultImpl\n-                    => self.check_snake_case(cx, \"trait method\", ident, span),\n-                _ => (),\n-            },\n-            visit::FkItemFn(ident, _, _, _)\n-                => self.check_snake_case(cx, \"function\", ident, span),\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        if let ast::ItemMod(_) = it.node {\n-            self.check_snake_case(cx, \"module\", it.ident, it.span);\n-        }\n-    }\n-\n-    fn check_ty_method(&mut self, cx: &Context, t: &ast::TypeMethod) {\n-        self.check_snake_case(cx, \"trait method\", t.ident, t.span);\n-    }\n-\n-    fn check_lifetime_def(&mut self, cx: &Context, t: &ast::LifetimeDef) {\n-        self.check_snake_case(cx, \"lifetime\", t.lifetime.name.ident(), t.lifetime.span);\n-    }\n-\n-    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n-        if let &ast::PatIdent(_, ref path1, _) = &p.node {\n-            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-            if let Some(def::DefLocal(_)) = def {\n-                self.check_snake_case(cx, \"variable\", path1.node, p.span);\n-            }\n-        }\n-    }\n-\n-    fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n-            _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n-        for sf in &s.fields {\n-            if let ast::StructField_ { kind: ast::NamedField(ident, _), .. } = sf.node {\n-                self.check_snake_case(cx, \"structure field\", ident, sf.span);\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub NON_UPPER_CASE_GLOBALS,\n-    Warn,\n-    \"static constants should have uppercase identifiers\"\n-}\n-\n-#[derive(Copy)]\n-pub struct NonUpperCaseGlobals;\n-\n-impl NonUpperCaseGlobals {\n-    fn check_upper_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-        let s = token::get_ident(ident);\n-\n-        if s.chars().any(|c| c.is_lowercase()) {\n-            let uc: String = NonSnakeCase::to_snake_case(&s).chars()\n-                                           .map(|c| c.to_uppercase()).collect();\n-            if uc != &s[..] {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name such as `{}`\",\n-                             sort, s, uc));\n-            } else {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name\",\n-                             sort, s));\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for NonUpperCaseGlobals {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_UPPER_CASE_GLOBALS)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        match it.node {\n-            // only check static constants\n-            ast::ItemStatic(_, ast::MutImmutable, _) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n-            }\n-            ast::ItemConst(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n-        // Lint for constants that look like binding identifiers (#7526)\n-        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&ast::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                      path1.node, p.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_PARENS,\n-    Warn,\n-    \"`if`, `match`, `while` and `return` do not need parentheses\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnusedParens;\n-\n-impl UnusedParens {\n-    fn check_unused_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n-                                     struct_lit_needs_parens: bool) {\n-        if let ast::ExprParen(ref inner) = value.node {\n-            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n-            if !necessary {\n-                cx.span_lint(UNUSED_PARENS, value.span,\n-                             &format!(\"unnecessary parentheses around {}\",\n-                                     msg))\n-            }\n-        }\n-\n-        /// Expressions that syntactically contain an \"exterior\" struct\n-        /// literal i.e. not surrounded by any parens or other\n-        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n-        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n-        /// y: 1 }) == foo` does not.\n-        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-            match value.node {\n-                ast::ExprStruct(..) => true,\n-\n-                ast::ExprAssign(ref lhs, ref rhs) |\n-                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-                ast::ExprBinary(_, ref lhs, ref rhs) => {\n-                    // X { y: 1 } + X { y: 2 }\n-                    contains_exterior_struct_lit(&**lhs) ||\n-                        contains_exterior_struct_lit(&**rhs)\n-                }\n-                ast::ExprUnary(_, ref x) |\n-                ast::ExprCast(ref x, _) |\n-                ast::ExprField(ref x, _) |\n-                ast::ExprTupField(ref x, _) |\n-                ast::ExprIndex(ref x, _) => {\n-                    // &X { y: 1 }, X { y: 1 }.y\n-                    contains_exterior_struct_lit(&**x)\n-                }\n-\n-                ast::ExprMethodCall(_, _, ref exprs) => {\n-                    // X { y: 1 }.bar(...)\n-                    contains_exterior_struct_lit(&*exprs[0])\n-                }\n-\n-                _ => false\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for UnusedParens {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_PARENS)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        let (value, msg, struct_lit_needs_parens) = match e.node {\n-            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n-            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprMatch(ref head, _, source) => match source {\n-                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n-                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n-                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n-                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n-            },\n-            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n-            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n-            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n-            _ => return\n-        };\n-        self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n-    }\n-\n-    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n-        let (value, msg) = match s.node {\n-            ast::StmtDecl(ref decl, _) => match decl.node {\n-                ast::DeclLocal(ref local) => match local.init {\n-                    Some(ref value) => (value, \"assigned value\"),\n-                    None => return\n-                },\n-                _ => return\n-            },\n-            _ => return\n-        };\n-        self.check_unused_parens_core(cx, &**value, msg, false);\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_IMPORT_BRACES,\n-    Allow,\n-    \"unnecessary braces around an imported item\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnusedImportBraces;\n-\n-impl LintPass for UnusedImportBraces {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_IMPORT_BRACES)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ast::ViewPathList(_, ref items) => {\n-                        if items.len() == 1 {\n-                            match items[0].node {\n-                                ast::PathListIdent {ref name, ..} => {\n-                                    let m = format!(\"braces around {} is unnecessary\",\n-                                                    &token::get_ident(*name));\n-                                    cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n-                                                 &m[..]);\n-                                },\n-                                _ => ()\n-                            }\n-                        }\n-                    }\n-                    _ => ()\n-                }\n-            },\n-            _ => ()\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    NON_SHORTHAND_FIELD_PATTERNS,\n-    Warn,\n-    \"using `Struct { x: x }` instead of `Struct { x }`\"\n-}\n-\n-#[derive(Copy)]\n-pub struct NonShorthandFieldPatterns;\n-\n-impl LintPass for NonShorthandFieldPatterns {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_SHORTHAND_FIELD_PATTERNS)\n-    }\n-\n-    fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n-        let def_map = cx.tcx.def_map.borrow();\n-        if let ast::PatStruct(_, ref v, _) = pat.node {\n-            let field_pats = v.iter()\n-                              .filter(|fieldpat| !fieldpat.node.is_shorthand)\n-                              .filter(|fieldpat| {\n-                let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n-                def == Some(def::DefLocal(fieldpat.node.pat.id))\n-            });\n-            for fieldpat in field_pats {\n-                if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n-                    if ident.node.as_str() == fieldpat.node.ident.as_str() {\n-                        cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n-                                     &format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str()))\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub UNUSED_UNSAFE,\n-    Warn,\n-    \"unnecessary use of an `unsafe` block\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnusedUnsafe;\n-\n-impl LintPass for UnusedUnsafe {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_UNSAFE)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprBlock(ref blk) = e.node {\n-            // Don't warn about generated blocks, that'll just pollute the output.\n-            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n-                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNSAFE_CODE,\n-    Allow,\n-    \"usage of `unsafe` code\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnsafeCode;\n-\n-impl LintPass for UnsafeCode {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSAFE_CODE)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprBlock(ref blk) = e.node {\n-            // Don't warn about generated blocks, that'll just pollute the output.\n-            if blk.rules == ast::UnsafeBlock(ast::UserProvided) {\n-                cx.span_lint(UNSAFE_CODE, blk.span, \"usage of an `unsafe` block\");\n-            }\n-        }\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        match it.node {\n-            ast::ItemTrait(ast::Unsafety::Unsafe, _, _, _) =>\n-                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\"),\n-\n-            ast::ItemImpl(ast::Unsafety::Unsafe, _, _, _, _, _) =>\n-                cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\"),\n-\n-            _ => return,\n-        }\n-    }\n-\n-    fn check_fn(&mut self, cx: &Context, fk: visit::FnKind, _: &ast::FnDecl,\n-                _: &ast::Block, span: Span, _: ast::NodeId) {\n-        match fk {\n-            visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _) =>\n-                cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n-\n-            visit::FkMethod(_, _, m) => {\n-                if let ast::Method_::MethDecl(_, _, _, _, ast::Unsafety::Unsafe, _, _, _) = m.node {\n-                    cx.span_lint(UNSAFE_CODE, m.span, \"implementation of an `unsafe` method\")\n-                }\n-            },\n-\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_ty_method(&mut self, cx: &Context, ty_method: &ast::TypeMethod) {\n-        if let ast::TypeMethod { unsafety: ast::Unsafety::Unsafe, span, ..} = *ty_method {\n-            cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` method\")\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub UNUSED_MUT,\n-    Warn,\n-    \"detect mut variables which don't need to be mutable\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnusedMut;\n-\n-impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<ast::Pat>]) {\n-        // collect all mutable pattern and group their NodeIDs by their Identifier to\n-        // avoid false warnings in match arms with multiple patterns\n-\n-        let mut mutables = FnvHashMap();\n-        for p in pats {\n-            pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n-                let ident = path1.node;\n-                if let ast::BindByValue(ast::MutMutable) = mode {\n-                    if !token::get_ident(ident).starts_with(\"_\") {\n-                        match mutables.entry(ident.name.usize()) {\n-                            Vacant(entry) => { entry.insert(vec![id]); },\n-                            Occupied(mut entry) => { entry.get_mut().push(id); },\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-\n-        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-        for (_, v) in &mutables {\n-            if !v.iter().any(|e| used_mutables.contains(e)) {\n-                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n-                             \"variable does not need to be mutable\");\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for UnusedMut {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUT)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprMatch(_, ref arms, _) = e.node {\n-            for a in arms {\n-                self.check_unused_mut_pat(cx, &a.pats)\n-            }\n-        }\n-    }\n-\n-    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n-        if let ast::StmtDecl(ref d, _) = s.node {\n-            if let ast::DeclLocal(ref l) = d.node {\n-                self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n-            }\n-        }\n-    }\n-\n-    fn check_fn(&mut self, cx: &Context,\n-                _: visit::FnKind, decl: &ast::FnDecl,\n-                _: &ast::Block, _: Span, _: ast::NodeId) {\n-        for a in &decl.inputs {\n-            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_ALLOCATION,\n-    Warn,\n-    \"detects unnecessary allocations that can be eliminated\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnusedAllocation;\n-\n-impl LintPass for UnusedAllocation {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ALLOCATION)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n-            ast::ExprUnary(ast::UnUniq, _) => (),\n-            _ => return\n-        }\n-\n-        if let Some(adjustment) = cx.tcx.adjustments.borrow().get(&e.id) {\n-            if let ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) = *adjustment {\n-                match autoref {\n-                    &Some(ty::AutoPtr(_, ast::MutImmutable, None)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n-                                     \"unnecessary allocation, use & instead\");\n-                    }\n-                    &Some(ty::AutoPtr(_, ast::MutMutable, None)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n-                                     \"unnecessary allocation, use &mut instead\");\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    MISSING_DOCS,\n-    Allow,\n-    \"detects missing documentation for public members\"\n-}\n-\n-pub struct MissingDoc {\n-    /// Stack of IDs of struct definitions.\n-    struct_def_stack: Vec<ast::NodeId>,\n-\n-    /// True if inside variant definition\n-    in_variant: bool,\n-\n-    /// Stack of whether #[doc(hidden)] is set\n-    /// at each level which has lint attributes.\n-    doc_hidden_stack: Vec<bool>,\n-}\n-\n-impl MissingDoc {\n-    pub fn new() -> MissingDoc {\n-        MissingDoc {\n-            struct_def_stack: vec!(),\n-            in_variant: false,\n-            doc_hidden_stack: vec!(false),\n-        }\n-    }\n-\n-    fn doc_hidden(&self) -> bool {\n-        *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n-    }\n-\n-    fn check_missing_docs_attrs(&self,\n-                               cx: &Context,\n-                               id: Option<ast::NodeId>,\n-                               attrs: &[ast::Attribute],\n-                               sp: Span,\n-                               desc: &'static str) {\n-        // If we're building a test harness, then warning about\n-        // documentation is probably not really relevant right now.\n-        if cx.sess().opts.test { return }\n-\n-        // `#[doc(hidden)]` disables missing_docs check.\n-        if self.doc_hidden() { return }\n-\n-        // Only check publicly-visible items, using the result from the privacy pass.\n-        // It's an option so the crate root can also use this function (it doesn't\n-        // have a NodeId).\n-        if let Some(ref id) = id {\n-            if !cx.exported_items.contains(id) {\n-                return;\n-            }\n-        }\n-\n-        let has_doc = attrs.iter().any(|a| {\n-            match a.node.value.node {\n-                ast::MetaNameValue(ref name, _) if *name == \"doc\" => true,\n-                _ => false\n-            }\n-        });\n-        if !has_doc {\n-            cx.span_lint(MISSING_DOCS, sp,\n-                &format!(\"missing documentation for {}\", desc));\n-        }\n-    }\n-}\n-\n-impl LintPass for MissingDoc {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MISSING_DOCS)\n-    }\n-\n-    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n-        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") && match attr.meta_item_list() {\n-                None => false,\n-                Some(l) => attr::contains_name(&l[..], \"hidden\"),\n-            }\n-        });\n-        self.doc_hidden_stack.push(doc_hidden);\n-    }\n-\n-    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) {\n-        self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n-    }\n-\n-    fn check_struct_def(&mut self, _: &Context,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n-        self.struct_def_stack.push(id);\n-    }\n-\n-    fn check_struct_def_post(&mut self, _: &Context,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n-        let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n-        assert!(popped == id);\n-    }\n-\n-    fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, &krate.attrs,\n-                                     krate.span, \"crate\");\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        let desc = match it.node {\n-            ast::ItemFn(..) => \"a function\",\n-            ast::ItemMod(..) => \"a module\",\n-            ast::ItemEnum(..) => \"an enum\",\n-            ast::ItemStruct(..) => \"a struct\",\n-            ast::ItemTrait(..) => \"a trait\",\n-            ast::ItemTy(..) => \"a type alias\",\n-            _ => return\n-        };\n-        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs,\n-                                     it.span, desc);\n-    }\n-\n-    fn check_fn(&mut self, cx: &Context,\n-            fk: visit::FnKind, _: &ast::FnDecl,\n-            _: &ast::Block, _: Span, _: ast::NodeId) {\n-        if let visit::FkMethod(_, _, m) = fk {\n-            // If the method is an impl for a trait, don't doc.\n-            if method_context(cx, m) == TraitImpl { return; }\n-\n-            // Otherwise, doc according to privacy. This will also check\n-            // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs,\n-                                          m.span, \"a method\");\n-        }\n-    }\n-\n-    fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs,\n-                                     tm.span, \"a type method\");\n-    }\n-\n-    fn check_trait_method(&mut self, cx: &Context, it: &ast::TraitItem) {\n-        if let ast::TraitItem::TypeTraitItem(ref ty) = *it {\n-            let assoc_ty = &ty.ty_param;\n-            self.check_missing_docs_attrs(cx, Some(assoc_ty.id), &ty.attrs,\n-                                          assoc_ty.span, \"an associated type\");\n-        }\n-    }\n-\n-    fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n-        if let ast::NamedField(_, vis) = sf.node.kind {\n-            if vis == ast::Public || self.in_variant {\n-                let cur_struct_def = *self.struct_def_stack.last()\n-                    .expect(\"empty struct_def_stack\");\n-                self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              &sf.node.attrs, sf.span,\n-                                              \"a struct field\")\n-            }\n-        }\n-    }\n-\n-    fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs,\n-                                     v.span, \"a variant\");\n-        assert!(!self.in_variant);\n-        self.in_variant = true;\n-    }\n-\n-    fn check_variant_post(&mut self, _: &Context, _: &ast::Variant, _: &ast::Generics) {\n-        assert!(self.in_variant);\n-        self.in_variant = false;\n-    }\n-}\n-\n-#[derive(Copy)]\n-pub struct MissingCopyImplementations;\n-\n-impl LintPass for MissingCopyImplementations {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MISSING_COPY_IMPLEMENTATIONS)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !cx.exported_items.contains(&item.id) {\n-            return\n-        }\n-        if cx.tcx\n-             .destructor_for_type\n-             .borrow()\n-             .contains_key(&ast_util::local_def(item.id)) {\n-            return\n-        }\n-        let ty = match item.node {\n-            ast::ItemStruct(_, ref ast_generics) => {\n-                if ast_generics.is_parameterized() {\n-                    return\n-                }\n-                ty::mk_struct(cx.tcx,\n-                              ast_util::local_def(item.id),\n-                              cx.tcx.mk_substs(Substs::empty()))\n-            }\n-            ast::ItemEnum(_, ref ast_generics) => {\n-                if ast_generics.is_parameterized() {\n-                    return\n-                }\n-                ty::mk_enum(cx.tcx,\n-                            ast_util::local_def(item.id),\n-                            cx.tcx.mk_substs(Substs::empty()))\n-            }\n-            _ => return,\n-        };\n-        let parameter_environment = ty::empty_parameter_environment(cx.tcx);\n-        if !ty::type_moves_by_default(&parameter_environment, item.span, ty) {\n-            return\n-        }\n-        if ty::can_type_implement_copy(&parameter_environment, item.span, ty).is_ok() {\n-            cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n-                         item.span,\n-                         \"type could implement `Copy`; consider adding `impl \\\n-                          Copy`\")\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    MISSING_DEBUG_IMPLEMENTATIONS,\n-    Allow,\n-    \"detects missing implementations of fmt::Debug\"\n-}\n-\n-pub struct MissingDebugImplementations {\n-    impling_types: Option<NodeSet>,\n-}\n-\n-impl MissingDebugImplementations {\n-    pub fn new() -> MissingDebugImplementations {\n-        MissingDebugImplementations {\n-            impling_types: None,\n-        }\n-    }\n-}\n-\n-impl LintPass for MissingDebugImplementations {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MISSING_DEBUG_IMPLEMENTATIONS)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !cx.exported_items.contains(&item.id) {\n-            return;\n-        }\n-\n-        match item.node {\n-            ast::ItemStruct(..) | ast::ItemEnum(..) => {},\n-            _ => return,\n-        }\n-\n-        let debug = match cx.tcx.lang_items.debug_trait() {\n-            Some(debug) => debug,\n-            None => return,\n-        };\n-\n-        if self.impling_types.is_none() {\n-            let impls = cx.tcx.trait_impls.borrow();\n-            let impls = match impls.get(&debug) {\n-                Some(impls) => {\n-                    impls.borrow().iter()\n-                        .filter(|d| d.krate == ast::LOCAL_CRATE)\n-                        .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n-                        .map(|d| d.node)\n-                        .collect()\n-                }\n-                None => NodeSet(),\n-            };\n-            self.impling_types = Some(impls);\n-            debug!(\"{:?}\", self.impling_types);\n-        }\n-\n-        if !self.impling_types.as_ref().unwrap().contains(&item.id) {\n-            cx.span_lint(MISSING_DEBUG_IMPLEMENTATIONS,\n-                         item.span,\n-                         \"type does not implement `fmt::Debug`; consider adding #[derive(Debug)] \\\n-                          or a manual implementation\")\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    DEPRECATED,\n-    Warn,\n-    \"detects use of #[deprecated] items\"\n-}\n-\n-/// Checks for use of items with `#[deprecated]` attributes\n-#[derive(Copy)]\n-pub struct Stability;\n-\n-impl Stability {\n-    fn lint(&self, cx: &Context, _id: ast::DefId, span: Span, stability: &Option<attr::Stability>) {\n-\n-        // deprecated attributes apply in-crate and cross-crate\n-        let (lint, label) = match *stability {\n-            Some(attr::Stability { deprecated_since: Some(_), .. }) =>\n-                (DEPRECATED, \"deprecated\"),\n-            _ => return\n-        };\n-\n-        output(cx, span, stability, lint, label);\n-\n-        fn output(cx: &Context, span: Span, stability: &Option<attr::Stability>,\n-                  lint: &'static Lint, label: &'static str) {\n-            let msg = match *stability {\n-                Some(attr::Stability { reason: Some(ref s), .. }) => {\n-                    format!(\"use of {} item: {}\", label, *s)\n-                }\n-                _ => format!(\"use of {} item\", label)\n-            };\n-\n-            cx.span_lint(lint, span, &msg[..]);\n-        }\n-    }\n-}\n-\n-impl LintPass for Stability {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(DEPRECATED)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        stability::check_item(cx.tcx, item, false,\n-                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        stability::check_expr(cx.tcx, e,\n-                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n-    }\n-\n-    fn check_path(&mut self, cx: &Context, path: &ast::Path, id: ast::NodeId) {\n-        stability::check_path(cx.tcx, path, id,\n-                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n-    }\n-\n-    fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n-        stability::check_pat(cx.tcx, pat,\n-                             &mut |id, sp, stab| self.lint(cx, id, sp, stab))\n-    }\n-}\n-\n-declare_lint! {\n-    pub UNCONDITIONAL_RECURSION,\n-    Warn,\n-    \"functions that cannot return without calling themselves\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnconditionalRecursion;\n-\n-\n-impl LintPass for UnconditionalRecursion {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array![UNCONDITIONAL_RECURSION]\n-    }\n-\n-    fn check_fn(&mut self, cx: &Context, fn_kind: visit::FnKind, _: &ast::FnDecl,\n-                blk: &ast::Block, sp: Span, id: ast::NodeId) {\n-        type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n-                              ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n-\n-        let (name, checker) = match fn_kind {\n-            visit::FkItemFn(name, _, _, _) => (name, id_refers_to_this_fn as F),\n-            visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n-            // closures can't recur, so they don't matter.\n-            visit::FkFnBlock => return\n-        };\n-\n-        let impl_def_id = ty::impl_of_method(cx.tcx, ast_util::local_def(id))\n-            .unwrap_or(ast_util::local_def(ast::DUMMY_NODE_ID));\n-        assert!(ast_util::is_local(impl_def_id));\n-        let impl_node_id = impl_def_id.node;\n-\n-        // Walk through this function (say `f`) looking to see if\n-        // every possible path references itself, i.e. the function is\n-        // called recursively unconditionally. This is done by trying\n-        // to find a path from the entry node to the exit node that\n-        // *doesn't* call `f` by traversing from the entry while\n-        // pretending that calls of `f` are sinks (i.e. ignoring any\n-        // exit edges from them).\n-        //\n-        // NB. this has an edge case with non-returning statements,\n-        // like `loop {}` or `panic!()`: control flow never reaches\n-        // the exit node through these, so one can have a function\n-        // that never actually calls itselfs but is still picked up by\n-        // this lint:\n-        //\n-        //     fn f(cond: bool) {\n-        //         if !cond { panic!() } // could come from `assert!(cond)`\n-        //         f(false)\n-        //     }\n-        //\n-        // In general, functions of that form may be able to call\n-        // itself a finite number of times and then diverge. The lint\n-        // considers this to be an error for two reasons, (a) it is\n-        // easier to implement, and (b) it seems rare to actually want\n-        // to have behaviour like the above, rather than\n-        // e.g. accidentally recurring after an assert.\n-\n-        let cfg = cfg::CFG::new(cx.tcx, blk);\n-\n-        let mut work_queue = vec![cfg.entry];\n-        let mut reached_exit_without_self_call = false;\n-        let mut self_call_spans = vec![];\n-        let mut visited = BitSet::new();\n-\n-        while let Some(idx) = work_queue.pop() {\n-            let cfg_id = idx.node_id();\n-            if idx == cfg.exit {\n-                // found a path!\n-                reached_exit_without_self_call = true;\n-                break\n-            } else if visited.contains(&cfg_id) {\n-                // already done\n-                continue\n-            }\n-            visited.insert(cfg_id);\n-            let node_id = cfg.graph.node_data(idx).id();\n-\n-            // is this a recursive call?\n-            if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {\n-\n-                self_call_spans.push(cx.tcx.map.span(node_id));\n-                // this is a self call, so we shouldn't explore past\n-                // this node in the CFG.\n-                continue\n-            }\n-            // add the successors of this node to explore the graph further.\n-            cfg.graph.each_outgoing_edge(idx, |_, edge| {\n-                let target_idx = edge.target();\n-                let target_cfg_id = target_idx.node_id();\n-                if !visited.contains(&target_cfg_id) {\n-                    work_queue.push(target_idx)\n-                }\n-                true\n-            });\n-        }\n-\n-        // check the number of sell calls because a function that\n-        // doesn't return (e.g. calls a `-> !` function or `loop { /*\n-        // no break */ }`) shouldn't be linted unless it actually\n-        // recurs.\n-        if !reached_exit_without_self_call && self_call_spans.len() > 0 {\n-            cx.span_lint(UNCONDITIONAL_RECURSION, sp,\n-                         \"function cannot return without recurring\");\n-\n-            // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n-            if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n-                let sess = cx.sess();\n-                // offer some help to the programmer.\n-                for call in &self_call_spans {\n-                    sess.span_note(*call, \"recursive call site\")\n-                }\n-                sess.span_help(sp, \"a `loop` may express intention better if this is on purpose\")\n-            }\n-        }\n-\n-        // all done\n-        return;\n-\n-        // Functions for identifying if the given NodeId `id`\n-        // represents a call to the function `fn_id`/method\n-        // `method_id`.\n-\n-        fn id_refers_to_this_fn<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      _: ast::NodeId,\n-                                      fn_id: ast::NodeId,\n-                                      _: ast::Ident,\n-                                      id: ast::NodeId) -> bool {\n-            tcx.def_map.borrow().get(&id)\n-                .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n-        }\n-\n-        // check if the method call `id` refers to method `method_id`\n-        // (with name `method_name` contained in impl `impl_id`).\n-        fn id_refers_to_this_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                          impl_id: ast::NodeId,\n-                                          method_id: ast::NodeId,\n-                                          method_name: ast::Ident,\n-                                          id: ast::NodeId) -> bool {\n-            let did = match tcx.method_map.borrow().get(&ty::MethodCall::expr(id)) {\n-                None => return false,\n-                Some(m) => match m.origin {\n-                    // There's no way to know if a method call via a\n-                    // vtable is recursion, so we assume it's not.\n-                    ty::MethodTraitObject(_) => return false,\n-\n-                    // This `did` refers directly to the method definition.\n-                    ty::MethodStatic(did) | ty::MethodStaticClosure(did) => did,\n-\n-                    // MethodTypeParam are methods from traits:\n-\n-                    // The `impl ... for ...` of this method call\n-                    // isn't known, e.g. it might be a default method\n-                    // in a trait, so we get the def-id of the trait\n-                    // method instead.\n-                    ty::MethodTypeParam(\n-                        ty::MethodParam { ref trait_ref, method_num, impl_def_id: None, }) => {\n-                        ty::trait_item(tcx, trait_ref.def_id, method_num).def_id()\n-                    }\n-\n-                    // The `impl` is known, so we check that with a\n-                    // special case:\n-                    ty::MethodTypeParam(\n-                        ty::MethodParam { impl_def_id: Some(impl_def_id), .. }) => {\n-\n-                        let name = match tcx.map.expect_expr(id).node {\n-                            ast::ExprMethodCall(ref sp_ident, _, _) => sp_ident.node,\n-                            _ => tcx.sess.span_bug(\n-                                tcx.map.span(id),\n-                                \"non-method call expr behaving like a method call?\")\n-                        };\n-                        // it matches if it comes from the same impl,\n-                        // and has the same method name.\n-                        return ast_util::is_local(impl_def_id)\n-                            && impl_def_id.node == impl_id\n-                            && method_name.name == name.name\n-                    }\n-                }\n-            };\n-\n-            ast_util::is_local(did) && did.node == method_id\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    PLUGIN_AS_LIBRARY,\n-    Warn,\n-    \"compiler plugin used as ordinary library in non-plugin crate\"\n-}\n-\n-#[derive(Copy)]\n-pub struct PluginAsLibrary;\n-\n-impl LintPass for PluginAsLibrary {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array![PLUGIN_AS_LIBRARY]\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        if cx.sess().plugin_registrar_fn.get().is_some() {\n-            // We're compiling a plugin; it's fine to link other plugins.\n-            return;\n-        }\n-\n-        match it.node {\n-            ast::ItemExternCrate(..) => (),\n-            _ => return,\n-        };\n-\n-        let md = match cx.sess().cstore.find_extern_mod_stmt_cnum(it.id) {\n-            Some(cnum) => cx.sess().cstore.get_crate_data(cnum),\n-            None => {\n-                // Probably means we aren't linking the crate for some reason.\n-                //\n-                // Not sure if / when this could happen.\n-                return;\n-            }\n-        };\n-\n-        if decoder::get_plugin_registrar_fn(md.data()).is_some() {\n-            cx.span_lint(PLUGIN_AS_LIBRARY, it.span,\n-                \"compiler plugin used as an ordinary library\");\n-        }\n-    }\n-}\n+use lint::{LintPass, LintArray};\n \n declare_lint! {\n     pub UNUSED_IMPORTS,\n@@ -2089,12 +111,6 @@ declare_lint! {\n     \"detects transmutes of fat pointers\"\n }\n \n-declare_lint! {\n-    pub MISSING_COPY_IMPLEMENTATIONS,\n-    Allow,\n-    \"detects potentially-forgotten implementations of `Copy`\"\n-}\n-\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy)]\n@@ -2120,82 +136,3 @@ impl LintPass for HardwiredLints {\n         )\n     }\n }\n-\n-declare_lint! {\n-    PRIVATE_NO_MANGLE_FNS,\n-    Warn,\n-    \"functions marked #[no_mangle] should be exported\"\n-}\n-\n-declare_lint! {\n-    PRIVATE_NO_MANGLE_STATICS,\n-    Warn,\n-    \"statics marked #[no_mangle] should be exported\"\n-}\n-\n-declare_lint! {\n-    NO_MANGLE_CONST_ITEMS,\n-    Deny,\n-    \"const items will not have their symbols exported\"\n-}\n-\n-#[derive(Copy)]\n-pub struct InvalidNoMangleItems;\n-\n-impl LintPass for InvalidNoMangleItems {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(PRIVATE_NO_MANGLE_FNS,\n-                    PRIVATE_NO_MANGLE_STATICS,\n-                    NO_MANGLE_CONST_ITEMS)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        match it.node {\n-            ast::ItemFn(..) => {\n-                if attr::contains_name(&it.attrs, \"no_mangle\") &&\n-                       !cx.exported_items.contains(&it.id) {\n-                    let msg = format!(\"function {} is marked #[no_mangle], but not exported\",\n-                                      it.ident);\n-                    cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, &msg);\n-                }\n-            },\n-            ast::ItemStatic(..) => {\n-                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") &&\n-                       !cx.exported_items.contains(&it.id) {\n-                    let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n-                                      it.ident);\n-                    cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, msg.as_slice());\n-                }\n-            },\n-            ast::ItemConst(..) => {\n-                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") {\n-                    // Const items do not refer to a particular location in memory, and therefore\n-                    // don't have anything to attach a symbol to\n-                    let msg = \"const items should never be #[no_mangle], consider instead using \\\n-                        `pub static`\";\n-                    cx.span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n-                }\n-            }\n-            _ => {},\n-        }\n-    }\n-}\n-\n-/// Forbids using the `#[feature(...)]` attribute\n-#[derive(Copy)]\n-pub struct UnstableFeatures;\n-\n-declare_lint!(UNSTABLE_FEATURES, Allow,\n-              \"enabling unstable features\");\n-\n-impl LintPass for UnstableFeatures {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSTABLE_FEATURES)\n-    }\n-    fn check_attribute(&mut self, ctx: &Context, attr: &ast::Attribute) {\n-        use syntax::attr;\n-        if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n-            ctx.span_lint(UNSTABLE_FEATURES, attr.span, \"unstable feature\");\n-        }\n-    }\n-}"}, {"sha": "2b968736ffd9a6240c5bbca23197535fb00d3349", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 76, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -159,88 +159,14 @@ impl LintStore {\n         }\n     }\n \n-    fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n+    pub fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n         let target = match self.by_name.get(new_name) {\n             Some(&Id(lint_id)) => lint_id.clone(),\n             _ => panic!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n         };\n         self.by_name.insert(old_name.to_string(), Renamed(new_name.to_string(), target));\n     }\n \n-    pub fn register_builtin(&mut self, sess: Option<&Session>) {\n-        macro_rules! add_builtin {\n-            ($sess:ident, $($name:ident),*,) => (\n-                {$(\n-                    self.register_pass($sess, false, box builtin::$name as LintPassObject);\n-                )*}\n-            )\n-        }\n-\n-        macro_rules! add_builtin_with_new {\n-            ($sess:ident, $($name:ident),*,) => (\n-                {$(\n-                    self.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n-                )*}\n-            )\n-        }\n-\n-        macro_rules! add_lint_group {\n-            ($sess:ident, $name:expr, $($lint:ident),*) => (\n-                self.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n-            )\n-        }\n-\n-        add_builtin!(sess,\n-                     HardwiredLints,\n-                     WhileTrue,\n-                     UnusedCasts,\n-                     ImproperCTypes,\n-                     BoxPointers,\n-                     UnusedAttributes,\n-                     PathStatements,\n-                     UnusedResults,\n-                     NonCamelCaseTypes,\n-                     NonSnakeCase,\n-                     NonUpperCaseGlobals,\n-                     UnusedParens,\n-                     UnusedImportBraces,\n-                     NonShorthandFieldPatterns,\n-                     UnusedUnsafe,\n-                     UnsafeCode,\n-                     UnusedMut,\n-                     UnusedAllocation,\n-                     MissingCopyImplementations,\n-                     UnstableFeatures,\n-                     Stability,\n-                     UnconditionalRecursion,\n-                     InvalidNoMangleItems,\n-                     PluginAsLibrary,\n-        );\n-\n-        add_builtin_with_new!(sess,\n-                              TypeLimits,\n-                              RawPointerDerive,\n-                              MissingDoc,\n-                              MissingDebugImplementations,\n-        );\n-\n-        add_lint_group!(sess, \"bad_style\",\n-                        NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPER_CASE_GLOBALS);\n-\n-        add_lint_group!(sess, \"unused\",\n-                        UNUSED_IMPORTS, UNUSED_VARIABLES, UNUSED_ASSIGNMENTS, DEAD_CODE,\n-                        UNUSED_MUT, UNREACHABLE_CODE, UNUSED_MUST_USE,\n-                        UNUSED_UNSAFE, PATH_STATEMENTS);\n-\n-        // We have one lint pass defined in this module.\n-        self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n-\n-        // Insert temporary renamings for a one-time deprecation\n-        self.register_renamed(\"raw_pointer_deriving\", \"raw_pointer_derive\");\n-\n-        self.register_renamed(\"unknown_features\", \"unused_features\");\n-    }\n-\n     #[allow(unused_variables)]\n     fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n                  -> Option<LintId>\n@@ -741,7 +667,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n // nodes, so that the variant size difference check in trans can call\n // `raw_emit_lint`.\n \n-struct GatherNodeLevels;\n+pub struct GatherNodeLevels;\n \n impl LintPass for GatherNodeLevels {\n     fn get_lints(&self) -> LintArray {"}, {"sha": "f3fa3b8846ca2b6d6d6eb175f68873cff5bed564", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -37,7 +37,8 @@ use syntax::codemap::Span;\n use syntax::visit::FnKind;\n use syntax::ast;\n \n-pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs};\n+pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs,\n+                        GatherNodeLevels};\n \n /// Specification of a single lint.\n #[derive(Copy, Debug)]"}, {"sha": "67c39bcca81f9a963fd8d863d57dc562675de040", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use lint;\n use metadata::cstore::CStore;\n use metadata::filesearch;\n@@ -389,7 +388,6 @@ pub fn build_session_(sopts: config::Options,\n         can_print_warnings: can_print_warnings\n     };\n \n-    sess.lint_store.borrow_mut().register_builtin(Some(&sess));\n     sess\n }\n "}, {"sha": "f0c7777b0af12233a104e6ddbf624678a6452d16", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -47,6 +47,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n+extern crate rustc_lint;\n extern crate rustc_privacy;\n extern crate rustc_resolve;\n extern crate rustc_trans;\n@@ -133,6 +134,7 @@ pub fn run_compiler<'a>(args: &[String],\n     };\n \n     let mut sess = build_session(sopts, input_file_path, descriptions);\n+    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     if sess.unstable_options() {\n         sess.opts.show_span = matches.opt_str(\"show-span\");\n     }\n@@ -299,11 +301,12 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             0 => {\n                 if sopts.describe_lints {\n                     let mut ls = lint::LintStore::new();\n-                    ls.register_builtin(None);\n+                    rustc_lint::register_builtins(&mut ls, None);\n                     describe_lints(&ls, false);\n                     return None;\n                 }\n                 let sess = build_session(sopts.clone(), None, descriptions.clone());\n+                rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let should_stop = RustcDefaultCalls::print_crate_info(&sess, None, odir, ofile);\n                 if should_stop == Compilation::Stop {\n                     return None;\n@@ -844,4 +847,3 @@ pub fn main() {\n     let result = run(env::args().collect());\n     std::env::set_exit_status(result as i32);\n }\n-"}, {"sha": "cdbee9da334228d42b0ea48443c0456d6ce7d7b7", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -13,6 +13,7 @@\n use diagnostic;\n use diagnostic::Emitter;\n use driver;\n+use rustc_lint;\n use rustc_resolve as resolve;\n use rustc_typeck::middle::lang_items;\n use rustc_typeck::middle::region::{self, CodeExtent, DestructionScopeData};\n@@ -108,6 +109,7 @@ fn test_env<F>(source_string: &str,\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n     let sess = session::build_session_(options, None, span_diagnostic_handler);\n+    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let krate_config = Vec::new();\n     let input = config::Input::Str(source_string.to_string());\n     let krate = driver::phase_1_parse_input(&sess, krate_config, &input);"}, {"sha": "2ffc33ffb15b9c116a45a271894278b362f09a3a", "filename": "src/librustc_lint/builtin.rs", "status": "added", "additions": 2095, "deletions": 0, "changes": 2095, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -0,0 +1,2095 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Lints built in to rustc.\n+//!\n+//! This is a sibling of `lint::context` in order to ensure that\n+//! lints implemented here use the same public API as lint plugins.\n+//!\n+//! To add a new lint to rustc, declare it here using `declare_lint!()`.\n+//! Then add code to emit the new lint in the appropriate circumstances.\n+//! You can do that in an existing `LintPass` if it makes sense, or in\n+//! a new `LintPass`, or using `Session::add_lint` elsewhere in the\n+//! compiler. Only do the latter if the check can't be written cleanly\n+//! as a `LintPass`.\n+//!\n+//! If you define a new `LintPass`, you will also need to add it to the\n+//! `add_builtin!` or `add_builtin_with_new!` invocation in `context.rs`.\n+//! Use the former for unit-like structs and the latter for structs with\n+//! a `pub fn new()`.\n+\n+use self::MethodContext::*;\n+\n+use metadata::{csearch, decoder};\n+use middle::def::*;\n+use middle::subst::Substs;\n+use middle::ty::{self, Ty};\n+use middle::{def, pat_util, stability};\n+use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n+use middle::cfg;\n+use util::ppaux::{ty_to_string};\n+use util::nodemap::{FnvHashMap, NodeSet};\n+use lint::{Level, Context, LintPass, LintArray, Lint};\n+\n+use std::collections::BitSet;\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::num::SignedInt;\n+use std::{cmp, slice};\n+use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n+\n+use syntax::{abi, ast, ast_map};\n+use syntax::ast_util::is_shift_binop;\n+use syntax::attr::{self, AttrMetaMethods};\n+use syntax::codemap::{self, Span};\n+use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n+use syntax::parse::token;\n+use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n+use syntax::ast_util;\n+use syntax::ptr::P;\n+use syntax::visit::{self, Visitor};\n+\n+// hardwired lints from librustc\n+pub use lint::builtin::*;\n+\n+declare_lint! {\n+    WHILE_TRUE,\n+    Warn,\n+    \"suggest using `loop { }` instead of `while true { }`\"\n+}\n+\n+#[derive(Copy)]\n+pub struct WhileTrue;\n+\n+impl LintPass for WhileTrue {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(WHILE_TRUE)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        if let ast::ExprWhile(ref cond, _, _) = e.node {\n+            if let ast::ExprLit(ref lit) = cond.node {\n+                if let ast::LitBool(true) = lit.node {\n+                    cx.span_lint(WHILE_TRUE, e.span,\n+                                 \"denote infinite loops with loop { ... }\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_TYPECASTS,\n+    Allow,\n+    \"detects unnecessary type casts that can be removed\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnusedCasts;\n+\n+impl LintPass for UnusedCasts {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_TYPECASTS)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        if let ast::ExprCast(ref expr, ref ty) = e.node {\n+            let t_t = ty::expr_ty(cx.tcx, e);\n+            if ty::expr_ty(cx.tcx, &**expr) == t_t {\n+                cx.span_lint(UNUSED_TYPECASTS, ty.span, \"unnecessary type cast\");\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNSIGNED_NEGATION,\n+    Warn,\n+    \"using an unary minus operator on unsigned type\"\n+}\n+\n+declare_lint! {\n+    UNUSED_COMPARISONS,\n+    Warn,\n+    \"comparisons made useless by limits of the types involved\"\n+}\n+\n+declare_lint! {\n+    OVERFLOWING_LITERALS,\n+    Warn,\n+    \"literal out of range for its type\"\n+}\n+\n+declare_lint! {\n+    EXCEEDING_BITSHIFTS,\n+    Deny,\n+    \"shift exceeds the type's number of bits\"\n+}\n+\n+#[derive(Copy)]\n+pub struct TypeLimits {\n+    /// Id of the last visited negated expression\n+    negated_expr_id: ast::NodeId,\n+}\n+\n+impl TypeLimits {\n+    pub fn new() -> TypeLimits {\n+        TypeLimits {\n+            negated_expr_id: -1,\n+        }\n+    }\n+}\n+\n+impl LintPass for TypeLimits {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNSIGNED_NEGATION, UNUSED_COMPARISONS, OVERFLOWING_LITERALS,\n+                    EXCEEDING_BITSHIFTS)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprUnary(ast::UnNeg, ref expr) => {\n+                match expr.node  {\n+                    ast::ExprLit(ref lit) => {\n+                        match lit.node {\n+                            ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n+                                cx.span_lint(UNSIGNED_NEGATION, e.span,\n+                                             \"negation of unsigned int literal may \\\n+                                             be unintentional\");\n+                            },\n+                            _ => ()\n+                        }\n+                    },\n+                    _ => {\n+                        let t = ty::expr_ty(cx.tcx, &**expr);\n+                        match t.sty {\n+                            ty::ty_uint(_) => {\n+                                cx.span_lint(UNSIGNED_NEGATION, e.span,\n+                                             \"negation of unsigned int variable may \\\n+                                             be unintentional\");\n+                            },\n+                            _ => ()\n+                        }\n+                    }\n+                };\n+                // propagate negation, if the negation itself isn't negated\n+                if self.negated_expr_id != e.id {\n+                    self.negated_expr_id = expr.id;\n+                }\n+            },\n+            ast::ExprParen(ref expr) if self.negated_expr_id == e.id => {\n+                self.negated_expr_id = expr.id;\n+            },\n+            ast::ExprBinary(binop, ref l, ref r) => {\n+                if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n+                    cx.span_lint(UNUSED_COMPARISONS, e.span,\n+                                 \"comparison is useless due to type limits\");\n+                }\n+\n+                if is_shift_binop(binop.node) {\n+                    let opt_ty_bits = match ty::expr_ty(cx.tcx, &**l).sty {\n+                        ty::ty_int(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n+                        ty::ty_uint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n+                        _ => None\n+                    };\n+\n+                    if let Some(bits) = opt_ty_bits {\n+                        let exceeding = if let ast::ExprLit(ref lit) = r.node {\n+                            if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n+                            else { false }\n+                        } else {\n+                            match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.uint)) {\n+                                Ok(const_int(shift)) => { shift as u64 >= bits },\n+                                Ok(const_uint(shift)) => { shift >= bits },\n+                                _ => { false }\n+                            }\n+                        };\n+                        if exceeding {\n+                            cx.span_lint(EXCEEDING_BITSHIFTS, e.span,\n+                                         \"bitshift exceeds the type's number of bits\");\n+                        }\n+                    };\n+                }\n+            },\n+            ast::ExprLit(ref lit) => {\n+                match ty::expr_ty(cx.tcx, e).sty {\n+                    ty::ty_int(t) => {\n+                        match lit.node {\n+                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n+                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n+                                let int_type = if let ast::TyIs(_) = t {\n+                                    cx.sess().target.int_type\n+                                } else { t };\n+                                let (min, max) = int_ty_range(int_type);\n+                                let negative = self.negated_expr_id == e.id;\n+\n+                                if (negative && v > (min.abs() as u64)) ||\n+                                   (!negative && v > (max.abs() as u64)) {\n+                                    cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                                                 &*format!(\"literal out of range for {:?}\", t));\n+                                    return;\n+                                }\n+                            }\n+                            _ => panic!()\n+                        };\n+                    },\n+                    ty::ty_uint(t) => {\n+                        let uint_type = if let ast::TyUs(_) = t {\n+                            cx.sess().target.uint_type\n+                        } else { t };\n+                        let (min, max) = uint_ty_range(uint_type);\n+                        let lit_val: u64 = match lit.node {\n+                            ast::LitByte(_v) => return,  // _v is u8, within range by definition\n+                            ast::LitInt(v, _) => v,\n+                            _ => panic!()\n+                        };\n+                        if  lit_val < min || lit_val > max {\n+                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                                         &*format!(\"literal out of range for {:?}\", t));\n+                        }\n+                    },\n+                    ty::ty_float(t) => {\n+                        let (min, max) = float_ty_range(t);\n+                        let lit_val: f64 = match lit.node {\n+                            ast::LitFloat(ref v, _) |\n+                            ast::LitFloatUnsuffixed(ref v) => {\n+                                match v.parse().ok() {\n+                                    Some(f) => f,\n+                                    None => return\n+                                }\n+                            }\n+                            _ => panic!()\n+                        };\n+                        if lit_val < min || lit_val > max {\n+                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                                         &*format!(\"literal out of range for {:?}\", t));\n+                        }\n+                    },\n+                    _ => ()\n+                };\n+            },\n+            _ => ()\n+        };\n+\n+        fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n+                                min: T, max: T) -> bool {\n+            match binop.node {\n+                ast::BiLt => v >  min && v <= max,\n+                ast::BiLe => v >= min && v <  max,\n+                ast::BiGt => v >= min && v <  max,\n+                ast::BiGe => v >  min && v <= max,\n+                ast::BiEq | ast::BiNe => v >= min && v <= max,\n+                _ => panic!()\n+            }\n+        }\n+\n+        fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n+            codemap::respan(binop.span, match binop.node {\n+                ast::BiLt => ast::BiGt,\n+                ast::BiLe => ast::BiGe,\n+                ast::BiGt => ast::BiLt,\n+                ast::BiGe => ast::BiLe,\n+                _ => return binop\n+            })\n+        }\n+\n+        // for int & uint, be conservative with the warnings, so that the\n+        // warnings are consistent between 32- and 64-bit platforms\n+        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n+            match int_ty {\n+                ast::TyIs(_) =>    (i64::MIN,        i64::MAX),\n+                ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n+                ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n+                ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n+                ast::TyI64 =>  (i64::MIN,        i64::MAX)\n+            }\n+        }\n+\n+        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n+            match uint_ty {\n+                ast::TyUs(_) =>   (u64::MIN,         u64::MAX),\n+                ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n+                ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n+                ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n+                ast::TyU64 => (u64::MIN,         u64::MAX)\n+            }\n+        }\n+\n+        fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n+            match float_ty {\n+                ast::TyF32  => (f32::MIN as f64, f32::MAX as f64),\n+                ast::TyF64  => (f64::MIN,        f64::MAX)\n+            }\n+        }\n+\n+        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n+            match int_ty {\n+                ast::TyIs(_) =>    int_ty_bits(target_int_ty, target_int_ty),\n+                ast::TyI8 =>   i8::BITS  as u64,\n+                ast::TyI16 =>  i16::BITS as u64,\n+                ast::TyI32 =>  i32::BITS as u64,\n+                ast::TyI64 =>  i64::BITS as u64\n+            }\n+        }\n+\n+        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n+            match uint_ty {\n+                ast::TyUs(_) =>    uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::TyU8 =>   u8::BITS  as u64,\n+                ast::TyU16 =>  u16::BITS as u64,\n+                ast::TyU32 =>  u32::BITS as u64,\n+                ast::TyU64 =>  u64::BITS as u64\n+            }\n+        }\n+\n+        fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n+                        l: &ast::Expr, r: &ast::Expr) -> bool {\n+            let (lit, expr, swap) = match (&l.node, &r.node) {\n+                (&ast::ExprLit(_), _) => (l, r, true),\n+                (_, &ast::ExprLit(_)) => (r, l, false),\n+                _ => return true\n+            };\n+            // Normalize the binop so that the literal is always on the RHS in\n+            // the comparison\n+            let norm_binop = if swap { rev_binop(binop) } else { binop };\n+            match ty::expr_ty(tcx, expr).sty {\n+                ty::ty_int(int_ty) => {\n+                    let (min, max) = int_ty_range(int_ty);\n+                    let lit_val: i64 = match lit.node {\n+                        ast::ExprLit(ref li) => match li.node {\n+                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n+                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => v as i64,\n+                            ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n+                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Minus)) => -(v as i64),\n+                            _ => return true\n+                        },\n+                        _ => panic!()\n+                    };\n+                    is_valid(norm_binop, lit_val, min, max)\n+                }\n+                ty::ty_uint(uint_ty) => {\n+                    let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n+                    let lit_val: u64 = match lit.node {\n+                        ast::ExprLit(ref li) => match li.node {\n+                            ast::LitInt(v, _) => v,\n+                            _ => return true\n+                        },\n+                        _ => panic!()\n+                    };\n+                    is_valid(norm_binop, lit_val, min, max)\n+                }\n+                _ => true\n+            }\n+        }\n+\n+        fn is_comparison(binop: ast::BinOp) -> bool {\n+            match binop.node {\n+                ast::BiEq | ast::BiLt | ast::BiLe |\n+                ast::BiNe | ast::BiGe | ast::BiGt => true,\n+                _ => false\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    IMPROPER_CTYPES,\n+    Warn,\n+    \"proper use of libc types in foreign modules\"\n+}\n+\n+struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n+    cx: &'a Context<'a, 'tcx>\n+}\n+\n+impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n+    fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n+        match self.cx.tcx.def_map.borrow()[id].full_def() {\n+            def::DefPrimTy(ast::TyInt(ast::TyIs(_))) => {\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n+                                  \"found rust type `isize` in foreign module, while \\\n+                                   libc::c_int or libc::c_long should be used\");\n+            }\n+            def::DefPrimTy(ast::TyUint(ast::TyUs(_))) => {\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n+                                  \"found rust type `usize` in foreign module, while \\\n+                                   libc::c_uint or libc::c_ulong should be used\");\n+            }\n+            def::DefTy(..) => {\n+                let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n+                    Some(&ty::atttce_resolved(t)) => t,\n+                    _ => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n+                };\n+\n+                if !ty::is_ffi_safe(self.cx.tcx, tty) {\n+                    self.cx.span_lint(IMPROPER_CTYPES, sp,\n+                                      \"found type without foreign-function-safe\n+                                      representation annotation in foreign module, consider \\\n+                                      adding a #[repr(...)] attribute to the type\");\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &ast::Ty) {\n+        if let ast::TyPath(..) = ty.node {\n+            self.check_def(ty.span, ty.id);\n+        }\n+        visit::walk_ty(self, ty);\n+    }\n+}\n+\n+#[derive(Copy)]\n+pub struct ImproperCTypes;\n+\n+impl LintPass for ImproperCTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(IMPROPER_CTYPES)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        fn check_ty(cx: &Context, ty: &ast::Ty) {\n+            let mut vis = ImproperCTypesVisitor { cx: cx };\n+            vis.visit_ty(ty);\n+        }\n+\n+        fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n+            for input in &decl.inputs {\n+                check_ty(cx, &*input.ty);\n+            }\n+            if let ast::Return(ref ret_ty) = decl.output {\n+                check_ty(cx, &**ret_ty);\n+            }\n+        }\n+\n+        match it.node {\n+            ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n+                for ni in &nmod.items {\n+                    match ni.node {\n+                        ast::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n+                        ast::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    BOX_POINTERS,\n+    Allow,\n+    \"use of owned (Box type) heap memory\"\n+}\n+\n+#[derive(Copy)]\n+pub struct BoxPointers;\n+\n+impl BoxPointers {\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n+                                 span: Span, ty: Ty<'tcx>) {\n+        let mut n_uniq: usize = 0;\n+        ty::fold_ty(cx.tcx, ty, |t| {\n+            match t.sty {\n+                ty::ty_uniq(_) => {\n+                    n_uniq += 1;\n+                }\n+                _ => ()\n+            };\n+            t\n+        });\n+\n+        if n_uniq > 0 {\n+            let s = ty_to_string(cx.tcx, ty);\n+            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n+            cx.span_lint(BOX_POINTERS, span, &m[..]);\n+        }\n+    }\n+}\n+\n+impl LintPass for BoxPointers {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(BOX_POINTERS)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemFn(..) |\n+            ast::ItemTy(..) |\n+            ast::ItemEnum(..) |\n+            ast::ItemStruct(..) =>\n+                self.check_heap_type(cx, it.span,\n+                                     ty::node_id_to_type(cx.tcx, it.id)),\n+            _ => ()\n+        }\n+\n+        // If it's a struct, we also have to check the fields' types\n+        match it.node {\n+            ast::ItemStruct(ref struct_def, _) => {\n+                for struct_field in &struct_def.fields {\n+                    self.check_heap_type(cx, struct_field.span,\n+                                         ty::node_id_to_type(cx.tcx, struct_field.node.id));\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        let ty = ty::expr_ty(cx.tcx, e);\n+        self.check_heap_type(cx, e.span, ty);\n+    }\n+}\n+\n+declare_lint! {\n+    RAW_POINTER_DERIVE,\n+    Warn,\n+    \"uses of #[derive] with raw pointers are rarely correct\"\n+}\n+\n+struct RawPtrDeriveVisitor<'a, 'tcx: 'a> {\n+    cx: &'a Context<'a, 'tcx>\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDeriveVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &ast::Ty) {\n+        static MSG: &'static str = \"use of `#[derive]` with a raw pointer\";\n+        if let ast::TyPtr(..) = ty.node {\n+            self.cx.span_lint(RAW_POINTER_DERIVE, ty.span, MSG);\n+        }\n+        visit::walk_ty(self, ty);\n+    }\n+    // explicit override to a no-op to reduce code bloat\n+    fn visit_expr(&mut self, _: &ast::Expr) {}\n+    fn visit_block(&mut self, _: &ast::Block) {}\n+}\n+\n+pub struct RawPointerDerive {\n+    checked_raw_pointers: NodeSet,\n+}\n+\n+impl RawPointerDerive {\n+    pub fn new() -> RawPointerDerive {\n+        RawPointerDerive {\n+            checked_raw_pointers: NodeSet(),\n+        }\n+    }\n+}\n+\n+impl LintPass for RawPointerDerive {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(RAW_POINTER_DERIVE)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n+            return\n+        }\n+        let did = match item.node {\n+            ast::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n+                // Deriving the Copy trait does not cause a warning\n+                if let &Some(ref trait_ref) = t_ref_opt {\n+                    let def_id = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n+                    if Some(def_id) == cx.tcx.lang_items.copy_trait() {\n+                        return\n+                    }\n+                }\n+\n+                match ty::node_id_to_type(cx.tcx, item.id).sty {\n+                    ty::ty_enum(did, _) => did,\n+                    ty::ty_struct(did, _) => did,\n+                    _ => return,\n+                }\n+            }\n+            _ => return,\n+        };\n+        if !ast_util::is_local(did) { return }\n+        let item = match cx.tcx.map.find(did.node) {\n+            Some(ast_map::NodeItem(item)) => item,\n+            _ => return,\n+        };\n+        if !self.checked_raw_pointers.insert(item.id) { return }\n+        match item.node {\n+            ast::ItemStruct(..) | ast::ItemEnum(..) => {\n+                let mut visitor = RawPtrDeriveVisitor { cx: cx };\n+                visit::walk_item(&mut visitor, &*item);\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_ATTRIBUTES,\n+    Warn,\n+    \"detects attributes that were not used by the compiler\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnusedAttributes;\n+\n+impl LintPass for UnusedAttributes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_ATTRIBUTES)\n+    }\n+\n+    fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n+        for &(ref name, ty) in KNOWN_ATTRIBUTES {\n+            match ty {\n+                AttributeType::Whitelisted\n+                | AttributeType::Gated(_, _) if attr.check_name(name) => {\n+                    break;\n+                },\n+                _ => ()\n+            }\n+        }\n+\n+        if !attr::is_used(attr) {\n+            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n+            if KNOWN_ATTRIBUTES.contains(&(&attr.name(), AttributeType::CrateLevel)) {\n+                let msg = match attr.node.style {\n+                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n+                                       attribute: add an exclamation mark: #![foo]\",\n+                    ast::AttrInner => \"crate-level attribute should be in the \\\n+                                       root module\",\n+                };\n+                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub PATH_STATEMENTS,\n+    Warn,\n+    \"path statements with no effect\"\n+}\n+\n+#[derive(Copy)]\n+pub struct PathStatements;\n+\n+impl LintPass for PathStatements {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(PATH_STATEMENTS)\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        match s.node {\n+            ast::StmtSemi(ref expr, _) => {\n+                match expr.node {\n+                    ast::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n+                                                      \"path statement with no effect\"),\n+                    _ => ()\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub UNUSED_MUST_USE,\n+    Warn,\n+    \"unused result of a type flagged as #[must_use]\"\n+}\n+\n+declare_lint! {\n+    pub UNUSED_RESULTS,\n+    Allow,\n+    \"unused result of an expression in a statement\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnusedResults;\n+\n+impl LintPass for UnusedResults {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        let expr = match s.node {\n+            ast::StmtSemi(ref expr, _) => &**expr,\n+            _ => return\n+        };\n+\n+        if let ast::ExprRet(..) = expr.node {\n+            return;\n+        }\n+\n+        let t = ty::expr_ty(cx.tcx, expr);\n+        let mut warned = false;\n+        match t.sty {\n+            ty::ty_tup(ref tys) if tys.is_empty() => return,\n+            ty::ty_bool => return,\n+            ty::ty_struct(did, _) |\n+            ty::ty_enum(did, _) => {\n+                if ast_util::is_local(did) {\n+                    if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n+                        warned |= check_must_use(cx, &it.attrs, s.span);\n+                    }\n+                } else {\n+                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n+                    warned |= check_must_use(cx, &attrs[..], s.span);\n+                }\n+            }\n+            _ => {}\n+        }\n+        if !warned {\n+            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n+        }\n+\n+        fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n+            for attr in attrs {\n+                if attr.check_name(\"must_use\") {\n+                    let mut msg = \"unused result which must be used\".to_string();\n+                    // check for #[must_use=\"...\"]\n+                    match attr.value_str() {\n+                        None => {}\n+                        Some(s) => {\n+                            msg.push_str(\": \");\n+                            msg.push_str(&s);\n+                        }\n+                    }\n+                    cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n+                    return true;\n+                }\n+            }\n+            false\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub NON_CAMEL_CASE_TYPES,\n+    Warn,\n+    \"types, variants, traits and type parameters should have camel case names\"\n+}\n+\n+#[derive(Copy)]\n+pub struct NonCamelCaseTypes;\n+\n+impl NonCamelCaseTypes {\n+    fn check_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+        fn is_camel_case(ident: ast::Ident) -> bool {\n+            let ident = token::get_ident(ident);\n+            if ident.is_empty() { return true; }\n+            let ident = ident.trim_matches('_');\n+\n+            // start with a non-lowercase letter rather than non-uppercase\n+            // ones (some scripts don't have a concept of upper/lowercase)\n+            ident.len() > 0 && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n+        }\n+\n+        fn to_camel_case(s: &str) -> String {\n+            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n+                if i == 0 { c.to_uppercase() }\n+                else { c }\n+            )).collect()\n+        }\n+\n+        let s = token::get_ident(ident);\n+\n+        if !is_camel_case(ident) {\n+            let c = to_camel_case(&s);\n+            let m = if c.is_empty() {\n+                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n+            } else {\n+                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n+            };\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n+        }\n+    }\n+}\n+\n+impl LintPass for NonCamelCaseTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_CAMEL_CASE_TYPES)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        let has_extern_repr = it.attrs.iter().map(|attr| {\n+            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n+                .any(|r| r == &attr::ReprExtern)\n+        }).any(|x| x);\n+        if has_extern_repr { return }\n+\n+        match it.node {\n+            ast::ItemTy(..) | ast::ItemStruct(..) => {\n+                self.check_case(cx, \"type\", it.ident, it.span)\n+            }\n+            ast::ItemTrait(..) => {\n+                self.check_case(cx, \"trait\", it.ident, it.span)\n+            }\n+            ast::ItemEnum(ref enum_definition, _) => {\n+                if has_extern_repr { return }\n+                self.check_case(cx, \"type\", it.ident, it.span);\n+                for variant in &enum_definition.variants {\n+                    self.check_case(cx, \"variant\", variant.node.name, variant.span);\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_generics(&mut self, cx: &Context, it: &ast::Generics) {\n+        for gen in &*it.ty_params {\n+            self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq)]\n+enum MethodContext {\n+    TraitDefaultImpl,\n+    TraitImpl,\n+    PlainImpl\n+}\n+\n+fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n+    let did = ast::DefId {\n+        krate: ast::LOCAL_CRATE,\n+        node: m.id\n+    };\n+\n+    match cx.tcx.impl_or_trait_items.borrow().get(&did).cloned() {\n+        None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n+        Some(md) => {\n+            match md {\n+                ty::MethodTraitItem(md) => {\n+                    match md.container {\n+                        ty::TraitContainer(..) => TraitDefaultImpl,\n+                        ty::ImplContainer(cid) => {\n+                            match ty::impl_trait_ref(cx.tcx, cid) {\n+                                Some(..) => TraitImpl,\n+                                None => PlainImpl\n+                            }\n+                        }\n+                    }\n+                }\n+                ty::TypeTraitItem(typedef) => {\n+                    match typedef.container {\n+                        ty::TraitContainer(..) => TraitDefaultImpl,\n+                        ty::ImplContainer(cid) => {\n+                            match ty::impl_trait_ref(cx.tcx, cid) {\n+                                Some(..) => TraitImpl,\n+                                None => PlainImpl\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub NON_SNAKE_CASE,\n+    Warn,\n+    \"methods, functions, lifetime parameters and modules should have snake case names\"\n+}\n+\n+#[derive(Copy)]\n+pub struct NonSnakeCase;\n+\n+impl NonSnakeCase {\n+    fn to_snake_case(mut str: &str) -> String {\n+        let mut words = vec![];\n+        // Preserve leading underscores\n+        str = str.trim_left_matches(|c: char| {\n+            if c == '_' {\n+                words.push(String::new());\n+                true\n+            } else { false }\n+        });\n+        for s in str.split('_') {\n+            let mut last_upper = false;\n+            let mut buf = String::new();\n+            if s.is_empty() { continue; }\n+            for ch in s.chars() {\n+                if !buf.is_empty() && buf != \"'\"\n+                                   && ch.is_uppercase()\n+                                   && !last_upper {\n+                    words.push(buf);\n+                    buf = String::new();\n+                }\n+                last_upper = ch.is_uppercase();\n+                buf.push(ch.to_lowercase());\n+            }\n+            words.push(buf);\n+        }\n+        words.connect(\"_\")\n+    }\n+\n+    fn check_snake_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+        fn is_snake_case(ident: ast::Ident) -> bool {\n+            let ident = token::get_ident(ident);\n+            if ident.is_empty() { return true; }\n+            let ident = ident.trim_left_matches('\\'');\n+            let ident = ident.trim_matches('_');\n+\n+            let mut allow_underscore = true;\n+            ident.chars().all(|c| {\n+                allow_underscore = match c {\n+                    '_' if !allow_underscore => return false,\n+                    '_' => false,\n+                    c if !c.is_uppercase() => true,\n+                    _ => return false,\n+                };\n+                true\n+            })\n+        }\n+\n+        let s = token::get_ident(ident);\n+\n+        if !is_snake_case(ident) {\n+            let sc = NonSnakeCase::to_snake_case(&s);\n+            if sc != &s[..] {\n+                cx.span_lint(NON_SNAKE_CASE, span,\n+                    &*format!(\"{} `{}` should have a snake case name such as `{}`\",\n+                            sort, s, sc));\n+            } else {\n+                cx.span_lint(NON_SNAKE_CASE, span,\n+                    &*format!(\"{} `{}` should have a snake case name\",\n+                            sort, s));\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for NonSnakeCase {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_SNAKE_CASE)\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context,\n+                fk: visit::FnKind, _: &ast::FnDecl,\n+                _: &ast::Block, span: Span, _: ast::NodeId) {\n+        match fk {\n+            visit::FkMethod(ident, _, m) => match method_context(cx, m) {\n+                PlainImpl\n+                    => self.check_snake_case(cx, \"method\", ident, span),\n+                TraitDefaultImpl\n+                    => self.check_snake_case(cx, \"trait method\", ident, span),\n+                _ => (),\n+            },\n+            visit::FkItemFn(ident, _, _, _)\n+                => self.check_snake_case(cx, \"function\", ident, span),\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        if let ast::ItemMod(_) = it.node {\n+            self.check_snake_case(cx, \"module\", it.ident, it.span);\n+        }\n+    }\n+\n+    fn check_ty_method(&mut self, cx: &Context, t: &ast::TypeMethod) {\n+        self.check_snake_case(cx, \"trait method\", t.ident, t.span);\n+    }\n+\n+    fn check_lifetime_def(&mut self, cx: &Context, t: &ast::LifetimeDef) {\n+        self.check_snake_case(cx, \"lifetime\", t.lifetime.name.ident(), t.lifetime.span);\n+    }\n+\n+    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n+        if let &ast::PatIdent(_, ref path1, _) = &p.node {\n+            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n+            if let Some(def::DefLocal(_)) = def {\n+                self.check_snake_case(cx, \"variable\", path1.node, p.span);\n+            }\n+        }\n+    }\n+\n+    fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n+            _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n+        for sf in &s.fields {\n+            if let ast::StructField_ { kind: ast::NamedField(ident, _), .. } = sf.node {\n+                self.check_snake_case(cx, \"structure field\", ident, sf.span);\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub NON_UPPER_CASE_GLOBALS,\n+    Warn,\n+    \"static constants should have uppercase identifiers\"\n+}\n+\n+#[derive(Copy)]\n+pub struct NonUpperCaseGlobals;\n+\n+impl NonUpperCaseGlobals {\n+    fn check_upper_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n+        let s = token::get_ident(ident);\n+\n+        if s.chars().any(|c| c.is_lowercase()) {\n+            let uc: String = NonSnakeCase::to_snake_case(&s).chars()\n+                                           .map(|c| c.to_uppercase()).collect();\n+            if uc != &s[..] {\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n+                    &format!(\"{} `{}` should have an upper case name such as `{}`\",\n+                             sort, s, uc));\n+            } else {\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n+                    &format!(\"{} `{}` should have an upper case name\",\n+                             sort, s));\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for NonUpperCaseGlobals {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_UPPER_CASE_GLOBALS)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            // only check static constants\n+            ast::ItemStatic(_, ast::MutImmutable, _) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n+            }\n+            ast::ItemConst(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n+        // Lint for constants that look like binding identifiers (#7526)\n+        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n+            (&ast::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n+                                                      path1.node, p.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_PARENS,\n+    Warn,\n+    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnusedParens;\n+\n+impl UnusedParens {\n+    fn check_unused_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n+                                     struct_lit_needs_parens: bool) {\n+        if let ast::ExprParen(ref inner) = value.node {\n+            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n+            if !necessary {\n+                cx.span_lint(UNUSED_PARENS, value.span,\n+                             &format!(\"unnecessary parentheses around {}\",\n+                                     msg))\n+            }\n+        }\n+\n+        /// Expressions that syntactically contain an \"exterior\" struct\n+        /// literal i.e. not surrounded by any parens or other\n+        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n+        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n+        /// y: 1 }) == foo` does not.\n+        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n+            match value.node {\n+                ast::ExprStruct(..) => true,\n+\n+                ast::ExprAssign(ref lhs, ref rhs) |\n+                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+                ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                    // X { y: 1 } + X { y: 2 }\n+                    contains_exterior_struct_lit(&**lhs) ||\n+                        contains_exterior_struct_lit(&**rhs)\n+                }\n+                ast::ExprUnary(_, ref x) |\n+                ast::ExprCast(ref x, _) |\n+                ast::ExprField(ref x, _) |\n+                ast::ExprTupField(ref x, _) |\n+                ast::ExprIndex(ref x, _) => {\n+                    // &X { y: 1 }, X { y: 1 }.y\n+                    contains_exterior_struct_lit(&**x)\n+                }\n+\n+                ast::ExprMethodCall(_, _, ref exprs) => {\n+                    // X { y: 1 }.bar(...)\n+                    contains_exterior_struct_lit(&*exprs[0])\n+                }\n+\n+                _ => false\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for UnusedParens {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_PARENS)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        let (value, msg, struct_lit_needs_parens) = match e.node {\n+            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n+            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n+            ast::ExprMatch(ref head, _, source) => match source {\n+                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n+                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n+                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n+                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n+            },\n+            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n+            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n+            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n+            _ => return\n+        };\n+        self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        let (value, msg) = match s.node {\n+            ast::StmtDecl(ref decl, _) => match decl.node {\n+                ast::DeclLocal(ref local) => match local.init {\n+                    Some(ref value) => (value, \"assigned value\"),\n+                    None => return\n+                },\n+                _ => return\n+            },\n+            _ => return\n+        };\n+        self.check_unused_parens_core(cx, &**value, msg, false);\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_IMPORT_BRACES,\n+    Allow,\n+    \"unnecessary braces around an imported item\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnusedImportBraces;\n+\n+impl LintPass for UnusedImportBraces {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_IMPORT_BRACES)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ast::ViewPathList(_, ref items) => {\n+                        if items.len() == 1 {\n+                            match items[0].node {\n+                                ast::PathListIdent {ref name, ..} => {\n+                                    let m = format!(\"braces around {} is unnecessary\",\n+                                                    &token::get_ident(*name));\n+                                    cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n+                                                 &m[..]);\n+                                },\n+                                _ => ()\n+                            }\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            },\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    NON_SHORTHAND_FIELD_PATTERNS,\n+    Warn,\n+    \"using `Struct { x: x }` instead of `Struct { x }`\"\n+}\n+\n+#[derive(Copy)]\n+pub struct NonShorthandFieldPatterns;\n+\n+impl LintPass for NonShorthandFieldPatterns {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_SHORTHAND_FIELD_PATTERNS)\n+    }\n+\n+    fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n+        let def_map = cx.tcx.def_map.borrow();\n+        if let ast::PatStruct(_, ref v, _) = pat.node {\n+            let field_pats = v.iter()\n+                              .filter(|fieldpat| !fieldpat.node.is_shorthand)\n+                              .filter(|fieldpat| {\n+                let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n+                def == Some(def::DefLocal(fieldpat.node.pat.id))\n+            });\n+            for fieldpat in field_pats {\n+                if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n+                    if ident.node.as_str() == fieldpat.node.ident.as_str() {\n+                        cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n+                                     &format!(\"the `{}:` in this pattern is redundant and can \\\n+                                              be removed\", ident.node.as_str()))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub UNUSED_UNSAFE,\n+    Warn,\n+    \"unnecessary use of an `unsafe` block\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnusedUnsafe;\n+\n+impl LintPass for UnusedUnsafe {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_UNSAFE)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        if let ast::ExprBlock(ref blk) = e.node {\n+            // Don't warn about generated blocks, that'll just pollute the output.\n+            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n+                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNSAFE_CODE,\n+    Allow,\n+    \"usage of `unsafe` code\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnsafeCode;\n+\n+impl LintPass for UnsafeCode {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNSAFE_CODE)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        if let ast::ExprBlock(ref blk) = e.node {\n+            // Don't warn about generated blocks, that'll just pollute the output.\n+            if blk.rules == ast::UnsafeBlock(ast::UserProvided) {\n+                cx.span_lint(UNSAFE_CODE, blk.span, \"usage of an `unsafe` block\");\n+            }\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemTrait(ast::Unsafety::Unsafe, _, _, _) =>\n+                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\"),\n+\n+            ast::ItemImpl(ast::Unsafety::Unsafe, _, _, _, _, _) =>\n+                cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\"),\n+\n+            _ => return,\n+        }\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context, fk: visit::FnKind, _: &ast::FnDecl,\n+                _: &ast::Block, span: Span, _: ast::NodeId) {\n+        match fk {\n+            visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _) =>\n+                cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n+\n+            visit::FkMethod(_, _, m) => {\n+                if let ast::Method_::MethDecl(_, _, _, _, ast::Unsafety::Unsafe, _, _, _) = m.node {\n+                    cx.span_lint(UNSAFE_CODE, m.span, \"implementation of an `unsafe` method\")\n+                }\n+            },\n+\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_ty_method(&mut self, cx: &Context, ty_method: &ast::TypeMethod) {\n+        if let ast::TypeMethod { unsafety: ast::Unsafety::Unsafe, span, ..} = *ty_method {\n+            cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` method\")\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub UNUSED_MUT,\n+    Warn,\n+    \"detect mut variables which don't need to be mutable\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnusedMut;\n+\n+impl UnusedMut {\n+    fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<ast::Pat>]) {\n+        // collect all mutable pattern and group their NodeIDs by their Identifier to\n+        // avoid false warnings in match arms with multiple patterns\n+\n+        let mut mutables = FnvHashMap();\n+        for p in pats {\n+            pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n+                let ident = path1.node;\n+                if let ast::BindByValue(ast::MutMutable) = mode {\n+                    if !token::get_ident(ident).starts_with(\"_\") {\n+                        match mutables.entry(ident.name.usize()) {\n+                            Vacant(entry) => { entry.insert(vec![id]); },\n+                            Occupied(mut entry) => { entry.get_mut().push(id); },\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+\n+        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n+        for (_, v) in &mutables {\n+            if !v.iter().any(|e| used_mutables.contains(e)) {\n+                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n+                             \"variable does not need to be mutable\");\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for UnusedMut {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_MUT)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        if let ast::ExprMatch(_, ref arms, _) = e.node {\n+            for a in arms {\n+                self.check_unused_mut_pat(cx, &a.pats)\n+            }\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n+        if let ast::StmtDecl(ref d, _) = s.node {\n+            if let ast::DeclLocal(ref l) = d.node {\n+                self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n+            }\n+        }\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context,\n+                _: visit::FnKind, decl: &ast::FnDecl,\n+                _: &ast::Block, _: Span, _: ast::NodeId) {\n+        for a in &decl.inputs {\n+            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_ALLOCATION,\n+    Warn,\n+    \"detects unnecessary allocations that can be eliminated\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnusedAllocation;\n+\n+impl LintPass for UnusedAllocation {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_ALLOCATION)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        match e.node {\n+            ast::ExprUnary(ast::UnUniq, _) => (),\n+            _ => return\n+        }\n+\n+        if let Some(adjustment) = cx.tcx.adjustments.borrow().get(&e.id) {\n+            if let ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) = *adjustment {\n+                match autoref {\n+                    &Some(ty::AutoPtr(_, ast::MutImmutable, None)) => {\n+                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                                     \"unnecessary allocation, use & instead\");\n+                    }\n+                    &Some(ty::AutoPtr(_, ast::MutMutable, None)) => {\n+                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                                     \"unnecessary allocation, use &mut instead\");\n+                    }\n+                    _ => ()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    MISSING_DOCS,\n+    Allow,\n+    \"detects missing documentation for public members\"\n+}\n+\n+pub struct MissingDoc {\n+    /// Stack of IDs of struct definitions.\n+    struct_def_stack: Vec<ast::NodeId>,\n+\n+    /// True if inside variant definition\n+    in_variant: bool,\n+\n+    /// Stack of whether #[doc(hidden)] is set\n+    /// at each level which has lint attributes.\n+    doc_hidden_stack: Vec<bool>,\n+}\n+\n+impl MissingDoc {\n+    pub fn new() -> MissingDoc {\n+        MissingDoc {\n+            struct_def_stack: vec!(),\n+            in_variant: false,\n+            doc_hidden_stack: vec!(false),\n+        }\n+    }\n+\n+    fn doc_hidden(&self) -> bool {\n+        *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n+    }\n+\n+    fn check_missing_docs_attrs(&self,\n+                               cx: &Context,\n+                               id: Option<ast::NodeId>,\n+                               attrs: &[ast::Attribute],\n+                               sp: Span,\n+                               desc: &'static str) {\n+        // If we're building a test harness, then warning about\n+        // documentation is probably not really relevant right now.\n+        if cx.sess().opts.test { return }\n+\n+        // `#[doc(hidden)]` disables missing_docs check.\n+        if self.doc_hidden() { return }\n+\n+        // Only check publicly-visible items, using the result from the privacy pass.\n+        // It's an option so the crate root can also use this function (it doesn't\n+        // have a NodeId).\n+        if let Some(ref id) = id {\n+            if !cx.exported_items.contains(id) {\n+                return;\n+            }\n+        }\n+\n+        let has_doc = attrs.iter().any(|a| {\n+            match a.node.value.node {\n+                ast::MetaNameValue(ref name, _) if *name == \"doc\" => true,\n+                _ => false\n+            }\n+        });\n+        if !has_doc {\n+            cx.span_lint(MISSING_DOCS, sp,\n+                &format!(\"missing documentation for {}\", desc));\n+        }\n+    }\n+}\n+\n+impl LintPass for MissingDoc {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MISSING_DOCS)\n+    }\n+\n+    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n+        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n+            attr.check_name(\"doc\") && match attr.meta_item_list() {\n+                None => false,\n+                Some(l) => attr::contains_name(&l[..], \"hidden\"),\n+            }\n+        });\n+        self.doc_hidden_stack.push(doc_hidden);\n+    }\n+\n+    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) {\n+        self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n+    }\n+\n+    fn check_struct_def(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+        self.struct_def_stack.push(id);\n+    }\n+\n+    fn check_struct_def_post(&mut self, _: &Context,\n+        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+        let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n+        assert!(popped == id);\n+    }\n+\n+    fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n+        self.check_missing_docs_attrs(cx, None, &krate.attrs,\n+                                     krate.span, \"crate\");\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        let desc = match it.node {\n+            ast::ItemFn(..) => \"a function\",\n+            ast::ItemMod(..) => \"a module\",\n+            ast::ItemEnum(..) => \"an enum\",\n+            ast::ItemStruct(..) => \"a struct\",\n+            ast::ItemTrait(..) => \"a trait\",\n+            ast::ItemTy(..) => \"a type alias\",\n+            _ => return\n+        };\n+        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs,\n+                                     it.span, desc);\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context,\n+            fk: visit::FnKind, _: &ast::FnDecl,\n+            _: &ast::Block, _: Span, _: ast::NodeId) {\n+        if let visit::FkMethod(_, _, m) = fk {\n+            // If the method is an impl for a trait, don't doc.\n+            if method_context(cx, m) == TraitImpl { return; }\n+\n+            // Otherwise, doc according to privacy. This will also check\n+            // doc for default methods defined on traits.\n+            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs,\n+                                          m.span, \"a method\");\n+        }\n+    }\n+\n+    fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n+        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs,\n+                                     tm.span, \"a type method\");\n+    }\n+\n+    fn check_trait_method(&mut self, cx: &Context, it: &ast::TraitItem) {\n+        if let ast::TraitItem::TypeTraitItem(ref ty) = *it {\n+            let assoc_ty = &ty.ty_param;\n+            self.check_missing_docs_attrs(cx, Some(assoc_ty.id), &ty.attrs,\n+                                          assoc_ty.span, \"an associated type\");\n+        }\n+    }\n+\n+    fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n+        if let ast::NamedField(_, vis) = sf.node.kind {\n+            if vis == ast::Public || self.in_variant {\n+                let cur_struct_def = *self.struct_def_stack.last()\n+                    .expect(\"empty struct_def_stack\");\n+                self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n+                                              &sf.node.attrs, sf.span,\n+                                              \"a struct field\")\n+            }\n+        }\n+    }\n+\n+    fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs,\n+                                     v.span, \"a variant\");\n+        assert!(!self.in_variant);\n+        self.in_variant = true;\n+    }\n+\n+    fn check_variant_post(&mut self, _: &Context, _: &ast::Variant, _: &ast::Generics) {\n+        assert!(self.in_variant);\n+        self.in_variant = false;\n+    }\n+}\n+\n+declare_lint! {\n+    pub MISSING_COPY_IMPLEMENTATIONS,\n+    Allow,\n+    \"detects potentially-forgotten implementations of `Copy`\"\n+}\n+\n+#[derive(Copy)]\n+pub struct MissingCopyImplementations;\n+\n+impl LintPass for MissingCopyImplementations {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MISSING_COPY_IMPLEMENTATIONS)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        if !cx.exported_items.contains(&item.id) {\n+            return\n+        }\n+        if cx.tcx\n+             .destructor_for_type\n+             .borrow()\n+             .contains_key(&ast_util::local_def(item.id)) {\n+            return\n+        }\n+        let ty = match item.node {\n+            ast::ItemStruct(_, ref ast_generics) => {\n+                if ast_generics.is_parameterized() {\n+                    return\n+                }\n+                ty::mk_struct(cx.tcx,\n+                              ast_util::local_def(item.id),\n+                              cx.tcx.mk_substs(Substs::empty()))\n+            }\n+            ast::ItemEnum(_, ref ast_generics) => {\n+                if ast_generics.is_parameterized() {\n+                    return\n+                }\n+                ty::mk_enum(cx.tcx,\n+                            ast_util::local_def(item.id),\n+                            cx.tcx.mk_substs(Substs::empty()))\n+            }\n+            _ => return,\n+        };\n+        let parameter_environment = ty::empty_parameter_environment(cx.tcx);\n+        if !ty::type_moves_by_default(&parameter_environment, item.span, ty) {\n+            return\n+        }\n+        if ty::can_type_implement_copy(&parameter_environment, item.span, ty).is_ok() {\n+            cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n+                         item.span,\n+                         \"type could implement `Copy`; consider adding `impl \\\n+                          Copy`\")\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    MISSING_DEBUG_IMPLEMENTATIONS,\n+    Allow,\n+    \"detects missing implementations of fmt::Debug\"\n+}\n+\n+pub struct MissingDebugImplementations {\n+    impling_types: Option<NodeSet>,\n+}\n+\n+impl MissingDebugImplementations {\n+    pub fn new() -> MissingDebugImplementations {\n+        MissingDebugImplementations {\n+            impling_types: None,\n+        }\n+    }\n+}\n+\n+impl LintPass for MissingDebugImplementations {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MISSING_DEBUG_IMPLEMENTATIONS)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        if !cx.exported_items.contains(&item.id) {\n+            return;\n+        }\n+\n+        match item.node {\n+            ast::ItemStruct(..) | ast::ItemEnum(..) => {},\n+            _ => return,\n+        }\n+\n+        let debug = match cx.tcx.lang_items.debug_trait() {\n+            Some(debug) => debug,\n+            None => return,\n+        };\n+\n+        if self.impling_types.is_none() {\n+            let impls = cx.tcx.trait_impls.borrow();\n+            let impls = match impls.get(&debug) {\n+                Some(impls) => {\n+                    impls.borrow().iter()\n+                        .filter(|d| d.krate == ast::LOCAL_CRATE)\n+                        .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n+                        .map(|d| d.node)\n+                        .collect()\n+                }\n+                None => NodeSet(),\n+            };\n+            self.impling_types = Some(impls);\n+            debug!(\"{:?}\", self.impling_types);\n+        }\n+\n+        if !self.impling_types.as_ref().unwrap().contains(&item.id) {\n+            cx.span_lint(MISSING_DEBUG_IMPLEMENTATIONS,\n+                         item.span,\n+                         \"type does not implement `fmt::Debug`; consider adding #[derive(Debug)] \\\n+                          or a manual implementation\")\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    DEPRECATED,\n+    Warn,\n+    \"detects use of #[deprecated] items\"\n+}\n+\n+/// Checks for use of items with `#[deprecated]` attributes\n+#[derive(Copy)]\n+pub struct Stability;\n+\n+impl Stability {\n+    fn lint(&self, cx: &Context, _id: ast::DefId, span: Span, stability: &Option<attr::Stability>) {\n+\n+        // deprecated attributes apply in-crate and cross-crate\n+        let (lint, label) = match *stability {\n+            Some(attr::Stability { deprecated_since: Some(_), .. }) =>\n+                (DEPRECATED, \"deprecated\"),\n+            _ => return\n+        };\n+\n+        output(cx, span, stability, lint, label);\n+\n+        fn output(cx: &Context, span: Span, stability: &Option<attr::Stability>,\n+                  lint: &'static Lint, label: &'static str) {\n+            let msg = match *stability {\n+                Some(attr::Stability { reason: Some(ref s), .. }) => {\n+                    format!(\"use of {} item: {}\", label, *s)\n+                }\n+                _ => format!(\"use of {} item\", label)\n+            };\n+\n+            cx.span_lint(lint, span, &msg[..]);\n+        }\n+    }\n+}\n+\n+impl LintPass for Stability {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DEPRECATED)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        stability::check_item(cx.tcx, item, false,\n+                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        stability::check_expr(cx.tcx, e,\n+                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+    }\n+\n+    fn check_path(&mut self, cx: &Context, path: &ast::Path, id: ast::NodeId) {\n+        stability::check_path(cx.tcx, path, id,\n+                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+    }\n+\n+    fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n+        stability::check_pat(cx.tcx, pat,\n+                             &mut |id, sp, stab| self.lint(cx, id, sp, stab))\n+    }\n+}\n+\n+declare_lint! {\n+    pub UNCONDITIONAL_RECURSION,\n+    Warn,\n+    \"functions that cannot return without calling themselves\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnconditionalRecursion;\n+\n+\n+impl LintPass for UnconditionalRecursion {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![UNCONDITIONAL_RECURSION]\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context, fn_kind: visit::FnKind, _: &ast::FnDecl,\n+                blk: &ast::Block, sp: Span, id: ast::NodeId) {\n+        type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n+                              ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n+\n+        let (name, checker) = match fn_kind {\n+            visit::FkItemFn(name, _, _, _) => (name, id_refers_to_this_fn as F),\n+            visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n+            // closures can't recur, so they don't matter.\n+            visit::FkFnBlock => return\n+        };\n+\n+        let impl_def_id = ty::impl_of_method(cx.tcx, ast_util::local_def(id))\n+            .unwrap_or(ast_util::local_def(ast::DUMMY_NODE_ID));\n+        assert!(ast_util::is_local(impl_def_id));\n+        let impl_node_id = impl_def_id.node;\n+\n+        // Walk through this function (say `f`) looking to see if\n+        // every possible path references itself, i.e. the function is\n+        // called recursively unconditionally. This is done by trying\n+        // to find a path from the entry node to the exit node that\n+        // *doesn't* call `f` by traversing from the entry while\n+        // pretending that calls of `f` are sinks (i.e. ignoring any\n+        // exit edges from them).\n+        //\n+        // NB. this has an edge case with non-returning statements,\n+        // like `loop {}` or `panic!()`: control flow never reaches\n+        // the exit node through these, so one can have a function\n+        // that never actually calls itselfs but is still picked up by\n+        // this lint:\n+        //\n+        //     fn f(cond: bool) {\n+        //         if !cond { panic!() } // could come from `assert!(cond)`\n+        //         f(false)\n+        //     }\n+        //\n+        // In general, functions of that form may be able to call\n+        // itself a finite number of times and then diverge. The lint\n+        // considers this to be an error for two reasons, (a) it is\n+        // easier to implement, and (b) it seems rare to actually want\n+        // to have behaviour like the above, rather than\n+        // e.g. accidentally recurring after an assert.\n+\n+        let cfg = cfg::CFG::new(cx.tcx, blk);\n+\n+        let mut work_queue = vec![cfg.entry];\n+        let mut reached_exit_without_self_call = false;\n+        let mut self_call_spans = vec![];\n+        let mut visited = BitSet::new();\n+\n+        while let Some(idx) = work_queue.pop() {\n+            let cfg_id = idx.node_id();\n+            if idx == cfg.exit {\n+                // found a path!\n+                reached_exit_without_self_call = true;\n+                break\n+            } else if visited.contains(&cfg_id) {\n+                // already done\n+                continue\n+            }\n+            visited.insert(cfg_id);\n+            let node_id = cfg.graph.node_data(idx).id();\n+\n+            // is this a recursive call?\n+            if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {\n+\n+                self_call_spans.push(cx.tcx.map.span(node_id));\n+                // this is a self call, so we shouldn't explore past\n+                // this node in the CFG.\n+                continue\n+            }\n+            // add the successors of this node to explore the graph further.\n+            cfg.graph.each_outgoing_edge(idx, |_, edge| {\n+                let target_idx = edge.target();\n+                let target_cfg_id = target_idx.node_id();\n+                if !visited.contains(&target_cfg_id) {\n+                    work_queue.push(target_idx)\n+                }\n+                true\n+            });\n+        }\n+\n+        // check the number of sell calls because a function that\n+        // doesn't return (e.g. calls a `-> !` function or `loop { /*\n+        // no break */ }`) shouldn't be linted unless it actually\n+        // recurs.\n+        if !reached_exit_without_self_call && self_call_spans.len() > 0 {\n+            cx.span_lint(UNCONDITIONAL_RECURSION, sp,\n+                         \"function cannot return without recurring\");\n+\n+            // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n+            if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n+                let sess = cx.sess();\n+                // offer some help to the programmer.\n+                for call in &self_call_spans {\n+                    sess.span_note(*call, \"recursive call site\")\n+                }\n+                sess.span_help(sp, \"a `loop` may express intention better if this is on purpose\")\n+            }\n+        }\n+\n+        // all done\n+        return;\n+\n+        // Functions for identifying if the given NodeId `id`\n+        // represents a call to the function `fn_id`/method\n+        // `method_id`.\n+\n+        fn id_refers_to_this_fn<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      _: ast::NodeId,\n+                                      fn_id: ast::NodeId,\n+                                      _: ast::Ident,\n+                                      id: ast::NodeId) -> bool {\n+            tcx.def_map.borrow().get(&id)\n+                .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n+        }\n+\n+        // check if the method call `id` refers to method `method_id`\n+        // (with name `method_name` contained in impl `impl_id`).\n+        fn id_refers_to_this_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          impl_id: ast::NodeId,\n+                                          method_id: ast::NodeId,\n+                                          method_name: ast::Ident,\n+                                          id: ast::NodeId) -> bool {\n+            let did = match tcx.method_map.borrow().get(&ty::MethodCall::expr(id)) {\n+                None => return false,\n+                Some(m) => match m.origin {\n+                    // There's no way to know if a method call via a\n+                    // vtable is recursion, so we assume it's not.\n+                    ty::MethodTraitObject(_) => return false,\n+\n+                    // This `did` refers directly to the method definition.\n+                    ty::MethodStatic(did) | ty::MethodStaticClosure(did) => did,\n+\n+                    // MethodTypeParam are methods from traits:\n+\n+                    // The `impl ... for ...` of this method call\n+                    // isn't known, e.g. it might be a default method\n+                    // in a trait, so we get the def-id of the trait\n+                    // method instead.\n+                    ty::MethodTypeParam(\n+                        ty::MethodParam { ref trait_ref, method_num, impl_def_id: None, }) => {\n+                        ty::trait_item(tcx, trait_ref.def_id, method_num).def_id()\n+                    }\n+\n+                    // The `impl` is known, so we check that with a\n+                    // special case:\n+                    ty::MethodTypeParam(\n+                        ty::MethodParam { impl_def_id: Some(impl_def_id), .. }) => {\n+\n+                        let name = match tcx.map.expect_expr(id).node {\n+                            ast::ExprMethodCall(ref sp_ident, _, _) => sp_ident.node,\n+                            _ => tcx.sess.span_bug(\n+                                tcx.map.span(id),\n+                                \"non-method call expr behaving like a method call?\")\n+                        };\n+                        // it matches if it comes from the same impl,\n+                        // and has the same method name.\n+                        return ast_util::is_local(impl_def_id)\n+                            && impl_def_id.node == impl_id\n+                            && method_name.name == name.name\n+                    }\n+                }\n+            };\n+\n+            ast_util::is_local(did) && did.node == method_id\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    PLUGIN_AS_LIBRARY,\n+    Warn,\n+    \"compiler plugin used as ordinary library in non-plugin crate\"\n+}\n+\n+#[derive(Copy)]\n+pub struct PluginAsLibrary;\n+\n+impl LintPass for PluginAsLibrary {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![PLUGIN_AS_LIBRARY]\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        if cx.sess().plugin_registrar_fn.get().is_some() {\n+            // We're compiling a plugin; it's fine to link other plugins.\n+            return;\n+        }\n+\n+        match it.node {\n+            ast::ItemExternCrate(..) => (),\n+            _ => return,\n+        };\n+\n+        let md = match cx.sess().cstore.find_extern_mod_stmt_cnum(it.id) {\n+            Some(cnum) => cx.sess().cstore.get_crate_data(cnum),\n+            None => {\n+                // Probably means we aren't linking the crate for some reason.\n+                //\n+                // Not sure if / when this could happen.\n+                return;\n+            }\n+        };\n+\n+        if decoder::get_plugin_registrar_fn(md.data()).is_some() {\n+            cx.span_lint(PLUGIN_AS_LIBRARY, it.span,\n+                \"compiler plugin used as an ordinary library\");\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    PRIVATE_NO_MANGLE_FNS,\n+    Warn,\n+    \"functions marked #[no_mangle] should be exported\"\n+}\n+\n+declare_lint! {\n+    PRIVATE_NO_MANGLE_STATICS,\n+    Warn,\n+    \"statics marked #[no_mangle] should be exported\"\n+}\n+\n+declare_lint! {\n+    NO_MANGLE_CONST_ITEMS,\n+    Deny,\n+    \"const items will not have their symbols exported\"\n+}\n+\n+#[derive(Copy)]\n+pub struct InvalidNoMangleItems;\n+\n+impl LintPass for InvalidNoMangleItems {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(PRIVATE_NO_MANGLE_FNS,\n+                    PRIVATE_NO_MANGLE_STATICS,\n+                    NO_MANGLE_CONST_ITEMS)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemFn(..) => {\n+                if attr::contains_name(&it.attrs, \"no_mangle\") &&\n+                       !cx.exported_items.contains(&it.id) {\n+                    let msg = format!(\"function {} is marked #[no_mangle], but not exported\",\n+                                      it.ident);\n+                    cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, &msg);\n+                }\n+            },\n+            ast::ItemStatic(..) => {\n+                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") &&\n+                       !cx.exported_items.contains(&it.id) {\n+                    let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n+                                      it.ident);\n+                    cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, msg.as_slice());\n+                }\n+            },\n+            ast::ItemConst(..) => {\n+                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") {\n+                    // Const items do not refer to a particular location in memory, and therefore\n+                    // don't have anything to attach a symbol to\n+                    let msg = \"const items should never be #[no_mangle], consider instead using \\\n+                        `pub static`\";\n+                    cx.span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n+                }\n+            }\n+            _ => {},\n+        }\n+    }\n+}\n+\n+/// Forbids using the `#[feature(...)]` attribute\n+#[derive(Copy)]\n+pub struct UnstableFeatures;\n+\n+declare_lint!(UNSTABLE_FEATURES, Allow,\n+              \"enabling unstable features\");\n+\n+impl LintPass for UnstableFeatures {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNSTABLE_FEATURES)\n+    }\n+    fn check_attribute(&mut self, ctx: &Context, attr: &ast::Attribute) {\n+        use syntax::attr;\n+        if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n+            ctx.span_lint(UNSTABLE_FEATURES, attr.span, \"unstable feature\");\n+        }\n+    }\n+}"}, {"sha": "cce68e5d6919bc1fa367223715749d87b8c1ade5", "filename": "src/librustc_lint/lib.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Many of the lints built into the Rust compiler.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_lint\"]\n+#![unstable(feature = \"rustc_private\")]\n+#![staged_api]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n+\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(int_uint)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_private)]\n+#![feature(unsafe_destructor)]\n+#![feature(staged_api)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n+#![cfg_attr(test, feature(test))]\n+\n+extern crate syntax;\n+#[macro_use]\n+extern crate rustc;\n+#[macro_use]\n+extern crate log;\n+\n+pub use rustc::lint as lint;\n+pub use rustc::metadata as metadata;\n+pub use rustc::middle as middle;\n+pub use rustc::session as session;\n+pub use rustc::util as util;\n+\n+use session::Session;\n+use lint::{LintPassObject, LintId};\n+\n+mod builtin;\n+\n+pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n+    macro_rules! add_builtin {\n+        ($sess:ident, $($name:ident),*,) => (\n+            {$(\n+                store.register_pass($sess, false, box builtin::$name as LintPassObject);\n+                )*}\n+            )\n+    }\n+\n+    macro_rules! add_builtin_with_new {\n+        ($sess:ident, $($name:ident),*,) => (\n+            {$(\n+                store.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n+                )*}\n+            )\n+    }\n+\n+    macro_rules! add_lint_group {\n+        ($sess:ident, $name:expr, $($lint:ident),*) => (\n+            store.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n+            )\n+    }\n+\n+    add_builtin!(sess,\n+                 HardwiredLints,\n+                 WhileTrue,\n+                 UnusedCasts,\n+                 ImproperCTypes,\n+                 BoxPointers,\n+                 UnusedAttributes,\n+                 PathStatements,\n+                 UnusedResults,\n+                 NonCamelCaseTypes,\n+                 NonSnakeCase,\n+                 NonUpperCaseGlobals,\n+                 UnusedParens,\n+                 UnusedImportBraces,\n+                 NonShorthandFieldPatterns,\n+                 UnusedUnsafe,\n+                 UnsafeCode,\n+                 UnusedMut,\n+                 UnusedAllocation,\n+                 MissingCopyImplementations,\n+                 UnstableFeatures,\n+                 Stability,\n+                 UnconditionalRecursion,\n+                 InvalidNoMangleItems,\n+                 PluginAsLibrary,\n+                 );\n+\n+    add_builtin_with_new!(sess,\n+                          TypeLimits,\n+                          RawPointerDerive,\n+                          MissingDoc,\n+                          MissingDebugImplementations,\n+                          );\n+\n+    add_lint_group!(sess, \"bad_style\",\n+                    NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPER_CASE_GLOBALS);\n+\n+    add_lint_group!(sess, \"unused\",\n+                    UNUSED_IMPORTS, UNUSED_VARIABLES, UNUSED_ASSIGNMENTS, DEAD_CODE,\n+                    UNUSED_MUT, UNREACHABLE_CODE, UNUSED_MUST_USE,\n+                    UNUSED_UNSAFE, PATH_STATEMENTS);\n+\n+    // We have one lint pass defined specially\n+    store.register_pass(sess, false, box lint::GatherNodeLevels as LintPassObject);\n+\n+    // Insert temporary renamings for a one-time deprecation\n+    store.register_renamed(\"raw_pointer_deriving\", \"raw_pointer_derive\");\n+\n+    store.register_renamed(\"unknown_features\", \"unused_features\");\n+}"}, {"sha": "113a622b07ae47cd2430288adc66c86313c02730", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n pub use self::MaybeTyped::*;\n \n+use rustc_lint;\n use rustc_driver::driver;\n use rustc::session::{self, config};\n use rustc::session::config::UnstableFeatures;\n@@ -114,6 +115,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n \n     let sess = session::build_session_(sessopts, cpath,\n                                        span_diagnostic_handler);\n+    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let cfg = config::build_configuration(&sess);\n "}, {"sha": "fcad91bf14ad99f245863c820c6885483b095d27", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -42,6 +42,7 @@ extern crate rustc;\n extern crate rustc_trans;\n extern crate rustc_driver;\n extern crate rustc_resolve;\n+extern crate rustc_lint;\n extern crate serialize;\n extern crate syntax;\n extern crate \"test\" as testing;"}, {"sha": "43e8f44244e788c258b5f3a0d0b6873d2cd317ef", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -20,6 +20,7 @@ use std::thunk::Thunk;\n \n use std::collections::{HashSet, HashMap};\n use testing;\n+use rustc_lint;\n use rustc::session::{self, config};\n use rustc::session::config::get_unstable_features_setting;\n use rustc::session::search_paths::{SearchPaths, PathKind};\n@@ -62,6 +63,7 @@ pub fn run(input: &str,\n     let sess = session::build_session_(sessopts,\n                                       Some(input_path.clone()),\n                                       span_diagnostic_handler);\n+    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(config::parse_cfgspecs(cfgs).into_iter());\n@@ -165,6 +167,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let sess = session::build_session_(sessopts,\n                                        None,\n                                        span_diagnostic_handler);\n+    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\");\n     let out = Some(outdir.path().clone());"}, {"sha": "cff4d44910b3146d312c11a0d41958d79c3a22c8", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532cd5f85a93921f74f5991db2e419c6da58b188/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=532cd5f85a93921f74f5991db2e419c6da58b188", "patch": "@@ -10,6 +10,7 @@\n \n extern crate rustc;\n extern crate rustc_driver;\n+extern crate rustc_lint;\n extern crate syntax;\n \n use rustc::session::{build_session, Session};\n@@ -46,6 +47,7 @@ fn basic_sess(sysroot: Path) -> Session {\n \n     let descriptions = Registry::new(&rustc::diagnostics::DIAGNOSTICS);\n     let sess = build_session(opts, None, descriptions);\n+    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     sess\n }\n "}]}