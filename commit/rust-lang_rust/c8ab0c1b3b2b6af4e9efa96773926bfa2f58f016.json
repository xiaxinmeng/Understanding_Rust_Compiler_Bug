{"sha": "c8ab0c1b3b2b6af4e9efa96773926bfa2f58f016", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YWIwYzFiM2IyYjZhZjRlOWVmYTk2NzczOTI2YmZhMmY1OGYwMTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-21T22:22:12Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-21T22:22:12Z"}, "message": "rustc: Replace region parameters in function return values", "tree": {"sha": "55ad92b587e9874f31477f56b86d1c475003800e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55ad92b587e9874f31477f56b86d1c475003800e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8ab0c1b3b2b6af4e9efa96773926bfa2f58f016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ab0c1b3b2b6af4e9efa96773926bfa2f58f016", "html_url": "https://github.com/rust-lang/rust/commit/c8ab0c1b3b2b6af4e9efa96773926bfa2f58f016", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8ab0c1b3b2b6af4e9efa96773926bfa2f58f016/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "324f57a180ed2c80b17894ccd0b0b75aab14ec97", "url": "https://api.github.com/repos/rust-lang/rust/commits/324f57a180ed2c80b17894ccd0b0b75aab14ec97", "html_url": "https://github.com/rust-lang/rust/commit/324f57a180ed2c80b17894ccd0b0b75aab14ec97"}], "stats": {"total": 44, "additions": 35, "deletions": 9}, "files": [{"sha": "8fba31e6daf6d50fbc03e6e556f314cc4a10fc49", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c8ab0c1b3b2b6af4e9efa96773926bfa2f58f016/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ab0c1b3b2b6af4e9efa96773926bfa2f58f016/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=c8ab0c1b3b2b6af4e9efa96773926bfa2f58f016", "patch": "@@ -16,6 +16,7 @@ import util::ppaux::ty_to_str;\n import std::smallintmap;\n import std::map::{hashmap, int_hash};\n import std::serialization::{serialize_uint, deserialize_uint};\n+import std::ufind;\n import syntax::print::pprust::*;\n \n export check_crate;\n@@ -1554,6 +1555,33 @@ fn universally_quantify_regions(tcx: ty::ctxt, ty: ty::t) -> ty::t {\n     }\n }\n \n+// Replaces region parameter types in the given type with the appropriate\n+// bindings.\n+fn replace_region_params(tcx: ty::ctxt,\n+                         sp: span,\n+                         rb: @ty::unify::region_bindings,\n+                         ty: ty::t)\n+        -> ty::t {\n+\n+    if ty::type_has_rptrs(ty) {\n+        ty::fold_ty(tcx, ty::fm_rptr({ |r|\n+            alt r {\n+                ty::re_param(n) {\n+                    if n < ufind::set_count(rb.sets) {\n+                        smallintmap::get(rb.regions, ufind::find(rb.sets, n))\n+                    } else {\n+                        tcx.sess.span_err(sp, \"unresolved region\");\n+                        r\n+                    }\n+                }\n+                _ { r }\n+            }\n+        }), ty)\n+    } else {\n+        ty\n+    }\n+}\n+\n fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                      subpats: [@ast::pat], expected: ty::t) {\n     // Typecheck the path.\n@@ -2277,40 +2305,38 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     // A generic function for checking call expressions\n     fn check_call(fcx: @fn_ctxt, sp: span, id: ast::node_id, f: @ast::expr,\n                   args: [@ast::expr])\n-        -> bool {\n+            -> check_call_or_bind_result {\n         let args_opt_0: [option<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n             args_opt_0 += [some::<@ast::expr>(arg)];\n         }\n \n-        let mut bot = check_expr(fcx, f);\n+        let bot = check_expr(fcx, f);\n         // Call the generic checker.\n         let ccobr = check_call_or_bind(fcx, sp, id, expr_ty(fcx.ccx.tcx, f),\n                                        args_opt_0);\n-        bot |= ccobr.bot;\n-\n-        // TODO: Munge return type.\n-\n-        ret bot;\n+        ret { bot: bot | ccobr.bot with ccobr };\n     }\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call_full(fcx: @fn_ctxt, sp: span, id: ast::node_id,\n                        f: @ast::expr, args: [@ast::expr]) -> bool {\n-        let bot = check_call(fcx, sp, id, f, args);\n+        let ccobr = check_call(fcx, sp, id, f, args);\n+        let mut bot = ccobr.bot;\n         /* need to restrict oper to being an explicit expr_path if we're\n         inside a pure function */\n         require_pure_call(fcx.ccx, fcx.purity, f, sp);\n \n         // Pull the return type out of the type of the function.\n         let fty = ty::expr_ty(fcx.ccx.tcx, f);\n-        let rt_1 = alt structure_of(fcx, sp, fty) {\n+        let mut rt_1 = alt structure_of(fcx, sp, fty) {\n           ty::ty_fn(f) {\n             bot |= f.ret_style == ast::noreturn;\n             f.output\n           }\n           _ { fcx.ccx.tcx.sess.span_fatal(sp, \"calling non-function\"); }\n         };\n+        rt_1 = replace_region_params(fcx.ccx.tcx, f.span, ccobr.rb, rt_1);\n         write_ty(fcx.ccx.tcx, id, rt_1);\n         ret bot;\n     }"}]}