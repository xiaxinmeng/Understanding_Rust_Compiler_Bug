{"sha": "9567544902e1a6cca1b10333b6fc929e50ec1fba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1Njc1NDQ5MDJlMWE2Y2NhMWIxMDMzM2I2ZmM5MjllNTBlYzFmYmE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-01-07T01:21:43Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-01-14T01:36:29Z"}, "message": "Suggest removal of semicolon when appropriate", "tree": {"sha": "7e86c675aec6d17e0752f57ae9c5be3b05e4f47d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e86c675aec6d17e0752f57ae9c5be3b05e4f47d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9567544902e1a6cca1b10333b6fc929e50ec1fba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9567544902e1a6cca1b10333b6fc929e50ec1fba", "html_url": "https://github.com/rust-lang/rust/commit/9567544902e1a6cca1b10333b6fc929e50ec1fba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9567544902e1a6cca1b10333b6fc929e50ec1fba/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fc1685c47e316d1377e4d54393db6c18ff8a744", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fc1685c47e316d1377e4d54393db6c18ff8a744", "html_url": "https://github.com/rust-lang/rust/commit/7fc1685c47e316d1377e4d54393db6c18ff8a744"}], "stats": {"total": 260, "additions": 169, "deletions": 91}, "files": [{"sha": "2995b25308d4c9f455565cf6278f92fa3e3fd988", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9567544902e1a6cca1b10333b6fc929e50ec1fba", "patch": "@@ -511,9 +511,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             },\n-            ObligationCauseCode::IfExpression { then, outer } => {\n+            ObligationCauseCode::IfExpression { then, outer, semicolon } => {\n                 err.span_label(then, \"expected because of this\");\n                 outer.map(|sp| err.span_label(sp, \"if and else have incompatible types\"));\n+                if let Some(sp) = semicolon {\n+                    err.span_suggestion_short_with_applicability(\n+                        sp,\n+                        \"consider removing this semicolon\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n             }\n             _ => (),\n         }"}, {"sha": "68383bef37a6a90d4f40cc93c43182ea7b40df94", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9567544902e1a6cca1b10333b6fc929e50ec1fba", "patch": "@@ -232,6 +232,7 @@ pub enum ObligationCauseCode<'tcx> {\n     IfExpression {\n         then: Span,\n         outer: Option<Span>,\n+        semicolon: Option<Span>,\n     },\n \n     /// Computing common supertype of an if expression with no else counter-part"}, {"sha": "2f5df022218fe3fd4e71c6d0ec0f230f2785b5d5", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=9567544902e1a6cca1b10333b6fc929e50ec1fba", "patch": "@@ -520,7 +520,11 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::MatchExpressionArmPattern { span, ty } => {\n                 tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n             }\n-            super::IfExpression { then, outer } => Some(super::IfExpression { then, outer }),\n+            super::IfExpression { then, outer, semicolon } => Some(super::IfExpression {\n+                then,\n+                outer,\n+                semicolon,\n+            }),\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n             super::MainFunctionType => Some(super::MainFunctionType),\n             super::StartFunctionType => Some(super::StartFunctionType),"}, {"sha": "1b07385d4d1f4e95da1d63627bddfddcda2e6f56", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 81, "deletions": 66, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9567544902e1a6cca1b10333b6fc929e50ec1fba", "patch": "@@ -3366,37 +3366,44 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let coerce_to_ty = expected.coercion_target_type(self, sp);\n         let mut coerce: DynamicCoerceMany = CoerceMany::new(coerce_to_ty);\n \n-        let mut outer_sp = if self.tcx.sess.source_map().is_multiline(sp) {\n-            // The `if`/`else` isn't in one line in the output, include some context to make it\n-            // clear it is an if/else expression:\n-            // ```\n-            // LL |      let x = if true {\n-            //    | _____________-\n-            // LL ||         10i32\n-            //    ||         ----- expected because of this\n-            // LL ||     } else {\n-            // LL ||         10u32\n-            //    ||         ^^^^^ expected i32, found u32\n-            // LL ||     };\n-            //    ||_____- if and else have incompatible types\n-            // ```\n-            Some(sp)\n-        } else {\n-            // The entire expression is in one line, only point at the arms\n-            // ```\n-            // LL |     let x = if true { 10i32 } else { 10u32 };\n-            //    |                       -----          ^^^^^ expected i32, found u32\n-            //    |                       |\n-            //    |                       expected because of this\n-            // ```\n-            None\n-        };\n-        let error_sp = opt_else_expr.map(|expr| {\n-            if let ExprKind::Block(block, _) = &expr.node {\n+        coerce.coerce(self, &self.misc(sp), then_expr, then_ty);\n+\n+        if let Some(else_expr) = opt_else_expr {\n+            let else_ty = self.check_expr_with_expectation(else_expr, expected);\n+            let else_diverges = self.diverges.get();\n+\n+            let mut outer_sp = if self.tcx.sess.source_map().is_multiline(sp) {\n+                // The `if`/`else` isn't in one line in the output, include some context to make it\n+                // clear it is an if/else expression:\n+                // ```\n+                // LL |      let x = if true {\n+                //    | _____________-\n+                // LL ||         10i32\n+                //    ||         ----- expected because of this\n+                // LL ||     } else {\n+                // LL ||         10u32\n+                //    ||         ^^^^^ expected i32, found u32\n+                // LL ||     };\n+                //    ||_____- if and else have incompatible types\n+                // ```\n+                Some(sp)\n+            } else {\n+                // The entire expression is in one line, only point at the arms\n+                // ```\n+                // LL |     let x = if true { 10i32 } else { 10u32 };\n+                //    |                       -----          ^^^^^ expected i32, found u32\n+                //    |                       |\n+                //    |                       expected because of this\n+                // ```\n+                None\n+            };\n+            let mut remove_semicolon = None;\n+            let error_sp = if let ExprKind::Block(block, _) = &else_expr.node {\n                 if let Some(expr) = &block.expr {\n                     expr.span\n                 } else if let Some(stmt) = block.stmts.last() {\n                     // possibly incorrect trailing `;` in the else arm\n+                    remove_semicolon = self.could_remove_semicolon(block, then_ty);\n                     stmt.span\n                 } else {  // empty block, point at its entirety\n                     // Avoid overlapping spans that aren't as readable:\n@@ -3429,35 +3436,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if outer_sp.is_some() {\n                         outer_sp = Some(self.tcx.sess.source_map().def_span(sp));\n                     }\n-                    expr.span\n+                    else_expr.span\n                 }\n             } else { // shouldn't happen unless the parser has done something weird\n-                expr.span\n-            }\n-        }).unwrap_or(sp);  // shouldn't be needed\n-        let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n-            if let Some(expr) = &block.expr {\n-                expr.span\n-            } else if let Some(stmt) = block.stmts.last() {\n-                // possibly incorrect trailing `;` in the else arm\n-                stmt.span\n-            } else {  // empty block, point at its entirety\n-                outer_sp = None;  // same as in `error_sp`, cleanup output\n+                else_expr.span\n+            };\n+            let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n+                if let Some(expr) = &block.expr {\n+                    expr.span\n+                } else if let Some(stmt) = block.stmts.last() {\n+                    // possibly incorrect trailing `;` in the else arm\n+                    remove_semicolon = remove_semicolon.or(\n+                        self.could_remove_semicolon(block, else_ty));\n+                    stmt.span\n+                } else {  // empty block, point at its entirety\n+                    outer_sp = None;  // same as in `error_sp`, cleanup output\n+                    then_expr.span\n+                }\n+            } else {  // shouldn't happen unless the parser has done something weird\n                 then_expr.span\n-            }\n-        } else {  // shouldn't happen unless the parser has done something weird\n-            then_expr.span\n-        };\n-\n-        let if_cause = self.cause(error_sp, ObligationCauseCode::IfExpression {\n-            then: then_sp,\n-            outer: outer_sp,\n-        });\n-        coerce.coerce(self, &if_cause, then_expr, then_ty);\n+            };\n \n-        if let Some(else_expr) = opt_else_expr {\n-            let else_ty = self.check_expr_with_expectation(else_expr, expected);\n-            let else_diverges = self.diverges.get();\n+            let if_cause = self.cause(error_sp, ObligationCauseCode::IfExpression {\n+                then: then_sp,\n+                outer: outer_sp,\n+                semicolon: remove_semicolon,\n+            });\n \n             coerce.coerce(self, &if_cause, else_expr, else_ty);\n \n@@ -5230,7 +5234,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-\n     /// A common error is to add an extra semicolon:\n     ///\n     /// ```\n@@ -5242,31 +5245,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This routine checks if the final statement in a block is an\n     /// expression with an explicit semicolon whose type is compatible\n     /// with `expected_ty`. If so, it suggests removing the semicolon.\n-    fn consider_hint_about_removing_semicolon(&self,\n-                                              blk: &'gcx hir::Block,\n-                                              expected_ty: Ty<'tcx>,\n-                                              err: &mut DiagnosticBuilder) {\n+    fn consider_hint_about_removing_semicolon(\n+        &self,\n+        blk: &'gcx hir::Block,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut DiagnosticBuilder,\n+    ) {\n+        if let Some(span_semi) = self.could_remove_semicolon(blk, expected_ty) {\n+            err.span_suggestion_with_applicability(\n+                span_semi,\n+                \"consider removing this semicolon\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n+    fn could_remove_semicolon(\n+        &self,\n+        blk: &'gcx hir::Block,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<Span> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = match blk.stmts.last() {\n             Some(s) => s,\n-            None => return,\n+            None => return None,\n         };\n         let last_expr = match last_stmt.node {\n             hir::StmtKind::Semi(ref e, _) => e,\n-            _ => return,\n+            _ => return None,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n         if self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err() {\n-            return;\n+            return None;\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n-        let span_semi = original_span.with_lo(original_span.hi() - BytePos(1));\n-        err.span_suggestion_with_applicability(\n-            span_semi,\n-            \"consider removing this semicolon\",\n-            String::new(),\n-            Applicability::MachineApplicable);\n+        Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n     }\n \n     // Instantiates the given path, which must refer to an item with the given"}, {"sha": "583c3d0b765cf2397296896b38d69930b2d1b2d0", "filename": "src/test/ui/if-else-type-mismatch.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Ftest%2Fui%2Fif-else-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Ftest%2Fui%2Fif-else-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-else-type-mismatch.rs?ref=9567544902e1a6cca1b10333b6fc929e50ec1fba", "patch": "@@ -1,32 +1,44 @@\n fn main() {\n     let _ = if true {\n-        42i32\n+        1i32\n     } else {\n-        42u32\n+        2u32\n     };\n     //~^^ ERROR if and else have incompatible types\n     let _ = if true { 42i32 } else { 42u32 };\n     //~^ ERROR if and else have incompatible types\n     let _ = if true {\n-        42i32;\n+        3u32;\n     } else {\n-        42u32\n+        4u32\n     };\n     //~^^ ERROR if and else have incompatible types\n     let _ = if true {\n-        42i32\n+        5u32\n     } else {\n-        42u32;\n+        6u32;\n+    };\n+    //~^^ ERROR if and else have incompatible types\n+    let _ = if true {\n+        7i32;\n+    } else {\n+        8u32\n+    };\n+    //~^^ ERROR if and else have incompatible types\n+    let _ = if true {\n+        9i32\n+    } else {\n+        10u32;\n     };\n     //~^^ ERROR if and else have incompatible types\n     let _ = if true {\n \n     } else {\n-        42u32\n+        11u32\n     };\n     //~^^ ERROR if and else have incompatible types\n     let _ = if true {\n-        42i32\n+        12i32\n     } else {\n \n     };"}, {"sha": "b418c961189d6b59f2f2ad6b38506d472b895dff", "filename": "src/test/ui/if-else-type-mismatch.stderr", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Ftest%2Fui%2Fif-else-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9567544902e1a6cca1b10333b6fc929e50ec1fba/src%2Ftest%2Fui%2Fif-else-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-else-type-mismatch.stderr?ref=9567544902e1a6cca1b10333b6fc929e50ec1fba", "patch": "@@ -3,11 +3,11 @@ error[E0308]: if and else have incompatible types\n    |\n LL |       let _ = if true {\n    |  _____________-\n-LL | |         42i32\n-   | |         ----- expected because of this\n+LL | |         1i32\n+   | |         ---- expected because of this\n LL | |     } else {\n-LL | |         42u32\n-   | |         ^^^^^ expected i32, found u32\n+LL | |         2u32\n+   | |         ^^^^ expected i32, found u32\n LL | |     };\n    | |_____- if and else have incompatible types\n    |\n@@ -30,11 +30,14 @@ error[E0308]: if and else have incompatible types\n    |\n LL |       let _ = if true {\n    |  _____________-\n-LL | |         42i32;\n-   | |         ------ expected because of this\n+LL | |         3u32;\n+   | |         -----\n+   | |         |   |\n+   | |         |   help: consider removing this semicolon\n+   | |         expected because of this\n LL | |     } else {\n-LL | |         42u32\n-   | |         ^^^^^ expected (), found u32\n+LL | |         4u32\n+   | |         ^^^^ expected (), found u32\n LL | |     };\n    | |_____- if and else have incompatible types\n    |\n@@ -46,10 +49,45 @@ error[E0308]: if and else have incompatible types\n    |\n LL |       let _ = if true {\n    |  _____________-\n-LL | |         42i32\n+LL | |         5u32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         6u32;\n+   | |         ^^^^-\n+   | |         |   |\n+   | |         |   help: consider removing this semicolon\n+   | |         expected u32, found ()\n+LL | |     };\n+   | |_____- if and else have incompatible types\n+   |\n+   = note: expected type `u32`\n+              found type `()`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:25:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |         7i32;\n    | |         ----- expected because of this\n LL | |     } else {\n-LL | |         42u32;\n+LL | |         8u32\n+   | |         ^^^^ expected (), found u32\n+LL | |     };\n+   | |_____- if and else have incompatible types\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:31:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |         9i32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         10u32;\n    | |         ^^^^^^ expected i32, found ()\n LL | |     };\n    | |_____- if and else have incompatible types\n@@ -58,25 +96,25 @@ LL | |     };\n               found type `()`\n \n error[E0308]: if and else have incompatible types\n-  --> $DIR/if-else-type-mismatch.rs:25:9\n+  --> $DIR/if-else-type-mismatch.rs:37:9\n    |\n LL |       let _ = if true {\n    |  _____________________-\n LL | |\n LL | |     } else {\n    | |_____- expected because of this\n-LL |           42u32\n+LL |           11u32\n    |           ^^^^^ expected (), found u32\n    |\n    = note: expected type `()`\n               found type `u32`\n \n error[E0308]: if and else have incompatible types\n-  --> $DIR/if-else-type-mismatch.rs:30:12\n+  --> $DIR/if-else-type-mismatch.rs:42:12\n    |\n LL |       let _ = if true {\n    |               ------- if and else have incompatible types\n-LL |           42i32\n+LL |           12i32\n    |           ----- expected because of this\n LL |       } else {\n    |  ____________^\n@@ -87,6 +125,6 @@ LL | |     };\n    = note: expected type `i32`\n               found type `()`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}