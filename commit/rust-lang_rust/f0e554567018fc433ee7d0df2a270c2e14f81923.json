{"sha": "f0e554567018fc433ee7d0df2a270c2e14f81923", "node_id": "C_kwDOAAsO6NoAKGYwZTU1NDU2NzAxOGZjNDMzZWU3ZDBkZjJhMjcwYzJlMTRmODE5MjM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-08T20:00:11Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-08T22:24:15Z"}, "message": "another attempt at performance improvements", "tree": {"sha": "a2f0863e63a505569a8db7994e4a63194b1f2b30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2f0863e63a505569a8db7994e4a63194b1f2b30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0e554567018fc433ee7d0df2a270c2e14f81923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0e554567018fc433ee7d0df2a270c2e14f81923", "html_url": "https://github.com/rust-lang/rust/commit/f0e554567018fc433ee7d0df2a270c2e14f81923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0e554567018fc433ee7d0df2a270c2e14f81923/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c15b3c08cbd5d0932b47b1a2361470562113384", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c15b3c08cbd5d0932b47b1a2361470562113384", "html_url": "https://github.com/rust-lang/rust/commit/2c15b3c08cbd5d0932b47b1a2361470562113384"}], "stats": {"total": 49, "additions": 26, "deletions": 23}, "files": [{"sha": "e118a1bb7b2954c5912679e0a4d601fe96dcaf47", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/provenance_map.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f0e554567018fc433ee7d0df2a270c2e14f81923/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e554567018fc433ee7d0df2a270c2e14f81923/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs?ref=f0e554567018fc433ee7d0df2a270c2e14f81923", "patch": "@@ -191,27 +191,24 @@ impl<Prov: Provenance> ProvenanceMap<Prov> {\n         // # Pointer-sized provenances\n         // Get the provenances that are entirely within this range.\n         // (Different from `range_get_ptrs` which asks if they overlap the range.)\n-        let ptrs = if src.size < ptr_size {\n-            // This isn't even large enough to contain a pointer.\n-            &[]\n-        } else {\n-            let adjusted_end =\n-                Size::from_bytes(src.end().bytes().saturating_sub(ptr_size.bytes() - 1));\n-            self.ptrs.range(src.start..adjusted_end)\n+        // Only makes sense if we are copying at least one pointer worth of bytes.\n+        let mut dest_ptrs = Vec::new();\n+        if src.size >= ptr_size {\n+            let adjusted_end = Size::from_bytes(src.end().bytes() - (ptr_size.bytes() - 1));\n+            let ptrs = self.ptrs.range(src.start..adjusted_end);\n+            dest_ptrs.reserve_exact(ptrs.len() * (count as usize));\n+            // If `count` is large, this is rather wasteful -- we are allocating a big array here, which\n+            // is mostly filled with redundant information since it's just N copies of the same `Prov`s\n+            // at slightly adjusted offsets. The reason we do this is so that in `mark_provenance_range`\n+            // we can use `insert_presorted`. That wouldn't work with an `Iterator` that just produces\n+            // the right sequence of provenance for all N copies.\n+            // Basically, this large array would have to be created anyway in the target allocation.\n+            for i in 0..count {\n+                dest_ptrs\n+                    .extend(ptrs.iter().map(|&(offset, reloc)| (shift_offset(i, offset), reloc)));\n+            }\n         };\n \n-        // Buffer for the new list.\n-        let mut dest_ptrs = Vec::with_capacity(ptrs.len() * (count as usize));\n-        // If `count` is large, this is rather wasteful -- we are allocating a big array here, which\n-        // is mostly filled with redundant information since it's just N copies of the same `Prov`s\n-        // at slightly adjusted offsets. The reason we do this is so that in `mark_provenance_range`\n-        // we can use `insert_presorted`. That wouldn't work with an `Iterator` that just produces\n-        // the right sequence of provenance for all N copies.\n-        // Basically, this large array would have to be created anyway in the target allocation.\n-        for i in 0..count {\n-            dest_ptrs.extend(ptrs.iter().map(|&(offset, reloc)| (shift_offset(i, offset), reloc)));\n-        }\n-\n         // # Byte-sized provenances\n         let mut bytes = Vec::new();\n         // First, if there is a part of a pointer at the start, add that.\n@@ -261,10 +258,16 @@ impl<Prov: Provenance> ProvenanceMap<Prov> {\n         trace!(\"byte provenances: {bytes:?}\");\n \n         // And again a buffer for the new list on the target side.\n-        let mut dest_bytes = Vec::with_capacity(bytes.len() * (count as usize));\n-        for i in 0..count {\n-            dest_bytes\n-                .extend(bytes.iter().map(|&(offset, reloc)| (shift_offset(i, offset), reloc)));\n+        let mut dest_bytes = Vec::new();\n+        if Prov::OFFSET_IS_ADDR {\n+            dest_bytes.reserve_exact(bytes.len() * (count as usize));\n+            for i in 0..count {\n+                dest_bytes\n+                    .extend(bytes.iter().map(|&(offset, reloc)| (shift_offset(i, offset), reloc)));\n+            }\n+        } else {\n+            // There can't be any bytewise provenance when OFFSET_IS_ADDR is false.\n+            debug_assert!(bytes.is_empty());\n         }\n \n         Ok(ProvenanceCopy { dest_ptrs, dest_bytes })"}]}