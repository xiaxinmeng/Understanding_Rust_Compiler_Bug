{"sha": "2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMTRjNDNkNWJkMTgwM2ZjOGM1ZGNkZGQyYTViOGIzMGM0YTVmZWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-16T09:39:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-16T09:39:25Z"}, "message": "Merge #5403\n\n5403: Simplify r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b84ea78d9945e4cd4f0b38d337c39af68c769fe5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b84ea78d9945e4cd4f0b38d337c39af68c769fe5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfECBNCRBK7hj4Ov3rIwAAdHIIAFXeGUFoNT7SFCo3S4NnCx/X\nwzRRfsvC3+U50LlXqrMfW1JgMhqj4TPlZhRRO7GW5X7kMqd/bq59eQ966R6Jp9aP\n4Pxh1fHJIY74vkbR1TmtUKWJUD4Uw4zmZhGU++lI421koVGm64ESkVeQU1seQgt0\n3DGh7EiVv0Dn/0QN5v4+A6Hv2OZ1r+9TDagvWGoRdlfKUT9U1c9WYSYBrlMUFjfa\nJWBh0pwI0InWNGQZlatHtBwImmrXs8h6czTlQzvSHm5HUtKw7aOesVRD2IUMgmwm\nOgxAFVICmBImYHh7NKBmQt4mDZESewE2h5wZqgj7NPeu460YvBM8d/+tp+761Ps=\n=dmag\n-----END PGP SIGNATURE-----\n", "payload": "tree b84ea78d9945e4cd4f0b38d337c39af68c769fe5\nparent c3ce89145dbdf529738646aa3af3492dc7ec3066\nparent 1d6cf336630c7b1d7779eb5abb6e84584e41c4d4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594892365 +0000\ncommitter GitHub <noreply@github.com> 1594892365 +0000\n\nMerge #5403\n\n5403: Simplify r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee", "html_url": "https://github.com/rust-lang/rust/commit/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3ce89145dbdf529738646aa3af3492dc7ec3066", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ce89145dbdf529738646aa3af3492dc7ec3066", "html_url": "https://github.com/rust-lang/rust/commit/c3ce89145dbdf529738646aa3af3492dc7ec3066"}, {"sha": "1d6cf336630c7b1d7779eb5abb6e84584e41c4d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6cf336630c7b1d7779eb5abb6e84584e41c4d4", "html_url": "https://github.com/rust-lang/rust/commit/1d6cf336630c7b1d7779eb5abb6e84584e41c4d4"}], "stats": {"total": 192, "additions": 76, "deletions": 116}, "files": [{"sha": "0ef92ed4bf8b61b5b8b6e42e76ebee1ab67624d6", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 28, "deletions": 48, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee", "patch": "@@ -7,7 +7,15 @@ use ra_syntax::{\n };\n use test_utils::mark;\n \n-use crate::{CallInfo, FilePosition, FunctionSignature};\n+use crate::{FilePosition, FunctionSignature};\n+\n+/// Contains information about a call site. Specifically the\n+/// `FunctionSignature`and current parameter.\n+#[derive(Debug)]\n+pub struct CallInfo {\n+    pub signature: FunctionSignature,\n+    pub active_parameter: Option<usize>,\n+}\n \n /// Computes parameter information for the given call expression.\n pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo> {\n@@ -40,43 +48,40 @@ fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Op\n     // Find the calling expression and it's NameRef\n     let calling_node = FnCallNode::with_node(&token.parent())?;\n \n-    let (mut call_info, has_self) = match &calling_node {\n+    let signature = match &calling_node {\n         FnCallNode::CallExpr(call) => {\n             //FIXME: Type::as_callable is broken\n             let callable_def = sema.type_of_expr(&call.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::FunctionId(it) => {\n                     let fn_def = it.into();\n-                    (CallInfo::with_fn(sema.db, fn_def), fn_def.has_self_param(sema.db))\n+                    FunctionSignature::from_hir(sema.db, fn_def)\n                 }\n                 hir::CallableDef::StructId(it) => {\n-                    (CallInfo::with_struct(sema.db, it.into())?, false)\n+                    FunctionSignature::from_struct(sema.db, it.into())?\n                 }\n                 hir::CallableDef::EnumVariantId(it) => {\n-                    (CallInfo::with_enum_variant(sema.db, it.into())?, false)\n+                    FunctionSignature::from_enum_variant(sema.db, it.into())?\n                 }\n             }\n         }\n         FnCallNode::MethodCallExpr(method_call) => {\n             let function = sema.resolve_method_call(&method_call)?;\n-            (CallInfo::with_fn(sema.db, function), function.has_self_param(sema.db))\n+            FunctionSignature::from_hir(sema.db, function)\n         }\n         FnCallNode::MacroCallExpr(macro_call) => {\n             let macro_def = sema.resolve_macro_call(&macro_call)?;\n-            (CallInfo::with_macro(sema.db, macro_def)?, false)\n+            FunctionSignature::from_macro(sema.db, macro_def)?\n         }\n     };\n \n     // If we have a calling expression let's find which argument we are on\n-    let num_params = call_info.parameters().len();\n+    let num_params = signature.parameters.len();\n \n-    match num_params {\n-        0 => (),\n-        1 => {\n-            if !has_self {\n-                call_info.active_parameter = Some(0);\n-            }\n-        }\n+    let active_parameter = match num_params {\n+        0 => None,\n+        1 if signature.has_self_param => None,\n+        1 => Some(0),\n         _ => {\n             if let Some(arg_list) = calling_node.arg_list() {\n                 // Number of arguments specified at the call site\n@@ -99,16 +104,18 @@ fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Op\n                 );\n \n                 // If we are in a method account for `self`\n-                if has_self {\n+                if signature.has_self_param {\n                     param += 1;\n                 }\n \n-                call_info.active_parameter = Some(param);\n+                Some(param)\n+            } else {\n+                None\n             }\n         }\n-    }\n+    };\n \n-    Some(call_info)\n+    Some(CallInfo { signature, active_parameter })\n }\n \n #[derive(Debug)]\n@@ -181,34 +188,6 @@ impl CallInfo {\n         let res = ActiveParameter { ty, name };\n         Some(res)\n     }\n-\n-    fn with_fn(db: &RootDatabase, function: hir::Function) -> Self {\n-        let signature = FunctionSignature::from_hir(db, function);\n-\n-        CallInfo { signature, active_parameter: None }\n-    }\n-\n-    fn with_struct(db: &RootDatabase, st: hir::Struct) -> Option<Self> {\n-        let signature = FunctionSignature::from_struct(db, st)?;\n-\n-        Some(CallInfo { signature, active_parameter: None })\n-    }\n-\n-    fn with_enum_variant(db: &RootDatabase, variant: hir::EnumVariant) -> Option<Self> {\n-        let signature = FunctionSignature::from_enum_variant(db, variant)?;\n-\n-        Some(CallInfo { signature, active_parameter: None })\n-    }\n-\n-    fn with_macro(db: &RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n-        let signature = FunctionSignature::from_macro(db, macro_def)?;\n-\n-        Some(CallInfo { signature, active_parameter: None })\n-    }\n-\n-    fn parameters(&self) -> &[String] {\n-        &self.signature.parameters\n-    }\n }\n \n #[cfg(test)]\n@@ -228,7 +207,8 @@ mod tests {\n                     Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n                 };\n                 let params = call_info\n-                    .parameters()\n+                    .signature\n+                    .parameters\n                     .iter()\n                     .enumerate()\n                     .map(|(i, param)| {"}, {"sha": "1d39544d3f617c6b9692147b88fab4946c342441", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 47, "deletions": 60, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee", "patch": "@@ -61,15 +61,11 @@ pub struct FunctionQualifier {\n }\n \n impl FunctionSignature {\n-    pub(crate) fn with_doc_opt(mut self, doc: Option<Documentation>) -> Self {\n-        self.doc = doc;\n-        self\n-    }\n-\n     pub(crate) fn from_hir(db: &RootDatabase, function: hir::Function) -> Self {\n-        let doc = function.docs(db);\n         let ast_node = function.source(db).value;\n-        FunctionSignature::from(&ast_node).with_doc_opt(doc)\n+        let mut res = FunctionSignature::from(&ast_node);\n+        res.doc = function.docs(db);\n+        res\n     }\n \n     pub(crate) fn from_struct(db: &RootDatabase, st: hir::Struct) -> Option<Self> {\n@@ -93,24 +89,21 @@ impl FunctionSignature {\n             params.push(raw_param);\n         }\n \n-        Some(\n-            FunctionSignature {\n-                kind: CallableKind::StructConstructor,\n-                visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n-                // Do we need `const`?\n-                qualifier: Default::default(),\n-                name: node.name().map(|n| n.text().to_string()),\n-                ret_type: node.name().map(|n| n.text().to_string()),\n-                parameters: params,\n-                parameter_names: vec![],\n-                parameter_types,\n-                generic_parameters: generic_parameters(&node),\n-                where_predicates: where_predicates(&node),\n-                doc: None,\n-                has_self_param: false,\n-            }\n-            .with_doc_opt(st.docs(db)),\n-        )\n+        Some(FunctionSignature {\n+            kind: CallableKind::StructConstructor,\n+            visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n+            // Do we need `const`?\n+            qualifier: Default::default(),\n+            name: node.name().map(|n| n.text().to_string()),\n+            ret_type: node.name().map(|n| n.text().to_string()),\n+            parameters: params,\n+            parameter_names: vec![],\n+            parameter_types,\n+            generic_parameters: generic_parameters(&node),\n+            where_predicates: where_predicates(&node),\n+            doc: st.docs(db),\n+            has_self_param: false,\n+        })\n     }\n \n     pub(crate) fn from_enum_variant(db: &RootDatabase, variant: hir::EnumVariant) -> Option<Self> {\n@@ -140,48 +133,42 @@ impl FunctionSignature {\n             params.push(format!(\"{}: {}\", name, ty.display(db)));\n         }\n \n-        Some(\n-            FunctionSignature {\n-                kind: CallableKind::VariantConstructor,\n-                visibility: None,\n-                // Do we need `const`?\n-                qualifier: Default::default(),\n-                name: Some(name),\n-                ret_type: None,\n-                parameters: params,\n-                parameter_names: vec![],\n-                parameter_types,\n-                generic_parameters: vec![],\n-                where_predicates: vec![],\n-                doc: None,\n-                has_self_param: false,\n-            }\n-            .with_doc_opt(variant.docs(db)),\n-        )\n+        Some(FunctionSignature {\n+            kind: CallableKind::VariantConstructor,\n+            visibility: None,\n+            // Do we need `const`?\n+            qualifier: Default::default(),\n+            name: Some(name),\n+            ret_type: None,\n+            parameters: params,\n+            parameter_names: vec![],\n+            parameter_types,\n+            generic_parameters: vec![],\n+            where_predicates: vec![],\n+            doc: variant.docs(db),\n+            has_self_param: false,\n+        })\n     }\n \n     pub(crate) fn from_macro(db: &RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n         let node: ast::MacroCall = macro_def.source(db).value;\n \n         let params = vec![];\n \n-        Some(\n-            FunctionSignature {\n-                kind: CallableKind::Macro,\n-                visibility: None,\n-                qualifier: Default::default(),\n-                name: node.name().map(|n| n.text().to_string()),\n-                ret_type: None,\n-                parameters: params,\n-                parameter_names: vec![],\n-                parameter_types: vec![],\n-                generic_parameters: vec![],\n-                where_predicates: vec![],\n-                doc: None,\n-                has_self_param: false,\n-            }\n-            .with_doc_opt(macro_def.docs(db)),\n-        )\n+        Some(FunctionSignature {\n+            kind: CallableKind::Macro,\n+            visibility: None,\n+            qualifier: Default::default(),\n+            name: node.name().map(|n| n.text().to_string()),\n+            ret_type: None,\n+            parameters: params,\n+            parameter_names: vec![],\n+            parameter_types: vec![],\n+            generic_parameters: vec![],\n+            where_predicates: vec![],\n+            doc: macro_def.docs(db),\n+            has_self_param: false,\n+        })\n     }\n }\n "}, {"sha": "5d1f64e1920d1afdb2963c8bd3a198d43c468106", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=2a14c43d5bd1803fc8c5dcddd2a5b8b30c4a5fee", "patch": "@@ -60,6 +60,7 @@ use crate::display::ToNav;\n \n pub use crate::{\n     call_hierarchy::CallItem,\n+    call_info::CallInfo,\n     completion::{\n         CompletionConfig, CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat,\n     },\n@@ -131,14 +132,6 @@ impl<T> RangeInfo<T> {\n     }\n }\n \n-/// Contains information about a call site. Specifically the\n-/// `FunctionSignature`and current parameter.\n-#[derive(Debug)]\n-pub struct CallInfo {\n-    pub signature: FunctionSignature,\n-    pub active_parameter: Option<usize>,\n-}\n-\n /// `AnalysisHost` stores the current state of the world.\n #[derive(Debug)]\n pub struct AnalysisHost {"}]}