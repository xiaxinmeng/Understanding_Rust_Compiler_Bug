{"sha": "5d4238b6fc8769c35ff5818ed04d16a6deab784f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNDIzOGI2ZmM4NzY5YzM1ZmY1ODE4ZWQwNGQxNmE2ZGVhYjc4NGY=", "commit": {"author": {"name": "kwantam", "email": "kwantam@gmail.com", "date": "2014-06-30T21:04:10Z"}, "committer": {"name": "kwantam", "email": "kwantam@gmail.com", "date": "2014-07-07T18:52:24Z"}, "message": "Add libunicode; move unicode functions from core\n\n- created new crate, libunicode, below libstd\n- split Char trait into Char (libcore) and UnicodeChar (libunicode)\n  - Unicode-aware functions now live in libunicode\n    - is_alphabetic, is_XID_start, is_XID_continue, is_lowercase,\n      is_uppercase, is_whitespace, is_alphanumeric, is_control,\n      is_digit, to_uppercase, to_lowercase\n  - added width method in UnicodeChar trait\n    - determines printed width of character in columns, or None if it is\n      a non-NULL control character\n    - takes a boolean argument indicating whether the present context is\n      CJK or not (characters with 'A'mbiguous widths are double-wide in\n      CJK contexts, single-wide otherwise)\n- split StrSlice into StrSlice (libcore) and UnicodeStrSlice\n  (libunicode)\n  - functionality formerly in StrSlice that relied upon Unicode\n    functionality from Char is now in UnicodeStrSlice\n    - words, is_whitespace, is_alphanumeric, trim, trim_left, trim_right\n  - also moved Words type alias into libunicode because words method is\n    in UnicodeStrSlice\n- unified Unicode tables from libcollections, libcore, and libregex into\n  libunicode\n- updated unicode.py in src/etc to generate aforementioned tables\n- generated new tables based on latest Unicode data\n- added UnicodeChar and UnicodeStrSlice traits to prelude\n- libunicode is now the collection point for the std::char module,\n  combining the libunicode functionality with the Char functionality\n  from libcore\n  - thus, moved doc comment for char from core::char to unicode::char\n- libcollections remains the collection point for std::str\n\nThe Unicode-aware functions that previously lived in the Char and\nStrSlice traits are no longer available to programs that only use\nlibcore. To regain use of these methods, include the libunicode crate\nand use the UnicodeChar and/or UnicodeStrSlice traits:\n\n    extern crate unicode;\n    use unicode::UnicodeChar;\n    use unicode::UnicodeStrSlice;\n    use unicode::Words; // if you want to use the words() method\n\nNOTE: this does *not* impact programs that use libstd, since UnicodeChar\nand UnicodeStrSlice have been added to the prelude.\n\ncloses #15224\n[breaking-change]", "tree": {"sha": "085ec3efe2b40fabad3603104a2f93f00df6926a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/085ec3efe2b40fabad3603104a2f93f00df6926a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d4238b6fc8769c35ff5818ed04d16a6deab784f", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4238b6fc8769c35ff5818ed04d16a6deab784f", "html_url": "https://github.com/rust-lang/rust/commit/5d4238b6fc8769c35ff5818ed04d16a6deab784f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d4238b6fc8769c35ff5818ed04d16a6deab784f/comments", "author": {"login": "kwantam", "id": 716593, "node_id": "MDQ6VXNlcjcxNjU5Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/716593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kwantam", "html_url": "https://github.com/kwantam", "followers_url": "https://api.github.com/users/kwantam/followers", "following_url": "https://api.github.com/users/kwantam/following{/other_user}", "gists_url": "https://api.github.com/users/kwantam/gists{/gist_id}", "starred_url": "https://api.github.com/users/kwantam/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kwantam/subscriptions", "organizations_url": "https://api.github.com/users/kwantam/orgs", "repos_url": "https://api.github.com/users/kwantam/repos", "events_url": "https://api.github.com/users/kwantam/events{/privacy}", "received_events_url": "https://api.github.com/users/kwantam/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kwantam", "id": 716593, "node_id": "MDQ6VXNlcjcxNjU5Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/716593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kwantam", "html_url": "https://github.com/kwantam", "followers_url": "https://api.github.com/users/kwantam/followers", "following_url": "https://api.github.com/users/kwantam/following{/other_user}", "gists_url": "https://api.github.com/users/kwantam/gists{/gist_id}", "starred_url": "https://api.github.com/users/kwantam/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kwantam/subscriptions", "organizations_url": "https://api.github.com/users/kwantam/orgs", "repos_url": "https://api.github.com/users/kwantam/repos", "events_url": "https://api.github.com/users/kwantam/events{/privacy}", "received_events_url": "https://api.github.com/users/kwantam/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f120e6bafe971452adfede158a7957b00562a4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f120e6bafe971452adfede158a7957b00562a4e", "html_url": "https://github.com/rust-lang/rust/commit/4f120e6bafe971452adfede158a7957b00562a4e"}], "stats": {"total": 19020, "additions": 7433, "deletions": 11587}, "files": [{"sha": "4ad16b785a4d7542eb4f9cf68b4cdbd4e1dcfc8c", "filename": "mk/crates.mk", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -51,17 +51,19 @@\n \n TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n-                 url log regex graphviz core rlibc alloc debug rustrt\n+                 url log regex graphviz core rlibc alloc debug rustrt \\\n+\t\t\t\t unicode\n HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n DEPS_core :=\n DEPS_rlibc :=\n+DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc\n DEPS_debug := std\n DEPS_rustrt := alloc core libc collections native:rustrt_native\n-DEPS_std := core libc rand alloc collections rustrt sync \\\n+DEPS_std := core libc rand alloc collections rustrt sync unicode \\\n \tnative:rust_builtin native:backtrace\n DEPS_graphviz := std\n DEPS_green := std native:context_switch\n@@ -82,7 +84,7 @@ DEPS_semver := std\n DEPS_uuid := std serialize\n DEPS_sync := core alloc rustrt collections\n DEPS_getopts := std\n-DEPS_collections := core alloc\n+DEPS_collections := core alloc unicode\n DEPS_fourcc := rustc syntax std\n DEPS_hexfloat := rustc syntax std\n DEPS_num := std\n@@ -108,6 +110,7 @@ ONLY_RLIB_rlibc := 1\n ONLY_RLIB_alloc := 1\n ONLY_RLIB_rand := 1\n ONLY_RLIB_collections := 1\n+ONLY_RLIB_unicode := 1\n \n ################################################################################\n # You should not need to edit below this line"}, {"sha": "5dc404736a4032452b4d62c5322b0c66b2832839", "filename": "src/etc/regex-unicode-tables.py", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/4f120e6bafe971452adfede158a7957b00562a4e/src%2Fetc%2Fregex-unicode-tables.py", "raw_url": "https://github.com/rust-lang/rust/raw/4f120e6bafe971452adfede158a7957b00562a4e/src%2Fetc%2Fregex-unicode-tables.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fregex-unicode-tables.py?ref=4f120e6bafe971452adfede158a7957b00562a4e", "patch": "@@ -1,183 +0,0 @@\n-#!/usr/bin/env python2\n-\n-# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-from __future__ import absolute_import, division, print_function\n-import argparse\n-from collections import defaultdict\n-import csv\n-import datetime\n-import urllib2\n-\n-BASE_URL = 'http://www.unicode.org/Public/6.3.0/ucd/'\n-DATA = 'UnicodeData.txt'\n-SCRIPTS = 'Scripts.txt'\n-\n-# Mapping taken from Table 12 from:\n-# http://www.unicode.org/reports/tr44/#General_Category_Values\n-expanded_categories = {\n-    'Lu': ['LC', 'L'], 'Ll': ['LC', 'L'], 'Lt': ['LC', 'L'],\n-    'Lm': ['L'], 'Lo': ['L'],\n-    'Mn': ['M'], 'Mc': ['M'], 'Me': ['M'],\n-    'Nd': ['N'], 'Nl': ['N'], 'No': ['No'],\n-    'Pc': ['P'], 'Pd': ['P'], 'Ps': ['P'], 'Pe': ['P'],\n-    'Pi': ['P'], 'Pf': ['P'], 'Po': ['P'],\n-    'Sm': ['S'], 'Sc': ['S'], 'Sk': ['S'], 'So': ['S'],\n-    'Zs': ['Z'], 'Zl': ['Z'], 'Zp': ['Z'],\n-    'Cc': ['C'], 'Cf': ['C'], 'Cs': ['C'], 'Co': ['C'], 'Cn': ['C'],\n-}\n-\n-\n-def as_4byte_uni(n):\n-    s = hex(n)[2:]\n-    return '\\\\U%s%s' % ('0' * (8 - len(s)), s)\n-\n-\n-def expand_cat(c):\n-    return expanded_categories.get(c, []) + [c]\n-\n-\n-def is_valid_unicode(n):\n-    return 0 <= n <= 0xD7FF or 0xE000 <= n <= 0x10FFFF\n-\n-\n-def read_cats(f):\n-    assigned = defaultdict(list)\n-    for row in csv.reader(f, delimiter=';'):\n-        (hex, cats) = (int(row[0], 16), expand_cat(row[2]))\n-        if not is_valid_unicode(hex):\n-            continue\n-        for cat in cats:\n-            assigned[cat].append(hex)\n-    return assigned\n-\n-\n-def read_scripts(f):\n-    assigned = defaultdict(list)\n-    for line in f:\n-        line = line.strip()\n-        if not line or line.startswith('#'):\n-            continue\n-        hexes, name = map(str.strip, line.split(';'))[:2]\n-        name = name[:name.index('#')].strip()\n-        if '..' not in hexes:\n-            hex = int(hexes, 16)\n-            if is_valid_unicode(hex):\n-                assigned[name].append(hex)\n-        else:\n-            hex1, hex2 = map(lambda s: int(s, 16), hexes.split('..'))\n-            for hex in xrange(hex1, hex2 + 1):\n-                if is_valid_unicode(hex):\n-                    assigned[name].append(hex)\n-    return assigned\n-\n-\n-def group(letters):\n-    letters = sorted(set(letters))\n-    grouped = []\n-    cur_start = letters.pop(0)\n-    cur_end = cur_start\n-    for letter in letters:\n-        assert letter > cur_end, \\\n-            'cur_end: %s, letter: %s' % (hex(cur_end), hex(letter))\n-\n-        if letter == cur_end + 1:\n-            cur_end = letter\n-        else:\n-            grouped.append((cur_start, cur_end))\n-            cur_start, cur_end = letter, letter\n-    grouped.append((cur_start, cur_end))\n-    return grouped\n-\n-\n-def ranges_to_rust(rs):\n-    rs = (\"('%s', '%s')\" % (as_4byte_uni(s), as_4byte_uni(e)) for s, e in rs)\n-    return ',\\n    '.join(rs)\n-\n-\n-def groups_to_rust(groups):\n-    rust_groups = []\n-    for group_name in sorted(groups):\n-        rust_groups.append('(\"%s\", &[\\n    %s\\n    ]),'\n-                           % (group_name, ranges_to_rust(groups[group_name])))\n-    return '\\n'.join(rust_groups)\n-\n-\n-if __name__ == '__main__':\n-    parser = argparse.ArgumentParser(\n-        description='Generate Unicode character class tables.')\n-    aa = parser.add_argument\n-    aa('--local', action='store_true',\n-       help='When set, Scripts.txt and UnicodeData.txt will be read from '\n-            'the CWD.')\n-    aa('--base-url', type=str, default=BASE_URL,\n-       help='The base URL to use for downloading Unicode data files.')\n-    args = parser.parse_args()\n-\n-    if args.local:\n-        cats = read_cats(open(DATA))\n-        scripts = read_scripts(open(SCRIPTS))\n-    else:\n-        cats = read_cats(urllib2.urlopen(args.base_url + '/' + DATA))\n-        scripts = read_scripts(urllib2.urlopen(args.base_url + '/' + SCRIPTS))\n-\n-    # Get Rust code for all Unicode general categories and scripts.\n-    combined = dict(cats, **scripts)\n-    unigroups = groups_to_rust({k: group(letters)\n-                                for k, letters in combined.items()})\n-\n-    # Now get Perl character classes that are Unicode friendly.\n-    perld = range(ord('0'), ord('9') + 1)\n-    dgroups = ranges_to_rust(group(perld + cats['Nd'][:]))\n-\n-    perls = map(ord, ['\\t', '\\n', '\\x0C', '\\r', ' '])\n-    sgroups = ranges_to_rust(group(perls + cats['Z'][:]))\n-\n-    low, up = (range(ord('a'), ord('z') + 1), range(ord('A'), ord('Z') + 1))\n-    perlw = [ord('_')] + perld + low + up\n-    wgroups = ranges_to_rust(group(perlw + cats['L'][:]))\n-\n-    tpl = '''// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// DO NOT EDIT. Automatically generated by 'src/etc/regexp-unicode-tables'\n-// on {date}.\n-\n-use parse::{{Class, NamedClasses}};\n-\n-pub static UNICODE_CLASSES: NamedClasses = &[\n-\n-{groups}\n-\n-];\n-\n-pub static PERLD: Class = &[\n-    {dgroups}\n-];\n-\n-pub static PERLS: Class = &[\n-    {sgroups}\n-];\n-\n-pub static PERLW: Class = &[\n-    {wgroups}\n-];\n-'''\n-    now = datetime.datetime.now()\n-    print(tpl.format(date=str(now), groups=unigroups,\n-                     dgroups=dgroups, sgroups=sgroups, wgroups=wgroups))"}, {"sha": "a87c755397d94d4ad64b816e406342f909cdeb31", "filename": "src/etc/unicode.py", "status": "modified", "additions": 351, "deletions": 285, "changes": 636, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -10,17 +10,46 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-# This digests UnicodeData.txt and DerivedCoreProperties.txt and emits rust\n-# code covering the core properties. Since this is a pretty rare event we\n-# just store this out-of-line and check the unicode.rs file into git.\n+# This script uses the following Unicode tables:\n+# - DerivedCoreProperties.txt\n+# - EastAsianWidth.txt\n+# - PropList.txt\n+# - Scripts.txt\n+# - UnicodeData.txt\n #\n-# The emitted code is \"the minimum we think is necessary for libstd\", that\n-# is, to support basic operations of the compiler and \"most nontrivial rust\n-# programs\". It is not meant to be a complete implementation of unicode.\n-# For that we recommend you use a proper binding to libicu.\n+# Since this should not require frequent updates, we just store this\n+# out-of-line and check the unicode.rs file into git.\n \n import fileinput, re, os, sys, operator\n \n+preamble = '''// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n+\n+#![allow(missing_doc, non_uppercase_statics, non_snake_case_functions)]\n+'''\n+\n+# Mapping taken from Table 12 from:\n+# http://www.unicode.org/reports/tr44/#General_Category_Values\n+expanded_categories = {\n+    'Lu': ['LC', 'L'], 'Ll': ['LC', 'L'], 'Lt': ['LC', 'L'],\n+    'Lm': ['L'], 'Lo': ['L'],\n+    'Mn': ['M'], 'Mc': ['M'], 'Me': ['M'],\n+    'Nd': ['N'], 'Nl': ['N'], 'No': ['No'],\n+    'Pc': ['P'], 'Pd': ['P'], 'Ps': ['P'], 'Pe': ['P'],\n+    'Pi': ['P'], 'Pf': ['P'], 'Po': ['P'],\n+    'Sm': ['S'], 'Sc': ['S'], 'Sk': ['S'], 'So': ['S'],\n+    'Zs': ['Z'], 'Zl': ['Z'], 'Zp': ['Z'],\n+    'Cc': ['C'], 'Cf': ['C'], 'Cs': ['C'], 'Co': ['C'], 'Cn': ['C'],\n+}\n \n def fetch(f):\n     if not os.path.exists(f):\n@@ -31,21 +60,17 @@ def fetch(f):\n         sys.stderr.write(\"cannot load %s\" % f)\n         exit(1)\n \n+def is_valid_unicode(n):\n+    return 0 <= n <= 0xD7FF or 0xE000 <= n <= 0x10FFFF\n \n def load_unicode_data(f):\n     fetch(f)\n     gencats = {}\n     upperlower = {}\n     lowerupper = {}\n-    combines = []\n+    combines = {}\n     canon_decomp = {}\n     compat_decomp = {}\n-    curr_cat = \"\"\n-    curr_combine = \"\"\n-    c_lo = 0\n-    c_hi = 0\n-    com_lo = 0\n-    com_hi = 0\n \n     for line in fileinput.input(f):\n         fields = line.split(\";\")\n@@ -58,6 +83,9 @@ def load_unicode_data(f):\n         code_org = code\n         code     = int(code, 16)\n \n+        if not is_valid_unicode(code):\n+            continue\n+\n         # generate char to char direct common and simple conversions\n         # uppercase to lowercase\n         if gencat == \"Lu\" and lowcase != \"\" and code_org != lowcase:\n@@ -67,6 +95,7 @@ def load_unicode_data(f):\n         if gencat == \"Ll\" and upcase != \"\" and code_org != upcase:\n             lowerupper[code] = int(upcase, 16)\n \n+        # store decomposition, if given\n         if decomp != \"\":\n             if decomp.startswith('<'):\n                 seq = []\n@@ -79,37 +108,75 @@ def load_unicode_data(f):\n                     seq.append(int(i, 16))\n                 canon_decomp[code] = seq\n \n-        if curr_cat == \"\":\n-            curr_cat = gencat\n-            c_lo = code\n-            c_hi = code\n+        # place letter in categories as appropriate\n+        for cat in [gencat] + expanded_categories.get(gencat, []):\n+            if cat not in gencats:\n+                gencats[cat] = []\n+            gencats[cat].append(code)\n \n-        if curr_cat == gencat:\n-            c_hi = code\n-        else:\n-            if curr_cat not in gencats:\n-                gencats[curr_cat] = []\n+        # record combining class, if any\n+        if combine != \"0\":\n+            if combine not in combines:\n+                combines[combine] = []\n+            combines[combine].append(code)\n \n-            gencats[curr_cat].append((c_lo, c_hi))\n-            curr_cat = gencat\n-            c_lo = code\n-            c_hi = code\n+    gencats = group_cats(gencats)\n+    combines = to_combines(group_cats(combines))\n \n-        if curr_combine == \"\":\n-            curr_combine = combine\n-            com_lo = code\n-            com_hi = code\n+    return (canon_decomp, compat_decomp, gencats, combines, lowerupper, upperlower)\n \n-        if curr_combine == combine:\n-            com_hi = code\n+def group_cats(cats):\n+    cats_out = {}\n+    for cat in cats:\n+        cats_out[cat] = group_cat(cats[cat])\n+    return cats_out\n+\n+def group_cat(cat):\n+    cat_out = []\n+    letters = sorted(set(cat))\n+    cur_start = letters.pop(0)\n+    cur_end = cur_start\n+    for letter in letters:\n+        assert letter > cur_end, \\\n+            \"cur_end: %s, letter: %s\" % (hex(cur_end), hex(letter))\n+        if letter == cur_end + 1:\n+            cur_end = letter\n         else:\n-            if curr_combine != \"0\":\n-                combines.append((com_lo, com_hi, curr_combine))\n-            curr_combine = combine\n-            com_lo = code\n-            com_hi = code\n+            cat_out.append((cur_start, cur_end))\n+            cur_start = cur_end = letter\n+    cat_out.append((cur_start, cur_end))\n+    return cat_out\n+\n+def ungroup_cat(cat):\n+    cat_out = []\n+    for (lo, hi) in cat:\n+        while lo <= hi:\n+            cat_out.append(lo)\n+            lo += 1\n+    return cat_out\n+\n+def to_combines(combs):\n+    combs_out = []\n+    for comb in combs:\n+        for (lo, hi) in combs[comb]:\n+            combs_out.append((lo, hi, comb))\n+    combs_out.sort(key=lambda comb: comb[0])\n+    return combs_out\n \n-    return (canon_decomp, compat_decomp, gencats, combines, lowerupper, upperlower)\n+def format_table_content(f, content, indent):\n+    line = \" \"*indent\n+    first = True\n+    for chunk in content.split(\",\"):\n+        if len(line) + len(chunk) < 98:\n+            if first:\n+                line += chunk\n+            else:\n+                line += \", \" + chunk\n+            first = False\n+        else:\n+            f.write(line + \",\\n\")\n+            line = \" \"*indent + chunk\n+    f.write(line)\n \n def load_properties(f, interestingprops):\n     fetch(f)\n@@ -134,7 +201,7 @@ def load_properties(f, interestingprops):\n                 prop = m.group(3)\n             else:\n                 continue\n-        if prop not in interestingprops:\n+        if interestingprops and prop not in interestingprops:\n             continue\n         d_lo = int(d_lo, 16)\n         d_hi = int(d_hi, 16)\n@@ -143,66 +210,116 @@ def load_properties(f, interestingprops):\n         props[prop].append((d_lo, d_hi))\n     return props\n \n+# load all widths of want_widths, except those in except_cats\n+def load_east_asian_width(want_widths, except_cats):\n+    f = \"EastAsianWidth.txt\"\n+    fetch(f)\n+    widths = {}\n+    re1 = re.compile(\"^([0-9A-F]+);(\\w+) +# (\\w+)\")\n+    re2 = re.compile(\"^([0-9A-F]+)\\.\\.([0-9A-F]+);(\\w+) +# (\\w+)\")\n+\n+    for line in fileinput.input(f):\n+        width = None\n+        d_lo = 0\n+        d_hi = 0\n+        cat = None\n+        m = re1.match(line)\n+        if m:\n+            d_lo = m.group(1)\n+            d_hi = m.group(1)\n+            width = m.group(2)\n+            cat = m.group(3)\n+        else:\n+            m = re2.match(line)\n+            if m:\n+                d_lo = m.group(1)\n+                d_hi = m.group(2)\n+                width = m.group(3)\n+                cat = m.group(4)\n+            else:\n+                continue\n+        if cat in except_cats or width not in want_widths:\n+            continue\n+        d_lo = int(d_lo, 16)\n+        d_hi = int(d_hi, 16)\n+        if width not in widths:\n+            widths[width] = []\n+        widths[width].append((d_lo, d_hi))\n+    return widths\n+\n def escape_char(c):\n     if c <= 0xff:\n         return \"'\\\\x%2.2x'\" % c\n     if c <= 0xffff:\n         return \"'\\\\u%4.4x'\" % c\n     return \"'\\\\U%8.8x'\" % c\n \n-def ch_prefix(ix):\n-    if ix == 0:\n-        return \"        \"\n-    if ix % 2 == 0:\n-        return \",\\n        \"\n-    else:\n-        return \", \"\n-\n def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n-    use cmp::{Equal, Less, Greater};\n-    use slice::ImmutableVector;\n-    use option::None;\n+    use core::cmp::{Equal, Less, Greater};\n+    use core::slice::ImmutableVector;\n+    use core::option::None;\n     r.bsearch(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n         else { Greater }\n     }) != None\n }\\n\n-\"\"\");\n+\"\"\")\n+\n+def emit_table(f, name, t_data, t_type = \"&'static [(char, char)]\", is_pub=True,\n+        pfun=lambda x: \"(%s,%s)\" % (escape_char(x[0]), escape_char(x[1]))):\n+    pub_string = \"\"\n+    if is_pub:\n+        pub_string = \"pub \"\n+    f.write(\"    %sstatic %s: %s = &[\\n\" % (pub_string, name, t_type))\n+    data = \"\"\n+    first = True\n+    for dat in t_data:\n+        if not first:\n+            data += \",\"\n+        first = False\n+        data += pfun(dat)\n+    format_table_content(f, data, 8)\n+    f.write(\"\\n    ];\\n\\n\")\n \n-def emit_property_module(f, mod, tbl):\n+def emit_property_module(f, mod, tbl, emit_fn):\n     f.write(\"pub mod %s {\\n\" % mod)\n     keys = tbl.keys()\n     keys.sort()\n-\n     for cat in keys:\n-        if cat not in [\"Nd\", \"Nl\", \"No\", \"Cc\",\n-            \"XID_Start\", \"XID_Continue\", \"Alphabetic\",\n-            \"Lowercase\", \"Uppercase\", \"White_Space\"]:\n-            continue\n-        f.write(\"    static %s_table : &'static [(char,char)] = &[\\n\" % cat)\n-        ix = 0\n-        for pair in tbl[cat]:\n-            f.write(ch_prefix(ix))\n-            f.write(\"(%s, %s)\" % (escape_char(pair[0]), escape_char(pair[1])))\n-            ix += 1\n-        f.write(\"\\n    ];\\n\\n\")\n-\n-        f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n-        f.write(\"        super::bsearch_range_table(c, %s_table)\\n\" % cat)\n-        f.write(\"    }\\n\\n\")\n+        emit_table(f, \"%s_table\" % cat, tbl[cat])\n+        if cat in emit_fn:\n+            f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n+            f.write(\"        super::bsearch_range_table(c, %s_table)\\n\" % cat)\n+            f.write(\"    }\\n\\n\")\n     f.write(\"}\\n\\n\")\n \n+def emit_regex_module(f, cats, w_data):\n+    f.write(\"pub mod regex {\\n\")\n+    regex_class = \"&'static [(char, char)]\"\n+    class_table = \"&'static [(&'static str, %s)]\" % regex_class\n+\n+    emit_table(f, \"UNICODE_CLASSES\", cats, class_table,\n+        pfun=lambda x: \"(\\\"%s\\\",super::%s::%s_table)\" % (x[0], x[1], x[0]))\n+\n+    f.write(\"    pub static PERLD: %s = super::general_category::Nd_table;\\n\\n\"\n+            % regex_class)\n+    f.write(\"    pub static PERLS: %s = super::property::White_Space_table;\\n\\n\"\n+            % regex_class)\n+\n+    emit_table(f, \"PERLW\", w_data, regex_class)\n+\n+    f.write(\"}\\n\\n\")\n \n def emit_conversions_module(f, lowerupper, upperlower):\n     f.write(\"pub mod conversions {\")\n     f.write(\"\"\"\n-    use cmp::{Equal, Less, Greater};\n-    use slice::ImmutableVector;\n-    use tuple::Tuple2;\n-    use option::{Option, Some, None};\n+    use core::cmp::{Equal, Less, Greater};\n+    use core::slice::ImmutableVector;\n+    use core::tuple::Tuple2;\n+    use core::option::{Option, Some, None};\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n@@ -226,189 +343,88 @@ def emit_conversions_module(f, lowerupper, upperlower):\n         })\n     }\n \n-\"\"\");\n-    emit_caseconversion_table(f, \"LuLl\", upperlower)\n-    emit_caseconversion_table(f, \"LlLu\", lowerupper)\n-    f.write(\"}\\n\")\n-\n-def emit_caseconversion_table(f, name, table):\n-    f.write(\"    static %s_table : &'static [(char, char)] = &[\\n\" % name)\n-    sorted_table = sorted(table.iteritems(), key=operator.itemgetter(0))\n-    ix = 0\n-    for key, value in sorted_table:\n-        f.write(ch_prefix(ix))\n-        f.write(\"(%s, %s)\" % (escape_char(key), escape_char(value)))\n-        ix += 1\n-    f.write(\"\\n    ];\\n\\n\")\n-\n-def format_table_content(f, content, indent):\n-    line = \" \"*indent\n-    first = True\n-    for chunk in content.split(\",\"):\n-        if len(line) + len(chunk) < 98:\n-            if first:\n-                line += chunk\n-            else:\n-                line += \", \" + chunk\n-            first = False\n-        else:\n-            f.write(line + \",\\n\")\n-            line = \" \"*indent + chunk\n-    f.write(line)\n-\n-def emit_core_norm_module(f, canon, compat):\n-    canon_keys = canon.keys()\n-    canon_keys.sort()\n+\"\"\")\n+    emit_table(f, \"LuLl_table\",\n+        sorted(upperlower.iteritems(), key=operator.itemgetter(0)), is_pub=False)\n+    emit_table(f, \"LlLu_table\",\n+        sorted(lowerupper.iteritems(), key=operator.itemgetter(0)), is_pub=False)\n+    f.write(\"}\\n\\n\")\n \n-    compat_keys = compat.keys()\n-    compat_keys.sort()\n-    f.write(\"pub mod normalization {\\n\");\n-    f.write(\"    use option::Option;\\n\");\n-    f.write(\"    use option::{Some, None};\\n\");\n-    f.write(\"    use slice::ImmutableVector;\\n\");\n+def emit_charwidth_module(f, width_table):\n+    f.write(\"pub mod charwidth {\\n\")\n+    f.write(\"    use core::option::{Option, Some, None};\\n\")\n+    f.write(\"    use core::slice::ImmutableVector;\\n\")\n     f.write(\"\"\"\n-    fn bsearch_table(c: char, r: &'static [(char, &'static [char])]) -> Option<&'static [char]> {\n-        use cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(val, _)| {\n-            if c == val { Equal }\n-            else if val < c { Less }\n+    fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n+        use core::cmp::{Equal, Less, Greater};\n+        match r.bsearch(|&(lo, hi, _, _)| {\n+            if lo <= c && c <= hi { Equal }\n+            else if hi < c { Less }\n             else { Greater }\n         }) {\n             Some(idx) => {\n-                let (_, result) = r[idx];\n-                Some(result)\n+                let (_, _, r_ncjk, r_cjk) = r[idx];\n+                if is_cjk { r_cjk } else { r_ncjk }\n             }\n-            None => None\n+            None => 1\n         }\n-    }\\n\\n\n+    }\n \"\"\")\n \n-    f.write(\"    // Canonical decompositions\\n\")\n-    f.write(\"    static canonical_table : &'static [(char, &'static [char])] = &[\\n\")\n-    data = \"\"\n-    first = True\n-    for char in canon_keys:\n-        if not first:\n-            data += \",\"\n-        first = False\n-        data += \"(%s,&[\" % escape_char(char)\n-        first2 = True\n-        for d in canon[char]:\n-            if not first2:\n-                data += \",\"\n-            first2 = False\n-            data += escape_char(d)\n-        data += \"])\"\n-    format_table_content(f, data, 8)\n-    f.write(\"\\n    ];\\n\\n\")\n-\n-    f.write(\"    // Compatibility decompositions\\n\")\n-    f.write(\"    static compatibility_table : &'static [(char, &'static [char])] = &[\\n\")\n-    data = \"\"\n-    first = True\n-    for char in compat_keys:\n-        if not first:\n-            data += \",\"\n-        first = False\n-        data += \"(%s,&[\" % escape_char(char)\n-        first2 = True\n-        for d in compat[char]:\n-            if not first2:\n-                data += \",\"\n-            first2 = False\n-            data += escape_char(d)\n-        data += \"])\"\n-    format_table_content(f, data, 8)\n-    f.write(\"\\n    ];\\n\\n\")\n-\n     f.write(\"\"\"\n-    pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }\n-\n-    pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }\n-\n-    fn d(c: char, i: |char|, k: bool) {\n-        use iter::Iterator;\n-\n-        // 7-bit ASCII never decomposes\n-        if c <= '\\\\x7f' { i(c); return; }\n-\n-        // Perform decomposition for Hangul\n-        if (c as u32) >= S_BASE && (c as u32) < (S_BASE + S_COUNT) {\n-            decompose_hangul(c, i);\n-            return;\n+    pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n+        match c as uint {\n+            _c @ 0 => Some(0),          // null is zero width\n+            cu if cu < 0x20 => None,    // control sequences have no width\n+            cu if cu < 0x7F => Some(1), // ASCII\n+            cu if cu < 0xA0 => None,    // more control sequences\n+            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as uint)\n         }\n+    }\n \n-        // First check the canonical decompositions\n-        match bsearch_table(c, canonical_table) {\n-            Some(canon) => {\n-                for x in canon.iter() {\n-                    d(*x, |b| i(b), k);\n-                }\n-                return;\n-            }\n-            None => ()\n-        }\n+\"\"\")\n \n-        // Bottom out if we're not doing compat.\n-        if !k { i(c); return; }\n+    f.write(\"    // character width table. Based on Markus Kuhn's free wcwidth() implementation,\\n\")\n+    f.write(\"    //     http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c\\n\")\n+    emit_table(f, \"charwidth_table\", width_table, \"&'static [(char, char, u8, u8)]\", is_pub=False,\n+            pfun=lambda x: \"(%s,%s,%s,%s)\" % (escape_char(x[0]), escape_char(x[1]), x[2], x[3]))\n+    f.write(\"}\\n\")\n \n-        // Then check the compatibility decompositions\n-        match bsearch_table(c, compatibility_table) {\n-            Some(compat) => {\n-                for x in compat.iter() {\n-                    d(*x, |b| i(b), k);\n-                }\n-                return;\n-            }\n-            None => ()\n-        }\n+def emit_norm_module(f, canon, compat, combine):\n+    canon_keys = canon.keys()\n+    canon_keys.sort()\n \n-        // Finally bottom out.\n-        i(c);\n-    }\n+    compat_keys = compat.keys()\n+    compat_keys.sort()\n \n-    // Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n-    static S_BASE: u32 = 0xAC00;\n-    static L_BASE: u32 = 0x1100;\n-    static V_BASE: u32 = 0x1161;\n-    static T_BASE: u32 = 0x11A7;\n-    static L_COUNT: u32 = 19;\n-    static V_COUNT: u32 = 21;\n-    static T_COUNT: u32 = 28;\n-    static N_COUNT: u32 = (V_COUNT * T_COUNT);\n-    static S_COUNT: u32 = (L_COUNT * N_COUNT);\n-\n-    // Decompose a precomposed Hangul syllable\n-    fn decompose_hangul(s: char, f: |char|) {\n-        use cast::transmute;\n-\n-        let si = s as u32 - S_BASE;\n-\n-        let li = si / N_COUNT;\n-        unsafe {\n-            f(transmute(L_BASE + li));\n-\n-            let vi = (si % N_COUNT) / T_COUNT;\n-            f(transmute(V_BASE + vi));\n-\n-            let ti = si % T_COUNT;\n-            if ti > 0 {\n-                f(transmute(T_BASE + ti));\n-            }\n-        }\n-    }\n-}\n+    f.write(\"pub mod normalization {\\n\")\n+\n+    def mkdata_fun(table):\n+        def f(char):\n+            data = \"(%s,&[\" % escape_char(char)\n+            first = True\n+            for d in table[char]:\n+                if not first:\n+                    data += \",\"\n+                first = False\n+                data += escape_char(d)\n+            data += \"])\"\n+            return data\n+        return f\n \n-\"\"\")\n+    f.write(\"    // Canonical decompositions\\n\")\n+    emit_table(f, \"canonical_table\", canon_keys, \"&'static [(char, &'static [char])]\",\n+        pfun=mkdata_fun(canon))\n \n-def emit_std_norm_module(f, combine):\n-    f.write(\"pub mod normalization {\\n\");\n-    f.write(\"    use option::{Some, None};\\n\");\n-    f.write(\"    use slice::ImmutableVector;\\n\");\n+    f.write(\"    // Compatibility decompositions\\n\")\n+    emit_table(f, \"compatibility_table\", compat_keys, \"&'static [(char, &'static [char])]\",\n+        pfun=mkdata_fun(compat))\n \n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        use cmp::{Equal, Less, Greater};\n+        use core::option::{Some, None};\n+        use core::cmp::{Equal, Less, Greater};\n+        use core::slice::ImmutableVector;\n         match r.bsearch(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n@@ -420,72 +436,122 @@ def emit_std_norm_module(f, combine):\n             }\n             None => 0\n         }\n-    }\\n\\n\n+    }\\n\n \"\"\")\n \n-    f.write(\"    static combining_class_table : &'static [(char, char, u8)] = &[\\n\")\n-    ix = 0\n-    for pair in combine:\n-        f.write(ch_prefix(ix))\n-        f.write(\"(%s, %s, %s)\" % (escape_char(pair[0]), escape_char(pair[1]), pair[2]))\n-        ix += 1\n-    f.write(\"\\n    ];\\n\\n\")\n+    emit_table(f, \"combining_class_table\", combine, \"&'static [(char, char, u8)]\", is_pub=False,\n+            pfun=lambda x: \"(%s,%s,%s)\" % (escape_char(x[0]), escape_char(x[1]), x[2]))\n \n     f.write(\"    pub fn canonical_combining_class(c: char) -> u8 {\\n\"\n         + \"        bsearch_range_value_table(c, combining_class_table)\\n\"\n         + \"    }\\n\")\n-    f.write(\"}\\n\")\n-\n-\n-preamble = '''// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n \n-// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n-\n-#![allow(missing_doc, non_uppercase_statics)]\n+    f.write(\"\"\"\n+}\n \n-'''\n+\"\"\")\n \n-(canon_decomp, compat_decomp, gencats,\n- combines, lowerupper, upperlower) = load_unicode_data(\"UnicodeData.txt\")\n+def remove_from_wtable(wtable, val):\n+    wtable_out = []\n+    while wtable:\n+        if wtable[0][1] < val:\n+            wtable_out.append(wtable.pop(0))\n+        elif wtable[0][0] > val:\n+            break\n+        else:\n+            (wt_lo, wt_hi, width, width_cjk) = wtable.pop(0)\n+            if wt_lo == wt_hi == val:\n+                continue\n+            elif wt_lo == val:\n+                wtable_out.append((wt_lo+1, wt_hi, width, width_cjk))\n+            elif wt_hi == val:\n+                wtable_out.append((wt_lo, wt_hi-1, width, width_cjk))\n+            else:\n+                wtable_out.append((wt_lo, val-1, width, width_cjk))\n+                wtable_out.append((val+1, wt_hi, width, width_cjk))\n+    if wtable:\n+        wtable_out.extend(wtable)\n+    return wtable_out\n+\n+def optimize_width_table(wtable):\n+    wtable_out = []\n+    w_this = wtable.pop(0)\n+    while wtable:\n+        if w_this[1] == wtable[0][0] - 1 and w_this[2:3] == wtable[0][2:3]:\n+            w_tmp = wtable.pop(0)\n+            w_this = (w_this[0], w_tmp[1], w_tmp[2], w_tmp[3])\n+        else:\n+            wtable_out.append(w_this)\n+            w_this = wtable.pop(0)\n+    wtable_out.append(w_this)\n+    return wtable_out\n \n-def gen_core_unicode():\n-    r = \"core_unicode.rs\"\n+if __name__ == \"__main__\":\n+    r = \"unicode.rs\"\n     if os.path.exists(r):\n-        os.remove(r);\n+        os.remove(r)\n     with open(r, \"w\") as rf:\n-        # Preamble\n+        # write the file's preamble\n         rf.write(preamble)\n \n-        emit_bsearch_range_table(rf);\n-        emit_property_module(rf, \"general_category\", gencats)\n-\n-        emit_core_norm_module(rf, canon_decomp, compat_decomp)\n+        # download and parse all the data\n+        (canon_decomp, compat_decomp, gencats, combines,\n+                lowerupper, upperlower) = load_unicode_data(\"UnicodeData.txt\")\n+        want_derived = [\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\"]\n+        other_derived = [\"Default_Ignorable_Code_Point\"]\n+        derived = load_properties(\"DerivedCoreProperties.txt\", want_derived + other_derived)\n+        scripts = load_properties(\"Scripts.txt\", [])\n+        props = load_properties(\"PropList.txt\",\n+                [\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\"])\n+\n+        # bsearch_range_table is used in all the property modules below\n+        emit_bsearch_range_table(rf)\n+\n+        # all of these categories will also be available as \\p{} in libregex\n+        allcats = []\n+        for (name, cat, pfuns) in (\"general_category\", gencats, [\"N\", \"Cc\"]), \\\n+                                  (\"derived_property\", derived, want_derived), \\\n+                                  (\"script\", scripts, []), \\\n+                                  (\"property\", props, [\"White_Space\"]):\n+            emit_property_module(rf, name, cat, pfuns)\n+            allcats.extend(map(lambda x: (x, name), cat))\n+        allcats.sort(key=lambda c: c[0])\n+\n+        # the \\w regex corresponds to Alphabetic + Mark + Decimal_Number +\n+        # Connector_Punctuation + Join-Control according to UTS#18\n+        # http://www.unicode.org/reports/tr18/#Compatibility_Properties\n+        perl_words = []\n+        for cat in derived[\"Alphabetic\"], gencats[\"M\"], gencats[\"Nd\"], \\\n+                   gencats[\"Pc\"], props[\"Join_Control\"]:\n+            perl_words.extend(ungroup_cat(cat))\n+        perl_words = group_cat(perl_words)\n+\n+        # emit lookup tables for \\p{}, along with \\d, \\w, and \\s for libregex\n+        emit_regex_module(rf, allcats, perl_words)\n+\n+        # normalizations and conversions module\n+        emit_norm_module(rf, canon_decomp, compat_decomp, combines)\n+        emit_conversions_module(rf, lowerupper, upperlower)\n \n-        derived = load_properties(\"DerivedCoreProperties.txt\",\n-                [\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\"])\n+        # character width module\n+        width_table = []\n+        for zwcat in [\"Me\", \"Mn\", \"Cf\"]:\n+            width_table.extend(map(lambda (lo, hi): (lo, hi, 0, 0), gencats[zwcat]))\n+        width_table.append((4448, 4607, 0, 0))\n \n-        emit_property_module(rf, \"derived_property\", derived)\n+        # get widths, except those that are explicitly marked zero-width above\n+        ea_widths = load_east_asian_width([\"W\", \"F\", \"A\"], [\"Me\", \"Mn\", \"Cf\"])\n+        # these are doublewidth\n+        for dwcat in [\"W\", \"F\"]:\n+            width_table.extend(map(lambda (lo, hi): (lo, hi, 2, 2), ea_widths[dwcat]))\n+        width_table.extend(map(lambda (lo, hi): (lo, hi, 1, 2), ea_widths[\"A\"]))\n \n-        props = load_properties(\"PropList.txt\", [\"White_Space\"])\n-        emit_property_module(rf, \"property\", props)\n-        emit_conversions_module(rf, lowerupper, upperlower)\n+        width_table.sort(key=lambda w: w[0])\n \n-def gen_std_unicode():\n-    r = \"std_unicode.rs\"\n-    if os.path.exists(r):\n-        os.remove(r);\n-    with open(r, \"w\") as rf:\n-        # Preamble\n-        rf.write(preamble)\n-        emit_std_norm_module(rf, combines)\n+        # soft hyphen is not zero width in preformatted text; it's used to indicate\n+        # a hyphen inserted to facilitate a linebreak.\n+        width_table = remove_from_wtable(width_table, 173)\n \n-gen_core_unicode()\n-gen_std_unicode()\n+        # optimize the width table by collapsing adjacent entities when possible\n+        width_table = optimize_width_table(width_table)\n+        emit_charwidth_module(rf, width_table)"}, {"sha": "74a9953403d55844bea5590e4597bbeee4d8db7a", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -28,6 +28,7 @@\n #![allow(unused_attribute)] // NOTE: remove after stage0\n \n #[phase(plugin, link)] extern crate core;\n+extern crate unicode;\n extern crate alloc;\n \n #[cfg(test)] extern crate native;\n@@ -69,9 +70,6 @@ pub mod string;\n pub mod vec;\n pub mod hash;\n \n-// Internal unicode fiddly bits for the str module\n-mod unicode;\n-\n mod deque;\n \n /// A trait to represent mutable containers"}, {"sha": "cedb33831900de72b796f0d0240bdb6ecc2557df", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -69,7 +69,6 @@ is the same as `&[u8]`.\n \n use core::prelude::*;\n \n-use core::char;\n use core::default::Default;\n use core::fmt;\n use core::cmp;\n@@ -79,15 +78,17 @@ use core::mem;\n use Collection;\n use hash;\n use string::String;\n+use unicode;\n use vec::Vec;\n \n pub use core::str::{from_utf8, CharEq, Chars, CharOffsets};\n pub use core::str::{Bytes, CharSplits};\n-pub use core::str::{CharSplitsN, Words, AnyLines, MatchIndices, StrSplits};\n+pub use core::str::{CharSplitsN, AnyLines, MatchIndices, StrSplits};\n pub use core::str::{eq_slice, is_utf8, is_utf16, Utf16Items};\n pub use core::str::{Utf16Item, ScalarValue, LoneSurrogate, utf16_items};\n pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n pub use core::str::{Str, StrSlice};\n+pub use unicode::{Words, UnicodeStrSlice};\n \n /*\n Section: Creating a string\n@@ -283,7 +284,7 @@ pub struct Decompositions<'a> {\n impl<'a> Iterator<char> for Decompositions<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        use unicode::normalization::canonical_combining_class;\n+        use unicode::canonical_combining_class;\n \n         match self.buffer.as_slice().head() {\n             Some(&(c, 0)) => {\n@@ -299,8 +300,8 @@ impl<'a> Iterator<char> for Decompositions<'a> {\n         }\n \n         let decomposer = match self.kind {\n-            Canonical => char::decompose_canonical,\n-            Compatible => char::decompose_compatible\n+            Canonical => unicode::char::decompose_canonical,\n+            Compatible => unicode::char::decompose_compatible\n         };\n \n         if !self.sorted {"}, {"sha": "440290164c37d2031a8b22f599513d488908d82b", "filename": "src/libcollections/unicode.rs", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/4f120e6bafe971452adfede158a7957b00562a4e/src%2Flibcollections%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f120e6bafe971452adfede158a7957b00562a4e/src%2Flibcollections%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Funicode.rs?ref=4f120e6bafe971452adfede158a7957b00562a4e", "patch": "@@ -1,183 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n-\n-#![allow(missing_doc, non_uppercase_statics)]\n-\n-pub mod normalization {\n-    use core::prelude::*;\n-\n-    fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        match r.bsearch(|&(lo, hi, _)| {\n-            if lo <= c && c <= hi { Equal }\n-            else if hi < c { Less }\n-            else { Greater }\n-        }) {\n-            Some(idx) => {\n-                let (_, _, result) = r[idx];\n-                result\n-            }\n-            None => 0\n-        }\n-    }\n-\n-\n-    static combining_class_table : &'static [(char, char, u8)] = &[\n-        ('\\u0300', '\\u0314', 230), ('\\u0315', '\\u0315', 232),\n-        ('\\u0316', '\\u0319', 220), ('\\u031a', '\\u031a', 232),\n-        ('\\u031b', '\\u031b', 216), ('\\u031c', '\\u0320', 220),\n-        ('\\u0321', '\\u0322', 202), ('\\u0323', '\\u0326', 220),\n-        ('\\u0327', '\\u0328', 202), ('\\u0329', '\\u0333', 220),\n-        ('\\u0334', '\\u0338', 1), ('\\u0339', '\\u033c', 220),\n-        ('\\u033d', '\\u0344', 230), ('\\u0345', '\\u0345', 240),\n-        ('\\u0346', '\\u0346', 230), ('\\u0347', '\\u0349', 220),\n-        ('\\u034a', '\\u034c', 230), ('\\u034d', '\\u034e', 220),\n-        ('\\u0350', '\\u0352', 230), ('\\u0353', '\\u0356', 220),\n-        ('\\u0357', '\\u0357', 230), ('\\u0358', '\\u0358', 232),\n-        ('\\u0359', '\\u035a', 220), ('\\u035b', '\\u035b', 230),\n-        ('\\u035c', '\\u035c', 233), ('\\u035d', '\\u035e', 234),\n-        ('\\u035f', '\\u035f', 233), ('\\u0360', '\\u0361', 234),\n-        ('\\u0362', '\\u0362', 233), ('\\u0363', '\\u036f', 230),\n-        ('\\u0483', '\\u0487', 230), ('\\u0591', '\\u0591', 220),\n-        ('\\u0592', '\\u0595', 230), ('\\u0596', '\\u0596', 220),\n-        ('\\u0597', '\\u0599', 230), ('\\u059a', '\\u059a', 222),\n-        ('\\u059b', '\\u059b', 220), ('\\u059c', '\\u05a1', 230),\n-        ('\\u05a2', '\\u05a7', 220), ('\\u05a8', '\\u05a9', 230),\n-        ('\\u05aa', '\\u05aa', 220), ('\\u05ab', '\\u05ac', 230),\n-        ('\\u05ad', '\\u05ad', 222), ('\\u05ae', '\\u05ae', 228),\n-        ('\\u05af', '\\u05af', 230), ('\\u05b0', '\\u05b0', 10),\n-        ('\\u05b1', '\\u05b1', 11), ('\\u05b2', '\\u05b2', 12),\n-        ('\\u05b3', '\\u05b3', 13), ('\\u05b4', '\\u05b4', 14),\n-        ('\\u05b5', '\\u05b5', 15), ('\\u05b6', '\\u05b6', 16),\n-        ('\\u05b7', '\\u05b7', 17), ('\\u05b8', '\\u05b8', 18),\n-        ('\\u05b9', '\\u05ba', 19), ('\\u05bb', '\\u05bb', 20),\n-        ('\\u05bc', '\\u05bc', 21), ('\\u05bd', '\\u05bd', 22),\n-        ('\\u05bf', '\\u05bf', 23), ('\\u05c1', '\\u05c1', 24),\n-        ('\\u05c2', '\\u05c2', 25), ('\\u05c4', '\\u05c4', 230),\n-        ('\\u05c5', '\\u05c5', 220), ('\\u05c7', '\\u05c7', 18),\n-        ('\\u0610', '\\u0617', 230), ('\\u0618', '\\u0618', 30),\n-        ('\\u0619', '\\u0619', 31), ('\\u061a', '\\u061a', 32),\n-        ('\\u064b', '\\u064b', 27), ('\\u064c', '\\u064c', 28),\n-        ('\\u064d', '\\u064d', 29), ('\\u064e', '\\u064e', 30),\n-        ('\\u064f', '\\u064f', 31), ('\\u0650', '\\u0650', 32),\n-        ('\\u0651', '\\u0651', 33), ('\\u0652', '\\u0652', 34),\n-        ('\\u0653', '\\u0654', 230), ('\\u0655', '\\u0656', 220),\n-        ('\\u0657', '\\u065b', 230), ('\\u065c', '\\u065c', 220),\n-        ('\\u065d', '\\u065e', 230), ('\\u065f', '\\u065f', 220),\n-        ('\\u0670', '\\u0670', 35), ('\\u06d6', '\\u06dc', 230),\n-        ('\\u06df', '\\u06e2', 230), ('\\u06e3', '\\u06e3', 220),\n-        ('\\u06e4', '\\u06e4', 230), ('\\u06e7', '\\u06e8', 230),\n-        ('\\u06ea', '\\u06ea', 220), ('\\u06eb', '\\u06ec', 230),\n-        ('\\u06ed', '\\u06ed', 220), ('\\u0711', '\\u0711', 36),\n-        ('\\u0730', '\\u0730', 230), ('\\u0731', '\\u0731', 220),\n-        ('\\u0732', '\\u0733', 230), ('\\u0734', '\\u0734', 220),\n-        ('\\u0735', '\\u0736', 230), ('\\u0737', '\\u0739', 220),\n-        ('\\u073a', '\\u073a', 230), ('\\u073b', '\\u073c', 220),\n-        ('\\u073d', '\\u073d', 230), ('\\u073e', '\\u073e', 220),\n-        ('\\u073f', '\\u0741', 230), ('\\u0742', '\\u0742', 220),\n-        ('\\u0743', '\\u0743', 230), ('\\u0744', '\\u0744', 220),\n-        ('\\u0745', '\\u0745', 230), ('\\u0746', '\\u0746', 220),\n-        ('\\u0747', '\\u0747', 230), ('\\u0748', '\\u0748', 220),\n-        ('\\u0749', '\\u074a', 230), ('\\u07eb', '\\u07f1', 230),\n-        ('\\u07f2', '\\u07f2', 220), ('\\u07f3', '\\u07f3', 230),\n-        ('\\u0816', '\\u0819', 230), ('\\u081b', '\\u0823', 230),\n-        ('\\u0825', '\\u0827', 230), ('\\u0829', '\\u082d', 230),\n-        ('\\u0859', '\\u085b', 220), ('\\u08e4', '\\u08e5', 230),\n-        ('\\u08e6', '\\u08e6', 220), ('\\u08e7', '\\u08e8', 230),\n-        ('\\u08e9', '\\u08e9', 220), ('\\u08ea', '\\u08ec', 230),\n-        ('\\u08ed', '\\u08ef', 220), ('\\u08f0', '\\u08f0', 27),\n-        ('\\u08f1', '\\u08f1', 28), ('\\u08f2', '\\u08f2', 29),\n-        ('\\u08f3', '\\u08f5', 230), ('\\u08f6', '\\u08f6', 220),\n-        ('\\u08f7', '\\u08f8', 230), ('\\u08f9', '\\u08fa', 220),\n-        ('\\u08fb', '\\u08fe', 230), ('\\u093c', '\\u093c', 7),\n-        ('\\u094d', '\\u094d', 9), ('\\u0951', '\\u0951', 230),\n-        ('\\u0952', '\\u0952', 220), ('\\u0953', '\\u0954', 230),\n-        ('\\u09bc', '\\u09bc', 7), ('\\u09cd', '\\u09cd', 9),\n-        ('\\u0a3c', '\\u0a3c', 7), ('\\u0a4d', '\\u0a4d', 9),\n-        ('\\u0abc', '\\u0abc', 7), ('\\u0acd', '\\u0acd', 9),\n-        ('\\u0b3c', '\\u0b3c', 7), ('\\u0b4d', '\\u0b4d', 9),\n-        ('\\u0bcd', '\\u0bcd', 9), ('\\u0c4d', '\\u0c4d', 9),\n-        ('\\u0c55', '\\u0c55', 84), ('\\u0c56', '\\u0c56', 91),\n-        ('\\u0cbc', '\\u0cbc', 7), ('\\u0ccd', '\\u0ccd', 9),\n-        ('\\u0d4d', '\\u0d4d', 9), ('\\u0dca', '\\u0dca', 9),\n-        ('\\u0e38', '\\u0e39', 103), ('\\u0e3a', '\\u0e3a', 9),\n-        ('\\u0e48', '\\u0e4b', 107), ('\\u0eb8', '\\u0eb9', 118),\n-        ('\\u0ec8', '\\u0ecb', 122), ('\\u0f18', '\\u0f19', 220),\n-        ('\\u0f35', '\\u0f35', 220), ('\\u0f37', '\\u0f37', 220),\n-        ('\\u0f39', '\\u0f39', 216), ('\\u0f71', '\\u0f71', 129),\n-        ('\\u0f72', '\\u0f72', 130), ('\\u0f74', '\\u0f74', 132),\n-        ('\\u0f7a', '\\u0f7d', 130), ('\\u0f80', '\\u0f80', 130),\n-        ('\\u0f82', '\\u0f83', 230), ('\\u0f84', '\\u0f84', 9),\n-        ('\\u0f86', '\\u0f87', 230), ('\\u0fc6', '\\u0fc6', 220),\n-        ('\\u1037', '\\u1037', 7), ('\\u1039', '\\u103a', 9),\n-        ('\\u108d', '\\u108d', 220), ('\\u135d', '\\u135f', 230),\n-        ('\\u1714', '\\u1714', 9), ('\\u1734', '\\u1734', 9),\n-        ('\\u17d2', '\\u17d2', 9), ('\\u17dd', '\\u17dd', 230),\n-        ('\\u18a9', '\\u18a9', 228), ('\\u1939', '\\u1939', 222),\n-        ('\\u193a', '\\u193a', 230), ('\\u193b', '\\u193b', 220),\n-        ('\\u1a17', '\\u1a17', 230), ('\\u1a18', '\\u1a18', 220),\n-        ('\\u1a60', '\\u1a60', 9), ('\\u1a75', '\\u1a7c', 230),\n-        ('\\u1a7f', '\\u1a7f', 220), ('\\u1b34', '\\u1b34', 7),\n-        ('\\u1b44', '\\u1b44', 9), ('\\u1b6b', '\\u1b6b', 230),\n-        ('\\u1b6c', '\\u1b6c', 220), ('\\u1b6d', '\\u1b73', 230),\n-        ('\\u1baa', '\\u1bab', 9), ('\\u1be6', '\\u1be6', 7),\n-        ('\\u1bf2', '\\u1bf3', 9), ('\\u1c37', '\\u1c37', 7),\n-        ('\\u1cd0', '\\u1cd2', 230), ('\\u1cd4', '\\u1cd4', 1),\n-        ('\\u1cd5', '\\u1cd9', 220), ('\\u1cda', '\\u1cdb', 230),\n-        ('\\u1cdc', '\\u1cdf', 220), ('\\u1ce0', '\\u1ce0', 230),\n-        ('\\u1ce2', '\\u1ce8', 1), ('\\u1ced', '\\u1ced', 220),\n-        ('\\u1cf4', '\\u1cf4', 230), ('\\u1dc0', '\\u1dc1', 230),\n-        ('\\u1dc2', '\\u1dc2', 220), ('\\u1dc3', '\\u1dc9', 230),\n-        ('\\u1dca', '\\u1dca', 220), ('\\u1dcb', '\\u1dcc', 230),\n-        ('\\u1dcd', '\\u1dcd', 234), ('\\u1dce', '\\u1dce', 214),\n-        ('\\u1dcf', '\\u1dcf', 220), ('\\u1dd0', '\\u1dd0', 202),\n-        ('\\u1dd1', '\\u1de6', 230), ('\\u1dfc', '\\u1dfc', 233),\n-        ('\\u1dfd', '\\u1dfd', 220), ('\\u1dfe', '\\u1dfe', 230),\n-        ('\\u1dff', '\\u1dff', 220), ('\\u20d0', '\\u20d1', 230),\n-        ('\\u20d2', '\\u20d3', 1), ('\\u20d4', '\\u20d7', 230),\n-        ('\\u20d8', '\\u20da', 1), ('\\u20db', '\\u20dc', 230),\n-        ('\\u20e1', '\\u20e1', 230), ('\\u20e5', '\\u20e6', 1),\n-        ('\\u20e7', '\\u20e7', 230), ('\\u20e8', '\\u20e8', 220),\n-        ('\\u20e9', '\\u20e9', 230), ('\\u20ea', '\\u20eb', 1),\n-        ('\\u20ec', '\\u20ef', 220), ('\\u20f0', '\\u20f0', 230),\n-        ('\\u2cef', '\\u2cf1', 230), ('\\u2d7f', '\\u2d7f', 9),\n-        ('\\u2de0', '\\u2dff', 230), ('\\u302a', '\\u302a', 218),\n-        ('\\u302b', '\\u302b', 228), ('\\u302c', '\\u302c', 232),\n-        ('\\u302d', '\\u302d', 222), ('\\u302e', '\\u302f', 224),\n-        ('\\u3099', '\\u309a', 8), ('\\ua66f', '\\ua66f', 230),\n-        ('\\ua674', '\\ua67d', 230), ('\\ua69f', '\\ua69f', 230),\n-        ('\\ua6f0', '\\ua6f1', 230), ('\\ua806', '\\ua806', 9),\n-        ('\\ua8c4', '\\ua8c4', 9), ('\\ua8e0', '\\ua8f1', 230),\n-        ('\\ua92b', '\\ua92d', 220), ('\\ua953', '\\ua953', 9),\n-        ('\\ua9b3', '\\ua9b3', 7), ('\\ua9c0', '\\ua9c0', 9),\n-        ('\\uaab0', '\\uaab0', 230), ('\\uaab2', '\\uaab3', 230),\n-        ('\\uaab4', '\\uaab4', 220), ('\\uaab7', '\\uaab8', 230),\n-        ('\\uaabe', '\\uaabf', 230), ('\\uaac1', '\\uaac1', 230),\n-        ('\\uaaf6', '\\uaaf6', 9), ('\\uabed', '\\uabed', 9),\n-        ('\\ufb1e', '\\ufb1e', 26), ('\\ufe20', '\\ufe26', 230),\n-        ('\\U000101fd', '\\U000101fd', 220), ('\\U00010a0d', '\\U00010a0d', 220),\n-        ('\\U00010a0f', '\\U00010a0f', 230), ('\\U00010a38', '\\U00010a38', 230),\n-        ('\\U00010a39', '\\U00010a39', 1), ('\\U00010a3a', '\\U00010a3a', 220),\n-        ('\\U00010a3f', '\\U00010a3f', 9), ('\\U00011046', '\\U00011046', 9),\n-        ('\\U000110b9', '\\U000110b9', 9), ('\\U000110ba', '\\U000110ba', 7),\n-        ('\\U00011100', '\\U00011102', 230), ('\\U00011133', '\\U00011134', 9),\n-        ('\\U000111c0', '\\U000111c0', 9), ('\\U000116b6', '\\U000116b6', 9),\n-        ('\\U000116b7', '\\U000116b7', 7), ('\\U0001d165', '\\U0001d166', 216),\n-        ('\\U0001d167', '\\U0001d169', 1), ('\\U0001d16d', '\\U0001d16d', 226),\n-        ('\\U0001d16e', '\\U0001d172', 216), ('\\U0001d17b', '\\U0001d182', 220),\n-        ('\\U0001d185', '\\U0001d189', 230), ('\\U0001d18a', '\\U0001d18b', 220),\n-        ('\\U0001d1aa', '\\U0001d1ad', 230), ('\\U0001d242', '\\U0001d244', 230)\n-    ];\n-\n-    pub fn canonical_combining_class(c: char) -> u8 {\n-        bsearch_range_value_table(c, combining_class_table)\n-    }\n-}"}, {"sha": "99c5722699e8d966180fc86a68971f3dab5b4879", "filename": "src/libcore/char.rs", "status": "modified", "additions": 3, "deletions": 238, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -8,33 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Character manipulation (`char` type, Unicode Scalar Value)\n+//! Character manipulation.\n //!\n-//! This module  provides the `Char` trait, as well as its implementation\n-//! for the primitive `char` type, in order to allow basic character manipulation.\n-//!\n-//! A `char` actually represents a\n-//! *[Unicode Scalar Value](http://www.unicode.org/glossary/#unicode_scalar_value)*,\n-//! as it can contain any Unicode code point except high-surrogate and\n-//! low-surrogate code points.\n-//!\n-//! As such, only values in the ranges \\[0x0,0xD7FF\\] and \\[0xE000,0x10FFFF\\]\n-//! (inclusive) are allowed. A `char` can always be safely cast to a `u32`;\n-//! however the converse is not always true due to the above range limits\n-//! and, as such, should be performed via the `from_u32` function..\n+//! For more details, see ::unicode::char (a.k.a. std::char)\n \n #![allow(non_snake_case_functions)]\n #![doc(primitive = \"char\")]\n \n use mem::transmute;\n use option::{None, Option, Some};\n use iter::{Iterator, range_step};\n-use unicode::{derived_property, property, general_category, conversions};\n-\n-/// Returns the canonical decomposition of a character.\n-pub use unicode::normalization::decompose_canonical;\n-/// Returns the compatibility decomposition of a character.\n-pub use unicode::normalization::decompose_compatible;\n \n // UTF-8 ranges and tags for encoding characters\n static TAG_CONT: u8    = 0b1000_0000u8;\n@@ -93,84 +76,6 @@ pub fn from_u32(i: u32) -> Option<char> {\n     }\n }\n \n-/// Returns whether the specified `char` is considered a Unicode alphabetic\n-/// code point\n-pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }\n-\n-/// Returns whether the specified `char` satisfies the 'XID_Start' Unicode property\n-///\n-/// 'XID_Start' is a Unicode Derived Property specified in\n-/// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-/// mostly similar to ID_Start but modified for closure under NFKx.\n-pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n-\n-/// Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property\n-///\n-/// 'XID_Continue' is a Unicode Derived Property specified in\n-/// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-/// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n-pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n-\n-///\n-/// Indicates whether a `char` is in lower case\n-///\n-/// This is defined according to the terms of the Unicode Derived Core Property 'Lowercase'.\n-///\n-#[inline]\n-pub fn is_lowercase(c: char) -> bool { derived_property::Lowercase(c) }\n-\n-///\n-/// Indicates whether a `char` is in upper case\n-///\n-/// This is defined according to the terms of the Unicode Derived Core Property 'Uppercase'.\n-///\n-#[inline]\n-pub fn is_uppercase(c: char) -> bool { derived_property::Uppercase(c) }\n-\n-///\n-/// Indicates whether a `char` is whitespace\n-///\n-/// Whitespace is defined in terms of the Unicode Property 'White_Space'.\n-///\n-#[inline]\n-pub fn is_whitespace(c: char) -> bool {\n-    // As an optimization ASCII whitespace characters are checked separately\n-    c == ' '\n-        || ('\\x09' <= c && c <= '\\x0d')\n-        || property::White_Space(c)\n-}\n-\n-///\n-/// Indicates whether a `char` is alphanumeric\n-///\n-/// Alphanumericness is defined in terms of the Unicode General Categories\n-/// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-///\n-#[inline]\n-pub fn is_alphanumeric(c: char) -> bool {\n-    derived_property::Alphabetic(c)\n-        || general_category::Nd(c)\n-        || general_category::Nl(c)\n-        || general_category::No(c)\n-}\n-\n-///\n-/// Indicates whether a `char` is a control code point\n-///\n-/// Control code points are defined in terms of the Unicode General Category\n-/// 'Cc'.\n-///\n-#[inline]\n-pub fn is_control(c: char) -> bool { general_category::Cc(c) }\n-\n-/// Indicates whether the `char` is numeric (Nd, Nl, or No)\n-#[inline]\n-pub fn is_digit(c: char) -> bool {\n-    general_category::Nd(c)\n-        || general_category::Nl(c)\n-        || general_category::No(c)\n-}\n-\n ///\n /// Checks if a `char` parses as a numeric digit in the given radix\n ///\n@@ -227,38 +132,6 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     else { None }\n }\n \n-/// Convert a char to its uppercase equivalent\n-///\n-/// The case-folding performed is the common or simple mapping:\n-/// it maps one unicode codepoint (one char in Rust) to its uppercase equivalent according\n-/// to the Unicode database at ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n-/// The additional SpecialCasing.txt is not considered here, as it expands to multiple\n-/// codepoints in some cases.\n-///\n-/// A full reference can be found here\n-/// http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-///\n-/// # Return value\n-///\n-/// Returns the char itself if no conversion was made\n-#[inline]\n-pub fn to_uppercase(c: char) -> char {\n-    conversions::to_upper(c)\n-}\n-\n-/// Convert a char to its lowercase equivalent\n-///\n-/// The case-folding performed is the common or simple mapping\n-/// see `to_uppercase` for references and more information\n-///\n-/// # Return value\n-///\n-/// Returns the char itself if no conversion if possible\n-#[inline]\n-pub fn to_lowercase(c: char) -> char {\n-    conversions::to_lower(c)\n-}\n-\n ///\n /// Converts a number to the character representing it\n ///\n@@ -355,61 +228,8 @@ pub fn len_utf8_bytes(c: char) -> uint {\n     }\n }\n \n-/// Useful functions for Unicode characters.\n+/// Basic `char` manipulations.\n pub trait Char {\n-    /// Returns whether the specified character is considered a Unicode\n-    /// alphabetic code point.\n-    fn is_alphabetic(&self) -> bool;\n-\n-    /// Returns whether the specified character satisfies the 'XID_Start'\n-    /// Unicode property.\n-    ///\n-    /// 'XID_Start' is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to ID_Start but modified for closure under NFKx.\n-    fn is_XID_start(&self) -> bool;\n-\n-    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n-    /// Unicode property.\n-    ///\n-    /// 'XID_Continue' is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n-    fn is_XID_continue(&self) -> bool;\n-\n-\n-    /// Indicates whether a character is in lowercase.\n-    ///\n-    /// This is defined according to the terms of the Unicode Derived Core\n-    /// Property `Lowercase`.\n-    fn is_lowercase(&self) -> bool;\n-\n-    /// Indicates whether a character is in uppercase.\n-    ///\n-    /// This is defined according to the terms of the Unicode Derived Core\n-    /// Property `Uppercase`.\n-    fn is_uppercase(&self) -> bool;\n-\n-    /// Indicates whether a character is whitespace.\n-    ///\n-    /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n-    fn is_whitespace(&self) -> bool;\n-\n-    /// Indicates whether a character is alphanumeric.\n-    ///\n-    /// Alphanumericness is defined in terms of the Unicode General Categories\n-    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-    fn is_alphanumeric(&self) -> bool;\n-\n-    /// Indicates whether a character is a control code point.\n-    ///\n-    /// Control code points are defined in terms of the Unicode General\n-    /// Category `Cc`.\n-    fn is_control(&self) -> bool;\n-\n-    /// Indicates whether the character is numeric (Nd, Nl, or No).\n-    fn is_digit(&self) -> bool;\n-\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n     /// Compared to `is_digit()`, this function only recognizes the characters\n@@ -438,37 +258,6 @@ pub trait Char {\n     /// Fails if given a radix outside the range [0..36].\n     fn to_digit(&self, radix: uint) -> Option<uint>;\n \n-    /// Converts a character to its lowercase equivalent.\n-    ///\n-    /// The case-folding performed is the common or simple mapping. See\n-    /// `to_uppercase()` for references and more information.\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns the lowercase equivalent of the character, or the character\n-    /// itself if no conversion is possible.\n-    fn to_lowercase(&self) -> char;\n-\n-    /// Converts a character to its uppercase equivalent.\n-    ///\n-    /// The case-folding performed is the common or simple mapping: it maps\n-    /// one unicode codepoint (one character in Rust) to its uppercase\n-    /// equivalent according to the Unicode database [1]. The additional\n-    /// `SpecialCasing.txt` is not considered here, as it expands to multiple\n-    /// codepoints in some cases.\n-    ///\n-    /// A full reference can be found here [2].\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns the uppercase equivalent of the character, or the character\n-    /// itself if no conversion was made.\n-    ///\n-    /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n-    ///\n-    /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    fn to_uppercase(&self) -> char;\n-\n     /// Converts a number to the character representing it.\n     ///\n     /// # Return value\n@@ -526,32 +315,10 @@ pub trait Char {\n }\n \n impl Char for char {\n-    fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }\n-\n-    fn is_XID_start(&self) -> bool { is_XID_start(*self) }\n-\n-    fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }\n-\n-    fn is_lowercase(&self) -> bool { is_lowercase(*self) }\n-\n-    fn is_uppercase(&self) -> bool { is_uppercase(*self) }\n-\n-    fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n-\n-    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n-\n-    fn is_control(&self) -> bool { is_control(*self) }\n-\n-    fn is_digit(&self) -> bool { is_digit(*self) }\n-\n     fn is_digit_radix(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }\n \n     fn to_digit(&self, radix: uint) -> Option<uint> { to_digit(*self, radix) }\n \n-    fn to_lowercase(&self) -> char { to_lowercase(*self) }\n-\n-    fn to_uppercase(&self) -> char { to_uppercase(*self) }\n-\n     fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n \n     fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }\n@@ -600,5 +367,3 @@ impl Char for char {\n         }\n     }\n }\n-\n-"}, {"sha": "d27cf76069064fb050d2c01d8e2fb2cbd3a6f22e", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -108,7 +108,6 @@ pub mod collections;\n \n /* Core types and methods on primitives */\n \n-mod unicode;\n pub mod any;\n pub mod atomics;\n pub mod bool;"}, {"sha": "2d3aac642c72515d0dddd668b4ccc8196e8359cb", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 82, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -22,7 +22,7 @@ use cmp;\n use cmp::{PartialEq, Eq};\n use collections::Collection;\n use default::Default;\n-use iter::{Filter, Map, Iterator};\n+use iter::{Map, Iterator};\n use iter::{DoubleEndedIterator, ExactSize};\n use iter::range;\n use num::{CheckedMul, Saturating};\n@@ -204,10 +204,6 @@ pub struct CharSplitsN<'a, Sep> {\n     invert: bool,\n }\n \n-/// An iterator over the words of a string, separated by a sequence of whitespace\n-pub type Words<'a> =\n-    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n-\n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n pub type AnyLines<'a> =\n     Map<'a, &'a str, &'a str, CharSplits<'a, char>>;\n@@ -1209,48 +1205,6 @@ pub trait StrSlice<'a> {\n     /// ```\n     fn lines_any(&self) -> AnyLines<'a>;\n \n-    /// An iterator over the words of a string (subsequences separated\n-    /// by any sequence of whitespace). Sequences of whitespace are\n-    /// collapsed, so empty \"words\" are not included.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n-    /// let v: Vec<&str> = some_words.words().collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    /// ```\n-    fn words(&self) -> Words<'a>;\n-\n-    /// Returns true if the string contains only whitespace.\n-    ///\n-    /// Whitespace characters are determined by `char::is_whitespace`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\" \\t\\n\".is_whitespace());\n-    /// assert!(\"\".is_whitespace());\n-    ///\n-    /// assert!( !\"abc\".is_whitespace());\n-    /// ```\n-    fn is_whitespace(&self) -> bool;\n-\n-    /// Returns true if the string contains only alphanumeric code\n-    /// points.\n-    ///\n-    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n-    /// assert!(\"\".is_alphanumeric());\n-    ///\n-    /// assert!( !\" &*~\".is_alphanumeric());\n-    /// ```\n-    fn is_alphanumeric(&self) -> bool;\n-\n     /// Returns the number of Unicode code points (`char`) that a\n     /// string holds.\n     ///\n@@ -1368,15 +1322,6 @@ pub trait StrSlice<'a> {\n     /// Returns true if `needle` is a suffix of the string.\n     fn ends_with(&self, needle: &str) -> bool;\n \n-    /// Returns a string with leading and trailing whitespace removed.\n-    fn trim(&self) -> &'a str;\n-\n-    /// Returns a string with leading whitespace removed.\n-    fn trim_left(&self) -> &'a str;\n-\n-    /// Returns a string with trailing whitespace removed.\n-    fn trim_right(&self) -> &'a str;\n-\n     /// Returns a string with characters that match `to_trim` removed.\n     ///\n     /// # Arguments\n@@ -1748,17 +1693,6 @@ impl<'a> StrSlice<'a> for &'a str {\n         })\n     }\n \n-    #[inline]\n-    fn words(&self) -> Words<'a> {\n-        self.split(char::is_whitespace).filter(|s| !s.is_empty())\n-    }\n-\n-    #[inline]\n-    fn is_whitespace(&self) -> bool { self.chars().all(char::is_whitespace) }\n-\n-    #[inline]\n-    fn is_alphanumeric(&self) -> bool { self.chars().all(char::is_alphanumeric) }\n-\n     #[inline]\n     fn char_len(&self) -> uint { self.chars().count() }\n \n@@ -1814,21 +1748,6 @@ impl<'a> StrSlice<'a> for &'a str {\n         m >= n && needle.as_bytes() == self.as_bytes().slice_from(m - n)\n     }\n \n-    #[inline]\n-    fn trim(&self) -> &'a str {\n-        self.trim_left().trim_right()\n-    }\n-\n-    #[inline]\n-    fn trim_left(&self) -> &'a str {\n-        self.trim_left_chars(char::is_whitespace)\n-    }\n-\n-    #[inline]\n-    fn trim_right(&self) -> &'a str {\n-        self.trim_right_chars(char::is_whitespace)\n-    }\n-\n     #[inline]\n     fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n         let cur = match self.find(|c: char| !to_trim.matches(c)) {"}, {"sha": "c6fc5f16ed142afbbaa95c0705fc9be57bf3a644", "filename": "src/libcore/unicode.rs", "status": "removed", "additions": 0, "deletions": 5056, "changes": 5056, "blob_url": "https://github.com/rust-lang/rust/blob/4f120e6bafe971452adfede158a7957b00562a4e/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f120e6bafe971452adfede158a7957b00562a4e/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=4f120e6bafe971452adfede158a7957b00562a4e"}, {"sha": "5325524d2cb86c39167e3699fd816a68881161dc", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -200,3 +200,30 @@ fn test_encode_utf16() {\n     check('\\ua66e', [0xa66e]);\n     check('\\U0001f4a9', [0xd83d, 0xdca9]);\n }\n+\n+#[test]\n+fn test_width() {\n+    assert_eq!('\\x00'.width(false),Some(0));\n+    assert_eq!('\\x00'.width(true),Some(0));\n+\n+    assert_eq!('\\x0A'.width(false),None);\n+    assert_eq!('\\x0A'.width(true),None);\n+\n+    assert_eq!('w'.width(false),Some(1));\n+    assert_eq!('w'.width(true),Some(1));\n+\n+    assert_eq!('\uff48'.width(false),Some(2));\n+    assert_eq!('\uff48'.width(true),Some(2));\n+\n+    assert_eq!('\\xAD'.width(false),Some(1));\n+    assert_eq!('\\xAD'.width(true),Some(1));\n+\n+    assert_eq!('\\u1160'.width(false),Some(0));\n+    assert_eq!('\\u1160'.width(true),Some(0));\n+\n+    assert_eq!('\\u00a1'.width(false),Some(1));\n+    assert_eq!('\\u00a1'.width(true),Some(2));\n+\n+    assert_eq!('\\u0300'.width(false),Some(0));\n+    assert_eq!('\\u0300'.width(true),Some(0));\n+}"}, {"sha": "181f60538dfb12aeee78671fb8520807a3083feb", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -306,12 +306,15 @@\n //!\n //! ## Perl character classes (Unicode friendly)\n //!\n+//! These classes are based on the definitions provided in\n+//! [UTS#18](http://www.unicode.org/reports/tr18/#Compatibility_Properties):\n+//!\n //! <pre class=\"rust\">\n-//! \\d     digit ([0-9] + \\p{Nd})\n+//! \\d     digit (\\p{Nd})\n //! \\D     not digit\n-//! \\s     whitespace ([\\t\\n\\f\\r ] + \\p{Z})\n+//! \\s     whitespace (\\p{White_Space})\n //! \\S     not whitespace\n-//! \\w     word character ([0-9A-Za-z_] + \\p{L})\n+//! \\w     word character (\\p{Alphabetic} + \\p{M} + \\d + \\p{Pc} + \\p{Join_Control})\n //! \\W     not word character\n //! </pre>\n //!\n@@ -378,6 +381,9 @@ extern crate rand;\n #[cfg(test)]\n extern crate regex;\n \n+// unicode tables for character classes are defined in libunicode\n+extern crate unicode;\n+\n pub use parse::Error;\n pub use re::{Regex, Captures, SubCaptures, SubCapturesPos};\n pub use re::{FindCaptures, FindMatches};"}, {"sha": "a2747526df859899c760d219e8f67e00d45c8871", "filename": "src/libregex/parse.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -16,9 +16,7 @@ use std::num;\n use std::str;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n-use self::unicode::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n-#[allow(visible_private_types)]\n-pub mod unicode;\n+use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n \n /// The maximum number of repetitions allowed with the `{n,m}` syntax.\n static MAX_REPEAT: uint = 1000;", "previous_filename": "src/libregex/parse/mod.rs"}, {"sha": "c263827dab847ae305adbeed4e97adef1b9c1eba", "filename": "src/libregex/parse/unicode.rs", "status": "removed", "additions": 0, "deletions": 5537, "changes": 5537, "blob_url": "https://github.com/rust-lang/rust/blob/4f120e6bafe971452adfede158a7957b00562a4e/src%2Flibregex%2Fparse%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f120e6bafe971452adfede158a7957b00562a4e/src%2Flibregex%2Fparse%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Funicode.rs?ref=4f120e6bafe971452adfede158a7957b00562a4e"}, {"sha": "782078ced497b9d09cf139416bc9e226848d5619", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -42,7 +42,7 @@ use compile::{\n     Save, Jump, Split,\n };\n use parse::{FLAG_NOCASE, FLAG_MULTI, FLAG_DOTNL, FLAG_NEGATED};\n-use parse::unicode::PERLW;\n+use unicode::regex::PERLW;\n \n pub type CaptureLocs = Vec<Option<uint>>;\n "}, {"sha": "52f8a53ad6230b0c55d647cc4dea8e6052f34b64", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -237,6 +237,7 @@ use str::{Str, StrSlice, StrAllocating};\n use str;\n use string::String;\n use uint;\n+use unicode::UnicodeChar;\n use vec::Vec;\n \n // Reexports"}, {"sha": "586f513835bc0364e68b48a8f2c69ae45612aaf2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -126,6 +126,7 @@\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n extern crate alloc;\n+extern crate unicode;\n extern crate core;\n extern crate core_collections = \"collections\";\n extern crate core_rand = \"rand\";\n@@ -148,7 +149,6 @@ extern crate rustrt;\n pub use core::any;\n pub use core::bool;\n pub use core::cell;\n-pub use core::char;\n pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;\n pub use core::default;\n@@ -180,6 +180,8 @@ pub use core_collections::vec;\n pub use rustrt::c_str;\n pub use rustrt::local_data;\n \n+pub use unicode::char;\n+\n pub use core_sync::comm;\n \n // Run tests with libgreen instead of libnative."}, {"sha": "10db5c1bf9f1aee221b35d7c99b2e408b732ba70", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -24,6 +24,7 @@ use option::{Option, Some, None};\n use slice::{Vector, ImmutableVector};\n use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};\n use string::String;\n+use unicode::UnicodeChar;\n use vec::Vec;\n \n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -997,7 +998,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n                 let idx = path.find('\\\\');\n                 if idx == Some(2) && path.as_bytes()[1] == ':' as u8 {\n                     let c = path.as_bytes()[0];\n-                    if c.is_ascii() && ::char::is_alphabetic(c as char) {\n+                    if c.is_ascii() && (c as char).is_alphabetic() {\n                         // \\\\?\\C:\\ path\n                         return Some(VerbatimDiskPrefix);\n                     }\n@@ -1021,7 +1022,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     } else if path.len() > 1 && path.as_bytes()[1] == ':' as u8 {\n         // C:\n         let c = path.as_bytes()[0];\n-        if c.is_ascii() && ::char::is_alphabetic(c as char) {\n+        if c.is_ascii() && (c as char).is_alphabetic() {\n             return Some(DiskPrefix);\n         }\n     }"}, {"sha": "338f6fdffed8dc1a549591a225b8153704243570", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -88,6 +88,7 @@\n #[doc(no_inline)] pub use slice::{Vector, VectorVector};\n #[doc(no_inline)] pub use slice::MutableVectorAllocating;\n #[doc(no_inline)] pub use string::String;\n+#[doc(no_inline)] pub use unicode::{UnicodeChar, UnicodeStrSlice};\n #[doc(no_inline)] pub use vec::Vec;\n \n // Reexported runtime types"}, {"sha": "09922b5ad76154bc81c0c57a5ad6b9e0ad144f09", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -12,7 +12,6 @@\n \n #![allow(non_camel_case_types)]\n \n-use char::Char;\n use collections::Collection;\n use from_str::from_str;\n use io::{IoResult, Writer};\n@@ -22,6 +21,7 @@ use os;\n use result::{Ok, Err};\n use str::StrSlice;\n use sync::atomics;\n+use unicode::UnicodeChar;\n \n pub use self::imp::write;\n "}, {"sha": "832b65d473996d4e642e23d996b57d630eb50816", "filename": "src/libunicode/decompose.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Fdecompose.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Fdecompose.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fdecompose.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+  Functions for computing canonical and compatible decompositions\n+  for Unicode characters.\n+  */\n+\n+use core::option::{Option, Some, None};\n+use core::slice::ImmutableVector;\n+use tables::normalization::{canonical_table, compatibility_table};\n+\n+fn bsearch_table(c: char, r: &'static [(char, &'static [char])]) -> Option<&'static [char]> {\n+    use core::cmp::{Equal, Less, Greater};\n+    match r.bsearch(|&(val, _)| {\n+        if c == val { Equal }\n+        else if val < c { Less }\n+        else { Greater }\n+    }) {\n+        Some(idx) => {\n+            let (_, result) = r[idx];\n+            Some(result)\n+        }\n+        None => None\n+    }\n+}\n+\n+/// Compute canonical Unicode decomposition for character\n+pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }\n+\n+/// Compute canonical or compatible Unicode decomposition for character\n+pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }\n+\n+fn d(c: char, i: |char|, k: bool) {\n+    use core::iter::Iterator;\n+\n+    // 7-bit ASCII never decomposes\n+    if c <= '\\x7f' { i(c); return; }\n+\n+    // Perform decomposition for Hangul\n+    if (c as u32) >= S_BASE && (c as u32) < (S_BASE + S_COUNT) {\n+        decompose_hangul(c, i);\n+        return;\n+    }\n+\n+    // First check the canonical decompositions\n+    match bsearch_table(c, canonical_table) {\n+        Some(canon) => {\n+            for x in canon.iter() {\n+                d(*x, |b| i(b), k);\n+            }\n+            return;\n+        }\n+        None => ()\n+    }\n+\n+    // Bottom out if we're not doing compat.\n+    if !k { i(c); return; }\n+\n+    // Then check the compatibility decompositions\n+    match bsearch_table(c, compatibility_table) {\n+        Some(compat) => {\n+            for x in compat.iter() {\n+                d(*x, |b| i(b), k);\n+            }\n+            return;\n+        }\n+        None => ()\n+    }\n+\n+    // Finally bottom out.\n+    i(c);\n+}\n+\n+// Constants from Unicode 6.3.0 Section 3.12 Conjoining Jamo Behavior\n+static S_BASE: u32 = 0xAC00;\n+static L_BASE: u32 = 0x1100;\n+static V_BASE: u32 = 0x1161;\n+static T_BASE: u32 = 0x11A7;\n+static L_COUNT: u32 = 19;\n+static V_COUNT: u32 = 21;\n+static T_COUNT: u32 = 28;\n+static N_COUNT: u32 = (V_COUNT * T_COUNT);\n+static S_COUNT: u32 = (L_COUNT * N_COUNT);\n+\n+// Decompose a precomposed Hangul syllable\n+fn decompose_hangul(s: char, f: |char|) {\n+    use core::mem::transmute;\n+\n+    let si = s as u32 - S_BASE;\n+\n+    let li = si / N_COUNT;\n+    unsafe {\n+        f(transmute(L_BASE + li));\n+\n+        let vi = (si % N_COUNT) / T_COUNT;\n+        f(transmute(V_BASE + vi));\n+\n+        let ti = si % T_COUNT;\n+        if ti > 0 {\n+            f(transmute(T_BASE + ti));\n+        }\n+    }\n+}"}, {"sha": "49e8bb66b4241f3c57920ecd25d1126fc51274fe", "filename": "src/libunicode/lib.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # The Unicode Library\n+//!\n+//! Unicode-intensive functions for `char` and `str` types.\n+//!\n+//! This crate provides a collection of Unicode-related functionality,\n+//! including decompositions, conversions, etc., and provides traits\n+//! implementing these functions for the `char` and `str` types.\n+//!\n+//! The functionality included here is only that which is necessary to\n+//! provide for basic string-related manipulations. This crate does not\n+//! (yet) aim to provide a full set of Unicode tables.\n+\n+#![crate_id = \"unicode#0.11.0\"]\n+#![crate_name = \"unicode\"]\n+#![experimental]\n+#![license = \"MIT/ASL2\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/\",\n+       html_playground_url = \"http://play.rust-lang.org/\")]\n+#![no_std]\n+#![allow(unused_attribute)] // NOTE: remove after stage0\n+\n+extern crate core;\n+\n+pub use tables::normalization::canonical_combining_class;\n+pub use tables::regex;\n+\n+pub use u_char::UnicodeChar;\n+pub use u_str::UnicodeStrSlice;\n+pub use u_str::Words;\n+\n+mod decompose;\n+mod tables;\n+mod u_char;\n+mod u_str;\n+\n+// re-export char so that std et al see it correctly\n+/// Character manipulation (`char` type, Unicode Scalar Value)\n+///\n+/// This module  provides the `Char` and `UnicodeChar` traits, as well as their\n+/// implementation for the primitive `char` type, in order to allow basic character\n+/// manipulation.\n+///\n+/// A `char` actually represents a\n+/// *[Unicode Scalar Value](http://www.unicode.org/glossary/#unicode_scalar_value)*,\n+/// as it can contain any Unicode code point except high-surrogate and\n+/// low-surrogate code points.\n+///\n+/// As such, only values in the ranges \\[0x0,0xD7FF\\] and \\[0xE000,0x10FFFF\\]\n+/// (inclusive) are allowed. A `char` can always be safely cast to a `u32`;\n+/// however the converse is not always true due to the above range limits\n+/// and, as such, should be performed via the `from_u32` function..\n+pub mod char {\n+    pub use core::char::{MAX, from_u32, is_digit_radix, to_digit};\n+    pub use core::char::{from_digit, escape_unicode, escape_default};\n+    pub use core::char::{len_utf8_bytes, Char};\n+\n+    pub use decompose::decompose_canonical;\n+    pub use decompose::decompose_compatible;\n+\n+    pub use u_char::{is_alphabetic, is_XID_start, is_XID_continue};\n+    pub use u_char::{is_lowercase, is_uppercase, is_whitespace};\n+    pub use u_char::{is_alphanumeric, is_control, is_digit};\n+    pub use u_char::{to_uppercase, to_lowercase, width, UnicodeChar};\n+}"}, {"sha": "7f59656ba399a0be7f6e3209b87814ba09bb3837", "filename": "src/libunicode/tables.rs", "status": "added", "additions": 6445, "deletions": 0, "changes": 6445, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f"}, {"sha": "a927c364ff928ad6e8f0a96fba6b713ec697b168", "filename": "src/libunicode/u_char.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -0,0 +1,266 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Unicode-intensive `char` methods.\n+ *\n+ * These methods implement functionality for `char` that requires knowledge of\n+ * Unicode definitions, including normalization, categorization, and display information.\n+ */\n+\n+use core::option::Option;\n+use tables::{derived_property, property, general_category, conversions, charwidth};\n+\n+/// Returns whether the specified `char` is considered a Unicode alphabetic\n+/// code point\n+pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }\n+\n+/// Returns whether the specified `char` satisfies the 'XID_Start' Unicode property\n+///\n+/// 'XID_Start' is a Unicode Derived Property specified in\n+/// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+/// mostly similar to ID_Start but modified for closure under NFKx.\n+#[allow(non_snake_case_functions)]\n+pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n+\n+/// Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property\n+///\n+/// 'XID_Continue' is a Unicode Derived Property specified in\n+/// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+/// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n+#[allow(non_snake_case_functions)]\n+pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n+\n+///\n+/// Indicates whether a `char` is in lower case\n+///\n+/// This is defined according to the terms of the Unicode Derived Core Property 'Lowercase'.\n+///\n+#[inline]\n+pub fn is_lowercase(c: char) -> bool { derived_property::Lowercase(c) }\n+\n+///\n+/// Indicates whether a `char` is in upper case\n+///\n+/// This is defined according to the terms of the Unicode Derived Core Property 'Uppercase'.\n+///\n+#[inline]\n+pub fn is_uppercase(c: char) -> bool { derived_property::Uppercase(c) }\n+\n+///\n+/// Indicates whether a `char` is whitespace\n+///\n+/// Whitespace is defined in terms of the Unicode Property 'White_Space'.\n+///\n+#[inline]\n+pub fn is_whitespace(c: char) -> bool {\n+    // As an optimization ASCII whitespace characters are checked separately\n+    c == ' '\n+        || ('\\x09' <= c && c <= '\\x0d')\n+        || property::White_Space(c)\n+}\n+\n+///\n+/// Indicates whether a `char` is alphanumeric\n+///\n+/// Alphanumericness is defined in terms of the Unicode General Categories\n+/// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+///\n+#[inline]\n+pub fn is_alphanumeric(c: char) -> bool {\n+    derived_property::Alphabetic(c)\n+        || general_category::N(c)\n+}\n+\n+///\n+/// Indicates whether a `char` is a control code point\n+///\n+/// Control code points are defined in terms of the Unicode General Category\n+/// 'Cc'.\n+///\n+#[inline]\n+pub fn is_control(c: char) -> bool { general_category::Cc(c) }\n+\n+/// Indicates whether the `char` is numeric (Nd, Nl, or No)\n+#[inline]\n+pub fn is_digit(c: char) -> bool {\n+    general_category::N(c)\n+}\n+\n+/// Convert a char to its uppercase equivalent\n+///\n+/// The case-folding performed is the common or simple mapping:\n+/// it maps one unicode codepoint (one char in Rust) to its uppercase equivalent according\n+/// to the Unicode database at ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+/// The additional SpecialCasing.txt is not considered here, as it expands to multiple\n+/// codepoints in some cases.\n+///\n+/// A full reference can be found here\n+/// http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n+///\n+/// # Return value\n+///\n+/// Returns the char itself if no conversion was made\n+#[inline]\n+pub fn to_uppercase(c: char) -> char {\n+    conversions::to_upper(c)\n+}\n+\n+/// Convert a char to its lowercase equivalent\n+///\n+/// The case-folding performed is the common or simple mapping\n+/// see `to_uppercase` for references and more information\n+///\n+/// # Return value\n+///\n+/// Returns the char itself if no conversion if possible\n+#[inline]\n+pub fn to_lowercase(c: char) -> char {\n+    conversions::to_lower(c)\n+}\n+\n+/// Returns this character's displayed width in columns, or `None` if it is a\n+/// control character other than `'\\x00'`.\n+///\n+/// `is_cjk` determines behavior for characters in the Ambiguous category:\n+/// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+/// In CJK contexts, `is_cjk` should be `true`, else it should be `false`.\n+/// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+/// recommends that these characters be treated as 1 column (i.e.,\n+/// `is_cjk` = `false`) if the context cannot be reliably determined.\n+pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n+    charwidth::width(c, is_cjk)\n+}\n+\n+/// Useful functions for Unicode characters.\n+pub trait UnicodeChar {\n+    /// Returns whether the specified character is considered a Unicode\n+    /// alphabetic code point.\n+    fn is_alphabetic(&self) -> bool;\n+\n+    /// Returns whether the specified character satisfies the 'XID_Start'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Start' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to ID_Start but modified for closure under NFKx.\n+    #[allow(non_snake_case_functions)]\n+    fn is_XID_start(&self) -> bool;\n+\n+    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Continue' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n+    #[allow(non_snake_case_functions)]\n+    fn is_XID_continue(&self) -> bool;\n+\n+\n+    /// Indicates whether a character is in lowercase.\n+    ///\n+    /// This is defined according to the terms of the Unicode Derived Core\n+    /// Property `Lowercase`.\n+    fn is_lowercase(&self) -> bool;\n+\n+    /// Indicates whether a character is in uppercase.\n+    ///\n+    /// This is defined according to the terms of the Unicode Derived Core\n+    /// Property `Uppercase`.\n+    fn is_uppercase(&self) -> bool;\n+\n+    /// Indicates whether a character is whitespace.\n+    ///\n+    /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n+    fn is_whitespace(&self) -> bool;\n+\n+    /// Indicates whether a character is alphanumeric.\n+    ///\n+    /// Alphanumericness is defined in terms of the Unicode General Categories\n+    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+    fn is_alphanumeric(&self) -> bool;\n+\n+    /// Indicates whether a character is a control code point.\n+    ///\n+    /// Control code points are defined in terms of the Unicode General\n+    /// Category `Cc`.\n+    fn is_control(&self) -> bool;\n+\n+    /// Indicates whether the character is numeric (Nd, Nl, or No).\n+    fn is_digit(&self) -> bool;\n+\n+    /// Converts a character to its lowercase equivalent.\n+    ///\n+    /// The case-folding performed is the common or simple mapping. See\n+    /// `to_uppercase()` for references and more information.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns the lowercase equivalent of the character, or the character\n+    /// itself if no conversion is possible.\n+    fn to_lowercase(&self) -> char;\n+\n+    /// Converts a character to its uppercase equivalent.\n+    ///\n+    /// The case-folding performed is the common or simple mapping: it maps\n+    /// one unicode codepoint (one character in Rust) to its uppercase\n+    /// equivalent according to the Unicode database [1]. The additional\n+    /// `SpecialCasing.txt` is not considered here, as it expands to multiple\n+    /// codepoints in some cases.\n+    ///\n+    /// A full reference can be found here [2].\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns the uppercase equivalent of the character, or the character\n+    /// itself if no conversion was made.\n+    ///\n+    /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    ///\n+    /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n+    fn to_uppercase(&self) -> char;\n+\n+    /// Returns this character's displayed width in columns, or `None` if it is a\n+    /// control character other than `'\\x00'`.\n+    ///\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK contexts, `is_cjk` should be `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these characters be treated as 1 column (i.e.,\n+    /// `is_cjk` = `false`) if the context cannot be reliably determined.\n+    fn width(&self, is_cjk: bool) -> Option<uint>;\n+}\n+\n+impl UnicodeChar for char {\n+    fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }\n+\n+    fn is_XID_start(&self) -> bool { is_XID_start(*self) }\n+\n+    fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }\n+\n+    fn is_lowercase(&self) -> bool { is_lowercase(*self) }\n+\n+    fn is_uppercase(&self) -> bool { is_uppercase(*self) }\n+\n+    fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n+\n+    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n+\n+    fn is_control(&self) -> bool { is_control(*self) }\n+\n+    fn is_digit(&self) -> bool { is_digit(*self) }\n+\n+    fn to_lowercase(&self) -> char { to_lowercase(*self) }\n+\n+    fn to_uppercase(&self) -> char { to_uppercase(*self) }\n+\n+    fn width(&self, is_cjk: bool) -> Option<uint> { width(*self, is_cjk) }\n+}"}, {"sha": "84a2eab4b251257888887599fba8433fcd00372c", "filename": "src/libunicode/u_str.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4238b6fc8769c35ff5818ed04d16a6deab784f/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=5d4238b6fc8769c35ff5818ed04d16a6deab784f", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Unicode-intensive string manipulations.\n+ *\n+ * This module provides functionality to `str` that requires the Unicode\n+ * methods provided by the UnicodeChar trait.\n+ */\n+\n+use core::collections::Collection;\n+use core::iter::{Filter};\n+use core::str::{CharSplits, StrSlice};\n+use core::iter::Iterator;\n+use u_char;\n+\n+/// An iterator over the words of a string, separated by a sequence of whitespace\n+pub type Words<'a> =\n+    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n+\n+/// Methods for Unicode string slices\n+pub trait UnicodeStrSlice<'a> {\n+    /// An iterator over the words of a string (subsequences separated\n+    /// by any sequence of whitespace). Sequences of whitespace are\n+    /// collapsed, so empty \"words\" are not included.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: Vec<&str> = some_words.words().collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// ```\n+    fn words(&self) -> Words<'a>;\n+\n+    /// Returns true if the string contains only whitespace.\n+    ///\n+    /// Whitespace characters are determined by `char::is_whitespace`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\" \\t\\n\".is_whitespace());\n+    /// assert!(\"\".is_whitespace());\n+    ///\n+    /// assert!( !\"abc\".is_whitespace());\n+    /// ```\n+    fn is_whitespace(&self) -> bool;\n+\n+    /// Returns true if the string contains only alphanumeric code\n+    /// points.\n+    ///\n+    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n+    /// assert!(\"\".is_alphanumeric());\n+    ///\n+    /// assert!( !\" &*~\".is_alphanumeric());\n+    /// ```\n+    fn is_alphanumeric(&self) -> bool;\n+\n+    /// Returns a string's displayed width in columns, treating control\n+    /// characters as zero-width.\n+    ///\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK locales, `is_cjk` should be `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these characters be treated as 1 column (i.e.,\n+    /// `is_cjk` = `false`) if the locale is unknown.\n+    //fn width(&self, is_cjk: bool) -> uint;\n+\n+    /// Returns a string with leading and trailing whitespace removed.\n+    fn trim(&self) -> &'a str;\n+\n+    /// Returns a string with leading whitespace removed.\n+    fn trim_left(&self) -> &'a str;\n+\n+    /// Returns a string with trailing whitespace removed.\n+    fn trim_right(&self) -> &'a str;\n+}\n+\n+impl<'a> UnicodeStrSlice<'a> for &'a str {\n+    #[inline]\n+    fn words(&self) -> Words<'a> {\n+        self.split(u_char::is_whitespace).filter(|s| !s.is_empty())\n+    }\n+\n+    #[inline]\n+    fn is_whitespace(&self) -> bool { self.chars().all(u_char::is_whitespace) }\n+\n+    #[inline]\n+    fn is_alphanumeric(&self) -> bool { self.chars().all(u_char::is_alphanumeric) }\n+\n+    #[inline]\n+    fn trim(&self) -> &'a str {\n+        self.trim_left().trim_right()\n+    }\n+\n+    #[inline]\n+    fn trim_left(&self) -> &'a str {\n+        self.trim_left_chars(u_char::is_whitespace)\n+    }\n+\n+    #[inline]\n+    fn trim_right(&self) -> &'a str {\n+        self.trim_right_chars(u_char::is_whitespace)\n+    }\n+}"}]}