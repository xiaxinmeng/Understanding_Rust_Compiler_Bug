{"sha": "c65547337831babea8d9052b960649309263df36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NTU0NzMzNzgzMWJhYmVhOGQ5MDUyYjk2MDY0OTMwOTI2M2RmMzY=", "commit": {"author": {"name": "Donato Sciarra", "email": "sciarp@gmail.com", "date": "2018-08-18T10:13:35Z"}, "committer": {"name": "Donato Sciarra", "email": "sciarp@gmail.com", "date": "2018-08-19T21:00:59Z"}, "message": "mv CodeMap SourceMap", "tree": {"sha": "e33b9c8d595cc8d8cf59b844daadfc390c24b368", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e33b9c8d595cc8d8cf59b844daadfc390c24b368"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c65547337831babea8d9052b960649309263df36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c65547337831babea8d9052b960649309263df36", "html_url": "https://github.com/rust-lang/rust/commit/c65547337831babea8d9052b960649309263df36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c65547337831babea8d9052b960649309263df36/comments", "author": {"login": "dsciarra", "id": 2036702, "node_id": "MDQ6VXNlcjIwMzY3MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2036702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dsciarra", "html_url": "https://github.com/dsciarra", "followers_url": "https://api.github.com/users/dsciarra/followers", "following_url": "https://api.github.com/users/dsciarra/following{/other_user}", "gists_url": "https://api.github.com/users/dsciarra/gists{/gist_id}", "starred_url": "https://api.github.com/users/dsciarra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dsciarra/subscriptions", "organizations_url": "https://api.github.com/users/dsciarra/orgs", "repos_url": "https://api.github.com/users/dsciarra/repos", "events_url": "https://api.github.com/users/dsciarra/events{/privacy}", "received_events_url": "https://api.github.com/users/dsciarra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dsciarra", "id": 2036702, "node_id": "MDQ6VXNlcjIwMzY3MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2036702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dsciarra", "html_url": "https://github.com/dsciarra", "followers_url": "https://api.github.com/users/dsciarra/followers", "following_url": "https://api.github.com/users/dsciarra/following{/other_user}", "gists_url": "https://api.github.com/users/dsciarra/gists{/gist_id}", "starred_url": "https://api.github.com/users/dsciarra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dsciarra/subscriptions", "organizations_url": "https://api.github.com/users/dsciarra/orgs", "repos_url": "https://api.github.com/users/dsciarra/repos", "events_url": "https://api.github.com/users/dsciarra/events{/privacy}", "received_events_url": "https://api.github.com/users/dsciarra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ac79c718475fd29b8be34dde667b683390c2aee", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac79c718475fd29b8be34dde667b683390c2aee", "html_url": "https://github.com/rust-lang/rust/commit/3ac79c718475fd29b8be34dde667b683390c2aee"}], "stats": {"total": 266, "additions": 133, "deletions": 133}, "files": [{"sha": "ceeb31934e16aad7cf0679a88837926df26ddb9d", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -18,7 +18,7 @@ use middle::cstore::CrateStore;\n use session::CrateDisambiguator;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n-use syntax::codemap::CodeMap;\n+use syntax::codemap::SourceMap;\n use syntax_pos::Span;\n \n use ich::StableHashingContext;\n@@ -122,7 +122,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn finalize_and_compute_crate_hash(mut self,\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &dyn CrateStore,\n-                                                  codemap: &CodeMap,\n+                                                  codemap: &SourceMap,\n                                                   commandline_args_hash: u64)\n                                                   -> (Vec<MapEntry<'hir>>, Svh) {\n         self"}, {"sha": "7ecbf7ebbaff07f63520365a79e33fee18ed05db", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -739,7 +739,7 @@ define_global_metadata_kind!(pub enum GlobalMetaDataKind {\n     LangItems,\n     LangItemsMissing,\n     NativeLibraries,\n-    CodeMap,\n+    SourceMap,\n     Impls,\n     ExportedSymbols\n });"}, {"sha": "512f78763b27383003732f0e99c1fb52b8070911", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -12,7 +12,7 @@ pub use self::AnnNode::*;\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n-use syntax::codemap::{CodeMap, Spanned};\n+use syntax::codemap::{SourceMap, Spanned};\n use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n@@ -85,7 +85,7 @@ impl PpAnn for hir::Crate {\n \n pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n-    cm: Option<&'a CodeMap>,\n+    cm: Option<&'a SourceMap>,\n     comments: Option<Vec<comments::Comment>>,\n     literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n@@ -129,7 +129,7 @@ pub const default_columns: usize = 78;\n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments and literals to\n /// copy forward.\n-pub fn print_crate<'a>(cm: &'a CodeMap,\n+pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n                        filename: FileName,\n@@ -149,7 +149,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n }\n \n impl<'a> State<'a> {\n-    pub fn new_from_input(cm: &'a CodeMap,\n+    pub fn new_from_input(cm: &'a SourceMap,\n                           sess: &ParseSess,\n                           filename: FileName,\n                           input: &mut dyn Read,\n@@ -173,7 +173,7 @@ impl<'a> State<'a> {\n                    })\n     }\n \n-    pub fn new(cm: &'a CodeMap,\n+    pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write + 'a>,\n                ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,"}, {"sha": "769c4cfe9fa9386563569bfd1343ab1c46250a5d", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc_data_structures::sync::Lrc;\n-use syntax::codemap::CodeMap;\n+use syntax::codemap::SourceMap;\n use syntax_pos::{BytePos, FileMap};\n \n #[derive(Clone)]\n@@ -24,13 +24,13 @@ struct CacheEntry {\n \n #[derive(Clone)]\n pub struct CachingCodemapView<'cm> {\n-    codemap: &'cm CodeMap,\n+    codemap: &'cm SourceMap,\n     line_cache: [CacheEntry; 3],\n     time_stamp: usize,\n }\n \n impl<'cm> CachingCodemapView<'cm> {\n-    pub fn new(codemap: &'cm CodeMap) -> CachingCodemapView<'cm> {\n+    pub fn new(codemap: &'cm SourceMap) -> CachingCodemapView<'cm> {\n         let files = codemap.files();\n         let first_file = files[0].clone();\n         let entry = CacheEntry {"}, {"sha": "91fbb1cc0fde6107748cedcf6fc367af409f10ed", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -25,7 +25,7 @@ use std::cell::RefCell;\n \n use syntax::ast;\n \n-use syntax::codemap::CodeMap;\n+use syntax::codemap::SourceMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -58,7 +58,7 @@ pub struct StableHashingContext<'a> {\n \n     // Very often, we are hashing something that does not need the\n     // CachingCodemapView, so we initialize it lazily.\n-    raw_codemap: &'a CodeMap,\n+    raw_codemap: &'a SourceMap,\n     caching_codemap: Option<CachingCodemapView<'a>>,\n \n     pub(super) alloc_id_recursion_tracker: FxHashSet<AllocId>,\n@@ -308,9 +308,9 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n-    // offsets into the CodeMap). Instead, we hash the (file name, line, column)\n+    // offsets into the SourceMap). Instead, we hash the (file name, line, column)\n     // triple, which stays the same even if the containing FileMap has moved\n-    // within the CodeMap.\n+    // within the SourceMap.\n     // Also note that we are hashing byte offsets for the column, not unicode\n     // codepoint offsets. For the purpose of the hash that's sufficient.\n     // Also, hashing filenames is expensive so we avoid doing it twice when the"}, {"sha": "05f8e3cfb00ac9ab24416aec56e1a6fbd069cd4a", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -484,7 +484,7 @@ impl Session {\n         );\n     }\n \n-    pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n+    pub fn codemap<'a>(&'a self) -> &'a codemap::SourceMap {\n         self.parse_sess.codemap()\n     }\n     pub fn verbose(&self) -> bool {\n@@ -984,7 +984,7 @@ pub fn build_session(\n         sopts,\n         local_crate_source_file,\n         registry,\n-        Lrc::new(codemap::CodeMap::new(file_path_mapping)),\n+        Lrc::new(codemap::SourceMap::new(file_path_mapping)),\n         None,\n     )\n }\n@@ -993,7 +993,7 @@ pub fn build_session_with_codemap(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     registry: errors::registry::Registry,\n-    codemap: Lrc<codemap::CodeMap>,\n+    codemap: Lrc<codemap::SourceMap>,\n     emitter_dest: Option<Box<dyn Write + Send>>,\n ) -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n@@ -1070,7 +1070,7 @@ pub fn build_session_(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     span_diagnostic: errors::Handler,\n-    codemap: Lrc<codemap::CodeMap>,\n+    codemap: Lrc<codemap::SourceMap>,\n ) -> Session {\n     let host_triple = TargetTriple::from_triple(config::host_triple());\n     let host = match Target::search(&host_triple) {"}, {"sha": "1f0f6bee77795b6d7049a7d686b04a8b75faf3f0", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -26,7 +26,7 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n use session::{CrateDisambiguator, Session};\n use std::mem;\n use syntax::ast::NodeId;\n-use syntax::codemap::{CodeMap, StableFilemapId};\n+use syntax::codemap::{SourceMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n@@ -62,7 +62,7 @@ pub struct OnDiskCache<'sess> {\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     cnum_map: Once<IndexVec<CrateNum, Option<CrateNum>>>,\n \n-    codemap: &'sess CodeMap,\n+    codemap: &'sess SourceMap,\n     file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n \n     // These two fields caches that are populated lazily during decoding.\n@@ -149,7 +149,7 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn new_empty(codemap: &'sess CodeMap) -> OnDiskCache<'sess> {\n+    pub fn new_empty(codemap: &'sess SourceMap) -> OnDiskCache<'sess> {\n         OnDiskCache {\n             serialized_data: Vec::new(),\n             file_index_to_stable_id: FxHashMap(),\n@@ -475,7 +475,7 @@ impl<'sess> OnDiskCache<'sess> {\n struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     opaque: opaque::Decoder<'x>,\n-    codemap: &'x CodeMap,\n+    codemap: &'x SourceMap,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n     synthetic_expansion_infos: &'x Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n     file_index_to_file: &'x Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,"}, {"sha": "ed6e9db5e4e512f65b72989613d7da72a35b9219", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -107,7 +107,7 @@ use std::sync::{Once, ONCE_INIT};\n use std::thread;\n \n use syntax::ast;\n-use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n+use syntax::codemap::{SourceMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n@@ -522,7 +522,7 @@ fn run_compiler_with_pool<'a>(\n     };\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n-    let codemap = Lrc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n+    let codemap = Lrc::new(SourceMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n         sopts, input_file_path.clone(), descriptions, codemap, emitter_dest,\n     );"}, {"sha": "a4bba31b669c7f548fd7ba2786f66b15fadba5ca", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -32,7 +32,7 @@ use rustc_data_structures::sync::{self, Lrc};\n use syntax;\n use syntax::ast;\n use rustc_target::spec::abi::Abi;\n-use syntax::codemap::{CodeMap, FilePathMapping, FileName};\n+use syntax::codemap::{SourceMap, FilePathMapping, FileName};\n use errors;\n use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n@@ -121,7 +121,7 @@ fn test_env_with_pool<F>(\n     let sess = session::build_session_(options,\n                                        None,\n                                        diagnostic_handler,\n-                                       Lrc::new(CodeMap::new(FilePathMapping::empty())));\n+                                       Lrc::new(SourceMap::new(FilePathMapping::empty())));\n     let cstore = CStore::new(::get_codegen_backend(&sess).metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {"}, {"sha": "0a3e4d3ad25c0c555244f1cdaff06feefb052884", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -12,7 +12,7 @@ use self::Destination::*;\n \n use syntax_pos::{FileMap, Span, MultiSpan};\n \n-use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapperDyn, DiagnosticId};\n+use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, SourceMapperDyn, DiagnosticId};\n use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n use styled_buffer::StyledBuffer;\n \n@@ -120,7 +120,7 @@ impl ColorConfig {\n \n pub struct EmitterWriter {\n     dst: Destination,\n-    cm: Option<Lrc<CodeMapperDyn>>,\n+    cm: Option<Lrc<SourceMapperDyn>>,\n     short_message: bool,\n     teach: bool,\n     ui_testing: bool,\n@@ -134,7 +134,7 @@ struct FileWithAnnotatedLines {\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n-                  code_map: Option<Lrc<CodeMapperDyn>>,\n+                  code_map: Option<Lrc<SourceMapperDyn>>,\n                   short_message: bool,\n                   teach: bool)\n                   -> EmitterWriter {\n@@ -149,7 +149,7 @@ impl EmitterWriter {\n     }\n \n     pub fn new(dst: Box<dyn Write + Send>,\n-               code_map: Option<Lrc<CodeMapperDyn>>,\n+               code_map: Option<Lrc<SourceMapperDyn>>,\n                short_message: bool,\n                teach: bool)\n                -> EmitterWriter {"}, {"sha": "40d7a122d3091d214e723b7a4e3216423321c8fb", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -111,9 +111,9 @@ pub struct SubstitutionPart {\n     pub snippet: String,\n }\n \n-pub type CodeMapperDyn = dyn CodeMapper + sync::Send + sync::Sync;\n+pub type SourceMapperDyn = dyn SourceMapper + sync::Send + sync::Sync;\n \n-pub trait CodeMapper {\n+pub trait SourceMapper {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc;\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n     fn span_to_string(&self, sp: Span) -> String;\n@@ -126,7 +126,7 @@ pub trait CodeMapper {\n \n impl CodeSuggestion {\n     /// Returns the assembled code suggestions and whether they should be shown with an underline.\n-    pub fn splice_lines(&self, cm: &CodeMapperDyn)\n+    pub fn splice_lines(&self, cm: &SourceMapperDyn)\n                         -> Vec<(String, Vec<SubstitutionPart>)> {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n@@ -321,7 +321,7 @@ impl Handler {\n     pub fn with_tty_emitter(color_config: ColorConfig,\n                             can_emit_warnings: bool,\n                             treat_err_as_bug: bool,\n-                            cm: Option<Lrc<CodeMapperDyn>>)\n+                            cm: Option<Lrc<SourceMapperDyn>>)\n                             -> Handler {\n         Handler::with_tty_emitter_and_flags(\n             color_config,\n@@ -334,7 +334,7 @@ impl Handler {\n     }\n \n     pub fn with_tty_emitter_and_flags(color_config: ColorConfig,\n-                                      cm: Option<Lrc<CodeMapperDyn>>,\n+                                      cm: Option<Lrc<SourceMapperDyn>>,\n                                       flags: HandlerFlags)\n                                       -> Handler {\n         let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false, false));"}, {"sha": "4a17c5845fdb4a7b4c76065e2565e2191e51814f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -1117,7 +1117,7 @@ impl<'a, 'tcx> CrateMetadata {\n     /// multibyte characters. This information is enough to generate valid debuginfo\n     /// for items inlined from other crates.\n     pub fn imported_filemaps(&'a self,\n-                             local_codemap: &codemap::CodeMap)\n+                             local_codemap: &codemap::SourceMap)\n                              -> ReadGuard<'a, Vec<cstore::ImportedFileMap>> {\n         {\n             let filemaps = self.codemap_import_info.borrow();\n@@ -1154,7 +1154,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n             // Translate line-start positions and multibyte character\n             // position into frame of reference local to file.\n-            // `CodeMap::new_imported_filemap()` will then translate those\n+            // `SourceMap::new_imported_filemap()` will then translate those\n             // coordinates to their new global frame of reference when the\n             // offset of the FileMap is known.\n             for pos in &mut lines {"}, {"sha": "0356bdae7dc341c96a85c9d7b6e4631b65b95c1f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -49,7 +49,7 @@ use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n \n-use syntax::codemap::CodeMap;\n+use syntax::codemap::SourceMap;\n use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -415,7 +415,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n /// Attention: The method used is very fragile since it essentially duplicates the work of the\n /// parser. If you need to use this function or something similar, please consider updating the\n /// codemap functions and this function to something more robust.\n-fn reduce_impl_span_to_impl_keyword(cm: &CodeMap, impl_span: Span) -> Span {\n+fn reduce_impl_span_to_impl_keyword(cm: &SourceMap, impl_span: Span) -> Span {\n     let impl_span = cm.span_until_char(impl_span, '<');\n     let impl_span = cm.span_until_whitespace(impl_span);\n     impl_span"}, {"sha": "8bd53976e264c48563e9e8b1b40ff9ba8c49fd06", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::map::{NodeItem, NodeExpr};\n use rustc::hir::{Item, ItemKind, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n-use errors::{DiagnosticBuilder, CodeMapper};\n+use errors::{DiagnosticBuilder, SourceMapper};\n \n use super::method::probe;\n "}, {"sha": "6b2cb53b8f1f05f5cc3eaa05729b8ac78da600c8", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -258,9 +258,9 @@ impl DocAccessLevels for AccessLevels<DefId> {\n \n /// Creates a new diagnostic `Handler` that can be used to emit warnings and errors.\n ///\n-/// If the given `error_format` is `ErrorOutputType::Json` and no `CodeMap` is given, a new one\n+/// If the given `error_format` is `ErrorOutputType::Json` and no `SourceMap` is given, a new one\n /// will be created for the handler.\n-pub fn new_handler(error_format: ErrorOutputType, codemap: Option<Lrc<codemap::CodeMap>>)\n+pub fn new_handler(error_format: ErrorOutputType, codemap: Option<Lrc<codemap::SourceMap>>)\n     -> errors::Handler\n {\n     // rustdoc doesn't override (or allow to override) anything from this that is relevant here, so\n@@ -277,7 +277,7 @@ pub fn new_handler(error_format: ErrorOutputType, codemap: Option<Lrc<codemap::C\n         ),\n         ErrorOutputType::Json(pretty) => {\n             let codemap = codemap.unwrap_or_else(\n-                || Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping())));\n+                || Lrc::new(codemap::SourceMap::new(sessopts.file_path_mapping())));\n             Box::new(\n                 JsonEmitter::stderr(\n                     None,\n@@ -387,7 +387,7 @@ pub fn run_core(search_paths: SearchPaths,\n         ..Options::default()\n     };\n     driver::spawn_thread_pool(sessopts, move |sessopts| {\n-        let codemap = Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n+        let codemap = Lrc::new(codemap::SourceMap::new(sessopts.file_path_mapping()));\n         let diagnostic_handler = new_handler(error_format, Some(codemap.clone()));\n \n         let mut sess = session::build_session_("}, {"sha": "a913700911507dfd2d632089f461d876a9b6598c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -21,7 +21,7 @@ use std::fmt::Display;\n use std::io;\n use std::io::prelude::*;\n \n-use syntax::codemap::{CodeMap, FilePathMapping};\n+use syntax::codemap::{SourceMap, FilePathMapping};\n use syntax::parse::lexer::{self, TokenAndSpan};\n use syntax::parse::token;\n use syntax::parse;\n@@ -60,7 +60,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>,\n /// each span of text in sequence.\n struct Classifier<'a> {\n     lexer: lexer::StringReader<'a>,\n-    codemap: &'a CodeMap,\n+    codemap: &'a SourceMap,\n \n     // State of the classifier.\n     in_attribute: bool,\n@@ -145,7 +145,7 @@ impl<U: Write> Writer for U {\n }\n \n impl<'a> Classifier<'a> {\n-    fn new(lexer: lexer::StringReader<'a>, codemap: &'a CodeMap) -> Classifier<'a> {\n+    fn new(lexer: lexer::StringReader<'a>, codemap: &'a SourceMap) -> Classifier<'a> {\n         Classifier {\n             lexer,\n             codemap,"}, {"sha": "605b08219a14888dff19422a5f40ecb54bc970a5", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -33,7 +33,7 @@ use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n use syntax::ast;\n-use syntax::codemap::CodeMap;\n+use syntax::codemap::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::with_globals;\n@@ -86,7 +86,7 @@ pub fn run(input_path: &Path,\n         ..config::Options::default()\n     };\n     driver::spawn_thread_pool(sessopts, |sessopts| {\n-        let codemap = Lrc::new(CodeMap::new(sessopts.file_path_mapping()));\n+        let codemap = Lrc::new(SourceMap::new(sessopts.file_path_mapping()));\n         let handler =\n             errors::Handler::with_tty_emitter(ColorConfig::Auto,\n                                             true, false,\n@@ -205,7 +205,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n     // never wrap the test in `fn main() { ... }`\n     let (test, line_offset) = make_test(test, Some(cratename), as_test_harness, opts);\n     // FIXME(#44940): if doctests ever support path remapping, then this filename\n-    // needs to be the result of CodeMap::span_to_unmapped_path\n+    // needs to be the result of SourceMap::span_to_unmapped_path\n     let input = config::Input::Str {\n         name: filename.to_owned(),\n         input: test.to_owned(),\n@@ -262,7 +262,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n     let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n \n     let (libdir, outdir, compile_result) = driver::spawn_thread_pool(sessopts, |sessopts| {\n-        let codemap = Lrc::new(CodeMap::new_doctest(\n+        let codemap = Lrc::new(SourceMap::new_doctest(\n             sessopts.file_path_mapping(), filename.clone(), line as isize - line_offset as isize\n         ));\n         let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n@@ -500,7 +500,7 @@ pub struct Collector {\n     opts: TestOptions,\n     maybe_sysroot: Option<PathBuf>,\n     position: Span,\n-    codemap: Option<Lrc<CodeMap>>,\n+    codemap: Option<Lrc<SourceMap>>,\n     filename: Option<PathBuf>,\n     linker: Option<PathBuf>,\n     edition: Edition,\n@@ -509,7 +509,7 @@ pub struct Collector {\n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, cg: CodegenOptions,\n                externs: Externs, use_headers: bool, opts: TestOptions,\n-               maybe_sysroot: Option<PathBuf>, codemap: Option<Lrc<CodeMap>>,\n+               maybe_sysroot: Option<PathBuf>, codemap: Option<Lrc<SourceMap>>,\n                filename: Option<PathBuf>, linker: Option<PathBuf>, edition: Edition) -> Collector {\n         Collector {\n             tests: Vec::new(),"}, {"sha": "8175e2495c5d17e382392abcf8c9255fdfca699d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The CodeMap tracks all the source code used within a single crate, mapping\n+//! The SourceMap tracks all the source code used within a single crate, mapping\n //! from integer byte positions to the original source code location. Each bit\n //! of source parsed during crate parsing (typically files, in-memory strings,\n //! or various bits of macro expansion) cover a continuous range of bytes in the\n-//! CodeMap and are represented by FileMaps. Byte positions are stored in\n+//! SourceMap and are represented by FileMaps. Byte positions are stored in\n //! `spans` and used pervasively in the compiler. They are absolute positions\n-//! within the CodeMap, which upon request can be converted to line and column\n+//! within the SourceMap, which upon request can be converted to line and column\n //! information, source code snippets, etc.\n \n \n@@ -32,7 +32,7 @@ use std::path::{Path, PathBuf};\n use std::env;\n use std::fs;\n use std::io::{self, Read};\n-use errors::CodeMapper;\n+use errors::SourceMapper;\n \n /// Return the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n@@ -121,29 +121,29 @@ impl StableFilemapId {\n }\n \n // _____________________________________________________________________________\n-// CodeMap\n+// SourceMap\n //\n \n-pub(super) struct CodeMapFiles {\n+pub(super) struct SourceMapFiles {\n     pub(super) file_maps: Vec<Lrc<FileMap>>,\n     stable_id_to_filemap: FxHashMap<StableFilemapId, Lrc<FileMap>>\n }\n \n-pub struct CodeMap {\n-    pub(super) files: Lock<CodeMapFiles>,\n+pub struct SourceMap {\n+    pub(super) files: Lock<SourceMapFiles>,\n     file_loader: Box<dyn FileLoader + Sync + Send>,\n     // This is used to apply the file path remapping as specified via\n-    // --remap-path-prefix to all FileMaps allocated within this CodeMap.\n+    // --remap-path-prefix to all FileMaps allocated within this SourceMap.\n     path_mapping: FilePathMapping,\n     /// In case we are in a doctest, replace all file names with the PathBuf,\n     /// and add the given offsets to the line info\n     doctest_offset: Option<(FileName, isize)>,\n }\n \n-impl CodeMap {\n-    pub fn new(path_mapping: FilePathMapping) -> CodeMap {\n-        CodeMap {\n-            files: Lock::new(CodeMapFiles {\n+impl SourceMap {\n+    pub fn new(path_mapping: FilePathMapping) -> SourceMap {\n+        SourceMap {\n+            files: Lock::new(SourceMapFiles {\n                 file_maps: Vec::new(),\n                 stable_id_to_filemap: FxHashMap(),\n             }),\n@@ -154,19 +154,19 @@ impl CodeMap {\n     }\n \n     pub fn new_doctest(path_mapping: FilePathMapping,\n-                       file: FileName, line: isize) -> CodeMap {\n-        CodeMap {\n+                       file: FileName, line: isize) -> SourceMap {\n+        SourceMap {\n             doctest_offset: Some((file, line)),\n-            ..CodeMap::new(path_mapping)\n+            ..SourceMap::new(path_mapping)\n         }\n \n     }\n \n     pub fn with_file_loader(file_loader: Box<dyn FileLoader + Sync + Send>,\n                             path_mapping: FilePathMapping)\n-                            -> CodeMap {\n-        CodeMap {\n-            files: Lock::new(CodeMapFiles {\n+                            -> SourceMap {\n+        SourceMap {\n+            files: Lock::new(SourceMapFiles {\n                 file_maps: Vec::new(),\n                 stable_id_to_filemap: FxHashMap(),\n             }),\n@@ -463,7 +463,7 @@ impl CodeMap {\n \n     pub fn span_to_unmapped_path(&self, sp: Span) -> FileName {\n         self.lookup_char_pos(sp.lo()).file.unmapped_path.clone()\n-            .expect(\"CodeMap::span_to_unmapped_path called for imported FileMap?\")\n+            .expect(\"SourceMap::span_to_unmapped_path called for imported FileMap?\")\n     }\n \n     pub fn is_multiline(&self, sp: Span) -> bool {\n@@ -941,7 +941,7 @@ impl CodeMap {\n     }\n }\n \n-impl CodeMapper for CodeMap {\n+impl SourceMapper for SourceMap {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n         self.lookup_char_pos(pos)\n     }\n@@ -1023,8 +1023,8 @@ mod tests {\n     use super::*;\n     use rustc_data_structures::sync::Lrc;\n \n-    fn init_code_map() -> CodeMap {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n+    fn init_code_map() -> SourceMap {\n+        let cm = SourceMap::new(FilePathMapping::empty());\n         cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n                        \"first line.\\nsecond line\".to_string());\n         cm.new_filemap(PathBuf::from(\"empty.rs\").into(),\n@@ -1080,8 +1080,8 @@ mod tests {\n         assert_eq!(loc2.col, CharPos(0));\n     }\n \n-    fn init_code_map_mbc() -> CodeMap {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n+    fn init_code_map_mbc() -> SourceMap {\n+        let cm = SourceMap::new(FilePathMapping::empty());\n         // \u20ac is a three byte utf8 char.\n         cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n                        \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n@@ -1135,7 +1135,7 @@ mod tests {\n     /// lines in the middle of a file.\n     #[test]\n     fn span_to_snippet_and_lines_spanning_multiple_lines() {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n+        let cm = SourceMap::new(FilePathMapping::empty());\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n         cm.new_filemap(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_string());\n@@ -1177,7 +1177,7 @@ mod tests {\n     /// Test failing to merge two spans on different lines\n     #[test]\n     fn span_merging_fail() {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n+        let cm = SourceMap::new(FilePathMapping::empty());\n         let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n         let selection1 = \"     ~~\\n      \\n\";\n         let selection2 = \"       \\n   ~~~\\n\";\n@@ -1190,7 +1190,7 @@ mod tests {\n \n     /// Returns the span corresponding to the `n`th occurrence of\n     /// `substring` in `source_text`.\n-    trait CodeMapExtension {\n+    trait SourceMapExtension {\n         fn span_substr(&self,\n                     file: &Lrc<FileMap>,\n                     source_text: &str,\n@@ -1199,7 +1199,7 @@ mod tests {\n                     -> Span;\n     }\n \n-    impl CodeMapExtension for CodeMap {\n+    impl SourceMapExtension for SourceMap {\n         fn span_substr(&self,\n                     file: &Lrc<FileMap>,\n                     source_text: &str,"}, {"sha": "8ae4f9c1aa46f6da07ed6d15495daaef371731e0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -12,7 +12,7 @@ pub use self::SyntaxExtension::*;\n \n use ast::{self, Attribute, Name, PatKind, MetaItem};\n use attr::HasAttrs;\n-use codemap::{self, CodeMap, Spanned, respan};\n+use codemap::{self, SourceMap, Spanned, respan};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n use edition::Edition;\n use errors::{DiagnosticBuilder, DiagnosticId};\n@@ -836,7 +836,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree]) -> parser::Parser<'a> {\n         parse::stream_to_parser(self.parse_sess, tts.iter().cloned().collect())\n     }\n-    pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }\n+    pub fn codemap(&self) -> &'a SourceMap { self.parse_sess.codemap() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {"}, {"sha": "22de184938f0cb9f4ad4d468bee1eb1ec6c0dd66", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -19,10 +19,10 @@\n \n // FIXME spec the JSON output properly.\n \n-use codemap::{CodeMap, FilePathMapping};\n+use codemap::{SourceMap, FilePathMapping};\n use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n use errors::registry::Registry;\n-use errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, CodeMapper};\n+use errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, SourceMapper};\n use errors::{DiagnosticId, Applicability};\n use errors::emitter::{Emitter, EmitterWriter};\n \n@@ -36,14 +36,14 @@ use rustc_serialize::json::{as_json, as_pretty_json};\n pub struct JsonEmitter {\n     dst: Box<dyn Write + Send>,\n     registry: Option<Registry>,\n-    cm: Lrc<dyn CodeMapper + sync::Send + sync::Sync>,\n+    cm: Lrc<dyn SourceMapper + sync::Send + sync::Sync>,\n     pretty: bool,\n     ui_testing: bool,\n }\n \n impl JsonEmitter {\n     pub fn stderr(registry: Option<Registry>,\n-                  code_map: Lrc<CodeMap>,\n+                  code_map: Lrc<SourceMap>,\n                   pretty: bool) -> JsonEmitter {\n         JsonEmitter {\n             dst: Box::new(io::stderr()),\n@@ -56,13 +56,13 @@ impl JsonEmitter {\n \n     pub fn basic(pretty: bool) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n-        JsonEmitter::stderr(None, Lrc::new(CodeMap::new(file_path_mapping)),\n+        JsonEmitter::stderr(None, Lrc::new(SourceMap::new(file_path_mapping)),\n                             pretty)\n     }\n \n     pub fn new(dst: Box<dyn Write + Send>,\n                registry: Option<Registry>,\n-               code_map: Lrc<CodeMap>,\n+               code_map: Lrc<SourceMap>,\n                pretty: bool) -> JsonEmitter {\n         JsonEmitter {\n             dst,"}, {"sha": "2c227756f9a31fb14cdd9ab2b9c05f6037f5fcb6", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -11,7 +11,7 @@\n pub use self::CommentStyle::*;\n \n use ast;\n-use codemap::CodeMap;\n+use codemap::SourceMap;\n use syntax_pos::{BytePos, CharPos, Pos, FileName};\n use parse::lexer::{is_block_doc_comment, is_pattern_whitespace};\n use parse::lexer::{self, ParseSess, StringReader, TokenAndSpan};\n@@ -371,7 +371,7 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut\n {\n     let mut src = String::new();\n     srdr.read_to_string(&mut src).unwrap();\n-    let cm = CodeMap::new(sess.codemap().path_mapping().clone());\n+    let cm = SourceMap::new(sess.codemap().path_mapping().clone());\n     let filemap = cm.new_filemap(path, src);\n     let mut rdr = lexer::StringReader::new_raw(sess, filemap, None);\n "}, {"sha": "c1919434e374a87ab398e51df1eb7202b30a0622", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -10,7 +10,7 @@\n \n use ast::{self, Ident};\n use syntax_pos::{self, BytePos, CharPos, Pos, Span, NO_EXPANSION};\n-use codemap::{CodeMap, FilePathMapping};\n+use codemap::{SourceMap, FilePathMapping};\n use errors::{Applicability, FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n@@ -622,7 +622,7 @@ impl<'a> StringReader<'a> {\n \n                 // I guess this is the only way to figure out if\n                 // we're at the beginning of the file...\n-                let cmap = CodeMap::new(FilePathMapping::empty());\n+                let cmap = SourceMap::new(FilePathMapping::empty());\n                 cmap.files.borrow_mut().file_maps.push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.pos);\n                 debug!(\"Skipping a shebang\");\n@@ -1827,7 +1827,7 @@ mod tests {\n     use ast::{Ident, CrateConfig};\n     use symbol::Symbol;\n     use syntax_pos::{BytePos, Span, NO_EXPANSION};\n-    use codemap::CodeMap;\n+    use codemap::SourceMap;\n     use errors;\n     use feature_gate::UnstableFeatures;\n     use parse::token;\n@@ -1837,7 +1837,7 @@ mod tests {\n     use diagnostics::plugin::ErrorMap;\n     use rustc_data_structures::sync::Lock;\n     use with_globals;\n-    fn mk_sess(cm: Lrc<CodeMap>) -> ParseSess {\n+    fn mk_sess(cm: Lrc<SourceMap>) -> ParseSess {\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n                                                           Some(cm.clone()),\n                                                           false,\n@@ -1857,7 +1857,7 @@ mod tests {\n     }\n \n     // open a string reader for the given string\n-    fn setup<'a>(cm: &CodeMap,\n+    fn setup<'a>(cm: &SourceMap,\n                  sess: &'a ParseSess,\n                  teststr: String)\n                  -> StringReader<'a> {\n@@ -1868,7 +1868,7 @@ mod tests {\n     #[test]\n     fn t1() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             let mut string_reader = setup(&cm,\n                                         &sh,\n@@ -1916,7 +1916,7 @@ mod tests {\n     #[test]\n     fn doublecolonparsing() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             check_tokenization(setup(&cm, &sh, \"a b\".to_string()),\n                             vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n@@ -1926,7 +1926,7 @@ mod tests {\n     #[test]\n     fn dcparsing_2() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             check_tokenization(setup(&cm, &sh, \"a::b\".to_string()),\n                             vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n@@ -1936,7 +1936,7 @@ mod tests {\n     #[test]\n     fn dcparsing_3() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             check_tokenization(setup(&cm, &sh, \"a ::b\".to_string()),\n                             vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n@@ -1946,7 +1946,7 @@ mod tests {\n     #[test]\n     fn dcparsing_4() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             check_tokenization(setup(&cm, &sh, \"a:: b\".to_string()),\n                             vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n@@ -1956,7 +1956,7 @@ mod tests {\n     #[test]\n     fn character_a() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n                     token::Literal(token::Char(Symbol::intern(\"a\")), None));\n@@ -1966,7 +1966,7 @@ mod tests {\n     #[test]\n     fn character_space() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n                     token::Literal(token::Char(Symbol::intern(\" \")), None));\n@@ -1976,7 +1976,7 @@ mod tests {\n     #[test]\n     fn character_escaped() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n                     token::Literal(token::Char(Symbol::intern(\"\\\\n\")), None));\n@@ -1986,7 +1986,7 @@ mod tests {\n     #[test]\n     fn lifetime_name() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n                     token::Lifetime(Ident::from_str(\"'abc\")));\n@@ -1996,7 +1996,7 @@ mod tests {\n     #[test]\n     fn raw_string() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n                         .next_token()\n@@ -2008,7 +2008,7 @@ mod tests {\n     #[test]\n     fn literal_suffixes() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             macro_rules! test {\n                 ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n@@ -2054,7 +2054,7 @@ mod tests {\n     #[test]\n     fn nested_block_comments() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             let mut lexer = setup(&cm, &sh, \"/* /* */ */'a'\".to_string());\n             match lexer.next_token().tok {\n@@ -2069,7 +2069,7 @@ mod tests {\n     #[test]\n     fn crlf_comments() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n             let comment = lexer.next_token();"}, {"sha": "d43cbf38064e2a1797128b74c241cee955e2980d", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -13,7 +13,7 @@\n use rustc_data_structures::sync::{Lrc, Lock};\n use ast::{self, CrateConfig, NodeId};\n use early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n-use codemap::{CodeMap, FilePathMapping};\n+use codemap::{SourceMap, FilePathMapping};\n use syntax_pos::{Span, FileMap, FileName, MultiSpan};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n@@ -57,21 +57,21 @@ pub struct ParseSess {\n     pub non_modrs_mods: Lock<Vec<(ast::Ident, Span)>>,\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: Lock<Vec<PathBuf>>,\n-    code_map: Lrc<CodeMap>,\n+    code_map: Lrc<SourceMap>,\n     pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n }\n \n impl ParseSess {\n     pub fn new(file_path_mapping: FilePathMapping) -> Self {\n-        let cm = Lrc::new(CodeMap::new(file_path_mapping));\n+        let cm = Lrc::new(SourceMap::new(file_path_mapping));\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n                                                 true,\n                                                 false,\n                                                 Some(cm.clone()));\n         ParseSess::with_span_handler(handler, cm)\n     }\n \n-    pub fn with_span_handler(handler: Handler, code_map: Lrc<CodeMap>) -> ParseSess {\n+    pub fn with_span_handler(handler: Handler, code_map: Lrc<SourceMap>) -> ParseSess {\n         ParseSess {\n             span_diagnostic: handler,\n             unstable_features: UnstableFeatures::from_environment(),\n@@ -86,7 +86,7 @@ impl ParseSess {\n         }\n     }\n \n-    pub fn codemap(&self) -> &CodeMap {\n+    pub fn codemap(&self) -> &SourceMap {\n         &self.code_map\n     }\n "}, {"sha": "1e6c1eee4835a133c0d8771b31d666a5b16e2a33", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -42,7 +42,7 @@ use ast::{UseTree, UseTreeKind};\n use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n-use codemap::{self, CodeMap, Spanned, respan};\n+use codemap::{self, SourceMap, Spanned, respan};\n use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, edition::Edition};\n use errors::{self, Applicability, DiagnosticBuilder, DiagnosticId};\n use parse::{self, SeqSep, classify, token};\n@@ -6322,7 +6322,7 @@ impl<'a> Parser<'a> {\n         id: ast::Ident,\n         relative: Option<ast::Ident>,\n         dir_path: &Path,\n-        codemap: &CodeMap) -> ModulePath\n+        codemap: &SourceMap) -> ModulePath\n     {\n         // If we're in a foo.rs file instead of a mod.rs file,\n         // we need to look for submodules in"}, {"sha": "2646d52b739862878a6b6a71d0b67cec64dbc6e4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -16,7 +16,7 @@ use ast::{SelfKind, GenericBound, TraitBoundModifier};\n use ast::{Attribute, MacDelimiter, GenericArg};\n use util::parser::{self, AssocOp, Fixity};\n use attr;\n-use codemap::{self, CodeMap, Spanned};\n+use codemap::{self, SourceMap, Spanned};\n use syntax_pos::{self, BytePos};\n use syntax_pos::hygiene::{Mark, SyntaxContext};\n use parse::token::{self, BinOpToken, Token};\n@@ -57,7 +57,7 @@ impl PpAnn for NoAnn {}\n \n pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n-    cm: Option<&'a CodeMap>,\n+    cm: Option<&'a SourceMap>,\n     comments: Option<Vec<comments::Comment> >,\n     literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n@@ -84,7 +84,7 @@ pub const DEFAULT_COLUMNS: usize = 78;\n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments and literals to\n /// copy forward.\n-pub fn print_crate<'a>(cm: &'a CodeMap,\n+pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &ast::Crate,\n                        filename: FileName,\n@@ -118,7 +118,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n }\n \n impl<'a> State<'a> {\n-    pub fn new_from_input(cm: &'a CodeMap,\n+    pub fn new_from_input(cm: &'a SourceMap,\n                           sess: &ParseSess,\n                           filename: FileName,\n                           input: &mut dyn Read,\n@@ -138,7 +138,7 @@ impl<'a> State<'a> {\n             if is_expanded { None } else { Some(lits) })\n     }\n \n-    pub fn new(cm: &'a CodeMap,\n+    pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write+'a>,\n                ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,"}, {"sha": "633de812a87a07f19f2a0dbdbc0ce207a222bae7", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -22,7 +22,7 @@ use std::vec;\n use attr::{self, HasAttrs};\n use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n \n-use codemap::{self, CodeMap, ExpnInfo, MacroAttribute, dummy_spanned};\n+use codemap::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned};\n use errors;\n use config;\n use entry::{self, EntryPointType};"}, {"sha": "12f72a3979e0144738ee8e25384eb00585049366", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use codemap::{CodeMap, FilePathMapping};\n+use codemap::{SourceMap, FilePathMapping};\n use errors::Handler;\n use errors::emitter::EmitterWriter;\n use std::io;\n@@ -50,7 +50,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n     with_globals(|| {\n         let output = Arc::new(Mutex::new(Vec::new()));\n \n-        let code_map = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+        let code_map = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         code_map.new_filemap(Path::new(\"test.rs\").to_owned().into(), file_text.to_owned());\n \n         let primary_span = make_span(&file_text, &span_labels[0].start, &span_labels[0].end);"}, {"sha": "fec7551a208c6de9a33cea81dbf7dec17bce332d", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65547337831babea8d9052b960649309263df36/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=c65547337831babea8d9052b960649309263df36", "patch": "@@ -163,7 +163,7 @@ impl FileName {\n \n /// Spans represent a region of code, used for error reporting. Positions in spans\n /// are *absolute* positions from the beginning of the codemap, not positions\n-/// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n+/// relative to FileMaps. Methods on the SourceMap can be used to relate spans back\n /// to the original source.\n /// You must be careful if the span crosses more than one file - you will not be\n /// able to use many of the functions on spans in codemap and you cannot assume\n@@ -678,7 +678,7 @@ pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n /// Identifies an offset of a multi-byte character in a FileMap\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {\n-    /// The absolute offset of the character in the CodeMap\n+    /// The absolute offset of the character in the SourceMap\n     pub pos: BytePos,\n     /// The number of bytes, >=2\n     pub bytes: u8,\n@@ -705,7 +705,7 @@ impl NonNarrowChar {\n         }\n     }\n \n-    /// Returns the absolute offset of the character in the CodeMap\n+    /// Returns the absolute offset of the character in the SourceMap\n     pub fn pos(&self) -> BytePos {\n         match *self {\n             NonNarrowChar::ZeroWidth(p) |\n@@ -777,7 +777,7 @@ impl ExternalSource {\n     }\n }\n \n-/// A single source in the CodeMap.\n+/// A single source in the SourceMap.\n #[derive(Clone)]\n pub struct FileMap {\n     /// The name of the file that the source came from, source that doesn't\n@@ -798,9 +798,9 @@ pub struct FileMap {\n     /// The external source code (used for external crates, which will have a `None`\n     /// value as `self.src`.\n     pub external_src: Lock<ExternalSource>,\n-    /// The start position of this source in the CodeMap\n+    /// The start position of this source in the SourceMap\n     pub start_pos: BytePos,\n-    /// The end position of this source in the CodeMap\n+    /// The end position of this source in the SourceMap\n     pub end_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n     pub lines: Vec<BytePos>,\n@@ -1141,7 +1141,7 @@ pub trait Pos {\n pub struct BytePos(pub u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n-/// is not equivalent to a character offset. The CodeMap will convert BytePos\n+/// is not equivalent to a character offset. The SourceMap will convert BytePos\n /// values to CharPos values as necessary.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub struct CharPos(pub usize);"}]}