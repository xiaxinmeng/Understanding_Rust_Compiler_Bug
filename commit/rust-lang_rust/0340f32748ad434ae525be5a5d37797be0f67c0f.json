{"sha": "0340f32748ad434ae525be5a5d37797be0f67c0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNDBmMzI3NDhhZDQzNGFlNTI1YmU1YTVkMzc3OTdiZTBmNjdjMGY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-12T23:33:53Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-13T01:28:03Z"}, "message": "Eliminate autoderef on binops and unary negation.\n\nAutoderef on binops is basically unused, kind of silly, and\ncomplicates typechecking. There were only three instances of it in the\ncompiler and the test drivers, two of which were of the form \"*foo =\nfoo + 1\", which should be written as \"*foo += 1\" anyways.", "tree": {"sha": "256ccd1c268a05888577c8bbf270e9dd0e3f0f54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/256ccd1c268a05888577c8bbf270e9dd0e3f0f54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0340f32748ad434ae525be5a5d37797be0f67c0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0340f32748ad434ae525be5a5d37797be0f67c0f", "html_url": "https://github.com/rust-lang/rust/commit/0340f32748ad434ae525be5a5d37797be0f67c0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0340f32748ad434ae525be5a5d37797be0f67c0f/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5271405480f53ab1ed05da11001858c25be8558", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5271405480f53ab1ed05da11001858c25be8558", "html_url": "https://github.com/rust-lang/rust/commit/e5271405480f53ab1ed05da11001858c25be8558"}], "stats": {"total": 151, "additions": 47, "deletions": 104}, "files": [{"sha": "13bac3218bbcc1e4405f250b8370d45d73493f75", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 17, "deletions": 43, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0340f32748ad434ae525be5a5d37797be0f67c0f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0340f32748ad434ae525be5a5d37797be0f67c0f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0340f32748ad434ae525be5a5d37797be0f67c0f", "patch": "@@ -2497,15 +2497,13 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n     alt op {\n       ast::not. {\n         let sub = trans_expr(cx, e);\n-        let dr = autoderef(sub.bcx, sub.val, ty::expr_ty(bcx_tcx(cx), e));\n-        ret rslt(dr.bcx, dr.bcx.build.Not(dr.val));\n+        ret rslt(sub.bcx, sub.bcx.build.Not(sub.val));\n       }\n       ast::neg. {\n         let sub = trans_expr(cx, e);\n-        let dr = autoderef(sub.bcx, sub.val, ty::expr_ty(bcx_tcx(cx), e));\n         if ty::struct(bcx_tcx(cx), e_ty) == ty::ty_float {\n-            ret rslt(dr.bcx, dr.bcx.build.FNeg(dr.val));\n-        } else { ret rslt(dr.bcx, sub.bcx.build.Neg(dr.val)); }\n+            ret rslt(sub.bcx, sub.bcx.build.FNeg(sub.val));\n+        } else { ret rslt(sub.bcx, sub.bcx.build.Neg(sub.val)); }\n       }\n       ast::box(_) {\n         let lv = trans_lval(cx, e);\n@@ -2532,28 +2530,18 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n     }\n }\n \n-fn trans_compare(cx0: &@block_ctxt, op: ast::binop,\n-                 lhs0: ValueRef, lhs_t: ty::t, rhs0: ValueRef,\n-                rhs_t: ty::t) -> result {\n-    // Autoderef both sides.\n-\n-    let cx = cx0;\n-    let lhs_r = autoderef(cx, lhs0, lhs_t);\n-    let lhs = lhs_r.val;\n-    cx = lhs_r.bcx;\n-    let rhs_r = autoderef(cx, rhs0, rhs_t);\n-    let rhs = rhs_r.val;\n-    cx = rhs_r.bcx;\n+fn trans_compare(cx: &@block_ctxt, op: ast::binop,\n+                 lhs: ValueRef, lhs_t: ty::t, rhs: ValueRef,\n+                 rhs_t: ty::t) -> result {\n     // Determine the operation we need.\n-\n     let llop;\n     alt op {\n       ast::eq. | ast::ne. { llop = C_u8(abi::cmp_glue_op_eq); }\n       ast::lt. | ast::ge. { llop = C_u8(abi::cmp_glue_op_lt); }\n       ast::le. | ast::gt. { llop = C_u8(abi::cmp_glue_op_le); }\n     }\n \n-    let rs = compare(cx, lhs, rhs, rhs_r.ty, llop);\n+    let rs = compare(cx, lhs, rhs, rhs_t, llop);\n \n     // Invert the result if necessary.\n     alt op {\n@@ -3320,15 +3308,10 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n     alt op {\n       ast::and. {\n         // Lazy-eval and\n-        let lhs_expr = trans_expr(cx, a);\n-        let lhs_res =\n-            autoderef(lhs_expr.bcx, lhs_expr.val,\n-                      ty::expr_ty(bcx_tcx(cx), a));\n+        let lhs_res = trans_expr(cx, a);\n         let rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n-        let rhs_expr = trans_expr(rhs_cx, b);\n-        let rhs_res =\n-            autoderef(rhs_expr.bcx, rhs_expr.val,\n-                      ty::expr_ty(bcx_tcx(cx), b));\n+        let rhs_res = trans_expr(rhs_cx, b);\n+\n         let lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n         let lhs_false_res = rslt(lhs_false_cx, C_bool(false));\n \n@@ -3343,15 +3326,9 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n       }\n       ast::or. {\n         // Lazy-eval or\n-        let lhs_expr = trans_expr(cx, a);\n-        let lhs_res =\n-            autoderef(lhs_expr.bcx, lhs_expr.val,\n-                      ty::expr_ty(bcx_tcx(cx), a));\n+        let lhs_res = trans_expr(cx, a);\n         let rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n-        let rhs_expr = trans_expr(rhs_cx, b);\n-        let rhs_res =\n-            autoderef(rhs_expr.bcx, rhs_expr.val,\n-                      ty::expr_ty(bcx_tcx(cx), b));\n+        let rhs_res = trans_expr(rhs_cx, b);\n         let lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n         let lhs_true_res = rslt(lhs_true_cx, C_bool(true));\n \n@@ -3363,15 +3340,12 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n       }\n       _ {\n         // Remaining cases are eager:\n+        let lhs = trans_expr(cx, a);\n+        let rhs = trans_expr(lhs.bcx, b);\n \n-        let lhs_expr = trans_expr(cx, a);\n-        let lhty = ty::expr_ty(bcx_tcx(cx), a);\n-        let lhs = autoderef(lhs_expr.bcx, lhs_expr.val, lhty);\n-        let rhs_expr = trans_expr(lhs.bcx, b);\n-        let rhty = ty::expr_ty(bcx_tcx(cx), b);\n-        let rhs = autoderef(rhs_expr.bcx, rhs_expr.val, rhty);\n-\n-        ret trans_eager_binop(rhs.bcx, op, lhs.val, lhs.ty, rhs.val, rhs.ty);\n+        ret trans_eager_binop(rhs.bcx, op,\n+                              lhs.val, ty::expr_ty(bcx_tcx(cx), a),\n+                              rhs.val, ty::expr_ty(bcx_tcx(cx), b));\n       }\n     }\n }"}, {"sha": "7484fd92996fa772bca0aa6b6e98ca239210dd27", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 28, "deletions": 56, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0340f32748ad434ae525be5a5d37797be0f67c0f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0340f32748ad434ae525be5a5d37797be0f67c0f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0340f32748ad434ae525be5a5d37797be0f67c0f", "patch": "@@ -890,7 +890,6 @@ mod unify {\n     }\n }\n \n-tag autoderef_kind { AUTODEREF_OK; NO_AUTODEREF; AUTODEREF_BLOCK_COERCE; }\n \n // FIXME This is almost a duplicate of ty::type_autoderef, with structure_of\n // instead of ty::struct.\n@@ -929,27 +928,8 @@ fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> ty::t {\n     fail;\n }\n \n-fn add_boxes(ccx: &@crate_ctxt, n: uint, t: &ty::t) -> ty::t {\n-    let t1 = t;\n-    while n != 0u { t1 = ty::mk_imm_box(ccx.tcx, t1); n -= 1u; }\n-    ret t1;\n-}\n-\n-fn count_boxes(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> uint {\n-    let n = 0u;\n-    let t1 = t;\n-    while true {\n-        alt structure_of(fcx, sp, t1) {\n-          ty::ty_box(inner) { n += 1u; t1 = inner.ty; }\n-          _ { ret n; }\n-        }\n-    }\n-    fail;\n-}\n-\n fn do_fn_block_coerce(fcx: &@fn_ctxt, sp: &span, actual: &ty::t,\n                       expected: &ty::t) -> ty::t {\n-\n     // fns can be silently coerced to blocks when being used as\n     // function call or bind arguments, but not the reverse.\n     // If our actual type is a fn and our expected type is a block,\n@@ -986,27 +966,26 @@ type ty_param_substs_and_ty = {substs: [ty::t], ty: ty::t};\n mod demand {\n     fn simple(fcx: &@fn_ctxt, sp: &span, expected: &ty::t, actual: &ty::t) ->\n        ty::t {\n-        ret full(fcx, sp, expected, actual, ~[], NO_AUTODEREF).ty;\n+        full(fcx, sp, expected, actual, ~[], false).ty\n+    }\n+    fn block_coerce(fcx: &@fn_ctxt, sp: &span,\n+                    expected: &ty::t, actual: &ty::t) -> ty::t {\n+        full(fcx, sp, expected, actual, ~[], true).ty\n     }\n-    fn autoderef(fcx: &@fn_ctxt, sp: &span, expected: &ty::t, actual: &ty::t,\n-                 adk: autoderef_kind) -> ty::t {\n-        ret full(fcx, sp, expected, actual, ~[], adk).ty;\n+\n+    fn with_substs(fcx: &@fn_ctxt, sp: &span, expected: &ty::t,\n+                   actual: &ty::t, ty_param_substs_0: &[ty::t]) ->\n+        ty_param_substs_and_ty {\n+        full(fcx, sp, expected, actual, ty_param_substs_0, false)\n     }\n \n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n-    fn full(fcx: &@fn_ctxt, sp: &span, expected: &ty::t, actual: &ty::t,\n-            ty_param_substs_0: &[ty::t], adk: autoderef_kind) ->\n+    fn full(fcx: &@fn_ctxt, sp: &span, expected: ty::t, actual: ty::t,\n+            ty_param_substs_0: &[ty::t], do_block_coerece: bool) ->\n        ty_param_substs_and_ty {\n-        let expected_1 = expected;\n-        let actual_1 = actual;\n-        let implicit_boxes = 0u;\n-        if adk == AUTODEREF_OK {\n-            expected_1 = do_autoderef(fcx, sp, expected_1);\n-            actual_1 = do_autoderef(fcx, sp, actual_1);\n-            implicit_boxes = count_boxes(fcx, sp, actual);\n-        } else if (adk == AUTODEREF_BLOCK_COERCE) {\n-            actual_1 = do_fn_block_coerce(fcx, sp, actual, expected);\n+        if do_block_coerece {\n+            actual = do_fn_block_coerce(fcx, sp, actual, expected);\n         }\n \n         let ty_param_substs: [mutable ty::t] = ~[mutable];\n@@ -1021,33 +1000,31 @@ mod demand {\n         }\n \n         fn mk_result(fcx: &@fn_ctxt, result_ty: &ty::t,\n-                     ty_param_subst_var_ids: &[int], implicit_boxes: uint) ->\n+                     ty_param_subst_var_ids: &[int]) ->\n            ty_param_substs_and_ty {\n             let result_ty_param_substs: [ty::t] = ~[];\n             for var_id: int  in ty_param_subst_var_ids {\n                 let tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n                 result_ty_param_substs += ~[tp_subst];\n             }\n-            ret {substs: result_ty_param_substs,\n-                 ty: add_boxes(fcx.ccx, implicit_boxes, result_ty)};\n+            ret {substs: result_ty_param_substs, ty: result_ty};\n         }\n \n \n-        alt unify::unify(fcx, expected_1, actual_1) {\n+        alt unify::unify(fcx, expected, actual) {\n           ures_ok(t) {\n-            ret mk_result(fcx, t, ty_param_subst_var_ids, implicit_boxes);\n+            ret mk_result(fcx, t, ty_param_subst_var_ids);\n           }\n           ures_err(err) {\n-            let e_err = resolve_type_vars_if_possible(fcx, expected_1);\n-            let a_err = resolve_type_vars_if_possible(fcx, actual_1);\n+            let e_err = resolve_type_vars_if_possible(fcx, expected);\n+            let a_err = resolve_type_vars_if_possible(fcx, actual);\n             fcx.ccx.tcx.sess.span_err(sp,\n                                       \"mismatched types: expected \" +\n                                           ty_to_str(fcx.ccx.tcx, e_err) +\n                                           \" but found \" +\n                                           ty_to_str(fcx.ccx.tcx, a_err) + \" (\"\n                                           + ty::type_err_to_str(err) + \")\");\n-            ret mk_result(fcx, expected_1, ty_param_subst_var_ids,\n-                          implicit_boxes);\n+            ret mk_result(fcx, expected, ty_param_subst_var_ids);\n           }\n         }\n     }\n@@ -1379,8 +1356,8 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                                                            path_tpot);\n \n             let path_tpt =\n-                demand::full(fcx, pat.span, expected, ctor_ty, expected_tps,\n-                             NO_AUTODEREF);\n+                demand::with_substs(fcx, pat.span, expected, ctor_ty,\n+                                    expected_tps);\n             path_tpot =\n                 {substs: some[[ty::t]](path_tpt.substs), ty: path_tpt.ty};\n \n@@ -1604,13 +1581,11 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         }\n \n         // Check the arguments.\n-        let unifier =\n-            bind demand::autoderef(_, _, _, _, AUTODEREF_BLOCK_COERCE);\n         let i = 0u;\n         for a_opt: option::t[@ast::expr]  in args {\n             alt a_opt {\n               some(a) {\n-                bot |= check_expr_with_unifier(fcx, a, unifier,\n+                bot |= check_expr_with_unifier(fcx, a, demand::block_coerce,\n                                                arg_tys.(i).ty);\n               }\n               none. { }\n@@ -1776,12 +1751,10 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         let lhs_t = next_ty_var(fcx);\n         bot = check_expr_with(fcx, lhs, lhs_t);\n \n-        let unifier = bind demand::autoderef(_, _, _, _, AUTODEREF_OK);\n-        let rhs_bot = check_expr_with_unifier(fcx, rhs, unifier, lhs_t);\n+        let rhs_bot = check_expr_with(fcx, rhs, lhs_t);\n         if !ast::lazy_binop(binop) { bot |= rhs_bot; }\n \n-        let deref_t = do_autoderef(fcx, expr.span, lhs_t);\n-        check_binop_type_compat(fcx, expr.span, deref_t, binop);\n+        check_binop_type_compat(fcx, expr.span, lhs_t, binop);\n \n         let t =\n             alt binop {\n@@ -1791,7 +1764,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n               ast::ne. { ty::mk_bool(tcx) }\n               ast::ge. { ty::mk_bool(tcx) }\n               ast::gt. { ty::mk_bool(tcx) }\n-              _ { deref_t }\n+              _ { lhs_t }\n             };\n         write::ty_only_fixup(fcx, id, t);\n       }\n@@ -1838,8 +1811,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             }\n           }\n           ast::neg. {\n-            oper_t = structurally_resolved_type\n-                (fcx, oper.span, do_autoderef(fcx, expr.span, oper_t));\n+            oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n             if !(ty::type_is_integral(tcx, oper_t) ||\n                  ty::type_is_fp(tcx, oper_t)) {\n                 tcx.sess.span_fatal(expr.span, \"applying unary minus to \\"}, {"sha": "5729b4e190b93c5730f5fd8f1e906860c5358f13", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0340f32748ad434ae525be5a5d37797be0f67c0f/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0340f32748ad434ae525be5a5d37797be0f67c0f/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=0340f32748ad434ae525be5a5d37797be0f67c0f", "patch": "@@ -1,7 +1,4 @@\n-\n-\n-\n-// -*- rust -*-\n+// error-pattern: binary operation + cannot be applied to type\n type clam = {x: @int, y: @int};\n \n type fish = {a: @int};\n@@ -17,4 +14,4 @@ fn main() {\n     let answer: int = forty.a + two.a;\n     log answer;\n     assert (answer == 42);\n-}\n\\ No newline at end of file\n+}", "previous_filename": "src/test/run-pass/autoderef-full-lval.rs"}]}