{"sha": "028c6f1454787c068ff5117e9000a1de4fd98374", "node_id": "C_kwDOAAsO6NoAKDAyOGM2ZjE0NTQ3ODdjMDY4ZmY1MTE3ZTkwMDBhMWRlNGZkOTgzNzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-01T09:57:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-01T09:57:35Z"}, "message": "Auto merge of #92471 - matthiaskrgr:rollup-lmduxwh, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #88310 (Lock bootstrap (x.py) build directory)\n - #92097 (Implement split_at_spare_mut without Deref to a slice so that the spare slice is valid)\n - #92412 (Fix double space in pretty printed TryBlock)\n - #92420 (Fix whitespace in pretty printed PatKind::Range)\n - #92457 (Sync rustc_codegen_gcc)\n - #92460 ([rustc_builtin_macros] add indices to format_foreign::printf::Substitution::Escape)\n - #92469 (Make tidy check for magic numbers that spell things)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a748f49ea5fca0a8775ad712a130b6da4d3f824c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a748f49ea5fca0a8775ad712a130b6da4d3f824c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/028c6f1454787c068ff5117e9000a1de4fd98374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/028c6f1454787c068ff5117e9000a1de4fd98374", "html_url": "https://github.com/rust-lang/rust/commit/028c6f1454787c068ff5117e9000a1de4fd98374", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/028c6f1454787c068ff5117e9000a1de4fd98374/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad0d4190facd509a5c79dce427bb7deb2824046e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad0d4190facd509a5c79dce427bb7deb2824046e", "html_url": "https://github.com/rust-lang/rust/commit/ad0d4190facd509a5c79dce427bb7deb2824046e"}, {"sha": "4bd4e271e44a88cf57d63214716f5c33429cf2d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd4e271e44a88cf57d63214716f5c33429cf2d3", "html_url": "https://github.com/rust-lang/rust/commit/4bd4e271e44a88cf57d63214716f5c33429cf2d3"}], "stats": {"total": 627, "additions": 368, "deletions": 259}, "files": [{"sha": "b87dd449a1e57131cab019899a0f750c51b75fb0", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -2241,7 +2241,6 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::TryBlock(ref blk) => {\n                 self.head(\"try\");\n-                self.space();\n                 self.print_block_with_attrs(blk, attrs)\n             }\n             ast::ExprKind::Err => {\n@@ -2517,7 +2516,6 @@ impl<'a> State<'a> {\n             PatKind::Range(ref begin, ref end, Spanned { node: ref end_kind, .. }) => {\n                 if let Some(e) = begin {\n                     self.print_expr(e);\n-                    self.space();\n                 }\n                 match *end_kind {\n                     RangeEnd::Included(RangeSyntax::DotDotDot) => self.word(\"...\"),"}, {"sha": "ecd16736e7c302e4a518113e20d0c29604b5d718", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -7,28 +7,29 @@ pub(crate) mod printf {\n     pub enum Substitution<'a> {\n         /// A formatted output substitution with its internal byte offset.\n         Format(Format<'a>),\n-        /// A literal `%%` escape.\n-        Escape,\n+        /// A literal `%%` escape, with its start and end indices.\n+        Escape((usize, usize)),\n     }\n \n     impl<'a> Substitution<'a> {\n         pub fn as_str(&self) -> &str {\n             match *self {\n                 Substitution::Format(ref fmt) => fmt.span,\n-                Substitution::Escape => \"%%\",\n+                Substitution::Escape(_) => \"%%\",\n             }\n         }\n \n         pub fn position(&self) -> Option<InnerSpan> {\n             match *self {\n                 Substitution::Format(ref fmt) => Some(fmt.position),\n-                _ => None,\n+                Substitution::Escape((start, end)) => Some(InnerSpan::new(start, end)),\n             }\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n-            if let Substitution::Format(ref mut fmt) = self {\n-                fmt.position = InnerSpan::new(start, end);\n+            match self {\n+                Substitution::Format(ref mut fmt) => fmt.position = InnerSpan::new(start, end),\n+                Substitution::Escape(ref mut pos) => *pos = (start, end),\n             }\n         }\n \n@@ -39,7 +40,7 @@ pub(crate) mod printf {\n         pub fn translate(&self) -> Result<String, Option<String>> {\n             match *self {\n                 Substitution::Format(ref fmt) => fmt.translate(),\n-                Substitution::Escape => Err(None),\n+                Substitution::Escape(_) => Err(None),\n             }\n         }\n     }\n@@ -304,14 +305,9 @@ pub(crate) mod printf {\n         fn next(&mut self) -> Option<Self::Item> {\n             let (mut sub, tail) = parse_next_substitution(self.s)?;\n             self.s = tail;\n-            match sub {\n-                Substitution::Format(_) => {\n-                    if let Some(inner_span) = sub.position() {\n-                        sub.set_position(inner_span.start + self.pos, inner_span.end + self.pos);\n-                        self.pos += inner_span.end;\n-                    }\n-                }\n-                Substitution::Escape => self.pos += 2,\n+            if let Some(InnerSpan { start, end }) = sub.position() {\n+                sub.set_position(start + self.pos, end + self.pos);\n+                self.pos += end;\n             }\n             Some(sub)\n         }\n@@ -340,7 +336,7 @@ pub(crate) mod printf {\n         let at = {\n             let start = s.find('%')?;\n             if let '%' = s[start + 1..].chars().next()? {\n-                return Some((Substitution::Escape, &s[start + 2..]));\n+                return Some((Substitution::Escape((start, start + 2)), &s[start + 2..]));\n             }\n \n             Cur::new_at(s, start)"}, {"sha": "fc7442470ac82a85ada490cd9555bc3be920017d", "filename": "compiler/rustc_builtin_macros/src/format_foreign/printf/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -13,9 +13,9 @@ macro_rules! assert_eq_pnsat {\n fn test_escape() {\n     assert_eq!(pns(\"has no escapes\"), None);\n     assert_eq!(pns(\"has no escapes, either %\"), None);\n-    assert_eq!(pns(\"*so* has a %% escape\"), Some((S::Escape, \" escape\")));\n-    assert_eq!(pns(\"%% leading escape\"), Some((S::Escape, \" leading escape\")));\n-    assert_eq!(pns(\"trailing escape %%\"), Some((S::Escape, \"\")));\n+    assert_eq!(pns(\"*so* has a %% escape\"), Some((S::Escape((11, 13)), \" escape\")));\n+    assert_eq!(pns(\"%% leading escape\"), Some((S::Escape((0, 2)), \" leading escape\")));\n+    assert_eq!(pns(\"trailing escape %%\"), Some((S::Escape((16, 18)), \"\")));\n }\n \n #[test]"}, {"sha": "47925f72c2cbdd30b6964213f60da8da3dc26d2f", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -17,12 +17,6 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"450575f58f7bee32816abbff470cbc47797397c2a81e0eaced4b98436daf52e1\"\n \n-[[package]]\n-name = \"autocfg\"\n-version = \"1.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n-\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -35,15 +29,6 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n-[[package]]\n-name = \"crc32fast\"\n-version = \"1.2.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"81156fece84ab6a9f2afdb109ce3ae577e42b1228441eded99bd77f627953b1a\"\n-dependencies = [\n- \"cfg-if\",\n-]\n-\n [[package]]\n name = \"fm\"\n version = \"0.1.4\"\n@@ -56,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#0672b78d162d65b6f36ea4062947253affe9fdef\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#0672b78d162d65b6f36ea4062947253affe9fdef\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -85,33 +70,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"wasi\",\n ]\n \n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.11.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n-\n [[package]]\n name = \"hermit-abi\"\n version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n dependencies = [\n- \"libc 0.2.102\",\n-]\n-\n-[[package]]\n-name = \"indexmap\"\n-version = \"1.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bc633605454125dec4b66843673f01c7df2b89479b32e0ed634e43a91cff62a5\"\n-dependencies = [\n- \"autocfg\",\n- \"hashbrown\",\n+ \"libc 0.2.112\",\n ]\n \n [[package]]\n@@ -122,7 +91,7 @@ checksum = \"96bd995a092cac79868250589869b5a5d656b02a02bd74c8ebdc566dc7203090\"\n dependencies = [\n  \"fm\",\n  \"getopts\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"num_cpus\",\n  \"termcolor\",\n  \"threadpool\",\n@@ -138,9 +107,9 @@ checksum = \"e32a70cf75e5846d53a673923498228bbec6a8624708a9ea5645f075d6276122\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.102\"\n+version = \"0.2.112\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2a5ac8f984bfcf3a823267e5fde638acc3325f6496633a5da6bb6eb2171e103\"\n+checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n \n [[package]]\n name = \"memchr\"\n@@ -155,33 +124,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3\"\n dependencies = [\n  \"hermit-abi\",\n- \"libc 0.2.102\",\n-]\n-\n-[[package]]\n-name = \"object\"\n-version = \"0.25.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a38f2be3697a57b4060074ff41b44c16870d916ad7877c17696e063257482bc7\"\n-dependencies = [\n- \"crc32fast\",\n- \"indexmap\",\n- \"memchr\",\n+ \"libc 0.2.112\",\n ]\n \n [[package]]\n name = \"ppv-lite86\"\n-version = \"0.2.10\"\n+version = \"0.2.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ac74c624d6b2d21f425f752262f42188365d7b8ff1aff74c82e45136510a4857\"\n+checksum = \"ed0cfbc8191465bed66e1718596ee0b0b35d5ee1f41c5df2189d0fe8bde535ba\"\n \n [[package]]\n name = \"rand\"\n version = \"0.8.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2e7573632e6454cf6b99d7aac4ccca54be06da05aca2ef7423d22d27d4d4bcd8\"\n dependencies = [\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"rand_chacha\",\n  \"rand_core\",\n  \"rand_hc\",\n@@ -257,7 +215,6 @@ dependencies = [\n  \"ar\",\n  \"gccjit\",\n  \"lang_tester\",\n- \"object\",\n  \"target-lexicon\",\n  \"tempfile\",\n ]\n@@ -284,7 +241,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"rand\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n@@ -321,7 +278,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6\"\n dependencies = [\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n ]\n \n [[package]]"}, {"sha": "21f0bfbf69d7fac441bccb879999fbc80bd801b5", "filename": "compiler/rustc_codegen_gcc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.toml?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -23,11 +23,6 @@ target-lexicon = \"0.10.0\"\n \n ar = \"0.8.0\"\n \n-[dependencies.object]\n-version = \"0.25.0\"\n-default-features = false\n-features = [\"read\", \"std\", \"write\"] # We don't need WASM support.\n-\n [dev-dependencies]\n lang_tester = \"0.3.9\"\n tempfile = \"3.1.0\""}, {"sha": "1fcfb5f6e20a108661fce85ecbc8fa36ab5d7820", "filename": "compiler/rustc_codegen_gcc/Readme.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FReadme.md?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -111,6 +111,8 @@ Or add a breakpoint to `add_error` in gdb and print the line number using:\n p loc->m_line\n ```\n \n+To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n+\n ### How to use a custom-build rustc\n \n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`)."}, {"sha": "73e9c858caf2b6dbb51419d804152e83045a3ab8", "filename": "compiler/rustc_codegen_gcc/patches/0023-core-Ignore-failing-tests.patch", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -46,4 +46,24 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n+diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+index 3e00e0a..8e5663b 100644\n+--- a/library/core/tests/slice.rs\n++++ b/library/core/tests/slice.rs\n+@@ -2108,6 +2108,7 @@ fn test_copy_within_panics_src_out_of_bounds() {\n+     bytes.copy_within(usize::MAX..=usize::MAX, 0);\n+ }\n+ \n++/*\n+ #[test]\n+ fn test_is_sorted() {\n+     let empty: [i32; 0] = [];\n+@@ -2122,6 +2123,7 @@ fn test_is_sorted() {\n+     assert!(![\"c\", \"bb\", \"aaa\"].is_sorted());\n+     assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n+ }\n++*/\n+ \n+ #[test]\n+ fn test_slice_run_destructors() {\n -- 2.21.0 (Apple Git-122)"}, {"sha": "8954f91021f47ab9ccd2e2e3fd0b1227aecb3bc6", "filename": "compiler/rustc_codegen_gcc/patches/0024-core-Disable-portable-simd-test.patch", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -0,0 +1,24 @@\n+From b1ae000f6da1abd3b8e9b80c40bc11c89b8ae93c Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 30 Dec 2021 16:54:40 +0100\n+Subject: [PATCH] [core] Disable portable-simd test\n+\n+---\n+ library/core/tests/lib.rs | 1 -\n+ 1 file changed, 1 deletion(-)\n+\n+diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n+index ec70034..7cd9e21 100644\n+--- a/library/core/tests/lib.rs\n++++ b/library/core/tests/lib.rs\n+@@ -121,7 +121,6 @@ mod pattern;\n+ mod pin;\n+ mod ptr;\n+ mod result;\n+-mod simd;\n+ mod slice;\n+ mod str;\n+ mod str_lossy;\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "bf74a74c7c4b8dd44ede03324d707a3bd89acfa2", "filename": "compiler/rustc_codegen_gcc/patches/0028-core-Disable-long-running-tests.patch", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fpatches%2F0028-core-Disable-long-running-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fpatches%2F0028-core-Disable-long-running-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0028-core-Disable-long-running-tests.patch?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -0,0 +1,30 @@\n+From 0ffdd8eda8df364391c8ac6e1ce92c73ba9254d4 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Fri, 3 Dec 2021 12:16:30 +0100\n+Subject: [PATCH] Disable long running tests\n+\n+---\n+ library/core/tests/slice.rs | 3 +++\n+ 1 file changed, 3 insertions(+)\n+\n+diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+index 2c8f00a..44847ee 100644\n+--- a/library/core/tests/slice.rs\n++++ b/library/core/tests/slice.rs\n+@@ -2332,7 +2332,8 @@ macro_rules! empty_max_mut {\n+     };\n+ }\n+ \n++/*\n+ #[cfg(not(miri))] // Comparing usize::MAX many elements takes forever in Miri (and in rustc without optimizations)\n+ take_tests! {\n+     slice: &[(); usize::MAX], method: take,\n+     (take_in_bounds_max_range_to, (..usize::MAX), Some(EMPTY_MAX), &[(); 0]),\n+@@ -2345,3 +2347,4 @@ take_tests! {\n+     (take_mut_oob_max_range_to_inclusive, (..=usize::MAX), None, empty_max_mut!()),\n+     (take_mut_in_bounds_max_range_from, (usize::MAX..), Some(&mut [] as _), empty_max_mut!()),\n+ }\n++*/\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "ee0822f6c31457c6b4f125a765e613221d466537", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -1 +1 @@\n-nightly-2021-09-28\n+nightly-2021-12-30"}, {"sha": "453bcd601d3fe51b391b5627930c4350190d5bcc", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 51, "deletions": 60, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -18,30 +18,30 @@ use crate::type_of::LayoutGccExt;\n \n // Rust asm! and GCC Extended Asm semantics differ substantially.\n //\n-// 1. Rust asm operands go along as one list of operands. Operands themselves indicate \n-//    if they're \"in\" or \"out\". \"In\" and \"out\" operands can interleave. One operand can be \n+// 1. Rust asm operands go along as one list of operands. Operands themselves indicate\n+//    if they're \"in\" or \"out\". \"In\" and \"out\" operands can interleave. One operand can be\n //    both \"in\" and \"out\" (`inout(reg)`).\n //\n-//    GCC asm has two different lists for \"in\" and \"out\" operands. In terms of gccjit, \n-//    this means that all \"out\" operands must go before \"in\" operands. \"In\" and \"out\" operands \n+//    GCC asm has two different lists for \"in\" and \"out\" operands. In terms of gccjit,\n+//    this means that all \"out\" operands must go before \"in\" operands. \"In\" and \"out\" operands\n //    cannot interleave.\n //\n-// 2. Operand lists in both Rust and GCC are indexed. Index starts from 0. Indexes are important \n+// 2. Operand lists in both Rust and GCC are indexed. Index starts from 0. Indexes are important\n //    because the asm template refers to operands by index.\n //\n //    Mapping from Rust to GCC index would be 1-1 if it wasn't for...\n //\n-// 3. Clobbers. GCC has a separate list of clobbers, and clobbers don't have indexes. \n-//    Contrary, Rust expresses clobbers through \"out\" operands that aren't tied to \n+// 3. Clobbers. GCC has a separate list of clobbers, and clobbers don't have indexes.\n+//    Contrary, Rust expresses clobbers through \"out\" operands that aren't tied to\n //    a variable (`_`),  and such \"clobbers\" do have index.\n //\n-// 4. Furthermore, GCC Extended Asm does not support explicit register constraints \n-//    (like `out(\"eax\")`) directly, offering so-called \"local register variables\" \n-//    as a workaround. These variables need to be declared and initialized *before* \n-//    the Extended Asm block but *after* normal local variables \n+// 4. Furthermore, GCC Extended Asm does not support explicit register constraints\n+//    (like `out(\"eax\")`) directly, offering so-called \"local register variables\"\n+//    as a workaround. These variables need to be declared and initialized *before*\n+//    the Extended Asm block but *after* normal local variables\n //    (see comment in `codegen_inline_asm` for explanation).\n //\n-// With that in mind, let's see how we translate Rust syntax to GCC \n+// With that in mind, let's see how we translate Rust syntax to GCC\n // (from now on, `CC` stands for \"constraint code\"):\n //\n // * `out(reg_class) var`   -> translated to output operand: `\"=CC\"(var)`\n@@ -52,18 +52,17 @@ use crate::type_of::LayoutGccExt;\n //\n // * `out(\"explicit register\") _` -> not translated to any operands, register is simply added to clobbers list\n //\n-// * `inout(reg_class) in_var => out_var` -> translated to two operands: \n+// * `inout(reg_class) in_var => out_var` -> translated to two operands:\n //                              output: `\"=CC\"(in_var)`\n-//                              input:  `\"num\"(out_var)` where num is the GCC index \n+//                              input:  `\"num\"(out_var)` where num is the GCC index\n //                                       of the corresponding output operand\n //\n-// * `inout(reg_class) in_var => _` -> same as `inout(reg_class) in_var => tmp`, \n+// * `inout(reg_class) in_var => _` -> same as `inout(reg_class) in_var => tmp`,\n //                                      where \"tmp\" is a temporary unused variable\n //\n-// * `out/in/inout(\"explicit register\") var` -> translated to one or two operands as described above \n-//                                              with `\"r\"(var)` constraint, \n+// * `out/in/inout(\"explicit register\") var` -> translated to one or two operands as described above\n+//                                              with `\"r\"(var)` constraint,\n //                                              and one register variable assigned to the desired register.\n-// \n \n const ATT_SYNTAX_INS: &str = \".att_syntax noprefix\\n\\t\";\n const INTEL_SYNTAX_INS: &str = \"\\n\\t.intel_syntax noprefix\";\n@@ -131,7 +130,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let att_dialect = is_x86 && options.contains(InlineAsmOptions::ATT_SYNTAX);\n         let intel_dialect = is_x86 && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n-        // GCC index of an output operand equals its position in the array \n+        // GCC index of an output operand equals its position in the array\n         let mut outputs = vec![];\n \n         // GCC index of an input operand equals its position in the array\n@@ -145,9 +144,9 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let mut constants_len = 0;\n \n         // There are rules we must adhere to if we want GCC to do the right thing:\n-        // \n+        //\n         // * Every local variable that the asm block uses as an output must be declared *before*\n-        //   the asm block. \n+        //   the asm block.\n         // * There must be no instructions whatsoever between the register variables and the asm.\n         //\n         // Therefore, the backend must generate the instructions strictly in this order:\n@@ -159,7 +158,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // We also must make sure that no input operands are emitted before output operands.\n         //\n         // This is why we work in passes, first emitting local vars, then local register vars.\n-        // Also, we don't emit any asm operands immediately; we save them to \n+        // Also, we don't emit any asm operands immediately; we save them to\n         // the one of the buffers to be emitted later.\n \n         // 1. Normal variables (and saving operands to buffers).\n@@ -172,7 +171,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n                         // When `reg` is a class and not an explicit register but the out place is not specified,\n                         // we need to create an unused output variable to assign the output to. This var\n-                        // needs to be of a type that's \"compatible\" with the register class, but specific type \n+                        // needs to be of a type that's \"compatible\" with the register class, but specific type\n                         // doesn't matter.\n                         (Constraint(constraint), None) => (constraint, dummy_output_type(self.cx, reg.reg_class())),\n                         (Register(_), Some(_)) => {\n@@ -200,7 +199,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                     outputs.push(AsmOutOperand {\n-                        constraint, \n+                        constraint,\n                         rust_idx,\n                         late,\n                         readwrite: false,\n@@ -211,12 +210,12 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n                 InlineAsmOperandRef::In { reg, value } => {\n                     if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n-                        inputs.push(AsmInOperand { \n-                            constraint: Cow::Borrowed(constraint), \n-                            rust_idx, \n+                        inputs.push(AsmInOperand {\n+                            constraint: Cow::Borrowed(constraint),\n+                            rust_idx,\n                             val: value.immediate()\n                         });\n-                    } \n+                    }\n                     else {\n                         // left for the next pass\n                         continue\n@@ -226,7 +225,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     let constraint = if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n                         constraint\n-                    } \n+                    }\n                     else {\n                         // left for the next pass\n                         continue\n@@ -235,22 +234,22 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // Rustc frontend guarantees that input and output types are \"compatible\",\n                     // so we can just use input var's type for the output variable.\n                     //\n-                    // This decision is also backed by the fact that LLVM needs in and out \n-                    // values to be of *exactly the same type*, not just \"compatible\". \n+                    // This decision is also backed by the fact that LLVM needs in and out\n+                    // values to be of *exactly the same type*, not just \"compatible\".\n                     // I'm not sure if GCC is so picky too, but better safe than sorry.\n                     let ty = in_value.layout.gcc_type(self.cx, false);\n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n \n                     // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n-                    // it to one \"readwrite (+) output variable\", otherwise we translate it to two \n+                    // it to one \"readwrite (+) output variable\", otherwise we translate it to two\n                     // \"out and tied in\" vars as described above.\n                     let readwrite = out_place.is_none();\n                     outputs.push(AsmOutOperand {\n-                        constraint, \n+                        constraint,\n                         rust_idx,\n                         late,\n                         readwrite,\n-                        tmp_var, \n+                        tmp_var,\n                         out_place,\n                     });\n \n@@ -259,8 +258,8 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         let constraint = Cow::Owned(out_gcc_idx.to_string());\n \n                         inputs.push(AsmInOperand {\n-                            constraint, \n-                            rust_idx, \n+                            constraint,\n+                            rust_idx,\n                             val: in_value.immediate()\n                         });\n                     }\n@@ -287,7 +286,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n                         let out_place = if let Some(place) = place {\n                             place\n-                        } \n+                        }\n                         else {\n                             // processed in the previous pass\n                             continue\n@@ -298,7 +297,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         tmp_var.set_register_name(reg_name);\n \n                         outputs.push(AsmOutOperand {\n-                            constraint: \"r\".into(), \n+                            constraint: \"r\".into(),\n                             rust_idx,\n                             late,\n                             readwrite: false,\n@@ -318,9 +317,9 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         reg_var.set_register_name(reg_name);\n                         self.llbb().add_assignment(None, reg_var, value.immediate());\n \n-                        inputs.push(AsmInOperand { \n-                            constraint: \"r\".into(), \n-                            rust_idx, \n+                        inputs.push(AsmInOperand {\n+                            constraint: \"r\".into(),\n+                            rust_idx,\n                             val: reg_var.to_rvalue()\n                         });\n                     }\n@@ -331,31 +330,23 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 // `inout(\"explicit register\") in_var => out_var`\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n-                        let out_place = if let Some(place) = out_place {\n-                            place\n-                        } \n-                        else {\n-                            // processed in the previous pass\n-                            continue\n-                        };\n-\n                         // See explanation in the first pass.\n                         let ty = in_value.layout.gcc_type(self.cx, false);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n                         outputs.push(AsmOutOperand {\n-                            constraint: \"r\".into(), \n+                            constraint: \"r\".into(),\n                             rust_idx,\n                             late,\n                             readwrite: false,\n                             tmp_var,\n-                            out_place: Some(out_place)\n+                            out_place,\n                         });\n \n                         let constraint = Cow::Owned((outputs.len() - 1).to_string());\n-                        inputs.push(AsmInOperand { \n-                            constraint, \n+                        inputs.push(AsmInOperand {\n+                            constraint,\n                             rust_idx,\n                             val: in_value.immediate()\n                         });\n@@ -364,8 +355,8 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // processed in the previous pass\n                 }\n \n-                InlineAsmOperandRef::Const { .. } \n-                | InlineAsmOperandRef::SymFn { .. } \n+                InlineAsmOperandRef::Const { .. }\n+                | InlineAsmOperandRef::SymFn { .. }\n                 | InlineAsmOperandRef::SymStatic { .. } => {\n                     // processed in the previous pass\n                 }\n@@ -460,7 +451,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         if !intel_dialect {\n             template_str.push_str(INTEL_SYNTAX_INS);\n         }\n-        \n+\n         // 4. Generate Extended Asm block\n \n         let block = self.llbb();\n@@ -479,7 +470,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         }\n \n         if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n-            // TODO(@Commeownist): I'm not 100% sure this one clobber is sufficient \n+            // TODO(@Commeownist): I'm not 100% sure this one clobber is sufficient\n             // on all architectures. For instance, what about FP stack?\n             extended_asm.add_clobber(\"cc\");\n         }\n@@ -498,18 +489,18 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n             self.call(self.type_void(), builtin_unreachable, &[], None);\n         }\n \n-        // Write results to outputs. \n+        // Write results to outputs.\n         //\n         // We need to do this because:\n-        //  1. Turning `PlaceRef` into `RValue` is error-prone and has nasty edge cases \n+        //  1. Turning `PlaceRef` into `RValue` is error-prone and has nasty edge cases\n         //     (especially with current `rustc_backend_ssa` API).\n         //  2. Not every output operand has an `out_place`, and it's required by `add_output_operand`.\n         //\n         // Instead, we generate a temporary output variable for each output operand, and then this loop,\n         // generates `out_place = tmp_var;` assignments if out_place exists.\n         for op in &outputs {\n             if let Some(place) = op.out_place {\n-                OperandValue::Immediate(op.tmp_var.to_rvalue()).store(self, place);                \n+                OperandValue::Immediate(op.tmp_var.to_rvalue()).store(self, place);\n             }\n         }\n "}, {"sha": "334ef32f1d1d7471f7bb6b2bf0b511974cfeae9b", "filename": "compiler/rustc_codegen_gcc/src/back/write.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -1,4 +1,4 @@\n-use std::fs;\n+use std::{env, fs};\n \n use gccjit::OutputKind;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n@@ -42,17 +42,17 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &*module.name);\n-                match &*module.name {\n-                    \"std_example.7rcbfp3g-cgu.15\" => {\n-                        println!(\"Dumping reproducer {}\", module.name);\n-                        let _ = fs::create_dir(\"/tmp/reproducers\");\n-                        // FIXME(antoyo): segfault in dump_reproducer_to_file() might be caused by\n-                        // transmuting an rvalue to an lvalue.\n-                        // Segfault is actually in gcc::jit::reproducer::get_identifier_as_lvalue\n-                        context.dump_reproducer_to_file(&format!(\"/tmp/reproducers/{}.c\", module.name));\n-                        println!(\"Dumped reproducer {}\", module.name);\n-                    },\n-                    _ => (),\n+                if env::var(\"CG_GCCJIT_DUMP_MODULE_NAMES\").as_deref() == Ok(\"1\") {\n+                    println!(\"Module {}\", module.name);\n+                }\n+                if env::var(\"CG_GCCJIT_DUMP_MODULE\").as_deref() == Ok(&module.name) {\n+                    println!(\"Dumping reproducer {}\", module.name);\n+                    let _ = fs::create_dir(\"/tmp/reproducers\");\n+                    // FIXME(antoyo): segfault in dump_reproducer_to_file() might be caused by\n+                    // transmuting an rvalue to an lvalue.\n+                    // Segfault is actually in gcc::jit::reproducer::get_identifier_as_lvalue\n+                    context.dump_reproducer_to_file(&format!(\"/tmp/reproducers/{}.c\", module.name));\n+                    println!(\"Dumped reproducer {}\", module.name);\n                 }\n                 context.compile_to_file(OutputKind::ObjectFile, obj_out.to_str().expect(\"path to str\"));\n             }"}, {"sha": "8b23e96066eed1307ffd46982cfe8e0c65b06252", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -81,7 +81,10 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }\n+        // NOTE: an optimization (https://github.com/rust-lang/rustc_codegen_gcc/issues/53).\n         context.add_command_line_option(\"-fno-semantic-interposition\");\n+        // NOTE: Rust relies on LLVM not doing TBAA (https://github.com/rust-lang/unsafe-code-guidelines/issues/292).\n+        context.add_command_line_option(\"-fno-strict-aliasing\");\n         if env::var(\"CG_GCCJIT_DUMP_CODE\").as_deref() == Ok(\"1\") {\n             context.set_dump_code_on_compile(true);\n         }"}, {"sha": "ccf8123000cf83ec0fff9c58bb09d28fb31f6e71", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -200,7 +200,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     fn check_ptr_call<'b>(&mut self, _typ: &str, func_ptr: RValue<'gcc>, args: &'b [RValue<'gcc>]) -> Cow<'b, [RValue<'gcc>]> {\n         let mut all_args_match = true;\n         let mut param_types = vec![];\n-        let gcc_func = func_ptr.get_type().is_function_ptr_type().expect(\"function ptr\");\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         for (index, arg) in args.iter().enumerate().take(gcc_func.get_param_count()) {\n             let param = gcc_func.get_param_type(index);\n             if param != arg.get_type() {\n@@ -277,7 +277,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n-        let gcc_func = func_ptr.get_type().is_function_ptr_type().expect(\"function ptr\");\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let mut return_type = gcc_func.get_return_type();\n         let current_block = self.current_block.borrow().expect(\"block\");\n         let void_type = self.context.new_type::<()>();\n@@ -605,31 +605,25 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn and(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): hack by putting the result in a variable to workaround this bug:\n-        // https://gcc.gnu.org/bugzilla//show_bug.cgi?id=95498\n         if a.get_type() != b.get_type() {\n             b = self.context.new_cast(None, b, a.get_type());\n         }\n-        let res = self.current_func().new_local(None, b.get_type(), \"andResult\");\n-        self.llbb().add_assignment(None, res, a & b);\n-        res.to_rvalue()\n+        a & b\n     }\n \n-    fn or(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): hack by putting the result in a variable to workaround this bug:\n-        // https://gcc.gnu.org/bugzilla//show_bug.cgi?id=95498\n-        let res = self.current_func().new_local(None, b.get_type(), \"orResult\");\n-        self.llbb().add_assignment(None, res, a | b);\n-        res.to_rvalue()\n+    fn or(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n+        if a.get_type() != b.get_type() {\n+            b = self.context.new_cast(None, b, a.get_type());\n+        }\n+        a | b\n     }\n \n     fn xor(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a ^ b\n     }\n \n     fn neg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): use new_unary_op()?\n-        self.cx.context.new_rvalue_from_long(a.get_type(), 0) - a\n+        self.cx.context.new_unary_op(None, UnaryOp::Minus, a.get_type(), a)\n     }\n \n     fn fneg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n@@ -816,7 +810,10 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let atomic_load = self.context.get_builtin_function(&format!(\"__atomic_load_{}\", size.bytes()));\n         let ordering = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n \n-        let volatile_const_void_ptr_type = self.context.new_type::<*mut ()>().make_const().make_volatile();\n+        let volatile_const_void_ptr_type = self.context.new_type::<()>()\n+            .make_const()\n+            .make_volatile()\n+            .make_pointer();\n         let ptr = self.context.new_cast(None, ptr, volatile_const_void_ptr_type);\n         self.context.new_call(None, atomic_load, &[ptr, ordering])\n     }\n@@ -941,7 +938,9 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo): handle alignment.\n         let atomic_store = self.context.get_builtin_function(&format!(\"__atomic_store_{}\", size.bytes()));\n         let ordering = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n-        let volatile_const_void_ptr_type = self.context.new_type::<*mut ()>().make_const().make_volatile();\n+        let volatile_const_void_ptr_type = self.context.new_type::<()>()\n+            .make_volatile()\n+            .make_pointer();\n         let ptr = self.context.new_cast(None, ptr, volatile_const_void_ptr_type);\n \n         // FIXME(antoyo): fix libgccjit to allow comparing an integer type with an aligned integer type because\n@@ -981,12 +980,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         assert_eq!(idx as usize as u64, idx);\n         let value = ptr.dereference(None).to_rvalue();\n \n-        if value_type.is_array().is_some() {\n+        if value_type.dyncast_array().is_some() {\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n             let element = self.context.new_array_access(None, value, index);\n             element.get_address(None)\n         }\n-        else if let Some(vector_type) = value_type.is_vector() {\n+        else if let Some(vector_type) = value_type.dyncast_vector() {\n             let array_type = vector_type.get_element_type().make_pointer();\n             let array = self.bitcast(ptr, array_type);\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n@@ -1009,7 +1008,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn sext(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): check that it indeed sign extend the value.\n-        if dest_ty.is_vector().is_some() {\n+        if dest_ty.dyncast_vector().is_some() {\n             // TODO(antoyo): nothing to do as it is only for LLVM?\n             return value;\n         }\n@@ -1081,7 +1080,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let right_type = rhs.get_type();\n         if left_type != right_type {\n             // NOTE: because libgccjit cannot compare function pointers.\n-            if left_type.is_function_ptr_type().is_some() && right_type.is_function_ptr_type().is_some() {\n+            if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n                 lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n                 rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n             }\n@@ -1189,12 +1188,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         assert_eq!(idx as usize as u64, idx);\n         let value_type = aggregate_value.get_type();\n \n-        if value_type.is_array().is_some() {\n+        if value_type.dyncast_array().is_some() {\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n             let element = self.context.new_array_access(None, aggregate_value, index);\n             element.get_address(None)\n         }\n-        else if value_type.is_vector().is_some() {\n+        else if value_type.dyncast_vector().is_some() {\n             panic!();\n         }\n         else if let Some(pointer_type) = value_type.get_pointee() {\n@@ -1221,11 +1220,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let value_type = aggregate_value.get_type();\n \n         let lvalue =\n-            if value_type.is_array().is_some() {\n+            if value_type.dyncast_array().is_some() {\n                 let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n                 self.context.new_array_access(None, aggregate_value, index)\n             }\n-            else if value_type.is_vector().is_some() {\n+            else if value_type.dyncast_vector().is_some() {\n                 panic!();\n             }\n             else if let Some(pointer_type) = value_type.get_pointee() {"}, {"sha": "5851826147dfac9fd5cedacf1d9120f406be702b", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -1,5 +1,4 @@\n use std::convert::TryFrom;\n-use std::convert::TryInto;\n \n use gccjit::LValue;\n use gccjit::{Block, CType, RValue, Type, ToRValue};\n@@ -44,7 +43,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let string = self.context.new_string_literal(&*string);\n         let sym = self.generate_local_symbol_name(\"str\");\n         let global = self.declare_private_global(&sym, self.val_ty(string));\n-        global.global_set_initializer_value(string);\n+        global.global_set_initializer_rvalue(string);\n         global\n         // TODO(antoyo): set linkage.\n     }\n@@ -79,7 +78,7 @@ pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) ->\n         bytes.iter()\n         .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n         .collect();\n-    context.new_rvalue_from_array(None, typ, &elements)\n+    context.new_array_constructor(None, typ, &elements)\n }\n \n pub fn type_is_pointer<'gcc>(typ: Type<'gcc>) -> bool {\n@@ -120,13 +119,6 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn const_uint_big(&self, typ: Type<'gcc>, num: u128) -> RValue<'gcc> {\n-        let num64: Result<i64, _> = num.try_into();\n-        if let Ok(num) = num64 {\n-            // FIXME(antoyo): workaround for a bug where libgccjit is expecting a constant.\n-            // The operations >> 64 and | low are making the normal case a non-constant.\n-            return self.context.new_rvalue_from_long(typ, num as i64);\n-        }\n-\n         if num >> 64 != 0 {\n             // FIXME(antoyo): use a new function new_rvalue_from_unsigned_long()?\n             let low = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n@@ -193,7 +185,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo): cache the type? It's anonymous, so probably not.\n         let typ = self.type_struct(&fields, packed);\n         let struct_type = typ.is_struct().expect(\"struct type\");\n-        self.context.new_rvalue_from_struct(None, struct_type, values)\n+        self.context.new_struct_constructor(None, struct_type.as_type(), None, values)\n     }\n \n     fn const_to_opt_uint(&self, _v: RValue<'gcc>) -> Option<u64> {"}, {"sha": "ba4589bd810255be742e27f90a908bd54d4135f8", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -20,7 +20,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn const_bitcast(&self, value: RValue<'gcc>, typ: Type<'gcc>) -> RValue<'gcc> {\n         if value.get_type() == self.bool_type.make_pointer() {\n             if let Some(pointee) = typ.get_pointee() {\n-                if pointee.is_vector().is_some() {\n+                if pointee.dyncast_vector().is_some() {\n                     panic!()\n                 }\n             }\n@@ -31,9 +31,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn static_addr_of(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n-        if let Some(global_value) = self.const_globals.borrow().get(&cv) {\n-            // TODO(antoyo): upgrade alignment.\n-            return *global_value;\n+        // TODO(antoyo): implement a proper rvalue comparison in libgccjit instead of doing the\n+        // following:\n+        for (value, variable) in &*self.const_globals.borrow() {\n+            if format!(\"{:?}\", value) == format!(\"{:?}\", cv) {\n+                // TODO(antoyo): upgrade alignment.\n+                return *variable;\n+            }\n         }\n         let global_value = self.static_addr_of_mut(cv, align, kind);\n         // TODO(antoyo): set global constant.\n@@ -77,7 +81,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n             else {\n                 value\n             };\n-        global.global_set_initializer_value(value);\n+        global.global_set_initializer_rvalue(value);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n@@ -176,7 +180,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             };\n         // FIXME(antoyo): I think the name coming from generate_local_symbol_name() above cannot be used\n         // globally.\n-        global.global_set_initializer_value(cv);\n+        global.global_set_initializer_rvalue(cv);\n         // TODO(antoyo): set unnamed address.\n         global.get_address(None)\n     }\n@@ -371,7 +375,7 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         real_name.push_str(&sym);\n         let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n         // TODO(antoyo): set linkage.\n-        global2.global_set_initializer_value(global1.get_address(None));\n+        global2.global_set_initializer_rvalue(global1.get_address(None));\n         // TODO(antoyo): use global_set_initializer() when it will work.\n         global2\n     }"}, {"sha": "dfcd1b6231216cb49acc361bdb83e054a43e058d", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -1,16 +1,6 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{\n-    Block,\n-    Context,\n-    CType,\n-    Function,\n-    FunctionType,\n-    LValue,\n-    RValue,\n-    Struct,\n-    Type,\n-};\n+use gccjit::{Block, CType, Context, Function, FunctionType, LValue, RValue, Struct, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,"}, {"sha": "572ac559d09dfb89fb5842cab86c7903d900dae7", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_bitcast(None, value, typ)\n+                self.context.new_cast(None, value, typ)\n             }\n             else {\n                 value\n@@ -690,7 +690,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 },\n             };\n \n-        self.context.new_bitcast(None, result, result_type)\n+        self.context.new_cast(None, result, result_type)\n     }\n \n     fn count_leading_zeroes(&self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n@@ -741,6 +741,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let not_low = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, low);\n                 let not_low_and_not_high = not_low & not_high;\n                 let index = not_high + not_low_and_not_high;\n+                // NOTE: the following cast is necessary to avoid a GIMPLE verification failure in\n+                // gcc.\n+                // TODO(antoyo): do the correct verification in libgccjit to avoid an error at the\n+                // compilation stage.\n+                let index = self.context.new_cast(None, index, self.i32_type);\n \n                 let res = self.context.new_array_access(None, result, index);\n \n@@ -764,7 +769,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let arg =\n             if result_type.is_signed(self.cx) {\n                 let new_type = result_type.to_unsigned(self.cx);\n-                self.context.new_bitcast(None, arg, new_type)\n+                self.context.new_cast(None, arg, new_type)\n             }\n             else {\n                 arg\n@@ -816,10 +821,15 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let not_high = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, high);\n                 let not_low_and_not_high = not_low & not_high;\n                 let index = not_low + not_low_and_not_high;\n+                // NOTE: the following cast is necessary to avoid a GIMPLE verification failure in\n+                // gcc.\n+                // TODO(antoyo): do the correct verification in libgccjit to avoid an error at the\n+                // compilation stage.\n+                let index = self.context.new_cast(None, index, self.i32_type);\n \n                 let res = self.context.new_array_access(None, result, index);\n \n-                return self.context.new_bitcast(None, res, result_type);\n+                return self.context.new_cast(None, res, result_type);\n             }\n             else {\n                 unimplemented!(\"count_trailing_zeroes for {:?}\", arg_type);\n@@ -833,7 +843,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 arg\n             };\n         let res = self.context.new_call(None, count_trailing_zeroes, &[arg]);\n-        self.context.new_bitcast(None, res, result_type)\n+        self.context.new_cast(None, res, result_type)\n     }\n \n     fn int_width(&self, typ: Type<'gcc>) -> i64 {\n@@ -847,7 +857,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_bitcast(None, value, value_type)\n+                self.context.new_cast(None, value, value_type)\n             }\n             else {\n                 value\n@@ -863,7 +873,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             let low = self.context.new_cast(None, value, self.cx.ulonglong_type);\n             let low = self.context.new_call(None, popcount, &[low]);\n             let res = high + low;\n-            return self.context.new_bitcast(None, res, result_type);\n+            return self.context.new_cast(None, res, result_type);\n         }\n \n         // First step.\n@@ -888,7 +898,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u8(&self.cx) {\n-            return self.context.new_bitcast(None, value, result_type);\n+            return self.context.new_cast(None, value, result_type);\n         }\n \n         // Fourth step.\n@@ -899,7 +909,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u16(&self.cx) {\n-            return self.context.new_bitcast(None, value, result_type);\n+            return self.context.new_cast(None, value, result_type);\n         }\n \n         // Fifth step.\n@@ -910,7 +920,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u32(&self.cx) {\n-            return self.context.new_bitcast(None, value, result_type);\n+            return self.context.new_cast(None, value, result_type);\n         }\n \n         // Sixth step.\n@@ -920,7 +930,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let right = shifted & mask;\n         let value = left + right;\n \n-        self.context.new_bitcast(None, value, result_type)\n+        self.context.new_cast(None, value, result_type)\n     }\n \n     // Algorithm from: https://blog.regehr.org/archives/1063"}, {"sha": "20347f187868eb6a63d233e756e58548149f4422", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -20,7 +20,6 @@ extern crate rustc_metadata;\n extern crate rustc_middle;\n extern crate rustc_session;\n extern crate rustc_span;\n-extern crate rustc_symbol_mangling;\n extern crate rustc_target;\n \n // This prevents duplicating functions and statics that are already part of the host rustc process.\n@@ -91,8 +90,6 @@ impl CodegenBackend for GccCodegenBackend {\n         let target_cpu = target_cpu(tcx.sess);\n         let res = codegen_crate(self.clone(), tcx, target_cpu.to_string(), metadata, need_metadata_module);\n \n-        rustc_symbol_mangling::test::report_symbol_names(tcx);\n-\n         Box::new(res)\n     }\n "}, {"sha": "28e2adc492bbeb49f86be0c3037610c3d0fd53a2", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -122,7 +122,7 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         if typ.is_integral() {\n             TypeKind::Integer\n         }\n-        else if typ.is_vector().is_some() {\n+        else if typ.dyncast_vector().is_some() {\n             TypeKind::Vector\n         }\n         else {\n@@ -141,10 +141,10 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn element_type(&self, ty: Type<'gcc>) -> Type<'gcc> {\n-        if let Some(typ) = ty.is_array() {\n+        if let Some(typ) = ty.dyncast_array() {\n             typ\n         }\n-        else if let Some(vector_type) = ty.is_vector() {\n+        else if let Some(vector_type) = ty.dyncast_vector() {\n             vector_type.get_element_type()\n         }\n         else if let Some(typ) = ty.get_pointee() {"}, {"sha": "46abbb553bf2f6e257d61bc39e399161a5654553", "filename": "compiler/rustc_codegen_gcc/tests/run/asm.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -3,6 +3,10 @@\n // Run-time:\n //   status: 0\n \n+#![feature(asm_const, asm_sym)]\n+\n+use std::arch::{asm, global_asm};\n+\n global_asm!(\"\n     .global add_asm\n add_asm:\n@@ -15,6 +19,16 @@ extern \"C\" {\n     fn add_asm(a: i64, b: i64) -> i64;\n }\n \n+pub unsafe fn mem_cpy(dst: *mut u8, src: *const u8, len: usize) {\n+    asm!(\n+        \"rep movsb\",\n+        inout(\"rdi\") dst => _,\n+        inout(\"rsi\") src => _,\n+        inout(\"rcx\") len => _,\n+        options(preserves_flags, nostack)\n+    );\n+}\n+\n fn main() {\n     unsafe {\n         asm!(\"nop\");\n@@ -60,11 +74,11 @@ fn main() {\n     }\n     assert_eq!(x, 43);\n \n-    // check inout(reg_class) x \n+    // check inout(reg_class) x\n     let mut x: u64 = 42;\n     unsafe {\n         asm!(\"add {0}, {0}\",\n-            inout(reg) x \n+            inout(reg) x\n         );\n     }\n     assert_eq!(x, 84);\n@@ -73,7 +87,7 @@ fn main() {\n     let mut x: u64 = 42;\n     unsafe {\n         asm!(\"add r11, r11\",\n-            inout(\"r11\") x \n+            inout(\"r11\") x\n         );\n     }\n     assert_eq!(x, 84);\n@@ -96,12 +110,12 @@ fn main() {\n     assert_eq!(res, 7);\n     assert_eq!(rem, 2);\n \n-    // check const \n+    // check const\n     let mut x: u64 = 42;\n     unsafe {\n         asm!(\"add {}, {}\",\n             inout(reg) x,\n-            const 1 \n+            const 1\n         );\n     }\n     assert_eq!(x, 43);\n@@ -148,4 +162,11 @@ fn main() {\n     assert_eq!(x, 42);\n \n     assert_eq!(unsafe { add_asm(40, 2) }, 42);\n+\n+    let array1 = [1u8, 2, 3];\n+    let mut array2 = [0u8, 0, 0];\n+    unsafe {\n+        mem_cpy(array2.as_mut_ptr(), array1.as_ptr(), 3);\n+    }\n+    assert_eq!(array1, array2);\n }"}, {"sha": "fb11aaf24c4b8d15804de10ab819e2036a29ef29", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -1948,7 +1948,6 @@ impl<'a> State<'a> {\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n                 if let Some(expr) = begin {\n                     self.print_expr(expr);\n-                    self.space();\n                 }\n                 match *end_kind {\n                     RangeEnd::Included => self.word(\"...\"),"}, {"sha": "fffdc2c3ac09d234e25defd6d2da3dd3842dd26c", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -2141,12 +2141,17 @@ impl<T, A: Allocator> Vec<T, A> {\n     unsafe fn split_at_spare_mut_with_len(\n         &mut self,\n     ) -> (&mut [T], &mut [MaybeUninit<T>], &mut usize) {\n-        let Range { start: ptr, end: spare_ptr } = self.as_mut_ptr_range();\n+        let ptr = self.as_mut_ptr();\n+        // SAFETY:\n+        // - `ptr` is guaranteed to be valid for `self.len` elements\n+        // - but the allocation extends out to `self.buf.capacity()` elements, possibly\n+        // uninitialized\n+        let spare_ptr = unsafe { ptr.add(self.len) };\n         let spare_ptr = spare_ptr.cast::<MaybeUninit<T>>();\n         let spare_len = self.buf.capacity() - self.len;\n \n         // SAFETY:\n-        // - `ptr` is guaranteed to be valid for `len` elements\n+        // - `ptr` is guaranteed to be valid for `self.len` elements\n         // - `spare_ptr` is pointing one element past the buffer, so it doesn't overlap with `initialized`\n         unsafe {\n             let initialized = slice::from_raw_parts_mut(ptr, self.len);"}, {"sha": "70a7d7a8cabc14e73e0634a75bd71517083dbae5", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -1140,8 +1140,8 @@ impl From<Ipv4Addr> for u32 {\n     /// ```\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// let addr = Ipv4Addr::new(0xca, 0xfe, 0xba, 0xbe);\n-    /// assert_eq!(0xcafebabe, u32::from(addr));\n+    /// let addr = Ipv4Addr::new(0x12, 0x34, 0x56, 0x78);\n+    /// assert_eq!(0x12345678, u32::from(addr));\n     /// ```\n     #[inline]\n     fn from(ip: Ipv4Addr) -> u32 {\n@@ -1159,8 +1159,8 @@ impl From<u32> for Ipv4Addr {\n     /// ```\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// let addr = Ipv4Addr::from(0xcafebabe);\n-    /// assert_eq!(Ipv4Addr::new(0xca, 0xfe, 0xba, 0xbe), addr);\n+    /// let addr = Ipv4Addr::from(0x12345678);\n+    /// assert_eq!(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78), addr);\n     /// ```\n     #[inline]\n     fn from(ip: u32) -> Ipv4Addr {"}, {"sha": "5a33073e6b022a7159e8109ac74d76e1cdf6ac62", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -15,6 +15,42 @@\n \n from time import time\n \n+# Acquire a lock on the build directory to make sure that\n+# we don't cause a race condition while building\n+# Lock is created in `build_dir/lock.db`\n+def acquire_lock(build_dir):\n+    try:\n+        import sqlite3\n+\n+        path = os.path.join(build_dir, \"lock.db\")\n+        try:\n+            con = sqlite3.Connection(path, timeout=0)\n+            curs = con.cursor()\n+            curs.execute(\"BEGIN EXCLUSIVE\")\n+            # The lock is released when the cursor is dropped\n+            return curs\n+        # If the database is busy then lock has already been acquired\n+        # so we wait for the lock.\n+        # We retry every quarter second so that execution is passed back to python\n+        # so that it can handle signals\n+        except sqlite3.OperationalError:\n+            del con\n+            del curs\n+            print(\"Waiting for lock on build directory\")\n+            con = sqlite3.Connection(path, timeout=0.25)\n+            curs = con.cursor()\n+            while True:\n+                try:\n+                    curs.execute(\"BEGIN EXCLUSIVE\")\n+                except sqlite3.OperationalError:\n+                    pass\n+            return curs\n+    except ImportError:\n+        print(\"warning: sqlite3 not available in python, skipping build directory lock\")\n+        print(\"please file an issue on rust-lang/rust\")\n+        print(\"this is not a problem for non-concurrent x.py invocations\")\n+        return None\n+\n def support_xz():\n     try:\n         with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n@@ -1228,6 +1264,12 @@ def bootstrap(help_triggered):\n     build.set_dist_environment(data[\"dist_server\"])\n \n     build.build = args.build or build.build_triple()\n+\n+    # Acquire the lock before doing any build actions\n+    # The lock is released when `lock` is dropped\n+    if not os.path.exists(build.build_dir):\n+        os.makedirs(build.build_dir)\n+    lock = acquire_lock(build.build_dir)\n     build.update_submodules()\n \n     # Fetch/build the bootstrap"}, {"sha": "93b73c57e9b4d364099996f648f651f9eb81a211", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-ref-ambiguous-interp.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.stderr?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -2,7 +2,7 @@ error: the range pattern here has ambiguous interpretation\n   --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:8:10\n    |\n LL |         &0.. | _ => {}\n-   |          ^^^ help: add parentheses to clarify the precedence: `(0 ..)`\n+   |          ^^^ help: add parentheses to clarify the precedence: `(0..)`\n \n error[E0586]: inclusive range with no end\n   --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:10:11\n@@ -16,7 +16,7 @@ error: the range pattern here has ambiguous interpretation\n   --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:10:10\n    |\n LL |         &0..= | _ => {}\n-   |          ^^^^ help: add parentheses to clarify the precedence: `(0 ..=)`\n+   |          ^^^^ help: add parentheses to clarify the precedence: `(0..=)`\n \n error[E0586]: inclusive range with no end\n   --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:13:11"}, {"sha": "48efb07ff48bc34082edc923eb4db364aa94f0c4", "filename": "src/test/ui/link-section.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Flink-section.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Flink-section.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flink-section.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -31,7 +31,7 @@ static mut frobulator: usize = 0xdeadbeef;\n \n pub fn main() {\n     unsafe {\n-        frobulator = 0xcafebabe;\n+        frobulator = 0x12345678;\n         println!(\"{} {} {}\", i_live_in_more_text(), magic, frobulator);\n     }\n }"}, {"sha": "f1daaeb743e83ec8e93b83e489d2f0da426d3d97", "filename": "src/test/ui/macros/issue-92267.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fmacros%2Fissue-92267.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fmacros%2Fissue-92267.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-92267.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -0,0 +1,3 @@\n+// check-fail\n+\n+pub fn main() { println!(\"\ud83e\udd80%%%\", 0) } //~ ERROR argument never used"}, {"sha": "d2d66c81198ec71d429632c4ebb0d3e690cf7f86", "filename": "src/test/ui/macros/issue-92267.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fmacros%2Fissue-92267.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fmacros%2Fissue-92267.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-92267.stderr?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -0,0 +1,16 @@\n+error: argument never used\n+  --> $DIR/issue-92267.rs:3:34\n+   |\n+LL | pub fn main() { println!(\"\ud83e\udd80%%%\", 0) }\n+   |                                   ^ argument never used\n+   |\n+note: format specifiers use curly braces, and the conversion specifier `\n+      ` is unknown or unsupported\n+  --> $DIR/issue-92267.rs:3:30\n+   |\n+LL | pub fn main() { println!(\"\ud83e\udd80%%%\", 0) }\n+   |                               ^^\n+   = note: printf formatting not supported; see the documentation for `std::fmt`\n+\n+error: aborting due to previous error\n+"}, {"sha": "343a26c14a9b0034ce617331362db35d7c38d5ed", "filename": "src/test/ui/macros/stringify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -256,7 +256,7 @@ fn test_expr() {\n     assert_eq!(stringify_expr!(expr.await), \"expr.await\");\n \n     // ExprKind::TryBlock\n-    assert_eq!(stringify_expr!(try {}), \"try  {}\"); // FIXME\n+    assert_eq!(stringify_expr!(try {}), \"try {}\");\n \n     // ExprKind::Assign\n     assert_eq!(stringify_expr!(expr = true), \"expr = true\");\n@@ -712,10 +712,10 @@ fn test_pat() {\n \n     // PatKind::Range\n     assert_eq!(stringify_pat!(..1), \"..1\");\n-    assert_eq!(stringify_pat!(0..), \"0 ..\"); // FIXME\n-    assert_eq!(stringify_pat!(0..1), \"0 ..1\");\n-    assert_eq!(stringify_pat!(0..=1), \"0 ..=1\");\n-    assert_eq!(stringify_pat!(-2..=-1), \"-2 ..=-1\");\n+    assert_eq!(stringify_pat!(0..), \"0..\");\n+    assert_eq!(stringify_pat!(0..1), \"0..1\");\n+    assert_eq!(stringify_pat!(0..=1), \"0..=1\");\n+    assert_eq!(stringify_pat!(-2..=-1), \"-2..=-1\");\n \n     // PatKind::Slice\n     assert_eq!(stringify_pat!([]), \"[]\");"}, {"sha": "a6d27aab4f6af0269d477a1497ccac643cefc38d", "filename": "src/test/ui/parser/intersection-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -34,7 +34,7 @@ fn main() {\n         //~| pattern on the left, should be on the right\n         //~| binding on the right, should be on the left\n         //~| HELP switch the order\n-        //~| SUGGESTION e @ 1 ..=5\n+        //~| SUGGESTION e @ 1..=5\n         _ => {}\n     }\n }"}, {"sha": "9dc4c469a60720258ee9eebab4c6284716f946e3", "filename": "src/test/ui/parser/intersection-patterns.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.stderr?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -27,7 +27,7 @@ LL |         1 ..= 5 @ e => {}\n    |         |         |\n    |         |         binding on the right, should be on the left\n    |         pattern on the left, should be on the right\n-   |         help: switch the order: `e @ 1 ..=5`\n+   |         help: switch the order: `e @ 1..=5`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "38104bab7c8ee77762f1a309412e360dc9f3ea6a", "filename": "src/test/ui/range/range-inclusive-pattern-precedence.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence.fixed?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -12,7 +12,7 @@ pub fn main() {\n         //~^ WARN `...` range patterns are deprecated\n         //~| WARN this is accepted in the current edition\n         //~| HELP use `..=` for an inclusive range\n-        &(10 ..=15) => {}\n+        &(10..=15) => {}\n         //~^ ERROR the range pattern here has ambiguous interpretation\n         //~| HELP add parentheses to clarify the precedence\n         &(16..=20) => {}"}, {"sha": "10513374cf8087f8e2ec0b656f734fe45feeacd9", "filename": "src/test/ui/range/range-inclusive-pattern-precedence.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence.stderr?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -2,7 +2,7 @@ error: the range pattern here has ambiguous interpretation\n   --> $DIR/range-inclusive-pattern-precedence.rs:15:10\n    |\n LL |         &10..=15 => {}\n-   |          ^^^^^^^ help: add parentheses to clarify the precedence: `(10 ..=15)`\n+   |          ^^^^^^^ help: add parentheses to clarify the precedence: `(10..=15)`\n \n warning: `...` range patterns are deprecated\n   --> $DIR/range-inclusive-pattern-precedence.rs:11:9"}, {"sha": "cdec41d7f75d57a99d09d7d808f61a5b1d22f9b6", "filename": "src/test/ui/range/range-inclusive-pattern-precedence2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence2.stderr?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -2,7 +2,7 @@ error: the range pattern here has ambiguous interpretation\n   --> $DIR/range-inclusive-pattern-precedence2.rs:14:13\n    |\n LL |         box 10..=15 => {}\n-   |             ^^^^^^^ help: add parentheses to clarify the precedence: `(10 ..=15)`\n+   |             ^^^^^^^ help: add parentheses to clarify the precedence: `(10..=15)`\n \n warning: `...` range patterns are deprecated\n   --> $DIR/range-inclusive-pattern-precedence2.rs:10:14"}, {"sha": "b745b988631693bcb54a88dce0959e1456cd8537", "filename": "src/test/ui/unpretty-expr-fn-arg.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Funpretty-expr-fn-arg.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftest%2Fui%2Funpretty-expr-fn-arg.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funpretty-expr-fn-arg.stdout?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -14,4 +14,4 @@ extern crate std;\n \n fn main() ({ } as ())\n \n-fn foo((-(128 as i8) as i8) ...(127 as i8): i8) ({ } as ())\n+fn foo((-(128 as i8) as i8)...(127 as i8): i8) ({ } as ())"}, {"sha": "e726b652ef1ed7a18ba4b950137770e271ab57f7", "filename": "src/tools/clippy/tests/ui/unreadable_literal.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.fixed?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -30,7 +30,7 @@ fn main() {\n         1_234.123_f32,\n         1.123_4_f32,\n     );\n-    let _bad = (0b11_0110_i64, 0xcafe_babe_usize, 123_456_f32, 1.234_567_f32);\n+    let _bad = (0b11_0110_i64, 0x1234_5678_usize, 123_456_f32, 1.234_567_f32);\n     let _good_sci = 1.1234e1;\n     let _bad_sci = 1.123_456e1;\n "}, {"sha": "5bbb2fc9dc137c28339316a5d5c7dc3a85792d64", "filename": "src/tools/clippy/tests/ui/unreadable_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -30,7 +30,7 @@ fn main() {\n         1_234.123_f32,\n         1.123_4_f32,\n     );\n-    let _bad = (0b110110_i64, 0xcafebabe_usize, 123456_f32, 1.234567_f32);\n+    let _bad = (0b110110_i64, 0x12345678_usize, 123456_f32, 1.234567_f32);\n     let _good_sci = 1.1234e1;\n     let _bad_sci = 1.123456e1;\n "}, {"sha": "ee5466fd517fd6e00dd79b2cd4324f1df819a8c3", "filename": "src/tools/clippy/tests/ui/unreadable_literal.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funreadable_literal.stderr?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -9,27 +9,27 @@ LL |         0x1_234_567,\n error: long literal lacking separators\n   --> $DIR/unreadable_literal.rs:33:17\n    |\n-LL |     let _bad = (0b110110_i64, 0xcafebabe_usize, 123456_f32, 1.234567_f32);\n+LL |     let _bad = (0b110110_i64, 0x12345678_usize, 123456_f32, 1.234567_f32);\n    |                 ^^^^^^^^^^^^ help: consider: `0b11_0110_i64`\n    |\n    = note: `-D clippy::unreadable-literal` implied by `-D warnings`\n \n error: long literal lacking separators\n   --> $DIR/unreadable_literal.rs:33:31\n    |\n-LL |     let _bad = (0b110110_i64, 0xcafebabe_usize, 123456_f32, 1.234567_f32);\n-   |                               ^^^^^^^^^^^^^^^^ help: consider: `0xcafe_babe_usize`\n+LL |     let _bad = (0b110110_i64, 0x12345678_usize, 123456_f32, 1.234567_f32);\n+   |                               ^^^^^^^^^^^^^^^^ help: consider: `0x1234_5678_usize`\n \n error: long literal lacking separators\n   --> $DIR/unreadable_literal.rs:33:49\n    |\n-LL |     let _bad = (0b110110_i64, 0xcafebabe_usize, 123456_f32, 1.234567_f32);\n+LL |     let _bad = (0b110110_i64, 0x12345678_usize, 123456_f32, 1.234567_f32);\n    |                                                 ^^^^^^^^^^ help: consider: `123_456_f32`\n \n error: long literal lacking separators\n   --> $DIR/unreadable_literal.rs:33:61\n    |\n-LL |     let _bad = (0b110110_i64, 0xcafebabe_usize, 123456_f32, 1.234567_f32);\n+LL |     let _bad = (0b110110_i64, 0x12345678_usize, 123456_f32, 1.234567_f32);\n    |                                                             ^^^^^^^^^^^^ help: consider: `1.234_567_f32`\n \n error: long literal lacking separators"}, {"sha": "ca79c835b9fa11db5edc962eb0268a471cec6d4c", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028c6f1454787c068ff5117e9000a1de4fd98374/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=028c6f1454787c068ff5117e9000a1de4fd98374", "patch": "@@ -56,6 +56,12 @@ const ANNOTATIONS_TO_IGNORE: &[&str] = &[\n     \"// normalize-stderr-test\",\n ];\n \n+// Intentionally written in decimal rather than hex\n+const PROBLEMATIC_CONSTS: &[u32] = &[\n+    184594741, 2880289470, 2881141438, 2965027518, 2976579765, 3203381950, 3405691582, 3405697037,\n+    3735927486, 4027431614, 4276992702,\n+];\n+\n /// Parser states for `line_is_url`.\n #[derive(Clone, Copy, PartialEq)]\n #[allow(non_camel_case_types)]\n@@ -217,6 +223,10 @@ pub fn check(path: &Path, bad: &mut bool) {\n     fn skip(path: &Path) -> bool {\n         super::filter_dirs(path) || skip_markdown_path(path)\n     }\n+    let problematic_consts_strings: Vec<String> = (PROBLEMATIC_CONSTS.iter().map(u32::to_string))\n+        .chain(PROBLEMATIC_CONSTS.iter().map(|v| format!(\"{:x}\", v)))\n+        .chain(PROBLEMATIC_CONSTS.iter().map(|v| format!(\"{:X}\", v)))\n+        .collect();\n     super::walk(path, &mut skip, &mut |entry, contents| {\n         let file = entry.path();\n         let filename = file.file_name().unwrap().to_string_lossy();\n@@ -306,6 +316,11 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 if line.contains(\"//\") && line.contains(\" XXX\") {\n                     err(\"XXX is deprecated; use FIXME\")\n                 }\n+                for s in problematic_consts_strings.iter() {\n+                    if line.contains(s) {\n+                        err(\"Don't use magic numbers that spell things (consider 0x12345678)\");\n+                    }\n+                }\n             }\n             let is_test = || file.components().any(|c| c.as_os_str() == \"tests\");\n             // for now we just check libcore"}]}