{"sha": "7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "node_id": "C_kwDOAAsO6NoAKDcwODNmOGVkZmQyNGIxYzdmMmM2Mzc1YmFkZDVjYzE2MzU5Yzg0ZmU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-11T15:02:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-11T15:02:46Z"}, "message": "Rollup merge of #91640 - cjgillot:in-band-collect, r=oli-obk\n\nSimplify collection of in-band lifetimes\n\nSplit from https://github.com/rust-lang/rust/pull/91403\n\nr? ````@oli-obk````", "tree": {"sha": "91680d5c9a58bff8c246b8b1040b80592b9b70be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91680d5c9a58bff8c246b8b1040b80592b9b70be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhtL2WCRBK7hj4Ov3rIwAAY1wIAJPlZxmPUn6G6GOQie1CANdN\noOEyoAvJiNLRy+jObS4OprHUAB9ahSfdKqMJmXOr5wb/rxO4+3lO5ALaFeD7z9/4\nftMD/cR8hkGxhkaxpkteAVnCZIpEI6osI9iFd6Gghgsf5byR3pZLHyjGz85M5eTi\nyhtn6zi+XnlB70Y9jPJSrjQr+SWKU/nhT+KbfJOEVrBrJ2wMMNsUYT0gGUaUdzPE\nX8hEk01Qi53WX0NW7pkHsXD8UWxBEbDlqt1+SrXyUGUORF/5FbTLLrMQ29WoAmIP\n5LaKrIq18Aj3NgJGUftzTihDXY2UO2LOG5xpc+VEOF8Ww47OX54XtaWl9blth6Q=\n=2Dpa\n-----END PGP SIGNATURE-----\n", "payload": "tree 91680d5c9a58bff8c246b8b1040b80592b9b70be\nparent 1de7815ebb9a001a07625b4bff7518b057b1ac22\nparent 54ff72132c860726f40e0ff6d547b039de0a1323\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639234966 +0100\ncommitter GitHub <noreply@github.com> 1639234966 +0100\n\nRollup merge of #91640 - cjgillot:in-band-collect, r=oli-obk\n\nSimplify collection of in-band lifetimes\n\nSplit from https://github.com/rust-lang/rust/pull/91403\n\nr? ````@oli-obk````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "html_url": "https://github.com/rust-lang/rust/commit/7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1de7815ebb9a001a07625b4bff7518b057b1ac22", "url": "https://api.github.com/repos/rust-lang/rust/commits/1de7815ebb9a001a07625b4bff7518b057b1ac22", "html_url": "https://github.com/rust-lang/rust/commit/1de7815ebb9a001a07625b4bff7518b057b1ac22"}, {"sha": "54ff72132c860726f40e0ff6d547b039de0a1323", "url": "https://api.github.com/repos/rust-lang/rust/commits/54ff72132c860726f40e0ff6d547b039de0a1323", "html_url": "https://github.com/rust-lang/rust/commit/54ff72132c860726f40e0ff6d547b039de0a1323"}], "stats": {"total": 410, "additions": 211, "deletions": 199}, "files": [{"sha": "ca7a64e254e14795cee5daa01c8a05b84a4e5b12", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -247,12 +247,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         AnonymousLifetimeMode::PassThrough,\n                         |this, idty| {\n                             let ret_id = asyncness.opt_return_id();\n-                            this.lower_fn_decl(\n-                                &decl,\n-                                Some((fn_def_id.to_def_id(), idty)),\n-                                true,\n-                                ret_id,\n-                            )\n+                            this.lower_fn_decl(&decl, Some((fn_def_id, idty)), true, ret_id)\n                         },\n                     );\n                     let sig = hir::FnSig {\n@@ -1264,7 +1259,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             |this, idty| {\n                 this.lower_fn_decl(\n                     &sig.decl,\n-                    Some((fn_def_id.to_def_id(), idty)),\n+                    Some((fn_def_id, idty)),\n                     impl_trait_return_allow,\n                     is_async,\n                 )"}, {"sha": "c04b0471cb72fe62ac3239d82ffde547d9227c02", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 87, "deletions": 105, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -228,7 +228,7 @@ enum ImplTraitContext<'b, 'a> {\n     ReturnPositionOpaqueTy {\n         /// `DefId` for the parent function, used to look up necessary\n         /// information later.\n-        fn_def_id: DefId,\n+        fn_def_id: LocalDefId,\n         /// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,\n         origin: hir::OpaqueTyOrigin,\n     },\n@@ -646,31 +646,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T>(\n         &mut self,\n-        parent_def_id: LocalDefId,\n-        anonymous_lifetime_mode: AnonymousLifetimeMode,\n-        f: impl FnOnce(&mut Self) -> (Vec<hir::GenericParam<'hir>>, T),\n-    ) -> (Vec<hir::GenericParam<'hir>>, T) {\n-        assert!(!self.is_collecting_in_band_lifetimes);\n-        assert!(self.lifetimes_to_define.is_empty());\n-        let old_anonymous_lifetime_mode = self.anonymous_lifetime_mode;\n-\n-        self.anonymous_lifetime_mode = anonymous_lifetime_mode;\n-        self.is_collecting_in_band_lifetimes = true;\n-\n-        let (in_band_ty_params, res) = f(self);\n-\n-        self.is_collecting_in_band_lifetimes = false;\n-        self.anonymous_lifetime_mode = old_anonymous_lifetime_mode;\n-\n-        let lifetimes_to_define = self.lifetimes_to_define.split_off(0);\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> (Vec<(Span, ParamName)>, T) {\n+        let was_collecting = std::mem::replace(&mut self.is_collecting_in_band_lifetimes, true);\n+        let len = self.lifetimes_to_define.len();\n \n-        let params = lifetimes_to_define\n-            .into_iter()\n-            .map(|(span, hir_name)| self.lifetime_to_generic_param(span, hir_name, parent_def_id))\n-            .chain(in_band_ty_params.into_iter())\n-            .collect();\n+        let res = f(self);\n \n-        (params, res)\n+        let lifetimes_to_define = self.lifetimes_to_define.split_off(len);\n+        self.is_collecting_in_band_lifetimes = was_collecting;\n+        (lifetimes_to_define, res)\n     }\n \n     /// Converts a lifetime into a new generic parameter.\n@@ -785,27 +770,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     ) -> (hir::Generics<'hir>, T) {\n-        let (in_band_defs, (mut lowered_generics, res)) =\n-            self.with_in_scope_lifetime_defs(&generics.params, |this| {\n-                this.collect_in_band_defs(parent_def_id, anonymous_lifetime_mode, |this| {\n-                    let mut params = Vec::new();\n-                    // Note: it is necessary to lower generics *before* calling `f`.\n-                    // When lowering `async fn`, there's a final step when lowering\n-                    // the return type that assumes that all in-scope lifetimes have\n-                    // already been added to either `in_scope_lifetimes` or\n-                    // `lifetimes_to_define`. If we swapped the order of these two,\n-                    // in-band-lifetimes introduced by generics or where-clauses\n-                    // wouldn't have been added yet.\n-                    let generics = this.lower_generics_mut(\n-                        generics,\n-                        ImplTraitContext::Universal(&mut params, this.current_hir_id_owner),\n-                    );\n-                    let res = f(this, &mut params);\n-                    (params, (generics, res))\n+        let (lifetimes_to_define, (mut lowered_generics, impl_trait_defs, res)) = self\n+            .collect_in_band_defs(|this| {\n+                this.with_anonymous_lifetime_mode(anonymous_lifetime_mode, |this| {\n+                    this.with_in_scope_lifetime_defs(&generics.params, |this| {\n+                        let mut impl_trait_defs = Vec::new();\n+                        // Note: it is necessary to lower generics *before* calling `f`.\n+                        // When lowering `async fn`, there's a final step when lowering\n+                        // the return type that assumes that all in-scope lifetimes have\n+                        // already been added to either `in_scope_lifetimes` or\n+                        // `lifetimes_to_define`. If we swapped the order of these two,\n+                        // in-band-lifetimes introduced by generics or where-clauses\n+                        // wouldn't have been added yet.\n+                        let generics = this.lower_generics_mut(\n+                            generics,\n+                            ImplTraitContext::Universal(\n+                                &mut impl_trait_defs,\n+                                this.current_hir_id_owner,\n+                            ),\n+                        );\n+                        let res = f(this, &mut impl_trait_defs);\n+                        (generics, impl_trait_defs, res)\n+                    })\n                 })\n             });\n \n-        lowered_generics.params.extend(in_band_defs);\n+        lowered_generics.params.extend(\n+            lifetimes_to_define\n+                .into_iter()\n+                .map(|(span, hir_name)| {\n+                    self.lifetime_to_generic_param(span, hir_name, parent_def_id)\n+                })\n+                .chain(impl_trait_defs),\n+        );\n \n         let lowered_generics = lowered_generics.into_generics(self.arena);\n         (lowered_generics, res)\n@@ -1380,7 +1377,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_opaque_impl_trait(\n         &mut self,\n         span: Span,\n-        fn_def_id: Option<DefId>,\n+        fn_def_id: Option<LocalDefId>,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n         capturable_lifetimes: Option<&FxHashSet<hir::LifetimeName>>,\n@@ -1452,7 +1449,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     span: lctx.lower_span(span),\n                 },\n                 bounds: hir_bounds,\n-                impl_trait_fn: fn_def_id,\n                 origin,\n             };\n \n@@ -1522,7 +1518,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n-        mut in_band_ty_params: Option<(DefId, &mut Vec<hir::GenericParam<'hir>>)>,\n+        mut in_band_ty_params: Option<(LocalDefId, &mut Vec<hir::GenericParam<'hir>>)>,\n         impl_trait_return_allow: bool,\n         make_ret_async: Option<NodeId>,\n     ) -> &'hir hir::FnDecl<'hir> {\n@@ -1580,7 +1576,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         Some((def_id, _)) if impl_trait_return_allow => {\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n                                 fn_def_id: def_id,\n-                                origin: hir::OpaqueTyOrigin::FnReturn,\n+                                origin: hir::OpaqueTyOrigin::FnReturn(def_id),\n                             }\n                         }\n                         _ => ImplTraitContext::disallowed(),\n@@ -1635,7 +1631,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_async_fn_ret_ty(\n         &mut self,\n         output: &FnRetTy,\n-        fn_def_id: DefId,\n+        fn_def_id: LocalDefId,\n         opaque_ty_node_id: NodeId,\n     ) -> hir::FnRetTy<'hir> {\n         debug!(\n@@ -1689,18 +1685,29 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // this is because the elided lifetimes from the return type\n         // should be figured out using the ordinary elision rules, and\n         // this desugaring achieves that.\n+\n+        debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", self.in_scope_lifetimes);\n+        debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", self.lifetimes_to_define);\n+\n+        // Calculate all the lifetimes that should be captured\n+        // by the opaque type. This should include all in-scope\n+        // lifetime parameters, including those defined in-band.\n         //\n-        // The variable `input_lifetimes_count` tracks the number of\n-        // lifetime parameters to the opaque type *not counting* those\n-        // lifetimes elided in the return type. This includes those\n-        // that are explicitly declared (`in_scope_lifetimes`) and\n-        // those elided lifetimes we found in the arguments (current\n-        // content of `lifetimes_to_define`). Next, we will process\n-        // the return type, which will cause `lifetimes_to_define` to\n-        // grow.\n-        let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n-\n-        let mut lifetime_params = Vec::new();\n+        // `lifetime_params` is a vector of tuple (span, parameter name, lifetime name).\n+\n+        // Input lifetime like `'a` or `'1`:\n+        let mut lifetime_params: Vec<_> = self\n+            .in_scope_lifetimes\n+            .iter()\n+            .cloned()\n+            .map(|name| (name.ident().span, name, hir::LifetimeName::Param(name)))\n+            .chain(\n+                self.lifetimes_to_define\n+                    .iter()\n+                    .map(|&(span, name)| (span, name, hir::LifetimeName::Param(name))),\n+            )\n+            .collect();\n+\n         self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n@@ -1710,34 +1717,26 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             //\n             // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n             // hence the elision takes place at the fn site.\n-            let future_bound = this\n-                .with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n-                    this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n+            let (lifetimes_to_define, future_bound) =\n+                this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n+                    this.collect_in_band_defs(|this| {\n+                        this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n+                    })\n                 });\n-\n             debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n+            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", lifetimes_to_define);\n \n-            // Calculate all the lifetimes that should be captured\n-            // by the opaque type. This should include all in-scope\n-            // lifetime parameters, including those defined in-band.\n-            //\n-            // Note: this must be done after lowering the output type,\n-            // as the output type may introduce new in-band lifetimes.\n-            lifetime_params = this\n-                .in_scope_lifetimes\n-                .iter()\n-                .cloned()\n-                .map(|name| (name.ident().span, name))\n-                .chain(this.lifetimes_to_define.iter().cloned())\n-                .collect();\n-\n-            debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", this.in_scope_lifetimes);\n-            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n+            lifetime_params.extend(\n+                // Output lifetime like `'_`:\n+                lifetimes_to_define\n+                    .into_iter()\n+                    .map(|(span, name)| (span, name, hir::LifetimeName::Implicit(false))),\n+            );\n             debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n \n             let generic_params =\n-                this.arena.alloc_from_iter(lifetime_params.iter().map(|(span, hir_name)| {\n-                    this.lifetime_to_generic_param(*span, *hir_name, opaque_ty_def_id)\n+                this.arena.alloc_from_iter(lifetime_params.iter().map(|&(span, hir_name, _)| {\n+                    this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_id)\n                 }));\n \n             let opaque_ty_item = hir::OpaqueTy {\n@@ -1747,8 +1746,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     span: this.lower_span(span),\n                 },\n                 bounds: arena_vec![this; future_bound],\n-                impl_trait_fn: Some(fn_def_id),\n-                origin: hir::OpaqueTyOrigin::AsyncFn,\n+                origin: hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n             };\n \n             trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n@@ -1771,25 +1769,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //\n         // For the \"output\" lifetime parameters, we just want to\n         // generate `'_`.\n-        let mut generic_args = Vec::with_capacity(lifetime_params.len());\n-        generic_args.extend(lifetime_params[..input_lifetimes_count].iter().map(\n-            |&(span, hir_name)| {\n-                // Input lifetime like `'a` or `'1`:\n+        let generic_args =\n+            self.arena.alloc_from_iter(lifetime_params.into_iter().map(|(span, _, name)| {\n                 GenericArg::Lifetime(hir::Lifetime {\n                     hir_id: self.next_id(),\n                     span: self.lower_span(span),\n-                    name: hir::LifetimeName::Param(hir_name),\n+                    name,\n                 })\n-            },\n-        ));\n-        generic_args.extend(lifetime_params[input_lifetimes_count..].iter().map(|&(span, _)|\n-            // Output lifetime like `'_`.\n-            GenericArg::Lifetime(hir::Lifetime {\n-                hir_id: self.next_id(),\n-                span: self.lower_span(span),\n-                name: hir::LifetimeName::Implicit(false),\n-            })));\n-        let generic_args = self.arena.alloc_from_iter(generic_args);\n+            }));\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n@@ -1805,7 +1792,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_async_fn_output_type_to_future_bound(\n         &mut self,\n         output: &FnRetTy,\n-        fn_def_id: DefId,\n+        fn_def_id: LocalDefId,\n         span: Span,\n     ) -> hir::GenericBound<'hir> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n@@ -1816,7 +1803,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // generates.\n                 let context = ImplTraitContext::ReturnPositionOpaqueTy {\n                     fn_def_id,\n-                    origin: hir::OpaqueTyOrigin::FnReturn,\n+                    origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                 };\n                 self.lower_ty(ty, context)\n             }\n@@ -2453,17 +2440,12 @@ impl<'hir> GenericArgsCtor<'hir> {\n     }\n }\n \n+#[tracing::instrument(level = \"debug\")]\n fn lifetimes_from_impl_trait_bounds(\n     opaque_ty_id: NodeId,\n     bounds: hir::GenericBounds<'_>,\n     lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n ) -> Vec<(hir::LifetimeName, Span)> {\n-    debug!(\n-        \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n-             bounds={:#?})\",\n-        opaque_ty_id, bounds,\n-    );\n-\n     // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n     // appear in the bounds, excluding lifetimes that are created within the bounds.\n     // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`."}, {"sha": "76b3be7976c61e9b8def72466f0d6a39f95f8cfb", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -173,7 +173,7 @@ fn check_opaque_type_parameter_valid(\n         // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n         //\n         // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn | OpaqueTyOrigin::AsyncFn => return true,\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n         // Check these\n         OpaqueTyOrigin::TyAlias => {}\n     }"}, {"sha": "d393ea6893849b953f49be38c509656d6cc7a457", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -2248,17 +2248,16 @@ pub struct BareFnTy<'hir> {\n pub struct OpaqueTy<'hir> {\n     pub generics: Generics<'hir>,\n     pub bounds: GenericBounds<'hir>,\n-    pub impl_trait_fn: Option<DefId>,\n     pub origin: OpaqueTyOrigin,\n }\n \n /// From whence the opaque type came.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n     /// `-> impl Trait`\n-    FnReturn,\n+    FnReturn(LocalDefId),\n     /// `async fn`\n-    AsyncFn,\n+    AsyncFn(LocalDefId),\n     /// type aliases: `type Foo = impl Trait;`\n     TyAlias,\n }\n@@ -2809,7 +2808,9 @@ impl ItemKind<'_> {\n         Some(match *self {\n             ItemKind::Fn(_, ref generics, _)\n             | ItemKind::TyAlias(_, ref generics)\n-            | ItemKind::OpaqueTy(OpaqueTy { ref generics, impl_trait_fn: None, .. })\n+            | ItemKind::OpaqueTy(OpaqueTy {\n+                ref generics, origin: OpaqueTyOrigin::TyAlias, ..\n+            })\n             | ItemKind::Enum(_, ref generics)\n             | ItemKind::Struct(_, ref generics)\n             | ItemKind::Union(_, ref generics)"}, {"sha": "04eceecc5f072a6e4faf48fdde71178f03a78a52", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                         kind:\n                             hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                 bounds,\n-                                origin: hir::OpaqueTyOrigin::AsyncFn,\n+                                origin: hir::OpaqueTyOrigin::AsyncFn(..),\n                                 ..\n                             }),\n                         .."}, {"sha": "c2ef0b41e27bf182761eef46e02d64d33f6b86d9", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(?concrete_ty);\n \n         let first_own_region = match opaque_defn.origin {\n-            hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n+            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {\n                 // We lower\n                 //\n                 // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n@@ -461,35 +461,29 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     if let Some(def_id) = def_id.as_local() {\n                         let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                         let parent_def_id = self.infcx.defining_use_anchor;\n-                        let (in_definition_scope, origin) = match tcx.hir().expect_item(def_id).kind\n-                        {\n+                        let item_kind = &tcx.hir().expect_item(def_id).kind;\n+                        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n+                            span_bug!(\n+                                self.value_span,\n+                                \"weird opaque type: {:#?}, {:#?}\",\n+                                ty.kind(),\n+                                item_kind\n+                            )\n+                        };\n+                        let in_definition_scope = match *origin {\n+                            // Async `impl Trait`\n+                            hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n                             // Anonymous `impl Trait`\n-                            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                impl_trait_fn: Some(parent),\n-                                origin,\n-                                ..\n-                            }) => (parent == parent_def_id.to_def_id(), origin),\n+                            hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n                             // Named `type Foo = impl Bar;`\n-                            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                impl_trait_fn: None,\n-                                origin,\n-                                ..\n-                            }) => {\n-                                (may_define_opaque_type(tcx, parent_def_id, opaque_hir_id), origin)\n-                            }\n-                            ref itemkind => {\n-                                span_bug!(\n-                                    self.value_span,\n-                                    \"weird opaque type: {:#?}, {:#?}\",\n-                                    ty.kind(),\n-                                    itemkind\n-                                )\n+                            hir::OpaqueTyOrigin::TyAlias => {\n+                                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n                             }\n                         };\n                         if in_definition_scope {\n                             let opaque_type_key =\n                                 OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n+                            return self.fold_opaque_ty(ty, opaque_type_key, *origin);\n                         }\n \n                         debug!("}, {"sha": "fd1409949f0a707ef225525cc481565796ae045a", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -2055,13 +2055,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-/// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n-pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    if let Some(def_id) = def_id.as_local() {\n-        if let Node::Item(item) = tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n-            if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n-                return opaque_ty.impl_trait_fn;\n-            }\n+/// Yields the parent function's `LocalDefId` if `def_id` is an `impl Trait` definition.\n+pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<LocalDefId> {\n+    let def_id = def_id.as_local()?;\n+    if let Node::Item(item) = tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n+        if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n+            return match opaque_ty.origin {\n+                hir::OpaqueTyOrigin::FnReturn(parent) | hir::OpaqueTyOrigin::AsyncFn(parent) => {\n+                    Some(parent)\n+                }\n+                hir::OpaqueTyOrigin::TyAlias => None,\n+            };\n         }\n     }\n     None"}, {"sha": "c94c56df75b7821a435fbe3150cee9bc9f7f65be", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -968,7 +968,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let (generics, bounds) = match opaque_ty.kind {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n                     // This arm is for `impl Trait` in the types of statics, constants and locals.\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: None, .. }) => {\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                        origin: hir::OpaqueTyOrigin::TyAlias,\n+                        ..\n+                    }) => {\n                         intravisit::walk_ty(self, ty);\n \n                         // Elided lifetimes are not allowed in non-return\n@@ -985,7 +988,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                     // RPIT (return position impl trait)\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                        impl_trait_fn: Some(_),\n+                        origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n                         ref generics,\n                         bounds,\n                         ..\n@@ -1695,7 +1698,11 @@ fn compute_object_lifetime_defaults(\n         hir::ItemKind::Struct(_, ref generics)\n         | hir::ItemKind::Union(_, ref generics)\n         | hir::ItemKind::Enum(_, ref generics)\n-        | hir::ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, impl_trait_fn: None, .. })\n+        | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+            ref generics,\n+            origin: hir::OpaqueTyOrigin::TyAlias,\n+            ..\n+        })\n         | hir::ItemKind::TyAlias(_, ref generics)\n         | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n             let result = object_lifetime_defaults_for_item(tcx, generics);\n@@ -2067,7 +2074,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     ..\n                                 }) = self.tcx.hir().get(parent_hir_id)\n                                 {\n-                                    if opaque.origin != hir::OpaqueTyOrigin::AsyncFn {\n+                                    if !matches!(opaque.origin, hir::OpaqueTyOrigin::AsyncFn(..)) {\n                                         continue 'lifetimes;\n                                     }\n                                     // We want to do this only if the liftime identifier is already defined"}, {"sha": "74a015d4c348e68445df79ee8e236f017679dfe8", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -248,7 +248,7 @@ fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // The param_env of an impl Trait type is its defining function's param_env\n     if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n-        return param_env(tcx, parent);\n+        return param_env(tcx, parent.to_def_id());\n     }\n     // Compute the bounds on Self and the type parameters.\n \n@@ -313,7 +313,7 @@ fn well_formed_types_in_env<'tcx>(\n \n     // The environment of an impl Trait type is its defining function's environment.\n     if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n-        return well_formed_types_in_env(tcx, parent);\n+        return well_formed_types_in_env(tcx, parent.to_def_id());\n     }\n \n     // Compute the bounds on `Self` and the type parameters."}, {"sha": "dc52c49499a5805c76ddf2871de0223501ae269a", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -2336,9 +2336,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let def_id = item_id.def_id.to_def_id();\n \n                 match opaque_ty.kind {\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n-                        self.impl_trait_ty_to_ty(def_id, lifetimes, impl_trait_fn.is_some())\n-                    }\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => self\n+                        .impl_trait_ty_to_ty(\n+                            def_id,\n+                            lifetimes,\n+                            matches!(\n+                                origin,\n+                                hir::OpaqueTyOrigin::FnReturn(..)\n+                                    | hir::OpaqueTyOrigin::AsyncFn(..)\n+                            ),\n+                        ),\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 }\n             }"}, {"sha": "a6b16e7f0d4d8128811e0742c3cffcbe0439c108", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -541,7 +541,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n     }\n \n     if let ItemKind::OpaqueTy(hir::OpaqueTy {\n-        origin: hir::OpaqueTyOrigin::AsyncFn | hir::OpaqueTyOrigin::FnReturn,\n+        origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n         ..\n     }) = item.kind\n     {\n@@ -567,7 +567,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n             visitor.visit_item(&item);\n             let is_async = match item.kind {\n                 ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n-                    matches!(origin, hir::OpaqueTyOrigin::AsyncFn)\n+                    matches!(origin, hir::OpaqueTyOrigin::AsyncFn(..))\n                 }\n                 _ => unreachable!(),\n             };\n@@ -604,7 +604,7 @@ pub(super) fn check_opaque_for_cycles<'tcx>(\n ) -> Result<(), ErrorReported> {\n     if tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs).is_err() {\n         match origin {\n-            hir::OpaqueTyOrigin::AsyncFn => async_opaque_type_cycle_error(tcx, span),\n+            hir::OpaqueTyOrigin::AsyncFn(..) => async_opaque_type_cycle_error(tcx, span),\n             _ => opaque_type_cycle_error(tcx, def_id, span),\n         }\n         Err(ErrorReported)\n@@ -635,7 +635,7 @@ fn check_opaque_meets_bounds<'tcx>(\n ) {\n     match origin {\n         // Checked when type checking the function containing them.\n-        hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => return,\n+        hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => return,\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {}\n     }"}, {"sha": "1334328f4e2ae111f9e3f76e1f238b0e4a6ab863", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -594,7 +594,11 @@ fn type_param_predicates(\n                 ItemKind::Fn(.., ref generics, _)\n                 | ItemKind::Impl(hir::Impl { ref generics, .. })\n                 | ItemKind::TyAlias(_, ref generics)\n-                | ItemKind::OpaqueTy(OpaqueTy { ref generics, impl_trait_fn: None, .. })\n+                | ItemKind::OpaqueTy(OpaqueTy {\n+                    ref generics,\n+                    origin: hir::OpaqueTyOrigin::TyAlias,\n+                    ..\n+                })\n                 | ItemKind::Enum(_, ref generics)\n                 | ItemKind::Struct(_, ref generics)\n                 | ItemKind::Union(_, ref generics) => generics,\n@@ -793,7 +797,10 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n         }\n \n         // Desugared from `impl Trait`, so visited by the function's return type.\n-        hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) => {}\n+        hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+            origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n+            ..\n+        }) => {}\n \n         // Don't call `type_of` on opaque types, since that depends on type\n         // checking function bodies. `check_item_type` ensures that it's called\n@@ -1488,15 +1495,18 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             Some(tcx.typeck_root_def_id(def_id))\n         }\n         Node::Item(item) => match item.kind {\n-            ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n-                impl_trait_fn.or_else(|| {\n-                    let parent_id = tcx.hir().get_parent_item(hir_id);\n-                    assert!(parent_id != hir_id && parent_id != CRATE_HIR_ID);\n-                    debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n-                    // Opaque types are always nested within another item, and\n-                    // inherit the generics of the item.\n-                    Some(tcx.hir().local_def_id(parent_id).to_def_id())\n-                })\n+            ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin:\n+                    hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n+                ..\n+            }) => Some(fn_def_id.to_def_id()),\n+            ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n+                let parent_id = tcx.hir().get_parent_item(hir_id);\n+                assert!(parent_id != hir_id && parent_id != CRATE_HIR_ID);\n+                debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n+                // Opaque types are always nested within another item, and\n+                // inherit the generics of the item.\n+                Some(tcx.hir().local_def_id(parent_id).to_def_id())\n             }\n             _ => None,\n         },\n@@ -2051,31 +2061,32 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     generics\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy {\n-                    bounds: _,\n-                    impl_trait_fn,\n+                    origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n+                    ..\n+                }) => {\n+                    // return-position impl trait\n+                    //\n+                    // We don't inherit predicates from the parent here:\n+                    // If we have, say `fn f<'a, T: 'a>() -> impl Sized {}`\n+                    // then the return type is `f::<'static, T>::{{opaque}}`.\n+                    //\n+                    // If we inherited the predicates of `f` then we would\n+                    // require that `T: 'static` to show that the return\n+                    // type is well-formed.\n+                    //\n+                    // The only way to have something with this opaque type\n+                    // is from the return type of the containing function,\n+                    // which will ensure that the function's predicates\n+                    // hold.\n+                    return ty::GenericPredicates { parent: None, predicates: &[] };\n+                }\n+                ItemKind::OpaqueTy(OpaqueTy {\n                     ref generics,\n-                    origin: _,\n+                    origin: hir::OpaqueTyOrigin::TyAlias,\n+                    ..\n                 }) => {\n-                    if impl_trait_fn.is_some() {\n-                        // return-position impl trait\n-                        //\n-                        // We don't inherit predicates from the parent here:\n-                        // If we have, say `fn f<'a, T: 'a>() -> impl Sized {}`\n-                        // then the return type is `f::<'static, T>::{{opaque}}`.\n-                        //\n-                        // If we inherited the predicates of `f` then we would\n-                        // require that `T: 'static` to show that the return\n-                        // type is well-formed.\n-                        //\n-                        // The only way to have something with this opaque type\n-                        // is from the return type of the containing function,\n-                        // which will ensure that the function's predicates\n-                        // hold.\n-                        return ty::GenericPredicates { parent: None, predicates: &[] };\n-                    } else {\n-                        // type-alias impl trait\n-                        generics\n-                    }\n+                    // type-alias impl trait\n+                    generics\n                 }\n \n                 _ => NO_GENERICS,"}, {"sha": "af199ca99460f292a1236e55966669ba6859e70c", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -394,13 +394,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                     tcx.mk_adt(def, substs)\n                 }\n-                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {\n+                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n                     find_opaque_ty_constraints(tcx, def_id)\n                 }\n                 // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), .. }) => {\n+                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::FnReturn(owner) | hir::OpaqueTyOrigin::AsyncFn(owner), .. }) => {\n                     let concrete_ty = tcx\n-                        .mir_borrowck(owner.expect_local())\n+                        .mir_borrowck(owner)\n                         .concrete_opaque_types\n                         .get_value_matching(|(key, _)| key.def_id == def_id.to_def_id())\n                         .copied()\n@@ -413,7 +413,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 ),\n                             );\n                             if let Some(ErrorReported) =\n-                                tcx.typeck(owner.expect_local()).tainted_by_errors\n+                                tcx.typeck(owner).tainted_by_errors\n                             {\n                                 // Some error in the\n                                 // owner fn prevented us from populating"}, {"sha": "90ab0c01f5450f086ad569fdb911eecaf721284c", "filename": "src/test/ui/async-await/generics-and-bounds.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7083f8edfd24b1c7f2c6375badd5cc16359c84fe/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs?ref=7083f8edfd24b1c7f2c6375badd5cc16359c84fe", "patch": "@@ -2,6 +2,8 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n+#![feature(in_band_lifetimes)]\n+\n use std::future::Future;\n \n pub async fn simple_generic<T>() {}\n@@ -71,6 +73,10 @@ pub fn call_with_ref_block<'a>(f: &'a (impl Foo + 'a)) -> impl Future<Output = (\n     async move { f.foo() }\n }\n \n+pub fn call_with_ref_block_in_band(f: &'a (impl Foo + 'a)) -> impl Future<Output = ()> + 'a {\n+    async move { f.foo() }\n+}\n+\n pub fn async_block_with_same_generic_params_unifies() {\n     let mut a = call_generic_bound_block(FooType);\n     a = call_generic_bound_block(FooType);\n@@ -85,4 +91,9 @@ pub fn async_block_with_same_generic_params_unifies() {\n     let f_two = FooType;\n     let mut d = call_with_ref_block(&f_one);\n     d = call_with_ref_block(&f_two);\n+\n+    let f_one = FooType;\n+    let f_two = FooType;\n+    let mut d = call_with_ref_block_in_band(&f_one);\n+    d = call_with_ref_block_in_band(&f_two);\n }"}]}